moveto & rmoveto operators.
 *
 * TITLE:       moveto_process
 *
 * CALL:        moveto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type (MOVETO, RMOVETO)
 *
 * INTERFACE:   op_moveto, op_rmoveto
 *
 * CALLS:       transform, moveto
 ************************************************************************/
static void near moveto_process(opr_type)
fix     opr_type;
{
        real32  x, y, px, py;
        struct coord FAR *p;
        struct object_def FAR *obj_x, FAR *obj_y;

        if(opr_type == RMOVETO ){
                /* check nocurrentpoint error */
                if(F2L(GSptr->position.x) == NOCURPNT){
                        ERROR(NOCURRENTPOINT);
                        return;
                }
        }

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_y = GET_OPERAND(0);
        obj_x = GET_OPERAND(1);

        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */

        /* Transform coordinates and set up MOVETO node */
        p = transform(F2L(x), F2L(y));

        if(opr_type == MOVETO){
                /* process op_moveto */
                moveto(F2L(p->x), F2L(p->y));
        }
        else{
                /* opr_type == RMOVETO, process op_rmoveto */
                px = p->x - GSptr->ctm[4] + GSptr->position.x;
                py = p->y - GSptr->ctm[5] + GSptr->position.y;
                moveto(F2L(px), F2L(py));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(2);

}


/************************************************************************
 * This module is to implement moveto operator.
 * Syntax :        x y   moveto   -
 *
 * TITLE:       op_moveto
 *
 * CALL:        op_moveto()
 *
 * INTERFACE:   interpreter(op_moveto)
 *
 * CALLS:       moveto_process
 ************************************************************************/
fix
op_moveto()
{
        moveto_process(MOVETO);
        return(0);
}


/************************************************************************
 * This module is to implement rmoveto operator.
 * Syntax :        dx dy   rmoveto   -
 *
 * TITLE:       op_rmoveto
 *
 * CALL:        op_rmoveto()
 *
 * INTERFACE:   interpreter(op_rmoveto)
 *
 * CALLS:       moveto_process
 ************************************************************************/
fix
op_rmoveto()
{
        moveto_process(RMOVETO);
        return(0);

}


/************************************************************************
 * This module is to process lineto & rlineto operators.
 *
 * TITLE:       lineto_process
 *
 * CALL:        lineto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type (LINETO, RLINETO)
 *
 * INTERFACE:   op_lineto, op_rlineto
 *
 * CALLS:       transform, lineto
 ************************************************************************/
static void near lineto_process(opr_type)
fix     opr_type;
{
        real32  x, y, px, py;
        struct coord FAR *p;
        struct object_def FAR *obj_x, FAR *obj_y;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return;
        }

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_y = GET_OPERAND(0);
        obj_x = GET_OPERAND(1);

        /* Transform coordinates and set up MOVETO node */
        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */

        p = transform(F2L(x), F2L(y));

        if(opr_type == LINETO){
                /* process op_lineto */
                lineto(F2L(p->x), F2L(p->y));
        }
        else{
                /* opr_type == RLINETO,  process op_rlineto */
                px = p->x - GSptr->ctm[4] + GSptr->position.x;
                py = p->y - GSptr->ctm[5] + GSptr->position.y;
                lineto(F2L(px), F2L(py));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(2);

}


/************************************************************************
 * This module is to implement lineto operator.
 * Syntax :        x y   lineto   -
 *
 * TITLE:       op_lineto
 *
 * CALL:        op_lineto()
 *
 * INTERFACE:   interpreter(op_lineto)
 *
 * CALLS:       lineto_process
 ************************************************************************/
fix
op_lineto()
{
        lineto_process(LINETO);
        return(0);

}

/************************************************************************
 * This module is to implement rlineto operator.
 * Syntax :        dx dy   rlineto   -
 *
 * TITLE:       op_rlineto
 *
 * CALL:        op_rlineto()
 *
 * INTERFACE:   interpreter(op_rlineto)
 *
 * CALLS:       lineto_process
 ************************************************************************/
fix
op_rlineto()
{
        lineto_process(RLINETO);
        return(0);
}


/************************************************************************
 * This module is to process arc & arcn operators.
 *
 * TITLE:       arc_process
 *
 * CALL:        arc_process(direction)
 *
 * PARAMETER:   direction : CLKWISE, CNTCLK
 *
 * INTERFACE:   op_arc, op_arcn
 *
 * CALLS:       transform, arc, moveto, lineto
 ************************************************************************/
static void near arc_process(direction)
fix     direction;
{
        VX_IDX node;
        real32  x, y, r, ang1, ang2, lx, ly;
        struct coord FAR *p;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct object_def FAR *obj_x, FAR *obj_y, FAR *obj_r, FAR *obj_ang1, FAR *obj_ang2;

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_ang2 = GET_OPERAND(0);
        obj_ang1 = GET_OPERAND(1);
        obj_r = GET_OPERAND(2);
        obj_y = GET_OPERAND(3);
        obj_x = GET_OPERAND(4);

        GET_OBJ_VALUE(x, obj_x);        /* x = get_obj_value(obj_x); */
        GET_OBJ_VALUE(y, obj_y);        /* y = get_obj_value(obj_y); */
        GET_OBJ_VALUE(r, obj_r);        /* r = get_obj_value(obj_r); */
        GET_OBJ_VALUE(ang1, obj_ang1);  /* ang1 = get_obj_value(obj_ang1); */
        GET_OBJ_VALUE(ang2, obj_ang2);  /* ang2 = get_obj_value(obj_ang2); */

        /* Pre_draw a line if current point exist;
         *  Otherwise, create a MOVETO node
         */

        lx = x+r*(real32)cos(ang1*PI/(real32)180.0);
        ly = y+r*(real32)sin(ang1*PI/(real32)180.0);
        p = transform(F2L(lx), F2L(ly));

        if(F2L(GSptr->position.x) != NOCURPNT)
                lineto(F2L(p->x), F2L(p->y));
        else
                moveto(F2L(p->x), F2L(p->y));

        /* degenerated case handling */
        /* if (F2L(r) == F2L(zero_f)) {    3/20/91; scchen */
        if (IS_ZERO(r)) {
                POP(5);                 /* @ARC_POP */
                return;
        }

        /* Convert arc to some curvetoes */
        vlist = arc(direction,F2L(x),F2L(y),F2L(r),F2L(ang1),F2L(ang2));

        if( ANY_ERROR() == LIMITCHECK ){
                return;                         /* @REM_STK */
        }

        /* append approximated arc into current path */
        /* if (vlist->head != NULLP) { @NODE */
        if (vlist != NULLP) {
            VX_IDX  ivtx;
            struct nd_hdr FAR *vtx;

            sp = &node_table[path_table[GSptr->path].tail];
                    /* pointer to current subpath */
            node = sp->SP_TAIL;
            /* @NODE
             * node_table[node].next = vlist->head;
             * sp->SP_TAIL = vlist->tail;
             */
            node_table[node].next = vlist;
            sp->SP_TAIL = node_table[vlist].SP_TAIL;

            /* set sp_flag @SP_FLG 1/8/88 */
            sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
            if (!(sp->SP_FLAG & SP_OUTPAGE)) {               /* 12/02/88 */
                /* for (ivtx = vlist->head; ivtx!=NULLP; @NODE */
                for (ivtx = vlist; ivtx!=NULLP; /* check OUTPAGE flag */
                     ivtx = vtx->next) {
                    vtx = &node_table[ivtx];
                    /* set sp_flag @SP_FLG */
                    if (out_page(F2L(vtx->VERTEX_X)) ||        /* @OUT_PAGE */
                        out_page(F2L(vtx->VERTEX_Y))) {
                            sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                            break;                        /* 12/02/88 */
                    } /* if */
                } /* for */
            } /* if */
        } /* if */

        /* Update current position */
        ang2 = ang2 * PI /(real32)180.0;
        lx = x+r*(real32)cos(ang2);
        ly = y+r*(real32)sin(ang2);
        p = transform(F2L(lx), F2L(ly));
        GSptr->position.x = p->x;
        GSptr->position.y = p->y;

        POP(5);

}


/************************************************************************
 * This module is to implement arc operator.
 * Syntax :        x y r ang1 ang2   arc   -
 *
 * TITLE:       op_arc
 *
 * CALL:        op_arc()
 *
 * INTERFACE:   interpreter(op_arc)
 *
 * CALLS:       arc_process
 ************************************************************************/
fix
op_arc()
{
        arc_process(CNTCLK);
        return(0);
}


/************************************************************************
 * This module is to implement arcn operator.
 * Syntax :        x y r ang1 ang2   arcn   -
 *
 * TITLE:       op_arcn
 *
 * CALL:        op_arcn()
 *
 * INTERFACE:   interpreter(op_arcn)
 *
 * CALLS:       arc_process
 ************************************************************************/
fix
op_arcn()
{
        arc_process(CLKWISE);
        return(0);
}


/************************************************************************
 * This module is to implement arcto operator.
 * Syntax :        x1 y1 x2 y2 r   arcto   xt1 yt1 xt2 yt2
 *
 * TITLE:       op_arcto
 *
 * CALL:        op_arcto()
 *
 * INTERFACE:   interpreter(op_arcto)
 *
 * CALLS:       transform, arc, lineto
 ************************************************************************/
fix
op_arcto()
{
        VX_IDX node;
        ufix   direction;
        struct coord FAR *p=NULL;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct object_def FAR *obj_x1, FAR *obj_y1, FAR *obj_x2, FAR *obj_y2, FAR *obj_r;
        real32  cross, absr;
        real32  px0, py0, px1, py1;
        real32  dtx1, dty1, dtx2, dty2, delta;
        real32  dx, dy, dx2, dy2, dxy;
        real32  x0, y0, x1, y1, x2, y2, r;
        real32  rx0, ry0, ang1, ang2, xt1, yt1, xt2, yt2;
        union  four_byte  xt14, yt14, xt24, yt24;
        real32  tmpx, tmpy;     /* @FABS */
        real32  d, tmp;
        fix     NEG;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_r  = GET_OPERAND(0);
        obj_y2 = GET_OPERAND(1);
        obj_x2 = GET_OPERAND(2);
        obj_y1 = GET_OPERAND(3);
        obj_x1 = GET_OPERAND(4);

        /* Get values */
        GET_OBJ_VALUE(x1, obj_x1);      /* x1 = get_obj_value(obj_x1); */
        GET_OBJ_VALUE(y1, obj_y1);      /* y1 = get_obj_value(obj_y1); */
        GET_OBJ_VALUE(x2, obj_x2);      /* x2 = get_obj_value(obj_x2); */
        GET_OBJ_VALUE(y2, obj_y2);      /* y2 = get_obj_value(obj_y2); */
        GET_OBJ_VALUE(r, obj_r);        /* r  = get_obj_value(obj_r);  */

        /* check undefinedresult error */
        tmpx = x1 - x2;
        tmpy = y1 - y2;
        FABS(tmpx, tmpx);
        FABS(tmpy, tmpy);
        if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        /* current point */
        p = inverse_transform(F2L(GSptr->position.x), F2L(GSptr->position.y));
		if (p == NULL) {
                ERROR(UNDEFINEDRESULT);
				return (0);
		}
        x0 = p->x;
        y0 = p->y;


        /* Calculate arguments for arc, and join points with 2 tangent lines
         * compute root of arc (rx0, ry0) */
                /* Find end point of edge 1 */
                p = endpoint (F2L(x1), F2L(y1), F2L(x0), F2L(y0),
                              F2L(x2), F2L(y2), F2L(r), IN_POINT);
                px0 = p->x;
                py0 = p->y;

                /* Find end point of edge 2 */
                p = endpoint(F2L(x1), F2L(y1), F2L(x2), F2L(y2),
                             F2L(x0), F2L(y0), F2L(r), IN_POINT);
                px1 = p->x;
                py1 = p->y;

                /* compute root of arc (rx0, ry0) */
                tmpx = px0 - px1;
                tmpy = py0 - py1;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                        rx0 = px0;
                        ry0 = py0;
                }
                else{
                        dtx1 = x1 - px0;
                        dty1 = y1 - py0;
                        dtx2 = x1 - px1;
                        dty2 = y1 - py1;
                        delta = (dtx2*dty1 - dtx1*dty2);
                        FABS(tmpx, delta);
                        if( tmpx < (real32)5e-3 ){                /* ??? */
                            rx0 = x1;
                            ry0 = y1;
                        }else {
                            rx0 = (dty1*dty2*(py1-py0) + px1*dtx2*dty1 -
                                  px0*dtx1*dty2) / delta;
                            ry0 = (dtx1*dtx2*(px1-px0) + py1*dtx1*dty2 -
                                  py0*dtx2*dty1) / (- delta);
                        }
                }


        /* Compute join points (xt1, yt1), (xt2, yt2) */
                dx = x1 - x0;
                dy = y1 - y0;
                FABS (tmpx, dx);
                FABS (tmpy, dy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                     xt1 = x0;
                     yt1 = y0;
                }
                else{
                     if(tmpx < (real32)1e-4)dx = zero_f;
                     if(tmpy < (real32)1e-4)dy = zero_f;
                     dxy = dx * dy;
                     dx2 = dx * dx;
                     dy2 = dy * dy;
                     xt1 = (x0*dy2 + rx0 *dx2 - (y0-ry0) * dxy) / (dx2 + dy2);
                     yt1 = (y0*dx2 + ry0 *dy2 - (x0-rx0) * dxy) / (dx2 + dy2);
                }

                dx = x1 - x2;
                dy = y1 - y2;
                FABS (tmpx, dx);
                FABS (tmpy, dy);
                if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)){
                     xt2 = x1;
                     yt2 = y1;
                }
                else{
                     if(tmpx < (real32)1e-4)dx = zero_f;
                     if(tmpy < (real32)1e-4)dy = zero_f;
                     dxy = dx * dy;
                     dx2 = dx * dx;
                     dy2 = dy * dy;
                     xt2 = (x2*dy2 + rx0 *dx2 - (y2-ry0) * dxy) / (dx2 + dy2);
                     yt2 = (y2*dx2 + ry0 *dy2 - (x2-rx0) * dxy) / (dx2 + dy2);
                }

                tmpx = rx0 - xt1;
                tmpy = ry0 - yt1;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if(tmpx < (real32)1e-4) {
                        if(yt1 > ry0) ang1 = (real32)( PI / 2.);
                        else          ang1 = (real32)(-PI / 2.);
                } else if (tmpy < (real32)1e-4) {
                        if(xt1 < rx0) ang1 = (real32) PI;
                        else          ang1 = zero_f;
                } else
                        ang1 = (real32)atan2((yt1-ry0) , (xt1-rx0));

                tmpx = rx0 - xt2;
                tmpy = ry0 - yt2;
                FABS(tmpx, tmpx);
                FABS(tmpy, tmpy);
                if(tmpx < (real32)1e-4) {
                        if(yt2 > ry0) ang2 =  (real32)( PI / 2.0);
                        else          ang2 =  (real32)(-PI / 2.);
                } else if (tmpy < (real32)1e-4) {
                        if(xt2 < rx0) ang2 =  (real32)PI;
                        else          ang2 =  zero_f;
                } else
                        ang2 = (real32)atan2((yt2-ry0) , (xt2 - rx0));

        /* calculate cross product of edge1 and edge2
         * (rx0, ry0), (xt1, yt1)  cross (xt1, yt1), (xt2, yt2)
         * i.e. (xt1-rx0, yt1-ry0) cross (xt2-xt1, yt2-yt1)
         */
//      cross = (xt1-rx0)*DIFF(yt2-yt1) - (yt1-ry0)*DIFF(xt2-xt1);
        tmpx = xt2-xt1;                 // @WIN: fabs => FABS
        tmpy = yt2-yt1;
        FABS(tmpx, tmpx);
        FABS(tmpy, tmpy);
        cross = (xt1-rx0)* (tmpy < (real32)1e-4 ? (real32)0.0 : (yt2-yt1)) -
                (yt1-ry0)* (tmpx < (real32)1e-4 ? (real32)0.0 : (xt2-xt1));

        /* Create a preceeding edge and an arc */
        p = transform(F2L(xt1), F2L(yt1));
        lineto(F2L(p->x), F2L(p->y));

        /* (xt1, yt1) and (xt2, yt2) isn't co_point */
        FABS(tmpx, cross);
        if(tmpx > (real32)TOLERANCE){
            /*direction = (cross < zero_f) ? CLKWISE : CNTCLK ; 3/20/91; scchen*/
            direction = (SIGN_F(cross)) ? CLKWISE : CNTCLK ;

            ang1 = ang1 * (real32)180.0 / PI;
            ang2 = ang2 * (real32)180.0 / PI;
            FABS(absr, r);

            /* create a bezier curve */
            if(direction == CLKWISE)
                    NEG = -1;
            else
                    NEG = 1;

            d = NEG * (ang2-ang1);
            /*while (d < zero_f) d += (real32)360; 3/20/91; scchen */
            while (SIGN_F(d)) d += (real32)360.0;

            /* degernated case */
            FABS(tmp, d);
            if (tmp >= (real32)1e-3){  /* 1e-4 => 1e-3;  12/14/88 */
                  ang2 = ang1 + NEG * d;
            }

            vlist = arc_to_bezier (F2L(rx0), F2L(ry0),
                       F2L(absr), F2L(ang1),F2L(ang2));
                    /* arc routine is under user's space */

            if( ANY_ERROR() == LIMITCHECK ){
                    return(0);                  /* @REM_STK */
            }

            /* append approximated arc into current path */
            /* if (vlist->head != NULLP) { @NODE */
            if (vlist != NULLP) {
                VX_IDX  ivtx;
                struct nd_hdr FAR *vtx;

                sp = &node_table[path_table[GSptr->path].tail];
                        /* pointer to current subpath */
                node = sp->SP_TAIL;
                /* @NODE
                 * node_table[node].next = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                node_table[node].next = vlist;
                sp->SP_TAIL = node_table[vlist].SP_TAIL;

                /* set sp_flag @SP_FLG 1/8/88 */
                sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
                /*sp->SP_FLAG &= ~SP_OUTPAGE;    (*init. in page*) */
                if (!(sp->SP_FLAG & SP_OUTPAGE)) {               /* 12/02/88 */
                    /* for (ivtx = vlist->head; ivtx!=NULLP; @NODE */
                    for (ivtx = vlist; ivtx!=NULLP; /* check OUTPAGE flag */
                         ivtx = vtx->next) {
                            vtx = &node_table[ivtx];
                            /* set sp_flag @SP_FLG */
                            if (out_page(F2L(vtx->VERTEX_X)) ||
                                out_page(F2L(vtx->VERTEX_Y))) {
                                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                                break;                /* 12/02/88 */
                            }
                    } /* for */
                } /* if */
            } /* if */

        }

        /* Update current position */
        p = transform(F2L(xt2), F2L(yt2));
        GSptr->position.x = p->x;
        GSptr->position.y = p->y;

        POP(5);

        /* Return 2 join points: xt1, yt1, xt2, yt2 */
        xt14.ff = xt1;
        yt14.ff = yt1;
        xt24.ff = xt2;
        yt24.ff = yt2;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xt14.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yt14.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, xt24.ll);
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, yt24.ll);

        return(0);
}


/***********************************************************************
 *
 * TITLE:       endpoint
 *
 * CALL:        endpoint (x0, y0, x1, t1, x2, y2)
 *
 * PARAMETERS:  x0, y0, x1, y1, x2, y2 -- 3 coordinates
 *
 * INTERFACE:   linejoin
 *
 * CALLS:
 *
 * RETURN:      coordinate of a endpoint
 **********************************************************************/
static struct coord * near endpoint (lx0, ly0, lx1, ly1, lx2, ly2, ld, select)
long32    lx0, ly0, lx1, ly1, lx2, ly2, ld;
ufix    select;
{
        real32   x0, y0, x1, y1, x2, y2, d;
        real32   tx1, ty1, tx2, ty2, m, c;
        static  struct  coord p;        /* should be static */
        real32   f, dx, dy;
        real32  tmpx, tmpy;     /* @FABS */

        x0 = L2F(lx0);
        y0 = L2F(ly0);
        x1 = L2F(lx1);
        y1 = L2F(ly1);
        x2 = L2F(lx2);
        y2 = L2F(ly2);
        d  = L2F(ld);

        /* Compute 2 endpoints of the edge (x0, y0) --> (x1, y1) */
        tmpy = y1 - y0;
        FABS(tmpy, tmpy);
        if(tmpy < (real32)1e-4) {
                tx1 = tx2 = x0;
                ty1 = y0 + d;
                ty2 = y0 - d;
        } else {
                m = (x0 - x1) / (y1 - y0);
                c = d * (real32)sqrt(1 / (1 + m*m));
                tx1 = x0 + c;
                ty1 = y0 + m*c;
                tx2 = x0 - c;
                ty2 = y0 - m*c;
        }

        /* select the desired endpoint */

        dx = x2 - x0;
        dy = y2 - y0;
        FABS(tmpx, dx);
        FABS(tmpy, dy);
        if((tmpx < (real32)1e-4) && (tmpy < (real32)1e-4)) {
             dx = one_f;
             dy = one_f;
        } else{
                if(tmpx < (real32)1e-4) dx = zero_f;
                if(tmpy < (real32)1e-4) dy = zero_f;
        }

        f = (tx1-x0)*dx+(ty1-y0)*dy;
        f = ((select == OUT_POINT) ? f : (real32)-1.0 * f);
        /* if (d < zero_f) f = -f; 3/20/91; scchen */
        if (SIGN_F(d)) f = -f;
        if (f <= zero_f) {
                p.x = tx1;
                p.y = ty1;
        } else {
                p.x = tx2;
                p.y = ty2;
        }

        return (&p);
}



/************************************************************************
 * This module is to process curveto & rcurve operators.
 *
 * TITLE:       curveto_process
 *
 * CALL:        curveto_process(opr_type)
 *
 * PARAMETER:   opr_type : operator type : CURVETO, RCURVETO
 *
 * INTERFACE:   op_curveto, op_rcurveto
 *
 * CALLS:       transform, curveto
 ************************************************************************/
static void near curveto_process(opr_type)
fix     opr_type;
{
        struct coord FAR *p;
        real32  dx1, dy1, dx2, dy2, dx3, dy3, x, y, temp_x, temp_y;
        struct object_def FAR *obj_x1, FAR *obj_y1, FAR *obj_x2, FAR *obj_y2, FAR *obj_x3, FAR *obj_y3;

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return;
        }

        /* Get input parameters from operand stack */

        /* Get operands */
        obj_y3 = GET_OPERAND(0);
        obj_x3 = GET_OPERAND(1);
        obj_y2 = GET_OPERAND(2);
        obj_x2 = GET_OPERAND(3);
        obj_y1 = GET_OPERAND(4);
        obj_x1 = GET_OPERAND(5);

        if(opr_type == CURVETO){
                /* process op_curveto */
                GET_OBJ_VALUE(x, obj_x3);       /* x = get_obj_value(obj_x3); */
                GET_OBJ_VALUE(y, obj_y3);       /* y = get_obj_value(obj_y3); */
                p = transform(F2L(x), F2L(y));
                dx3 = p->x;
                dy3 = p->y;
                GET_OBJ_VALUE(x, obj_x2);       /* x = get_obj_value(obj_x2); */
                GET_OBJ_VALUE(y, obj_y2);       /* y = get_obj_value(obj_y2); */
                p = transform(F2L(x), F2L(y));
                dx2 = p->x;
                dy2 = p->y;
                GET_OBJ_VALUE(x, obj_x1);       /* x = get_obj_value(obj_x1); */
                GET_OBJ_VALUE(y, obj_y1);       /* y = get_obj_value(obj_y1); */
                p = transform(F2L(x), F2L(y));
                dx1 = p->x;
                dy1 = p->y;
                curveto(F2L(dx1),F2L(dy1),F2L(dx2),F2L(dy2),F2L(dx3),F2L(dy3));
        }
        else{
                /* opr_type == RCURVETO, process op_rcurveto */

                temp_x = GSptr->position.x - GSptr->ctm[4];
                temp_y = GSptr->position.y - GSptr->ctm[5];

                GET_OBJ_VALUE(x, obj_x3);       /* x = get_obj_value(obj_x3); */
                GET_OBJ_VALUE(y, obj_y3);       /* y = get_obj_value(obj_y3); */
                p = transform(F2L(x), F2L(y));
                dx3 = p->x + temp_x;
                dy3 = p->y + temp_y;

                GET_OBJ_VALUE(x, obj_x2);       /* x = get_obj_value(obj_x2); */
                GET_OBJ_VALUE(y, obj_y2);       /* y = get_obj_value(obj_y2); */
                p = transform(F2L(x), F2L(y));
                dx2 = p->x + temp_x;
                dy2 = p->y + temp_y;

                GET_OBJ_VALUE(x, obj_x1);       /* x = get_obj_value(obj_x1); */
                GET_OBJ_VALUE(y, obj_y1);       /* y = get_obj_value(obj_y1); */
                p = transform(F2L(x), F2L(y));
                dx1 = p->x + temp_x;
                dy1 = p->y + temp_y;
                curveto(F2L(dx1),F2L(dy1),F2L(dx2),F2L(dy2),F2L(dx3),F2L(dy3));
        }

        if(ANY_ERROR()) return;      /* @REM_STK */

        POP(6);

}


/************************************************************************
 * This module is to implement curveto operator.
 * Syntax :        x1 y1 x2 y2 x3 y3   curveto   -
 *
 * TITLE:       op_curveto
 *
 * CALL:        op_curveto
 *
 * INTERFACE:   interpreter(op_curveto)
 *
 * CALLS:       curveto_process
 ************************************************************************/
fix
op_curveto()
{
        curveto_process(CURVETO);
        return(0);
}


/************************************************************************
 * This module is to implement rcurveto operator.
 * Syntax :        dx1 dy1 dx2 dy2 dx3 dy3   rcurveto   -
 *
 * TITLE:       op_rcurveto
 *
 * CALL:        op_rcurveto()
 *
 * INTERFACE:   interpreter(op_rcurveto)
 *
 * CALLS:       transform, curveto
 *
 ************************************************************************/
fix
op_rcurveto()
{
        curveto_process(RCURVETO);
        return(0);
}


/************************************************************************
 * This module is to implement closepath operator.
 * Syntax :        -   closepath   -
 *
 * TITLE:       op_closepath
 *
 * CALL:        op_closepath()
 *
 * INTERFACE:   interpreter(op_closepath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_closepath()
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;   /* index to node_table for vertex */

        /* Ignore closepath if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return(0);
                }
        }

        //DJC fix from history.log UPD020
        if (path->tail == NULLP) return(0);

        sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* Ignore ineffective closepath */
        if (vtx->VX_TYPE == CLOSEPATH) return(0);

        /* Create a CLOSEPATH node */
        /* Allocate a node */
        if((ivtx = get_node()) == NULLP){
                ERROR(LIMITCHECK);
                return(0);
        }
        vtx = &node_table[ivtx];

        /* Set up a CLOSEPATH node */
        vtx->VX_TYPE = CLOSEPATH;
        vtx->next = NULLP;

        /* Append this node to current_subpath */
        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        /* Set current position = head of current subpath */
        /* @NODE
         * vtx = &node_table[sp->SP_HEAD];
         * GSptr->position.x = vtx->VERTEX_X;
         * GSptr->position.y = vtx->VERTEX_Y;
         */
        GSptr->position.x = sp->VERTEX_X;
        GSptr->position.y = sp->VERTEX_Y;

        return(0);
}


/************************************************************************
 * This module is to implement flattenpath operator.
 * Syntax :        -   flattenpath   -
 *
 * TITLE:       op_flattenpath
 *
 * CALL:        op_flattenpath()
 *
 * INTERFACE:   interpreter(op_flattenpath)
 *
 * CALLS:       flatten_subpath
 *
 ************************************************************************/
fix
op_flattenpath()
{
        SP_IDX isp;    /* index to node_table for subpath */
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist=NULLP, FAR *pre_sp;            /* init.; scchen 2/22/91 */


        path = &path_table[GSptr->path];

        /* Traverse the current path, and immediately flatten the path
         * in current gsave level
         */
        pre_sp = &(path->head);         /* @NODE */
        /* for (isp = path->head; isp != NULLP; isp = sp->next) { @NODE */
        for (isp = path->head; isp != NULLP; isp = sp->SP_NEXT) {
                sp = &node_table[isp];
                /* @NODE
                 * vlist = flatten_subpath (sp->SP_HEAD, F2L(GSptr->flatness));
                 */
                vlist = flatten_subpath (isp, F2L(GSptr->flatness));

                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return(0);
                }
                /* @NODE
                 * free_node(sp->SP_HEAD);
                 * sp->SP_HEAD = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                free_node(isp);
                *pre_sp = vlist;

                /* clear CURVE flag of the new subpath @SP_FLG */
                /* sp->SP_FLAG &= ~SP_CURVE; @NODE */
                node_table[vlist].SP_FLAG &= ~SP_CURVE;

                pre_sp = &(node_table[vlist].SP_NEXT);  /* @NODE */
        }
        path->tail = vlist;             /* @NODE */

        /* Set flatten flag for path below current gsave level */
        if (!(path->rf & P_FLAT)) {
                path->rf |= P_FLAT;
                path->flat = GSptr->flatness;
        }

        return(0);
}


/************************************************************************
 * This module is to implement reversepath operator.
 * Syntax :        -   reversepath   -
 *
 * TITLE:       op_reversepath
 *
 * CALL:        op_reversepath()
 *
 * INTERFACE:   interpreter(op_reversepath)
 *
 * CALLS:       reverse_subpath
 ************************************************************************/
fix
op_reversepath()
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;
        struct nd_hdr FAR *vtx;
        SP_IDX isp, nsp;    /* index to node_table for subpath */
        /* struct vx_lst *vlist; @NODE */
        SP_IDX vlist, FAR *pre_sp;

        path = &path_table[GSptr->path];

        if (path->head == NULLP) return(0);     /* avoid to use uninitialized
                                                   vlist, phchen 3/26/91 */

        /* Traverse the current path, and immediately reverse the path
         * in current gsave level
         */
        pre_sp = &(path->head);         /* @NODE */
        /* for (isp = path->head; isp != NULLP; isp = sp->next) { @NODE */
        for (isp = path->head; isp != NULLP; isp = nsp) {  /* @NODE 2/20/90 */
                nsp = node_table[isp].SP_NEXT;          /* @NODE 2/20/90 */
                /* vlist = reverse_subpath (sp->SP_HEAD); @NODE */
                vlist = reverse_subpath (isp);

                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return(0);
                }

                /* @NODE
                 * free_node(sp->SP_HEAD);
                 * sp->SP_HEAD = vlist->head;
                 * sp->SP_TAIL = vlist->tail;
                 */
                free_node(isp);
                *pre_sp = vlist;

                /* pre_sp = &(sp->SP_NEXT);     @NODE */
                pre_sp = &(node_table[vlist].SP_NEXT);    /* @NODE 2/20/90 */
        }
        path->tail = vlist;             /* @NODE */

        /* update current position */
        sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        if (vtx->VX_TYPE == CLOSEPATH) {
                /* @NODE
                 * GSptr->position.x = node_table[sp->SP_HEAD].VERTEX_X;
                 * GSptr->position.y = node_table[sp->SP_HEAD].VERTEX_Y;
                 */
                GSptr->position.x = node_table[path->tail].VERTEX_X;
                GSptr->position.y = node_table[path->tail].VERTEX_Y;
        } else {
                GSptr->position.x = vtx->VERTEX_X;
                GSptr->position.y = vtx->VERTEX_Y;
        }

        /* Set reverse flag for path below current gsave level */
        if (!(path->rf & P_RVSE)) {
                path->rf ^= P_RVSE;
        }

        return(0);
}


/************************************************************************
 * This module is to implement strokepath operator.
 * Syntax :        -   strokepath   -
 *
 * TITLE:       op_strokepath
 *
 * CALL:        op_strokepath()
 *
 * INTERFACE:   interpreter(op_strokepath)
 *
 * CALLS:       traverse_path, path_to_outline
 *
 ************************************************************************/
fix
op_strokepath()
{

/* @WIN: Bug of c6.0; just dummy the all function ???*/
#ifdef XXX

        struct ph_hdr FAR *path;

        /* get pointer of current path */
        path = &path_table[GSptr->path];

        /* initialize new_path structure, where the new generated
         * path will be placed by path_to_outline routine
         */
        new_path.head = new_path.tail = NULLP;

        /* initialization of stroke parameters */
        init_stroke();          /* @EHS_STK 1/29/88 */

        /* Convert current path to outline and paint it */
        traverse_path (path_to_outline, (fix FAR *)FALSE);
                        /* new generated path in new_path structure */

        if( ANY_ERROR() == LIMITCHECK ){
                free_newpath();
                return(0);
        }

        /* free old current path on current gsave level */
        free_path();

        /* install the new current path */
        path->head = new_path.head;
        path->tail = new_path.tail;
        path->previous = NULLP;

        /* update current position 1/30/89 */
        if (path->tail == NULLP) {
            /* set no current point */
            F2L(GSptr->position.x) = F2L(GSptr->position.y) = NOCURPNT;
        } else {
            struct nd_hdr FAR *sp;
            struct nd_hdr FAR *vtx;

            sp = &node_table[path->tail];
//          vtx = &node_table[sp->SP_TAIL];   for c6.0 bug @WIN

            if (vtx->VX_TYPE == CLOSEPATH) {
                    /* @NODE
                     * GSptr->position.x = node_table[sp->SP_HEAD].VERTEX_X;
                     * GSptr->position.y = node_table[sp->SP_HEAD].VERTEX_Y;
                     */
                    GSptr->position.x = node_table[path->tail].VERTEX_X;
                    GSptr->position.y = node_table[path->tail].VERTEX_Y;
            } else {
                    GSptr->position.x = vtx->VERTEX_X;
                    GSptr->position.y = vtx->VERTEX_Y;
            }
        }

#endif
        return(0);
}


/************************************************************************
 * This module is to implement clippath operator.
 * Syntax :        -   clippath   -
 *
 * TITLE:       op_clippath
 *
 * CALL:        op_clippath()
 *
 * INTERFACE:   interpreter(op_clippath)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_clippath()
{
        struct nd_hdr FAR *tpzd;

        /* free current path */
        free_path();

        /* save clipping trapezoids in cp_path, instead of transforming
         * it to path directly. @CPPH; 12/4/90
         */

        /* set clip_path as part of current path @CPPH */
        path_table[GSptr->path].cp_path = GSptr->clip_path.head;

        /* update current position */
        tpzd = &node_table[GSptr->clip_path.tail];      /* @CPPH */
        GSptr->position.x = SFX2F(tpzd->CP_TOPXL);
        GSptr->position.y = SFX2F(tpzd->CP_TOPY);

        return(0);
}


/************************************************************************
 * This module is to implement pathbbox operator.
 * Syntax :        -   pathbbox   llx lly urx ury
 *
 * TITLE:       op_pathbbox
 *
 * CALL:        op_pathbbox()
 *
 * INTERFACE:   interpreter(op_pathbbox)
 *
 * CALLS:       inverse_transform
 ************************************************************************/
fix
op_pathbbox()
{
        real32    bbox[4];
        struct coord FAR *p;

        union    four_byte lx4, ly4, ux4, uy4;
        struct   ph_hdr FAR *path;
        struct   nd_hdr FAR *sp;
        struct   nd_hdr FAR *vtx;

        path = &path_table[GSptr->path];

        /* check nocurrentpoint error */
        if(F2L(GSptr->position.x) == NOCURPNT){
                ERROR(NOCURRENTPOINT);
                return(0);
        }

        /* set bbox[] init value 1/11/91 */
        if (path->rf & P_NACC) {
            /* for charpath, current point is not a real node, pathbbox
             * can not use it as init value(it added a advance vector).
             * to get the first MOVETO coordinate as initial value
             */
            while (path->head == NULLP) {
                    path = &path_table[path->previous];
            }
            sp = &node_table[path->head];
            vtx = sp;
            bbox[0] = bbox[2] = vtx->VERTEX_X;  /* min_x, max_x */
            bbox[1] = bbox[3] = vtx->VERTEX_Y;  /* min_y, max_y */
        } else {
            /* set current point as initial value @CPPH; 12/12/90 */
            bbox[0] = bbox[2] = GSptr->position.x;  /* min_x, max_x */
            bbox[1] = bbox[3] = GSptr->position.y;  /* min_y, max_y */
        }

        /* find bounding box of current path */
// DJC         traverse_path (bounding_box, (fix FAR *)bbox);
        traverse_path ((TRAVERSE_PATH_ARG1)(bounding_box), (fix FAR *)bbox);

        /* Transform to user's coordinate system */
        p = inverse_transform(F2L(bbox[0]), F2L(bbox[1]));  /* (min_x, min_y) */
        if(ANY_ERROR()) return(0);      /* @REM_STK */
        lx4.ff = ux4.ff = p->x;
        ly4.ff = uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[0]), F2L(bbox[3]));  /* (min_x, max_y) */
        if(ANY_ERROR()) return(0);      /* @REM_STK */
        if(p == NULL) return(0);      
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[2]), F2L(bbox[1]));  /* (max_x, min_y) */
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        p = inverse_transform(F2L(bbox[2]), F2L(bbox[3]));  /* (max_x, max_y) */
        if (p->x < lx4.ff) lx4.ff = p->x;
        else if (p->x > ux4.ff) ux4.ff = p->x;
        if (p->y < ly4.ff) ly4.ff = p->y;
        else if (p->y > uy4.ff) uy4.ff = p->y;

        /* Convert lx4, ly4, ux4, uy4 to objects, and push
         * them into operand stack.
         */
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, lx4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, ly4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, ux4.ll);
        if(FRCOUNT() < 1){                      /* @STK_OVR */
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, uy4.ll);

        return(0);
}


/************************************************************************
 * This module is to implement pathforall operator.
 * Syntax :        move line curve close   pathforall   -
 *
 * TITLE:       op_pathforall
 *
 * CALL:        op_pathforall()
 *
 * INTERFACE:   interpreter(op_pathforall)
 *
 * CALLS:       traverse_path, dump_subpath
 *
 ************************************************************************/
fix
op_pathforall()
{
        struct object_def objects[4];
        struct sp_lst sp_list;          /* @PFALL */
        SP_IDX isp;    /* index to node_table for subpath */

        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        COPY_OBJ(GET_OPERAND(3), &objects[0]);
        COPY_OBJ(GET_OPERAND(2), &objects[1]);
        COPY_OBJ(GET_OPERAND(1), &objects[2]);
        COPY_OBJ(GET_OPERAND(0), &objects[3]);

        /* reject dumpping noaccess path 1/25/88 */
        if (path_table[GSptr->path].rf & P_NACC) {
                ERROR(INVALIDACCESS);
                return(0);
        }

        /* pre-calculate inverse CTM  @INV_CTM */
        set_inverse_ctm();
        if( ANY_ERROR() == UNDEFINEDRESULT) return(0);

        POP(4);            /* @REM_STK */

        /* copy current path to a temp. path for dump */
        sp_list.head = sp_list.tail = NULLP;
        get_path(&sp_list);

        /* dump all nodes */
        /* @NODE
         * for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].next) {
         */
        for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].SP_NEXT) {
                dump_subpath (isp, objects);
        }

        /* free temp. path */
        /* @NODE
         * for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].next) {
         *         free_node (node_table[isp].SP_HEAD);
         * }
         * free_node (sp_list.head);
         */
        for (isp = sp_list.head; isp != NULLP; isp = node_table[isp].SP_NEXT) {
                free_node (isp);
        }

        return(0);
}


/************************************************************************
 * This module is to implement initclip operator.
 * Syntax :        -   initclip   -
 *
 * TITLE:       op_initclip
 *
 * CALL:        op_initclip()
 *
 * INTERFACE:   interpreter(op_initclip)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_initclip()
{
        CP_IDX itpzd;
        struct nd_hdr FAR *tpzd;

        /* free old clipping path if it is not used by lower gsave level
         * and not used by current path  @CPPH; 12/1/90
         */
        if(!GSptr->clip_path.inherit &&
           path_table[GSptr->path].cp_path != GSptr->clip_path.head) /* @CPPH */
                free_node (GSptr->clip_path.head);

        /* create a trapezoid with default clipping region */
        if((itpzd = get_node()) == NULLP){
                ERROR(LIMITCHECK);
                return(0);
        }

        tpzd = &node_table[itpzd];
        tpzd->CP_TOPY = GSptr->device.default_clip.ly;
        tpzd->CP_BTMY = GSptr->device.default_clip.uy;
        tpzd->CP_TOPXL = tpzd->CP_BTMXL = GSptr->device.default_clip.lx;
        tpzd->CP_TOPXR = tpzd->CP_BTMXR = GSptr->device.default_clip.ux;

        /* install the clipping path */
        GSptr->clip_path.head = GSptr->clip_path.tail = itpzd;
        GSptr->clip_path.inherit = FALSE;
        GSptr->clip_path.bb_ux = GSptr->device.default_clip.ux;
        GSptr->clip_path.bb_uy = GSptr->device.default_clip.uy;
        GSptr->clip_path.bb_lx = GSptr->device.default_clip.lx;
        GSptr->clip_path.bb_ly = GSptr->device.default_clip.ly;
        GSptr->clip_path.single_rect = TRUE;

        return(0);
}


/************************************************************************
 * This module is to implement clip operator.
 * Syntax :        -   clip   -
 *
 * TITLE:       op_clip
 *
 * CALL:        op_clip()
 *
 * INTERFACE:   interpreter(op_clip)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_clip()
{
        clip_process (NON_ZERO);
        return(0);
}


/************************************************************************
 * This module is to implement eoclip operator.
 * Syntax :        -   eoclip   -
 *
 * TITLE:       op_eoclip
 *
 * CALL:        op_eoclip()
 *
 * INTERFACE:   interpreter(op_eoclip)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_eoclip()
{
        clip_process (EVEN_ODD);
        return(0);
}




static void near clip_process(winding_type)
fix     winding_type;
{
        struct nd_hdr FAR *tpzd;

        /* initialize edge table 11/30/88 */
        init_edgetable();       /* in "shape.c" */

        /* Approximate the current path */
        traverse_path (shape_approximation, (fix FAR *)NULLP);
        if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                return;
        }

        /* initialize new_clip structure, where the new generated
         * clipping path will be placed by shape_reduction routine
         * after shape reduction and performming SAVE_CLIP action.
         */
        new_clip.head = new_clip.tail = NULLP;
        new_clip.bb_ux = new_clip.bb_uy = MIN_SFX;      /* -32767; 12/17/88 */
        new_clip.bb_lx = new_clip.bb_ly = MAX_SFX;      /*  32768; 12/17/88 */

        /* Reduce path to trapezoidized path, and clip it to old clip
         * region
         */
        fill_destination = SAVE_CLIP;
        shape_reduction (winding_type);
                        /* new generated clip in new_clip structure */

        if(ANY_ERROR() == LIMITCHECK){  /* 05/07/91, Peter, out of scany_table */
                free_node(new_clip.head);
                return;
        }

        /* free old clipping path if it is not used by lower gsave level */
        if(!GSptr->clip_path.inherit)
                free_node (GSptr->clip_path.head);

        /* install the new clipping path */
        GSptr->clip_path.head = new_clip.head;
        GSptr->clip_path.tail = new_clip.tail;
        GSptr->clip_path.inherit = FALSE;
        GSptr->clip_path.bb_ux = new_clip.bb_ux;
        GSptr->clip_path.bb_uy = new_clip.bb_uy;
        GSptr->clip_path.bb_lx = new_clip.bb_lx;
        GSptr->clip_path.bb_ly = new_clip.bb_ly;

        /* particular case, null clip; @WIN 5/20/92 */
        if (new_clip.head == NULLP) {
            GSptr->clip_path.single_rect = TRUE;
            return;
        }

        /* check if single rectangle */
        GSptr->clip_path.single_rect = FALSE;
        if (new_clip.head == new_clip.tail) {   /* single trapezoid */
                tpzd = &node_table[new_clip.head];
                if ((tpzd->CP_TOPXL == tpzd->CP_BTMXL) &&
                    (tpzd->CP_TOPXR == tpzd->CP_BTMXR)) {
                        /* rectangle */
                        GSptr->clip_path.single_rect = TRUE;
                }
        }

}




/************************************************************************
 * This module is to implement erasepage operator. It erases the entire current
 * page by painting it with gray level 1.
 * Syntax :        -   erasepage   -
 *
 * TITLE:       op_erasepage
 *
 * CALL:        op_erasepage()
 *
 * INTERFACE:   interpreter(op_erasepage)
 *
 * CALLS:       erasepage
 *
 ************************************************************************/
fix
op_erasepage()
{

        /* Erase the entire page */
        erasepage();

        return(0);
}


/************************************************************************
 * This module is to implement fill operator.
 * Syntax :        -   fill   -
 *
 * TITLE:       op_fill
 *
 * CALL:        op_fill()
 *
 * INTERFACE:   interpreter(op_fill)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 ************************************************************************/
fix
op_fill()
{
        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
            show_buildchar(OP_FILL);
        else {
            if (fill_clippath())                                /* @CPPH */
                fill_shape(NON_ZERO, F_NORMAL, F_TO_PAGE);
        }

        return(0);
}

/************************************************************************
 *
 * This module is to implement eofill operator.
 * Syntax :        -   eofill   -
 *
 * TITLE:       op_eofill
 *
 * CALL:        op_eofill()
 *
 * INTERFACE:   interpreter(op_eofill)
 *
 * CALLS:       traverse_path, shape_approximation, shape_painting
 *
 ************************************************************************/
fix
op_eofill()
{

        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
            show_buildchar(OP_EOFILL);
        else {
            if (fill_clippath())                                /* @CPPH */
                fill_shape(EVEN_ODD, F_NORMAL, F_TO_PAGE);
        }

        return(0);
}


/************************************************************************
 * Fill the clipping trapezoids directly from clip path which was stored
 * in path_table[].cp_path.
 *
 * TITLE:       fill_clippath
 *
 * CALL:        fill_clippath()
 *
 * RETURN:      0  -- fill clipping trapezoids successfully
 *              -1 -- do nothing
 *
 * INTERFACE:   op_fill, op_eofill
 *
 * CALLS:       save_tpzd, free_node
 ************************************************************************/
static fix near fill_clippath()                        /* @CPPH */
{
        struct ph_hdr FAR *path;
        PH_IDX  ipath;

        ipath = GSptr->path;

        do {
            path = &path_table[ipath];

            if (path->head != NULLP) return(-1);

            if (path->cp_path != NULLP) {
                CP_IDX itpzd;
                struct nd_hdr FAR *tpzd;

                /* fill trapezoid from clip_trapezoid */
                fill_destination = F_TO_PAGE;
                for (itpzd = path->cp_path; itpzd != NULLP;
                    itpzd = tpzd->next) {
                    tpzd = &node_table[itpzd];
                    save_tpzd(&tpzd->CP_TPZD);
                }

                /* free cp_path for current gsave level */
                if (ipath == GSptr->path) {
                    if (path->cp_path != GSptr->clip_path.head)
                            free_node (path->cp_path);
                    path->cp_path = NULLP;
                }
                return(0);      /* return successfully */
            } /* if */
        } while ((ipath = path->previous) != NULLP);

        return(-1);
}


/************************************************************************
 *
 * This module is to implement stroke operator.
 * Syntax :        -   stroke   -
 *
 * TITLE:       op_stroke
 *
 * CALL:        op_stroke()
 *
 * INTERFACE:   interpreter(op_stroke)
 *
 * CALLS:       traverse_path, path_to_outline
 *
 ************************************************************************/
fix
op_stroke()
{
/*      real32  tmp1, tmp2;     (*12-12-90*); deleted by scchen 2/28/91 */

        /* Ignore it if no currentpoints */
        if (F2L(GSptr->position.x) == NOCURPNT) return(0);

        if (buildchar)
                show_buildchar(OP_STROKE);
        else
                stroke_shape(F_TO_PAGE);

        return(0);
}


/************************************************************************
 * This module is to implement showpage operator. It output one copy of the
 * current page, and erase the current page).
 * Syntax :        -   showpage   -
 *
 * TITLE:       op_showpage
 *
 * CALL:        op_showpage()
 *
 * INTERFACE:   interpreter(op_showpage)
 *
 * CALLS:       erasepage, initgraphics
 ************************************************************************/
fix
op_showpage()
{

        /* check undefine error, Jack, 11-29-90 */
        struct  object_def      name_obj;
        if(is_after_setcachedevice()){
                get_name(&name_obj, "showpage", 8, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* set showpage flag for st_frametoprinter @PRT_FLAG */
        print_page_flag = SHOWPAGE;

        /* Transmit the current page to output device */
        if(interpreter(&GSptr->device.device_proc)) {
                return(0);
        }

        /* change frame buffer for showpage/erasepage enhancement */
        if (GSptr->device.nuldev_flg != NULLDEV) { /* not a null device only; Jack Liaw */
                next_pageframe();
        }

#ifndef DUMBO
/* Don't erase page @WIN */
//      /* Erase the current page */
//      erasepage();
        erasepage();  // DJC put this back...
#else
        erasepage();
#endif

        /* Initialize the graphics state */
        op_initgraphics();

        return(0);
}


/************************************************************************
 * This module is to implement copypage operator. It output one copy of the
 * current page, and without erasing the current page.
 * Syntax :        -   copypage   -
 *
 * TITLE:       op_copypage
 *
 * CALL:        op_copypage()
 *
 * INTERFACE:   interpreter(op_copypage)
 *
 * CALLS:       interpreter
 ************************************************************************/
fix
op_copypage()
{

        /* set copypage flag for st_frametoprinter @PRT_FLAG */
        print_page_flag = COPYPAGE;

        /* Transmit the current page to output device */
        if(interpreter(&GSptr->device.device_proc)) {
                return(0);
        }
        return(0);
}

/************************************************************************
 * This module is to implement banddevice operator.
 * Syntax :        matrix width height proc   banddevice   -
 *
 * TITLE:       op_banddevice
 *
 * CALL:        op_banddevice()
 ************************************************************************/
fix
op_banddevice()
{
       return(0);
}


/************************************************************************
 * This module is to implement framedevice operator.
 * Syntax :        matrix width height proc   framedevice   -
 *
 * TITLE:       op_framedevice
 *
 * CALL:        op_framedevice()
 *
 * INTERFACE:   interpreter(op_framedevice)
 *
 * CALLS:       none
 *
 ************************************************************************/
fix
op_framedevice()
{
        fix     i;
        fix     iwidth8, iheight;
        sfix_t  ux, uy;
        real32  height, width, elmt[MATRIX_LEN];
        struct object_def FAR *obj_matrix, FAR *obj_height, FAR *obj_width, FAR *obj_proc;
        fix GEIeng_checkcomplete(void);         /*@WIN: add prototype */

#ifdef DJC
        /* @EPS */
        typedef struct tagRECT
          {
            int         left;
            int         top;
            int         right;
            int         bottom;
          } RECT;
        extern RECT EPSRect;
#endif
        /*
         * Get input parameters from operand stack
         */

        /* Get operands */
        obj_matrix = GET_OPERAND(3);
        obj_width  = GET_OPERAND(2);
        obj_height = GET_OPERAND(1);
        obj_proc   = GET_OPERAND(0);

        /* Derive the default clipping path */
        GET_OBJ_VALUE(width, obj_width); /* width  = get_obj_value(obj_width);*/
        GET_OBJ_VALUE(height, obj_height);
                                       /* height = get_obj_value(obj_height); */
        /* check rangecheck error 1/25/89 */
        if(LENGTH(obj_matrix) != MATRIX_LEN) {
                ERROR(RANGECHECK);
                return(0);
        }

        /* check access right */
        /* if( !access_chk(obj_matrix, G_ARRAY) ) return(0); for compatability
         *                                                       1/25/89
         */

        if( !get_array_elmt(obj_matrix,MATRIX_LEN,elmt,G_ARRAY)) return(0);



         {

            double  xScale, yScale;


            xScale = yScale = 1.0;

            // DJC DJC DJC ?????
            // where do we get the xres and yres from ???
            PsGetScaleFactor(&xScale, &yScale, 300, 300);

            // Now we need to scale the X and Y multiplier by the ratio of
            // the PSTODIB model. This number is generated by comparing the
            // resolution of the target device surface and the interpreter
            // resolution, currently we dont support scaling for greater
            // than 300 dpi devices because of our MATH possibly breaking
            // down.
            if (xScale <= 1.0) {
               elmt[0] *= (real32)xScale;
               elmt[4] *= (real32)xScale;
            }
            if (yScale <= 1.0) {
               elmt[3] *= (real32)yScale;
               elmt[5] *= (real32)yScale;
            }



#ifdef DJC
            /* update width, height, and matrix according to EPS boundary; @EPS */
            width = (real32)(EPSRect.right - EPSRect.left + 1)/8;
            height = (real32)(EPSRect.bottom - EPSRect.top + 1);
            elmt[4] -= (real32)EPSRect.left;
            elmt[5] -= (real32)EPSRect.top;

#endif

        }

#ifdef XXX      /*@WIN; not need to update starting address of frame buffer */
        /* limit error check - grayscale 8-1-90 Jack Liaw */
        {
            ufix32      l_diff, frame_size;
            ufix32      twidth;

            twidth = ((WORD_ALLIGN((ufix32)(width * 8))) >> 3);
            if (GSptr->graymode)        /* gray */
                frame_size = twidth * (ufix32) height * 4;
            else                        /* mono */
                frame_size = twidth * (ufix32) height;
#ifdef  DBG
            printf("width<%x>,heigh<%x>,size<%lx>\n", (fix)width,
                   (fix)height, frame_size);
#endif
            /* BEGIN, papertype changed 10-11-90, JS */
            if (frame_size != last_frame) {
               /*  wait until laser printer turns ready  */
                while (GEIeng_checkcomplete()) ;
                last_frame = frame_size;
            }
            /* END 10-11-90, JS */

            DIFF_OF_ADDRESS (l_diff, fix32, (byte FAR *)highmem, (byte FAR *)vmptr);
            if (frame_size > l_diff) {
                ERROR(LIMITCHECK);
                return(0);
            } else {
                vmheap = (byte huge *)(highmem - frame_size);
                FBX_BASE = highmem - frame_size;
            }
        }
#endif





#ifdef DJC

        // DJC begin added for realloc of frame buff if needed...
        {
            ufix32 twidth, frame_size;

            twidth = ((WORD_ALLIGN((ufix32)(width * 8))) >> 3);
            frame_size = twidth * (ufix32) height;


            //twidth = ((WORD_ALLIGN((ufix32)(PageType.FB_Width ))) >> 3);
            //frame_size = twidth * PageType.FB_Heigh;

            if (! PsAdjustFrame((LPVOID *) &FBX_BASE, frame_size)) {
                    ERROR(LIMITCHECK);
                    return 0;  //DJC check this bug we need to report something???
            }

        }
        //DJC end



#endif












        if (GSptr->graymode)                    /* gray */
            iwidth8 = (fix)(width * 8 * 4);     /* bits */
        else                                    /* mono */
            iwidth8 = (fix)(width * 8);         /* bits */
        iheight = (fix)height;
        ux = I2SFX(GSptr->graymode ? (fix)(iwidth8 / 4) : iwidth8);   /* iwidth8 * 8;  SFX format */
        uy = I2SFX(iheight);             /* iheight * 8;             */

        /* default clipping region = {(0, 0), (ux, 0), (ux, uy),
         * and (0, uy)}
         */

        /* Save device characteristics: width, height, CTM, procedure @DEVICE */
        GSptr->device.width = (fix16)iwidth8;
        GSptr->device.height = (fix16)iheight;

        /* device procedure */
        COPY_OBJ(obj_proc, &GSptr->device.device_proc);

        /* CTM */
        for(i=0; i < MATRIX_LEN; i++) {
                   GSptr->ctm[i] = GSptr->device.default_ctm[i] = elmt[i];
        }

        /* set change_flag; @DEVICE */
        GSptr->device.chg_flg = TRUE;   /* device has been changed;
                                         * set for grestore
                                         */
        /* set not a null device; grayscale 8-1-90 Jack Liaw */
        if (GSptr->graymode) {
            GSptr->device.nuldev_flg = GRAYDEV;
            GSptr->halftone_screen.freq = (real32)100.0;        /* 100 lines */
            GSptr->halftone_screen.angle = (real32)45.0;
        } else {
            GSptr->device.nuldev_flg = MONODEV;
            GSptr->halftone_screen.freq = (real32)60.0;         /*  60 lines */             GSptr->halftone_screen.angle = (real32)45.0;
        }

#ifdef DBG
        if (GSptr->device.nuldev_flg == GRAYDEV)                /* test */
            fprintf(stderr, " framedevice is ... GRAY\n");      /* test */
        else                                                    /* test */
            fprintf(stderr, " framedevice is ... MONO\n");      /* test */
#endif

        /* reset halftone *)
        SetHalfToneCell();
        FillHalfTonePat();*/

        /* save default clipping */
        GSptr->device.default_clip.lx = 0;
        GSptr->device.default_clip.ly = 0;

        GSptr->device.default_clip.ux = ux - (fix16)ONE_SFX;    //@WIN
        GSptr->device.default_clip.uy = uy - (fix16)ONE_SFX;    //@WIN

        /*
         * set current clipping
         */
        op_initclip();

        reset_page (iwidth8, iheight, 1);
                                /* 1: monochrome */
/*      reset_page (iwidth8, iheight, 1); |* once again ?, Jack Liaw, 8-8-90 */

        POP(4);

        return(0);
}


/************************************************************************
 * This module is to implement nulldevice operator.
 * Syntax :        -   nulldevice   -
 *
 * TITLE:       op_nulldevice
 *
 * CALL:        op_nulldevice()
 *
 * INTERFACE:   interpreter(op_nulldevice)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_nulldevice()
{
        fix     i;

        create_array(&GSptr->device.device_proc, 0);
        ATTRIBUTE_SET(&GSptr->device.device_proc, EXECUTABLE);

        GSptr->device.default_ctm[0] = one_f;     /* identity CTM */
        GSptr->device.default_ctm[1] = zero_f;
        GSptr->device.default_ctm[2] = zero_f;
        GSptr->device.default_ctm[3] = one_f;
        GSptr->device.default_ctm[4] = zero_f;
        GSptr->device.default_ctm[5] = zero_f;

        GSptr->device.default_clip.lx = 0;    /* clip at the origin */
        GSptr->device.default_clip.ly = 0;
        GSptr->device.default_clip.ux = 0;
        GSptr->device.default_clip.uy = 0;

        /* Set current CTM */
        for(i=0; i<MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }

        /* set current clip */
        op_initclip();

        /* set a null device; Jack Liaw */
        GSptr->device.nuldev_flg = NULLDEV;

        return(0);
}


/************************************************************************
 * This module is to implement renderbands operator.
 * Syntax :        proc   renderbands   -
 *
 * TITLE:       op_renderbands
 *
 * CALL:        op_renderbands()
 ************************************************************************/
fix
op_renderbands()
{
        return(0);
}


/************************************************************************
 *
 * This module is to implement frametoprinter internal operator.
 * Syntax :        #copies   frametoprinter   -
 *
 * TITLE:       st_frametoprinter
 *
 * CALL:        st_frametoprinter()
 *
 * INTERFACE:   interpreter(st_frametoprinter)
 *
 * CALLS:       none
 ************************************************************************/
fix
st_frametoprinter()
{
        real32  copies, tmp;
        fix    copies_i;
        struct object_def FAR *obj_copies;
        fix    top, left, manfeed;
        struct object_def FAR *obj_top, FAR *obj_left, FAR *obj_manfeed;

        /*
         * Get input parameters from operand stack
         */

        /* Check number of operands */
        if(COUNT() < 4) {
                ERROR(STACKUNDERFLOW);
                return(0);
        }

        /* Get operand 3 */
        obj_top = GET_OPERAND(3);
        if (TYPE(obj_top) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_top);
        top   = (fix)tmp;

        /* Get operand 2 */
        obj_left = GET_OPERAND(2);
        if (TYPE(obj_left) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_left);
        left   = (fix)tmp;

        /* Get operand 1 */
        obj_manfeed = GET_OPERAND(1);
        if (TYPE(obj_manfeed) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }
        GET_OBJ_VALUE(tmp, obj_manfeed);
        manfeed   = (fix)tmp;

        /* Get operands */
        obj_copies = GET_OPERAND(0);

        /* Type check */
        if (TYPE(obj_copies) != INTEGERTYPE) {
                ERROR(TYPECHECK);
                return(0);
        }

        /* get # of copies */
        GET_OBJ_VALUE(copies, obj_copies);
                                     /* copies = get_obj_value(obj_copies); */

        if(copies > zero_f) {
                copies_i = (fix)copies;

                /* print pages */
                print_page (top, left, copies_i, print_page_flag, manfeed);
                /* print_page (top, left*8, copies_i, print_page_flag, manfeed);
                 *             input unit changed from bytes to bits; 1/15/90
                 */

                /* update page count @PAGE_CNT */
                updatepc((ufix32)copies_i);
        }

        POP(4);

        return(0);
}

/***********************************************************************
 *
 * This module erases the entire current page by painting it with gray
 * level 1.
 *
 * TITLE:       erasepage
 *
 * CALL:        erasepage()
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_erasepage, op_showpage
 *
 * CALLS:       setgray, filler
 *
 * RETURN:
 *
 **********************************************************************/
static void near erasepage()
{
        real32   old_gray, gray_1;

        /* do nothing if it is a null device; Jack Liaw */
//      if (GSptr->device.nuldev_flg == NULLDEV) { @WIN; device not set yet
//              return;                                  Temp. ???
//      }

        gray_1 = one_f;

        /* Save current gray level */
        old_gray = GSptr->color.gray;

        /* Paint the entire page with gray level 1 */
        setgray (F2L(gray_1));

        /* clear the full page */
        erase_page();

        /* Restore the gray level */
        setgray (F2L(old_gray));
        return;
}

/************************************************************************
 * This module is to transform (x, y) by CTM
 *
 * TITLE:       transform
 *
 * CALL:        transform(x, y)
 *
 * PARAMETER:   x, y: source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p: address of transform result (x', y')
 ************************************************************************/
struct coord FAR *transform(lx, ly)
long32   lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;
        p.x = GSptr->ctm[0]*x + GSptr->ctm[2]*y + GSptr->ctm[4];
        CHECK_INFINITY(p.x);

        p.y = GSptr->ctm[1]*x + GSptr->ctm[3]*y + GSptr->ctm[5];
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to inverse transform (x, y) by CTM
 *
 * TITLE:       inverse_transform
 *
 * CALL:        inverse_transform(x, y)
 *
 * PARAMETER:   x, y: source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p : address of inverse transform result (x', y')
 *
 ************************************************************************/
struct coord FAR *inverse_transform(lx, ly)
long32   lx, ly;
{
        static struct coord p;  /* should be static */
        real32  x, y, det_matrix;

        /* calculate the det(CTM) */
        _clear87() ;
        det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                     GSptr->ctm[1] * GSptr->ctm[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return((struct coord FAR *)NIL);
        }

        x = L2F(lx);
        y = L2F(ly);
        p.x = (GSptr->ctm[3]*x - GSptr->ctm[2]*y - GSptr->ctm[4]*GSptr->ctm[3] +
               GSptr->ctm[2]*GSptr->ctm[5]) / det_matrix;
        CHECK_INFINITY(p.x);

        p.y = (GSptr->ctm[0]*y - GSptr->ctm[1]*x - GSptr->ctm[0]*GSptr->ctm[5] +
               GSptr->ctm[4]*GSptr->ctm[1]) / det_matrix;
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to transform (x, y) by matrix
 *
 * TITLE:       any_transform
 *
 * CALL:        any_transform(matrix, x, y)
 *
 * PARAMETER:   matrix: transform matrix
 *              x, y  : source coordinate
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &p:address of transform result (x', y')
 ************************************************************************/
struct coord FAR *any_transform(matrix, lx, ly)
real32   FAR matrix[];
long32    lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;
        p.x = matrix[0] * x + matrix[2] * y + matrix[4];
        CHECK_INFINITY(p.x);

        p.y = matrix[1] * x + matrix[3] * y + matrix[5];
        CHECK_INFINITY(p.y);

        return(&p);
}


/************************************************************************
 * This module is to fill im with inverse of matrix
 *
 * TITLE:       inverse_mat
 *
 * CALL:        inverse_mat(matrix)
 *
 * PARAMETER:   matrix : source matrix
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      &im: address of im
 ************************************************************************/
real32 FAR *inverse_mat(matrix)
real32   FAR matrix[];
{
        static real32 im[6];
        real32 det_matrix;

        /* calculate the det(matrix1) */
        _clear87() ;
        det_matrix = matrix[0] * matrix[3] - matrix[1] * matrix[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return((real32 *)NIL);
        }

        /* calculate the value of INV(matrix) */
        im[0] =  matrix[3] / det_matrix;
        CHECK_INFINITY(im[0]);

        im[1] = -matrix[1] / det_matrix;
        CHECK_INFINITY(im[1]);

        im[2] = -matrix[2] / det_matrix;
        CHECK_INFINITY(im[2]);

        im[3] =  matrix[0] / det_matrix;
        CHECK_INFINITY(im[3]);

        im[4] = (matrix[2] * matrix[5] - matrix[3] * matrix[4]) / det_matrix;
        CHECK_INFINITY(im[4]);

        im[5] = (matrix[1] * matrix[4] - matrix[0] * matrix[5]) / det_matrix;
        CHECK_INFINITY(im[5]);

        return(im);
}


/************************************************************************
 * This module is to fill mat3 with mat1 * mat2.
 *
 * TITLE:       concat_mat
 *
 * CALL:        concat_mat(mat1, mat2)
 *
 * PARAMETER:   mat1, mat2 : matrix1 & matrix2
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      mat3
 ************************************************************************/
real32 FAR *concat_mat(mat1, mat2)
real32   FAR mat1[], FAR mat2[];
{
        static real32 mat3[6];

        /* create element of mat3 */
        _clear87() ;
        mat3[0] = mat1[0] * mat2[0] + mat1[1] * mat2[2];
        CHECK_INFINITY(mat3[0]);

        mat3[1] = mat1[0] * mat2[1] + mat1[1] * mat2[3];
        CHECK_INFINITY(mat3[1]);

        mat3[2] = mat1[2] * mat2[0] + mat1[3] * mat2[2];
        CHECK_INFINITY(mat3[2]);

        mat3[3] = mat1[2] * mat2[1] + mat1[3] * mat2[3];
        CHECK_INFINITY(mat3[3]);

        mat3[4] = mat1[4] * mat2[0] + mat1[5] * mat2[2] + mat2[4];
        CHECK_INFINITY(mat3[4]);

        mat3[5] = mat1[4] * mat2[1] + mat1[5] * mat2[3] + mat2[5];
        CHECK_INFINITY(mat3[5]);

        return(mat3);
}


/***********************************************************************
 * This module frees current new path
 *
 * TITLE:       free_newpath
 *
 * CALL:        free_newpath()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   op_strokepath
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
static void near free_newpath()
{
        struct  nd_hdr FAR *sp;
        SP_IDX  isp;    /* index to node_table for subpath */

        /*
         * Free current newpath
         */
        /* free each subpath of current newpath */
        /* @NODE
         * for (isp = new_path.head; isp != NULLP; isp = sp->next) {
         *         sp = &node_table[isp];
         *         free_node (sp->SP_HEAD);
         * }
         */
        for (isp = new_path.head; isp != NULLP; isp = sp->SP_NEXT) {
                sp = &node_table[isp];
                free_node (isp);
        }

        /* free all subpath headers */
        /* free_node (new_path.head);           @NODE; 1/6/90 */
        new_path.head = new_path.tail = NULLP;
}

/***********************************************************************
 * This module sets gray mode in the current graphics state
 *
 * TITLE:       op_setgraymode
 *
 * CALL:        op_setgraymode()
 *
 * PARAMETERS:  none
 *
 * NOTES:       Jack Liaw 7-26-90
 *
 * SYNTAX:      bool setgraymode bool
 **********************************************************************/
fix
op_setgraymode()
{
//  bool8  mode;                        @WIN
    struct object_def  FAR *obj;

    /* get operand */
    obj = GET_OPERAND(0);
//  GET_OBJ_VALUE (mode, obj);          @WIN ???
    POP(1);

    if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    }

    GSptr->graymode = FALSE;
    PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, FALSE);

    return(0);
} /* op_setgraymode */

/***********************************************************************
 * This module gets current gray mode in the graphics state
 *
 * TITLE:       op_currentgraymode
 *
 * CALL:        op_currentgraymode()
 *
 * PARAMETERS:  none
 *
 * NOTES:       Jack Liaw 7-26-90
 *
 * SYNTAX:      - currentgraymode bool
 **********************************************************************/
fix
op_currentgraymode()
{
    if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    }
    /* return gray mode */
    PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, GSptr->graymode);
    return(0);
} /* op_currentgraymode */

/***********************************************************************
 * This module sets the image interpolation value in the graphics state
 *
 * TITLE:       op_setinterpolation
 *
 * CALL:        op_setinterpolation()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 7-26-90
 *
 * SYNTAX:      bool setinterpolation -
 **********************************************************************/
fix
op_setinterpolation()
{
/*  POP(1); */
    return(0);
} /* op_setinterpolation */

/***********************************************************************
 * This module gets current value of the image interpolation in the
 * graphics state
 *
 * TITLE:       op_currentinterpolation
 *
 * CALL:        op_currentinterpolation()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 7-26-90
 *
 * SYNTAX:      - currentinterpolation bool
 **********************************************************************/
fix
op_currentinterpolation()
{
/*  if (FRCOUNT() < 1) {
        ERROR (STACKOVERFLOW);
        return(0);
    } */
    /* always false */
/*  PUSH_VALUE (BOOLEANTYPE, 0, LITERAL, 0, FALSE); */
    return(0);
} /* op_currentinterpolation */

/***********************************************************************
 * This module is used to calibrate the printer in graymode
 *
 * TITLE:       op_calibrategray
 *
 * CALL:        op_calibrategray()
 *
 * PARAMETERS:  none
 *
 * NOTES:       this is a dummy routine, Jack Liaw 8-15-90
 *
 * SYNTAX:      string int calibrategray -
 **********************************************************************/
fix
op_calibrategray()
{
    POP(2);
    return(0);
} /* op_calibrategray */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\filling.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   filling.c
 *
 *      Purpose: This file contains 2 modules of filling interfaces:
 *               1) fill_shape -- to fill the current path
 *               2) stroke_shape -- to stroke the current path
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *                  2/5/88      @IMAGE: enhance image processing
 *                  2/12/88     @RAISE_ONLY:
 *                              raise one pixel of problem point
 *                  2/25/88     add first_flag
 *                  2/27/88     @EHS_CACHE: enhance cache
 *                  3/1/88      @F_CHOP: truncation of filling
 *                                       RND_S -> INT_S
 *                  3/3/88      INT_S -> SFX_I
 *                  3/3/88      @RSL: fill resolution in SFX unit
 *                  3/18/88     @HORZ_LINE: add horizontal lines
 *                  3/21/88     @FILL_INFO: put bounding box information
 *                                 of filling to a global structure
 *                  3/24/88     @DFR_SCAN: defer scan_conversion, put
 *                              all edges and just do scan-conversion
 *                              once.
 *                  4/2/88      @CHOP_BOX:
 *                              bounding box: round -> truncation
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  4/22/88     @EHS_ROUND: enhance round_join and
 *                              round_cap
 *                  6/7/88      delete @DFR_SCAN; not defer performing
 *                              scan_conversion
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int   ==> sfix_t, for short fixed real
 *                                       ==> fix, for integer
 *                              3) int_coord ==> coord_i
 *                              4) delete INTG, FRAC, RND_S macro definitions
 *                              5) SFX_I ==> SFX2I_T
 *                              6) move ONE_SFX, HALF_SFX to "graphics.h"
 *                              7) bb_y << 3 ==> I2SFX(bb_y)
 *                  7/20/88     @ALIGN_W: word alignment of bounding box
 *                  7/28/88     @PARA: remove unused parameters of graphics
 *                              primitives interface
 *      3.0         8/13/88     @SCAN_EHS: scan_conversion enhancement
 *                              delete filler(), put_fill_edge().
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and set its value only at
 *                              necessary time instead of each op_stroke command
 *      3.0         9/10/88     @STK_INT: stroke enhancement for stroking under
 *                              interger operations
 *                  10/21/88    @THIN_STK: add condition for checking thin
 *                              linewidth stroke
 *                              call new routines: is_thinstroke &
 *                                                 path_to_outline_t
 *                  10/28/88    @CRC: update circle cache for putting bitmap in
 *                              correct position:
 *                              1. revise
 *                                 1) round_point for setting ref_x & ref_y,
 *                                    and calling fill_shape(.., F_FROM_CRC)
 *                                 2) fill_shape: add another type F_FROM_CRC
 *                  11/22/88    revise the sequence of conditions of checking
 *                              thin linewidth stroke in stroke_shape():
 *                  11/30/88    fill_shape(): call init_edgetable before
 *                              shape_approximation
 *                  01/16/89    @IMAGE: fill_shape(): add new fill type
 *                              F_FROM_IMAGE to generate clipping mask (CMB)
 *                              from clippath for clipped image/imagemask
 *                  01/26/89    stroke_shape(): return if any error occurs
 *                  08/11/89    fill_shape(): Update the max. y-coord(bb_uy),
 *                              decreased by 1, for step 2 of filling from cache
 *                              to page.
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  12/12/90    @CPPH: stroke_shape(): set current point as
 *                              init values of bbox, since path->head may be
 *                              NULLP.
 *                  03/26/91    stroke_shape(): added CLEAR_ERROR and
 *                              traverse_path to avoid error which come from
 *                              0 scale at the x and y direction.
 *                  4/17/91     fill_shape(): limit check for edge table
 *                  11/20/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"

/* ********* local constants *********** */
/* stroke type */
#define FLOAT_STROKE            1  /* floating point stroking */
#define THIN_STROKE             2  /* thin line width stroke */
#define INTEGER_STROKE_IN_CLIP  3  /* integer stroke & inside single clip */
#define INTEGER_STROKE_OV_CLIP  4  /* integer stroke & not inside single clip */

/* ********** static variables ********** */
static real32 near cache_y = (real32)0.0;        /* @EHS_CACHE */
static fix near cache_y_ii = 0;

/***********************************************************************
 * This routine provides an interface to fill the current path.
 *
 * TITLE:       fill_shape
 *
 * CALL:        fill_shape (winding_type, fill_type, dest)
 *
 * PARAMETERS:  winding_type -- (NON_ZERO/EVEN_ODD)
 *              fill_type -- F_NORMAL: from path to page or cache
 *                           F_FROM_CACHE: from cache to page
 *              dest -- F_TO_PAGE: fill to page
 *                      F_TO_CACHE: fill to cache
 *
 *              combination:
 *               fill_type   |  dest      |
 *              -------------+------------+-----------------------------------
 *               F_NORMAL    | F_TO_PAGE  | fill current path to page
 *               F_NORMAL    | F_TO_CACHE | fill current path to cache memory
 *               F_FROM_CACHE| F_TO_PAGE  | get bitmap from cache, and move to
 *                           |            | page
 *
 * INTERFACE:   op_fill, op_eofill, font machineary
 *
 * CALLS:       traverse_path, shape_approximation, shape_reduction
 *              op_newpath, draw_cache_page, init_cache_page,
 *              save_tpzd, fill_cache_page
 *
 * RETURN:      None
 **********************************************************************/
void fill_shape (winding_type, fill_type, dest)
ufix    winding_type, fill_type, dest;
{
    fix     bb_xorig, bb_yorig, bb_width, bb_heigh, bb_uy;
    CP_IDX icp;
    struct nd_hdr FAR *cp;
    struct polygon_i polygon, FAR *pgn; /*@WIN*/
    ufix        save;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
    real32   tmp;
#elif  FORMAT_16_16
    long dest1[2];
#elif  FORMAT_28_4
    long dest1[2];
#endif

    pgn = (struct polygon_i FAR *)&polygon;     /*@WIN*/

    switch (fill_type) {

    case F_NORMAL :         /* from shape to page/cache */
        fill_destination = dest;

        /* initialize edge table 11/30/88 */
        init_edgetable();       /* in "shape.c" */

        /* perform shape approximation, reduction, then fill it */
        traverse_path (shape_approximation, (fix FAR *)NULLP);
        if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                return;
        }
        shape_reduction (winding_type);

        if ( ANY_ERROR() == LIMITCHECK ) /* 05/07/91, Peter, out of scany_table */
                return;

        op_newpath();
        break;

    case F_FROM_CRC :     /* from circle cache to page @CRC 10/28/88 */
        fill_destination = dest;        /* 12/09/87 */

        /* STEP 1 : clear clipping bitmap */
        bb_xorig = SFX2I_T((F2SFX(GSptr->position.x) - cache_info->ref_x));
        bb_yorig = SFX2I_T((F2SFX(GSptr->position.y) - cache_info->ref_y));
        goto set_bb;            /*
                                 * Because circle cache needs 1/8 pixel unit of
                                 * ref_x and ref_y to compute the correct
                                 * bb_xorig and bb_yorig, so use different
                                 * calculation with F_FROM_CACHE case.
                                 * F2SFX should be consistent with those
                                 * defined in path_to_outline_i and
                                 * path_to_outline_t
                                 */

    case F_FROM_CACHE :     /* from cache to page */
        fill_destination = dest;        /* 12/09/87 */

        /* STEP 1 : clear clipping bitmap */
        /* get bounding box information on page */      /* 12/17/87 */

        //UPD058
        bb_xorig = (fix)(GSptr->position.x+.5) - cache_info->ref_x;/* 2/24/88 */

/*      bb_yorig = (fix)(GSptr->position.y) - cache_info->ref_y;
 */
        if (F2L(cache_y) != F2L(GSptr->position.y)) {   /* @EHS_CACHE 2/27/88 */
                cache_y = GSptr->position.y;

                //UPD058
                cache_y_ii = (fix)(GSptr->position.y+.5);
        }
        bb_yorig = cache_y_ii - cache_info->ref_y;

set_bb:
        bb_width = cache_info->box_w;
        bb_heigh = cache_info->box_h;
        bb_uy = bb_yorig + bb_heigh - 1;        /* 8/11/89 */

#ifdef DBG1
        printf(" fill_shape(F_FROM_CACHE): current point=(%f, %f)\n",
                 GSptr->position.x, GSptr->position.y);
        printf(" cache_info: ref_x=%d ref_y=%d\n", cache_info->ref_x,
                cache_info->ref_y);
        printf(" bb_xorig=%d,", bb_xorig);
        printf(" bb_yorig=%d, bb_width=%d, bb_heigh=%d\n", bb_yorig,
                 bb_width, bb_heigh);
        dump_all_clip();
#endif

        /* check if cache bitmap totally inside clipping region 12/4/87 */
        if ((GSptr->clip_path.single_rect) &&           /* 12/7/87 */
            (bb_xorig >= SFX2I_T(GSptr->clip_path.bb_lx)) &&
            (bb_yorig >= SFX2I_T(GSptr->clip_path.bb_ly)) &&
            ((bb_xorig + bb_width) <= SFX2I_T(GSptr->clip_path.bb_ux)) &&
            ((bb_yorig + bb_heigh) <= SFX2I_T(GSptr->clip_path.bb_uy))) {
                /* fill page buffer with cache image directly */
                draw_cache_page ((fix32)bb_xorig, (fix32)bb_yorig, /*@WIN*/
                    (ufix32)bb_width, (ufix32)bb_heigh, cache_info->bitmap);
                break;
        }


        init_cache_page (bb_xorig, bb_yorig, bb_width, bb_heigh,
                         cache_info->bitmap);

        /* STEP 2 : generate mask of clipping path */

        /* set fill_destination for generating clip mask */
        save = fill_destination;
        fill_destination = F_TO_CLIP;

        for (icp = GSptr->clip_path.head; icp != NULLP;
            icp = cp->next) {
            sfix_t   bb_uy8, bb_yorig8;          /* bb_ * 8  @PRE_CLIP */
            struct tpzd tpzd;

            cp = &node_table[icp];

            bb_uy8 = I2SFX(bb_uy);               /* bb_uy << 3; @PRE_CLIP */
            bb_yorig8 = I2SFX(bb_yorig);         /* bb_yorig << 3 */

            /* clip trapezoid outside bounding box */
            if ((cp->CP_TOPY > bb_uy8) ||
                (cp->CP_BTMY < bb_yorig8)) continue;
#ifdef DBG1
            printf("fill_shape(): clip mask gen. clip_trapez=\n");
            printf("(%f, %f, %f), (%f, %f, %f)\n",
                    cp->CP_TOPY/8.0, cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0,
                    cp->CP_BTMY/8.0, cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

            tpzd.topy  = cp->CP_TOPY;
            tpzd.topxl = cp->CP_TOPXL;
            tpzd.topxr = cp->CP_TOPXR;
            tpzd.btmy  = cp->CP_BTMY;
            tpzd.btmxl = cp->CP_BTMXL;
            tpzd.btmxr = cp->CP_BTMXR;

            /*
             * modify clip trapezoid
             */
            /* for bottom line */
            if (cp->CP_BTMY > bb_uy8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_uy8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.btmxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.btmxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.btmy = bb_uy8;
            }

            /* for top line */
            if (cp->CP_TOPY < bb_yorig8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_yorig8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.topxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.topxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif FORMAT_16_16
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif FORMAT_28_4
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.topy = bb_yorig8;
            }

            save_tpzd(&tpzd);

        } /* for cp */

        /* restore fill_destination */
        fill_destination = save;

        /* STEP 3 : fill page buffer with cache image */
        fill_cache_page ();
        break;

    /* ++++++++++++ @Y.C. BEGIN +++++++++++++++++++++++++++++++++++++++++++ */
    case F_FROM_IMAGE :     /* from cache to page  @IMAGE 01-16-89 */
        fill_destination = dest;        /* 12/27/88 */

        /* STEP 1 : clear clipping bitmap */
        /* get bounding box information on page */      /* 12/27/88 */
        bb_xorig = image_info.bb_lx;
        bb_yorig = image_info.bb_ly;
        bb_width = image_info.bb_xw;
        bb_heigh = image_info.bb_yh;

        bb_uy = bb_yorig + bb_heigh;

#ifdef DBG1
        printf(" fill_shape(F_FROM_IMAGE)\n");
        printf(" bb_xorig=%d, bb_yorig=%d, bb_width=%d, bb_heigh=%d\n",
                 bb_xorig, bb_yorig, bb_width, bb_heigh);
        dump_all_clip();
#endif
#ifdef DBG9
        printf(" fill_shape(F_FROM_IMAGE)\n");
        printf(" bb_xorig=%d, bb_yorig=%d, bb_width=%d, bb_heigh=%d\n",
                 bb_xorig, bb_yorig, bb_width, bb_heigh);
#endif

        init_image_page (bb_xorig, bb_yorig, bb_width, bb_heigh);

        /* STEP 2 : generate mask of clipping path */

        for (icp = GSptr->clip_path.head; icp != NULLP;
            icp = cp->next) {
            sfix_t   bb_uy8, bb_yorig8;          /* bb_ * 8  @PRE_CLIP */
            struct tpzd tpzd;

            cp = &node_table[icp];

            bb_uy8 = I2SFX(bb_uy);               /* bb_uy << 3; @PRE_CLIP */
            bb_yorig8 = I2SFX(bb_yorig);         /* bb_yorig << 3 */

            /* clip trapezoid outside bounding box */
            if ((cp->CP_TOPY > bb_uy8) ||
                (cp->CP_BTMY < bb_yorig8)) continue;
#ifdef DBG1
            printf("fill_shape(): clip mask gen. clip_trapez=\n");
            printf("(%f, %f, %f), (%f, %f, %f)\n",
                    cp->CP_TOPY/8.0, cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0,
                    cp->CP_BTMY/8.0, cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

            tpzd.topy  = cp->CP_TOPY;
            tpzd.topxl = cp->CP_TOPXL;
            tpzd.topxr = cp->CP_TOPXR;
            tpzd.btmy  = cp->CP_BTMY;
            tpzd.btmxl = cp->CP_BTMXL;
            tpzd.btmxr = cp->CP_BTMXR;

            /*
             * modify clip trapezoid
             */
            /* for bottom line */
            if (cp->CP_BTMY > bb_uy8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_uy8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.btmxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.btmxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.btmxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_uy8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.btmxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.btmy = bb_uy8;
            }

            /* for top line */
            if (cp->CP_TOPY < bb_yorig8) {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                tmp = (real32)(bb_yorig8 - cp->CP_TOPY) /
                      (cp->CP_BTMY - cp->CP_TOPY);
                tpzd.topxr = (sfix_t)(cp->CP_TOPXR + ROUND(tmp *
                              (cp->CP_BTMXR - cp->CP_TOPXR)));
                tpzd.topxl = (sfix_t)(cp->CP_TOPXL + ROUND(tmp *
                              (cp->CP_BTMXL - cp->CP_TOPXL)));
#elif  FORMAT_16_16
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                tpzd.topxr = cp->CP_TOPXR + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
                LongFixsMul((bb_yorig8 - cp->CP_TOPY),
                                (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                tpzd.topxl = cp->CP_TOPXL + LongFixsDiv(
                                        (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                tpzd.topy = bb_yorig8;
            }

            save_tpzd(&tpzd);

        } /* for cp */
        break;
    /* ++++++++++++ @Y.C. END +++++++++++++++++++++++++++++++++++++++++++++ */

    default :
            printf("\07Fatal error, fill_type");
    } /* switch */
}

extern void path_to_outline_q ();       /* stroke enhancement  -jwm, 3/18/91 */

/***********************************************************************
 * This routine provides an interface to stroke the current path.
 *
 * TITLE:       stroke_shape
 *
 * CALL:        stroke_shape (dest)
 *
 * PARAMETERS:
 *              dest -- F_TO_PAGE: stroke to page
 *                      F_TO_CACHE: stroke to cache
 *
 * INTERFACE:   op_stroke, font machineary
 *
 * CALLS:       traverse_path, path_to_outline, init_stroke,
 *              set_inverse_ctm, op_newpath, free_node
 *
 * RETURN:
 *
 **********************************************************************/
void stroke_shape (dest)
ufix    dest;
{
        real32    bbox[4];              /* @STK_INT */
        /* struct   nd_hdr *sp; @NODE */
        ufix     stroke_type;

        /* initialization of stroke parameters */
        init_stroke();          /* @EHS_STK 1/29/88 */

        if (ANY_ERROR()) {      /* return if any error 1/26/89 */
                /* When 0 scale at x and y direction will cause error at the
                 * inverse matrix calculation, we can not let this error showing
                 * at the screen(it is not an error at NTX). We just clear error
                 * ,traverse_path, and return. phchen 03/26/91. ref. Matrix1.ps */
                CLEAR_ERROR();
                traverse_path (path_to_outline_t, (fix FAR *)TRUE);
                end_stroke();
                return;
        }

        fill_destination = dest;

        /*
         * Check conditions for applying appropriate stroking routines:
         * Conditions:
         *      1: linejoin points inside
         *         [PAGE_LEFT, PAGE_TOP] and [PAGE_RIGHT, PAGE_BTM]@RESO_UPGR
         *      2: inside single clip path
         *      3: CTM criteria         @RESO_UPGR
         *               1. |a| == |d|
         *               2. |b| == |c|
         *               3. |a| < 8   and   |b| < 8  <------ wrong
         *               3. |a| <[=] CTM_LIMIT and |b| <[=] CTM_LIMIT
         *                  See graphics.h for the details
         *      4: linewidth < 1 pixel
         *
         * Stroke_type:
         * 1) FLOAT_STROKE -- worse case, using floating point arith.
         * 2) THIN_STROKE  -- thin line width stroke
         *                    condition: 1, 2, 4
         * 3) INTEGER_STROKE_IN_CLIP -- integer stroke & inside single clip
         *                    condition: 1, 2, 3
         * 4) INTEGER_STROKE_OV_CLIP -- integer stroke & not inside single clip
         *                    condition: 1, 3
         */

        /* initialization */
/*      (* get the first MOVETO coordinate as initial value 5/19/88 *)
 *      path = &path_table[GSptr->path];
 *      while (path->head == NULLP) {
 *              path = &path_table[path->previous];
 *      }
 *      (* @NODE
 *       * sp = &node_table[path->head];
 *       * vtx = &node_table[sp->SP_HEAD];
 *       *)
 *      vtx = &node_table[path->head];
 *
 *      bbox[0] = vtx->VERTEX_X;  (* min_x *)
 *      bbox[2] = vtx->VERTEX_X;  (* max_x *)
 *      bbox[1] = vtx->VERTEX_Y;  (* min_y *)
 *      bbox[3] = vtx->VERTEX_Y;  (* max_y *)
 */
        /* set current point as initial value @CPPH; 12/12/90 */
        bbox[0] = bbox[2] = GSptr->position.x;  /* min_x, max_x */
        bbox[1] = bbox[3] = GSptr->position.y;  /* min_y, max_y */

        /* find bounding box of current path */
// DJC        traverse_path (bounding_box, (fix FAR *)bbox);
        traverse_path ((TRAVERSE_PATH_ARG1)(bounding_box), (fix FAR *)bbox);

        /* add with max expanding length of miter join */
        expand_stroke_box (bbox);

        /*
         * Condition 1: linejoin points inside SFX boundary
         */
        /* check if outside the page boundary */
        if (too_small(F2L(bbox[0])) ||
            too_small(F2L(bbox[1])) ||
            too_large(F2L(bbox[2])) ||
            too_large(F2L(bbox[3]))) {
            /* Normal floating stroking */
            stroke_type = FLOAT_STROKE;

        } else {
            /*
             * Condition 2: inside single clip path
             */
            if ((GSptr->clip_path.single_rect) &&
                (F2SFX(bbox[0]) >= GSptr->clip_path.bb_lx) &&
                (F2SFX(bbox[1]) >= GSptr->clip_path.bb_ly) &&
                (F2SFX(bbox[2]) <= GSptr->clip_path.bb_ux) &&
                (F2SFX(bbox[3]) <= GSptr->clip_path.bb_uy)) {

                /*
                 * Condition 4: linewidth < 1 pixel
                 */
                if (is_thinstroke()) {
                    stroke_type = THIN_STROKE;
                } else {
                    /*
                     * Condition 3: CTM criteria
                     */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) <= CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) <= CTM_LIMIT))
#elif  FORMAT_16_16
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#elif  FORMAT_28_4
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#endif
                        stroke_type = INTEGER_STROKE_IN_CLIP;
                    else
                        stroke_type = FLOAT_STROKE;

                } /* condition 4: thin stroke */

            } else { /* not single rectangle clip */
                    /*
                     * Condition 3: CTM criteria
                     */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) <= CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) <= CTM_LIMIT))
#elif  FORMAT_16_16
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#elif  FORMAT_28_4
                    if ((MAGN(GSptr->ctm[0]) == MAGN(GSptr->ctm[3])) &&
                        (MAGN(GSptr->ctm[1]) == MAGN(GSptr->ctm[2])) &&
                        (EXP(F2L(GSptr->ctm[0])) < CTM_LIMIT) &&
                        (EXP(F2L(GSptr->ctm[1])) < CTM_LIMIT))
#endif
                        stroke_type = INTEGER_STROKE_OV_CLIP;
                    else
                        stroke_type = FLOAT_STROKE;
            } /* condition 2: single_rect */

        } /* condition 1: outside page */

        /* perform corresponding stroking routine */
        switch (stroke_type) {

        case FLOAT_STROKE:
                traverse_path (path_to_outline, (fix FAR *)TRUE);
                break;
        case THIN_STROKE:
                traverse_path (path_to_outline_t, (fix FAR *)TRUE);
                break;
        case INTEGER_STROKE_IN_CLIP:
/*              if ((GSptr->dash_pattern.pat_size == 0) && (fill_destination == F_TO_PAGE))
 *                  traverse_path (path_to_outline_q, (fix *)TRUE);  (* jwm, 3/18/91 *)
 *              else  (* quality has trouble,MPOST003; deleted by scchen 3/29/91 *)
 */
                    traverse_path (path_to_outline_i, (fix FAR *)TRUE);
                break;                          /* TRUE: inside clip region */
        case INTEGER_STROKE_OV_CLIP:
                traverse_path (path_to_outline_i, (fix FAR *)FALSE);
                break;                      /* FALSE: not inside clip region */
        }

        /* clear current path if stroke successful */
        if( ANY_ERROR() != LIMITCHECK ) op_newpath();

        /* restore cache_info which was set at init_stroke @CIR_CACHE */
        end_stroke();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\fillproc.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**************************************************************************
 *
 *      Name:       fillproc.h
 *
 *      Purpose:    Header files of graphics machinery, for definitions of
 *                  data types, data structures, constants, and macros.
 *
 *      Developer:  Y.C. Chen
 *      Modified By: D.S Tseng for INTEL 80960 board
 *
 *      History:
 *              5/23/91 mslin   Add Macro   ONE8000
 *                                          LSHIFTEQ
 *                                          RSHIFTEQ
 *
 **************************************************************************/

#define HT_WHITE        0x00            /* HTP all white                */
#define HT_MIXED        0x07            /* HTP mixed or colored         */
#define HT_BLACK        0xFF            /* HTP all black                */
#define HT_CHANGED      0x00            /* halftone pattern being changed  */
#define HT_UPDATED      0xFF            /* halftone pattern being updated  */

/*      Macro definitions of important parameters of bitmaps               */
#define FB_ADDR            (FBX_Bmap.bm_addr)
#define FB_WIDTH           (FBX_Bmap.bm_cols)
#define FB_HEIGH           (FBX_Bmap.bm_rows)
#define FB_PLANE           (FBX_Bmap.bm_bpp)
#define HT_WIDTH           (HTB_Bmap.bm_cols)
#define HT_HEIGH           (HTB_Bmap.bm_rows)
#define HT_PLANE           (HTB_Bmap.bm_bpp)


struct  PT_Entry        /* PageType structure                           */
{
    fix                 FB_Width;       /* width. of frame buffer       */
    fix                 FB_Heigh;       /* height of frame buffer       */
    fix                 PT_Width;       /* width. of paper tray         */
    fix                 PT_Heigh;       /* height of paper tray         */
    fix                 PM_Width;       /* width. of page margin (left) */
    fix                 PM_Heigh;       /* height of page margin (top.) */
};

struct  bitmap          /* Bitmap Structure
                                           all graphics primitives which
                                           operates on bitmap should
                                           recognize bitmap structure   */
{
    gmaddr              bm_addr;        /* base address of bitmap       */
    fix                 bm_cols;        /* #(cols) of bitmap in pixels  */
    fix                 bm_rows;        /* #(rows) of bitmap in pixels  */
    fix                 bm_bpp;         /* #(planes) of bitmap
                                           bpp means bits per pixel     */
                                        /* the following fields may be
                                           defined if necessary         */
};

#define BM_XORIG        0x0000
#define BM_XMAXI        0x7FFF
#define BM_YORIG        0x0000
#define BM_YMAXI        0x7FFF

#define BM_ENTRY(BM, BM_ADDR, BM_COLS, BM_ROWS, BM_BPP) \
                        BM.bm_addr = BM_ADDR; \
                        BM.bm_cols = BM_COLS; \
                        BM.bm_rows = BM_ROWS; \
                        BM.bm_bpp  = 1;

#define MB_ENTRY(MB)   ((gmaddr) ((ufix32) MB << 20))
#define FB_ENTRY(FB)   ((gmaddr) (MB_ENTRY(FB) + FBX_BASE))


/**************************************************************************
 *      The following macros shift a bitmap word left or right in the
 *      concept of printout.  You should modify these macros to match
 *      the bit ordering.
 **************************************************************************/

#define BMW_LEFT        0x8000          /* bitmap word left most bit      */
#define BMW_MASK        0x000F          /* bitmap word round or mask      */
#define BMW_PIXS        0x0010          /* bitmap word number of pixels   */
#define BMW_BYTE        0x0002          /* bitmap word number of bytes    */

#define CS_2WORD(CS)   (CS >> 4)        /* convert columns into words     */
#define BMS_LEFT(BM,S) (BM << S)        /* shift a bitmap word left       */
#define BMS_RIGH(BM,S) (BM >> S)        /* shift a bitmap word right      */


/**************************************************************************
 *      Symbolic Definition of HT/FC: Halftoning Flag & Function Code
 **************************************************************************/

#define HT_MASK         0xFF00  /* mask of halftone flag                  */
#define FC_MASK         0x00FF  /* mask of function code                  */

#define HT_NONE         0x0000  /* halftone flag: need not be applied     */
#define HT_APPLY        0xFF00  /* halftone flag: should be applied       */

#define FC_WHITE        0x0002  /* 0010B   logical function [all white]   */
#define FC_BLACK        0x0007  /* 0111B   logical function [all black]   */

#define FC_ERASE        0x0000  /* 0000B   for Step 1.  D <- 0            */
#define FC_SOLID        0x000F  /* 1111B   for Step 2.  D <- 1            */
#define FC_CLIPS        0x0001  /* 0001B   for Step 2.  D <- D.AND.S      */
#define FC_CLEAR        0x0002  /* 0010B   for Step 3.  D <- D.AND..NOT.S */
#define FC_HTONE        0x0001  /* 0001B   for Step 4.  D <- D.AND.S      */
#define FC_MERGE        0x0007  /* 0111B   for Step 5.  D <- D.OR.S       */
#define FC_MOVES        0x0005  /* 0101B             .  D <- S            */


/* BEGIN 02/26/90 D.S. Tseng */
/* Change the following defines to variables and initialize them in SETVM.C */
/************************************************************************
 *      System Parameters of Graphics Memory                            *
 ************************************************************************/

/* #define CCB_OFST    ((ufix32) 0x00080000L) */ /* Character Cache Buffer   */
/* #define CCB_SIZE    ((fix32)  1024 *  250) */ /*  250 kilobytes for CCB   */
                                                         /* @IMAGE  01-16-89 */

/* #define ECB_OFST    ((ufix32) 0x000BE800L) */ /* Erasepage Command Buffer */
                                                         /* @IMAGE  01-16-89 */
/* #define ECB_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for ECB   */
/* #define CRC_OFST    ((ufix32) 0x000BF000L) */ /* Joint/Cap Circular Cache */
                                                         /* @IMAGE  01-16-89 */
/* #define CRC_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for CRC   */
/* #define ISP_OFST    ((ufix32) 0x000BF800L) */ /* ImageMask Seed Pattern   */
                                                       /* @IMAGE  01-16-89 */
/* #define ISP_SIZE    ((fix32)   256 *    2) */ /*    8 kilobytes for ISP   */
/* #define HTP_OFST    ((ufix32) 0x000C1800L) */ /* HalfTone RepeatPattern   */
/* #define HTP_SIZE    ((fix32)  1024 *    2) */ /*    2 kilobytes for PCL   */
/* #define HTC_OFST    ((ufix32) 0x000C2000L) */ /* HalfTone Pattern Cache   */
/* #define HTC_SIZE    ((fix32)  1024 *   16) */ /*   16 kilobytes for HTC   */
/* #define HTB_OFST    ((ufix32) 0x000C6000L) */ /* HalfTone Bitmap Buffer   */
/* #define HTB_SIZE    ((fix32)  1024 *   12) */ /*   12 kilobytes for HTB   */
/* #define HTE_OFST    ((ufix32) 0x000C9000L) */ /* HalfTone Bitmap Buffer   */
/* #define HTE_SIZE    ((fix32)  1024 *   12) */ /*   12 kilobytes for HTB   */
/* #define CMB_OFST    ((ufix32) 0x000CC000L) */ /* Clipping  Mask  Buffer   */
/* #define CMB_SIZE    ((fix32)  1024 *   16) */ /*   16 kilobytes for CMB   */
/* #define GCB_OFST    ((ufix32) 0x000D0000L) */ /* GraphicsCommand Buffer   */
/* #define GCB_SIZE    ((fix32)  1024 *  128) */ /*  128 kilobytes for HTB   */
/* #define GWB_OFST    ((ufix32) 0x000F0000L) */ /* Graphic Working BitMap   */
/* #define GWB_SIZE    ((fix32)   300 *  216) */ /*  216 scanlines for GWB   */
/* END   02/26/90 D.S. Tseng */


/* ************************************************************************ *
 *      Environment Dependent Parameters                                    *
 * ************************************************************************ */
#define HTB_XMIN         256    /* mim width of expanded halftone pattern   */
#define HTB_XMAX        FB_WIDTH  /* max width of expanded halftone pattern */

#define SP_BLOCK         256    /* max number of image samples per block
                                       for gcb allocation                   */

#define SP_WIDTH        MAXSEEDSIZE
#define SP_HEIGH        MAXSEEDSIZE

#define GMS_i186       ((ufix32) 0xE0000000L)
                                /* Segment Address of Graphics Memory       */
#define GMA_i186(A)    ((ufix32) (GMS_i186 + (A & 0x0000FFFFL)))
                                /* macro for convert address of graphics
                                       memory into address of 80186         */
#define GM_PMASK       ((ufix32) 0xFFFF0000L)
#define GM_PBANK(G)    ((ufix16) ((ufix32) G >> 16))

/* ************************************************************************ *
 *      Following defined & declarations are added by M.S Lin               *
 *
 * ************************************************************************ */
#define         ZERO            0x0
#define         ONE             0x1
#define         ONE16           0xffffL
#define         ONE32           ((ufix32)0xffffffffL)
#define         BITSPERWORD     0x20
#define         WORDPOWER       0x5
#define         WORDMASK        0x1f
#define         BITSPERSHORT    0x10
#define         SHORTPOWER      0x4
#define         SHORTMASK       0xf

/*MS used by gp_vector 1-18-89 */
#define BM_DATYP        ufix32
#define CC_DATYP        ufix16
#define AND(X,Y)        (X & Y)
#define OR(X,Y)         (X | Y)

/*MS constant define used by GCB */
#define         RESET_PAGE           1
#define         ERASE_PAGE           2
#define         FILL_SCAN_PAGE       3
#define         FILL_PIXEL_PAGE      5
#define         INIT_CHAR_CACHE      6
#define         COPY_CHAR_CACHE      7
#define         FILL_SCAN_CACHE      8
#define         FILL_PIXEL_CACHE     9
#define         INIT_CACHE_PAGE      10
#define         CLIP_CACHE_PAGE      11
#define         FILL_CACHE_PAGE      12
#define         DRAW_CACHE_PAGE      13
#define         FILL_SEED_PATT       14
#define         FILL_TPZD            15
#define         CHANGE_HALFTONE      16
#define         MOVE_CHAR_CACHE      17
#define         FILL_LINE            18
#define         INIT_IMAGE_PAGE      19
#define         CLIP_IMAGE_PAGE      20
#define         FILL_BOX             21         /* jwm, 3/18/91 -begin- */
#define         FILL_RECT            22         /* jwm, 3/18/91 -end- */
#ifdef WIN
#define         PFILL_TPZD           23
#define         CHANGE_PF_PATTERN    24
#endif

#define         GCB_SIZE1            100        /* for no scanline commands */
#define         GCB_SIZE2            8192       /* for scanline commands    */



/*MS macro define */
#define WORD_ALLIGN(x)  (((x + BITSPERWORD -1) >> WORDPOWER) << WORDPOWER )


#ifdef  LBODR
#define         LSHIFT          <<
#define         RSHIFT          >>
#define         ONE1_32         (ufix32)0x1L
#define         ONE1_16         (ufix16)0x1
#define 	ONE8000 	(ufix32)0x80000000	     /*mslin 5/23/91 */
#define         LSHIFTEQ        <<=                     /*mslin 5/23/91 */
#define         RSHIFTEQ        >>=                     /*mslin 5/23/91 */
#else
#define         LSHIFT          >>
#define         RSHIFT          <<
#define         ONE1_32         (ufix32)0x80000000
#define         ONE1_16         (ufix16)0x8000
#define 	ONE8000 	(ufix32)0x1L	       /*mslin 5/23/91 */
#define         LSHIFTEQ        >>=                     /*mslin 5/23/91 */
#define         RSHIFTEQ        <<=                     /*mslin 5/23/91 */
#define         GP_BITBLT16_32  gp_bitblt16_32
#endif

#define BRSHIFT(value,shift,base) ((shift == base) ? 0 : value RSHIFT shift)
#define BLSHIFT(value,shift,base) ((shift == base) ? 0 : value LSHIFT shift)

/*MS
 * Bitmap related functions name macro definition
 */
#define GP_SCANLINE16           gp_scanline16
#define GP_SCANLINE32           gp_scanline32
#ifdef WIN
#define GP_SCANLINE32_pfREP     gp_scanline32_pfREP
#define GP_SCANLINE32_pfOR      gp_scanline32_pfOR
#endif
#define GP_BITBLT16             gp_bitblt16
#define GP_BITBLT32             gp_bitblt32
#define GP_PIXELS16             gp_pixels16
#define GP_PIXELS32             gp_pixels32
#define GP_CACHEBLT16           gp_cacheblt16
#define GP_CHARBLT16            gp_charblt16
#define GP_CHARBLT32            gp_charblt32
#define GP_CHARBLT16_CC         gp_charblt16_cc
#define GP_CHARBLT16_CLIP       gp_charblt16_clip
#define GP_CHARBLT32_CLIP       gp_charblt32_clip
#define GP_PATBLT               gp_patblt
#define GP_PATBLT_M             gp_patblt_m
#define GP_PATBLT_C             gp_patblt_c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\fillgs.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*  ----------------------------------------------------------------
 *  Fill : Fillgs.c
 *
 *  Programmed by: Y.C Chen for 80186+82786 iLaser Board.
 *  Modified by: M.S Lin for single CPU environment.
 *  Date: 5-26-1988
 *        6-05-1989  by J.S.
 *
 *  Purpose
 *     Provide graphics & font module fill and cache supporting functions
 *
 *  Modication History:
 *      8-8-1988 interface change for version X2.1
 *      10-18-88        add fill_tpzd for intermediate file feature.
 *      11-15-88        modified code for portable.
 *      11-25-88        copy_char_cache() modified: gp_charblt16_cc() added.
 *                      init_cache(), clip_cache_page(), fill_cache_page()
 *                      modified: gp_charblt16_clip(), gp_charblt32_clip added.
 *      11-28-88        add alloc_scanline() for font
 *                      add move_char_cache() for font
 *                      fill_scan_page, fill_scan_cache, clip_cache_page
 *                      didn't need save scanline table into GCB
 *      12-01-88        conv_SL() bug fixed.
 *                      *putptr++ = (xe > bb_width) ? (bb_width -1) : xe;
 *                             --->
 *                      *putptr++ = (xe >= bb_width) ? (bb_width -1) : xe;
 *
 *      12-16-88        print_page modified to support manualfeed.
 *
 *      12-20-88        ufix32 printer_status(void) added
 *      01-06-89        fill_line() added
 *      01-19-89        fill_seed_patt() parameter changed, seed_index added
 *      02-03-1989      update for image enchancement.
 *                      @IMAGE-1, @IMAGE-2
 *      06-07-1989      ImageClear() moved to fillgp.c
 *      07-29-1989      cg - Unix port changes to include files
 *      09-24-1990      @CONT_PRI, MSLin 9/24/90
 *                      init_char_cache(), fill_cache_page() and
 *                      draw_cache_page
 *      12/5/90  Danny  Fix the bugs for show char in show (ref. CIRL:)
 *                      new fill_cache_cache() routine added
 *      01/09/91        update GEIeng_printpage() return value check
 #ifdef WIN
 *  Ada 02-15-1991      change fill_tpzd(), fill_scan_page() to handle op_pfill
 #endif
 *      11/20/91        upgrade for higher resolution @RESO_UPGR
 *
 *  Debug Switch:
 *      DBG  -- for function enter message.
 *      DBG1 -- for more information on function call.
 *      DBGscanline -- for scanline list info.
 *      DBGgcb -- for GCB debug message.
 *      DBGfontdata -- for get fontdata info.
 *      DBGcmb -- clipping mask buffer info.
 *
 *
 *  Program Notes:
 *    1. This file support interface routines for graphics and font modules
 *       for running on single CPU environment.
 *
 *    2. We used scanline filling directly into frame buffer without using
 *       graphics working buffer like iLaser board. Scanline and Bitblt
 *       with halftoning applied directly.
 *
 *    3. gp_scanline16() used for filling into font character cache because
 *       bitmap width is multiple of 16.
 *
 *    4. gp_scanline32() used for filling into frame buffer, seed, CMB
 *       because bitmap width of these data area are multiple of 32.
 *
 *    5. gp_bitblt16() and gp_bitblt32() are BITBLT routines also support
 *       halftoning applied.
 *
 *    6. GCB (Graphics Command Buffer) feature also supported for througput
 *       in single buffer environment.
 *
 *
 * ------------------------------------------------------------------------ */


// DJC added global include
#include "psglobal.h"


#include                <stdio.h>
#include                <string.h>
#include                "global.ext"
#include                "graphics.h"

// DJC moved font.h above graphics.ext to avoid prototype prob with init_char_cache
#include                "font.h"

#include                "graphics.ext"
#include                "halftone.h"
#include                "fillproc.h"
#include                "fillproc.ext"   /* 02/28/90 D.S. Tseng */
#include                "language.h"     /* 12-16-88 */
#include                "geieng.h"      /* @GEI */
#include                "geitmr.h"      /* @GEI */
#include                "geierr.h"      /* @GEI */
#include                "user.h"     /* 12-16-88 */

#include                "win2ti.h"     /* @WIN */

/* routines defined in status.c */
extern void     printer_error();
extern fix16    timeout_flag;
int             timeout_flagset;
int             g_handler;
long            g_interval;

/* *************************************************************************
        Local variables
 * ************************************************************************/
static struct bitmap    ISP_Bmap[16]; /* 03/08/89 */
static fix              SP_Width;
static fix              SP_Heigh;

static struct bitmap    HTP_Bmap;
static struct bitmap    SCC_Bmap;
static struct bitmap    DCC_Bmap;


static fix              ISP_Repeat;     /* width of repeat pattern @IMAGE-1 */
static fix              HTB_Expand;     /* width of halftone       @IMAGE-1 */
static fix              HTB_Xmax;       /* HTB expansion width     @IMAGE-1 */
GEItmr_t                manualfeed_tmr;
short  int              manualfeedtimeout_set;
int                     manualfeedtimeout_task();
ufix32                  save_printer_status = EngNormal;

/* *************************************************************************
        Local variables for init_cache_page(), clip_cache_page(),
        fill_cache_page(), and draw_cache_page()

        BB_XXXXX are parameters are bounding box been aligned on word
                 and clipped
        CC_XXXXX are parameters describes how to bitblt CMB onto
                 frame buffer
        CB_XXXXX are parameters described how to bitblt character
                 cache onto CMB
 * ************************************************************************/
static fix              BB_Xorig;
static fix              BB_Yorig;
static fix              BB_Width;
static fix              BB_Heigh;
static fix              CC_Xorig;
static fix              CC_Yorig;
static fix              CC_Width;
static fix              CC_Heigh;

/* @WT: margins defined in "wrapper.c", used by ps_transmit() */
extern int      top_margin;
extern int      left_margin;

/* ufix            seed_flag = 0; */

#ifdef  LINT_ARGS
void      near  expand_halftone(void);
void      near  apply_halftone(fix, fix, fix, fix);

void      near  get_bitmap(gmaddr, ufix far *, fix, fix);
void      near  put_bitmap(gmaddr, ufix32 far *, fix, fix); /* ufix => ufix32 @WIN */

fix       far   conv_SL(fix, SCANLINE FAR *, fix, fix, fix, fix);
void      gp_vector(struct bitmap FAR *, ufix16, fix, fix, fix, fix);

void      gp_vector_c(struct bitmap FAR *, ufix16, fix, fix, fix, fix);
void      gp_patblt(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
void      gp_patblt_m(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
void      gp_patblt_c(struct bitmap FAR *, fix, fix, fix, fix, ufix16, struct bitmap FAR *);
fix       GEIeng_printpage(fix, fix);           /* @WIN */
void      GEIeng_setpage(GEIpage_t FAR *);


void      ImageClear(ufix32 /* void */);            /* fix => ufix32 @WIN */

#else
void      near  expand_halftone();
void      near  apply_halftone();

void      near  get_bitmap();
void      near  put_bitmap();

fix       far   conv_SL();
void      gp_vector();

void      gp_vector_c();
void      gp_patblt();
void      gp_patblt_m();
void      gp_patblt_c();
fix       GEIeng_printpage();
void      GEIeng_setpage();

void      ImageClear();

#endif

/*MS add*/
#ifdef DBGscanline
   void get_scanlist(fix, fix, SCANLINE FAR *);
#endif
#ifdef DBG
   fix           get_printbufferptr();
#endif

#ifdef  DUMBO
extern byte     bBackflag;      // @DLL
extern byte     bFlushframe;    // @DLL
extern void     longjump(void); // @DLL
extern byte far *lpStack;       // @DLL
#endif


/* ******************************************************************** */

/* -------------------------------------------------------------------- */
/*      init_physical     --  Initialize Fill Procedure Context         */
void
init_physical()
{
#ifdef  DBG
   printf("init_physical...\n");
#endif

/* BEGIN 02/27/90 D.S. Tseng */
/*
 *      FBX_BASE = 0x00800000;
 *
 *      CCB_BASE = CCB_OFST;
 *      ISP_BASE = ISP_OFST;
 *      HTP_BASE = HTP_OFST;
 *      HTC_BASE = HTC_OFST;
 *      HTB_BASE = HTB_OFST;
 *      CMB_BASE = CMB_OFST;
 *      CRC_BASE = CRC_OFST;
 *      GCB_BASE = GCB_OFST;
 *      GWB_BASE = GWB_OFST;
 */
/* END   02/27/90 D.S. Tseng */

        /* public graphics paramters for all modules; @YC 03-21-89 */
        ccb_base = CCB_BASE;    /* base of character cache pool         */
        ccb_size = CCB_SIZE;    /* size of character cache pool         */
        htc_base = HTC_BASE;    /* size of halftone pattern cache       */
        htc_size = HTC_SIZE;    /* size of halftone pattern cache       */
        crc_size = CRC_SIZE;    /* size of circular round cache         */
        isp_size = ISP_SIZE;    /* size of image seed patterns          */
        gwb_size = GWB_SIZE;    /* size of graphics working bitmap      */
        cmb_size = CMB_SIZE;    /* size of clipping mask bitmap         */

        /*  reset default paper tray type and page type  */
        reset_tray(2544, 3328);     /* letter paper tray as default   */
/* Peter reset_page(2400, 3236, 1);      letter page type as default    */
        //DJC took out reset_page(2496, 3300, 1);    /* letter page type as default    */

        /* setup GCB parameters */
        FB_busy = FALSE;      /* 03/08/89 */
        GCB_flush = FALSE;    /* 03/08/89 */
        gcb_ptr = (ULONG_PTR *)GCB_BASE;
        GCB_count = 0L;

#ifdef DBG
        printf("CCB_BASE=%lx, ISP_BASE\n", CCB_BASE, ISP_BASE);
        printf("HTP_BASE=%lx, HTC_BASE=%lx, HTB_BASE=%lx\n",
                HTP_BASE, HTC_BASE, HTB_BASE);
        printf("CMB_BASE=%lx, CRC_BASE=%lx, GCB_BASE=%lx\n",
                CMB_BASE, CRC_BASE, GCB_BASE);
        printf("GWB_BASE=%lx, FBX_BASE=%lx\n", GWB_BASE,FBX_BASE);
#endif

}

/* -------------------------------------------------------------------- */
/*      init_halftone     --  Initialize Half Tone Pattern              */

void init_halftone()
{
#ifdef DBG
   printf("init_halftone..\n");
#endif

        InitHalfToneDat();                                /* 01-29-88 */
#ifdef DBG
   printf("init_halftone().1\n");
#endif

        SetHalfToneCell();
#ifdef DBG
   printf("init_halftone().2\n");
#endif

         FillHalfTonePat();
#ifdef DBG
   printf("init_halftone().3\n");
#endif
}


/* ******************************************************************** *
 *                                                                      *
 *      5.4.2.1 Page Manipulation                                       *
 *                                                                      *
 * ******************************************************************** */


/* -------------------------------------------------------------------- */
/*      reset_tray                                                      */
void far
reset_tray(pt_width, pt_heigh)
fix             pt_width;
fix             pt_heigh;
{
#ifdef  DBG
    printf("reset_tray:  %x %x\n", pt_width, pt_heigh);
#endif

        /* width and height of paper tray in page type structure */
        PageType.PT_Width = pt_width;
        PageType.PT_Heigh = pt_heigh;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   reset_page()                                            *
 *                                                                      *
 *  Parameters: 1. width  of page type                                  *
 *              2. height of page type                                  *
 *                                                                      *
 *  Called by:  init_physical(), op_framedevice(), restore()            *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
reset_page(fb_width, fb_heigh, fb_plane)
fix            fb_width;
fix            fb_heigh;
fix            fb_plane;
{
        // fix    *old_ptr; @WIN
        ULONG_PTR *old_ptr;

#ifdef  DBG
   printf("reset_page:  %x %x %x\n", fb_width, fb_heigh, fb_plane);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = RESET_PAGE;
                *gcb_ptr++ = fb_width;
                *gcb_ptr++ = fb_heigh;
                *gcb_ptr++ = fb_plane;
                *old_ptr = (ULONG_PTR)gcb_ptr;       // (fix )gcb_ptr;@WIN
                return;
            }
        }

    /*  record width, height and number of planes of page type in page
        type structure  */
        PageType.FB_Width = WORD_ALLIGN(fb_width);       /* 10-08-88 */
        PageType.FB_Heigh = fb_heigh;
        FB_Plane = fb_plane;

/* 10-16-90, JS
        HTB_Xmax = HTB_XMAX;                             (* @IMAGE-1 *)
 */

#ifdef DBG1
    printf("Page width=%ld, Page height=%lx\n", FB_WIDTH, FB_HEIGH);
#endif
    /*  define bitmap of active frame buffer  */





        // DJC begin added for realloc of frame buff if needed...
        {
            ufix32 twidth, frame_size;

            twidth = ((WORD_ALLIGN((ufix32)(fb_width))) >> 3);
            frame_size = twidth * (ufix32) fb_heigh;


            //twidth = ((WORD_ALLIGN((ufix32)(PageType.FB_Width ))) >> 3);
            //frame_size = twidth * PageType.FB_Heigh;

            if (! PsAdjustFrame((LPVOID *) &FBX_BASE, frame_size)) {
                    ERROR(LIMITCHECK);
                    return ;  //DJC check this bug we need to report something???
            }

        }
        //DJC end



        BM_ENTRY(FBX_Bmap, FBX_BASE, PageType.FB_Width,
                 PageType.FB_Heigh, FB_PLANE);

    /* 10-16-90, JS */
        HTB_Xmax = HTB_XMAX;                             /* @IMAGE-1 */

    /*  Clear Active frame buffer */
        ImageClear(BM_WHITE);

}
/* --------------------------------------------------
              manualfeedtimeout handler
-----------------------------------------------------*/
int manualfeedtimeout_task()
{
/*
   printf("%c%c[PrinterError : manualfeed timeout ]%c%c\n",37,37,37,37);
   ERROR(TIMEOUT);
   GESseterror(ETIME);
   GEItmr_stop(manualfeed_tmr.timer_id);
   manualfeedtimeout_set=0;
   timeout_flag=1;
   return(TRUE);
*/
    struct object_def  FAR *l_stopobj;
//  struct object_def  FAR *l_valueobj,FAR *l_tmpobj;   @WIN
//  byte   l_buf[60];                                   @WIN
   get_dict_value(SYSTEMDICT,"stop",&l_stopobj);
   printf("%c%c[PrinterError : manualfeed timeout ]%c%c\n",37,37,37,37);
   ERROR(TIMEOUT);
   GESseterror(ETIME);
   GEItmr_stop(manualfeed_tmr.timer_id);
   manualfeedtimeout_set=0;
   PUSH_EXEC_OBJ(l_stopobj);
   timeout_flag = 1;
   timeout_flagset=1;
/* interpreter(l_stopobj); */
   return(TRUE);
}

/* -------------------------------------------------------------------- */
/*      print_page        --  Print Full Page Buffer                    */

void far
print_page(tm_heigh, lm_width, no_pages, pageflag, manualfeed)
fix                     tm_heigh;
fix                     lm_width;
fix                     no_pages;
bool                    pageflag;
fix                     manualfeed;
{
#ifdef _AM29K
   GEIpage_t      PagePt;               /* Peter 09/21/1990 */
   unsigned long  eng_status;           /* Peter 09/28/1990 */
   short int   ii;
   struct object_def  FAR *l_mfeedtimeout;
#endif                                          //@WIN

#ifdef DBG
   printf("print_page()\n");
   printf("page size = %ld %ld %ld, %ld, %ld\n",
           PageType.FB_Width, PageType.FB_Heigh, lm_width, tm_heigh, no_pages);
#endif

#ifdef _AM29K
        flush_gcb(TRUE);
        PagePt.pageNX    = PageType.FB_Width;
        PagePt.pageNY    = PageType.FB_Heigh;
        PagePt.pageLM    = lm_width;
        PagePt.pageTM    = tm_heigh;
        PagePt.feed_mode = manualfeed;
        PagePt.pagePtr   = (unsigned char *) FBX_BASE;
        GEIeng_setpage(&PagePt);
        ii=0;

printf("1\n");
           if (manualfeed)
           {
              get_dict_value(STATUSDICT,"manualfeedtimeout",&l_mfeedtimeout);
              if (VALUE(l_mfeedtimeout)>0)
              {
                g_interval=VALUE(l_mfeedtimeout)*1000;
/*
                manualfeed_tmr.handler=manualfeedtimeout_task;
                manualfeed_tmr.interval=VALUE(l_mfeedtimeout)*1000;
                manualfeedtimeout_set=1;
                GEItmr_start(&manualfeed_tmr);
                */

              }
           }
        while((eng_status = GEIeng_status()) != EngNormal)
        {

/*
           if ((manualfeed) && (!ii))
           {
              ii=1;
              get_dict_value(STATUSDICT,"manualfeedtimeout",&l_mfeedtimeout);
              if (VALUE(l_mfeedtimeout)>0)
              {
printf("manualfeed_set \n");
                manualfeed_tmr.handler=manualfeedtimeout_task;
                manualfeed_tmr.interval=VALUE(l_mfeedtimeout)*1000;
                manualfeedtimeout_set=1;
                GEItmr_start(&manualfeed_tmr);

              }
           }
           */
           printer_error(eng_status);                   /* Peter 09/28/1990 */
        }
        save_printer_status = EngNormal;

        /* waiting until last printout finished */
        while( !GEIeng_printpage(no_pages, 0))         /* Jimmy 1/9/91     */
        ;
      /*
        timeout_flagset = 0;
        if (manualfeedtimeout_set)
        {
          manualfeedtimeout_set=0;
          GEItmr_stop(manualfeed_tmr.timer_id);
        }
        */
        FB_busy = TRUE;
#else
#ifdef  DUMBO
        bFlushframe = 1;        // @DLL
        bBackflag = 1;          // @DLL
        longjump(lpStack);      // @DLL
        bFlushframe = 0;        // @DLL
#else
        //DJC GEIeng_printpage(1, 0);            /* Peter 09/28/1990 @WIN */


        //DJC add code to get the current page type and pass along
        //
        {
          struct object_def FAR *l_page;
          real32 page_type;


          get_dict_value(PSPRIVATEDICT, "psprivatepagetype", &l_page) ;
          GET_OBJ_VALUE( page_type, l_page);


          PsPrintPage( no_pages,
                       0,
                       (LPVOID) FB_ADDR,
                       FB_WIDTH,
                       FB_HEIGH,
                       FB_PLANE,
                       (DWORD) page_type );



        }
#endif
#endif
}


/* ************* Erase ************************************************ */

/* -------------------------------------------------------------------- */
/*      erase_page        --  Erase full Page Buffer                    */

void erase_page()
{
//DJC #ifdef DUMBO
        fix             FB_Ycord;
        //fix           *old_ptr;       @WIN
        ULONG_PTR *old_ptr;
//DJC #endif

#ifdef DBG
   printf("erase_page()\n");
#endif

   /* @WINFLOW; don't erase page temp solution */
// printf("Warning to call erase_page()\n");
//DJC #ifdef DUMBO

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = ERASE_PAGE;
                *gcb_ptr++ = HTP_Type;          /* Jun-21-91 YM */
                *old_ptr = (ULONG_PTR)gcb_ptr;          /*@WIN*/
                return;
            }
        }

        if (HTP_Flag == HT_CHANGED) {                     /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        if(HTP_Type != HT_MIXED) {
                ImageClear((HTP_Type == HT_WHITE) ? BM_WHITE : BM_BLACK);
        }
        else {
     /*
      * copy HTB repeat pattern which have been expanded on expand_halftone
      * to frame buffer
      */
           GP_BITBLT32(&FBX_Bmap, BM_XORIG, BM_YORIG, FB_WIDTH,
                        RP_Heigh,
                        FC_MOVES,
                       &HTB_Bmap, BM_XORIG, BM_YORIG);

           for(FB_Ycord = RP_Heigh; FB_Ycord < FB_HEIGH;
                   FB_Ycord = FB_Ycord << 1) {
                GP_BITBLT32(&FBX_Bmap, BM_XORIG, FB_Ycord, FB_WIDTH,
                            ((FB_Ycord << 1) <= FB_HEIGH)
                            ? FB_Ycord : (FB_HEIGH - FB_Ycord),
                            FC_MOVES,
                            &FBX_Bmap, BM_XORIG, BM_YORIG);
           }
        }
//DJC #endif
        return;
} /* erase_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   next_pageframe()                                        *
 *                                                                      *
 *  Parameters: ----                                                    *
 *                                                                      *
 *  Called by:  op_showpage()                                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
next_pageframe()
{
#ifdef  DBG
    printf("next_pageframe...\n");
#endif

}



/* ************* Halftone ********************************************* */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   change_halftone()                                       *
 *                                                                      *
 *  Parameters: 1. pointer of repeat pattern                            *
 *              2. address of halftone pattern cache                    *
 *              3. type of halftoning; white, gray, or black            *
 *              4. width  of repeat pattern                             *
 *              5. height of repeat pattern                             *
 *                                                                      *
 *  Called by:  FillHalfTonePat()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
change_halftone(rp_array, rp_entry, htp_type, rp_width, rp_heigh)
ufix32             far *rp_array;       /* ufix => ufix32 @WIN */
gmaddr                  rp_entry;
fix                     htp_type;
fix                     rp_width;
fix                     rp_heigh;
{
        //fix           *old_ptr, *temp_ptr;    @WIN
        ULONG_PTR       *old_ptr, *temp_ptr;
        fix             length;

#ifdef  DBG
   printf("change_halftone:  %lx %x %x %x\n",
           rp_entry, htp_type, rp_width, rp_heigh);
#endif

  /*
   * if Frame Buffer busy then put into GCB
   */
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                HTP_Type = htp_type;    /* 6/26/1989 */
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = CHANGE_HALFTONE;
                temp_ptr = gcb_ptr;
                *gcb_ptr++ = (ULONG_PTR)rp_array;      /*@WIN*/
                *gcb_ptr++ = rp_entry;      /*@WIN*/
                *gcb_ptr++ = htp_type;
                *gcb_ptr++ = rp_width;
                *gcb_ptr++ = rp_heigh;
        /*  put repeat pattern onto halftone pattern cache by miss  */
                if (rp_array != NULL) {
                    *temp_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
                    length = rp_width * BM_BYTES(rp_heigh);
                    lmemcpy((ufix8 FAR *)gcb_ptr, (ufix8 FAR *)rp_array, length);/*@WIN*/
                    gcb_ptr += (length + 3) >> 2;
                }
                *old_ptr = (ULONG_PTR)gcb_ptr;         /*@WIN*/
                return;
            }
        }

    /*  record cache address, type, width and height of repeat pattern  */
        HTP_Flag = HT_CHANGED;
        ISP_Flag = HT_CHANGED;                           /* @IMAGE-1 */
        HTP_Type = htp_type;
        RP_CacheBase = rp_entry;
        RP_Width = rp_width;
        RP_Heigh = rp_heigh;

    /*  put repeat pattern onto halftone pattern cache by miss  */
        if (rp_array != NULL)
                put_bitmap(rp_entry, rp_array, rp_width, rp_heigh);
} /* change_halftone */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   expand_halftone()                                       *
 *                                                                      *
 *  Parameters: ----                                                    *
 *                                                                      *
 *  Called by:  erase_page()                                            *
 *              fill_scan_page(),  fill_pixel_page()                    *
 *              init_cache_page(), draw_cache_page()                    *
 *              fill_image_page()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void near
expand_halftone()
{
        fix              HT_Xcord;
        ufix32           i, FAR *hb_addr, FAR *hb_addrb;
        ufix32           FAR *hp_addr;
        fix              width;


#ifdef  DBG
   printf("expand_halftone...\n");
#endif

        /*  determine function code for erasing and painting  */
           if (HTP_Type != HT_MIXED) {
               FC_Paint = (HTP_Type == HT_WHITE) ? FC_WHITE : FC_BLACK;
               HTP_Flag = HT_UPDATED;

#ifdef DBG1
   printf("expand_halftone() OK.1 : %x\n", FC_Paint);
#endif
               return;
           }

#ifdef DBG
   printf("Start expand halftone !,HTB_Xmax = %x\n",HTB_Xmax);
#endif
           FC_Paint = HT_APPLY;

#ifdef DBG1
   printf("Halftone repeat pattern on cache addr = %lx\n",RP_CacheBase);
   printf("RP_Width = %x, RP_Heigh = %x\n",RP_Width, RP_Heigh);
   printf("Halftone pattern buffer addr = %lx\n", HTB_BASE);
   printf("FB_WIDTH = %lx\n", FB_WIDTH);
#endif
           BM_ENTRY(HTP_Bmap, (gmaddr)RP_CacheBase, BM_BOUND(RP_Width),
                    RP_Heigh, FB_PLANE);
           BM_ENTRY(HTB_Bmap, (gmaddr)HTB_BASE, HTB_Xmax,
                    RP_Heigh, FB_PLANE);

        /*  copy repeat pattern to halftone pattern buffer HTB_BASE  */
           hp_addr = (ufix32 FAR *)HTP_Bmap.bm_addr;
           hb_addrb = (ufix32 FAR *)HTB_Bmap.bm_addr;
           for (i = 0; i < (ufix32)RP_Heigh; i++) {     //@WIN
                width = RP_Width;
                hb_addr = hb_addrb;
                while (width > 0) {
                      *hb_addr++ = *hp_addr++;
                      width -= 32;
                 }
                 hb_addrb += HT_WIDTH >> 5;
           }
/*
 *         GP_BITBLT16(&HTB_Bmap, BM_XORIG, BM_YORIG,
 *                     RP_Width, RP_Heigh,
 *                     FC_MOVES,
 *                     &HTP_Bmap, BM_XORIG, BM_YORIG);
 */

#ifdef  DBG3
        {
            fix         row, col;
            ufix32       FAR *hpattern;

            printf("repeat pattern expanding ......\n");
            printf("HTB_BASE = %lx\n",HTB_BASE);
            hpattern = (ufix32 FAR *)HTB_BASE;
            for (row = 0; row < RP_Heigh; row++)
            {
                for (col = 0; col < RP_Width; col+=32)
                {
                    printf(" %lx", *hpattern);
                }
                hpattern += HT_WIDTH >> 5;
                printf("\n");
            }
        }
#endif

        /*  expand halftone on frame buffer horizontally

            +-------------------------------------------------------+
            |//////\\\\\\++++++++++++######################## . . . |
            |//////\\\\\\++++++++++++######################## . . . |
            +-------------------------------------------------------+
             |RP*1||RP*1||<- RP*2 ->||<------ RP * 4 ------>|

            horizontal expansion are applied as follows:

                1.  copy region(/) to region(\)
                2.  copy region(\) to region(+)
                3.  copy region(+) to region(#)
               etc.
        */

            for (HT_Xcord = RP_Width; HT_Xcord <= (HT_WIDTH >> 1);
                HT_Xcord = HT_Xcord << 1) {

#ifdef DBG1
   printf("expand_halftone().2, HT_Xcord = %ld\n", HT_Xcord);
#endif
                GP_BITBLT32(&HTB_Bmap, HT_Xcord, BM_YORIG,
                           HT_Xcord, RP_Heigh,
                           FC_MOVES,
                          &HTB_Bmap, BM_XORIG, BM_YORIG);

            }   /* for  */
            if (HT_Xcord != HT_WIDTH)
               GP_BITBLT32(&HTB_Bmap, HT_Xcord, BM_YORIG,
                          (HT_WIDTH - HT_Xcord), RP_Heigh,
                          FC_MOVES,
                         &HTB_Bmap, BM_XORIG, BM_YORIG);

#  ifdef DBG1
      printf("expand_halftone() OK.2\n");
#  endif

        return;

} /* expand_halftone() */


/* ************* Filling ********************************************** */

/* ********************************************************************
 *
 *  printout scanline list for debug
 *
 * ******************************************************************** */
#ifdef DBGscanline
void get_scanlist(startline, lines, scan)
fix        startline, lines;
SCANLINE  FAR *scan;
{
        fix   i = 1;
        SCANLINE   xs;

        printf("ys_lines = %d, no_lines = %d\n", startline, lines);
        while(lines-- >0) {
          printf("line %d : \n", i++);
          printf("\t");
          while( (xs = *scan++) != (SCANLINE)END_OF_SCANLINE )
             printf("<%d, %d>, ", xs, *scan++);
          printf("\n");
        }
        return;
}
#endif



/***********************************************************************
 * According to the type(dest), this routine appends the input
 * trapezoid to command buffer, or calls "gp_scanconv" to render it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_tpzd
 *
 * CALL:        fill_tpzd(dest, info, tpzd)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: bounding box information
 *              3. tpzd: a trapezoid
 *
 * INTERFACE:
 *
 * CALLS:       gp_scanconv
 *
 * RETURN:      None
 **********************************************************************/
void far fill_tpzd(dest, info, tpzd)
ufix dest;
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{

        ULONG_PTR *old_ptr;         /*@WIN*/
#ifdef WIN
        extern  fix     pfill_flag;
#endif

#ifdef DBG
   printf("fill_tpzd(): dest=%d\n\ttpzd=\n", dest);
   printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
           SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
   printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
           SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif

        /* Save trapezoid in command buffer if frame buffer/cache is busy */
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
#ifdef WIN
                if (pfill_flag) {
                    *gcb_ptr++ = PFILL_TPZD;
                    *gcb_ptr++ = pfill_flag;
                }
                else
#endif
                *gcb_ptr++ = FILL_TPZD;
                *gcb_ptr++ = (fix )image_info.seed_index;/*MS 10-20-88*/
                *gcb_ptr++ = (fix) dest;
                put_tpzd_info(info);
                put_tpzd(tpzd);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
            }
        }

/* @WINFLOW; ------------- begin ------------------*/
        {
          void far GDIPolygon(struct tpzd_info FAR *, struct tpzd FAR *);

          // /* perform scan conversion */
          // gp_scanconv(dest, info, tpzd);

          /* If using normal holftone, calls GDI directly, otherwise perform
           * the scan conversion  @WINFLOW
           */
          if (dest == F_TO_PAGE && bGDIRender) {        /* @WINFLOW */
              /* Windows GDI fill the trapezoid */
              // DJC GDIPolygon(info, tpzd);

          } else {
              /* Trueimage does the rendering */

              /* modify coord of tpzd as relative to the left-top corner @WINFLOW */
              /* for dynamic global memory allocate only
              tpzd->topxl -= I2SFX(info->BOX_X);
              tpzd->topxr -= I2SFX(info->BOX_X);
              tpzd->btmxl -= I2SFX(info->BOX_X);
              tpzd->btmxr -= I2SFX(info->BOX_X);
              */

              gp_scanconv(dest, info, tpzd);
          }
        }
/* @WINFLOW; -------------  end  ------------------*/

}

/* **************************************************************************
 * This is a interier filling routine for image seed filling.
 *
 * TITLE: fill_seed
 *
 * CALL: fill_seed(image_type, x_maxs, y_maxs, quadrangle)
 *
 * PARAMETERS:
 *
 * CALLS: gp_scanconv_i
 *
 * RETURN: none
 *
 * **************************************************************************
 */

void far
fill_seed(image_type, x_maxs, y_maxs, quadrangle)
ufix           image_type;
fix            x_maxs, y_maxs;
struct sample FAR *quadrangle;
{
    gp_scanconv_i(image_type, x_maxs, y_maxs, quadrangle);
} /* fill_seed */


/***********************************************************************
 * According to the type(dest), this routine appends the input
 * trapezoid to command buffer, or renders it to
 * appropriate destination(cache, page, mask, or seed pattern).
 *
 * TITLE:       fill_line
 *
 * CALL:        fill_line(dest, info, x0, y0, x1, y1)
 *
 * PARAMETERS:
 *              1. dest: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *              2. info: tpzd info.
 *              3. tpzd: line start & end points
 *
 * INTERFACE:
 *
 * CALLS: gp_vector, gp_vector_c
 *
 * RETURN:      None
 **********************************************************************/
void far fill_line(dest, info, x0, y0, x1, y1)
ufix              dest;
struct tpzd_info FAR *info;
sfix_t            x0, y0;
sfix_t            x1, y1;
{
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG1
    printf("fill_line(): dest=%d\n", dest);
    printf("[%d, %d] -- [%d, %d]\n", x0, y0, x1, y1);
#endif

    /* Save line in command buffer if frame buffer/cache is busy */
  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE1) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = FILL_LINE;
        *gcb_ptr++ = (fix) dest;
        put_tpzd_info(info);
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        *gcb_ptr++ = (fix) x0;
        *gcb_ptr++ = (fix) y0;
        *gcb_ptr++ = (fix) x1;
        *gcb_ptr++ = (fix) y1;
#elif  FORMAT_16_16 /* FORMAT_16_16 and FORMAT_28_4 can be combined */
        /* x0, y0, x1, y1 are 4-byte long while fix may be only 2-byte
           Therefore, storing high-byte then low-byte into gcb.
        */
        *gcb_ptr++ = (fix) (x0 >> 16);
        *gcb_ptr++ = (fix) (x0 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y0 >> 16);
        *gcb_ptr++ = (fix) (y0  & 0x0000ffff);
        *gcb_ptr++ = (fix) (x1 >> 16);
        *gcb_ptr++ = (fix) (x1 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y1 >> 16);
        *gcb_ptr++ = (fix) (y1 & 0x0000ffff);
#elif  FORMAT_28_4
        /* x0, y0, x1, y1 are 4-byte long while fix may be only 2-byte
           Therefore, storing high-byte then low-byte into gcb.
        */
        *gcb_ptr++ = (fix) (x0 >> 16);
        *gcb_ptr++ = (fix) (x0 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y0 >> 16);
        *gcb_ptr++ = (fix) (y0  & 0x0000ffff);
        *gcb_ptr++ = (fix) (x1 >> 16);
        *gcb_ptr++ = (fix) (x1 & 0x0000ffff);
        *gcb_ptr++ = (fix) (y1 >> 16);
        *gcb_ptr++ = (fix) (y1 & 0x0000ffff);
#endif
        *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
        return;
    }
  }


    /* perform line drawing */
    switch (dest)
    {
    case F_TO_PAGE:
        if (HTP_Flag == HT_CHANGED)                             /* @IMAGE-1 */
        {
            HTP_Flag =  HT_UPDATED;
            expand_halftone();
        }
        /*  fill line directly onto frame buffer black or white   */
        /* @WINFLOW; ------------ start ------------ */
        //gp_vector(&FBX_Bmap, /* @RESO_UPGR */
        //       FC_Paint,
        //       (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        if (bGDIRender)
            // DJC GDIPolyline((fix) x0, (fix) y0, (fix) x1, (fix) y1);
            ; // DJC
        else
            gp_vector(&FBX_Bmap, /* @RESO_UPGR */
                     FC_Paint,
                     (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        /* @WINFLOW; ------------  end  ------------ */
        break;
    case F_TO_CACHE:
        BM_ENTRY(DCC_Bmap, info->BMAP, info->box_w, info->box_h, 1);
        gp_vector_c(&DCC_Bmap, /* @RESO_UPGR */
                     FC_SOLID,
                     (sfix_t) x0, (sfix_t) y0, (sfix_t) x1, (sfix_t) y1);
        break;
    default:
        printf("Can't fill to other than PAGE or CACHE\n");
        break;
    }
} /* fill_line */



/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_scan_page()                                        *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT FOR RISC)  *
 *              2. x origin of bounding box             (NOT FOR RISC)  *
 *              3. width  of bounding box               (NOT FOR RISC)  *
 *              4. height of bounding box               (NOT FOR RISC)  *
 *              5. y coordinate of starting scanlines                   *
 *              6. number  of scanlines                                 *
 *              7. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  fill_a_band()                                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_scan_page(bb_xorig, bb_yorig, bb_width, bb_heigh, scanline)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
SCANLINE          FAR *scanline;
{
        ULONG_PTR *old_ptr;         /*@WIN*/
#ifdef WIN
        extern  fix     pfill_flag;
#endif

#ifdef  DBG
   printf("fill_scan_page:   %x %x %x %x \n",
           bb_xorig, bb_yorig, bb_width, bb_heigh);
   printf("scanline_table = %lx\n",scanline);
#endif
#ifdef  DBGscanline
   get_scanlist(bb_yorig, bb_heigh, scanline);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_SCAN_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                put_scanline(bb_heigh, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

#ifdef WIN
        if (pfill_flag == PF_REP) {
            GP_SCANLINE32_pfREP(&FBX_Bmap, (ufix16)FC_Paint,
                      bb_yorig, bb_heigh, scanline);
        }
        else if (pfill_flag == PF_OR) {
            GP_SCANLINE32_pfOR(&FBX_Bmap, (ufix16)FC_Paint,
                      bb_yorig, bb_heigh, scanline);
        }
        else
#endif
        /* @WINFLOW; ------------ start ------------ */
        {

            /* @WINFLOW; through GDI to bitblt to Windows */
            // GP_SCANLINE32(&FBX_Bmap, (ufix16)FC_Paint,
            //               bb_yorig, bb_heigh, scanline);
            if (bGDIRender)
                // DJC GDIBitmap(bb_xorig, bb_yorig, bb_width, bb_heigh,
                // DJC   (ufix16)FC_Paint, PROC_SCANLINE32, (LPSTR)scanline);
                ; // DJC
            else {
               GP_SCANLINE32(&FBX_Bmap, (ufix16)FC_Paint,
                             bb_yorig, bb_heigh, scanline);
            }
        }
        /* @WINFLOW; ------------  end  ------------ */

} /* fill_scan_page */


/* -------------------------------------------------------------------  */
/*      fill_pixel_page   --  Filling Pixel List into Page Buffer       */
/*MS    Note : page width should be multiple of 32                      */

void fill_pixel_page(no_pixel, pixelist)
fix                     no_pixel;
PIXELIST                FAR *pixelist;
{
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
   printf("fill_pixel_page()\n");
#endif
        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_PIXEL_PAGE;
                *gcb_ptr++ = no_pixel;
                put_pixelist(no_pixel, pixelist);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        GP_PIXELS32(&FBX_Bmap, FC_Paint, no_pixel, pixelist);
        return;

}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   init_char_cache()                                       *
 *                                                                      *
 *  Parameters: 1. cache_info to be cleared                             *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
init_char_cache(dcc_info)
struct Char_Tbl   far  *dcc_info;
{
        ufix16          FAR *ptr;
        ufix32          FAR *ptr32;
        fix             i;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef  DBG
    printf("init_char_cache:  %lx %x %x\n",
           dcc_info->bitmap, dcc_info->box_w, dcc_info->box_h);
#endif
/*@CONT_PRI, MSLin 9/24/90*/
        if(GCB_count)
            flush_gcb(TRUE);

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = INIT_CHAR_CACHE;
                put_Char_Tbl(dcc_info);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
             }
        }

  /*
   * clear cache bitmap
   */
        if (dcc_info->box_w & 0x1f) {
           ptr = (ufix16 FAR *)dcc_info->bitmap;
           i = dcc_info->box_h * (dcc_info->box_w >> SHORTPOWER);
           while(i--)
              *ptr++ = 0;
        }else {
           ptr32 = (ufix32 FAR *)dcc_info->bitmap;
           i = dcc_info->box_h * (dcc_info->box_w >> WORDPOWER);
           while (i--)
              *ptr32++ = 0L;
        }

}

/* --------------------------------------------------------------------
 *      move_char_cache   --  Move Character Cache
 *
 *       cc_from                cc_into
 *       +-------------+        +-----------+
 *       |  + cc_xorig |        |           |
 *       |    cc_yorig =========>           |
 *       |             |        |           |
 *       |             |        |           |
 *       +-------------+        +-----------+
 * --------------------------------------------------------------------- */

void move_char_cache(cci_into, cci_from)
struct Char_Tbl   far  *cci_into;
struct Char_Tbl   far  *cci_from;
{
  ULONG_PTR *old_ptr;
  fix           width;
  ufix16        FAR *src_addr16, FAR *dst_addr16;
  ufix32        FAR *src_addr32, FAR *dst_addr32;       //@WIN: ufix=>ufix32


#ifdef DBG
   printf("move_char_cache() : dest = %lx, src = %lx\n",
           cci_into->bitmap, cci_from->bitmap);
   printf( "width = %d, height = %d\n",
            cci_into->box_w, cci_into->box_h);

#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE1) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = MOVE_CHAR_CACHE;
        put_Char_Tbl(cci_into);
        put_Char_Tbl(cci_from);
        *old_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
        return;
    }
  }

  width = cci_into->box_w;
  if(width & 0x1f) {
     width = cci_into->box_h * (width >> SHORTPOWER);
     src_addr16 = (ufix16 FAR *)cci_from->bitmap;
     dst_addr16 = (ufix16 FAR *)cci_into->bitmap;
     while(width--)
       *dst_addr16++ = *src_addr16++;
  }
  else {
     width = cci_into->box_h * (width >> WORDPOWER);
     src_addr32 = (ufix32 FAR *)cci_from->bitmap;  // @WIN: ufix=>ufix32
     dst_addr32 = (ufix32 FAR *)cci_into->bitmap;  // @WIN: ufix=>ufix32
     while(width--)
       *dst_addr32++ = *src_addr32++;
  }

  return;
} /* move_char_cache */

/* ----------------------------------------------------------------------
 * alloc_scanline(): allocate scanline table for font module
 *
 * ---------------------------------------------------------------------- */
/* @INTEL960 BEGIN D.S.Tseng */
static     SCANLINE     scan_buf[MAXSCANLINES] = {0}; /* 0; */
/* @INTEL960 END   D.S.Tseng */

SCANLINE   FAR *alloc_scanline(size)
fix     size;
{
/*  SCANLINE    *old_ptr;
 *
 *  if(fb_busy()){
 *      size = WORD_ALLIGN(size);
 *      if(alloc_gcb(size + GCB_SIZE1) != NIL){
 *        old_ptr = (SCANLINE *)gcb_ptr;
 *        gcb_ptr += size >> 2;
 *        GCB_count--;
 *      }
 *      else
 *        old_ptr = (SCANLINE *)GCB_BASE;
 *  }
 *  else
 *      old_ptr = (SCANLINE *)GCB_BASE;
 *  return((SCANLINE *)old_ptr);
 */
    return((SCANLINE *)scan_buf);

} /* alloc_scanline */

/* --------------------------------------------------------------------
 *      copy_char_cache   --  Copy Character Cache
 *
 *       cc_from                cc_into
 *       +-------------+        +-----------+
 *       |  + cc_xorig |        |           |
 *       |    cc_yorig =========>           |
 *       |             |        |           |
 *       |             |        +-----------+
 *       +-------------+
 * --------------------------------------------------------------------- */

void copy_char_cache(cci_into, cci_from, cc_xorig, cc_yorig)
struct Char_Tbl   far  *cci_into;
struct Char_Tbl   far  *cci_from;
fix                     cc_xorig;
fix                     cc_yorig;
{
        ufix16         FAR *src_addr16, FAR *srcptr, FAR *dstptr;
        fix             cc_width, cc_heigh;
        ULONG_PTR *old_ptr;         /*@WIN*/

#ifdef DBG
   printf("copy_char_cache() : dest = %lx, src = %lx\n",
           cci_into->bitmap, cci_from->bitmap);
   printf( "cc_xorig = %d, cc_yorig = %d, width = %d, height = %d\n",
            cc_xorig, cc_yorig, cci_into->box_w, cci_into->box_h);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = COPY_CHAR_CACHE;
                put_Char_Tbl(cci_into);
                put_Char_Tbl(cci_from);
                *gcb_ptr++ = cc_xorig;
                *gcb_ptr++ = cc_yorig;
                *old_ptr = (ULONG_PTR)gcb_ptr;    /*@WIN*/
                return;
           }
        }

/*MS  11-25-88 */
        if ( cc_xorig == 0 ) {

        /* cc_xorig = # of ufix16 of source bitmap width */
           cc_xorig = cci_from->box_w >> 4;
           cc_heigh = cci_into->box_h;
           dstptr = (ufix16 FAR *)cci_into->bitmap;
           src_addr16 = (ufix16 FAR *)((ufix16 FAR *)cci_from->bitmap +
                                cc_yorig * cc_xorig);

        /* cc_yorig = # of ufix16 of destination bitmap width */
           cc_yorig = cci_into->box_w >> SHORTPOWER;
           while ( cc_heigh--) {
                srcptr = src_addr16;
                cc_width = cc_yorig;
                while (cc_width--)
                    *dstptr++ = *srcptr++;
                src_addr16 += cc_xorig;
           }
           return;
        }

        cc_width = MIN(cci_into->box_w, cci_from->box_w-cc_xorig);
/* 10-20-90, JS
        cc_heigh = cci_into->box_h;

        src_addr16 = (ufix16 *)((ufix16 *)cci_from->bitmap +
                        cc_yorig * (cci_from->box_w >> SHORTPOWER) +
                       (cc_xorig >> SHORTPOWER) );
        cc_width = (cc_width << 16) | (cc_heigh);       (* 11-22-1988 *)
        cc_heigh = ((cc_xorig & 0xf) << 16) | (cci_from->box_w >> SHORTPOWER) ;
        GP_CHARBLT16_CC((ufix16 *)cci_into->bitmap, src_addr16,
                          cc_width, cc_heigh);
 */
        GP_CHARBLT16_CC((ufix16 FAR *)cci_into->bitmap,
                                  cc_width, cci_into->box_h,
                        cci_from, cc_xorig, cc_yorig);

        return;

} /* copy_char_cache */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_scan_cache()                                       *
 *                                                                      *
 *  Parameters: 1. address of character cache                           *
 *              2. width  of character cache                            *
 *              3. height of character cache                            *
 *              4. y coordinate of starting scanlines                   *
 *              5. number  of scanlines                                 *
 *              6. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_scan_cache(cc_entry, cc_width, cc_heigh, ys_lines, no_lines, scanline)
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
fix                     ys_lines;
fix                     no_lines;
SCANLINE                FAR *scanline;
{
        ULONG_PTR *old_ptr;           /*@WIN*/

#ifdef  DBG
   printf("fill_scan_cache:  %lx %x %x  %x %x\n",
           cc_entry, cc_width, cc_heigh, ys_lines, no_lines);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_SCAN_CACHE;
                *gcb_ptr++ = (fix )cc_entry;
                *gcb_ptr++ = cc_width;
                *gcb_ptr++ = cc_heigh;
                *gcb_ptr++ = ys_lines;
                *gcb_ptr++ = no_lines;
                put_scanline(no_lines, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

        BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, cc_width, cc_heigh, 1);

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif
        GP_SCANLINE16(&SCC_Bmap,
                       FC_SOLID, ys_lines,
                       no_lines, scanline);
}



/* -------------------------------------------------------------------
 *      fill_pixel_cache  --  Filling Pixel List into Character Cache
 *MS    Note : cc_width should be multiple of 16
 * ------------------------------------------------------------------- */

void fill_pixel_cache(cc_entry, cc_width, cc_heigh, no_pixel, pixelist)
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
fix                     no_pixel;
PIXELIST                FAR *pixelist;
{
//      fix16           FAR *ptr;       //@WIN
//      PIXELIST        xc, yc;         //@WIN
        ULONG_PTR *old_ptr;   /*@WIN*/

#ifdef DBG
   printf("fill_pixel_cache() : ");
   printf("cc_entry = %lx, cc_width = %d,", cc_entry, cc_width);
   printf("no_pixel = %d\n", no_pixel);
#endif

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_PIXEL_CACHE;
                *gcb_ptr++ = (fix )cc_entry;
                *gcb_ptr++ = cc_width;
                *gcb_ptr++ = cc_heigh;
                *gcb_ptr++ = no_pixel;
                put_pixelist(no_pixel, pixelist);
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
            }
        }

        BM_ENTRY(SCC_Bmap, cc_entry, cc_width, cc_heigh, 1)
        GP_PIXELS16(&SCC_Bmap,
                     FC_SOLID,
                    no_pixel, pixelist);

        return;

} /* fill_pixel_cache */



/* ******************************************************************** *
 *                                                                      *
 *  Function:   init_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box                             *
 *              2. x origin of bounding box                             *
 *              3. width  of bounding box                               *
 *              4. height of bounding box                               *
 *              5. address of character cache                           *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
init_cache_page(bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
gmaddr                  cc_entry;
{
        fix32           i;                      /*@WIN*/
        ULONG_PTR *old_ptr;           /*@WIN*/
        ULONG_PTR *ptr;               /*@WIN*/

        /* Expand bb_xorig to 4 times; @GRAY */
        if (GSptr->device.nuldev_flg == GRAYDEV) {      /* Jack Liaw 7-26-90 */
                bb_xorig= bb_xorig << 2;
        }

#ifdef  DBG
    printf("init_cache_page:  %ld %ld %ld %ld  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif
#ifdef  DBGcmb
    printf("init_cache_page:  %ld %ld %ld %ld  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = INIT_CACHE_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                *gcb_ptr++ = (fix )cc_entry;
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
           }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }

        CC_Xorig = BM_XORIG;
        CC_Yorig = BM_YORIG;
        BB_Xorig = bb_xorig;
        BB_Yorig = bb_yorig;
        BB_Width = bb_width;
        BB_Heigh = bb_heigh;

        if (bb_xorig < BM_XORIG) {
           CC_Xorig = -bb_xorig;
           BB_Xorig = BM_XORIG;
           BB_Width += bb_xorig;
        }   /* if   */
        else if ((bb_xorig + bb_width) > FB_WIDTH)   /* Y.C. 10-19-88 */
                BB_Width = FB_WIDTH - BB_Xorig;

        if (bb_yorig < BM_YORIG) {
           CC_Yorig = -bb_yorig;
           BB_Yorig = BM_YORIG;
           BB_Heigh += bb_yorig;
        }   /* if   */
        else if ((bb_yorig + bb_heigh) > FB_HEIGH)   /* Y.C. 10-19-88 */
                 BB_Heigh = FB_HEIGH - BB_Yorig;

        if (BB_Width <= 0 || BB_Heigh <= 0)
                return;

        CC_Width = BB_Width;
        BB_Width = WORD_ALLIGN(BB_Width);

#ifdef  DBGcmb
    printf("BB:  %ld %ld %ld %ld\n", BB_Xorig, BB_Yorig, BB_Width, BB_Heigh);
    printf("CC:  %ld %ld\n", CC_Xorig, CC_Yorig);
#endif

        BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, bb_width, bb_heigh, 1);
        BM_ENTRY(CMB_Bmap, (gmaddr)CMB_BASE, BB_Width, BB_Heigh, 1);

    /*  clear clipping mask buffer  */

/*MS
 *      GP_BITBLT16(&CMB_Bmap, BM_XORIG, BM_YORIG,
 *                   CC_Width, CC_Heigh,
 *                   FC_CLEAR,
 *                  &CMB_Bmap, BM_XORIG, BM_YORIG);
 */
        ptr = (ULONG_PTR *)CMB_BASE;           /* @WIN 04-20-92 */
        i = BB_Heigh * (BB_Width >> 5);
        while(i--)
              *ptr++ = 0L;

}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   clip_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT USED)      *
 *              2. x origin of bounding box             (NOT USED)      *
 *              3. width  of bounding box               (NOT USED)      *
 *              4. height of bounding box               (NOT USED)      *
 *              5. y coordinate of starting scanlines                   *
 *              6. number  of scanlines                                 *
 *              7. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
clip_cache_page(ys_lines, no_lines, scanline)
fix                     ys_lines;
fix                     no_lines;
SCANLINE            FAR *scanline;
{
//  fix                 bb_xorig;               //@WIN
//  fix                 bb_yorig;               //@WIN
    ULONG_PTR *old_ptr;           /*@WIN*/

#ifdef  DBG
    printf("clip_cache_page:  %x %x\n", ys_lines, no_lines);
#endif

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE2) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = CLIP_CACHE_PAGE;
                *gcb_ptr++ = ys_lines;
                *gcb_ptr++ = no_lines;
                put_scanline(no_lines, scanline);
                *old_ptr = (ULONG_PTR)gcb_ptr;     /*@WIN*/
                return;
           }
        }

        if(BB_Width <= 0 || BB_Heigh <= 0)
                return;

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif

        if (conv_SL(no_lines, scanline,
                    BB_Xorig, BB_Yorig, CC_Width, BB_Heigh) == 0)
                return;

#ifdef  DBGscanline
   get_scanlist(ys_lines, no_lines, scanline);
#endif

    /*  setup clipping mask buffer from scanlines of clippath  */

#ifdef LBODR
        GP_SCANLINE32(&CMB_Bmap,
                       FC_SOLID,
                       ys_lines - BB_Yorig, no_lines, scanline);
#else
        GP_SCANLINE16(&CMB_Bmap,
                       FC_SOLID,
                       ys_lines - BB_Yorig, no_lines, scanline);
#endif
        return;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT USED)      *
 *              2. x origin of bounding box             (NOT USED)      *
 *              3. width  of bounding box               (NOT USED)      *
 *              4. height of bounding box               (NOT USED)      *
 *              5. address of character cache           (NOT USED)      *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
/*MS 11-25-88 */
void far
fill_cache_page()
{
    ULONG_PTR *old_ptr;           /*@WIN*/
//  ufix16              FAR *src_addr16;        //@WIN
//  ufix32              FAR *src_addr32;        //@WIN
    ufix32              huge *dst_addr32; /*@WIN 04-15-92*/
    ufix32              bb_width, bb_heigh;                /*@WIN 04-15-92*/
    fix32               scc_width;

#ifdef  DBG
    printf("fill_cache_page...\n");
#endif

/*@CONT_PRI, MSLin 9/24/90*/
        if(GCB_count)
            flush_gcb(TRUE);

        if (FB_busy) {
           if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = FILL_CACHE_PAGE;
                *old_ptr = (ULONG_PTR)gcb_ptr;             /*@WIN*/
                return;
           }
        }

        if(BB_Width <= 0 || BB_Heigh <= 0)
                return;

    /*
     *  clip character cache with clipping mask buffer into
     *  a clipped character cache
     */
/*
 *  GP_BITBLT16(&CMB_Bmap, BM_XORIG, BM_YORIG,
 *             CC_Width, BB_Heigh,
 *             FC_CLIPS,
 *            &SCC_Bmap, CC_Xorig, CC_Yorig);
 */
        scc_width = SCC_Bmap.bm_cols;
        if (scc_width & 0x1f) {
/* 10-20-90, JS
           src_addr16 = (ufix16 *)((ufix16 *)SCC_Bmap.bm_addr +
                                 CC_Yorig * (scc_width >> SHORTPOWER) +
                                 (CC_Xorig >> SHORTPOWER) );
           bb_width = (CC_Width << 16) | (BB_Heigh);  (* 11-22-1988 *)
           bb_heigh = ((CC_Xorig & 0xf) << 16) | (scc_width >> SHORTPOWER) ;
           GP_CHARBLT16_CLIP((ufix16 *)CMB_Bmap.bm_addr, src_addr16,
                                       bb_width, bb_heigh);
 */
           GP_CHARBLT16_CLIP(&CMB_Bmap, CC_Width, BB_Heigh,
                             &SCC_Bmap, CC_Xorig, CC_Yorig);
        } else {
/* 10-20-90, JS
           src_addr32 = (ufix *)((ufix *)SCC_Bmap.bm_addr +
                                 CC_Yorig * (scc_width >> WORDPOWER) +
                                 (CC_Xorig >> WORDPOWER) );
           bb_width = (CC_Width << 16) | (BB_Heigh);   (* 11-22-1988 *)
           bb_heigh = ((CC_Xorig & 0x1f) << 16) | (scc_width >> WORDPOWER) ;
           GP_CHARBLT32_CLIP((ufix *)CMB_Bmap.bm_addr, src_addr32,
                                     bb_width, bb_heigh);
 */
           GP_CHARBLT32_CLIP(&CMB_Bmap, CC_Width, BB_Heigh,
                             &SCC_Bmap, CC_Xorig, CC_Yorig);
        }

    /*
     * fill Clipping Mask buffer into frame buffer
     */
/*
 *      GP_BITBLT32(&FBX_Bmap, BB_Xorig, BB_Yorig,
 *                 BB_Width, BB_Heigh,
 *                 FC_Paint,
 *                &CMB_Bmap, BM_XORIG, BM_YORIG);
 */
        if (HTP_Type != HT_MIXED ){
           dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                        (ufix32)BB_Yorig * ((ufix32)FB_WIDTH >> WORDPOWER) +
                        (ufix32)(BB_Xorig >> WORDPOWER) );  /*@WIN*/
           bb_width = ((ufix32)BB_Width << 16) | (BB_Heigh);    /*@WIN*/
           bb_heigh = ((ufix32)(BB_Xorig & 0x1f) << 16) | FC_Paint; /*@WIN*/
           GP_CHARBLT32((ufix32 huge *)dst_addr32, (ufix32 FAR *)CMB_Bmap.bm_addr,
                        bb_width, bb_heigh);    /*@WIN 04-15-92*/

        } else {

#ifdef LBODR
           GP_BITBLT32(&FBX_Bmap, BB_Xorig, BB_Yorig,
                        BB_Width, BB_Heigh,
                        FC_Paint,
                       &CMB_Bmap, BM_XORIG, BM_YORIG);
#else
           GP_BITBLT16_32(&FBX_Bmap, BB_Xorig, BB_Yorig,
                           BB_Width, BB_Heigh,
                           FC_Paint,
                          &CMB_Bmap, BM_XORIG, BM_YORIG);
#endif

        }

} /* fill_cache_page */


/* ******************************************************************** *
 *                                                                      *
 *  Function:   draw_cache_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box                             *
 *              2. x origin of bounding box                             *
 *              3. width  of bounding box                               *
 *              4. height of bounding box                               *
 *              5. address of character cache                           *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
draw_cache_page(bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry)
fix32                   bb_xorig;
fix32                   bb_yorig;
ufix32                  bb_width;
ufix32                  bb_heigh;
gmaddr                  cc_entry;
{
        ULONG_PTR *old_ptr;       /*@WIN*/
        ufix32      huge *dst_addr32;   /*@WIN 04-15-92*/
#ifdef LBODR
        ufix16      huge *dst_addr16;   /*@WIN 04-15-92*/
#endif

        /* Expand bb_xorig to 4 times; @GRAY */
        if (GSptr->device.nuldev_flg == GRAYDEV) {      /* Jack Liaw 7-26-90 */
                bb_xorig= bb_xorig << 2;
        }

#ifdef  DBG
    printf("draw_cache_page:  %x %x %x %x  %lx\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, cc_entry);
#endif

/*@CONT_PRI, MSLin 9/24/90*/

        if ( ((ufix32)CCB_BASE > (ufix32)cc_entry) ||
             (((ufix32)CCB_BASE + (ufix32)CCB_SIZE) <= (ufix32)cc_entry) )
            flush_gcb(TRUE);

        if (FB_busy) {
            if (alloc_gcb(GCB_SIZE1) != NIL) {
                old_ptr = gcb_ptr++;
                *gcb_ptr++ = DRAW_CACHE_PAGE;
                *gcb_ptr++ = bb_xorig;
                *gcb_ptr++ = bb_yorig;
                *gcb_ptr++ = bb_width;
                *gcb_ptr++ = bb_heigh;
                *gcb_ptr++ = cc_entry;         /*@WIN*/
                *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
                return;
            }
        }

    /*  expand halftone before rendering onto frame buffer  */
        if (HTP_Flag == HT_CHANGED) {                    /* @IMAGE-1 */
           HTP_Flag =  HT_UPDATED;
           expand_halftone();
        }
/*
 *  BB_Xorig = BM_ALIGN(bb_xorig);
 *  BB_Yorig = bb_yorig;
 *  BB_Width = BM_BOUND((bb_xorig - BB_Xorig) + bb_width);
 *  BB_Heigh = bb_heigh;
 *
 *  CC_Xorig = bb_xorig - BB_Xorig;
 *  CC_Yorig = BM_YORIG;
 *  CC_Width = bb_width;
 *  CC_Heigh = bb_heigh;
 */

        if (HTP_Type != HT_MIXED) {

        /*  fill the character cache onto frame buffer
         *  for black halftone by FC_MERGE
         */
        /* 11-04-1988 GP_BITBLT16 --> gp_charblt */
/*MS        GP_BITBLT16(&FBX_Bmap, bb_xorig, bb_yorig,
 *                       bb_width, bb_heigh,
 *                       FC_MERGE,
 *                      &SCC_Bmap, BM_XORIG, BM_YORIG);
 */
            if(bb_width & 0x1f) {
#ifndef LBODR
                dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                               bb_yorig * (FB_WIDTH >> WORDPOWER) +
                              (bb_xorig >> WORDPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0x1f) << 16 | FC_Paint;
                GP_CHARBLT16((ufix32 huge *)dst_addr32, (ufix16 FAR *)cc_entry,
                                bb_width, bb_heigh);    /*@WIN 04-15-92*/
#else
                dst_addr16 = (ufix16 FAR *)((ufix16 FAR *)FB_ADDR +
                               bb_yorig * (FB_WIDTH >> SHORTPOWER) +
                              (bb_xorig >> SHORTPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0xf) << 16 | FC_Paint;
                GP_CHARBLT16((ufix16 FAR *)dst_addr16, (ufix16 FAR *)cc_entry,
                        bb_width, bb_heigh);
#endif
            } else {
                dst_addr32 = (ufix32 huge *)((ufix32 huge *)FB_ADDR + /*@WIN*/
                               bb_yorig * (FB_WIDTH >> WORDPOWER) +
                              (bb_xorig >> WORDPOWER) );
                bb_width = (bb_width << 16) | (bb_heigh);
                bb_heigh = (bb_xorig & 0x1f) << 16 | FC_Paint;
                GP_CHARBLT32((ufix32 huge *)dst_addr32, (ufix32 FAR *)cc_entry,
                                bb_width, bb_heigh);    /*@WIN 04-15-92*/
            }
        } else {
        /*
         *  fill the character cache onto frame buffer with
         *  halftoning directly
         */

            BM_ENTRY(SCC_Bmap, (gmaddr)cc_entry, (fix)bb_width, (fix)bb_heigh, 1); //@WIN
#ifndef LBODR
            GP_BITBLT16_32(&FBX_Bmap, (fix)bb_xorig, (fix)bb_yorig,
                            (fix)bb_width, (fix)bb_heigh,       /*@WIN*/
                            FC_MERGE | HT_APPLY,
                           &SCC_Bmap, BM_XORIG, BM_YORIG);
#else
            GP_BITBLT16(&FBX_Bmap, bb_xorig, bb_yorig,
                         bb_width, bb_heigh,
                         FC_MERGE | HT_APPLY,
                        &SCC_Bmap, BM_XORIG, BM_YORIG);
#endif
                                                      /* @HT HTB_Bmap */
        }   /* if   */
} /* draw_cache_page */


/* CIRL: Begin, 12/5/90, Danny */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_cache_cache()                                      *
 *                                                                      *
 *  Created By: Danny Lu, 12/5/90                                       *
 *                                                                      *
 *  Description: To fill the bitmap from cache to cache                 *
 *                                                                      *
 *  Parameters: 1. destination cache information                        *
 *              2. source cache information                             *
 *                                                                      *
 *  Called by:  ry_fill_shape() in ry_font.c                            *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_cache_cache(dest, src)
struct Char_Tbl  FAR *dest, FAR *src;
{
    fix16  org_x, org_y;
//  byte   FAR *sptr, FAR *dptr;                @WIN
    fix    DX, DY, W, H, SX, SY;
    struct bitmap DST, SRC;

    org_x = (fix16)GSptr->position.x - src->ref_x;
    org_y = (fix16)GSptr->position.y - src->ref_y;

#ifdef DBGfcc
    printf("org_x = %d, org_y = %d\n", org_x, org_y);
    printf("SRC: box_w = %d, box_h = %d\n", src->box_w, src->box_h);
    printf("DEST: box_w = %d, box_h = %d\n", dest->box_w, dest->box_h);
#endif

    if (org_x < 0) {
        W  = src->box_w + org_x;
        if (W <= 0)
            return;
        if (W > dest->box_w)
            W = dest->box_w;

        DX = 0;
        SX = -org_x;
    }
    else {
        if (org_x >= dest->box_w)
            return;
        if ((org_x + src->box_w) > dest->box_w)
            W = dest->box_w - org_x;
        else
            W = src->box_w;

        DX = org_x;
        SX = 0;
    }

    if (org_y < 0) {
        H  = src->box_h + org_y;
        if (H <= 0)
            return;
        if (H > dest->box_h)
            H = dest->box_h;

        DY = 0;
        SY = -org_y;
    }
    else {
        if (org_y >= dest->box_h)
            return;
        if ((org_y + src->box_h) > dest->box_h)
            H = dest->box_h - org_y;
        else
            H = src->box_h;

        DY = org_y;
        SY = 0;
    }

    SRC.bm_addr = (gmaddr)src->bitmap;
    SRC.bm_cols = (fix)src->box_w;
    SRC.bm_rows = (fix)src->box_h;
    SRC.bm_bpp  = 1;

    DST.bm_addr = (gmaddr)dest->bitmap;
    DST.bm_cols = (fix)dest->box_w;
    DST.bm_rows = (fix)dest->box_h;
    DST.bm_bpp  = 1;

#ifdef DBGfcc
    printf("BitBlt: ADDR = %lx, DX = %x, DY = %x, W = %x, H = %x, ADDR = %lx, SX = %x, SY = %x\n", DST.bm_addr, DX, DY, W, H, SRC.bm_addr, SX, SY);
#endif
    GP_CACHEBLT16(&DST, DX, DY, W, H, &SRC, SX, SY);

} /* fill_cache_cache() */
/* CIRL: End, 12/5/90, Danny */



/* ************* Image ************************************************ */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_seed_patt()                                        *
 *                                                                      *
 *  Parameters: 1. width  of image seed pattern                         *
 *              2. height of image seed pattern                         *
 *              3. number  of scanlines                                 *
 *              4. pointer of scanlines                                 *
 *                                                                      *
 *  Called by:  scan_conversion()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
fill_seed_patt(image_type, seed_index, sp_width, sp_heigh, no_lines, scanline)
ufix                    image_type;                             /* 05-25-89 */
fix                     seed_index;
fix                     sp_width;
fix                     sp_heigh;
fix                     no_lines;
SCANLINE            FAR *scanline;
{
        struct bitmap           FAR *isp_desc;
        ULONG_PTR *old_ptr;   /*@WIN*/
        fix                     i, FAR *ptr;
        fix16                   FAR *ptr16;

#ifdef  DBG
    printf("fill_seed_patt:   %x %x %x  (%x)\n",
           sp_width, sp_heigh, no_lines, seed_index);
#endif
        if (FB_busy) {
           if(alloc_gcb(GCB_SIZE2) != NIL) {
              old_ptr = gcb_ptr++;
              *gcb_ptr++ = FILL_SEED_PATT;
              *gcb_ptr++ = (fix )image_type;
              *gcb_ptr++ = seed_index;
              *gcb_ptr++ = sp_width;
              *gcb_ptr++ = sp_heigh;
              *gcb_ptr++ = no_lines;
              put_scanline(no_lines, scanline);
              *old_ptr = (ULONG_PTR)gcb_ptr;               /*@WIN*/
              return;
           }
        }


        ISP_Repeat = -1;

        isp_desc = &ISP_Bmap[seed_index];
        SP_Width = sp_width;                                    /* @IMAGE-2 */
        SP_Heigh = sp_heigh;                                    /* @IMAGE-2 */

        if (image_type == F_TO_PAGE) {                          /* 05-25-89 */
           BM_ENTRY(ISP_Bmap[seed_index],                       /* @IMAGE-1 */
                    ISP_BASE + ISP_SIZE * seed_index,
                    BM_BOUND(sp_width), sp_heigh, 1)

    /*  clear the image seed pattern  */
           ptr = (fix FAR *) isp_desc->bm_addr;                     /* 10-06-88 */
           i= SP_Heigh * (BM_BOUND(SP_Width) >> 5);
           while(i--)
                *ptr++ = 0L;

#ifdef  DBGscanline
   get_scanlist(0, no_lines, scanline);
#endif
    /*  fill scanlines onto the image seed pattern  */
           GP_SCANLINE32(isp_desc,
                         FC_SOLID,
                         BM_YORIG, no_lines, scanline);
        } else {
           BM_ENTRY(ISP_Bmap[seed_index],                       /* @IMAGE-1 */
                    ISP_BASE + ISP_SIZE * seed_index,
                    CC_BOUND(sp_width), sp_heigh, 1)

        /*  clear the image seed pattern  */
           ptr16 = (fix16 FAR *) isp_desc->bm_addr;                 /* 10-06-88 */
           i= SP_HEIGH * (SP_WIDTH >> 4);
           while(i--)
                 *ptr16++ = 0L;
        /*  fill scanlines onto the image seed pattern  */
           GP_SCANLINE16(isp_desc,
                         FC_SOLID,
                         BM_YORIG, no_lines, scanline);
        }

/*      seed_flag = 0; */

}


/* ********************************************************************
 *
 *  Function:   init_image_page(), clear image clipping mask buffer
 *
 *  Parameters: 1. bounding box Xorig
 *              2. bounding box Yorig
 *              3. bounding box Width
 *              4. bounding box Heigh
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
init_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh)
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
{
        fix     i, FAR *ptr;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
      printf("init_image_page()..\n");
      printf("bb_x=%lx, bb_y=%lx, bb_w=%lx, bb_h=%lx\n",
              bb_xorig, bb_yorig, bb_width, bb_heigh);
#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE2) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = INIT_IMAGE_PAGE;
        *gcb_ptr++ = bb_xorig;
        *gcb_ptr++ = bb_yorig;
        *gcb_ptr++ = bb_width;
        *gcb_ptr++ = bb_heigh;
        *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
        return;
    }
  }
    /*  update maximum expansion width for image operation  */
    if (ISP_Repeat != RP_Width)                         /* GVC-V3 11-01-88 */
    {
        ISP_Repeat = RP_Width;

        for (HTB_Expand = RP_Width; (HTB_Expand << 1) < HTB_XMAX;
             HTB_Expand = HTB_Expand << 1)
        {
            if (HTB_Expand & BM_PIXEL_MASK)
                continue;

            if (HTB_Expand >= SP_Width)
                break;
        }

        if ((HTB_Expand << 1) < HTB_XMAX)
        {
            HTB_Modula = HTB_Expand;
            HTB_Expand = HTB_Expand << 1;
        }
        else
        {
            HTB_Modula = FB_WIDTH;
            HTB_Expand = FB_WIDTH;
        }
    }

    /*  record x, y origin of CMB  */
    CMB_Xorig = bb_xorig;
    CMB_Yorig = bb_yorig;

    BB_Xorig = bb_xorig;
    BB_Yorig = bb_yorig;
    BB_Width = bb_width;
    BB_Heigh = bb_heigh;

    BM_ENTRY(CMB_Bmap, CMB_BASE, WORD_ALIGN(BB_Width), BB_Heigh, 1)

    /*  clear clipping mask buffer  */
        ptr = (fix FAR *)CMB_BASE;                       /* 10-06-88 */
        i = BB_Heigh * (BB_Width >> 5);
        while(i--)
           *ptr++ = 0;
} /* init_image_page */


/* ********************************************************************
 *
 *  Function:   clip_image_page(), fill image clipping mask buffer
 *
 *  Parameters: 1. scanline starting y_coordinate
 *              2. # of scanlines
 *              3. pointer to scanline table
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
clip_image_page(ys_lines, no_lines, scanline)
fix                     ys_lines;
fix                     no_lines;
SCANLINE           FAR *scanline;
{
        fix     no_segts;
        ULONG_PTR *old_ptr;        /*@WIN*/

#ifdef DBG
   printf("clip_image_page()  ");
   printf("%x, %x, %lx\n", ys_lines, no_lines, scanline);
#endif

  if(FB_busy) {
    if(alloc_gcb(GCB_SIZE2) != NIL) {
        old_ptr = gcb_ptr++;
        *gcb_ptr++ = CLIP_IMAGE_PAGE;
        *gcb_ptr++ = ys_lines;
        *gcb_ptr++ = no_lines;
        put_scanline(no_lines, scanline);
        *old_ptr = (ULONG_PTR)gcb_ptr;            /*@WIN*/
        return;
    }
  }
    if ((no_segts = conv_SL(no_lines, scanline,
                            BB_Xorig, BB_Yorig, BB_Width, BB_Heigh)) == 0)
        return;

    /*  setup clipping mask buffer from scanlines of clippath  */
    GP_SCANLINE32(&CMB_Bmap,                       /* GVC-V3 11-01-88 */
                   FC_SOLID,
                   ys_lines - BB_Yorig, no_lines, scanline);
} /* clip_image_page */


/* ********************************************************************
 *
 *  Function:   fill_image_page(), fill image seed pattern into page
 *              with image clipping mask buffer "AND" operation.
 *
 *  Parameters: 1. image seed index
 *
 *  Return:     none
 *
 * ********************************************************************
 */
void far
/*fill_image_page(sp_index)
fix                     sp_index;*/
fill_image_page(isp_index)              /* 3-13-91, Jack */
fix16                   isp_index;      /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap  FAR *isp_desc;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("fill_image_page:  %x \n", sp_index);
#endif
    if(GCB_count)
       flush_gcb(TRUE);
    /*  expand halftone before rendering onto frame buffer  */
    if (ISP_Flag == HT_CHANGED)                                 /* @IMAGE-1 */
    {
        ISP_Flag =  HT_UPDATED;

        HTB_Xmax = HTB_Expand;                                  /* @IMAGE-1 */
        expand_halftone();
        HTB_Xmax = HTB_XMAX;                                    /* @IMAGE-1 */
    }

/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        GP_PATBLT_M(&FBX_Bmap, nd_point->SAMPLE_BB_LX,
                               nd_point->SAMPLE_BB_LY,
                     SP_Width, SP_Heigh,                (* GVC-V3 11-01-88 *)
                     FC_Paint, isp_desc);
(*                     isp_desc, BM_XORIG, BM_YORIG);*)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {
        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        //GP_PATBLT_M(&FBX_Bmap, isp->bb_x, isp->bb_y,  @WINFLOW
        //           SP_Width, SP_Heigh,
        //           FC_Paint, isp_desc);
        if (bGDIRender)
            // DJC GDIBitmap(isp->bb_x, isp->bb_y,
            // DJC           SP_Width, SP_Heigh, (ufix16)FC_Paint,
            // DJC            PROC_PATBLT_M, (LPSTR)isp_desc);
            ; // DJC
        else
            GP_PATBLT_M(&FBX_Bmap, isp->bb_x, isp->bb_y,
                       SP_Width, SP_Heigh,
                       FC_Paint, isp_desc);
    }   /* for, 3-13-91, Jack */
} /* fill_image_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   draw_image_page()                                       *
 *                                                                      *
 *  Parameters: 1. x origin of bounding box             (NOT FOR RISC)  *
 *              2. x origin of bounding box             (NOT FOR RISC)  *
 *              3. width  of bounding box               (NOT FOR RISC)  *
 *              4. height of bounding box               (NOT FOR RISC)  *
 *              5. index  of sample list                                *
 *                                                                      *
 *  Called by:  op_image(), imagemask_shape()                           *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
/*draw_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh, sp_index)*/
draw_image_page(bb_xorig, bb_yorig, bb_width, bb_heigh, isp_index) /* 3-13-91, Jack */
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
/*fix                     sp_index;*/
fix16                   isp_index;      /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap  FAR *isp_desc;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("draw_image_page:  %x %x %x %x  %x\n",
           bb_xorig, bb_yorig, bb_width, bb_heigh, sp_index);
#endif

    if(GCB_count)
       flush_gcb(TRUE);


    /*  update maximum expansion width for image operation  */
    if (ISP_Repeat != RP_Width)                         /* GVC-V3 11-01-88 */
    {
        ISP_Repeat =  RP_Width;

        for (HTB_Expand = RP_Width; (HTB_Expand << 1) < HTB_XMAX;
             HTB_Expand = HTB_Expand << 1)
        {
            if (HTB_Expand & BM_PIXEL_MASK)
                continue;

            if (HTB_Expand >= SP_Width)
                break;
        }

        if ((HTB_Expand << 1) < HTB_XMAX)
        {
            HTB_Modula = HTB_Expand;
            HTB_Expand = HTB_Expand << 1;
        }
        else
        {
            HTB_Modula = FB_WIDTH;
            HTB_Expand = FB_WIDTH;
        }
    }

    /*  expand halftone before rendering onto frame buffer  */
    if (ISP_Flag == HT_CHANGED)                                 /* @IMAGE-1 */
    {
        ISP_Flag =  HT_UPDATED;

        HTB_Xmax = HTB_Expand;                                  /* @IMAGE-1 */
        expand_halftone();
        HTB_Xmax = HTB_XMAX;                                    /* @IMAGE-1 */
    }

/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        GP_PATBLT(&FBX_Bmap, nd_point->SAMPLE_BB_LX,
                             nd_point->SAMPLE_BB_LY,
                   SP_Width, SP_Heigh,                  (* GVC-V3 11-01-88 *)
                   FC_Paint, isp_desc);
(*                   isp_desc, BM_XORIG, BM_YORIG); *)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {

        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        //GP_PATBLT(&FBX_Bmap, isp->bb_x, isp->bb_y,    @WINFLOW
        //           SP_Width, SP_Heigh,
        //           FC_Paint, isp_desc);
        if (bGDIRender)
            // DJC GDIBitmap(isp->bb_x, isp->bb_y,
            // DJC          SP_Width, SP_Heigh, (ufix16)FC_Paint,
            // DJC         PROC_PATBLT, (LPSTR)isp_desc);
            ; // DJC
        else
            GP_PATBLT(&FBX_Bmap, isp->bb_x, isp->bb_y,
                     SP_Width, SP_Heigh,
                     FC_Paint, isp_desc);

    }   /* for, 3-13-91, Jack */

} /* draw_image_page */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   fill_image_cache()                                      *
 *                                                                      *
 *  Parameters: 1. address of character cache                           *
 *              2. width  of character cache                            *
 *              3. height of character cache                            *
 *              4. index  of sample list                                *
 *                                                                      *
 *  Called by:  imagemask_shape()                                       *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
/*fill_image_cache(cc_entry, cc_width, cc_heigh, sp_index)*/
fill_image_cache(cc_entry, cc_width, cc_heigh, isp_index) /* 3-13-91, Jack */
gmaddr                  cc_entry;
fix                     cc_width;
fix                     cc_heigh;
/*fix                     sp_index;*/
fix16                   isp_index;     /* 3-13-91, Jack */
{
//  fix                 sp_count;       //@WIN
    fix                 sd_index;
//  struct nd_hdr      FAR *nd_point;   //@WIN
    struct bitmap      FAR *isp_desc;
/*  ufix32   i, j, data, *ptr; */
    fix                width, heigh;
    struct isp_data     FAR *isp;           /* 3-13-91, Jack */

#ifdef  DBG
    printf("fill_image_cache: %lx %x %x  %x\n",
           cc_entry, cc_width, cc_heigh, isp_index);
#endif

        if(GCB_count)
          flush_gcb(TRUE);

/*
 *      if (seed_flag == 0) {
 *          for (i = 0; i < 16; i++) {
 *              ptr = (ufix32 *)ISP_Bmap[i].bm_addr;
 *              for (j = 0; j < ISP_Bmap[i].bm_rows; j++) {
 *                  data = (*ptr << 16) + (*ptr >> 16);
 *                  *ptr++ = data;
 *                  data = (*ptr << 16) + (*ptr >> 16);
 *                  *ptr++ = data;
 *              }
 *          }
 *          seed_flag = 1;
 *      }
 */

    BM_ENTRY(SCC_Bmap, cc_entry, cc_width, cc_heigh, 1)
/*  for (; sp_index != NULLP; sp_index = nd_point->next)
    {
        nd_point = &node_table[sp_index];
        sd_index = nd_point->SEED_INDEX;
        isp_desc = &ISP_Bmap[sd_index];
        width = MIN(SP_Width, cc_width-nd_point->SAMPLE_BB_LX); (*06/02/89 MS*)
        heigh = MIN(SP_Heigh, cc_heigh-nd_point->SAMPLE_BB_LY); (*06/02/89 MS*)
        GP_PATBLT_C(&SCC_Bmap, nd_point->SAMPLE_BB_LX,
                               nd_point->SAMPLE_BB_LY,
                     width, heigh,
                (*   SP_Width, SP_Heigh,                          06/02/89 MS*)
                     FC_MERGE, isp_desc);
(*                     isp_desc, BM_XORIG, BM_YORIG); *)
    }   (* for  */
    for (; isp_index != NULLP; isp_index = isp->next) {
        isp = &isp_table[isp_index];
        sd_index = isp->index;
        isp_desc = &ISP_Bmap[sd_index];
        width = MIN(SP_Width, cc_width-isp->bb_x);
        heigh = MIN(SP_Heigh, cc_heigh-isp->bb_y);
        GP_PATBLT_C(&SCC_Bmap, isp->bb_x,
                               isp->bb_y,
                     width, heigh,
                     FC_MERGE, isp_desc);
    }   /* for, 3-13-91, Jack */

} /* fill_image_cache */


/* Following 2 routines for stroke improvements  -jwm, 3/18/21, -begin- */

extern void do_fill_box ();

void fill_box (ul_coord, lr_coord)
struct coord_i FAR *ul_coord, FAR *lr_coord;
{
    struct coord_i      FAR *tmp_coord;
    ULONG_PTR *old_ptr;                /*@WIN*/

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = FILL_BOX;
            tmp_coord = (struct coord_i FAR *) gcb_ptr;
            *tmp_coord++ = *ul_coord;
            *tmp_coord++ = *lr_coord;
            gcb_ptr =  (ULONG_PTR *)tmp_coord;         /*@WIN*/
            *old_ptr = (ULONG_PTR)gcb_ptr;                /*@WIN*/
            return;
            }
        }
    else
        do_fill_box (ul_coord, lr_coord);

}



extern void do_fill_rect ();

void fill_rect (rect1)
struct line_seg_i FAR *rect1;
{
    struct line_seg_i   FAR *tmp_line_seg;
    ULONG_PTR *old_ptr;        /*@WIN*/

    if (FB_busy) {
        if (alloc_gcb(GCB_SIZE1) != NIL) {
            old_ptr = gcb_ptr++;
            *gcb_ptr++ = FILL_RECT;
            tmp_line_seg = (struct line_seg_i FAR *) gcb_ptr;
            *tmp_line_seg++ = *rect1;
            gcb_ptr =  (ULONG_PTR *)tmp_line_seg;      /*@WIN*/
            *old_ptr = (ULONG_PTR)gcb_ptr;        /*@WIN*/
            return;
            }
        }
    else
        do_fill_rect (rect1);

}
/*  -jwm, 3/18/21, -end- */

/* ******************************************************************** *
 *                                                                      *
 *  Function:   gwb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of space of GWB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
gwb_space(gwb_size)
fix32              far *gwb_size;
{
        *gwb_size = GWB_SIZE;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   ccb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of address of CCB                            *
 *              2. pointer of space of CCB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
ccb_space(ccb_base, ccb_size)
gmaddr            far  *ccb_base;
fix32             far  *ccb_size;
{
        *ccb_base = CCB_BASE;
        *ccb_size = CCB_SIZE;
}


/* ******************************************************************** *
 *                                                                      *
 *  Function:   cmb_space()                                             *
 *                                                                      *
 *  Parameters: 1. pointer of space of CMB                              *
 *                                                                      *
 *  Called by:  TBD.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
cmb_space(cmb_size)
fix32              far *cmb_size;
{
        *cmb_size = CMB_SIZE;
}



/* ******************************************************************** *
 *                                                                      *
 *  Function:   get_fontdata()                                          *
 *                                                                      *
 *  Parameters: 1. address of fontdata                                  *
 *              2. pointer of fontdata buffer                           *
 *              3. length  of fontdata                                  *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
get_fontdata(fontdata, buffer, length)
gmaddr          fontdata;
ufix8          huge *buffer;    /*@WIN 04-20-92 */
ufix            length;
{
        ufix8  FAR *src, huge *dst;
        ufix    temp;

#ifdef  DBGfontdata
   printf("get_fontdata()\n");
   printf("dest addr = %lx, src addr = %lx, length = %d\n",
           buffer, fontdata, length);
#endif
        temp = length;
        src = (ufix8 FAR *) fontdata;
        dst = buffer;    /* @WIN 04-20-92 */
        while (length--)
           *dst++ = *src++;

#ifdef  DBGfontdata
        {
           ubyte FAR *ptr;
           ufix  i, j;

           ptr = buffer;
           i = temp;
           j = 0;
           printf("\nfontdata1:\n ");
           while(i-- > 0){
             j++;
             if(j>=14) {
                j = 0;
                printf("\n ");
             }
             printf("%x ", *ptr++);
           }
        }
#endif
        return;

}

/* ******************************************************************** *
 *                                                                      *
 *  Function:   get_fontcache()                                         *
 *                                                                      *
 *  Parameters: 1. address of fontcache                                 *
 *              2. pointer of fontcache buffer                          *
 *              3. length  of fontcache                                 *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
get_fontcache(fontcache, buffer, length)
gmaddr          fontcache;
ufix8          FAR *buffer;
ufix            length;
{
        ufix8  FAR *src, FAR *dst;

#ifdef DBG
   printf("get_fontcache()\n");
   printf("dest addr = %lx, src addr = %lx, length = %d\n",
           buffer, fontcache, length);
#endif
        src = (ufix8 FAR *) fontcache;
        dst = (ufix8 FAR *) buffer;
        while(length--)
                *dst++ = *src++;
        return;

}

/* ******************************************************************** *
 *                                                                      *
 *  Function:   put_fontcache()                                         *
 *                                                                      *
 *  Parameters: 1. address of fontcache                                 *
 *              2. pointer of fontcache buffer                          *
 *              3. length  of fontcache                                 *
 *                                                                      *
 *  Called by:  TDB.                                                    *
 *                                                                      *
 *  Return:     ----                                                    *
 *                                                                      *
 * ******************************************************************** */
void far
put_fontcache(fontcache, buffer, length)
gmaddr          fontcache;
ufix8          FAR *buffer;
ufix            length;
{
        ufix8  FAR *src, FAR *dst;

#ifdef DBG
   printf("put_fontcache()\n");
#endif
        src = (ufix8 FAR *) buffer;
        dst = (ufix8 FAR *) fontcache;
        while(length--)
                *dst++ = *src++;
        return;

}


/* *********************************************************************
 *
 *  convert scanline from device coordinate into GWB coordinate
 *
 *    - Conv_SL     (NO, SL, BB_X, BB_Y, BB_W, BB_H);
 *    fix       far   conv_SL(fix, SCANLINE near *, fix, fix, fix, fix);
 * ********************************************************************* */

fix conv_SL(no_lines, scanlist, bb_xorig, bb_yorig, bb_width, bb_heigh)
fix                     no_lines;
SCANLINE                FAR *scanlist;
fix                     bb_xorig;
fix                     bb_yorig;
fix                     bb_width;
fix                     bb_heigh;
{
        fix             no_segts, xs, xe;
        SCANLINE        FAR *scan, FAR *putptr;

#ifdef DBG
   printf("conv_SL()..\n");
#endif

        no_segts = 0;
        scan = scanlist;
        putptr = scanlist;
   /*
    * convert scanline
    */
        while(no_lines--) {
            while( (xs = *scan++) != (SCANLINE)END_OF_SCANLINE ) {
                xs -= bb_xorig;
                xe = *scan++ - bb_xorig;
                if ((xs < bb_width) && (xe >= 0)) {
                   *putptr++ = (xs >= 0) ? xs : 0;
                   *putptr++ = (xe >= bb_width) ? (bb_width -1) : xe;
                   no_segts++;
                }
           }
           *putptr++ = (SCANLINE)xs;
        }
        *putptr = (SCANLINE)END_OF_SCANLINE;
        return(no_segts);
} /* conv_SL */


/* **********************************************************************
 *
 *  put_bitmap() : copy bitmap from source to destination
 *
 *  void      near  put_bitmap(gmaddr, ufix far *, fix, fix);
 * ********************************************************************** */
void      near  put_bitmap(dest_addr, src_addr, width, heigh)
gmaddr          dest_addr;
ufix32  far       *src_addr;    /* ufix => ufix32 @WIN */
fix             width, heigh;
{
        ufix    length;

#ifdef DBG
   printf("put_bitmap()..\n");
#endif

        length = width * BM_BYTES(heigh);

#ifdef DBG1
   {
      fix     i, j, k;
      ufix16  FAR *sptr, temp;

      printf("  length = %ld\n",length);
      sptr = (ufix16 FAR *)src_addr;
      for(i=0; i<width; i++){
        printf("\n");
        for(j=0; j< BM_WORDS(heigh); j++)
          printf("%x ", *sptr++);
      }
   }
#endif
        lmemcpy((ufix8 FAR *)dest_addr, (ufix8 FAR *)src_addr, length); /*@WIN*/
        return;
} /* put_bitmap */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\graphics.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   graphics.h
 *
 *      Purpose: Header files of graphics machinery, for definitions of data
 *               types, data structures, constants, and macros.
 *
 *      Developer:      S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *                  01/16/89    @IMAGE: new feature for fill_shape F_FROM_IMAGE
 *                              and F_TO_MASK to generate clipping mask (CMB)
 *                              for clipped image which can be processed by
 *                              using image seed patterns
 *                  03/17/89    @I2SFX: eliminate (sfix_t) cast of I2SFX macro
 *                              to make it feasible for conversion from "semi-
 *                              lfix" (13-bit fract) into exact lfix (16-bit fract).
 *                              (by Brian for BSFILL2.C)
 *                  03/30/89    MAXCELLSIZE is adjusted for V47 compatible
 *                              from 33 to 80
 *
 *                  04/12/89    approaching compatibility to V 47.
 *                               1) actual cell size would not be greater
 *                                  than 50 pixels in 300 DPI
 *                               2) the size of repeat pattern after
 *                                  expansing on 32-bit aligned would not
 *                                  be greater than 2400 pixels in 300 DPI
 *                  04/26/89    @MAC: update macros of transformation from
 *                              float to fixed numbers for performance
 *                              enhancement
 *                  05/10/89    delete F2SFX4, add F2LFX8
 *                  05/10/89    enlarge spot order array for V47 compatibility
 *                              from 4096 -> 5120
 *                  05/26/89    add new macros IS_ZERO() and IS_NOTZERO for
 *                              floating points
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  1/11/90     change max gsave level(MAXGSL) from 32 to 31
 *                              for compatibility.
 *                  07/26/90    update for grayscale, Jack Liaw
 *                  8/8/90      added rootfont in gs_hdr struct for KANJI
 *                  12/4/90     @CPPH: 1) Add cp_path in struct ph_hdr
 *                                     2) Add a mocro definition CP_TPZD
 *                  3/20/91     update macro IS_ZERO & IS_NOTZERO for speed;
 *                              add a macro SIGN_F to get a sign bit from a
 *                              floating point variable
 *                  3/20/91     add constants for pattern fill; Ada
 *                  3/26/91     Add bit 2 and bit 1 for PDL_CONDITION check
 *                  4/17/91     change MAXEDGE to 1600
 *                  11/11/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/

/* limits */

#ifdef DBG9              /* reduced version, so it can run with CoreView */
#define MAXGSL  4
#define MAXNODE 300
#define MAXEDGE 300
#else
#define MAXGSL MAXGSAVESZ    /* 31; max gsave level, defined in "constant.h" */
#define MAXNODE MAXPATHSZ    /* 1500; max number of nodes in path description */
//*!!!#define MAXEDGE MAXPATHSZ    |* 1500; max number of edges */
//DJCOld#define MAXEDGE 1600         /* 1500; max number of edges */
#define MAXEDGE (MAXPATHSZ + 100)   /* 1500; max number of edges */
#endif

#define MAXDASH MAXDASHSZ /* 11, maximum number of elements in a dash pattern */
#define MAXSCANLINES 3072 /* max. number of scan lines per band filling */
#define MAXGRAYVALUE 256  /* max. number of gray_chain table @IMAGE */
#define MAXGRAY 8         /* max. number of adjust gray table */
#define MAXSPOT 5120      /* max. number of adjust spot order table 05/10/89 */

/*      Note: MAXPATSIZE should be multiple of 16                       */
#define MAXPATTSIZE      128    /* 208 max. repeating pattern size      */
#define MAXSEEDSIZE       64    /* 128 max. seed size                   */
#define MAXCELLSIZE       70    /*  48 max. halftone cell size     03-16-89 */
#define MAXCACTSIZE       50    /* maximum cell actual size        04-12-89 */
#define MAXPEXPSIZE     2400    /* maximum pattern expansion size  04-12-89 */

#define GRAYUNIT         255    /* units of gray value         11-24-88 */
#define GRAYSCALE       0x4000  /* scale of gray value         11-24-88 */

/* grayscale for device state, 8-1-90 Jack Liaw */
#define NULLDEV         0       /* null device */
#define MONODEV         1       /* mono device */
#define GRAYDEV         4       /* gray device */

#define KANJI                   /* @WIN 05-05-92*/
/*-----------------*
 | type definition |
 *-----------------*/
/***************************************************************************
 *             ............ README ............
 *
 * While 13.3 was adopted for the short fixed format and 16.16 was used for
 * long fixed format in TrueImage, the range of number can be represented
 * in integer is between -2**12 and 2**12 -1. If the number does not fall
 * into this range, TrueImage will use "floating number math" to do the work.
 * To expand this range such that TrueImage could run faster for the higher
 * resolution, 16.16, 18.14 or 28.4 will be used.
 * @RESO_UPGR
 *
 * 16 bits fixed real number(13.3):
 *      +------------+------+           The range of numbers:
 *      |  integer   | frac |           [-2**12 .. 2**12 - 1]
 *      +------------+------+
 *          13 bits   3 bits
 *
 * 32 bits fixed real number(16.16):
 *      +------------+------------+
 *      |  integer   |    frac    |     [-2**14 .. 2**14 - 1]
 *      +------------+------------+
 *          16 bits      16 bits
 *
 * 32 bits fixed real number(18.14):
 *      +--------------+----------+
 *      |  integer     |   frac   |     [-2**16 .. 2**16 - 1]
 *      +--------------+----------+
 *          18 bits      14 bits
 *
 * 32 bits fixed real number(28.4):
 *      +------------------+------+
 *      |  integer         | frac |     [-2**26 .. 2**26 - 1]
 *      +------------------+------+
 *          28 bits         4 bits
 *
 * In the code, we used the following notation:
 *      "sfix_t" is used to maintain some degrees of precision while
 *      "lfix_t" is used when we need to keep higher precision during
 *      the math manipulation. Therefore,
 *      "sfix_t" can be either in 13.3, 16.16 or 28.4 while "lfix_t" is in
 *      16.16 or 18.14 depending upon the formats been used.
 *
 * Currently, the code is modified to support three different combination
 * of formats. The following compiler switch can be selected depending
 * upon the resolution of the printer.
 * (1) FORMAT_13_3: 13.3 is used for short fixed format and 16.16 is used
 *                  for long fixed format.  Basically, it is the same as
 *                  the released code before this modification. The range of
 *                  number can be represented in integer is
 *                  [-2**12 .. 2**12 - 1]. It should be used on 300 dpi
 *                  printer ONLY.
 * (2) FORMAT_16_16: 16.16 is used for both short and long fixed format.
 *                   The range of number can be represented in integer is
 *                   [-2**14 .. 2**14 - 1].  Therefore, the maximum resolution
 *                   can be supported by this format is up to 1152dpi(72 * 16)
 *                   on the legal size paper(14").
 * (3) FORMAT_28_4: 28.4 is used for short fixed format and 18.14 is for
 *                  long fixed format. The range of number can be represented
 *                  in integer is [-2**16 .. 2**16 - 1]. The maximum resolution
 *                  can be supported by this format is up to 3456dpi(72 * 48)
 *                  with the size of paper (17" maximum).
 ***************************************************************************/
#ifdef FORMAT_13_3
#undef FORMAT_16_16
#undef FORMAT_28_4
#endif

#ifdef FORMAT_16_16
#undef FORMAT_13_3
#undef FORMAT_28_4
#endif

#ifdef FORMAT_28_4
#undef FORMAT_13_3
#undef FORMAT_16_16
#endif

/*************************************************************************
 * To change from 28.4 and 16.16 combination to 28.4 and 18.14 combination
 * there are 3 places needed to be changed.
 * (1). L_SHIFT:  16 --> 14.
 * (2). Change the section which defines for PAGE_*
 * (3). CTM_LIMIT: CTM_16 --> CTM_48
 *************************************************************************/

#ifdef FORMAT_13_3 /* The current one before upgrade */
typedef fix16           sfix_t; /* 13.3 format (SF format) */
typedef fix32           lfix_t; /* 16.16 format (LF format) */
#define S_SHIFT         3       /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#elif FORMAT_16_16
typedef fix32           sfix_t; /* 16.16 format (SF format) */
typedef fix32           lfix_t; /* 16.16 format (LF format) */
#define S_SHIFT         16      /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#elif FORMAT_28_4
typedef fix32           sfix_t; /* 28.4 format (SF format) */
typedef fix32           lfix_t; /* 16.16 or 18.14 format (LF format) */
#define S_SHIFT         4       /* the shifting factor in SF format */
#define L_SHIFT         16      /* the shifting factor in LF format */
#endif

#define ONE_SFX  (1L << S_SHIFT)        /* 1   in SF format representation */
#define HALF_SFX (ONE_SFX >> 1)         /* 0.5 in SF format representation */
#define ONE_LFX  (1L << L_SHIFT)        /* 1   in LF format representation */
#define HALF_LFX (ONE_LFX >> 1)         /* 0.5 in LF format representation */
#define L_S_DIFF (L_SHIFT - S_SHIFT)    /* the difference between them */
#define HALF_L_S ((1L << L_S_DIFF)>> 1)/* the real half value of above number */

#ifdef FORMAT_13_3
#define MIN_SFX         -32768          /* min. 16-bit integer */
#define MAX_SFX          32767          /* max. 16-bit integer */
#elif  FORMAT_16_16
#define MIN_SFX         -2147483648     /* min. 32-bit integer */
#define MAX_SFX          2147483647     /* max. 32-bit integer */
#elif  FORMAT_28_4
#define MIN_SFX         -2147483648     /* min. 32-bit integer */
#define MAX_SFX          2147483647     /* max. 32-bit integer */
#endif

#ifdef FORMAT_13_3
#define PAGE_LEFT       -4096.0         /* -4K          */
#define PAGE_RIGHT       4095.0         /*  4K-1        */
#define PAGE_TOP        -4096.0         /* -4K          */
#define PAGE_BTM         4095.0         /*  4K-1        */
#define PG_CLP_IEEE      0x45800000L    /*  4K          */
#define PG_CLP_HALF_IEEE 0x45000000L    /*  2K          */
#define CTM_4_IEEE       0x40800000L    /*  4           */
#elif  FORMAT_16_16
/* The range of the numbers can be in [-32K .. 32K-1] under 16.16 format.
   However, there are some math "add" or "sub" operations of these numbers
   during internal calculation. Therefore, the range has been shrunk down
   to [-16384 .. 16383] to prevent from overflow.
*/
#define PAGE_LEFT       -16384.0        /* -16K         */
#define PAGE_RIGHT       16383.0        /*  16K-1       */
#define PAGE_TOP        -16384.0        /* -16K         */
#define PAGE_BTM         16383.0        /*  16K-1       */
#define PG_CLP_IEEE      0x46800000L    /*  16K         */
#define PG_CLP_HALF_IEEE 0x46000000L    /*  8K          */
#define CTM_16_IEEE      0x41800000L    /*  16          */
#elif  FORMAT_28_4
/* Theoretically, the range of the numbers can be represented by 28.4
   format is [-2**27 .. 2**27 - 1]. When this 28.4 is used with 16.16,
   the range of number can be represented in integer are decreased down
   to [-16384 .. 16383] due to there are some math "add" or "sub"
   operations for the long fixed numbers.
   The following are for 28.4 and 16.16 combination formats.
*/
#define PAGE_LEFT       -16384.0        /* -16K         */
#define PAGE_RIGHT       16383.0        /*  16K-1       */
#define PAGE_TOP        -16384.0        /* -16K         */
#define PAGE_BTM         16383.0        /*  16K-1       */
#define PG_CLP_IEEE      0x46800000L    /*  16K         */
#define PG_CLP_HALF_IEEE 0x46000000L    /*  8K          */
#define CTM_16_IEEE      0x41800000L    /*  16          */
#endif
/* Theoretically, the range of the numbers can be represented by 28.4
   format is [-2**27 .. 2**27 - 1]. When this 28.4 is used with 18.14,
   the range of number can be represented in integer are decreased down
   to [-65536 .. 65535] due to there are some math "add" or "sub"
   operations for the long fixed numbers.
   The following are for 28.4 and 18.14 combination formats.
#define PAGE_LEFT       -65536.0        |* -64K         *|
#define PAGE_RIGHT       65535.0        |*  64K-1       *|
#define PAGE_TOP        -65536.0        |* -64K         *|
#define PAGE_BTM         65535.0        |*  64K-1       *|
#define PG_CLP_IEEE      0x47800000L    |*  64K         *|
#define PG_CLP_HALF_IEEE 0x47000000L    |*  32K         *|
#define CTM_48_IEEE      0x42400000L    |*  48          *|
#endif
*/

#ifdef FORMAT_13_3
#define CTM_LIMIT       CTM_4_IEEE
#elif  FORMAT_16_16
#define CTM_LIMIT       CTM_16_IEEE
#elif  FORMAT_28_4
/* For 28.4 and 16.16 combination
*/
#define CTM_LIMIT       CTM_16_IEEE
/* For 28.4 and 18.14 combination
#define CTM_LIMIT       CTM_48_IEEE
*/
#endif

typedef fix16   PH_IDX;         /* index to path header, in path_table */
typedef fix16   SP_IDX;         /* index to subpath header, in node_table */
typedef fix16   VX_IDX;         /* index to vertex, in node_table */
typedef fix16   ET_IDX;         /* index to edge_table */
typedef fix16   CP_IDX;         /* index to clip_trpzd, in node_table */
typedef ULONG_PTR  gmaddr;         /* graphics memory address */
// DJC change to ufix16 typedef fix16   SCANLINE;       /* scanline structure */
typedef ufix16   SCANLINE;       /* scanline structure */

typedef fix16   HORZLINE;       /* scanline structure */
typedef fix16   PIXELIST;

/*------------------*
 | macro definition |
 *------------------*/
/* object related */
#define         IS_REAL(a)      (TYPE(a)  == REALTYPE ? TRUE : FALSE)
#define         IS_INTEGER(a)   (TYPE(a)  == INTEGERTYPE ? TRUE : FALSE)
/* Modify for speed; 3/20/90; scchen
 *#define         IS_ZERO(a)      ((F2L(a) & 0x7FFFFFFFL) == F2L(zero_f))
 *#define         IS_NOTZERO(a)   ((F2L(a) & 0x7FFFFFFFL) != F2L(zero_f))
 */
#define         IS_ZERO(f) ((ufix32)  (!((*((long FAR *)(&f))) & 0x7fffffffL)))
#define         IS_NOTZERO(f) ((ufix32)  (((*((long FAR *)(&f))) & 0x7fffffffL)))

#define         GET_OBJ(obj, indx)\
                ((struct object_def FAR *)VALUE(obj) + indx)
#define         VALUE_OPERAND(n)\
                ( opnstack[opnstktop - (n + 1)].value )
#define         LENGTH_OPERAND(n)\
                ( opnstack[opnstktop - (n + 1)].length )
#define         DIFF(a)         (fabs(a) < (real32)1e-4 ? (real32)0 : (a))

#define         PUT_VALUE(val, indx, ary_obj)\
                {\
                  struct object_def l_obj;\
                         l_obj.bitfield = 0;\
                         TYPE_SET(&l_obj, REALTYPE);\
                         l_obj.length = 0;\
                         l_obj.value = (val);\
                         put_array(ary_obj, indx, &l_obj);\
                }

#define         GET_OBJ_VALUE(f, obj)\
                {\
                        if (IS_REAL(obj))\
                                f = L2F(VALUE(obj));\
                        else\
                                f = (real32)((fix32)VALUE(obj));\
                }

#ifdef _AM29K
#define _clear87()      _clear_fp()
#define _status87()     _status_fp()
extern _clear_fp(), _status_fp();
#endif

#define         CHECK_INFINITY(f)\
                {\
                        if(_status87() & PDL_CONDITION){\
                                f = infinity_f ;\
                                _clear87() ;\
                        }\
                }

/* arithematic operations of the fix point real numbers */
/***************************************************************************
 * The following defines need to be modified according to the adopted format.
 * Some of the defines can still be used are kept without any changes. The
 * unused defines are removed.  The defines will be affected by the format
 * are modifed and only one of them should be activated.  @RESO_UPGR
 ***************************************************************************/
/* The defines have been used before upgrade.
#define F2LFX(f)        ((lfix_t)(floor((f) * 65536 + 0.5)))
#define F2LFX8(f)       ((lfix_t)(floor((f) *   256 + 0.5)))
#define F2SFX(f)        ((sfix_t)((((lfix_t)((f) * 65536)) +  4096L) >> 13))
#define F2SFX12(f)      ((sfix_t)((((lfix_t)((f) * 65536)) +     8L) >>  4))
#define LFX2F(lfx)      ((real32)(lfx) / 65536)         |* @FIXPNT *|
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) +  4096L) >> 13))
#define LFX2I(lfx)      ((fix)   (((lfx) + 32768L) >> 16))      |* @you *|
#define SFX2F(sfx)      ((real32)(sfx) / 8)
#define SFX2LFX(s)      ((lfix_t)(s) << 13)
#define SFX2I(sfx)      ((fix)(((sfx) + 4) >> 3))               |* @you *|
#define I2LFX(i)        ((lfix_t)(i) << 16)
#define I2SFX(i)                ((i) << 3)              |* @I2SFX *|

#define F2LFX_T(f)      ((lfix_t)((f) * 65536))
#define F2LFX8_T(f)     ((lfix_t)((f) *  256))
#define F2SFX_T(f)      ((sfix_t)((f) *     8))
#define F2SFX12_T(f)    ((sfix_t)((f) *  4096))                  |* @STK_INT *|
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> 13) )
#define LFX2I_T(lfix)   ( (fix) ((lfix) >> 16) )    |* truncate to long fix  *|
#define SFX2I_T(sfix)   ( (fix) ((sfix) >>  3) )    |* truncate to short fix *|
*/

/* #define F2LFX(f)     ((lfix_t)(floor((f) * 65536 + 0.5))) */
#define F2LFX(f)        ((lfix_t)(floor((f) * ONE_LFX + 0.5)))

/* #define F2LFX8(f)       ((lfix_t)(floor((f) * 256 + 0.5))) not used */

/* #define F2SFX(f)     ((sfix_t)((((lfix_t)((f) * 65536)) + 4096L) >> 13)) */
#ifdef FORMAT_13_3
#define F2SFX(f)    ((sfix_t)(((lfix_t)((f) * ONE_LFX) + HALF_L_S) >> L_S_DIFF))
#elif  FORMAT_16_16
#define F2SFX(f)    F2LFX(f)
#elif  FORMAT_28_4
#define F2SFX(f)    ((sfix_t)(((lfix_t)((f) * ONE_LFX) + HALF_L_S) >> L_S_DIFF))
#endif

/*#define F2SFX12(f) ((sfix_t)((((lfix_t)((f) * 65536)) + 8L) >> 4)) not used */

/* #define LFX2F(lfx)   ((real32)(lfx) / 65536) */
#define LFX2F(lfx)      ((real32)(lfx) / ONE_LFX)

/* LFX2SFX(lfx) is used in stroke.c and image.c
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + 4096L) >> 13))
*/
#ifdef FORMAT_13_3
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + HALF_L_S) >> L_S_DIFF))
#elif  FORMAT_16_16
#define LFX2SFX(lfx)    (lfx)
#elif  FORMAT_28_4
#define LFX2SFX(lfx)    ((sfix_t)(((lfx) + HALF_L_S) >> L_S_DIFF))
#endif

/* #define LFX2I(lfx)   ((fix)(((lfx) + 32768L) >> 16)) */
#define LFX2I(lfx)      ((fix)(((lfx) + HALF_LFX) >> L_SHIFT))

/*#define SFX2F(sfx)    ((real32)(sfx) / 8) */
#define SFX2F(sfx)      ((real32)(sfx) / ONE_SFX)

/*#define SFX2LFX(s)    ((lfix_t)(s) << 13) */
#ifdef FORMAT_13_3
#define SFX2LFX(s)      ((lfix_t)(s) << L_S_DIFF)
#elif  FORMAT_16_16
#define SFX2LFX(s)      (s)
#elif  FORMAT_28_4
#define SFX2LFX(s)      ((lfix_t)(s) << L_S_DIFF)
#endif

/*#define SFX2I(sfx)    ((fix)(((sfx) + 4) >> 3)) */
#define SFX2I(sfx)      ((fix)(((sfx) + HALF_SFX) >> S_SHIFT))

/*#define I2LFX(i)      ((lfix_t)(i) << 16) */
#define I2LFX(i)        ((lfix_t)(i) << L_SHIFT)

/*#define I2SFX(i)      ((i) << 3) */
#define I2SFX(i)        ((i) << S_SHIFT)

/*#define F2LFX_T(f)    ((lfix_t)((f) * 65536)) */
#define F2LFX_T(f)      ((lfix_t)((f) * ONE_LFX))

/* F2LFX8_T(f) is used in get_rect_points_i() ONLY. It is a generic
   define regardless the format used.  */
#define F2LFX8_T(f)     ((lfix_t)((f) * 256))

/* #define F2SFX_T(f)   ((sfix_t)((f) * 8)) */
#define F2SFX_T(f)      ((sfix_t)((f) * ONE_SFX))

/* F2SFX12_T(f) is used in init_stroke() ONLY. It is a generic define
   regardless the format used as F2LFX8_T(). please refer to
   stk_info.half_width_i and get_rect_points_i() for detail.
*/
#define F2SFX12_T(f)    ((fix32)((f) * 4096))

/*#define LFX2SFX_T(lfx) ((sfix_t)((lfx) >> 13)) */
#ifdef FORMAT_13_3
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> L_S_DIFF))
#elif  FORMAT_16_16
#define LFX2SFX_T(lfx)  (lfx)
#elif  FORMAT_28_4
#define LFX2SFX_T(lfx)  ((sfix_t)((lfx) >> L_S_DIFF))
#endif

/*#define LFX2I_T(lfix) ((fix)((lfix) >> 16)) */
#define LFX2I_T(lfix)   ((fix)((lfix) >> L_SHIFT))

/*#define SFX2I_T(sfix) ((fix)((sfix) >> 3)) */
#define SFX2I_T(sfix)   ((fix)((sfix) >> S_SHIFT))

/* These macros need to be modified too
#define I_OF_LFX(lfix)  ( (lfix) >> 16 )            |* take integer part     *|
#define F_OF_LFX(lfix)  ( (lfix) & 0x0000FFFF )     |* take fraction part    *|
#define I_OF_SFX(sfix)  ( (sfix) >> 3)              |* take integer part     *|
#define F_OF_SFX(sfix)  ( (sfix) & 7)               |* take fraction part    *|
*/
#define I_OF_LFX(lfix)  ((lfix) >> L_SHIFT)        /* take integer part */
#define F_OF_LFX(lfix)  ((lfix) & ((1L << L_SHIFT) - 1))
                                                   /* take fraction part */

/* #define I_OF_SFX(sfix)  ( (sfix) >> 3)          is not used */
/* #define F_OF_SFX(sfix)  ( (sfix) & 7)           is not used */
/* End of macro defines change @RESO_UPGR */

/* The following macro was in shape.c */
#define     LABS(i)      ((i) > (fix32)0    ? (i) : -(i))

/* IEEE floating point format */
#define SIGN(f)            (((f) & 0x80000000L))
#define EXP(f)  ((ufix32)  (((f) & 0x7f800000L)))
#define MAT(f)  ((ufix32)  (((f) & 0x007fffffL)))
#define MAGN(f) ((ufix32)  (((*((long32 FAR *)(&f))) & 0x7fffffffL)))
                           /* get magnitude, ignore sign bit */
#define SIGN_F(f) ((ufix32)  (((*((long FAR *)(&f))) & 0x80000000L)))

/* macro to align a bounding box to the word boundary @ALIGN_W
 *      |<== x                 y ====>|
 *      |    +-----------------+      |
 *           |                 |
 *           |                 |
 *      ^    +-----------------+      ^
 *      |                             |
 *    word                          word
 *    ALIGN_L(x)                    ALIGN_R(y)
 */
#define ALIGN_L(x)    ( (x) & 0xfff0 )
#define ALIGN_R(x)    ( ((x) & 0xfff0) + 15 )

/*-----------------------*
 | Common Data Structure |
 *-----------------------*/

struct sp_lst {         /* a list of subpaths */
        SP_IDX   head;
        SP_IDX   tail;
};

struct cp_lst {         /* a list of clipping trapezoids */
        CP_IDX   head;
        CP_IDX   tail;
};

struct list_hdr {       /* general header for a list */
        fix16     head;
        fix16     tail;
};

struct coord {          /* floating point coordinate structure */
        real32  x;
        real32  y;
};

struct coord_i {        /* fixed point coordinates @PRE_CLIP */
        sfix_t   x;
        sfix_t   y;
};

struct rectangle_i {    /* rectangle in integer coordinates */
        sfix_t  ux;
        sfix_t  uy;
        sfix_t  lx;
        sfix_t  ly;
};

struct  polygon {       /* 8 sides polygon in float coordinates */
        fix16   size;
        struct  coord p[8];
};

struct  polygon_i {     /* 8 sides polygon in integer coordinates */
        fix16   size;
        struct  coord_i p[8];
};

/* ***** stroke structure, moved from stroke.c, 3/18/91   -jwm, -begin- */
/* line_segment structure:
 *                      pgn[1]                           pgn[2]
 *                            +------------------------+
 *                      p0    +------------------------+ p1
 *                            +------------------------+
 *                      pgn[0]                           pgn[3]
 */
struct  line_seg {
        struct coord p0;        /* starting point of central line */
        struct coord p1;        /* ending point of central line */
        struct coord vct_u;     /* vector of p0 -> pgn[0] in user space */
        struct coord vct_d;     /* vector of p0 -> pgn[0] in device space */
        struct coord pgn[4];    /* outline of the line segment */
};
struct  line_seg_i {      /* @STK_INT */
        struct coord_i p0;        /* starting point of central line */
        struct coord_i p1;        /* ending point of central line */
        struct coord   vct_u;     /* vector of p0 -> pgn[0] in user space */
        struct coord_i vct_d;     /* vector of p0 -> pgn[0] in device space */
        struct coord_i pgn[4];    /* outline of the line segment */
};
/* ***** stroke structure, moved from stroke.c, 3/18/91   -jwm, -end- */

/* structures for enhancement of image */
struct  gray_chain_hdr {        /* @Enhance OP_IMAGE */
        fix16   start_seed_sample;
};

struct g_sample_hdr {
        fix16   bb_lx;
        fix16   bb_ly;
        fix16   bb_xw;          /* @IMAGE  01-16-89  Y.C. */
        fix16   bb_yh;          /* @IMAGE  01-16-89  Y.C. */
        fix16   seed_index;     /* @#IMAGE 04-27-88  Y.C. */
        fix16   gray_level;
};

struct vertex {         /* data structure of a vertex */
        fix     x, y;           /*   x and y coordinates of a vertex */
};

struct sample {         /* data structure of image seed pattern */
        struct vertex p[4];     /*   x and y coordinates of vertice of a seed */
};

/* data structures for 'xxx_image_proc'; were unodes  -jwm, 12/26 -begin- */
struct isp_data  {
        fix16   bb_x;
        fix16   bb_y;
        fix16   index;
        fix16   next;
};
/* data structures for 'xxx_image_proc'; were unodes  -jwm, 12/26 -end- */

/*-------------------------------*
 | Graphics State Data Structure |
 *-------------------------------*/

struct clr_hdr {                /* color structure */
        fix16   adj_gray;       /* index to gray table */
        real32  gray;           /* gray value */
        real32  hsb[3];         /* hue, sat, brt */
        fix16   inherit;        /* TRUE: inherit form previous */
};

struct gray_hdr {               /* adjust gray structure */
        fix16   val[256];
};

struct cp_hdr {                 /* Clipping trapezoid structure */
        CP_IDX  head;           /* index to edge table, to the head and tail */
        CP_IDX  tail;           /* of clipping trapezoids                    */
        sfix_t  bb_ux;          /* bounind box of clipping path:             */
        sfix_t  bb_uy;          /*      (ux, uy), (lx, ly)                   */
        sfix_t  bb_lx;          /*                                           */
        sfix_t  bb_ly;
        fix16   single_rect;    /* TRUE: single rectangle clipping region */
        fix16   inherit;        /* TRUE: inherit from previous gsave level */
};

struct scrn_hdr {               /* Halftone screen structure */
        fix16   chg_flag;       /* indicate repeat pattern need to update */
        real32  freq;
        real32  angle;
        fix16   no_whites;
        struct  object_def proc;
        fix16   spotindex;
                /* @@@ gstate manipulator should update fields above  */
        fix16   majorfact;
        fix16   minorfact;
        fix16   size_fact;
        fix16   cell_fact;
        fix16   scalefact;
        fix16   patt_size;
        fix16   cell_size;
        fix16   no_pixels;
                                /* the following fields inserted for
                                 * strange spots of binary pattern
                                 */
        fix16   ht_binary;
        fix16   bg_pixels;
        real32  back_gray;
        fix16   fg_pixels;
        real32  fore_gray;
};

struct dsh_hdr {                        /* dash pattern structure */
        fix16   pat_size;               /* no# of pattern element */
        real32  pattern[MAXDASH];       /* MAXDASH = 11 */
        struct  object_def pattern_obj;
        real32  offset;
                                        /* adjusted dash pattern @EHS_STK */
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

struct dev_hdr {                /* device related structure */
        real32  default_ctm[6];
        struct  rectangle_i default_clip;
        struct  object_def  device_proc;
        fix16   width;
        fix16   height;
        byte    chg_flg;        /* indicate device header needs to update */
        byte    nuldev_flg;     /* null device */
};

struct gs_hdr {                                 /* Graphics State structure */
        fix16   save_flag;                      /* set by save operator */
        real32  ctm[6];                         /* current transform matrix */
        struct  clr_hdr color;                  /* color */
        struct  coord   position;               /* current point */
        fix16   path;                           /* current path */
        struct  cp_hdr  clip_path;              /* clipping path */
        struct  object_def  font;               /* current typeface */
#ifdef KANJI
        struct  object_def  rootfont;           /* current rootfont */
#endif
        real32  line_width;                     /* line width */
        fix16   line_cap;                       /* line cap */
        fix16   line_join;                      /* line join */
        struct  scrn_hdr    halftone_screen;    /* halftone screen */
        struct  object_def transfer;            /* gray transfer function */
        real32  flatness;                       /* flatness */
        real32  miter_limit;                    /* miter limit */
        struct  dsh_hdr dash_pattern;           /* dash pattern */
        struct  dev_hdr device;                 /* device dependent */
                                                /* Jack Liaw 7-26-90 */
        bool8   graymode;                       /* FALSE:mono; TRUE:gray */
        bool8   interpolation;                  /* FALSE/TRUE */
};


/*----------------------------*
 | Path Header Data Structure |
 *----------------------------*/

struct ph_hdr {
        bool16  rf;             /* rf = P_RVSE : reverse_path,
                                 * rf = P_FLAT : flatten_path,
                                 * rf = P_NACC : can't be pathforall
                                 * rf = P_DFRGS: defer copying nodes @DFR_GS
                                 */
        real32  flat;           /* flatness of previous subpath(s) */
        SP_IDX  head;           /* index to node table, to the first subpath */
        SP_IDX  tail;           /* index to node table, to the last subpath */
        PH_IDX  previous;       /* index to path table, to previous path */
        CP_IDX  cp_path;        /* path defined in clip_path @CPPH */
};


/*---------------------*
 | Node Data Structure |
 *---------------------*/
/* node_table is an union of 4 structures: subpath, vertex, clip trapezoid,
 * and sample cell
 */

/* Structure 1: subpath header */
struct vx_hdr {
    bool8   type;   /* MOVETO/LINETO/CURVETO/CLOSEPATH; */
    bool8   flag;   /* for first node(MOVETO) only
                     * 1.SP_DUP:
                     *        duplicated subpath; if it is not on the top
                     *        gs_level, it is a useless subpath
                     * 2.SP_OUTPAGE:
                     *        subpath outside page boundary
                     * 3.SP_CURVE:
                     *        subpath contains curves
                     */
    real32  x, y;   /* vertex position */
    VX_IDX  tail;   /* tail of subpath; first node only */
    SP_IDX  next_sp;/* next subpath; first node only */
};
#define sp_hdr vx_hdr

/* Structure 3: short fixed vertex for font & stroke internal usage @SVX_NODE */
struct svx_hdr {
    bool16  type;   /* MOVETO/LINETO/CURVETO/CLOSEPATH */
    sfix_t x, y; /* vertex position */
};

/* Structure 4: clip trapezoid */
struct tpzd {                           /* clip_tpzd --> tpzd, @SCAN_EHS */
    sfix_t topy;  /* y coordinate of upper horiz. line */
    sfix_t topxl; /* left x_coordinate */
    sfix_t topxr; /* right x_coordinate */
    sfix_t btmy;  /* y coordinate of bottom horiz. line */
    sfix_t btmxl; /* left x_coordinate */
    sfix_t btmxr; /* right x_coordinate */
};

/* Structure 5: sample cell */
struct sample_hdr {
    fix16   bb_lx;
    fix16   bb_ly;
    fix16   seed_index;     /* @#IMAGE 04-27-88  Y.C. */
};

struct nd_hdr {
    VX_IDX  next;                            /* next node */
    union {
        struct  sp_hdr     subpath_node;      /* subpath header */
        struct  vx_hdr     vertex_node;       /* vertex */
        struct  svx_hdr    svx_node;          /* short fixed vertex @SVX_NODE*/
        struct  tpzd       clip_tpzd;         /* clip trapezoid */
        struct  sample_hdr seed_sample_node;  /* sample cell for image */
        struct  rectangle_i clip_sample_node; /* @JJ */
    } unode;
};

/* #define SP_HEAD      unode.subpath_node.head         @NODE */
#define SP_NEXT         unode.subpath_node.next_sp   /* @NODE */
#define SP_TAIL         unode.subpath_node.tail
#define SP_FLAG         unode.subpath_node.flag
#define VX_TYPE         unode.vertex_node.type
#define VERTEX_X        unode.vertex_node.x
#define VERTEX_Y        unode.vertex_node.y
#define CP_TPZD         unode.clip_tpzd                 /* @CPPH */
#define CP_TOPY         unode.clip_tpzd.topy
#define CP_TOPXL        unode.clip_tpzd.topxl
#define CP_TOPXR        unode.clip_tpzd.topxr
#define CP_BTMY         unode.clip_tpzd.btmy
#define CP_BTMXL        unode.clip_tpzd.btmxl
#define CP_BTMXR        unode.clip_tpzd.btmxr
#define SAMPLE_BB_LX    unode.seed_sample_node.bb_lx
#define SAMPLE_BB_LY    unode.seed_sample_node.bb_ly
#define SEED_INDEX      unode.seed_sample_node.seed_index
#define SAMPLE_P0_X     unode.clip_sample_node.lx
#define SAMPLE_P0_Y     unode.clip_sample_node.ly
#define SAMPLE_P1_X     unode.clip_sample_node.ux
#define SAMPLE_P1_Y     unode.clip_sample_node.ly
#define SAMPLE_P2_X     unode.clip_sample_node.ux
#define SAMPLE_P2_Y     unode.clip_sample_node.uy
#define SAMPLE_P3_X     unode.clip_sample_node.lx
#define SAMPLE_P3_Y     unode.clip_sample_node.uy
#define VXSFX_TYPE      unode.svx_node.type              /* @SVX_NODE */
#define VXSFX_X         unode.svx_node.x
#define VXSFX_Y         unode.svx_node.y

/*
 *                         Figure of Path
 *                         --------------
 *
 *
 *        path_table[]                   node_table[1500]
 *
 *          'Path'                       'Subpath' + 'Vertex'
 *      (ph_hdr structure)                (nd_hdr structure)
 *       +-----------+
 *       ! rf        !
 *       +-----------+          'Subpath'
 *       ! flat      !      (sp_hdr structure)
 *       +-----------+       +--------------+
 *       ! head      +------>!   SUBPATH    !
 *       +-----------+       +--------------+         'Vertex'
 *       ! tail      +--+    ! flag         !     (vx_hdr structure)
 *       +-----------+  !    +--------------+   +--------+   +--------+
 *       ! previous  !  !    ! head         +-->! MOVETO !   ! LINETO !
 *       +-+---------+  !    +--------------+   +--------+   +--------+
 *         !            !    ! tail         +-+ ! x, y   !   ! x, y   !
 *         v            !    +--------------+ ! +--------+   +--------+
 *       +-----------+  !    ! next         ! ! ! next   +-+>! next   !
 *       ! rf        !  !    +-+------------+ ! +--------+ ! +--------+
 *       +-----------+  !      !              +------------+
 *       ! flat      !  !      v
 *       +-----------+  !      ~
 *       ! head      +  !      ~
 *       +-----------+  !      !
 *       ! tail      +  !      v
 *       +-----------+  !    +--------------+
 *       ! previous  !  +--> !              !
 *       +-+---------+       !              !
 *         !                 +--------------+
 *         !                 +-+------------+
 *         !                   !
 *         ~                   ~
 *
 */
/*      @NODE
 *                         Figure of Path
 *                         --------------
 *
 *
 *        path_table[]                   node_table[1500]
 *
 *          'Path'                       'Subpath' + 'Vertex'
 *      (ph_hdr structure)                (nd_hdr structure)
 *       +-----------+
 *       ! rf        !
 *       +-----------+
 *       ! flat      !        (first node)
 *       +-----------+       +------+-----+    +------+-----+    +------+-----+
 *       ! head      +------>!MOVETO| flag!    !LINETO| *** !    !LINETO| *** !
 *       +-----------+       +------+-----+    +------+-----+    +------+-----+
 *       ! tail      +--+    !   x, y     !    !   x, y     !    !   x, y     !
 *       +-----------+  !    +------------+    +------------+    +------------+
 *       ! previous  !  !    !   next     +--->!   next     +-+->!   NULL     !
 *       +-+---------+  !    +------------+    +------------+ |  +------------+
 *         !            !    !   tail     +-+  !    ***     ! |  !    ***     !
 *         v            !    +------------+ |  +------------+ |  +------------+
 *       +-----------+  !    !  next_sp   ! |  !    ***     ! |  !    ***     !
 *       ! rf        !  !    +-----+------+ |  +------------+ |  +------------+
 *       +-----------+  !          !        |                 |
 *       ! flat      !  !          v        +-----------------+
 *       +-----------+  !          ~
 *       ! head      +  !          ~
 *       +-----------+  !          !
 *       ! tail      +  !          v
 *       +-----------+  !    +--------------+
 *       ! previous  !  +--> !              !
 *       +-+---------+       !              !
 *         !                 +--------------+
 *         !                 +-----+--------+
 *         !                       !
 *         ~                       ~
 *
 */


/*----------------------*
 | Edge Table Structure |
 *----------------------*/
/*
 * edge_table is an union of 3 different structures
 */

/* Structure 1: shape_reduction */
struct et_reduce {              /* For shape_reduction */
        sfix_t  top_y;       /* larger y coordinate of edge */
        sfix_t  top_x;       /* x coordinate that goes with top_y */
        sfix_t  left_x;      /* x coordinate for left split */
        sfix_t  left_y;      /* y coordinate for left split */
        sfix_t  right_x;     /* x coordinate for right split */
        sfix_t  end_y;       /* smaller y coordinate of edge */
        sfix_t  end_x;       /* x coordinate that goes with end_y */
        sfix_t  x_intersect; /* x coordinate that y_scan line
                              * intersects with the edge.
                              */
        sfix_t  x_isect0;    /* x coordinate that y_scan line     12/06/88
                              * intersects with previous edge.
                              */
        ufix8   flag;         /* bit 0 -- horizontal edge: HORIZ_EDGE
                               * bit 1 -- useless edge: FREE_EDGE
                               * bit 2 -- direction of edge: WIND_UP
                               * bit 3 -- intersect with scan line:
                               *          CROSS_PNT
                               */
        fix8    winding_no;   /* winding number of the area on the
                               * right side of the edge.
                               */
};
#define ET_TOPX         et_item.et_reduce.top_x
#define ET_TOPY         et_item.et_reduce.top_y
#define ET_LFTX         et_item.et_reduce.left_x
#define ET_LFTY         et_item.et_reduce.left_y
#define ET_RHTX         et_item.et_reduce.right_x
#define ET_ENDX         et_item.et_reduce.end_x
#define ET_ENDY         et_item.et_reduce.end_y
#define ET_XINT         et_item.et_reduce.x_intersect
#define ET_XINT0        et_item.et_reduce.x_isect0              /* 12/06/88 */
#define ET_FLAG         et_item.et_reduce.flag
#define ET_WNO          et_item.et_reduce.winding_no
/* for horizontal edge */
#define HT_Y            ET_TOPY
#define HT_XL           ET_TOPX
#define HT_XR           ET_ENDX

/* Structure 2: Font QEM filling @12/09/88= by you */
struct  qem_et_fill  {
        fix16   ystart;         /* starting y-scanline of the edge   */
        fix16   ylines;         /* number of y-scanlines of the edge */
        lfix_t  xintc;          /* x-intercept that goes with ystart */
        lfix_t  xchange;        /* delta of x-intercept per y-scanline */
        fix16   dir;            /* edge direction?  */
};      /*
         * all short names (macros) about this are defined
         *      in FONTQEM.EXT to show locality of this structure.
         */

/* Structure 3: cross point table; for shape_reduction */
struct xpnt_hdr {               /* cross point table */
        sfix_t  x;              /* x coordinate of the cross point */
        sfix_t  y;              /* y coordinate of the cross point */
        struct edge_hdr FAR *edge1; /* edge intersects with the following edge */
        struct edge_hdr FAR *edge2;                 /* @ET */
};
#define XT_X     et_item.xpnt.x
#define XT_Y     et_item.xpnt.y
#define XT_EDGE1 et_item.xpnt.edge1
#define XT_EDGE2 et_item.xpnt.edge2

struct edge_hdr {                               /* edge table */
        union {
                struct  et_reduce et_reduce;    /* shape_reduction */
                struct  qem_et_fill qem_et_fill;/* font QEM fill */
                struct  xpnt_hdr  xpnt;         /* cross point table */
        } et_item;
};

/*---------------------*
 | tpzd_info structure |        @FILL_INFO
 *---------------------*/
/* bounding box information of the trapezoid to be filled, used by savetpzd.c &
 * fillgb.c
 */
struct tpzd_info {
        union {
                struct {
                        fix  box_x;     /* x-coordinate of upper-left corner */
                        fix  box_y;     /* y-coordinate of upper-left corner */
                } coord;
                gmaddr  bitmap;         /* address of character bitmap */
        } orig;
        fix  box_w;          /* width of the bounding box */
        fix  box_h;          /* height of the bounding box */
};
#define BMAP   orig.bitmap
#define BOX_X  orig.coord.box_x
#define BOX_Y  orig.coord.box_y

/*-------------------------------*
 | active dash pattern structure |
 *-------------------------------*/
 /* for op_stroke/op_strokepath  */
struct actdp {
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

/*-----------*
 | constants |
 *-----------*/
#define NULLP           -1              /* 2 bytes, null index */
#define NOCURPNT        0xff800000L     /* -infinitive, IEEE standard
                                         * null coordinates
                                         */
/*#define BTMSCAN         3330          bottom scan line of the page, not used */

/* The following defines need to be changed for resolution upgrade. @RESO_UPGR
   They have been moved to the beginning of this file.
#define ONE_LFX         65536L          |* 1   in long  fix representation *|
#define HALF_LFX        32768L          |* 0.5 in long  fix representation *|
#define ONE_SFX         8               |* 1   in short fix representation *|
#define HALF_SFX        4               |* 0.5 in short fix representation *|
#define MIN_SFX         -32768
#define MAX_SFX         32767           |* max. 16-bits integer *|
*|
|* page boundary *|                     |* @PRE_CLIP *|
#define PAGE_LEFT       -4096.0         |* -4K          *|
#define PAGE_RIGHT       4095.0         |*  4K-1        *|
#define PAGE_TOP        -4096.0         |* -4K          *|
#define PAGE_BTM         4095.0         |*  4K-1        *|
*/

/* node type */
#define SUBPATH         1
#define MOVETO          2
#define LINETO          3
#define CURVETO         4
#define CLOSEPATH       5
#define PSMOVE          6

/* rf field of path header */
#define P_RVSE          01
#define P_FLAT          02
#define P_NACC          04
#define P_DFRGS        010  /* defer copying nodes of gsave operator @DFR_GS */

/* flag of subpath header(sp_flag) */
#define SP_OUTPAGE      01
#define SP_CURVE        02
#define SP_DUP          04

/* arc direction */
#define CNTCLK          1
#define CLKWISE         2

/* action */
#define ACT_PAINT       1
#define ACT_CLIP        2
#define ACT_SAVE        3
#define ACT_IMAGE       4

/* fill type */
#define F_NORMAL        1
#define F_FROM_CACHE    2       /* source from cache memory */
#define F_BSTREAM       3       /* filling for Bitstream font */
#define F_ITFONT        4       /* filling for Inteli_font */
#define F_FROM_CRC      5       /* source from circle cache memory */
#define F_FROM_IMAGE    6       /* @IMAGE  01-16-89  Y.C.
                                   fill_shape() call init_image_page()
                                                 and clip_image_page() */

/* fill destination */
#define F_TO_PAGE       1       /* fill to page */
#define F_TO_CACHE      2       /* fill to cache */
#define F_TO_CLIP       3
#define F_TO_IMAGE      4       /* @IMAGE */
#define SAVE_CLIP       5       /* to save clip path; from clip operator */
#define F_TO_MASK       6       /* @IMAGE  01-16-89  Y.C.
                                   fill_shape() call init_image_page()
                                                 and clip_image_page() */

/* clip status  @IMAGE */
#define OUT_CLIPPATH    0
#define CLIP            1
#define INSIDE_CLIPPATH 2


/* winding type */
#define NON_ZERO        1
#define EVEN_ODD        2

/* flag on edge_table: et_reduce.flag @ET */
#define HORIZ_EDGE      0x01
#define FREE_EDGE       0x02
#define WIND_UP         0x04
#define CROSS_PNT       0x08

/* type of linejoin */
#define MITER_JOIN      0
#define ROUND_JOIN      1
#define BEVEL_JOIN      2

/* type of linecap */
#define BUTT_CAP        0
#define ROUND_CAP       1
#define SQUARE_CAP      2

/*      System/Device Parameters        from HalfTone                   */
#define MIN_RESOLUTION   60                                     /* @RES */
#define MAX_RESOLUTION  300                                     /* @RES */
#define TOLERANCE       1e-7

#define END_OF_SCANLINE 0x8000          /* -32768   */

#define MATRIX_LEN      6

#define ARRAY_ONLY      0
#define G_ARRAY         1

#define OUT_POINT       0
#define IN_POINT        1
#define RLINETO         -1
#define RMOVETO         -1
#define RCURVETO        -1

#define OP_FILL         1
#define OP_EOFILL       2
#define OP_STROKE       3
#define OP_IMAGEMASK    4

/* type of print_page, for lower level graphics primitives @PRT_FLAG */
#define COPYPAGE        0
#define SHOWPAGE        1

/* used by "gstate.c" */
#define RESTORE         999

/* used for checking status87 */
#ifdef _AM29K
/* Define or appropriate bits for 29027 -- zero divide (bit 5),
 * overflow (bit 2), reserved (bit 1), and invalid (bit 0).
 */
#define PDL_CONDITION   32+4+2+1        /* phchen 03/26/91 */
#else
#define PDL_CONDITION   SW_ZERODIVIDE+SW_OVERFLOW+SW_INVALID
#endif

/* input flag to convex_clipper @SCAN_EHS */
#define CC_IMAGE        1       /* calling from image */
#define CC_TPZD         2       /* input is a trapezoid */

#ifdef WIN
/* Ada 3/20/91 for pattern fill */
#define PF_HEIGHT       16
#define PF_WIDTH        32
#define PF_BSIZE        (PF_HEIGHT * (PF_WIDTH >> WORDPOWER))

#define PF_REP          2
#define PF_OR           1
#define PF_NON          0
#endif

/* ***********  Constants from FILLPROC.DEF  11-24-88  **************** */


/************************************************************************
 *      Macro Definitions of Bitmap                     11-24-88        *
 ************************************************************************/
#define bSwap TRUE      /*@WIN*/

#define HT_ALIGN_MASK  (0xFFFFFFE0)             /* alignment mask of halftone */

/* @WIN: set following two macro from ufix => ufix32, so they may be
 * consistent with BM_DATP; scchen */
#define BM_WORD_POWER  ((sizeof(ufix32)   / 2) + 3) /* shift power to word  @WIN  */
#define BM_PIXEL_WORD  (sizeof(ufix32) * 8)     /* number of pixels per word @WIN */
#define BM_PIXEL_MASK  ( (BM_PIXEL_WORD - 1))   /* mask for pixel from word   */
#define BM_ALIGN_MASK  (~(BM_PIXEL_WORD - 1))   /* mask for word alignment    */
#define BM_ALIGN(X)    (((X) & BM_ALIGN_MASK))  /* floor   word alignment     */
                                                /* celling word alignment     */
#define BM_BOUND(X)    (((X) + BM_PIXEL_MASK) & BM_ALIGN_MASK)
#define BM_FRONT(X)    (((X) | BM_PIXEL_MASK) + 1)
#define BM_PIXEL(B)    ((B) * (sizeof(ufix8) * 8))        /* words  -> pixels */
#define BM_BYTES(W)    (BM_BOUND(W) / (sizeof(ufix8) * 8))/* pixels -> bytes  */
#define BM_WORDS(W)    (BM_BOUND(W) / (sizeof(ufix32)  * 8))/* pixels -> words @WIN */

#define BM_WHITE       ((ufix32) 0x00000000)    /* all white pixels in a word @WIN*/
#define BM_BLACK       ((ufix32) 0xFFFFFFFF)    /* all black pixels in a word @WIN*/
#ifdef  LBODR
#define BM_LEFT_SHIFT(D, S)                                             \
                       ((ufix32) ((D) >> (S)))          /* @WIN */
#define BM_RIGH_SHIFT(D, S)                                             \
                       ((ufix32) ((D) << (S)))          /* @WIN */
#else
#define BM_LEFT_SHIFT(D, S)                                             \
                       ((ufix32) ((D) << (S)))          /* @WIN */
#define BM_RIGH_SHIFT(D, S)                                             \
                       ((ufix32) ((D) >> (S)))          /* @WIN */
#endif
                                                /* left  most pixel in a word */
#define BM_L_PIX  ((ufix32) (BM_LEFT_SHIFT(BM_BLACK, BM_PIXEL_WORD - 1)))/*@WIN*/
                                                /* right most pixel in a word */
#define BM_R_PIX  ((ufix32) (BM_RIGH_SHIFT(BM_BLACK, BM_PIXEL_WORD - 1)))/*@WIN*/


#define BM_P_MASK(C)                                                          \
                (BM_RIGH_SHIFT(BM_L_PIX, (C) & BM_PIXEL_MASK))  /* ----*---- */
#define BM_L_MASK(C)                                                          \
                (BM_RIGH_SHIFT(BM_BLACK, (C) & BM_PIXEL_MASK))  /* ----***** */
#define BM_R_MASK(C)                                                          \
                (BM_LEFT_SHIFT(BM_BLACK, (((C) ^ BM_PIXEL_MASK)               \
                                             & BM_PIXEL_MASK))) /* *****---- */


/************************************************************************
 *      Macro Definitions of Character Cache            11-24-88        *
 ************************************************************************/


#define CC_WORD_POWER  ((sizeof(ufix16) / 2) + 3)   /* shift power to word    */
#define CC_PIXEL_WORD  ((sizeof(ufix16) * 8))   /* number of pixels per word */
#define CC_PIXEL_MASK  ( (CC_PIXEL_WORD - 1))   /* mask for pixel from word  */
#define CC_ALIGN_MASK  (~(CC_PIXEL_WORD - 1))   /* mask for word alignment   */
#define CC_ALIGN(X)    (((X) & CC_ALIGN_MASK))  /* floor   word alignment    */
                                                /* celling word alignment    */
#define CC_BOUND(X)    (((X) + CC_PIXEL_MASK) & CC_ALIGN_MASK)
#define CC_FRONT(X)    (((X) | CC_PIXEL_MASK) + 1)
#define CC_PIXEL(B)    ((B) * (sizeof(ufix8) * 8)))        /* words -> pixels */
#define CC_BYTES(W)    (CC_BOUND(W) / (sizeof(ufix8)  * 8))/* pixels -> bytes */
#define CC_WORDS(W)    (CC_BOUND(W) / (sizeof(ufix16) * 8))/* pixels -> words */

#define CC_WHITE       ((ufix16) 0x0000)        /* all white pixels in a word */
#define CC_BLACK       ((ufix16) 0xFFFF)        /* all black pixels in a word */
#ifdef  LBODR
#define CC_L_PIX  ((ufix16) 0x0001)     /* left  most pixel in a word */
#define CC_R_PIX  ((ufix16) 0x8000)     /* right most pixel in a word */
#define CC_LEFT_SHIFT(D, S)                                             \
                       ((ufix16) ((D) >> (S)))
#define CC_RIGH_SHIFT(D, S)                                             \
                       ((ufix16) ((D) << (S)))
#else
#define CC_L_PIX  ((ufix16) 0x8000)     /* left  most pixel in a word */
#define CC_R_PIX  ((ufix16) 0x0001)     /* right most pixel in a word */
#ifdef  bSwap
#define SwapWord(S)     ((S) << 8 | (S) >> 8)
#define CC_LEFT_SHIFT(D, S)                                             \
                ((ufix16) SwapWord((ufix16)(SwapWord(D) << (S))))
#define CC_RIGH_SHIFT(D, S)                                             \
                ((ufix16) SwapWord((ufix16)(SwapWord(D) >> (S))))
#else
#define CC_LEFT_SHIFT(D, S)                                             \
                       ((ufix16) ((D) << (S)))
#define CC_RIGH_SHIFT(D, S)                                             \
                       ((ufix16) ((D) >> (S)))
#endif  /* bSwap @WIN */
#endif


#define CC_P_MASK(C)                                                          \
                (CC_RIGH_SHIFT(CC_L_PIX, (C) & CC_PIXEL_MASK))  /* ----*---- */
#define CC_L_MASK(C)                                                          \
                (CC_RIGH_SHIFT(CC_BLACK, (C) & CC_PIXEL_MASK))  /* ----***** */
#define CC_R_MASK(C)                                                          \
                (CC_LEFT_SHIFT(CC_BLACK, (((C) ^ CC_PIXEL_MASK)               \
                                             & CC_PIXEL_MASK))) /* *****---- */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\gs_dummy.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:       gs_dummy.c
 *
 *      Purpose:    This file contains 4 pseudo BAUER PDL operators used
 *                  for debugging: st_dumppath, st_dumpclip, st_countnode,
 *                  and st_countedge.
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      1.0         12/28/87    Performance enhancement:
 *                              1.@TRVSE
 *                                update routines called by traverse_
 *                                path: dump_all_path().
 *                  4/18/88     @CLIP_TBL: move clip_path from
 *                              edge_table to node_table
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) add compiling option: LINT_ARGS
 *                  11/30/88    @ET:
 *                              1) delete count_freeedges()
 *                              2) revise dump_all_edge()
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include        <math.h>
#include        <stdio.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"



#ifdef DBG
#ifdef LINT_ARGS
        static void dump_a_node(struct nd_hdr FAR *);
#else
        static void dump_a_node();
#endif
#endif


fix st_dumppath()
{
#ifdef DBG
        traverse_path(dump_all_path, (fix FAR *)NULLP);
#endif
        return(0);
}

fix st_dumpclip()
{
#ifdef DBG
        printf("clipping information:\n bounding box:");
        dump_all_clip();
#endif
        return(0);
}


fix st_countnode()
{
#ifdef DBG
        fix     ret;
        fix     i;
        struct nd_hdr FAR *node;

        ret = count_freenodes();
        printf("# of free nodes = %d,",ret);
        printf("  current_gs_level = %d\n", current_gs_level);
#ifdef DBG2
        /* dump all nodes that are not in the free list */
        if (ret != MAXNODE) {
                printf("Unfreed nodes:\n");
                for (i=0; i<MAXNODE; i++) {
                        node = &node_table[i];
                        if (node->VX_TYPE != 0x55) {
                                printf("  #%d= ", i);
                                dump_a_node(node);
                        }
                }
        }
#endif
#endif
        return(0);
}

fix st_countedge()
{
        return(0);
}

#ifdef DBG

static void dump_a_node(node)
struct nd_hdr FAR *node;
{

        switch (node->VX_TYPE) {
        case MOVETO :
        case PSMOVE:

                /* @NODE */
                printf("SUBPATH  ");
                printf("flag=%d tail=%d\n",
                       node->SP_FLAG, node->SP_TAIL);

                printf("MOVETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;
        case LINETO:
                printf("LINETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        case CURVETO:
                printf("CURVETO  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        case CLOSEPATH:
                printf("CLOSEPATH  ");
                printf("(%f, %f)  ",
                       node->VERTEX_X, node->VERTEX_Y);
                break;

        default:
                /* @NODE
                 * printf("SUBPATH  ");
                 * printf("flag=%d head=%d tail=%d\n",
                 *        node->SP_FLAG, node->SP_HEAD, node->SP_TAIL);
                 * printf("or TPZD  ");
                 */
                printf("TPZD  ");
                printf("(%f, %f, %f), ", node->CP_TOPY/8.0,
                       node->CP_TOPXL/8.0, node->CP_TOPXR/8.0);
                printf("(%f, %f, %f)\n", node->CP_BTMY/8.0,
                       node->CP_BTMXL/8.0, node->CP_BTMXR/8.0);
        } /* switch */

        printf("next=%d\n", node->next);
}


void dump_all_clip ()
{
        fix     i;
        CP_IDX  itpzd;
        struct nd_hdr FAR *tpzd;

        printf(" (%f, %f),",
               GSptr->clip_path.bb_lx/8.0, GSptr->clip_path.bb_ly/8.0);
        printf(" (%f, %f)\n",
               GSptr->clip_path.bb_ux/8.0, GSptr->clip_path.bb_uy/8.0);
        printf("   single_rect=");
        if (GSptr->clip_path.single_rect)
                printf("TRUE");
        else
                printf("FALSE");
        printf("   inherit=");
        if (GSptr->clip_path.inherit)
                printf("TRUE");
        else
                printf("FALSE");

        printf("\n   clip trapezoids:\n");
        for (i = 1, itpzd = GSptr->clip_path.head; itpzd != NULLP;
             i++, itpzd = tpzd->next) {
                tpzd = &node_table[itpzd];
                printf("   %d) ",i);
                printf("(%f, %f, %f), ", tpzd->CP_TOPY/8.0,
                       tpzd->CP_TOPXL/8.0, tpzd->CP_TOPXR/8.0);
                printf("(%f, %f, %f)\n", tpzd->CP_BTMY/8.0,
                       tpzd->CP_BTMXL/8.0, tpzd->CP_BTMXR/8.0);
        }
}




void dump_all_path (isubpath)
SP_IDX isubpath;
{
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx;
        struct coord FAR *p;
        fix     i;

#ifdef DBG1
        printf("subpath# %d\n", isubpath);
#endif

        /* Traverse the current subpath, and dump all nodes */
        /* for (ivtx = node_table[isubpath].SP_HEAD; @NODE */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];
                p = inverse_transform(F2L(vtx->VERTEX_X),F2L(vtx->VERTEX_Y));

#ifdef DBG1
                printf("#%d", ivtx);
#endif

                switch (vtx->VX_TYPE) {

                case PSMOVE :
                        printf(" %f %f moveto", p->x, p->y);
#ifdef DBG1
                        printf(" Psmove (%f, %f)", p->x, p->y);
                        /* if (node_table[isubpath].SP_FLAG & SP_CURVE) @NODE*/
                        if (vtx->SP_FLAG & SP_CURVE)    /* @NODE */
                                printf(" V");
                        if (vtx->SP_FLAG & SP_OUTPAGE)  /* @NODE */
                                printf(" O");
                        if (vtx->SP_FLAG & SP_DUP)      /* @NODE */
                                printf(" D");
                        printf(", next=%d, tail=%d, sp_next=%d", vtx->next,
                                vtx->SP_TAIL, vtx->SP_NEXT);
#endif
                        printf("\n");
                        break;

                case MOVETO :
                        printf(" %f %f moveto", p->x, p->y);
#ifdef DBG1
                        /* if (node_table[isubpath].SP_FLAG & SP_CURVE) @NODE*/
                        if (vtx->SP_FLAG & SP_CURVE)    /* @NODE */
                                printf(" V");
                        if (vtx->SP_FLAG & SP_OUTPAGE)  /* @NODE */
                                printf(" O");
                        if (vtx->SP_FLAG & SP_DUP)      /* @NODE */
                                printf(" D");
                        printf(", next=%d, tail=%d, sp_next=%d", vtx->next,
                                vtx->SP_TAIL, vtx->SP_NEXT);
#endif
                        printf("\n");
                        break;

                case LINETO :
                        printf(" %f %f lineto\n", p->x, p->y);
                        break;

                case CURVETO :
                        for (i=0; i<2; i++) {
                                printf(" %f %f", p->x,p->y);
                                vtx = &node_table[vtx->next];
                                p = inverse_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                        }
                        printf(" %f %f curveto\n", p->x, p->y);
                        break;

                case CLOSEPATH :
                        printf(" closepath\n");
                        break;

                default:
                        printf(" Unknow node_type=%d\n", node->VX_TYPE);

                } /* switch */

        } /* for loop */

}

void dump_all_edge (first_edge, last_edge)              /* @ET */
fix     first_edge, last_edge;
{
        fix     current_edge;
        struct  edge_hdr FAR *cp;
        fix     i;

        printf("   edge#        topx:topy      endx:endy    x_int\n");
        for (i = 1, current_edge=first_edge; current_edge <= last_edge;
             i++, current_edge++) {

                /*cp = &edge_table[current_edge]; */
                cp = edge_ptr[current_edge];

                printf("%d)  %lx  (%f, %f)  (%f, %f) %f  ", current_edge, cp,
                       SFX2F(cp->ET_TOPX), SFX2F(cp->ET_TOPY),
                       SFX2F(cp->ET_ENDX), SFX2F(cp->ET_ENDY),
                       SFX2F(cp->ET_XINT));

                if (cp->ET_FLAG & HORIZ_EDGE) printf("- ");
                else if (cp->ET_FLAG & WIND_UP) printf("^ ");
                else printf("v ");
                if (cp->ET_FLAG & FREE_EDGE) printf("F ");
                if (cp->ET_FLAG & CROSS_PNT) printf("X ");
                if (cp->ET_WNO) printf("W ");
                printf("\n");
        }
}


fix count_freenodes()
{
        fix     i, inode;
        struct  nd_hdr FAR *node;

        i = 0;
        for (inode = freenode_list; inode != NULLP; ) {
            if (inode > MAXNODE || inode < 0) {
               printf("Fatal error - illegal node entry - %d\n", inode);
               break;
            }
            node = &node_table[inode];
            inode = node ->next;
#ifdef DBG2
            node->VX_TYPE = 0x55;
#endif
            i++;
        }
        return(i);
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\gstate.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   gstate.c
 *
 *      Purpose:
 *
 *      Developer:      J.Jih
 *
 *      History:
 *      Version     Date        Comments
 *                  1/31/89     @STK_OVR: push values to operand stack as many
 *                              as possible until overflow
 *                  1/31/89     @HT_RST: add code to restore legal halftone
 *                              screen when error occurs during setting new
 *                              halftone screen
 *                  5/20/89     update grestoreall_process() to restore
 *                              halftone screen information properly
 *                  6/04/89     fix bug of grestoreall_process() @05/20/89
 *                  11/8/89     fix copy_path_table() bug: reverse flag can not
 *                              be copied
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                              rename copy_node_table() to copy_last_subpath(),
 *                              and set it as a global routine.
 *                  3/13/90     op_sethsbcolor(): special values processing
 *                  8/17/90     grayscale: vm checking for resetting page
 *                  08/24/90    performance enhancement of setscreen, Jack
 *                  12/4/90     @CPPH: copy_path_table(): initialize cp_path
 *                              to be NULLP, when copy path from previous state
 *                              to current one.
 *                  12/14/90    update error checking of op_setscreen for
 *                              compatibility.
 *                  1/9/91      comment 8-24-90 performance enhancement of
 *                              op_setscreen
 *                  3/19/91     op_settransfer(): skip calling interpreter if
 *                              proc is null
 *                  3/20/91     refine the zero check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include       <math.h>
#include        "global.ext"
#include        "graphics.h"
#include        "graphics.ext"
#include        "font.h"
#include        "font.ext"
#include        "fntcache.ext"

#define         WR      .30
#define         WG      .59
#define         WB      .11

/* grayscale 8-1-90 Jack Liaw */
extern ufix32 highmem;
extern ufix32 FAR FBX_BASE;     /* @WIN */
/* papertype changed 10-11-90, JS */
extern ufix32 last_frame;

static real32  near Hue, near Sat,   near Brt;
static real32  near Red, near Green, near Blue;

static bool   near screen_change;

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near copy_stack_content(void);
static void near copy_path_table(void);
/* static void near copy_node_table(struct ph_hdr *);   @DFR_GS */
static void near restore(void);
static real32 near adj_color_domain(long32);
static real32 near hsb_to_gray(void);
static void near hsb_to_rgb(void);
static void near rgb_to_hsb(void);

#else
/* for no type checks of the parameters in function declarations */
static void near copy_stack_content();
static void near copy_path_table();
/* static void near copy_node_table();                  @DFR_GS */
static void near restore();
static real32 near adj_color_domain();
static real32 near hsb_to_gray();
static void near hsb_to_rgb();
static void near rgb_to_hsb();
#endif

/***********************************************************************
 *
 * This module is to check access right of array object
 *
 * TITLE:       access_chk
 *
 * CALL:        access_chk()
 *
 * PARAMETER:   obj_array
 *              flag    : 1  PACKEDARRAY || NORMAL ARRAY
 *                        2  NORMAL ARRAY
 *
 * INTERFACE:   * many *
 *
 * CALLS:       none
 *
 * RETURN:      TRUE  : success
 *              FALSE : failure
 *
 *********************************************************************/
bool
access_chk(obj_array, flag)
struct  object_def      FAR *obj_array;
fix     flag;
{
        if(flag == G_ARRAY){      /* PACKEDARRAY || NORMAL ARRAY */
              if((ACCESS(obj_array) == READONLY) ||
                 (ACCESS(obj_array) == UNLIMITED)){
                      return(TRUE);
              }
              else{
                      ERROR(INVALIDACCESS);
                      return(FALSE);
              }
         }
         else{ /* flag == ARRAY_ONLY,   NORMAL ARRAY */
              if(ACCESS(obj_array) == UNLIMITED){
                      return(TRUE);
              }
              else{
                      ERROR(INVALIDACCESS);
                      return(FALSE);
              }
         }
}

/***********************************************************************
 *
 * This module is to push a copy of graphics state on the graphics
 * state stack
 *
 * SYNTAX:      -    gsave    -
 *
 * TITLE:       op_gsave
 *
 * CALL:        op_gsave()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_gsave)
 *
 * CALLS:       gsave_process
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_gsave()
{
        bool    save_op_flag;

        save_op_flag = FALSE;
        /* process elements of graphics state after current graphics
         * state was copied */
        gsave_process(save_op_flag);

        return(0);
}

/***********************************************************************
 *
 * This module is to copy the current graphics state on the top of
 * graphics state stack
 *
 * TITLE:       copy_stack_content
 *
 * CALL:        copy_stack_content()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near copy_stack_content()
{
        // struct   gs_hdr   near *post_ptr, near *pre_ptr; @WIN
        struct   gs_hdr   FAR *post_ptr, FAR *pre_ptr;

        /* copy the current graphics state on the top of graphics
         * state stack
         */
        pre_ptr = &gs_stack[current_gs_level];
        post_ptr = &gs_stack[current_gs_level + 1];

        *post_ptr = *pre_ptr;
        post_ptr->color.inherit  = TRUE;
        post_ptr->path           = pre_ptr->path + 1;
        post_ptr->clip_path.inherit = TRUE;
        post_ptr->halftone_screen.chg_flag = FALSE;

}


/***********************************************************************
 *
 * This module is to copy the current path table on top of path table
 *
 * TITLE:       copy_path_table
 *
 * CALL:        copy_path_table()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near copy_path_table()
{
        /* copy path table to top of path table stack */
        path_table[GSptr->path].rf = path_table[GSptr->path - 1].rf & ~P_RVSE;
                                /* reverse flag can not be copied; 11/8/89 */
        path_table[GSptr->path].flat = path_table[GSptr->path - 1].flat;
        path_table[GSptr->path].head = NULLP;
        path_table[GSptr->path].tail = NULLP;
        path_table[GSptr->path].cp_path = NULLP;                /* @CPPH */
        path_table[GSptr->path].previous = GSptr->path - 1;

}

/***********************************************************************
 *
 * This module is to copy the last incomplete subpath(node table) to top
 * of path table
 *
 * TITLE:       copy_last_subpath
 *
 * CALL:        copy_last_subpath()
 *
 * PARAMETER:   path_ptr : subpath pointer
 *
 * INTERFACE:   gsave_process
 *
 * CALLS:       get_node
 *
 * RETURN:      none
 *
 **********************************************************************/
void copy_last_subpath(path_ptr)
struct ph_hdr FAR *path_ptr;
{
        fix     inode, idx, sp_node, pre_node;

        if (path_ptr->tail == NULLP) return;

        node_table[path_ptr->tail].SP_FLAG |= SP_DUP;
                                        /* old subpath is duplicated */
        sp_node = NULLP;                /* sub_path node    @NODE */

        for(idx = path_ptr->tail;
            idx != NULLP; idx = node_table[idx].next){
               /* create new node */
               if((inode = get_node()) == NULLP){
                        ERROR(LIMITCHECK);
                        free_node (sp_node);    /* @NODE */
                        return;
               }

                /* copy vertex node */
                node_table[inode].VX_TYPE     = node_table[idx].VX_TYPE;
                node_table[inode].next     = NULLP;
                node_table[inode].VERTEX_X = node_table[idx].VERTEX_X;
                node_table[inode].VERTEX_Y = node_table[idx].VERTEX_Y;

                if(sp_node == NULLP){
                        sp_node = inode;
                }
                else{
                        node_table[pre_node].next   = (VX_IDX)inode;
                }

                pre_node = inode;
        }

        /* setup subpath header @NODE */
        node_table[sp_node].SP_FLAG = (node_table[path_ptr->tail].SP_FLAG) &
                                    (bool8)(~SP_DUP);   //@WIN
                                /* copy subpath flag and set not duplicated */
        node_table[sp_node].SP_NEXT = NULLP;
        node_table[sp_node].SP_TAIL = (VX_IDX)inode;
        path_table[GSptr->path].head = (SP_IDX)sp_node;
        path_table[GSptr->path].tail = (SP_IDX)sp_node;
}


/***********************************************************************
 *
 * This module is to process elements of graphics state after current
 * graphics state was copied
 *
 * TITLE:       gsave_process
 *
 * CALL:        gsave_process()
 *
 * PARAMETER:   save_op_flag : check invoking source
 *                             TRUE:  invoked by save_op
 *                             FALSE: invoked by gsave_op
 *
 * INTERFACE:   op_gsave, op_save
 *
 * CALLS:       font_save
 *
 * RETURN:      none
 *
 **********************************************************************/
bool
gsave_process(save_op_flag)
bool    save_op_flag;
{
        struct  ph_hdr  FAR *path_ptr;

        /* check limitcheck error */
        if(current_gs_level >= (MAXGSL - 1)){
                ERROR(LIMITCHECK);
                return(FALSE);
        }

        /* copy the current graphics state on the top of graphics state stack */
        copy_stack_content();

        current_gs_level ++;
        GSptr = &gs_stack[current_gs_level];
        /* GSptr point to the current graphics state */

        if(save_op_flag == RESTORE) GSptr->save_flag = TRUE;
        else                        GSptr->save_flag = (fix16)save_op_flag;

        GSptr->halftone_screen.chg_flag = FALSE;

        /* set device not being changed; @DEVICE */
        GSptr->device.chg_flg = FALSE;

        /* copy path table to top of path table stack */
        copy_path_table();

        /* trace the inherit path to find whether last subpath is incomplete */
        path_ptr = &path_table[GSptr->path - 1];
        if(path_ptr->tail != NULLP &&
           node_table[node_table[path_ptr->tail].SP_TAIL].VX_TYPE != CLOSEPATH){
                path_table[GSptr->path].rf |= P_DFRGS;
        }
        else if(path_ptr->tail != NULLP){
                node_table[path_ptr->tail].SP_FLAG &= ~SP_DUP;
        }

        /* ??? */
        if(save_op_flag == TRUE){
                font_save();
        }

        return(TRUE);
}

/***********************************************************************
 *
 * This is to reset the current graphics state
 *
 * TITLE:       restore
 *
 * CALL:        restore()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_grestore, op_grestoreall
 *
 * CALLS:       free_path, free_edge
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near restore()
{
        fix GEIeng_checkcomplete();

        /* deallocate all nodes of the current subpaths to node table */
        free_path();

        if(GSptr->clip_path.inherit == FALSE){

                /* deallocate  all nodes of the current clipping path
                 * to edge table */
                free_node(GSptr->clip_path.head);
                GSptr->clip_path.head = GSptr->clip_path.tail = NULLP;
        }

        /* restore gray table , create in settransfer */
        if(GSptr->color.inherit == TRUE) GSptr->color.adj_gray --;

#ifdef  DBGs
        printf("restore: %d verify screen\n", current_gs_level);
#endif
        if(GSptr->halftone_screen.chg_flag == TRUE){
#ifdef  DBGs
                printf("restore: %d change screen\n", current_gs_level);
#endif
                gs_stack[current_gs_level - 1].halftone_screen.no_whites
                    = -1; /* 03-14-1988 */
                screen_change = TRUE;
#ifdef  DBGs
                printf("screen change: %d  just set\n", screen_change);
#endif
        }
        else {
                if(gs_stack[current_gs_level - 1].halftone_screen.no_whites
                                        != GSptr->halftone_screen.no_whites)
                    gs_stack[current_gs_level - 1].halftone_screen.no_whites
                        = -2; /* 03-14-1988,  -1 -> -2  Y.C. Chen 20-Apr-88 */
        }
        current_gs_level --;
#ifdef  DBGs
        printf("screen change: %d  gs--\n", screen_change);
#endif

        /* restore the current graphics state */
        GSptr = &gs_stack[current_gs_level];
        if(path_table[GSptr->path].tail != NULLP)       /* 02/12/92 SC */
        node_table[path_table[GSptr->path].tail].SP_FLAG &= ~SP_DUP;    /* 04/29/91, Peter */

#ifdef  DBGs
        printf("screen change: %d  gsptr\n", screen_change);
#endif

        spot_usage = GSptr->halftone_screen.spotindex           /* 03-12-87 */
                   + GSptr->halftone_screen.cell_size
                   * GSptr->halftone_screen.cell_size;
#ifdef  DBGs
        printf("screen change: %d  usage\n", screen_change);
#endif

        /* reset the page configuration if device header has been changed;
         * 8-1-90 Jack Liaw                                        @DEVICE
         */
        if (gs_stack[current_gs_level + 1].device.chg_flg &&
            (GSptr->device.nuldev_flg != NULLDEV)) {
/* @WIN; fix the starting address of frame buffer; not need to adjust FBX */
#ifdef XXX
                /* limit error check - grayscale 8-1-90 Jack Liaw */
                {
                    ufix32      l_diff, frame_size;
                    ufix32      twidth;

                    twidth = (((ufix32) (GSptr->device.width / 8) + 3) / 4) * 4;
                    frame_size = twidth * (ufix32) GSptr->device.height;
                    /* BEGIN, papertype changed 10-11-90, JS */
                    if (frame_size != last_frame) {
                       /*  wait until laser printer turns ready  */
                       while (GEIeng_checkcomplete()) ;
                       last_frame = frame_size;
                    }
                    /* END 10-11-90, JS */
                    DIFF_OF_ADDRESS (l_diff, fix32, (byte FAR *)highmem, (byte FAR*)vmptr);
                    if (frame_size > l_diff) {
                        ERROR(LIMITCHECK);
                        return;
                    } else {
                        vmheap = (byte huge *)(highmem - frame_size);
                        FBX_BASE = highmem - frame_size;
                    }
                }
#endif
                reset_page (GSptr->device.width, GSptr->device.height, 1);
#ifdef  DBGs
                printf("screen change: %d  reset\n", screen_change);
#endif
        }

#ifdef  DBGs
        printf("screen change: %d  done\n", screen_change);
#endif

        return;
}


/***********************************************************************
 *
 * This is to reset the current graphics state from the one that was
 * saved by matching gsave_op
 *
 * SYNTAX:      -    grestore    -
 *
 * TITLE:       op_grestore
 *
 * CALL:        op_grestore()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_grestore)
 *
 * CALLS:       restore, gsave_process, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_grestore()
{
        bool    save_flag;
        fix     gray_index, old_gray_val;

        /* check if there is matching gsave */
        if(current_gs_level == 0 ){
                return(0);
        }
        else {
               save_flag = GSptr->save_flag;

               gray_index = (fix)(GSptr->color.gray * 255);
               old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

               /* restore save level, initial screen_change = FALSE */
               screen_change = FALSE;
               restore();

               /* save graphics state */
               if(save_flag == TRUE){
                        gsave_process(RESTORE);
               }

               gray_index =(fix)(GSptr->color.gray * 255);
               /* restore the spot_matrix and halftone_grid, if necessary */
               if(screen_change == TRUE ||
               old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                       FillHalfTonePat();
               }

               gf_restore();
               return(0);
        }

}


/***********************************************************************
 *
 * This module is to reset the current graphic sstate from the on that
 * was saved by save_op or bottommost graphics state
 *
 * SYNTAX:      -    grestoreall    -
 *
 * TITLE:       op_grestoreall
 *
 * CALL:        op_grestoreall()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_grestoreall)
 *
 * CALLS:       grestoreall_process
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_grestoreall()
{
        grestoreall_process(FALSE);
        return(0);
}

/***********************************************************************
 *
 * This module is to main routine of op_grestoreall
 *
 * TITLE:       grestoreall_process
 *
 * CALL:        grestoreall_process(flag)
 *
 * PARAMETER:   flag : TRUE : called by restore operator
 *                     FALSE: called by grestoreall operator
 *
 * INTERFACE:   op_grestoreall
 *
 * CALLS:       restore, font_restore, gsave_process, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
void grestoreall_process(flag)
bool    flag;
{
        fix     gray_index, old_gray_val;

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        screen_change = FALSE;
        /* check if there is matching save */
        while(current_gs_level != 0 && GSptr->save_flag == FALSE){
                /* restore graphics state */
                restore();
        }

        if(GSptr->save_flag == TRUE){
                /* restore save level  */
                restore();

                /* save graphics state (called by grestoreall operator) */
                if(flag == FALSE) gsave_process(RESTORE);
        }

        /* restore the spot_matrix and halftone_grid, if necessary */
        gray_index = (fix)(GSptr->color.gray * 255);
        if(screen_change == TRUE ||
           old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                /* force halftone cache to be flushed */
                if (screen_change == TRUE)                      /* 06-04-89 */
                    GSptr->halftone_screen.no_whites = -1;
                FillHalfTonePat();
        }

        /* restore font  : called by restore */
        if(flag == TRUE) font_restore();

        gf_restore();
}


/***********************************************************************
 *
 * This module is to reset several values in the current graphics state
 * to their default values
 *
 * SYNTAX:      -    initgraphics    -
 *
 * TITLE:       op_initgraphics
 *
 * CALL:        op_initgraphics()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_initgraphics)
 *
 * CALLS:       op_newath, op_initclip, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_initgraphics()
{
        ufix16  i;
        fix     gray_index, old_gray_val;

        /* init current matrix */
        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->ctm[i] = GSptr->device.default_ctm[i];
        }

        /* deallocate all nodes of the current subpath to node table */
        op_newpath();

        /* allocate nodes to create a default clipping path and
         * chain it to clip path */
        op_initclip();

        gray_index   = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        GSptr->color.gray   = zero_f;
        GSptr->color.hsb[0] = zero_f;
        GSptr->color.hsb[1] = zero_f;
        GSptr->color.hsb[2] = zero_f;
        GSptr->line_width   = one_f;
        GSptr->line_join    = 0;
        GSptr->line_cap     = 0;
        GSptr->dash_pattern.pat_size = 0;
        GSptr->dash_pattern.offset   = zero_f;
        create_array(&GSptr->dash_pattern.pattern_obj, 0);
        GSptr->miter_limit = (real32)10.0;

        gray_index = (fix)(GSptr->color.gray * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                FillHalfTonePat();
        }

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current line width in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setlinewidth    -
 *
 * TITLE:       op_setlinewidth
 *
 * CALL:        op_setlinewidth()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinewidth)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinewidth()
{
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        GET_OBJ_VALUE(GSptr->line_width, obj_num);
        FABS(GSptr->line_width, GSptr->line_width);

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the value of the line width in the current
 * graphics state
 *
 * SYNTAX:      -       currentlinewidth        num
 *
 * TITLE:       op_currentlinewidth
 *
 * CALL:        op_currentlinewidth()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinewidth)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinewidth()
{
        union   four_byte       line_width4;

        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line width on the operand stack */
        line_width4.ff = GSptr->line_width;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, line_width4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current line cap in the current graphics
 * state to the specific value
 *
 * SYNTAX:      int     setlinecap      -
 *
 * TITLE:       op_setlinecap
 *
 * CALL:        op_setlinecap()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinecap)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinecap()
{
        union   four_byte intg4;
        struct  object_def FAR *obj_intg;

        /* get operand */
        obj_intg = GET_OPERAND(0);

        intg4.ll = (fix32)VALUE(obj_intg);

        /* check rangecheck error */
        if(intg4.ll < 0 || intg4.ll > 2){
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->line_cap = (fix)intg4.ll;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the line cap in the
 * current graphics state
 *
 * SYNTAX:      -    currentlinecap     int
 *
 * TITLE:       op_currentlinecap
 *
 * CALL:        op_currentlinecap()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinecap)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinecap()
{
        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line cap on the operand stack */
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0,
                                            (ufix32)GSptr->line_cap);
        return(0);
 }


/***********************************************************************
 *
 * This module is to set the current line join in the current graphics
 * state to the specific value
 *
 * SYNTAX:      int     setlinejoin     -
 *
 * TITLE:       op_setlinejoin
 *
 * CALL:        op_setlinejoin()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setlinejoin)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setlinejoin()
{
        union   four_byte  intg4;
        struct  object_def FAR *obj_intg;

        /* get operand */
        obj_intg = GET_OPERAND(0);

        intg4.ll = (fix32)VALUE(obj_intg);

        /* check rangecheck error */
        if(intg4.ll < 0 || intg4.ll > 2){
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->line_join = (fix)intg4.ll;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the line join in the
 * current graphics state
 *
 * SYNTAX:      -       currentlinejoin int
 *
 * TITLE:       op_currentlinejoin
 *
 * CALL:        op_currentlinejoin()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentlinejoin)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentlinejoin()
{
        /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current line join on the operand stack */
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0,
                                            (ufix32)GSptr->line_join);
        return(0);
}


/***********************************************************************
 *
 * This module is to set the current miter limit in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setmiterlimit   -
 *
 * TITLE:       op_setmiterlimit
 *
 * CALL:        op_setmiterlimit()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setmiterlimit)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setmiterlimit()
{
        real32   miter_limit;
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        /* check rangecheck error */
        GET_OBJ_VALUE(miter_limit, obj_num);
        if(miter_limit < one_f) {
                ERROR(RANGECHECK);
                return(0);
        }

        GSptr->miter_limit = miter_limit;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the miter limit in the
 * current graphics state
 *
 * SYNTAX:      -       currentmiterlimit       num
 *
 * TITLE:       op_currentmiterlimit
 *
 * CALL:        op_currentmiterlimit()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentmiterlimit)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentmiterlimit()
{
        union   four_byte       miter_limit4;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current miter limit on the operand stack */
        miter_limit4.ff = GSptr->miter_limit;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, miter_limit4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current dash patternin the current graphics
 * graphics state to the specific value
 *
 * SYNTAX:      array   offset  setdash    -
 *
 * TITLE:       op_setdash
 *
 * CALL:        op_setdash()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setdash)
 *
 * CALLS:       get_array
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setdash()
{
        ufix16  i;
        ufix16  array_length, zero_count;
        bool    negative_flag;
        real32   pattern[11];
        struct  object_def FAR *obj_array, FAR *obj_offset;

        /* get operand */
        obj_offset = GET_OPERAND(0);
        obj_array  = GET_OPERAND(1);

        /* get array length */
        array_length = LENGTH(obj_array);

        /* check limitcheck error */
        if(array_length > MAXDASH){
                ERROR(LIMITCHECK);
                return(0);
        }

        if( !access_chk(obj_array, G_ARRAY)) return(0);

        if( !get_array_elmt(obj_array,array_length,pattern,G_ARRAY) )
             return(0);

        zero_count = 0;
        negative_flag = FALSE;

        for(i = 0; i < array_length; i++){
                /*if(F2L(pattern[i]) == F2L(zero_f)) zero_count++; 3/20/91;sc*/
                if(IS_ZERO(pattern[i])) zero_count++;
                /*if(pattern[i] <  zero_f) negative_flag = TRUE; 3/20/91;sc */
                if(SIGN_F(pattern[i])) negative_flag = TRUE;
        }

        if((array_length > 0 && zero_count == array_length) ||
           (negative_flag == TRUE)){
                ERROR(RANGECHECK);
                return(0);
        }
        else{
                for(i = 0; i < array_length; i++){
                    GSptr->dash_pattern.pattern[i] = pattern[i];
                }
        }

        /* save each elements of array to pattern, and no. of element
         * to pat_size */

        GSptr->dash_pattern.pat_size = array_length;
        COPY_OBJ(obj_array, &GSptr->dash_pattern.pattern_obj);
        GET_OBJ_VALUE(GSptr->dash_pattern.offset, obj_offset );

        /* compute the adjusted dash pattern */
        /* init_dash_pattern();    12-8-90 */

        /* pop operand stack */
        POP(2);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the dash pattern in
 * the current graphics state
 *
 * SYNTAX:      -       currentdash     array   offset
 *
 * TITLE:       op_currentdash
 *
 * CALL:        op_currentdash()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentdash)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentdash()
{
        union   four_byte      offset4;

        /* push array object on the operand stack */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_OBJ(&GSptr->dash_pattern.pattern_obj);

        /* push GSptr->dash_pattern.offset on the operand stack */
        offset4.ff = GSptr->dash_pattern.offset;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, offset4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current flatness tolerance in the current
 * graphics state to the specific value
 *
 * SYNTAX:      num     setflat     -
 *
 * TITLE:       op_setflat
 *
 * CALL:        op_setflat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setflat)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setflat()
{
        real32   num;
        struct  object_def      FAR *obj_num;

        /* get operand */
        obj_num = GET_OPERAND(0);

        GET_OBJ_VALUE(num, obj_num );

        /* set range 0.2 <= num <= 100.0 */
        if(num < (real32)0.2)         num = (real32)0.2;
        else if(num > (real32)100.0)  num = (real32)100.0;

        GSptr->flatness = num;

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the flatness torlence
 * in the current graphics state
 *
 * SYNTAX:      -       currentflat     num
 *
 * TITLE:       op_currentflat
 *
 * CALL:        op_currentflat()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentflat)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentflat()
{
        union   four_byte       flatness4;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current flatness on the operand stack */
        flatness4.ff = GSptr->flatness;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, flatness4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current gray level in the current graphics
 * state to the specific value
 *
 * SYNTAX:      num     setgray     -
 *
 * TITLE:       op_setgray
 *
 * CALL:        op_setgray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setgray)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setgray()
{
        real32   num;
        struct  object_def      FAR *obj_num, name_obj;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "setgray", 7, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* get operand */
        obj_num = GET_OPERAND(0);

        /* adjust num value */
        GET_OBJ_VALUE(num, obj_num );
        num = (real32)floor(num * 255 + 0.5) / 255;

        /* set range 0.0 <= num <= 1.0 */
        if(num > one_f)      num = one_f;
        /*else if(num < zero_f) num = zero_f; 3/20/91; scchen */
        else if(SIGN_F(num)) num = zero_f;

        setgray(F2L(num));

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current gray level in the current graphics
 * state to the specific value
 *
 * TITLE:       setgray
 *
 * CALL:        setgray(num)
 *
 * PARAMETER:   num
 *
 * INTERFACE:   op_setgray
 *
 * CALLS:       FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
void setgray(l_num)
long32   l_num;
{
        real32   num;
        fix     gray_index, old_gray_val;

        num = L2F(l_num);

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        /* set the current gray level to the specific value */
        GSptr->color.hsb[0] = zero_f;
        GSptr->color.hsb[1] = zero_f;
        GSptr->color.hsb[2] = num;
        GSptr->color.gray   = num;

        gray_index = (fix)(num * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                FillHalfTonePat();
        }
}


/***********************************************************************
 *
 * This module is to return the current value of the gray level in the
 * current graphics state
 *
 * SYNTAX:      -       currentgray     num
 *
 * TITLE:       op_currentgray
 *
 * CALL:        op_currentgray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentgray)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentgray()
{
        union   four_byte       hsb24;

       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current gray level on the operand stack */
        hsb24.ff = GSptr->color.gray;
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb24.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to adjust color elements (HSB, RGB) to be in domain
 * [0, 1]
 *
 * TITLE:       adj_color_domain
 *
 * CALL:        adj_color_domain
 *
 * PARAMETER:   color_elmt
 *
 * INTERFACE:   op_setrgbcolor, op_sethsbcolor
 *
 * CALLS:       none
 *
 * RETURN:      color_elmt: adjusted color_elmt
 *
 * HISTORY: modified by J. Lin, 12-16-88 color_elmt value be digitized by
 *          1/255 quantity.
 *
 **********************************************************************/
static real32 near adj_color_domain(l_color_elmt)
long32   l_color_elmt;
{
        real32   color_elmt;

        color_elmt = L2F(l_color_elmt);

        /*if (color_elmt < zero_f) 3/20/91; scchen */
        if (SIGN_F(color_elmt))
           color_elmt = zero_f;
        else if (color_elmt > one_f)
           color_elmt = one_f;
        else
           color_elmt = (real32)((fix)(color_elmt * 255 + (real32)0.5)) / (real32)255.;
        return(color_elmt);
}


/***********************************************************************
 *
 * This module is to get gray value from Hue, Sat, and Blue. The sequence
 * is as follows.
 *
 *   HSB_TO_RBG
 *   Gray = WR * Red + WG * Green + WB * Blue
 *
 * TITLE:       hsb_to_gray
 *
 * CALL:        hsb_to_gray()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_sethsbcolor
 *
 * CALLS:       none
 *
 * RETURN:      gray value
 *
 * HISTORY: added by J. Lin, 8-12-88
 *          modified by J. Lin, 12-14-88
 **********************************************************************/
static real32 near hsb_to_gray()
{

    /* invoke hsb_to_rgb procedure to get the corresponding RGB value */
    hsb_to_rgb();
    return((real32)(WR * Red + WG * Green + WB * Blue));
}

/***********************************************************************
 *
 * This module is to translate RGB to HSB (presented by Alvy Ray Smith,
 * base on NTSC case)
 *
 * TITLE:       rgb_to_hsb
 *
 * CALL:        rgb_to_hsb()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_setrgbcolor
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near rgb_to_hsb()
{
        real32 min, max, rc, gc, bc;

        /* find min. and max. of (Red, Green, Blue) */
        if (Red > Green) {
                max = Red;
                min = Green;
        } else {
                max = Green;
                min = Red;
        }
        if (Blue > max) max = Blue;
        else if (Blue < min) min = Blue;

        /* find brightness (Brt) */
        Brt = max;

        /* find saturation (Sat) */
        /*if (F2L(max) != F2L(zero_f)) Sat = (max - min) / max; 3/20/90;scchen
         *else    Sat = zero_f;
         */
        if (IS_ZERO(max)) Sat = zero_f;
        else    Sat = (max - min) / max;

        /* find hue */
        /*if (F2L(Sat) == F2L(zero_f)) Hue = zero_f; 3/20/91; scchen */
        if (IS_ZERO(Sat)) Hue = zero_f;
        else {  /* saturation not zero, so determine hue */
                rc = (max - Red) / (max - min);
                gc = (max - Green) / (max - min);
                bc = (max - Blue) / (max - min);

                if (Red == max) {
                        if (Green == min)
                                Hue = 5 + bc;
                        else /* Blue == min */
                                Hue = 1 - gc;
                } else if (Green == max) {
                        if (Blue == min)
                                Hue = 1 + rc;
                        else /* Red == min */
                                Hue = 3 - bc;
                } else {        /* Blue == max */
                        if (Red == min)
                                Hue = 3 + gc;
                        else
                                Hue = 5 - rc;
                }
                if (Hue >= (real32)6.0) Hue = Hue - 6;
                Hue = Hue / 6;
        }

}


/***********************************************************************
 *
 * This module is to translate HSB to RGB (presented by Alvy Ray Smith
 * base on NTSC case)
 *
 * TITLE:       hsb_to_rgb
 *
 * CALL:        hsb_to_rgb()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   op_currentrgbcolor
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near hsb_to_rgb()
{

        fix     i;
        real32   h, f, p, q, t;

        h = Hue * (real32)360.;

        /*if (F2L(Sat) == F2L(zero_f)) { 3/20/91; scchen */
        if (IS_ZERO(Sat)) {   /* achromatic color; there is no hue */
           /*if (F2L(h) == F2L(zero_f)) {  3/20/91; scchen*/
           if (IS_ZERO(h)) {        /* achromatic case */
              Red = Brt;
              Green = Brt;
              Blue = Brt;
           } else {                /* error if Sat=0 and h has a value */
              return;
           }
        } else {        /* Sat != 0, achromatic color; there is a hus */
           if (h == (real32)360.0)
              h = zero_f;
           h = h / 60;
           i = (fix)floor(h);
           f = h - i;
           p = Brt * (1 - Sat);
           q = Brt * (1 - (Sat * f));
           t = Brt * (1 - (Sat * (1 - f)));
           switch (i) {
           case 0 :
                   Red = Brt;
                   Green = t;
                   Blue = p;
                   break;
           case 1 :
                   Red = q;
                   Green = Brt;
                   Blue = p;
                   break;
           case 2 :
                   Red = p;
                   Green = Brt;
                   Blue = t;
                   break;
           case 3 :
                   Red = p;
                   Green = q;
                   Blue = Brt;
                   break;
           case 4 :
                   Red = t;
                   Green = p;
                   Blue = Brt;
                   break;
           case 5 :
                   Red = Brt;
                   Green = p;
                   Blue = q;
                   break;
           } /* switch */
        } /* if */

}


/***********************************************************************
 *
 * This module is to set the current color in the current graphics
 * state to the specific hue, sat, and brt values
 *
 * SYNTAX:      hue   sat   brt   sethsbcolor   -
 *
 * TITLE:       op_sethsbcolor
 *
 * CALL:        op_sethsbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_sethsbcolor)
 *
 * CALLS:       FillHalfTonePat
 *
 * RETURN:      none
 *
 * HISTORY: modified by J. Lin, 8-12-88
 *          modified by J. Lin, 12-16-88, when S=0, H should be to 0.
 **********************************************************************/
fix
op_sethsbcolor()
{
        struct  object_def  name_obj;
        real32   gray;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "sethsbcolor", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        GET_OBJ_VALUE(Hue, GET_OPERAND(2));
        GET_OBJ_VALUE(Sat, GET_OPERAND(1));
        GET_OBJ_VALUE(Brt, GET_OPERAND(0));

        Hue = adj_color_domain(F2L(Hue));
        Sat = adj_color_domain(F2L(Sat));
        Brt = adj_color_domain(F2L(Brt));

        /* Special values processing 3/13/90 */
        /*if (F2L(Brt) == F2L(zero_f)) { 3/20/91; scchen */
        if (IS_ZERO(Brt)) {
           Hue = (real32)0.0;
           Sat = (real32)0.0;
        }
        /*if (F2L(Sat) == F2L(zero_f)) {        3/20/91; scchen */
        if (IS_ZERO(Sat)) {          /* 3/13/90 */
           Hue = (real32)0.0;
        } else {
           /*if (F2L(Hue) == F2L(zero_f))       3/20/91; scchen */
           if (IS_ZERO(Hue))         /* 3/13/90 */
              Hue = (real32)1.0;
        }

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        /* get a gray value from HSB */
        gray = hsb_to_gray();
        if(GSptr->color.gray != gray) {
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }

        /* pop operand stack */
        POP(3);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the color in the
 * current graphics state
 *
 * SYNTAX:      -       currenthsbcolor   hue  sat  brt
 *
 * TITLE:       op_currenthsbcolor
 *
 * CALL:        op_currenthsbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currenthsbcolor)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currenthsbcolor()
{
       union    four_byte       hsb4;

        /* push hue sat brt on operand stack */
        hsb4.ff = GSptr->color.hsb[0];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);
        hsb4.ff = GSptr->color.hsb[1];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);
        hsb4.ff = GSptr->color.hsb[2];
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, hsb4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current color in the current graphics
 * state to the specific red, green, and blue values
 *
 * SYNTAX:      red  green  blue  setrgbcolor   -
 *
 * TITLE:       op_setrgbcolor
 *
 * CALL:        op_setrgbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setrgbcolor)
 *
 * CALLS:       FillHalfTonePat, rgb_to_hsb
 *
 * RETURN:      none
 *
 *
 * HISTORY: modified by J. Lin, 8-12-88
 *          modified by J. Lin, 12-14-88 for gray value
 **********************************************************************/
fix
op_setrgbcolor()
{
        struct  object_def  name_obj;
        real32  gray;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "setrgbcolor", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        GET_OBJ_VALUE(Red, GET_OPERAND(2));
        GET_OBJ_VALUE(Green, GET_OPERAND(1));
        GET_OBJ_VALUE(Blue, GET_OPERAND(0));

        Red   = adj_color_domain(F2L(Red));
        Green = adj_color_domain(F2L(Green));
        Blue  = adj_color_domain(F2L(Blue));

        /* invoke rgb_to_hsb procedure to get the corresponding HSB
         * value */
        rgb_to_hsb();

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        gray = (real32)(WR * Red + WG * Green + WB * Blue);
        if(GSptr->color.gray != gray){
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }

        /*pop operand stack */
        POP(3);
        return(0);
}

#ifdef WIN
/***********************************************************************
 *
 **********************************************************************/
void
setrgbcolor(red, green, blue)
long32  red, green, blue;
{
        real32  gray;

        Red   = adj_color_domain(red);
        Green = adj_color_domain(green);
        Blue  = adj_color_domain(blue);

        /* invoke rgb_to_hsb procedure to get the corresponding HSB
         * value */
        rgb_to_hsb();

        /* set the current color to the specific value */
        GSptr->color.hsb[0] = Hue;
        GSptr->color.hsb[1] = Sat;
        GSptr->color.hsb[2] = Brt;

        gray = (real32)(WR * Red + WG * Green + WB * Blue);     /* 12-14-88 */
        if(GSptr->color.gray != gray){
                GSptr->color.gray = gray;
                FillHalfTonePat();
        }
}

#endif


/***********************************************************************
 *
 * This module is to return the current value of the color in the
 * current graphics state
 *
 * SYNTAX:      -       currentrgbcolor red  green  blue
 *
 * TITLE:       op_currentrgbcolor
 *
 * CALL:        op_currentrgbcolor()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currentrgbcolor)
 *
 * CALLS:       hsb_to_rgb
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentrgbcolor()
{
       union four_byte  rgb4;

        Hue = GSptr->color.hsb[0];
        Sat = GSptr->color.hsb[1];
        Brt = GSptr->color.hsb[2];

        /* invoke hsb_to_rgb procedure to get the corresponding RGB
         * value */
        hsb_to_rgb();

        /* push Red Green Blue on operand stack */
        rgb4.ff = Red;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);
        rgb4.ff = Green;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);
        rgb4.ff = Blue;
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, rgb4.ll);

        return(0);
}


/***********************************************************************
 *
 * This module is to set the current resolution or dpi of device
 *
 * SYNTAX:      resolution  setscreen
 *
 * TITLE:       st_setresolution
 *
 * CALL:        st_setresolution()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(st_setresolution)
 *
 * CALLS:       SetHalfToneCell, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
st_setresolution()                                              /* @RES */
{
        fix                     res;
        struct  object_def      FAR *obj_res;

        if (COUNT() < 1) {
           ERROR(STACKUNDERFLOW);
           return(0);
        }

        /* get operand */
        obj_res = GET_OPERAND(0);

        if (TYPE(obj_res) != INTEGERTYPE) {
           ERROR(TYPECHECK);
           return(0);
        }

        /* get resolution */
        res = (fix) VALUE(obj_res);

        if (res < MIN_RESOLUTION || res > MAX_RESOLUTION) {
           ERROR(RANGECHECK);
           return(0);
        }

        /* update resolution and setscreen and setgray */
        resolution = res;

        /* invoke SetHalfToneCell procedure to regenerate the
         * spot_matrix based on the current halftone screen */
        SetHalfToneCell();

        /* invoke FillhalftonePat procedure to regenerate the
         * halftone_cel and repeat_pattern based on the current
         * spot_matrix and gray */
        FillHalfTonePat();

        /* pop operand stack */
        POP(1);

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current resolution of device
 *
 * SYNTAX:      -       currentresolution   resolution
 *
 * TITLE:       st_currentresolution
 *
 * CALL:        st_currentresolution()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(currentresolution)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
st_currentresolution()                                          /* @RES */
{
       /* check if operand stack no free space */
        if (FRCOUNT() < 1){
           ERROR(STACKOVERFLOW);
        } else {
        /* push current resolution on the operand stack */
           PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, (ufix32)resolution);
        }
        return(0);
}


/***********************************************************************
 *
 * This module is to set the current halftone screen in the current
 * graphics state to the specific value
 *
 * SYNTAX:      freq  angle  proc  setscreen    -
 *
 * TITLE:       op_setscreen
 *
 * CALL:        op_setscreen()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_setscreen)
 *
 * CALLS:       SetHalfToneCell, FillHalfTonePat
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_setscreen()
{
/*      real32  angle;                                  (* ph, 8-24-90, Jack */
        real32  freq;
        struct  object_def     FAR *obj_freq, FAR *obj_angle, FAR *obj_proc;

        ufix16  gerc_save;                              /* @HT_RST: 01-31-89 */
        real32  freq_save;                              /* @HT_RST: 01-31-89 */
        real32  angle_save;                             /* @HT_RST: 01-31-89 */
        struct  object_def      proc_save;              /* @HT_RST: 01-31-89 */

        /* get operand */
        obj_proc  = GET_OPERAND(0);
        obj_angle = GET_OPERAND(1);
        obj_freq  = GET_OPERAND(2);

        GET_OBJ_VALUE(freq, obj_freq);
        /* if(freq <= zero_f){ (* 12-14-90, Jack *) 3/20/91; scchen*/
        if(IS_ZERO(freq)) {
                ERROR(UNDEFINEDRESULT);
                return(0);
        }

        /* performance enhancement, 8-24-90, Jack, begin *)
        GET_OBJ_VALUE(angle, obj_angle);

#ifdef DBG1x
        printf("Input: freq = %f, angle = %f\n", freq, angle);
        printf("Input: proc = %ld\n", VALUE(obj_proc));
        printf("Input: bitfield = %x\n", obj_proc->bitfield);
        printf("Gstate:freq = %f, angle = %f\n", GSptr->halftone_screen.freq,
                GSptr->halftone_screen.angle);
        printf("Gstate:proc = %ld\n", GSptr->halftone_screen.proc.value);
        printf("Gstate:bitfield = %x\n", GSptr->halftone_screen.proc.bitfield);
#endif

        if ( (freq == GSptr->halftone_screen.freq) &&
             (angle == GSptr->halftone_screen.angle) &&
             (LEVEL(obj_proc) >= LEVEL(&GSptr->halftone_screen.proc)) &&
             (VALUE(obj_proc) == GSptr->halftone_screen.proc.value) ) {
#ifdef DBG1x
            printf(" screen isn't changed ...\n");
#endif
            POP(3);
            return(0);             (* screen isn't changed *)
        }
#ifdef DBG1x
        printf(" change screen ???\n");
#endif
        (* performance enhancement, 8-24-90, Jack, end */

        /* save last screen parameters */
        freq_save  = GSptr->halftone_screen.freq;       /* @HT_RST: 01-31-89 */
        angle_save = GSptr->halftone_screen.angle;      /* @HT_RST: 01-31-89 */
        COPY_OBJ(&GSptr->halftone_screen.proc,          /* @HT_RST: 01-31-89 */
                 &proc_save);

        GSptr->halftone_screen.freq  = freq;
        GET_OBJ_VALUE(GSptr->halftone_screen.angle, obj_angle);
        COPY_OBJ(obj_proc, &GSptr->halftone_screen.proc);

        /* pop operand stack */
        POP(3);

        /* invoke SetHalfToneCell procedure to regenerate the
         * spot_matrix based on the current halftone screen */
        SetHalfToneCell();

        if (ANY_ERROR()) {                              /* @HT_RST: 01-31-89 */

            /* save global_error_code */
            gerc_save = ANY_ERROR();
            CLEAR_ERROR();

            /* restore last screen parameters */
            GSptr->halftone_screen.freq  = freq_save;   /* @HT_RST: 01-31-89 */
            GSptr->halftone_screen.angle = angle_save;  /* @HT_RST: 01-31-89 */
            COPY_OBJ(&proc_save,                        /* @HT_RST: 01-31-89 */
                     &GSptr->halftone_screen.proc);

            /* invoke SetHalfToneCell procedure to regenerate the
             * spot_matrix based on the current halftone screen */
            SetHalfToneCell();

            /* invoke FillhalftonePat procedure to regenerate the
             * halftone_cel and repeat_pattern based on the current
             * spot_matrix and gray */
            FillHalfTonePat();

            /* restore global_error_code */
            ERROR(gerc_save);

        } else {

            /* invoke FillhalftonePat procedure to regenerate the
             * halftone_cel and repeat_pattern based on the current
             * spot_matrix and gray */
            FillHalfTonePat();

        }

        return(0);
}


/***********************************************************************
 *
 * This module is to return the current value of the halftone screen
 * in the current graphics state
 *
 * SYNTAX:      -       currentscreen  freq  angle  proc
 *
 * TITLE:       op_currentscreen
 *
 * CALL:        op_currentscreen()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(currentscreen)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currentscreen()
{
        union   four_byte       freq4, angle4;

        /* push GSptr->halfscreen on the operand stack */
        freq4.ff = GSptr->halftone_screen.freq;
        angle4.ff = GSptr->halftone_screen.angle;

        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, freq4.ll);
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, angle4.ll);
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }
        PUSH_OBJ(&GSptr->halftone_screen.proc);

        return(0);
}


/**********************************************************************
 *
 * This module is to set the current gray transfer function in the
 * current graphics state to the specific value
 *
 * SYNTAX:      proc    settransfer     -
 *
 * TITLE:       op_settransfer
 *
 * CALL:        op_settransfer()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(settransfer)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_settransfer()
{
        ufix16  i;
        real32   gray_value;
        union   four_byte  iv4;
        fix     gray_index, old_gray_val;
        struct  object_def FAR *proc_obj, name_obj;

        /* check undefine error */
        if(is_after_setcachedevice()){
                get_name(&name_obj, "settransfer", 11, FALSE);
                if(FRCOUNT() < 1){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                PUSH_OBJ(&name_obj);
                ERROR(UNDEFINED);
                return(0);
        }

        /* get operand */
        proc_obj = GET_OPERAND(0);

        if(ATTRIBUTE(proc_obj) != EXECUTABLE){
                ERROR(TYPECHECK);
                return(0);
        }

        /* pop operand stack */
        POP(1);

        gray_index = (fix)(GSptr->color.gray * 255);
        old_gray_val = gray_table[GSptr->color.adj_gray].val[gray_index];

        /* set the current gray transfer function to the specific
         * value */
        COPY_OBJ(proc_obj, &GSptr->transfer);

        /* create gray table , restore in grestore & grestoreall */
        if(GSptr->color.inherit == TRUE){
                if(GSptr->color.adj_gray >= MAXGRAY){
                        ERROR(STACKOVERFLOW);
                        return(0);
                }
                else{
                        /* create new gray table */
                        GSptr->color.adj_gray ++;
                }
        }

        /* skip calling interpreter if proc is null scchen 3/19/91 */
        if( ! LENGTH(proc_obj) )
        for(i = 0; i < 256; i++){
                gray_value = (real32)(i/255.);
                gray_table[GSptr->color.adj_gray].val[i]
                        /* = (fix)(gray_value * GRAYSCALE); mslin 4/11/91*/
                        = (fix)(gray_value * GRAYSCALE+0.5);
        }
        else
        /* generate gray table value */
        for(i = 0; i < 256; i++){
                iv4.ff = (real32)(i/255.);
                PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, iv4.ll);

                if (interpreter(&GSptr->transfer)) {
                        return(0);
                }

                /* adjust gray value */
                GET_OBJ_VALUE(gray_value, GET_OPERAND(0));

                if (gray_value > one_f)      gray_value = one_f;
                /*else if (gray_value < zero_f) gray_value = zero_f; 3/20/91;sc*/
                else if (SIGN_F(gray_value)) gray_value = zero_f;

                /* "* 4096" is used to transfer data type from real
                 * to integer, it used 12 bits */
                gray_table[GSptr->color.adj_gray].val[i]
                        = (fix)(gray_value * GRAYSCALE);

                POP(1);
        }

        gray_index = (fix)(GSptr->color.gray * 255);
        if(old_gray_val != gray_table[GSptr->color.adj_gray].val[gray_index]){
                /* exchange halftone pattern */
                FillHalfTonePat();
        }

        GSptr->color.inherit = FALSE;

        return(0);
}


/**********************************************************************
 *
 * This module is to return the current gray transfer function in the
 * current graphics state
 *
 * SYNTAX:      -       currenttransfer  proc
 *
 * TITLE:       op_currenttransfer
 *
 * CALL:        op_currenttransfer()
 *
 * PARAMETER:   none
 *
 * INTERFACE:   interpreter(op_currenttransfer)
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
fix
op_currenttransfer()
{
       /* check if operand stack no free space */
        if(FRCOUNT() < 1){
                ERROR(STACKOVERFLOW);
                return(0);
        }

        /* push the current gray transfer function on the operand
         * stack */
        PUSH_OBJ(&GSptr->transfer);

        return(0);
}



/***********************************************************************
 *
 * This module is to restore the current clip path from the previous
 * graphics level.
 *
 * TITLE:       restore_clip
 *
 * CALL:        restore_clip()
 *
 * PARAMETER:   none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void
restore_clip()
{
        // struct   gs_hdr   near *pre_ptr; @WIN
        struct   gs_hdr   FAR *pre_ptr;

        /* pointer of previous graphics stack */
        pre_ptr = &gs_stack[current_gs_level - 1];

        /* free current clipping path if it is not used by lower gsave level */
        if(!GSptr->clip_path.inherit)
                free_node (GSptr->clip_path.head);

        /* copy clip information from previous level */
        GSptr->clip_path = pre_ptr->clip_path;
        GSptr->clip_path.inherit = TRUE;

}



/***********************************************************************
 *
 * This module is to restore the default CTM and clip from the previous
 * graphics level.
 *
 * TITLE:       restore_device
 *
 * CALL:        restore_device
 *
 * PARAMETER:   none
 *
 * INTERFACE:   font machinery
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void
restore_device()
{
        fix     i;
        //struct   gs_hdr   near *pre_ptr; @WIN
        struct   gs_hdr   FAR *pre_ptr;

        /* pointer of previous graphics stack */
        pre_ptr = &gs_stack[current_gs_level - 1];

        for(i = 0; i < MATRIX_LEN; i++){
                GSptr->device.default_ctm[i] =
                           pre_ptr->device.default_ctm[i];
        }

        GSptr->device.default_clip.ux = pre_ptr->device.default_clip.ux;
        GSptr->device.default_clip.uy = pre_ptr->device.default_clip.uy;
        GSptr->device.default_clip.lx = pre_ptr->device.default_clip.lx;
        GSptr->device.default_clip.ly = pre_ptr->device.default_clip.ly;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\halftone.c ===
/*
 * Copyright (c) 1989,90,1991 Microsoft Corporation
 */
/************************************************************************
    Halftone: gray integrated version


    History:

         02/04/91       new algorithm for sethalftone and fillhtpattern
                        The interface keeps the same.
         04/08/91       change sqrt(int) to sqrt((real32)int) for library
                        compatibility

    Programmed by:      shenzhi Zhang


    C Library Functions Called:

        1. memset()
************************************************************************/


// DJC added global include
#include "psglobal.h"



#include               <stdio.h>
#include               <math.h>
#include               <string.h>
/* #include               <stdlib.h> */ /* kevina 4.13.90: removed for Sun build */

#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "halftone.h"
#include               "halftone.def"
#include               "fillproc.h"
#include               "fillproc.ext"

/* @WIN; add prototype */
static struct angle_entry far *select_best_pair(
       fix32 real_size_, fix32 alpha_angle_);
float SpotFunc(float x, float y);

static ufix32              far *repeat_pattern;     /* ufix => ufix32 @WIN*/

static fix                      cache_count;
static fix                      cache_scale;
static struct cache_entry far  *cache_point;
static gmaddr                   cache_index;
static fix                      cache_colof;
static fix                      cache_sizof;
static fix16                    cos_theta;
static fix16                    sin_theta;



static struct group_entry far  *cache_group;
static struct cache_entry far  *cache_array;
//static struct cache_entry       cache_dummy = {-1, -1, NULL,};  /* 08-05-88 */
static struct cache_entry       cache_dummy = {-1, (gmaddr)-1, NULL,}; //@WIN


/*************************************************************************

 ** InitHalfToneDat()

*************************************************************************/

void InitHalfToneDat()                                          /* 01/12/88 */
{
    /*
     * Step 1. Allocate dynamic memory buffers for HalfTone
     */

    {
        /* set default resolution as max. resolution */
        resolution       = MAX_RESOLUTION;                      /* @RES */

        cache_group      = (struct group_entry far *)
                           fardata((ufix32) MAX_GROUP
                                          * sizeof(struct group_entry));
        cache_array      = (struct cache_entry far *)
                           fardata((ufix32) MAX_ENTRY
                                          * sizeof(struct cache_entry));

        /* initialize cache address of default cache */
        cache_dummy.cache = HTP_BASE;                           /* 08-05-88 */


#ifdef  DBG1X
        printf("cache_group:      %lx\n", cache_group);
        printf("cache_array:      %lx\n", cache_array);
#endif
    }
}


/*************************************************************************

 ** spot_function()

*************************************************************************/
//float SpotFunc(x,y)           @WIN
//float x, y;
float SpotFunc(float x, float y)
{
    return((float)1.0-x*x-y*y);         //@WIN
}






/*************************************************************************

 ** select_best_pair()

*************************************************************************/

static struct angle_entry far *select_best_pair(real_size_, alpha_angle_)
fix32                   real_size_;
fix32                   alpha_angle_;
{
    real32              real_size;
    real32              alpha_angle;
    fix                 scalefact;
    fix                 patt_size;
    fix                 cell_size;
    fix32               htwa_size;                              /* @HTWA */
    real32              alpha_error;
    struct angle_entry FAR *alpha_entry;
    struct angle_entry FAR *angle_entry;
    fix                 lower_index;
    struct angle_entry FAR *lower_entry;
    fix                 upper_index;
    struct angle_entry FAR *upper_entry;

    /*  select best frequency & angle pair
     */
    real_size   = L2F(real_size_);
    alpha_angle = L2F(alpha_angle_);

    alpha_entry = (struct angle_entry FAR *) NO_BEST_FIT_CASE;

    lower_index = MIN_AT_ENTRY;
    lower_entry = &angle_table[MIN_AT_ENTRY];
    upper_index = MAX_AT_ENTRY;
    upper_entry = &angle_table[MAX_AT_ENTRY];

    for (; lower_index <= upper_index;)
    {
        real32              spec_size;
        real32              entry_error;
        real32              angle_error;
        real32              fsize_error;
        real32              angle_diff;                         /* 11-24-88 */

        if ((alpha_angle - lower_entry->alpha) >
            (upper_entry->alpha - alpha_angle)) {
            angle_entry = lower_entry;
            lower_entry++;
            lower_index++;
        } else {
            angle_entry = upper_entry;
            upper_entry--;
            upper_index--;
        }
/* Removed by phchen, 04/10/91, to fixed the bug at "apple013.b" case
 *      if ((angle_entry->alpha - alpha_angle > 10.0) ||
 *          (angle_entry->alpha - alpha_angle < -10.0)) continue; (* 10-18-90 *)
 */

        /*  adjust frequency & size properly
         */
        scalefact = (fix) ((real_size * angle_entry->scale      /* 08-15-88 */
                                      / angle_entry->sum) + 0.5);

        /*  original approach                                      04-14-89
         *  if (scalefact > (MAXCELLSIZE / angle_entry->sum))
         *      scalefact = (MAXCELLSIZE / angle_entry->sum);
         *  if (scalefact > (MAXPATTSIZE / angle_entry->sos))
         *      scalefact = (MAXPATTSIZE / angle_entry->sos);
         */

        cell_size = scalefact * angle_entry->sum;
        patt_size = scalefact * angle_entry->sos;

        if (cell_size >  MAXCELLSIZE ||                         /* 04-14-89 */
            patt_size >  MAXPATTSIZE)  continue;

        spec_size = cell_size / angle_entry->scale;

        if (spec_size >= (real32) MAXCACTSIZE)  continue;       /* 04-14-89 */

        /*  check if expanded halftone on 32-bits over some threshold
         */
        for (htwa_size = patt_size; htwa_size & HT_ALIGN_MASK;  /*@HTWA @BAC*/
             htwa_size = htwa_size << 1)  ;
        /*  original approach                                      04-14-89
         *  if ((htwa_size * patt_size) > BM_PIXEL(HTB_SIZE))   (*@HTWA @BAC*)
         *      continue;
         */
        if (htwa_size >  MAXPEXPSIZE)  continue;                /* 04-14-89 */

        /*  calculate the error from idea halftone cell           @04-14-89
         */
        angle_diff  = angle_entry->alpha - alpha_angle;         /* 11-24-88 */
        FABS(angle_diff, angle_diff);                           /* 11-24-88 */
        angle_error = (real32) (1.0 - angle_diff / 90.0);       /* 11-24-88 */
        fsize_error = (spec_size < real_size)
                      ? (real32) (spec_size / real_size)
                      : (real32) (real_size / spec_size);
        entry_error = angle_error * angle_error * fsize_error;

        /*  select it if it is in minimum error (difference)
         */
        if (alpha_entry == (struct angle_entry FAR *) NO_BEST_FIT_CASE ||
            alpha_error <= entry_error) {
            alpha_entry = angle_entry;
            alpha_error = entry_error;
        }
    }

    return(alpha_entry);
}




/*************************************************************************

 ** SetHalfToneCell()

*************************************************************************/

void SetHalfToneCell()
{
    static real64           alpha_phase;        /*@WINDLL*/
    fix16                   cell_size;
    fix16                   majorfact;
    fix16                   minorfact;
    real32                  real_size;
    real32                  real_degs;
    real32                  alpha_angle;
    fix16                   scalefact;
    fix16                   no_pixels;
    struct angle_entry     FAR *alpha_entry;
    fix16                   i,j,k,l;
    real32                  x,y;
    fix16                  huge *cValue;        /*@WIN*/
    fix16                   val;
    union four_byte         x4, y4;
    fix                     status;
    struct object_def      FAR *object;
    byte huge              *vmheap_save;                        /* 01-30-89 */
    static fix              FirsTime = TRUE;    /* ???  For Demo 9/5/87 */
    real32                     theta_angle;
    fix32                   cx,cy,tx,ty;        /*@WIN 05-07-92*/
    fix32                   bound;              /*@WIN 05-06-92*/
    fix16                   minorp, majorp;

#ifdef DBG
        printf("Entering set halftone\n");
#endif
    /*
     * Step 1. Determine the final cell_size, alpha_angle, and cell_fact,
     *          after adjustment.
     */

                        /*      compute the real size of half tone cell*/
        if ((real_size = (real32) ((real32) resolution / Frequency))
                       < (real32) 1.0)
            real_size = (real32) 1.0;

        if (real_size >= (real32) MAXCACTSIZE)
        {                    /* 04-14-89 */
            /*  adjust fraquency and angle permanently
             *  **************************************
             *  ***  CAN'T FIND OUT RULES OF V.47  ***
             *  **************************************
             */
            for (Frequency+= (float) 2.0; ; Frequency+= (float) 2.0)
            {
                if ((real_size = (real32) ((real32) resolution / Frequency))
                               <= (real32) MAXCACTSIZE)  break;
            };
        };

        /*  get nearest angle_entry form angle_table          */

        real_degs = (real32) (modf((Angle < (real32) 0.0)                                   /* 01-08-88 */
                                  ? (real32) (1.0 - (-Angle / 360.0))
                                  : (real32) (Angle / 360.0),
                                  &alpha_phase) * 360.0);
        alpha_angle = ((theta_angle = (real32) (modf((real32) (real_degs / 90.),  /* 01-08-88 */
                                                    &alpha_phase) * 90.))
                                               <= (real32) 45.)
                      ? theta_angle : (real32) (90. - theta_angle);

        /*  select best frequency & angle pair
         */

        /*  calculate all halftone screen parameters
         */
/*shenzhi */
#ifdef  DBG
        printf("realsize angle %f %f \n", real_size, alpha_angle);
#endif

		if (real_size == (real32)0)
		{
             ERROR(RANGECHECK);
             return;
		}
		
        if ((alpha_entry = select_best_pair(F2L(real_size),
                                            F2L(alpha_angle)))
            == (struct angle_entry FAR *) NO_BEST_FIT_CASE)
            {
             ERROR(LIMITCHECK);
             return;
            }

        scalefact=(fix16)((real_size*alpha_entry->scale/alpha_entry->sum)+0.5);
        if (scalefact > (MAXCELLSIZE / alpha_entry->sum))       /* 01-08-88 */
            scalefact = (MAXCELLSIZE / alpha_entry->sum);
        if (scalefact > (MAXPATTSIZE / alpha_entry->sos))       /* 01-08-88 */
            scalefact = (MAXPATTSIZE / alpha_entry->sos);
        CGS_ScaleFact =scalefact;
        CGS_Cell_Size = cell_size = scalefact*alpha_entry->sum;
        if (cell_size ==1)
            {
#ifdef   DBG
                printf("binary\n");
#endif
                goto Setscreen_Exit;
            };



        /*  -2: calculate cosine/sine and major/minor
                major/minor are pair of intergers without common divisor
         */
        if (theta_angle > (float)45.0)          //@WIN
        {
/*shenzhi */
#ifdef   DBG
        printf(">45\n");
#endif
        CGS_MinorFact = alpha_entry->minor;
        CGS_MajorFact = alpha_entry->major;
        }
        else
        {
/* shenzhi */
#ifdef  DBG
        printf("<45\n");
#endif
        CGS_MinorFact = alpha_entry->major;
        CGS_MajorFact = alpha_entry->minor;
        };
/*shenzhi major here corresponding to m */
/*      i =(fix16)((CGS_MajorFact<<11)/sqrt(alpha_entry->sos)+0.5);
        j =(fix16)((CGS_MinorFact<<11)/sqrt(alpha_entry->sos)+0.5);*/
        i =(fix16)((CGS_MajorFact<<11)/sqrt((real32)alpha_entry->sos)+0.5); /* 4-8-91, Jack */
        j =(fix16)((CGS_MinorFact<<11)/sqrt((real32)alpha_entry->sos)+0.5); /* 4-8-91, Jack */
        switch ((fix) alpha_phase)
         {
            case 0:               /* 0-90 */
                 sin_theta = i;
                 cos_theta = j;
                 break;
            case 1:               /* 0-90 */
                 sin_theta = j;
                 cos_theta = -i;
                 break;
            case 2:               /* 0-90 */
                 sin_theta = -i;
                 cos_theta = -j;
                 break;
            case 3:               /* 0-90 */
                 sin_theta = -j;
                 cos_theta = i;
                 break;
         };
        minorfact = CGS_MinorFact*scalefact;
        majorfact = CGS_MajorFact*scalefact;
#ifdef DBG
        printf("M N %d %d\n", CGS_MajorFact, CGS_MinorFact);
#endif
        CGS_Patt_Size = scalefact*alpha_entry->sos;
        minorp =minorfact*minorfact;
        majorp =majorfact*majorfact;
        CGS_No_Pixels = no_pixels = majorp+minorp;
/* shenzhi    */
#ifdef DBG
        printf("COS SIN %d %d \n", cos_theta,sin_theta);
#endif
    /*
     *  Step 2. Allocate structures: spot_index_array & spot_value_array
     *          from VMHEAP.
     */

        vmheap_save = vmheap;


//DJC,fix bug from HIST if ((cValue = (fix16 huge *)alloc_heap(sizeof(fix16)*cell_size*cell_size))
        if ((cValue = (fix16 far *)alloc_heap(
            sizeof(fix16)*(cell_size*cell_size+1)))  // add 1 for init of qsort; @WIN
            == NIL) {                   /* 04-20-92 @WIN */
#ifdef DBG
            printf("no mem\n");
#endif
            goto Setscreen_Exit;
        };


    /*
     *  Step 3. Evaluate spot value for each pixel in halftone cell
     */
        CGS_HT_Binary = FALSE;
        CGS_BG_Pixels = 0;
        CGS_FG_Pixels = 0;
        if (CGS_AllocFlag == TRUE)
           {
                if ((CGS_SpotIndex +no_pixels) > MAXSPOT)
                  {
                        ERROR(LIMITCHECK);
                        goto Setscreen_Exit;
                  }
           }
        else
           {
                if ((CGS_SpotIndex +no_pixels) > MAXSPOT)
                  {
                        ERROR(LIMITCHECK);
                        goto Setscreen_Exit;
                  };
                CGS_SpotIndex = CGS_SpotUsage;
                CGS_AllocFlag = TRUE;
           };
        CGS_SpotUsage = CGS_SpotIndex + no_pixels;
        k = 0;   /* index of spot*/
        bound = (fix32)(sqrt((real32)alpha_entry->sos) *
                       ((fix32)scalefact<<11))/2;       /*@WIN 05-06-92*/
        cx =cy=(1-cell_size);
        cx = cx*(cos_theta + sin_theta)/2;
        cy = cy*(cos_theta - sin_theta)/2;
        for (l=0; l< no_pixels;l++)
           {
                    if (l<minorp)
                      { i = l/minorfact;
                        j = l%minorfact;
                      }
                    else
                      {
                        i = (l-minorp)/majorfact;
                        j = (l-minorp)%majorfact+minorfact;
                      };
                    tx = (fix32)i*sin_theta+(fix32)j*cos_theta+cx; /*@WIN*/
                    ty = (fix32)i*cos_theta-(fix32)j*sin_theta+cy; /*@WIN*/
                    if (tx< -bound )
                         x = (real32)(tx +2*bound)/bound;
                         else if (tx > bound)   /* shenzhi 4-17-91 */
                             x = (real32)(tx - 2 * bound) / bound; /* shenzhi 4-17-91 */
                    else
                         x = (real32)tx/bound;
                    if (ty< -bound )
                         y = (real32)(ty +2*bound)/bound;
                         else if (ty > bound)   /* shenzhi 4-17-91 */
                             y = (real32)(ty - 2 * bound) / bound; /* shenzhi 4-17-91 */
                    else
                         y = (real32)ty/bound;
#ifdef  DBG
                    if ((x>1.0) || (x<-1.0) || (y>1.0) || (y < -1.0))
                        printf("l,i,j,x,y %d %d %d %f %f\n",l,i,j,x,y);
#endif
                    if (FirsTime)
                        val = cValue[k++] = (fix16)(SpotFunc(x,y)*500);
                    else
                       {
                               /*       check if operand stack no available space
                                */
                        if(FRCOUNT() < 2)
                             {
                                ERROR(STACKOVERFLOW);
                                goto Setscreen_Exit;
                             };

                /*  push x & y coordinates as parameters of spot function
                 */
                        x4.ff = x;
                        y4.ff = y;
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);


                /*  call interpreter to execute spot function
                 */
                        if ((status = interpreter(&GSptr->halftone_screen.proc)))
                            {
                              if (ANY_ERROR() == INVALIDEXIT)
                              CLEAR_ERROR();
                              goto Setscreen_Exit;
                            };

                /*  extract spot value from operand stack
                 *    first,  check if any result in operand stack
                 *    second, check if type of result is numeric
                 *    third,  check if spot value in corrent range
                 */
                        if (COUNT() < 1)
                            {
                             ERROR(STACKUNDERFLOW);
                             goto Setscreen_Exit;
                            };

                        object = GET_OPERAND(0);

                        if ((TYPE(object) != INTEGERTYPE) &&
                                (TYPE(object) != REALTYPE))
                            {
                             ERROR(TYPECHECK);
                             goto Setscreen_Exit;
                            };

                        y4.ll = (fix32)VALUE(object);
                        if (TYPE(object) != INTEGERTYPE)
                           val = cValue[k++] = (fix16)(y4.ff*500);
                        else
                           val = cValue[k++] = (fix16)(y4.ll*500);       /* 12-30-87 +0.5 */
                        POP(1);

                        if ((val < -505) || ( 505 <val))
                            {
                                ERROR(RANGECHECK);
                                goto Setscreen_Exit;
                            };
                       };

           };
        val = 0;
        for (i = 0; i< no_pixels;i++)
                 CGS_SpotOrder[i] = i;

        cValue[no_pixels] = 0x7FFF;  // init as a max value for quick sort; @WIN

/* quick sort */
        {
        fix                         p, q, c;
        fix                         i, j, v;
        struct spot_stack FAR      *point;                      /*@WINDLL*/
        struct spot_stack           stack[MAX_SPOT_STACK];
        fix16                       spot_value;

         if (CGS_HT_Binary != TRUE)                             /* 02-03-88 */
          {
            /*  QUICKSORT algorithm: please refer to any textbook in hand
             */

            for (point = (struct spot_stack FAR *) stack,       /*@WINDLL*/
                 p = 0, q = no_pixels - 1, c = 0; ; c++)
              {
                while (p < q)
                {
                    i = p;
                    j = q + 1;
                    v = cValue[i];
                    for (; ; )
                    {
                        for (i++; v > cValue[i]; i++);
                        for (j--; v < cValue[j]; j--);
                        if (i < j)
                        {
                            spot_value = cValue[i];
                            cValue[i] = cValue[j];
                            cValue[j] = spot_value;
                            spot_value = CGS_SpotOrder[i];
                            CGS_SpotOrder[i] = CGS_SpotOrder[j];
                            CGS_SpotOrder[j] = spot_value;

                        }
                        else  break;
                    }
                    spot_value = cValue[p];
                    cValue[p] = cValue[j];
                    cValue[j] = spot_value;
                    spot_value = CGS_SpotOrder[p];
                    CGS_SpotOrder[p] = CGS_SpotOrder[j];
                    CGS_SpotOrder[j] = spot_value;
                    point->p = j + 1;
                    point->q = (fix16)q;
                    point++;
                    q = j - 1;
                }
                if (point == (struct spot_stack FAR *) stack)   /*@WINDLL*/
                    break;  point--;
                p = point->p;
                q = point->q;
              }
          };
        };   /* quick sort */
        for (i=0; i< no_pixels; i++)
          cValue[i] = CGS_SpotOrder[i];
        for (i=0; i< no_pixels; i++)
          CGS_SpotOrder[cValue[i]] = i;

        CGS_No_Whites = -1;

        /*  keep all halftone screen parameters in graphics stack
         */

Setscreen_Exit:

    {
		if (vmheap_save)
		{
        	free_heap(vmheap_save);         /* @VMHEAP: 01-31-89 */ /* 03-30-89 */
		}
        FirsTime = FALSE;                      /*   ??? For Demo 9/5/87 */
    }
}


/*************************************************************************

 ** FillHalfTonePat()

*************************************************************************/

fix  FromGrayToPixel(no_pixels, grayindex)                      /* 01-25-90 */
fix                     no_pixels;
fix                     grayindex;
{
    fix                 no_levels;
    fix                 graylevel;
    fix                 scale_unit;
    fix                 compensate;
    fix                 split_zone;

    if (grayindex >= (GrayScale - CGS_GrayRound))
        return(no_pixels);

    no_levels = (no_pixels <= MAXGRAYVALUE) ? no_pixels : MAXGRAYVALUE;
    graylevel = (fix)CGS_GrayLevel;     //@WIN

    scale_unit = GrayScale / no_levels;
    compensate = GrayScale - (scale_unit * no_levels);
    split_zone = scale_unit * (no_levels / 2) + compensate;

#ifdef  DBG1
    printf("I: %x%s    U: %d     C: %d     Z: %d    P: %d    L: %d\n",
           grayindex, (graylevel > split_zone) ? "*" : " ", scale_unit,
           compensate, split_zone, no_pixels, no_levels);
#endif

    if (graylevel > split_zone)
        graylevel-= compensate;

    return((fix) ((((fix32) (graylevel + CGS_GrayRound)) / scale_unit)
                  * no_pixels / no_levels));
}





/************************************************************************

 ** FillHalfTonePat()  - updated for greyscale by Jack Liaw 5/31/90

 ************************************************************************/

#ifdef  bSwap                                   /*@WIN 05-11-92*/
static ufix32 ShifterMask [32]
=
{
  0x00000080, 0x00000040, 0x00000020, 0x00000010,
  0x00000008, 0x00000004, 0x00000002, 0x00000001,
  0x00008000, 0x00004000, 0x00002000, 0x00001000,
  0x00000800, 0x00000400, 0x00000200, 0x00000100,
  0x00800000, 0x00400000, 0x00200000, 0x00100000,
  0x00080000, 0x00040000, 0x00020000, 0x00010000,
  0x80000000, 0x40000000, 0x20000000, 0x10000000,
  0x08000000, 0x04000000, 0x02000000, 0x01000000
};
#define SHIFTER(x)      ShifterMask[x&0x1f]
#else
#define SHIFTER(x)      (1L<<(31 - (x & 0x1f)))
#endif

void FillHalfTonePat()
{
    fix16    majorfact, minorfact, scalefact;
    fix16    patt_size, cell_size, no_pixels, no_whites;
    struct cache_entry  FAR *cache_entry;
    fix            grayindex;
    struct group_entry  FAR *group;
    struct cache_entry  FAR *cache;
    ufix32     patterns[MAXPATTSIZE*MAXPATTWORD];    /* ufix => ufix32 @WIN */
    fix   fill_type,ox,oy;
    fix16 i,j,k;
    fix16 x,y,ytemp,m;
    fix16 cPattern=0;


    /*  extract all halftone screen parameters in graphics stack */
        scalefact = CGS_ScaleFact;
        majorfact = CGS_MajorFact*scalefact;
        minorfact = CGS_MinorFact*scalefact;
        patt_size = CGS_Patt_Size;
        cell_size = CGS_Cell_Size;
        no_pixels = CGS_No_Pixels;
        /* shenzhi*/
/*      printf("PATT CELL %d %d \n", patt_size, cell_size);  */
    /*
     *  Step 2. Determine the number of white pixels
     */
        grayindex = CGS_GrayIndex;
        no_whites = (fix16)CGS_GrayValue(no_pixels, grayindex);
/* shenzhi
        printf("W P %d %d \n",no_whites,no_pixels);
*/
        /*  do nothing when halftone pattern unchanged */
        if (no_whites == CGS_No_Whites)
             return;
        /*  check if halftone pattern cache flushed or not
         *  halftone pattern cache flushed while screen changed *)
         *  or graydevice changed 06-11-90 */

        if (CGS_No_Whites == -1)
        {
            fix                 index;
            struct group_entry  FAR *group;

            /* flush cache and calculate corresponding parameters */
            for (group = cache_group, index = 0; index < MAX_GROUP;
                 group++, index++)
                 group->first = NULL;


            cache_index = htc_base;
            cache_colof = BM_WORDS(patt_size);
            cache_sizof = BM_BYTES(patt_size) * patt_size;
            cache_count = (fix) (htc_size / cache_sizof);
            if (cache_count > MAX_ENTRY)
                cache_count = MAX_ENTRY;
            cache_scale = no_pixels / MAX_GROUP + 1;
            cache_point = cache_array;

        }
        /*  update number of white pixel and determine type of pattern */

        CGS_No_Whites = no_whites;                              /* 03-09-88 */
        fill_type = (no_whites == no_pixels)
                ? HT_WHITE : (no_whites > 0)
                        ? HT_MIXED : HT_BLACK;
        /*  search against cache by number of white pixel */
        group = &cache_group[no_whites / cache_scale];
        cache = group->first;
        for (; cache != NULL; cache = cache->next)
                {
                    if (no_whites == cache->white)
                        {
                           repeat_pattern = NULL;
                           cache_entry = cache;
                           goto Reset_HalfTone;
                        }
                }
        if (cache_count >= 1)
            {
                if (group->first != NULL)
                   group->last->next = cache_point;
                else
                   group->first = cache_point;
                group->last = cache_point;
                cache_entry = cache_point;
                cache_entry->cache = cache_index;
                cache_entry->next       = NULL;
                cache_index+= cache_sizof;
                cache_point++;
                cache_count--;
            }
        else
            cache_entry = &cache_dummy;
        cache_entry->white = no_whites;



    /*
     *  Step 4. Generate the actual halftone repeat pattern
     */


        /*  clear repeat pattern to white
         */
        repeat_pattern = (ufix32 far *) patterns;   /*@BAC ufix => ufix32 @WIN*/
        lmemset((fix8 FAR *) repeat_pattern, (int)BM_WHITE, cache_sizof); /*@WIN*/
/*      ox=oy = 0; * need to align ox, 4-12-91, Jack */
        oy = 0;                                 /* alignment, 4-12-91 */
        ox = (majorfact == 0 || minorfact == 0) /* alignment, 4-12-91 */
             ? 0 : (patt_size - minorfact);     /* alignment, 4-12-91 */
        for (k = 0; k <patt_size/scalefact; k++)
        {
          y = (fix16)oy;
          m=0;
          for (i=0; i< minorfact; i++)
            {
              x = (fix16)ox;
              ytemp =y*cache_colof;
              for (j=0; j< minorfact; j++)
                {
                 if (CGS_SpotOrder[m++] >= (ufix16)no_whites)   //@WIN
                    repeat_pattern[ytemp+(x>>5)] |= SHIFTER(x); /*@WIN*/
                 x+=1;
                 if (x==patt_size)
                    x=0;
                };
              y +=1;
              if (y==patt_size)
                y=0;
            };
         m = minorfact*minorfact;
         y = (fix16)oy;
         for (i=0; i< majorfact; i++)
            {
              ytemp = y*cache_colof;
              x = (ox+minorfact)%patt_size;
              for (j=0; j< majorfact; j++)
                {
                 if (CGS_SpotOrder[m++] >= (ufix16)no_whites)   //@WIN
                    repeat_pattern[ytemp+(x>>5)] |= SHIFTER(x); /*@WIN*/
                 x+=1;
                 if (x==patt_size)
                    x=0;
                };
              y +=1;
              if (y==patt_size)
                 y=0;
            };
          ox +=minorfact;
          if (ox >=patt_size)
             ox -=patt_size;
          oy +=majorfact;
          if (oy >= patt_size)
             oy -=patt_size;
        };

/*
        for(i=0;i<cPattern;i++)
                printf(" val %d \n",repeat_pattern[i]);
*/
    /*
     *  Step 5. Reset halftone repeat pattern
     */
Reset_HalfTone:
    {
        change_halftone((ufix32 far *) repeat_pattern, cache_entry->cache, /* ufix => ufix32 @WIN */
                        fill_type, patt_size, patt_size);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\image.h ===
/* ---------------------------------------------------------------
 * File: image.h
 * Created by: MIn-Shyong Lin
 * Date: 1/13/91
 * Used by: image.c and scaling.c
 *
 * ---------------------------------------------------------------
 */

/*
 * image_dev_flag =
 *                  FALSE
 *                  PORTRATE
 *                  LANDSCAPE
 * image_logic_op =
 *                  00000001 -- IMAGE_BIT
 *                  00000010 -- IMAGEMASK_FALSE_BIT
 *                  00000100 -- IMAGE_CLIP_BIT
 */
#define F2SHORT(f)      ((sfix_t)((f) + 0.5))
#define PORTRATE        1
#define LANDSCAPE       5
#define ROTATE_LEFT     0x0800
#define ROTATE_RIGHT    0x0400
#define NOT_IMAGEMASK   2
#define IMAGE_BIT               0x1
#define IMAGEMASK_FALSE_BIT     0x2
#define IMAGE_CLIP_BIT          0x8

/* constant defined for image processing */
#define  DONE           0x8000
#define  NOT_DONE       0x0000
#define  NO_DATA        0x4000


/*
 *IGS Registers
 */
#define         IGS_DWIDTH      0x4C0030
#define         IGS_BMADR       0x4C0002
#define         IGS_BMDATA      0x4C0006
#define         IGS_AUTOINC     0x4C0008
#define         IGS_XLDSB       0x4C000E
#define         IGS_ALU         0x4C002A
#define         IGS_BITOFFSET   0x3800000


/*
 * IGS logic constant
 */
#define         LOG_OR          0x0E             /* Logical OR */
#define         LOG_NAND        0x02             /* (A*)B */
#define         LOG_AND         0x0B             /* 0 */
/* #define              FC_CLEAR        0x02     fillproc.h defined as white */

/*
 * IGS rotation constant
 */
#define         ROT_LEFT        0x800            /* rotate left */
#define         ROT_RIGHT       0x400            /* rotate right */
#define         ROT_DOWN        0xC00            /* upside down */

/*mslin 5/02/91 for image*/
#define CHECK_STRINGTYPE() {                    \
        if(TYPE(GET_OPERAND(0)) != STRINGTYPE){ \
            ERROR(TYPECHECK);                   \
            return;                             \
        }                                       \
}

/*
 * image information block
 */
 typedef struct {
    ufix16       ret_code;       /* return code of this module
                                  * 0x8000 -- complete image process
                                  * 0x0000 -- not yet completed but
                                  *           buffer full
                                  * others -- Error defined by language
                                  */
    ufix16       FAR *dev_buffer;/* device resolution image buffer */
    fix          dev_buffer_size;/* number of byte in dev_buffer[] */
    ufix16       dev_width;      /* pixel width of device resolution image */
    ufix16       dev_height;      /* pixel height of device resolution image */
    ufix16       band_height;     /* height return in dev_buffer*/
    ufix16       raw_width;      /* pixel width of raw image data */
    ufix16       raw_height;      /* pixel height of raw image data */
    fix16        flag;           /* indicate type of data in dev_buffer[]
                                  * 0: image source data
                                  * 1: device resolution data
                                  */
    fix16        bits_p_smp;     /* bits per samp */
    ufix16       FAR *divr;      /* pointer to array of row scaling info,
                                  * return when Amplify
                                  */
    ufix16       FAR *divc;      /* pointer to array of column scaling info,
                                  * return when Amplify
                                  */
    lfix_t       FAR *lfxm;      /* matrix in long fix format */
    struct object_def obj_proc; /* object to get string from interpreter */
    ufix16      logic;           /* logic and rotation for IGS */
    fix16       xorig;           /* x coord. in left upper cornor */
    fix16       yorig;           /* y coord. in left upper cornor */

 } IMAGE_INFOBLOCK;

/*
 * functions declaration
 */
void image_PortrateLandscape(IMAGE_INFOBLOCK FAR *);    /* @WIN */
void    amplify_image_page();      /*amplify image by IGS*/
void    set_IGS();                 /*defined in charblt.s */
void    restore_IGS();             /*defined in charblt.s */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\image.c ===
/***************************************************************************
 *
 *      Name:       image.c
 *
 *      Purpose:
 *
 *      Developer: J.Jih
 *
 *      History:
 *      Version    Date        Comments
 *                 4/2/88      @CACHE_INFO: get cache_info from
 *                             font machinery for scan_conversion
 *                 4/5/88      @SCAN_CVT: call scan_conversion with
 *                             F_TO_IMAGE only for filling a seed
 *                 4/18/88     @CLIP_TBL: move clip_path from
 *                             edge_table to node_table
 *                 4/27/88     @#IMAGE: split single image seed
 *                             pattern into 4 image seed patterns
 *                 5/20/88     @#IMAGE: correct the calculation of
 *                             max_bb_height by casting (fix32)
 *                 5/21/88     @#IMAGE: correct the calculation of
 *                             the size of image seed patterns and
 *                             x & y thresholds
 *                 5/24/88     @#IMAGE: coordinates of sample is
 *                             out of SFX range
 *                 5/25/88     @#IMAGE: show_buildchar does not call
 *                             imagemask_shape for space of user
 *                             defined font
 *                 5/31/88     @#IMAGE: different result of image
 *                 6/14/88     remove unnecessary codes and options
 *                 7/21/88     @DT: data type version
 *                             - long  -> long32 -- fill_seed()
 *                             - char  -> ubyte
 *                             - int   -> fix
 *                             - float -> real32
 *                             - short -> fix16
 *                             - long  -> fix32
 *                             Note: unsolved data type "union" in
 *                                   check_clip_status();
 *                                   ref. S.C. Chen
 *                 7/21/88     @#ALIGN: bitmap word alignment
 *                 8/11/88     remove continuation mark "\" in routines:
 *                             op_image, imagemask_shape
 *                 8/26/88     @#GEN: graphics enhancement              Y.C.
 *                 8/30/88     @#CSR: code size reduction               Y.C.
 *                                    op_imagemask()
 *                                    image_boundary()
 *                                    band_boundary()
 *                 9/14/88     reduce code size and remove commented code
 *                 10/07/88    change COUNT to FRCOUNT
 *                 10/20/88    modify check_clip_status add clip trapzod
 *                             feature
 *                 11/02/88    process rectangle clip case
 *                 12/30/88    remove set_pcode
 *                             modify image_boundary()
 *                                    check_clip_status()
 *                 01/16/89    new image/imagemask processing approach
 *                 01/26/89    fix bugs comes from new image/imagemask
 *                             processing approach
 *                 02/01/89    translate variables declared as fix16 to fix
 *                             unused parameters are also removed
 *                 03/18/89    pack neighboring samples on same number of
 *                             white pixels instead of same gray level
 *                 03/30/89    alloc_vmheap() & free_vmheap() is moved to
 *                             language group
 *                 04/08/89    fix bugs of selecting wrong image process
 *                             routine
 *                 04/21/89    approaching compatibility of gray to V 47
 *                 05/25/89    add a parameter of fill_destination to
 *                             fill_seed().
 *                 05/26/89    apply new macro for zero comparison of floating
 *                             points; macro: IS_ZERO()
 *                 07/18/89    fix bug of fast_clip_image_process(): string
 *                             pointer does not advance before enter unclipped
 *                             area such that image is swapped up
 *                 4/7/90      fix bug of white lines in fast_clip_image_process
 *                 5/15/90     skip pixmap[-1] in slow_clip_image_process
 *                 10/16/90    updated for upsidedown image
 *                 4/17/91     get rid of width checking (3331 was the previous
 *                             maximum width)
 *                 4/17/91     porting from 68K to 29K:
 *                              get rid of BottomLine, fb_mark
 *                              get rid of wait_unitl_flush()
 *                              add GEIeng_checkcomplete()
 *                              delete amplify_image_page()
 *                              get rid of path in include file.
 *                 5/02/91      Add CHECK_STRINGTYPE() after each interpreter
 *                              call
 *
 *                 5/06/91     Add macro SAVE_OPNPTR() and RESTORE_OPNPTR()
 *                              move operand stack pointer before image and
 *                              imagemask processing, restore opnstktop and
 *                              opnstkptr before return from op_image and
 *                              op_imagemask if error occurred.
 *                             Add two global varialbes:
 *                              ufix16  save_opnstktop;
 *                              struct  object_def      *save_opnstkptr;
 *                             Should be move to global.def in the future, also
 *                             save and restore opnstkptr and opnstktop in
 *                             operator dispatch function: interpreter().
 *                 5/6/91      update op_imagemask for empty procedure,
 *                              i.e. pop operands first.
 *                 5/7/91      update fast_clip_image_process to skip
 *                              clipping checking for rotated images
 *                 5/21/91     add flush_gcb in op_image and op_imagemask
 *                 11/21/91     upgrade for higher resolution @RESO_UPGR
 *****************************************************************************/


// DJC added global include
#include "psglobal.h"


#include <stdio.h>
#include <math.h>
//#include "float.h"
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "halftone.h"
#include "fillproc.h"
#include "fillproc.ext"
#include "font.h"
#include "font.ext"
#include "image.h"         /*mslin 1/13/91 IMG_OPT*/

#define static  /* ??? */

#define BOTTOM  1                       /* bit 0: BOTTOM   -- c1  */
#define TOP     2                       /* bit 1: TOP      -- c2  */
#define RIGHT   4                       /* bit 2: RIGHT    -- c3  */
#define LEFT    8                       /* bit 3: LEFT     -- c4  */

#define LFX2S(lfx)    ((fix16) (LFX2I(lfx)))
#define SFX2S(sfx)    ((fix16) (SFX2I(sfx)))

/* The following one is replaced by HALF_LFX.  @RESO_UPGR
#define LFX_HALF      ((lfix_t) (I2LFX(1)) >> 1) */

/*mslin 5/6/91 begin */
ufix16  save_opnstktop;
struct  object_def      FAR *save_opnstkptr;

#define SAVE_OPNPTR() {\
        save_opnstktop = opnstktop; \
        save_opnstkptr = opnstkptr; \
}
#define RESTORE_OPNPTR() {\
        opnstktop = save_opnstktop; \
        opnstkptr = save_opnstkptr; \
}
/*mslin 5/6/91 end */

/* ********** static function declartion ********** */

#ifdef  LINT_ARGS
/*mslin 3/21/91 begin OPT*/
bool image_shortcut(real32 FAR *, real32 FAR *, fix);
void clear_image(real32 FAR *);
static void  near    scale_image_process(fix, fix32,
                                        struct object_def,
                                        lfix_t FAR *);
void amplify_image_page(IMAGE_INFOBLOCK   FAR *);
/*mslin 3/21/91 end OPT*/

static void  near    best_image_process(ufix, fix, fix32, fix, bool,
                                        struct object_def, fix,
                                        lfix_t FAR *);
static void  near    fast_clip_image_process(ufix, fix, fix32, fix, bool,
                                             struct object_def, fix,
                                             lfix_t FAR *);
static void  near    slow_clip_image_process(ufix, fix, fix32, fix, bool,
                                             struct object_def,
                                             fix, lfix_t FAR *);
static void  near    worst_image_process(ufix, fix, fix32, fix, bool,
                                         struct object_def,
                                         real32 FAR *);
static void  near    exhaust_image_data(fix, fix32, fix, struct object_def);

static void  near    image_matrix(real32 FAR *, real32 FAR *,
                                  fix32, fix, real32 FAR *);
static void  near    image_sample(real32 FAR *, fix);
static fix   near    check_clip_status(real32 FAR *);
static fix   near    image_gwcm_space(fix32, lfix_t FAR *, fix);
static void  near    band_boundary(lfix_t FAR *, fix32, fix32, fix,
                                   fix FAR *);

static void  near    flush_seed_sample_list(ufix, fix, fix FAR *);
static void  near    flush_clip_sample_list(ufix, fix, fix FAR *);
static bool  near    fill_a_sample(struct polygon_i FAR *);
#else
/*mslin 3/21/91 begin OPT*/
bool image_shortcut();
void clear_image();
static void  near    scale_image_process();
void amplify_image_page();
/*mslin 3/21/91 end OPT*/

static void  near    best_image_process();
static void  near    fast_clip_image_process();
static void  near    slow_clip_image_process();
static void  near    worst_image_process();
static void  near    exhaust_image_data();

static void  near    image_matrix();
static void  near    image_sample();
static fix   near    check_clip_status();
static fix   near    image_gwcm_space();
static void  near    band_boundary();

static bool  near    fill_a_sample();
static void  near    flush_seed_sample_list();
static void  near    flush_clip_sample_list();
#endif


/* ************* Code Size Reduction ********************************** */

#define IMAGE           0x0000          /* op_image()                   */
#define IMAGEMASK       0x0001          /* op_imagemask()               */

static fix      save_res = -1;
/* static real32   gray_map[256]; move it out as a global allocate space @WIN*/
real32 FAR * gray_map;          /* gray value mapping table     */

/* ************* seed selection optimation *************** 12-16-88 *** */


#define MAXIMAGEWIDTH   1024                            /* @IMAGE 01-05-89 */
#define MAXSAMPLEWIDTH   256                            /* @IMAGE 01-05-89 */


struct vector {         /* data structure of a vector */
        fix     x, y;           /*   x and y component of a vector */
};

struct lookup {         /* data structure of lookup table */
        fix16     index;          /*   seed index */
        fix16     x, y;           /*   x and y relative coordinate */
};

#define ITM_A00D        0x1001          /* ITM - [A 0 0 D Tx Ty] */
#define ITM_0BC0        0x0110          /* ITM - [0 B C 0 Tx Ty] */
#define ITM_ABCD        0x1111          /* ITM - [A B C D Tx Ty] */

static ufix             itm_type;       /* Inverse Transformation Matrix type */

#define ISP_NONE        0x0000          /* ISP - SEED Too Large  */
#define ISP_FILL        0xFFFF          /* ISP - SEED Applicable */

static ufix             isp_flag = ISP_NONE;    /* SEED is applicable or not */

/*
    for image cases rotated by normal degree as [0, 90, 180, 270]
*/

static fix              no_vectors;
static fix              no_samples;     /* <- no_vectors * no_vectors */
static fix              no_lookups;
static struct vector    r_vector[4];
static struct vector    c_vector[4];
static struct sample    patterns[16];
static struct lookup   huge *x_lookup;  /* @WIN 04-20-92 */

static ufix             fill_destination_save = 0xFFFF;         /* 03-17-89 */
/* static sfix_t        r_save_x = -1, r_save_y = -1; Not useful */
/* static sfix_t        c_save_x = -1, c_save_y = -1; @RESO_UPGR */
static lfix_t           r_padv_x = -1, r_padv_y = -1; /* @RESO_UPGR */
static lfix_t           c_padv_x = -1, c_padv_y = -1; /* @RESO_UPGR */
static fix              x_mins, y_mins;
static fix              x_maxs, y_maxs;
static struct vector    r_mins, r_maxs;
static struct vector    c_mins, c_maxs;

/* mslin, begin 1/3/91 IMG_OPT */
ubyte   image_dev_flag;
ubyte   image_logic_op;
ubyte   image_shift;
/* mslin, end 1/3/91 IMG_OPT */


static void near
image_sample(inv_matrix, width)
real32    FAR *inv_matrix;
fix             width;
{
    real32              r_size_x, r_size_y;
    real32              c_size_x, c_size_y;

    /* get idea seed from inverse transformation matrix */
    r_size_x = inv_matrix[2];
    r_size_y = inv_matrix[3];
    c_size_x = inv_matrix[0];
    c_size_y = inv_matrix[1];

#ifdef  DBG1
    printf("R@: [%f, %f]     C@: [%f, %f]\n",
           r_size_x, r_size_y, c_size_x, c_size_y);
#endif

    /* check if image seed patterns changed */
    /* if (fill_destination_save != fill_destination ||   |* 03-17-89 *|
        r_save_x != F2SFX(r_size_x) || r_save_y != F2SFX(r_size_y) ||
        c_save_x != F2SFX(c_size_x) || c_save_y != F2SFX(c_size_y) */
    /* [cr]_save_[xy] is not useful and can be replaced by
       [cr]_padv_[xy] @RESO_UPGR
    */
    if (fill_destination_save != fill_destination ||
        r_padv_x != F2LFX(r_size_x) || r_padv_y != F2LFX(r_size_y) ||
        c_padv_x != F2LFX(c_size_x) || c_padv_y != F2LFX(c_size_y)
        )
    {
        fix                 r_index;
        fix                 c_index;
        fix                 p_index;
        struct sample      FAR *p_point;

        x_mins = y_mins = 0;
        x_maxs = y_maxs = 0;

        fill_destination_save = fill_destination;               /* 03-17-89 */

        /* calculate the vectors in internal short fix format
           Not useful and use [cr]_padv_[xy] instead   @RESO_UPGR
        r_save_x = F2SFX(r_size_x);
        r_save_y = F2SFX(r_size_y);
        c_save_x = F2SFX(c_size_x);
        c_save_y = F2SFX(c_size_y); */

        /* calculate the vectors in internal long fix format */
        r_padv_x = F2LFX(r_size_x);
        r_padv_y = F2LFX(r_size_y);
        c_padv_x = F2LFX(c_size_x);
        c_padv_y = F2LFX(c_size_y);
#ifdef DJC //This printf accesses variables that are commented out above!
#ifdef  DBG1
        printf("R*: [%x, %x]     C*: [%x, %x]\n",
               r_save_x, r_save_y, c_save_x, c_save_y);
        printf("R$: [%lx, %lx]     C$: [%lx, %lx]\n",
               r_padv_x, r_padv_y, c_padv_x, c_padv_y);
#endif
#endif


        /* setup minimum and maximum vectors along X and Y */
        r_mins.x = (fix) (r_size_x);
        r_maxs.x = (fix) (r_mins.x + ((r_padv_x >= 0) ? 1 : -1));
        r_mins.y = (fix) (r_size_y);
        r_maxs.y = (fix) (r_mins.y + ((r_padv_y >= 0) ? 1 : -1));
        c_mins.x = (fix) (c_size_x);
        c_maxs.x = (fix) (c_mins.x + ((c_padv_x >= 0) ? 1 : -1));
        c_mins.y = (fix) (c_size_y);
        c_maxs.y = (fix) (c_mins.y + ((c_padv_y >= 0) ? 1 : -1));

#ifdef  DBG1
        printf("RX- %d    RY-: %d\n", r_mins.x, r_mins.y);
        printf("RX+ %d    RY+: %d\n", r_maxs.x, r_maxs.y);
        printf("CX- %d    CY-: %d\n", c_mins.x, c_mins.y);
        printf("CX+ %d    CY+: %d\n", c_maxs.x, c_maxs.y);
#endif

        /* setup row and column vectors */
        if (IS_ZERO(c_size_y) && IS_ZERO(r_size_x)) {

            itm_type = ITM_A00D;
            c_vector[0].x = c_mins.x;   c_vector[0].y = 0;
            c_vector[1].x = c_maxs.x;   c_vector[1].y = 0;
            r_vector[0].x = 0;          r_vector[0].y = r_mins.y;
            r_vector[1].x = 0;          r_vector[1].y = r_maxs.y;
            no_vectors = 2;
        } else

        if (IS_ZERO(c_size_x) && IS_ZERO(r_size_y)) {
#ifdef  DBG1
            printf("[0 B C 0 Tx Ty]\n");
#endif

            itm_type = ITM_0BC0;
            c_vector[0].x = 0;          c_vector[0].y = c_mins.y;
            c_vector[1].x = 0;          c_vector[1].y = c_maxs.y;
            r_vector[0].x = r_mins.x;   r_vector[0].y = 0;
            r_vector[1].x = r_maxs.x;   r_vector[1].y = 0;
            no_vectors = 2;
        } else {
#ifdef  DBG1
            printf("[A B C D Tx Ty]\n");
#endif
            itm_type = ITM_ABCD;
            c_vector[0].x = c_mins.x;   c_vector[0].y = c_mins.y;
            c_vector[1].x = c_maxs.x;   c_vector[1].y = c_mins.y;
            c_vector[2].x = c_mins.x;   c_vector[2].y = c_maxs.y;
            c_vector[3].x = c_maxs.x;   c_vector[3].y = c_maxs.y;
            r_vector[0].x = r_mins.x;   r_vector[0].y = r_mins.y;
            r_vector[1].x = r_maxs.x;   r_vector[1].y = r_mins.y;
            r_vector[2].x = r_mins.x;   r_vector[2].y = r_maxs.y;
            r_vector[3].x = r_maxs.x;   r_vector[3].y = r_maxs.y;
            no_vectors = 4;
        }

        no_samples = no_vectors * no_vectors;

#ifdef  DBG1
        printf("#V: %d    #S: %d\n", no_vectors, no_samples);
#endif
        p_point = patterns;

        /* setup polygon descriptions of image seed patterns from
           row and column vectors */
        for (r_index = 0; r_index < no_vectors; r_index++) {
            for (c_index = 0; c_index < no_vectors; c_index++) {
                p_point->p[0].x = 0;
                p_point->p[0].y = 0;

                p_point->p[1].x = c_vector[c_index].x;
                if (x_mins > p_point->p[1].x)  x_mins = p_point->p[1].x;
                if (x_maxs < p_point->p[1].x)  x_maxs = p_point->p[1].x;
                p_point->p[1].y = c_vector[c_index].y;
                if (y_mins > p_point->p[1].y)  y_mins = p_point->p[1].y;
                if (y_maxs < p_point->p[1].y)  y_maxs = p_point->p[1].y;

                p_point->p[2].x = c_vector[c_index].x + r_vector[r_index].x;
                if (x_mins > p_point->p[2].x)  x_mins = p_point->p[2].x;
                if (x_maxs < p_point->p[2].x)  x_maxs = p_point->p[2].x;
                p_point->p[2].y = c_vector[c_index].y + r_vector[r_index].y;
                if (y_mins > p_point->p[2].y)  y_mins = p_point->p[2].y;
                if (y_maxs < p_point->p[2].y)  y_maxs = p_point->p[2].y;

                p_point->p[3].x = r_vector[r_index].x;
                if (x_mins > p_point->p[3].x)  x_mins = p_point->p[3].x;
                if (x_maxs < p_point->p[3].x)  x_maxs = p_point->p[3].x;
                p_point->p[3].y = r_vector[r_index].y;
                if (y_mins > p_point->p[3].y)  y_mins = p_point->p[3].y;
                if (y_maxs < p_point->p[3].y)  y_maxs = p_point->p[3].y;

#ifdef  DBG1
                printf("[%d, %d]  [%d, %d]  [%d, %d]\n",
                       p_point->p[1].x, p_point->p[1].y,
                       p_point->p[2].x, p_point->p[2].y,
                       p_point->p[3].x, p_point->p[3].y);
#endif

                p_point++;
            }
        }

#ifdef  DBG1
        printf("X-: %d    X+: %d\n", x_mins, x_maxs);
        printf("Y-: %d    Y+: %d\n", y_mins, y_maxs);
#endif

        x_maxs-= x_mins;        y_maxs-= y_mins;

        /* determine if image seed pattern is applicable or not */
        isp_flag = (ufix)((BM_BOUND(x_maxs)) <= MAXSAMPLEWIDTH &&
                    (BM_BYTES(x_maxs) * y_maxs) <= (ufix)isp_size)       //@WIN
                   ? ISP_FILL : ISP_NONE;

#ifdef  DBG1
        printf((isp_flag == ISP_FILL)
               ? "SEED is applicable\n" : "SEED is too large\n");
#endif

        if (isp_flag == ISP_FILL) {
            /* generate all image seed patterns: 4 or 16 */
            for (p_index= 0, p_point = patterns; p_index < no_samples;
                 p_index++, p_point++)
            {
                fix                     index;
                struct sample           quadrangle;

                /* select seed index */
                image_info.seed_index = (fix16)p_index;

                for (index = 0; index < 4; index++)
                {
                    quadrangle.p[index].x = p_point->p[index].x - x_mins;
                    quadrangle.p[index].y = p_point->p[index].y - y_mins;
                }

                fill_seed(fill_destination_save, x_maxs,        /* 05-25-89 */
                                      y_maxs, &quadrangle);
            }
        }

        no_lookups = 0;
    }

    /* setup lookup description of column */
    if (isp_flag == ISP_FILL)                                   /* 03-30-89 */
    {
        fix                 index;
        struct lookup huge  *point;     /* @WIN 04-20-92 */
        fix                 c_post_x, c_post_y;
        lfix_t              c_pabs_x, c_pabs_y;

#ifdef  DBG1
        printf("#L: %d\n", width);
#endif

        if ((x_lookup = (struct lookup huge *)  /* @WIN 04-20-92 */
                    alloc_heap((ufix32) (width + 1)
                                    * sizeof(struct lookup))) == NIL)
        {
            CLEAR_ERROR();
            goto skip;
        }

        point = x_lookup;
        c_post_x = c_post_y = 0;
        c_pabs_x = c_pabs_y = 0;

        if (itm_type == ITM_A00D) {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_x+= c_padv_x;
                if ((LFX2S(c_pabs_x) - c_post_x) == c_maxs.x)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_x = LFX2S(c_pabs_x);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }
        } else
        if (itm_type == ITM_0BC0) {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_y+= c_padv_y;
                if ((LFX2S(c_pabs_y) - c_post_y) == c_maxs.y)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_y = LFX2S(c_pabs_y);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }
        } else {
            for (index = 0; index < width; point++, index++) {
                point->x = (fix16)c_post_x;
                point->y = (fix16)c_post_y;

                c_pabs_x+= c_padv_x;
                if ((LFX2S(c_pabs_x) - c_post_x) == c_maxs.x)
                    point->index = 0x01;
                else
                    point->index = 0x00;
                c_post_x = LFX2S(c_pabs_x);

                c_pabs_y+= c_padv_y;
                if ((LFX2S(c_pabs_y) - c_post_y) == c_maxs.y)
                    point->index|= 0x02;
                c_post_y = LFX2S(c_pabs_y);

#ifdef  DBG7
                printf("%x %d,%d\n", point->index, point->x, point->y);
#endif
            }

            point->x = (fix16)c_post_x;
            point->y = (fix16)c_post_y;
        }

        no_lookups = width;

    skip:   ;
    }
}


/************************************************************************
 *
 * This module is to flush sample list to page
 *
 * TITLE:       flush_seed_sample_list
 *
 * CALL:        flush_seed_sample_list()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
flush_seed_sample_list(optype, gray_res, bb)
ufix     optype;
fix      gray_res;
fix FAR bb[];
{
    fix     index;
    fix     bb_xorig;
    fix     bb_yorig;
    fix     bb_width;
    fix     bb_height;

    bb_xorig  = bb[0];                                          /* 01-26-89 */
    bb_yorig  = bb[2];                                          /* 01-26-89 */
    bb_width  = bb[1] - bb[0];                                  /* 01-26-89 */
    bb_height = bb[3] - bb[2] + 1;                              /* 01-26-89 */

#ifdef  DBG3
    printf("SEED:  %x %x %x %x\n", bb_xorig, bb_yorig, bb_width, bb_height);
#endif

    if (optype == IMAGE) {
        for (index = 0; index <= gray_res; index++) {
            if (gray_chain[index].start_seed_sample != NULLP) {
#ifdef  DBG4
                printf("flush %x: %f %x\n",
                index, gray_map[index], gray_chain[index].start_seed_sample);
#endif

                setgray(F2L(gray_map[index]));
                draw_image_page(bb_xorig, bb_yorig,
                                bb_width, bb_height,
                                gray_chain[index].start_seed_sample);

/*                free_node(gray_chain[index].start_seed_sample);       */
                gray_chain[index].start_seed_sample = NULLP;
            }
        }
    } else {
        if (gray_chain[0].start_seed_sample != NULLP) {
            switch (fill_destination) {
            case F_TO_PAGE :
                 draw_image_page(bb_xorig, bb_yorig,
                                 bb_width, bb_height,
                                 gray_chain[0].start_seed_sample);
                 break;
            case F_TO_CACHE :
                 fill_image_cache(cache_info->bitmap,
                                  cache_info->box_w,
                                  cache_info->box_h,
                                  gray_chain[0].start_seed_sample);
                 break;
            }
/*            free_node(gray_chain[0].start_seed_sample);       */
            gray_chain[0].start_seed_sample = NULLP;
        }
    }
} /* end of flush_seed_sample_list() */


/************************************************************************
 *
 * This module is to flush sample list to page
 *
 * TITLE:       flush_clip_sample_list
 *
 * CALL:        flush_clip_sample_list()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
/*flush_clip_sample_list(optype, gray_res, bb, last_isp)*/
flush_clip_sample_list(optype, gray_res, bb)
ufix     optype;
fix      gray_res;
fix  FAR bb[];
/*struct isp_data *last_isp;*/
{
    fix    index;
    fix    bb_xorig;
    fix    bb_yorig;
    fix    bb_width;
    fix    bb_height;
    ufix   dest_save;

    bb_xorig  = bb[0];                                          /* 01-26-89 */
    bb_yorig  = bb[2];                                          /* 01-26-89 */
    bb_width  = bb[1] - bb[0];                                  /* 01-26-89 */
    bb_height = bb[3] - bb[2] + 1;                              /* 01-26-89 */

#ifdef  DBG3
    printf("CLIP:  %x %x %x %x\n", bb_xorig, bb_yorig, bb_width, bb_height);
#endif

    /* save fill_destination */
    dest_save = fill_destination;

    /* generate clipping mask for clipped image */
    image_info.bb_lx = (fix16)bb_xorig;
    image_info.bb_ly = (fix16)bb_yorig;
    image_info.bb_xw = (fix16)bb_width;
    image_info.bb_yh = (fix16)bb_height;
    fill_shape(NON_ZERO, F_FROM_IMAGE, F_TO_MASK);

    /* restore fill_destination */
    fill_destination = dest_save;

    if (optype == IMAGE) {
        for (index = 0; index <= gray_res; index++) {
            if (gray_chain[index].start_seed_sample != NULLP) {
#ifdef  DBG4
                printf("flush %x: %f %x\n",
                index, gray_map[index], gray_chain[index].start_seed_sample);
#endif

                setgray(F2L(gray_map[index]));
                fill_image_page(gray_chain[index].start_seed_sample);
/*                fill_image_page(gray_chain[index].start_seed_sample); -jwm, 12/26 */

/*                free_node(gray_chain[index].start_seed_sample);       -jwm, 12/26 */
                gray_chain[index].start_seed_sample = NULLP;
            }
        }
    } else {
        if (gray_chain[0].start_seed_sample != NULLP) {
            fill_image_page(gray_chain[0].start_seed_sample);
/*            fill_image_page(gray_chain[0].start_seed_sample);         -jwm, 12/26 */
/*            free_node(gray_chain[0].start_seed_sample);               -jwm, 12/26 */
            gray_chain[0].start_seed_sample = NULLP;
        }
    }
} /* end of flush_clip_sample_list() */


/************************************************************************
 *
 * This module is to detect if portrate or landscape
 *
 * TITLE:       image_shortcut
 *
 * CALL:        clear_image
 *
 * INTERFACE:
 *
 * CALLS:
 *
 *********************************************************************/
bool image_shortcut(inv_matrix, image_bb, type)
real32  FAR *inv_matrix, FAR *image_bb;
fix     type;
{
    fix    clip_status;
    real32  tmp0, tmp1, tmp2, tmp3;     // @WIN: fabs => FABS
        FABS(tmp0, inv_matrix[0]);      // @WIN
        FABS(tmp1, inv_matrix[1]);      // @WIN
        FABS(tmp2, inv_matrix[2]);      // @WIN
        FABS(tmp3, inv_matrix[3]);      // @WIN

        image_dev_flag = FALSE;
//      if ( (0.001 > (float)fabs(inv_matrix[1])) &&    @WIN
//                (0.001>(float)fabs(inv_matrix[2]))) {
        if ( 0.001 > tmp1 && 0.001 > tmp2) {

#ifdef  DBG1
            printf("[A 0 0 D Tx Ty]\n");
#endif

             image_dev_flag = PORTRATE;
//      } else if ( (0.001 > (float)fabs(inv_matrix[0])) &&     @WIN
//              (0.001 > (float)fabs(inv_matrix[3])) ) {
        } else if ( 0.001 > tmp0 && 0.001 > tmp3) {
#ifdef  DBG1
            printf("[0 B C 0 Tx Ty]\n");
#endif
             image_dev_flag =LANDSCAPE;

        }
        else
            {
             return(0);
             }

    if ( fill_destination != F_TO_CACHE ) {
        if ((clip_status = check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
             return(0);
        }
        if (clip_status == CLIP) {
                if(GSptr->clip_path.single_rect) {
                        image_logic_op |= IMAGE_CLIP_BIT;
                        if (image_bb[0] < SFX2F(GSptr->clip_path.bb_lx))
                            image_bb[0] = SFX2F(GSptr->clip_path.bb_lx);
                        if (image_bb[1] > SFX2F(GSptr->clip_path.bb_ux))
                            image_bb[1] = SFX2F(GSptr->clip_path.bb_ux);
                        if (image_bb[2] < SFX2F(GSptr->clip_path.bb_ly))
                            image_bb[2] = SFX2F(GSptr->clip_path.bb_ly);
                        if (image_bb[3] > SFX2F(GSptr->clip_path.bb_uy))
                            image_bb[3] = SFX2F(GSptr->clip_path.bb_uy);
                }
                else
                        return(0);

        }
        //
        // NTFIX, this was incorrectly commented out, we put it back.
        //

        if(type == IMAGE)              // @WIN_IM: not need to clear image ???
          clear_image(image_bb);      //  @WIN_IM


        return(1);
    }
    return(0);

} /* image_shortcut */

/************************************************************************
 *      (Not used by window)
 * This module is to implement image operator
 * Syntax :        width height bits matrix proc   image   -
 *
 * TITLE:       op_image
 *
 * CALL:        op_image()
 *
 * INTERFACE:   interpreter(op_image)
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
fix
op_image()
{
    fix32  height;
    lfix_t lfxm[MATRIX_LEN];
    fix    shift, width, index, gray_res;
    real32 matrix[MATRIX_LEN], inv_matrix[MATRIX_LEN], image_bb[4];
    fix    clip_status;
    real32 save_gray;
    struct object_def FAR *obj_matrix, obj_proc, name_obj;
    real32 tmp;

    byte huge          *vmheap_save;                            /* 02-13-89 */

#ifdef  DBG
    printf("op_image......\n");
#endif

    /* Check in setcachedevice error */
    if (is_after_setcachedevice()) {     /* @@ 08/17/88, you */
        /* Buildchar_and_setcachedevice flag is set to TRUE, when
         * setcachedevice operator is worked within the scope of a
         * Buildchar procedure
         */
        get_name(&name_obj, "image", 5, FALSE);
        if (FRCOUNT() < 1) {            /* Jerry 10-07-88 */
            ERROR(STACKOVERFLOW);
            return(0);
        }
        PUSH_OBJ(&name_obj);
        ERROR(UNDEFINED);
        return(0);
    }

    /* set fill_destination, it always fills to pages */
    fill_destination = F_TO_PAGE;

    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4));
 *  height = (fix32) get_obj_value(GET_OPERAND(3));
 *  shift  = ( fix ) get_obj_value(GET_OPERAND(2));
 */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix ) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(3));
    height = (fix32) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(2));
    shift  = ( fix ) tmp;

/* mslin, begin  1/3/91 IMG_OPT */
    image_logic_op = IMAGE_BIT;
    image_shift = (ubyte)shift;         //@WIN
/* mslin, end 1/3/91 IMG_OPT */


#ifdef  DBG
    printf("width  = %d\n", width);
    printf("height = %d\n", height);
    printf("shift  = %d\n", shift);
#endif

    obj_matrix = GET_OPERAND(1);
    COPY_OBJ(GET_OPERAND(0), &obj_proc);

    /* limit error check */
   /* mslin 4/17/91
    *if (width > 3331) {                 |* get from ADOBE postscript *|
    *    ERROR(LIMITCHECK);
    *    return(0);
    *}
    */

    /* rangecheck error check */
    if ((shift != 1) && (shift != 2) &&
        (shift != 4) && (shift != 8)) {
        ERROR(RANGECHECK);
        return(0);
    }

    /* check access right */
    if (!access_chk(obj_matrix, G_ARRAY) ||
        !get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY))
        return(0);

    SAVE_OPNPTR();      /*mslin 5/6/91*/
    POP(5);

    //while(GEIeng_checkcomplete());    /* @CPPH; Debug by scchen @WIN */
    flush_gcb(TRUE);    /* 5-21-91, Jack */


    /* Save current gray level */
    save_gray = GSptr->color.gray;

    /* Save the VM heap pointer */
    vmheap_save = vmheap;                                       /* 02-13-89 */

    /* Initialization; set image parameters & calculate image bounding box */
    image_matrix((real32 FAR *) matrix, (real32 FAR *) inv_matrix,
                 height, width, (real32 FAR *) image_bb);

/*mslin 3/26/91 begin OPT*/
    if(image_shortcut(inv_matrix,image_bb, IMAGE)) {
         /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }
#ifdef DBG_MS
{
    static ufix32       tmp, tmp1;

    tmp = curtime();
#endif
        scale_image_process(width, height,
                            obj_proc, (lfix_t FAR *) lfxm);
#ifdef DBG_MS
    tmp1 = curtime() - tmp;
    printf("time=%ld ", tmp1);
}
#endif
        goto exit;
    }
/*mslin 3/26/91 end OPT*/

    /* setup image seed patterns and relative information */
    image_sample((real32 FAR *) inv_matrix, width);

    if (ANY_ERROR())  goto exit;                                /* 02-13-89 */

    /* setup gray level mapping table */
    gray_res = (1 << shift) - 1;
    if (gray_res != save_res) {
        for (index = 0; index <= gray_res; index++) {
            gray_map[index] = (float) index / (float) gray_res;
        }
        save_res = gray_res;
    }

#ifdef  DBG
    printf("gray_res = %d\n", gray_res);
#endif

    /*  image/imagemask processing guildline:
     *
     *  best_image_process      -- INSIDE_CLIPPATH
     *  fast_clip_image_process -- CLIP AND ABLE TO FIT INTO SEED AND CMB
     *  slow_clip_image_process -- INSIDE_CLIPPATH OR
     *                                    UNABLE TO FIT INTO SEED OR CMB
     *  worst_image_process     -- UNABLE TO FIT INTO INTERNAL FORMAT
     *  exhaust_image_data      -- OUTSIDE_CLIPPATH
     */



    /* check if cross with wide_page size boundary */
    /* fast macro for boundary crossing check
    if (image_bb[0] < (real32)PAGE_LEFT || image_bb[1] > (real32)PAGE_RIGHT ||
        image_bb[2] < (real32)PAGE_TOP  || image_bb[3] > (real32)PAGE_BTM) {
    */
    if (too_small(F2L(image_bb[0])) || too_large(F2L(image_bb[1])) ||
        too_small(F2L(image_bb[2])) || too_large(F2L(image_bb[3]))) {
        /* worst process case */
        worst_image_process(IMAGE, width, height, shift, FALSE, obj_proc,
                            (real32 FAR *) inv_matrix);
        goto exit;
    }

    if ((clip_status = check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
        exhaust_image_data(width, height, shift, obj_proc);
        goto exit;

    }
    else { /* CLIP || INSIDE_CLIPPATH */

        /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }

        /* initial gray_chain */
        for (index = 0; index <= gray_res; index++) {
            gray_chain[index].start_seed_sample = NULLP;
        }

        /* check sample size is applicable or not */
        if (isp_flag == ISP_NONE || x_lookup == NIL) {  /* 03-30-89 04-08-89 */
            /* worst process case */
            slow_clip_image_process(IMAGE, width, height, shift, FALSE,
                                    obj_proc, gray_res, (lfix_t FAR *) lfxm);
            goto exit;
        }

        /* clip */
        if (clip_status == CLIP) {

            fast_clip_image_process(IMAGE, width, height, shift, FALSE,
                                    obj_proc, gray_res, (lfix_t FAR *) lfxm);

        } /* if CLIP */
        else { /* clip_status == INSIDE_CLIPPATH */

            best_image_process(IMAGE, width, height, shift, FALSE,
                               obj_proc, gray_res, (lfix_t FAR *) lfxm);

        }/* else INSIDE_CLIPPATH */
    }/* else CLIP || INSIDE_CLIPPATH */

exit:
    /* Restore the VM heap pointer */
    free_heap(vmheap_save);                     /* 02-13-89 */  /* 03-30-89 */

    /* Restore the gray level */
    setgray(F2L(save_gray));

#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %x %x %x %x\n",
           GSptr->clip_path.bb_lx, GSptr->clip_path.bb_ux,
           GSptr->clip_path.bb_ly, GSptr->clip_path.bb_uy);
#endif

    /*mslin 5/6/91 begin */
    if(ANY_ERROR())
        RESTORE_OPNPTR();
    /*mslin 5/6/91 end */

    return(0);
}/* end op_image */


/************************************************************************
 * This module is to implement imagemask operator.
 * Syntax :        width height invert matrix proc   imagemask   -
 *
 * TITLE:       op_imagemask
 *
 * CALL:        op_imagemask()
 *
 * INTERFACE:   interpreter(op_imagemask)
 *
 * CALLS:       none
 ************************************************************************/
fix
op_imagemask()
{
    fix    width;
    real32 matrix[MATRIX_LEN];
    struct object_def FAR *obj_matrix;
    real32 tmp;

#ifdef  DBG
    printf("op_imagemask......\n");
#endif

    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4)); */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix )tmp;

    obj_matrix = GET_OPERAND(1);

    /* limit error check */
   /* mslin 4/17/91
    *  if (width > 3331) {             |* get from ADOBE postscript *|
    *      ERROR(LIMITCHECK);
    *      return(0);
    * }
    */

    /* check access right */
    if (!access_chk(obj_matrix, G_ARRAY) ||
        !get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY))
        return(0);

    /*
     * The lines listed above are moved from imagemask_shape()
     *                                  @#IMAGE: 05-25-88 Y.C.
     */

    /*  UNDEFINED error check in show_buildchar() */
    if (buildchar) {
        show_buildchar(OP_IMAGEMASK);
        POP(5);         /* 5-8-91, Jack */
    } else
        imagemask_shape(F_TO_PAGE);

/*  POP(5); *mslin, 5/6/91 */

    //while(GEIeng_checkcomplete());    /* @CPPH; Debug by scchen @WIN */
    flush_gcb(TRUE);    /* 5-21-91, Jack */


#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %x %x %x %x\n",
           GSptr->clip_path.bb_lx, GSptr->clip_path.bb_ux,
           GSptr->clip_path.bb_ly, GSptr->clip_path.bb_uy);
#endif

    /*mslin 5/6/91 begin */
    if(ANY_ERROR())
        RESTORE_OPNPTR();
    /*mslin 5/6/91 end */

    return(0);
}/* end of op_imagemask */


/************************************************************************
 * This module is to implement imagemask operator.
 *
 * TITLE:       imagemask_shape
 *
 * CALL:        imagemask_shape(dest)
 *
 * INTERFACE:   op_imagemask
 *
 * CALLS:       transform, convex_clipper, filler
 ************************************************************************/
void
imagemask_shape(dest)
ufix    dest;
{
    fix32  height;
    lfix_t lfxm[MATRIX_LEN];
    bool   invert;
    fix    width, index;
    real32 matrix[MATRIX_LEN], inv_matrix[MATRIX_LEN], image_bb[4];
    fix    clip_status;
//  fix    max_bb_height;       @win
    fix shift=1,gray_res=1;
    struct object_def FAR *obj_matrix, obj_proc;
    real32 tmp;

    byte huge          *vmheap_save;                            /* 02-13-89 */

#ifdef  DBG
    printf("imagemask_shape......\n");
#endif

    /* set fill_destination, it always fills to pages */
    fill_destination = dest;


    /* Get operands and/or input value */
/*  width  = ( fix ) get_obj_value(GET_OPERAND(4));
 *  height = (fix32) get_obj_value(GET_OPERAND(3));
 */
    GET_OBJ_VALUE(tmp, GET_OPERAND(4));
    width  = ( fix ) tmp;
    GET_OBJ_VALUE(tmp, GET_OPERAND(3));
    height = (fix32) tmp;
    invert = (bool)  VALUE(GET_OPERAND(2));

/* mslin, begin 1/3/91 IMG_OPT */
    image_shift = 1;
    image_logic_op = (ubyte)(invert == FALSE ? IMAGEMASK_FALSE_BIT :    //@WIN
                        0);
/* mslin, end 1/3/91 IMG_OPT */

#ifdef  DBG
    printf("width  = %d\n", width);
    printf("height = %d\n", height);
    printf("invert = %d\n", invert);
#endif

    obj_matrix = GET_OPERAND(1);
    COPY_OBJ(GET_OPERAND(0), &obj_proc);

    /*mslin 5/6/91 begin, retored by op_imagemask() if error occurred */
    SAVE_OPNPTR();
    if (! buildchar)    /* 5-8-91, Jack */
        POP(5);
    /*mslin 5/6/91 end */


    //NTFIX we can get here in valid conditions and should check for for test....
    //      this boundary condition.

    if (height == 0 || width == 0 ) {
#ifdef DBG
       printf("\nGetting width or height = 0 in imagemask_shape()");
#endif
       return;
    }

    get_array_elmt(obj_matrix, MATRIX_LEN, matrix, G_ARRAY);

    /* Save the VM heap pointer */
    vmheap_save = vmheap;                                       /* 02-13-89 */

    /* Initialization; set image parameters & calculate image bounding box */
    image_matrix((real32 FAR *) matrix, (real32 FAR *) inv_matrix,
                 height, width, (real32 FAR *) image_bb);

/*mslin 3/26/91 begin OPT*/
    if(image_shortcut(inv_matrix,image_bb, IMAGEMASK)) {
         /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }
        scale_image_process(width, height,
                            obj_proc, (lfix_t FAR *) lfxm);
        goto exit;
    }
/*mslin 3/26/91 end OPT*/

    /* setup image seed patterns and relative information */
    image_sample((real32 FAR *) inv_matrix, width);

    if (ANY_ERROR())  goto exit;                                /* 02-13-89 */



    /* check if cross with wide_page size boundary */
    /* fast macro for boundary crossing check
    if (image_bb[0] < (real32)PAGE_LEFT || image_bb[1] > (real32)PAGE_RIGHT ||
        image_bb[2] < (real32)PAGE_TOP  || image_bb[3] > (real32)PAGE_BTM) {
    */
    if (too_small(F2L(image_bb[0])) || too_large(F2L(image_bb[1])) ||
        too_small(F2L(image_bb[2])) || too_large(F2L(image_bb[3]))) {
        /* worst process case */
        worst_image_process(IMAGEMASK, width, height, 1, invert, obj_proc,
                            (real32 FAR *) inv_matrix);
        goto exit;
    }

    if ((clip_status = (fill_destination == F_TO_CACHE)
                     ? INSIDE_CLIPPATH
                     : check_clip_status((real32 FAR *) image_bb))
                == OUT_CLIPPATH) {
        exhaust_image_data(width, height, 1, obj_proc);
        goto exit;
    }
    else { /* CLIP || INSIDE_CLIPPATH */

        /* transform real32 to fix32 fix integer */
        for (index = 0; index < 6; index++) {
            lfxm[index] = F2LFX(inv_matrix[index]);
        }

        /* initial gray_chain */
        gray_chain[0].start_seed_sample = NULLP;

        /* check sample size is applicable or not */
        if (isp_flag == ISP_NONE || x_lookup == NIL) {  /* 03-30-89 04-08-89 */
            /* worst process case */
            slow_clip_image_process(IMAGEMASK, width, height, 1, invert,
                                    obj_proc, 1, (lfix_t FAR *) lfxm);
            goto exit;

        }
        /* clip */
        if (clip_status == CLIP) {

            fast_clip_image_process(IMAGEMASK, width, height, 1, invert,
                                    obj_proc, 1, (lfix_t FAR *) lfxm);

        } /* if CLIP */
        else { /* clip_status == INSIDE_CLIPPATH */

            best_image_process(IMAGEMASK, width, height, 1, invert,
                               obj_proc, 1, (lfix_t FAR *) lfxm);

        }/* else INSIDE_CLIPPATH */
    }/* else CLIP || INSIDE_CLIPPATH */

exit:
    /* Restore the VM heap pointer */
    free_heap(vmheap_save);                     /* 02-13-89 */  /* 03-30-89 */

    return;
}/* end of imagemask_shape */

/*mslin 3/21/91 begin OPT*/
/************************************************************************
 *
 * This module is to implement clear image area before render image
 *
 * TITLE:       clear_image
 *
 * CALL:
 *
 * INTERFACE:
 *
 * CALLS:
 * History:     MSLin created on 3/21/91
 *
 *********************************************************************/

void
clear_image(bb)
real32  FAR *bb;
{
 fix                 ys_line, no_lines;
 register  fix       nwords;                     /* ufix -> fix  11-08-88 */
 register  ufix16    FAR *ptr;
 register  SCANLINE  xs, xe;
 register  fix       bb_width;
           ufix16    FAR *scan_addr;
           ufix16    FAR *bb_addr;
 register  ufix16    lmask, rmask;
           ufix16    loffset;
 real32              FAR *rptr;

   /*
    * get destination bitmap address & width
    */
   bb_addr = (ufix16 FAR *)FB_ADDR;
   bb_width = FB_WIDTH;
   rptr = bb;
   xs = (SCANLINE)F2SHORT(*rptr++) + 1;
   xe = (SCANLINE)F2SHORT(*rptr++) - 1;
   ys_line = (fix)F2SHORT(*rptr++) + 1;                 /* -1 ??? */
   no_lines = (fix)*rptr - ys_line - 1;                 /* -1 ??? */
   if(xe < xs)
        return;

#ifdef DBG_MS
 printf("xs=%d, xe=%d, ys=%d,  ye=%d\n",
         xs, xe, (fix)bb[2], (fix)bb[3]);
#endif
#ifdef DBG
 printf("Enter scanline(), bb_addr = %lx, no_lines = %d\n", bb_addr, no_lines);
#endif

   /*
    * caculate 1st scanline starting address
    */
   scan_addr = bb_addr + ys_line * (bb_width >> SHORTPOWER);

   /*
    * Filling zero
    */
     while(no_lines-- >0) {
        /*
         * process segment by segment
         */
#ifdef DBG
  printf("line start\n");
#endif
                /*
                 * fill left partial word
                 * fill nwords full word
                 * fill right partial word
                 */

                ptr = scan_addr + (xs >> SHORTPOWER);
#ifdef DBG
  printf("seg. ptr = %lx, xs = %d, xe = %d\n", ptr, xs, xe);
#endif
                loffset = xs & SHORTMASK;
                lmask = (ufix16) (ONE16 LSHIFT loffset);        //@WIN
                rmask = (ufix16) BRSHIFT(ONE16,
                        (BITSPERSHORT -((fix16)xe & SHORTMASK)),16); //@WIN
                nwords = (xe >> SHORTPOWER) - (xs >> SHORTPOWER);
#ifdef DBG
  printf("lmask = %x, rmask = %x, nwords = %d\n", lmask, rmask, nwords);
#endif
                if(nwords == 0) {
                   *ptr &= ~lmask;
                   continue;
                }
                if(lmask != 0) {
                   *ptr &=  ~lmask;
                   ptr++;
                }
                while(--nwords > 0)
                   *ptr++ = 0;
                *ptr &= ~rmask;

        /*
         * move scanline address to next line.
         */
        scan_addr += bb_width >> SHORTPOWER;

     } /* while */

} /* clear_image */

/************************************************************************
 *
 * This module is to implement scale image process
 *
 * TITLE:       scale_image_process
 *
 * CALL:        scale_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 * History:     MSLin created on 3/21/91
 *
 *********************************************************************/
static void near
scale_image_process(width, height, obj_proc, lfxm)
fix    width;
fix32  height;
struct object_def obj_proc;
lfix_t FAR  lfxm[];
{
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    IMAGE_INFOBLOCK     infoptr;

#ifdef  DBGX
    printf("scale_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    flush_gcb(TRUE);    /*mslin 3/29/91 for 29K*/

       r_post_x = LFX2S(lfxm[4]);
       r_post_y = LFX2S(lfxm[5]);
#ifdef DJC //The printf below acceses variables that are now undefined
#ifdef DBG1
        printf("r_post_x=%d, r_post_y=%d\n", r_post_x, r_post_y);
        printf("dst_ptr[BASE]=%lx [%lx]\n", dst_ptr, FBX_BASE);
        printf("bb_width=%d, max_bb_height=%d\n", bb_width, max_bb_height);
#endif
#endif

        infoptr.raw_width = (ufix16)width;
        infoptr.raw_height = (ufix16)height;    //@WIN
        infoptr.dev_buffer = (ufix16 FAR *)edge_table;
        infoptr.dev_buffer_size = (fix)(MAXEDGE * sizeof(struct edge_hdr)) ;
        infoptr.lfxm = lfxm;
        infoptr.ret_code = NOT_DONE;
        infoptr.obj_proc = obj_proc;
        infoptr.bits_p_smp = image_shift;
        infoptr.xorig = (fix16)r_post_x;
        infoptr.yorig = (fix16)r_post_y;
        image_PortrateLandscape(&infoptr);

      /* pop the last string in operand stack */
      POP(1);
      return;

} /* scale_image_process */
/*mslin 3/21/91 end OPT*/

/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       best_image_process
 *
 * CALL:        best_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
best_image_process(optype, width, height, shift, invert, obj_proc,
                   gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    fix         bit_count, right;
    ufix        chr_count;
    fix32       start_h, end_h;
    fix         bb_height, bb[4];
    fix32       gwb_size;                                       /* 01-26-89 */
    fix         max_bb_height;
    fix16       isp;
    struct isp_data     FAR *isp_ptr;

    fix         ys_index;                                               /*@OPT*/
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    fix         r_psav_x, r_psav_y;                                     /*@OPT*/
    lfix_t      r_pabs_x, r_pabs_y;                                     /*@OPT*/
    struct lookup huge  *xs_point;      /* @WIN 04-20-92 */


    /* decide gwb_size and whether gwb_size is enough or not */
    gwb_space(&gwb_size);                                       /* 01-26-89 */

    if ((max_bb_height = image_gwcm_space(gwb_size, (lfix_t FAR *) lfxm,
                                          width)) <= 0) {       /* 01-26-89 */
        // UPD053
        slow_clip_image_process(optype, width, height, shift, FALSE,
                                 obj_proc, gray_res,
                                 (lfix_t FAR *) lfxm);
        return;
    }

#ifdef  DBGX
    printf("best_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }


    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;

    /* initial bb_height & start_h */
    bb_height = 0;
    start_h = 1;

    r_post_x = LFX2S(lfxm[4]) + x_mins;
    r_post_y = LFX2S(lfxm[5]) + y_mins;
    r_pabs_x = I2LFX(r_post_x);
    r_pabs_y = I2LFX(r_post_y);

    isp = 0;            /* jwm, 12/26 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        r_psav_x = r_post_x;
        r_psav_y = r_post_y;

        if (itm_type == ITM_A00D)                                       /*@OPT*/
        {
            r_pabs_y+= r_padv_y;
/*          if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)*/
            if (((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y) || (y_maxs == 1)) /*
12-18-90 */
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("A- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        if (itm_type == ITM_0BC0)
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x04;
                else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);

            r_pabs_y+= r_padv_y;
            if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)
                ys_index|= 0x08;

            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }

        xs_point = x_lookup;

        for (ix=1; ix<=width; ix++) {

            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

            if (optype == IMAGE || !(sval ^ invert)) {

                if (isp >= last_isp_index) {            /* jwm, 12/26 */
/*                if ((isp = get_node()) == NULLP) [    */

                    end_h = start_h + bb_height;
                    /* calculate image bounding box */
                    band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                                  width, (fix FAR *) bb);
                    /* transfer sample list to page cache */
                    flush_seed_sample_list(optype, gray_res, (fix FAR *) bb);
                    start_h = end_h;
                    bb_height = 0;

                    isp = 0;    /* jwm, 12/26 */

/*                    if ((isp = get_node()) == NULLP) {
 *                        ERROR(LIMITCHECK);
 *                        return;
 *                    }
 */
                }

                /* calculate up_left corner's position */

                isp_ptr = &isp_table[isp];
                isp_ptr->bb_x = r_psav_x + xs_point->x;
                isp_ptr->bb_y = r_psav_y + xs_point->y;
                isp_ptr->index = ys_index + xs_point->index;
                if (optype == IMAGE) {
                    isp_ptr->next = gray_chain[sval].start_seed_sample;
                    gray_chain[sval].start_seed_sample = isp;
                } else {
                    isp_ptr->next = gray_chain[0].start_seed_sample;
                    gray_chain[0].start_seed_sample = isp;
                }

                ++isp;



/*                node_table[isp].SAMPLE_BB_LX = r_psav_x + xs_point->x;
 *                node_table[isp].SAMPLE_BB_LY = r_psav_y + xs_point->y;
 *                if (optype == IMAGE) {
 *                    node_table[isp].next =
 *                                    gray_chain[sval].start_seed_sample;
 *                    gray_chain[sval].start_seed_sample = isp;
 *                } else {
 *                    node_table[isp].next = gray_chain[0].start_seed_sample;
 *                    gray_chain[0].start_seed_sample = isp;
 *                }
 *
 *                node_table[isp].SEED_INDEX = ys_index + xs_point->index;
 */

#ifdef  DBG9
                printf("* %x,%x %x/%x\n",
                       r_psav_x + xs_point->x, r_psav_y + xs_point->y,
                       sval, ys_index + xs_point->index);
#endif
            }/* if */

            xs_point++;
        }/* for ix */

        bb_height++;
        /* check if bb_height is reached */
        if (bb_height == max_bb_height || iy == height) {

            end_h = start_h + bb_height - 1;
            /* calculate image bounding box */
            band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                          width, (fix FAR *) bb);
            /* transfer sample list to page or cache */
            flush_seed_sample_list(optype, gray_res, (fix FAR *) bb);
            start_h = end_h + 1;
            bb_height = 0;

            isp = 0;    /* jwm, 12/26 */

        }/* if max_bb_height */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of best_image_process */


/********************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       fast_clip_image_process
 *
 * CALL:        fast_clip_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
fast_clip_image_process(optype, width, height, shift, invert, obj_proc,
                        gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    fix         bit_count, right;
    ufix        chr_count;
    fix32       start_h, end_h;
    fix         bb_height, bb[4];
    fix32       cmb_size;                                       /* 01-26-89 */
    fix         max_bb_height;
    fix16       isp;    /* jwm, 12/26 */
    struct isp_data     FAR *isp_ptr;

/*    SP_IDX      isp; */

    fix         ys_index;                                               /*@OPT*/
    fix         r_post_x, r_post_y;                                     /*@OPT*/
    fix         r_psav_x, r_psav_y;                                     /*@OPT*/
    lfix_t      r_pabs_x, r_pabs_y;                                     /*@OPT*/
    struct lookup huge *xs_point;       /* @WIN 04-20-92 */

#define ROW_NONE        0x00
#define ROW_FILL        0x01
    fix         row_flag;                                               /*@OPT*/
#define ROW_PRIO        0x00
#define ROW_CLIP        0x01
#define ROW_POST        0x02
    fix         row_type;                                               /*@OPT*/
    fix         bb_lx, bb_ux;                                           /*@OPT*/
    fix         bb_ly, bb_uy;                                           /*@OPT*/

    /* decide gwb_size and whether gwb_size is enough or not */
    cmb_space(&cmb_size);                                       /* 01-26-89 */

    if ((max_bb_height = image_gwcm_space(cmb_size, (lfix_t FAR *) lfxm,
                                          width)) <= 0) {       /* 01-26-89 */
        // UPD053
        slow_clip_image_process(optype, width, height, shift, FALSE,
                                 obj_proc, gray_res,
                                 (lfix_t FAR *) lfxm);
        return;
    }

#ifdef  DBGX
    printf("fast_clip_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif


    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }


    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;

    /* initial bb_height & start_h */
    bb_height = 0;
    start_h = 1;

    r_post_x = LFX2S(lfxm[4]) + x_mins;
    r_post_y = LFX2S(lfxm[5]) + y_mins;
    r_pabs_x = I2LFX(r_post_x);
    r_pabs_y = I2LFX(r_post_y);

    row_flag = ROW_NONE;
    row_type = ROW_PRIO;
    bb_lx = SFX2S(GSptr->clip_path.bb_lx) - 1;
    bb_ly = SFX2S(GSptr->clip_path.bb_ly) - 1;
/*  bb_ux = SFX2S(GSptr->clip_path.bb_ux) - x_maxs + 1;
    bb_uy = SFX2S(GSptr->clip_path.bb_uy) - y_maxs + 1;  */
    bb_ux = SFX2S(GSptr->clip_path.bb_ux) + 1;    /* 4-7-90 SC */
    bb_uy = SFX2S(GSptr->clip_path.bb_uy) + 1;    /* 4-7-90 SC */

#ifdef  DBG
    printf("<bbox> lx: %x  ly: %x  ux: %x  uy: %x\n",
           bb_lx, bb_ly, bb_ux, bb_uy);
    printf("%x <- %lx    %x <- %lx\n",
           r_post_x, lfxm[4], r_post_y, lfxm[5]);
#endif

    isp = 0;            /* jwm, 12/26 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        r_psav_x = r_post_x;
        r_psav_y = r_post_y;

        if (itm_type == ITM_A00D)                                       /*@OPT*/
        {
            r_pabs_y+= r_padv_y;
/*          if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)*/
            if (((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y) || (iy == height)) /* 12-17-90, Jack */
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("A- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        if (itm_type == ITM_0BC0)
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x02;
            else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);
#ifdef  DBG8
            printf("6- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }
        else
        {
            r_pabs_x+= r_padv_x;
            if ((LFX2S(r_pabs_x) - r_post_x) == r_maxs.x)
                ys_index = 0x04;
                else
                ys_index = 0x00;
            r_post_x = LFX2S(r_pabs_x);

            r_pabs_y+= r_padv_y;
            if ((LFX2S(r_pabs_y) - r_post_y) == r_maxs.y)
                ys_index|= 0x08;

            r_post_y = LFX2S(r_pabs_y);
#ifdef  DBG8
            printf("C- %x %ld @%d,%d\n",
                   ys_index, iy, r_psav_x, r_psav_y);
#endif
        }

        /* NOTE: rotated images are not processed properly */
        /* note: to process rotated images, skip clipping checking for
                 rotated images, 5-7-91, Jack */
    if ((itm_type == ITM_A00D) || (itm_type == ITM_0BC0)) { /* 5-7-91, Jack */
        if (LFX2F(r_padv_y) < 0) {      /* added by Jack, 10-16-90 */
            if (row_type == ROW_PRIO) { /* as per setting of negative y */
                if (r_psav_y <= bb_uy /* && (r_psav_s + p_slop_y) > bb_ly */ ){
#ifdef  DBG8
                    printf("- enter clipping region\n");
#endif
                    row_type = ROW_CLIP;
                }
            }
            else
            if (row_type == ROW_CLIP) {
                if (r_psav_y < bb_ly /* && (r_psav_s + p_slop_y) > bb_uy */ ) {
#ifdef  DBG8
                    printf("- leave clipping region\n");
#endif
                    row_type = ROW_POST;
                }
            }                           /* added by Jack, 10-16-90 */
        } else {
            if (row_type == ROW_PRIO) {
                if (r_psav_y >= bb_ly /* && (r_psav_s + p_slop_y) > bb_ly */) {
#ifdef  DBG8
                    printf("+ enter clipping region\n");
#endif
                    row_type = ROW_CLIP;
                }
            }
            else
            if (row_type == ROW_CLIP) {
                if (r_psav_y > bb_uy /* && (r_psav_s + p_slop_y) > bb_uy */ ) {
#ifdef  DBG8
                    printf("+ leave clipping region\n");
#endif
                    row_type = ROW_POST;
                }
            }
        }
    } else                   /* 5-7-91, Jack */
        row_type = ROW_CLIP; /* 5-7-91, Jack */

        if (row_type != ROW_CLIP) {

            for (ix=1; ix<=width; ix++) {

                if (bit_count == 8) {
                    chr_count--;
                    if (chr_count == 0) {
                        /* pop last string on operand stack */
                        POP(1);

                        if (interpreter(&obj_proc)) {
                            ERROR(STACKUNDERFLOW);
                            return;
                        }
                        /*mslin 5/02/91*/
                        CHECK_STRINGTYPE();

                        string = (ubyte FAR *) VALUE_OPERAND(0); /* 07-18-89 */
                        if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                            return;
                        }
                    }

                    /* read next string */
                    string++;                                   /* 07-18-89 */
                    bit_count = 0;
                }

                bit_count+= shift;
            }/* for ix */

        } else {

            row_flag = ROW_FILL;
            xs_point = x_lookup;

            for (ix=1; ix<=width; ix++) {

                if (bit_count == 8) {
                    chr_count--;
                    if (chr_count == 0) {
                        /* pop last string on operand stack */
                        POP(1);

                        if (interpreter(&obj_proc)) {
                            ERROR(STACKUNDERFLOW);
                            return;
                        }
                        /*mslin 5/02/91*/
                        CHECK_STRINGTYPE();

                        string = (ubyte FAR *) VALUE_OPERAND(0);
                        if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                            return;
                        }
                    }

                    /* read next string */
                    data = *string++;
                    bit_count = 0;
                }

                sval = (ubyte) ((data & mask) >> right);        //@WIN
                data = (ubyte) (data << shift);                 //@WIN
                bit_count+= shift;

                /* JUST TURN OFF UNTIL FIXED
                if (bb_ux < (r_psav_x + xs_point->x) ||
                            (r_psav_x + xs_point->x) < bb_lx)
                    continue;
                */

                if (optype == IMAGE || !(sval ^ invert)) {

                    /* create sample node */
                    if (isp >= last_isp_index) {                /* jwm, 12/26 */
/*                    if ((isp = get_node()) == NULLP) [        */

                        end_h = start_h + bb_height;
                        /* calculate image bounding box */
                        band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                                      width, (fix FAR *) bb);
                        /* transfer sample list to page cache */
                        flush_clip_sample_list(optype, gray_res,
                                                       (fix FAR *) bb);
                        start_h = end_h;
                        bb_height = 0;

                        isp = 0;        /* jwm, 12/26 */

/*                        if ((isp = get_node()) == NULLP) {
 *                            ERROR(LIMITCHECK);
 *                            return;
 *                        }
 */

                    }

                    /* calculate up_left corner's position */

                    isp_ptr = &isp_table[isp];
                    isp_ptr->bb_x = r_psav_x + xs_point->x;
                    isp_ptr->bb_y = r_psav_y + xs_point->y;
                    isp_ptr->index = ys_index + xs_point->index;
                    if (optype == IMAGE) {
                        isp_ptr->next = gray_chain[sval].start_seed_sample;
                        gray_chain[sval].start_seed_sample = isp;
                    } else {
                        isp_ptr->next = gray_chain[0].start_seed_sample;
                        gray_chain[0].start_seed_sample = isp;
                    }

                    ++isp;


/*      -jwm, 12/26
 *                    node_table[isp].SAMPLE_BB_LX = r_psav_x + xs_point->x;
 *                    node_table[isp].SAMPLE_BB_LY = r_psav_y + xs_point->y;
 *                    if (optype == IMAGE) {
 *                        node_table[isp].next =
 *                                        gray_chain[sval].start_seed_sample;
 *                        gray_chain[sval].start_seed_sample = isp;
 *                    } else {
 *                        node_table[isp].next = gray_chain[0].start_seed_sample;
 *                        gray_chain[0].start_seed_sample = isp;
 *                    }
 *
 *                    node_table[isp].SEED_INDEX = ys_index + xs_point->index;
 */

#ifdef  DBG9
                    printf("* %x,%x %x/%x\n",
                           r_psav_x + xs_point->x, r_psav_y + xs_point->y,
                           sval, ys_index + xs_point->index);
#endif
                }/* if */

                xs_point++;
            }/* for ix */

        }

        bb_height++;
        /* check if bb_height is reached */
        if (bb_height == max_bb_height || iy == height) {

            end_h = start_h + bb_height - 1;
            if (row_flag == ROW_FILL) {
                /* calculate image bounding box */
                band_boundary((lfix_t FAR *) lfxm, start_h - 1, end_h,
                              width, (fix FAR *) bb);
                /* transfer sample list to page or cache */
                flush_clip_sample_list(optype, gray_res,
                                               (fix FAR *) bb);
                row_flag = ROW_NONE;

                isp = 0;        /* jwm, 12/26 */

            }
            start_h = end_h + 1;
            bb_height = 0;

        }/* if max_bb_height */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of fast_clip_image_process */


/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       slow_clip_image_process
 *
 * CALL:        slow_clip_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
slow_clip_image_process(optype, width, height, shift, invert, obj_proc,
                        gray_res, lfxm)
ufix   optype;                                                  /* @#CSR */
fix    width;
fix32  height;
fix    shift;
bool   invert;                                                  /* @#CSR */
struct object_def obj_proc;
fix    gray_res;
lfix_t FAR  lfxm[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    ufix        gval, pval;
    fix         bit_count, right;
    ufix        chr_count;
    lfix_t      dx_r, dy_r;
    lfix_t      dx_c, dy_c;
    lfix_t      lx[4], ly[4];
    sfix_t      sx[4], sy[4];
    struct polygon_i sample;

    fix         spix, ppix;                                     /* 03-18-89 */
    fix         no_pixels;                                      /* 03-18-89 */
    fix         grayindex;                                      /* 03-18-89 */
    fix         pixmap[256];                                    /* 03-18-89 */

#ifdef  DBGX
    printf("slow_clip_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    dx_r = lfxm[2];
    dy_r = lfxm[3];
    dx_c = lfxm[0];
    dy_c = lfxm[1];

    /* initial matrix parameter */
    lx[0] = lfxm[4];
    lx[1] = lfxm[4] + dx_r;
    ly[0] = lfxm[5];
    ly[1] = lfxm[5] + dy_r;

    /* generate pixel map from gray value */
    no_pixels = CGS_No_Pixels;                                  /* 03-18-89 */
    for (grayindex = 0; grayindex < gray_res; grayindex++) {
        pixmap[grayindex] = CGS_GrayValue(no_pixels,            /* 04-21-89 */
                                          grayindex);
    }

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;
    gval = pval = ppix = 0xFFFF;                                /* 03-18-89 */

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        /* initial sample's position */
        sx[0] = LFX2SFX(lx[0]);
        sx[1] = LFX2SFX(lx[1]);
        lx[2] = lx[1];
        lx[3] = lx[0];
        sy[0] = LFX2SFX(ly[0]);
        sy[1] = LFX2SFX(ly[1]);
        ly[2] = ly[1];
        ly[3] = ly[0];

#ifdef  DBG8
        printf("row: %3d [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n", iy,
               sx[0], sy[0], sx[1], sy[1], sx[2], sy[2], sx[3], sy[3]);
#endif

        for (ix=1; ix<=width; ix++) {

            lx[2]+= dx_c;
            sx[2] = LFX2SFX(lx[2]);
            lx[3]+= dx_c;
            sx[3] = LFX2SFX(lx[3]);
            ly[2]+= dy_c;
            sy[2] = LFX2SFX(ly[2]);
            ly[3]+= dy_c;
            sy[3] = LFX2SFX(ly[3]);

            /* Get endpoints of a sample cell */
            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

#ifdef  DBG8
            printf("value = %x\n", sval);
#endif

            if (optype == IMAGE || !(sval ^ invert)) {

                if (pval == 0xFFFF) goto skip; /* @SC, skip pixmap[-1] at
                                                  the following line, 5-15-90 */
                /* check if repeat pattern no changed */
                if (((ppix = pixmap[pval]) ==                   /* 03-18-89 */
                     (spix = pixmap[sval])) &&                  /* 03-18-89 */
                    (sample.p[3].x == sx[0] && sample.p[3].y == sy[0] &&
                     sample.p[2].x == sx[1] && sample.p[2].y == sy[1])) {
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                } else
                if (ppix == spix &&                             /* 03-18-89 */
                    (sample.p[1].x == sx[0] && sample.p[1].y == sy[0] &&
                     sample.p[2].x == sx[3] && sample.p[2].y == sy[3])) {
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                } else {
                    if (pval != 0xFFFF) {
#ifdef  DBG4
                        printf("pack fill gray: %f\n", gray_map[gval]);
#endif

                        if(gval != 0xFFFF)
                            setgray(F2L(gray_map[gval]));
                        fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                                /* convex_clipper just build up the edge table
                                 * and update the bounding box information, but
                                 * does not perform scan-conversion.
                                 */
                    }
skip:                                           /* @SC, 5-15-90 */
                    /* Calculate gray level of this sample */
                    if (optype == IMAGE && sval != (ubyte)gval) //@WIN
                        gval = sval;
                    pval = sval;
                    spix = ppix;                                /* 03-18-89 */

                    /* Fill this sample cell: create a sample */
                    sample.size = 4;
                    sample.p[0].x = sx[0];
                    sample.p[0].y = sy[0];
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                }

            } else {
                if (pval != 0xFFFF) {
#ifdef  DBG4
                    printf("pack fill gray: %f\n", gray_map[gval]);
#endif

                    if (gval != 0xFFFF)
                        setgray(F2L(gray_map[gval]));
                    fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                        /* convex_clipper just build up the edge table
                         * and update the bounding box information, but
                         * does not perform scan-conversion.
                         */
                    pval = spix = 0xFFFF;                       /* 03-18-89 */
                }
            }/* if */

            sx[0] = sx[3];
            sx[1] = sx[2];
            sy[0] = sy[3];
            sy[1] = sy[2];
        }/* for ix */

        bit_count = 8;

        lx[0] = lx[1];
        lx[1]+= dx_r;
        ly[0] = ly[1];
        ly[1]+= dy_r;
    }/* for iy */

    if (pval != 0xFFFF) {
#ifdef  DBG4
        printf("pack fill gray: %f\n", gray_map[gval]);
#endif

        if (gval != 0xFFFF)
            setgray(F2L(gray_map[gval]));
        fill_a_sample((struct polygon_i FAR *) &sample);       /* @#CVCF */
                /* convex_clipper just build up the edge table
                 * and update the bounding box information, but
                 * does not perform scan-conversion.
                 */
    }

    /* pop the last string in operand stack */
    POP(1);
}/* end of slow_clip_image_process */


/************************************************************************
 *
 * This module is to implement normal image process
 *
 * TITLE:       worst_image_process
 *
 * CALL:        worst_image_process()
 *
 * INTERFACE:
 *
 * CALLS:       transform, setgray, convex_clipper, filler
 *
 *********************************************************************/
static void near
worst_image_process(optype, width, height, shift, invert, obj_proc, inv_matrix)
ufix    optype;
fix     width;
fix32   height;
fix     shift;
bool    invert;
struct  object_def obj_proc;
real32  FAR  inv_matrix[];
{
    fix32       iy;
    fix         ix;
    ubyte      FAR *string, mask, data, sval;
    ufix        gval, pval;
    fix         bit_count, right;
    ufix        chr_count;
    real32      dx_r, dy_r;
    real32      dx_c, dy_c;
    real32      dx_o, dy_o;
    real32      fx[4], fy[4];
    sfix_t      sx[4], sy[4];
    struct polygon_i sample;

#ifdef  DBGX
    printf("worst_image_process......\n");
    printf("optype: %x\n", optype);
    printf("width:  %d\n", width);
    printf("height: %d\n", height);
    printf("shift:  %d\n", shift);
    printf("invert: %x\n", invert);
#endif

    dx_r = inv_matrix[2];
    dy_r = inv_matrix[3];
    dx_c = inv_matrix[0];
    dy_c = inv_matrix[1];

    /* initial matrix parameter */
    dx_o = inv_matrix[4];
    dy_o = inv_matrix[5];

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    string = (ubyte FAR *) VALUE_OPERAND(0);
    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    data = *string++;
    bit_count = 0;

    /* setup sample mask and shift right count */
    switch (shift) {
    case 1: mask = 0x80;
            break;
    case 2: mask = 0xC0;
            break;
    case 4: mask = 0xF0;
            break;
    case 8: mask = 0xFF;
            break;
    }
    right = 8 - shift;
    gval = pval = 0xFFFF;

    /* Loop to fill image */
    for (iy=1; iy<=height; iy++) {

        /* initial sample's position */
        fx[0] = fx[3] = dx_o;
        fx[1] = fx[2] = dx_o + dx_r;
        fy[0] = fy[3] = dy_o;
        fy[1] = fy[2] = dy_o + dy_r;

#ifdef  DBG1
        printf("row: %3d [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n", iy,
               sx[0], sy[0], sx[1], sy[1], sx[2], sy[2], sx[3], sy[3]);
#endif

        for (ix=1; ix<=width; ix++) {

            fx[2]+= dx_c;
            fx[3]+= dx_c;
            fy[2]+= dy_c;
            fy[3]+= dy_c;

            /* Get endpoints of a sample cell */
            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    string = (ubyte FAR *) VALUE_OPERAND(0);
                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                /* read next string */
                data = *string++;
                bit_count = 0;
            }

            sval = (ubyte) ((data & mask) >> right);    //@WIN
            data = (ubyte) (data << shift);             //@WIN
            bit_count+= shift;

            if (optype == IMAGE || !(sval ^ invert)) {
                /* Check if coordinates out of SFX range.
                   Should be solved by page_clipper().
                        Ref. S.C. Chen  @#IMAGE 05-24-88 Y.C.
                 */
                /* fast macro for boundary crossing check
                for (index = 0; index < 4; index++) {
                    if ((x[index] < (real32)PAGE_LEFT)  ||
                        (x[index] > (real32)PAGE_RIGHT) ||
                        (y[index] < (real32)PAGE_TOP)   ||
                        (y[index] > (real32)PAGE_BTM))
                }
                */
                    if (out_page(F2L(fx[0])) || out_page(F2L(fy[0])) ||
                        out_page(F2L(fx[1])) || out_page(F2L(fy[1])) ||
                        out_page(F2L(fx[2])) || out_page(F2L(fy[2])) ||
                        out_page(F2L(fx[3])) || out_page(F2L(fy[3])))
                        goto out_of_range;

                sx[0] = F2SFX(fx[0]);
                sy[0] = F2SFX(fy[0]);
                sx[1] = F2SFX(fx[1]);
                sy[1] = F2SFX(fy[1]);
                sx[2] = F2SFX(fx[2]);
                sy[2] = F2SFX(fy[2]);
                sx[3] = F2SFX(fx[3]);
                sy[3] = F2SFX(fy[3]);

                if (pval == sval &&
                    (sample.p[3].x == sx[0] && sample.p[3].y == sy[0] &&
                     sample.p[2].x == sx[1] && sample.p[2].y == sy[1])) {
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                } else
                if (pval == sval &&
                    (sample.p[1].x == sx[0] && sample.p[1].y == sy[0] &&
                     sample.p[2].x == sx[3] && sample.p[2].y == sy[3])) {
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                } else {
                    if (pval != 0xFFFF) {
                        if(gval != 0xFFFF)
                            setgray(F2L(gray_map[gval]));
                        fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                                /* convex_clipper just build up the edge table
                                 * and update the bounding box information, but
                                 * does not perform scan-conversion.
                                 */
                    }

                    /* Calculate gray level of this sample */
                    if (optype == IMAGE && sval != (ubyte)gval) //@WIN
                        gval = sval;
                    pval = sval;

                    /* Fill this sample cell: create a sample */
                    sample.size = 4;
                    sample.p[0].x = sx[0];
                    sample.p[0].y = sy[0];
                    sample.p[1].x = sx[1];
                    sample.p[1].y = sy[1];
                    sample.p[2].x = sx[2];
                    sample.p[2].y = sy[2];
                    sample.p[3].x = sx[3];
                    sample.p[3].y = sy[3];
                }

            } else {

out_of_range:
                if (pval != 0xFFFF) {
                    if (gval != 0xFFFF)
                        setgray(F2L(gray_map[gval]));
                    fill_a_sample((struct polygon_i FAR *) &sample);
                                                                /* @#CVCF */
                        /* convex_clipper just build up the edge table
                         * and update the bounding box information, but
                         * does not perform scan-conversion.
                         */
                    pval = 0xFFFF;
                }
            }/* if */

            fx[0] = fx[3];
            fx[1] = fx[2];
            fy[0] = fy[3];
            fy[1] = fy[2];
        }/* for ix */

        bit_count = 8;

        dx_o+= dx_r;
        dy_o+= dy_r;
    }/* for iy */

    if (pval != 0xFFFF) {
        if (gval != 0xFFFF)
            setgray(F2L(gray_map[gval]));
        fill_a_sample((struct polygon_i FAR *) &sample);       /* @#CVCF */
                /* convex_clipper just build up the edge table
                 * and update the bounding box information, but
                 * does not perform scan-conversion.
                 */
    }

    /* pop the last string in operand stack */
    POP(1);
}/* end of worst_image_process */


/***********************************************************************
 * Do nothing, exhaust image data only
 *
 * TITLE:       exhaust_image_data
 *
 * CALL:        exhaust_image_data()
 *
 * PARAMETERS:  height   : height of image
 *              width    : width of image
 *              shift    : bits/sample
 *              tot_char : total character of image
 *              obj_proc : input procedure
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
exhaust_image_data(width, height, shift, obj_proc)
fix    width;
fix32  height;
fix    shift;
struct object_def obj_proc;
{
    fix32  iy;
    fix    ix;
    fix    bit_count;
    ufix   chr_count;

#ifdef  DBGX
    printf("exhaust_image_data......\n");
#endif

    /* read first string */
    if (interpreter(&obj_proc)) {
        ERROR(STACKUNDERFLOW);
        return;
    }
    /*mslin 5/02/91*/
    CHECK_STRINGTYPE();

    if ((chr_count = LENGTH_OPERAND(0)) == (ufix) 0) {
        return;
    }

    bit_count = 0;

    for (iy=1; iy<=height; iy++) {

#ifdef  DBG1
        printf("process row: %d\n", iy);
#endif

        for (ix=1; ix<=width; ix++) {

            if (bit_count == 8) {
                chr_count--;
                if (chr_count == 0) {
                    /* pop last string on operand stack */
                    POP(1);

                    if (interpreter(&obj_proc)) {
                        ERROR(STACKUNDERFLOW);
                        return;
                    }
                    /*mslin 5/02/91*/
                    CHECK_STRINGTYPE();

                    if ((chr_count = LENGTH_OPERAND(0)) == (ufix)0) {
                        return;
                    }
                }

                bit_count = 0;
            }

            bit_count+= shift;
        }/* for ix */

        bit_count = 8;
    }/* for iy */

    /* pop the last string in operand stack */
    POP(1);
}/* end of exhaust_image_process */


/***********************************************************************
 *
 * TITLE:       image_matrix
 *
 * CALL:        image_matrix
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
image_matrix(matrix, inv_matrix, height, width, image_bb)
real32 FAR  matrix[];
real32 FAR  inv_matrix[];
fix32       height;
fix         width;
real32 FAR  image_bb[];
{
    /*  combine image_matrix & image_boundary                      01-26-89 */

    real32 FAR *im, x[4], y[4];
    fix     index;

#ifdef  DBG1
    printf("CTM:  |%f %f %f|\n     |%f %f %f|\n",
           GSptr->ctm[0], GSptr->ctm[1], GSptr->ctm[2],
           GSptr->ctm[3], GSptr->ctm[4], GSptr->ctm[5]);
    printf("ITM': |%f %f %f|\n     |%f %f %f|\n",
           matrix[0], matrix[1], matrix[2],
           matrix[3], matrix[4], matrix[5]);
#endif

    im = inverse_mat(matrix);
    for (index = 0; index < MATRIX_LEN; index++) {
        inv_matrix[index] = im[index];
    }

    im = concat_mat(inv_matrix, GSptr->ctm);
    for (index = 0; index < MATRIX_LEN; index++) {
        inv_matrix[index] = im[index];
    }

#ifdef  DBG1
    printf("ITM:  |%f %f %f|\n     |%f %f %f|\n",
           inv_matrix[0], inv_matrix[1], inv_matrix[2],
           inv_matrix[3], inv_matrix[4], inv_matrix[5]);
#endif

    /* special adjustment of Tx & Ty of ITM  01-12-89 */
    inv_matrix[4]+= (real32) 0.0001;    /* Tx */
    inv_matrix[5]+= (real32) 0.0001;    /* Ty */

    /* calculate bounding box of image/imagemask */
    x[0] =                                                  inv_matrix[4];
    y[0] =                                                  inv_matrix[5];
    x[1] =                          width * inv_matrix[0] + inv_matrix[4];
    y[1] =                          width * inv_matrix[1] + inv_matrix[5];
    x[2] = height * inv_matrix[2] + width * inv_matrix[0] + inv_matrix[4];
    y[2] = height * inv_matrix[3] + width * inv_matrix[1] + inv_matrix[5];
    x[3] = height * inv_matrix[2]                         + inv_matrix[4];
    y[3] = height * inv_matrix[3]                         + inv_matrix[5];

    image_bb[0] = image_bb[1] = x[0];
    image_bb[2] = image_bb[3] = y[0];
    for (index = 1; index <= 3; index++) {
        if (x[index] < image_bb[0]) image_bb[0] = x[index];
        if (x[index] > image_bb[1]) image_bb[1] = x[index];
        if (y[index] < image_bb[2]) image_bb[2] = y[index];
        if (y[index] > image_bb[3]) image_bb[3] = y[index];
    }

#ifdef  DBG
    printf("image_bb: X: %d - %d    Y %d - %d\n",
           image_bb[0], image_bb[1], image_bb[2], image_bb[3]);
#endif
} /* end of image_matrix() */


/***********************************************************************
 * Given a path, this module check its clip status
 *
 * TITLE:       check_clip_status
 *
 * CALL:        check_clip_status(im_path)
 *
 * PARAMETERS:  im_path : input path to be clipped
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      clip_status:
 *                      OUT_CLIPPATH    : out of clippath
 *                      CLIP            : take place clip
 *                      INSIDE_CLIPPATH : inside clippath
 **********************************************************************/
static fix near
check_clip_status(image_bb)
real32 FAR  image_bb[];
{
    ET_IDX  itpzd;
    struct nd_hdr FAR *tpzd;
    /* @RESO_UPGR */
    sfix_t     cp_lx, cp_ly, cp_ux, cp_uy; /* bbox of clippath */
    sfix_t     im_lx, im_ly, im_ux, im_uy; /* bbox of image */

    /* decide clip status and check if out of clip path */
    im_lx = F2SFX(image_bb[0]);
    im_ux = F2SFX(image_bb[1]);
    im_ly = F2SFX(image_bb[2]);
    im_uy = F2SFX(image_bb[3]);


#ifdef  DBG2
    printf("image box: %ld %ld %ld %ld\n", im_lx, im_ux, im_ly, im_uy);
#endif

    /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of current clip */
    cp_lx = GSptr->clip_path.bb_lx;
    cp_ly = GSptr->clip_path.bb_ly;
    cp_ux = GSptr->clip_path.bb_ux;
    cp_uy = GSptr->clip_path.bb_uy;

#ifdef  DBG2
    printf("GSptr: %lx -- %x\n", GSptr, current_gs_level);
    printf("clip  box: %ld %ld %ld %ld\n", cp_lx, cp_ux, cp_ly, cp_uy);
#endif

    /* check if totally outside clip polygon */
    if (im_uy < cp_ly || im_ly > cp_uy ||
        im_ux < cp_lx || im_lx > cp_ux) {
#ifdef  DBG2
        printf("check_clip_status -- OUTSIDE_CLIPPATH\n");
#endif
        return(OUT_CLIPPATH);
    }

    /* Check if im_path totally inside the rectangle current clip */
    if (GSptr->clip_path.single_rect) {

        if (cp_ly < im_ly && im_uy < cp_uy &&
            cp_lx < im_lx && im_ux < cp_ux) {

#ifdef  DBG2
            printf("check_clip_status -- INSIDE_CLIPPATH\n");
#endif
            return(INSIDE_CLIPPATH);
        } else {
#ifdef  DBG2
            printf("check_clip_status -- CLIP\n");
#endif
            return(CLIP);
        }
    }

    for (itpzd = GSptr->clip_path.head; itpzd != NULLP;
         itpzd = tpzd->next) {

        tpzd = &node_table[itpzd];

        cp_ly = tpzd->CP_TOPY;
        cp_uy = tpzd->CP_BTMY;

        if (im_uy < cp_ly || im_ly > cp_uy)
            continue;

        /* check if outside a trapezoid of clip_path */
        cp_lx = (tpzd->CP_TOPXL < tpzd->CP_BTMXL)
               ? tpzd->CP_TOPXL : tpzd->CP_BTMXL;
        cp_ux = (tpzd->CP_TOPXR > tpzd->CP_BTMXR)
               ? tpzd->CP_TOPXR : tpzd->CP_BTMXR;

        if (im_ux < cp_lx || im_lx > cp_ux)
            continue;

        /* check if inside a trapezoid of clip_path */
        cp_lx = (tpzd->CP_TOPXL > tpzd->CP_BTMXL)
               ? tpzd->CP_TOPXL : tpzd->CP_BTMXL;
        cp_ux = (tpzd->CP_TOPXR < tpzd->CP_BTMXR)
               ? tpzd->CP_TOPXR : tpzd->CP_BTMXR;

        /* Check if im_path totally inside the rectangle current clip */
        if (cp_ly < im_ly && im_uy < cp_uy &&
            cp_lx < im_lx && im_ux < cp_ux) {

#ifdef  DBG2
            printf("check_clip_status -- INSIDE_CLIPPATH\n");
#endif
            return(INSIDE_CLIPPATH);
        } else {
#ifdef  DBG2
            printf("check_clip_status -- CLIP\n");
#endif
            return(CLIP);
        }
    } /* for */

#ifdef  DBG2
    printf("check_clip_status -- OUTSIDE_CLIPPATH\n");
#endif
    return(OUT_CLIPPATH);
} /* check_clip_status */


/***********************************************************************
 * Fill a sample to page or cache
 *
 * TITLE:       fill_a_sample
 *
 * CALL:        fill_a_sample()
 *
 * PARAMETERS:  sample
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       convex_clipper
 *
 * RETURN:      TRUE  : successful
 *              FALSE : node table is NULL
 *
 *********************************************************************/
static bool near
fill_a_sample(sample)                           /* @#IMAGE 04-27-88  Y.C. */
struct polygon_i FAR  *sample;
{
    sfix_t   x, y;

    /* clockwise convertion before polygon reduction */
    /* clockwise: ((x1 - x0) * (y2 - y1) - (y1 - y0) * (x2 - x1)) >= 0 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
    if ((((fix32) (sample->p[1].x - sample->p[0].x)) *
         ((fix32) (sample->p[2].y - sample->p[1].y)) -
         ((fix32) (sample->p[1].y - sample->p[0].y)) *
         ((fix32) (sample->p[2].x - sample->p[1].x))) < 0) {
#elif  FORMAT_16_16
    long dest1[2], dest2[2], tmp[2];

    LongFixsMul((sample->p[1].x - sample->p[0].x),
                (sample->p[2].y - sample->p[1].y), dest1);
    LongFixsMul((sample->p[1].y - sample->p[0].y),
                (sample->p[2].x - sample->p[1].x), dest2);
    LongFixsSub(dest1, dest2, tmp);
    if (tmp[0] < 0) {
#elif  FORMAT_28_4
    long dest1[2], dest2[2], tmp[2];

    LongFixsMul((sample->p[1].x - sample->p[0].x),
                (sample->p[2].y - sample->p[1].y), dest1);
    LongFixsMul((sample->p[1].y - sample->p[0].y),
                (sample->p[2].x - sample->p[1].x), dest2);
    LongFixsSub(dest1, dest2, tmp);
    if (tmp[0] < 0) {
#endif
        x = sample->p[1].x;
        sample->p[1].x = sample->p[3].x;
        sample->p[3].x = x;
        y = sample->p[1].y;
        sample->p[1].y = sample->p[3].y;
        sample->p[3].y = y;
    }

#ifdef  DBG4
    printf("*sample*  [%x,%x] [%x,%x] [%x,%x] [%x,%x]\n",
           sample->p[0].x, sample->p[0].y,
           sample->p[1].x, sample->p[1].y,
           sample->p[2].x, sample->p[2].y,
           sample->p[3].x, sample->p[3].y);
#endif

    return(convex_clipper(sample, FALSE));                          /* @#CVCF */
        /* convex_clipper just build up the edge table and update the
         * bounding box information, but does not perform scan-conversion.
         */
} /* end of fill_a_sample() */

#ifdef DJC // this is the original
/***********************************************************************
 *
 * TITLE:       image_gwcm_space
 *
 * CALL:        image_gwcm_space
 *
 * RETURN:      none
 *
 *********************************************************************/
static fix near
image_gwcm_space(gwcm_size, lfxm, width)
fix32       gwcm_size;
lfix_t FAR  lfxm[];
fix         width;
{
    fix    image_width;

    if (itm_type == ITM_A00D) {

        /* adjust image width to word boundary */
        image_width = (lfxm[0] >= 0)
                    ? (BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] - HALF_LFX)) -
                       BM_ALIGN(LFX2I(lfxm[4] + HALF_LFX)))
/*                  : (BM_ALIGN(LFX2I(lfxm[4] - HALF_LFX)) -
                       BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] + HALF_LFX)));*/                    : (BM_ALIGN(LFX2I(lfxm[4])) -
                       BM_BOUND(LFX2I_T(lfxm[0] * width + lfxm[4] - HALF_LFX)));/* 12-13-90, Jack */

#ifdef  DBG1
        printf("gwbcmb: %d <- %lx & %lx\n", image_width, lfxm[0], lfxm[4]);
        printf("gwbcmb: %lx <- %d\n", gwcm_size,
               (fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));
#endif

        if (!image_width)               /* jwm, 12/11 */
            return (0);                 /* ??? -jwm */

        return((fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));

    } else {

        lfix_t  x[4], y[4];
        lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
        fix     max_bb, inc_bb;
        fix     no_row, no_col;
        fix     index;

        /* some binary search approach is applied */
        for (max_bb = inc_bb = 16; ; max_bb+= inc_bb) {

            x[1] =                    width * lfxm[0];
            y[1] =                    width * lfxm[1];
            x[2] = max_bb * lfxm[2] + width * lfxm[0];
            y[2] = max_bb * lfxm[3] + width * lfxm[1];
            x[3] = max_bb * lfxm[2];
            y[3] = max_bb * lfxm[3];

#ifdef  DBG1
            printf("%x+%x: [%lx, %lx] [%lx, %lx] [%lx, %lx]\n",
                   max_bb, inc_bb, x[1], y[1], x[2], y[2], x[3], y[3]);
#endif

            bb_lx = bb_ux = 0;
            bb_ly = bb_uy = 0;
            for (index = 1; index <= 3; index++) {
                if (x[index] < bb_lx) bb_lx = x[index];
                if (x[index] > bb_ux) bb_ux = x[index];
                if (y[index] < bb_ly) bb_ly = y[index];
                if (y[index] > bb_uy) bb_uy = y[index];
            }

            /* calculate the row and column in pixels */
            no_row = LFX2S(bb_uy + HALF_LFX) - LFX2S(bb_ly - HALF_LFX);
            no_col = BM_ALIGN(LFX2S(bb_ux + HALF_LFX) -
                              LFX2S(bb_lx - HALF_LFX)) + BM_PIXEL_WORD * 2;

#ifdef  DBG1
            printf("%x = %lx / (%x * %x)\n",
                   (fix) (gwcm_size * 8 / ((fix32) no_row * no_col)),
                   gwcm_size, no_row, no_col);
#endif

            /* check if size over space of GBW or CMB or not */
            if ((gwcm_size * 8 / ((fix32) no_row * no_col)) < max_bb) {
                max_bb-= inc_bb;
                if (inc_bb == 1) {
#ifdef  DBG1
                    printf("max_bb: %d\n", max_bb);
#endif

                    return(max_bb);
                }

                inc_bb = inc_bb / 2;
            }
        }

    }
} /* end of image_cmb_space() */

#endif


/***********************************************************************
 *
 * TITLE:       image_gwcm_space
 *
 * CALL:        image_gwcm_space
 *
 * RETURN:      none
 *
 *********************************************************************/
static fix near
image_gwcm_space(gwcm_size, lfxm, width)
fix32       gwcm_size;
lfix_t FAR  lfxm[];
fix         width;
{
    fix    image_width;

    if (itm_type == ITM_A00D) {
//DJC begin , this was broken out to solve calculation errors in original!!
        if (lfxm[0] >= 0 ) {
           fix32 temp_val;
           fix32 temp_val2;

           temp_val = lfxm[0] * width + lfxm[4] - HALF_LFX;
           temp_val = LFX2I(temp_val);
           temp_val = BM_BOUND(temp_val);

           temp_val2 = lfxm[4] + HALF_LFX;
           temp_val2 = LFX2I(temp_val2);
           temp_val2 = BM_ALIGN(temp_val2);
           temp_val -= temp_val2;
           image_width = temp_val;


        } else {
           fix32 temp_val;
           fix32 temp_val2;

           temp_val =  lfxm[4];
           temp_val =  LFX2I(temp_val);
           temp_val =  BM_ALIGN(temp_val);

           temp_val2 = lfxm[0] * width + lfxm[4] - HALF_LFX;
           temp_val2 = LFX2I_T( temp_val2);
           temp_val2 = BM_BOUND( temp_val2);

           image_width = temp_val - temp_val2;

        }
//DJC end

#ifdef DJC
        /* adjust image width to word boundary */
        image_width = (lfxm[0] >= 0)
                    ? (BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] - HALF_LFX)) -
                       BM_ALIGN(LFX2I(lfxm[4] + HALF_LFX)))
/*                  : (BM_ALIGN(LFX2I(lfxm[4] - HALF_LFX)) -
                       BM_BOUND(LFX2I(lfxm[0] * width + lfxm[4] + HALF_LFX)));*/                    : (BM_ALIGN(LFX2I(lfxm[4])) -
                       BM_BOUND(LFX2I_T(lfxm[0] * width + lfxm[4] - HALF_LFX)));/* 12-13-90, Jack */
#endif



#ifdef  DBG1
        printf("gwbcmb: %d <- %lx & %lx\n", image_width, lfxm[0], lfxm[4]);
        printf("gwbcmb: %lx <- %d\n", gwcm_size,
               (fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));
#endif

        if (!image_width)               /* jwm, 12/11 */
            return (0);                 /* ??? -jwm */

        return((fix) (gwcm_size * 8 / ((fix32) y_maxs * image_width)));

    } else {

        lfix_t  x[4], y[4];
        lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
        fix     max_bb, inc_bb;
        fix     no_row, no_col;
        fix     index;

        /* some binary search approach is applied */
        for (max_bb = inc_bb = 16; ; max_bb+= inc_bb) {

            x[1] =                    width * lfxm[0];
            y[1] =                    width * lfxm[1];
            x[2] = max_bb * lfxm[2] + width * lfxm[0];
            y[2] = max_bb * lfxm[3] + width * lfxm[1];
            x[3] = max_bb * lfxm[2];
            y[3] = max_bb * lfxm[3];

#ifdef  DBG1
            printf("%x+%x: [%lx, %lx] [%lx, %lx] [%lx, %lx]\n",
                   max_bb, inc_bb, x[1], y[1], x[2], y[2], x[3], y[3]);
#endif

            bb_lx = bb_ux = 0;
            bb_ly = bb_uy = 0;
            for (index = 1; index <= 3; index++) {
                if (x[index] < bb_lx) bb_lx = x[index];
                if (x[index] > bb_ux) bb_ux = x[index];
                if (y[index] < bb_ly) bb_ly = y[index];
                if (y[index] > bb_uy) bb_uy = y[index];
            }

            /* calculate the row and column in pixels */
            no_row = LFX2S(bb_uy + HALF_LFX) - LFX2S(bb_ly - HALF_LFX);
            no_col = BM_ALIGN(LFX2S(bb_ux + HALF_LFX) -
                              LFX2S(bb_lx - HALF_LFX)) + BM_PIXEL_WORD * 2;

#ifdef  DBG1
            printf("%x = %lx / (%x * %x)\n",
                   (fix) (gwcm_size * 8 / ((fix32) no_row * no_col)),
                   gwcm_size, no_row, no_col);
#endif

            /* check if size over space of GBW or CMB or not */
            if ((gwcm_size * 8 / ((fix32) no_row * no_col)) < max_bb) {
                max_bb-= inc_bb;
                if (inc_bb == 1) {
#ifdef  DBG1
                    printf("max_bb: %d\n", max_bb);
#endif

                    return(max_bb);
                }

                inc_bb = inc_bb / 2;
            }
        }

    }
} /* end of image_cmb_space() */


















/***********************************************************************
 * Give start_h and end_h this module calculate the band's boundary(fix)
 *
 * TITLE:       band_boundary
 *
 * CALL:        band_boundary()
 *
 * PARAMETERS:  lfxm       : coordinate parameter(fix32 fix)
 *              start_h    : start height
 *              end_h      : end height
 *              width      : width of image
 *              bb         : image boundary(fix)
 *
 * INTERFACE:   op_image, imagemask_shape
 *
 * CALLS:       sample_boundary
 *
 * RETURN:      none
 *
 *********************************************************************/
static void near
band_boundary(lfxm, start_h, end_h, width, bb)
lfix_t FAR  lfxm[];
fix32  start_h;
fix32  end_h;
fix    width;
fix    FAR  bb[];
{
    lfix_t  x[4], y[4];
    lfix_t  bb_lx, bb_ux, bb_ly, bb_uy;
    fix     index;

#ifdef  DBG3
    printf("BAND: %ld %ld %d\n", start_h, end_h, width);
#endif

    x[0] = start_h * lfxm[2]                   + lfxm[4];
    y[0] = start_h * lfxm[3]                   + lfxm[5];
    x[1] = start_h * lfxm[2] + width * lfxm[0] + lfxm[4];
    y[1] = start_h * lfxm[3] + width * lfxm[1] + lfxm[5];
    x[2] = end_h   * lfxm[2] + width * lfxm[0] + lfxm[4];
    y[2] = end_h   * lfxm[3] + width * lfxm[1] + lfxm[5];
    x[3] = end_h   * lfxm[2]                   + lfxm[4];
    y[3] = end_h   * lfxm[3]                   + lfxm[5];

    bb_lx = bb_ux = x[0];
    bb_ly = bb_uy = y[0];
    for (index = 1; index <= 3; index++) {
        if (x[index] < bb_lx) bb_lx = x[index];
        if (x[index] > bb_ux) bb_ux = x[index];
        if (y[index] < bb_ly) bb_ly = y[index];
        if (y[index] > bb_uy) bb_uy = y[index];
    }

    bb[0] = BM_ALIGN(LFX2S(bb_lx - HALF_LFX));                  /* 01-26-89 */
    bb[1] = BM_BOUND(LFX2S(bb_ux + HALF_LFX));                  /* 01-26-89 */
    bb[2] = LFX2S(bb_ly - HALF_LFX);                            /* 01-26-89 */
    bb[3] = LFX2S(bb_uy + HALF_LFX);                            /* 01-26-89 */

} /* end of band_boundary() */


/* .................... End of image.c .................... */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\pfill.h ===
/* Pattern Mapping */
#ifdef DJC //Fix from history.log UPD0027
const
ufix16 pf_cell[] = {
    /* 00 - 0f */
    0xffff, 0xfffc, 0xfff3, 0xfff0,
    0xffcf, 0xffcc, 0xffc3, 0xffc0,
    0xff3f, 0xff3c, 0xff33, 0xff30,
    0xff0f, 0xff0c, 0xff03, 0xff00,
    /* 10 - 1f */
    0xfcff, 0xfcfc, 0xfcf3, 0xfcf0,
    0xfccf, 0xfccc, 0xfcc3, 0xfcc0,
    0xfc3f, 0xfc3c, 0xfc33, 0xfc30,
    0xfc0f, 0xfc0c, 0xfc03, 0xfc00,
    /* 20 - 2f */
    0xf3ff, 0xf3fc, 0xf3f3, 0xf3f0,
    0xf3cf, 0xf3cc, 0xf3c3, 0xf3c0,
    0xf33f, 0xf33c, 0xf333, 0xf330,
    0xf30f, 0xf30c, 0xf303, 0xf300,
    /* 30 - 3f */
    0xf0ff, 0xf0fc, 0xf0f3, 0xf0f0,
    0xf0cf, 0xf0cc, 0xf0c3, 0xf0c0,
    0xf03f, 0xf03c, 0xf033, 0xf030,
    0xf00f, 0xf00c, 0xf003, 0xf000,
    /* 40 - 4f */
    0xcfff, 0xcffc, 0xcff3, 0xcff0,
    0xcfcf, 0xcfcc, 0xcfc3, 0xcfc0,
    0xcf3f, 0xcf3c, 0xcf33, 0xcf30,
    0xcf0f, 0xcf0c, 0xcf03, 0xcf00,
    /* 50 - 5f */
    0xccff, 0xccfc, 0xccf3, 0xccf0,
    0xcccf, 0xcccc, 0xccc3, 0xccc0,
    0xcc3f, 0xcc3c, 0xcc33, 0xcc30,
    0xcc0f, 0xcc0c, 0xcc03, 0xcc00,
    /* 60 - 6f */
    0xc3ff, 0xc3fc, 0xc3f3, 0xc3f0,
    0xc3cf, 0xc3cc, 0xc3c3, 0xc3c0,
    0xc33f, 0xc33c, 0xc333, 0xc330,
    0xc30f, 0xc30c, 0xc303, 0xc300,
    /* 70 - 7f */
    0xc0ff, 0xc0fc, 0xc0f3, 0xc0f0,
    0xc0cf, 0xc0cc, 0xc0c3, 0xc0c0,
    0xc03f, 0xc03c, 0xc033, 0xc030,
    0xc00f, 0xc00c, 0xc003, 0xc000,
    /* 80 - 8f */
    0x3fff, 0x3ffc, 0x3ff3, 0x3ff0,
    0x3fcf, 0x3fcc, 0x3fc3, 0x3fc0,
    0x3f3f, 0x3f3c, 0x3f33, 0x3f30,
    0x3f0f, 0x3f0c, 0x3f03, 0x3f00,
    /* 90 - 9f */
    0x3cff, 0x3cfc, 0x3cf3, 0x3cf0,
    0x3ccf, 0x3ccc, 0x3cc3, 0x3cc0,
    0x3c3f, 0x3c3c, 0x3c33, 0x3c30,
    0x3c0f, 0x3c0c, 0x3c03, 0x3c00,
    /* a0 - af */
    0x33ff, 0x33fc, 0x33f3, 0x33f0,
    0x33cf, 0x33cc, 0x33c3, 0x33c0,
    0x333f, 0x333c, 0x3333, 0x3330,
    0x330f, 0x330c, 0x3303, 0x3300,
    /* b0 - bf */
    0x30ff, 0x30fc, 0x30f3, 0x30f0,
    0x30cf, 0x30cc, 0x30c3, 0x30c0,
    0x303f, 0x303c, 0x3033, 0x3030,
    0x300f, 0x300c, 0x3003, 0x3000,
    /* c0 - cf */
    0x0fff, 0x0ffc, 0x0ff3, 0x0ff0,
    0x0fcf, 0x0fcc, 0x0fc3, 0x0fc0,
    0x0f3f, 0x0f3c, 0x0f33, 0x0f30,
    0x0f0f, 0x0f0c, 0x0f03, 0x0f00,
    /* d0 - df */
    0x0cff, 0x0cfc, 0x0cf3, 0x0cf0,
    0x0ccf, 0x0ccc, 0x0cc3, 0x0cc0,
    0x0c3f, 0x0c3c, 0x0c33, 0x0c30,
    0x0c0f, 0x0c0c, 0x0c03, 0x0c00,
    /* e0 - ef */
    0x03ff, 0x03fc, 0x03f3, 0x03f0,
    0x03cf, 0x03cc, 0x03c3, 0x03c0,
    0x033f, 0x033c, 0x0333, 0x0330,
    0x030f, 0x030c, 0x0303, 0x0300,
    /* f0 - ff */
    0x00ff, 0x00fc, 0x00f3, 0x00f0,
    0x00cf, 0x00cc, 0x00c3, 0x00c0,
    0x003f, 0x003c, 0x0033, 0x0030,
    0x000f, 0x000c, 0x0003, 0x0000,
};
#endif

ufix32  PF_BASE[PF_BSIZE];      /* initial ?? */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\halftone.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
        Modification history: Please refer to HALFTONE.C

        01-16-89        modify conversion of grayvalue to pixels; compensate
                        all calculation errors and adjust rounding method
        02-01-89        add new type of pixel DONE_INDEX
        04-21-89        approaching compatibility of gray to V 47.
        07-26-90        Jack Liaw, update for grayscale
*/


/*      Function Declaration Section                                    */


#define MAXREALSIZE      256                                    /* 04-07-88 */


#define MAXPATTWORD   (BM_WORDS(MAXPATTSIZE))                                   /* 11-24-88 */
#define MAXCELLWORD   (BM_WORDS(MAXCELLSIZE))                                   /* 11-24-88 */

#define NO_BEST_FIT_CASE  -1L


/*      CGS Group : Current Graphics State Macros                       */


#define Frequency      (GSptr->halftone_screen.freq)
#define Angle          (GSptr->halftone_screen.angle)

#define GrayScale      (GRAYSCALE)                                              /* 11-24-88 */
#define GrayEntry      (GRAYSCALE / MAXGRAYVALUE)               /* 04-21-89 */

#define CGS_GrayColor  (GSptr->color.gray)                      /* 02-03-88 */
#define CGS_GrayIndex  ((fix16) (GSptr->color.gray * GRAYUNIT + 0.001)) /* 11-24-88 */

/*  old gray to white pixels transformation                     (* 04-21-89 *)
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex] + 1))
#define CGS_GrayRound  (GrayScale / 18)                         (* 01-16-89 *)
#define CGS_GrayValue(no_pixels, grayindex)                                    \
                       ((fix) ((no_pixels * CGS_GrayLevel + CGS_GrayRound)     \
                               / (fix32) GrayScale))
*/

/*  new gray to white pixels transformation                     (* 04-21-89 *)
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex] + 1))
#define CGS_GrayRound  (GrayScale / MAXGRAYVALUE / 2)           (* 04-21-89 *)
#define CGS_GrayValue(no_pixels, grayindex)                     (* 04-21-89 *) \
                       ((fix) (no_pixels >= MAXGRAYVALUE)                      \
                              ? (((CGS_GrayLevel + CGS_GrayRound) / GrayEntry) \
                                 * no_pixels / MAXGRAYVALUE)                   \
                              : (((CGS_GrayLevel + CGS_GrayRound))             \
                                 * no_pixels / GrayScale))
*/

/*  new gray to white pixels transformation  */                 /* 01-25-90 */
#ifdef  LINT_ARGS
fix     FromGrayToPixel(fix, fix);
#else
fix     FromGrayToPixel();
#endif
#define CGS_GrayLevel  ((fix32) (gray_table[GSptr->color.adj_gray]             \
                                       .val[grayindex]))
#define CGS_GrayRound  (GrayScale / MAXGRAYVALUE / 2)           /* 01-25-90 */
#define CGS_GrayValue(no_pixels, grayindex)                     /* 01-25-90 */ \
        (fix) FromGrayToPixel((fix) no_pixels, (fix) grayindex)

#define CGS_AllocFlag  (GSptr->halftone_screen.chg_flag)        /* change/allocation flag       */
#define CGS_MajorFact  (GSptr->halftone_screen.majorfact)       /* major factor of halftone     */
#define CGS_MinorFact  (GSptr->halftone_screen.minorfact)       /* major factor of halftone     */
#define CGS_Size_Fact  (GSptr->halftone_screen.size_fact)       /* size factor of halftone      */
#define CGS_Cell_Fact  (GSptr->halftone_screen.cell_fact)       /* cell factor of halftone      */
#define CGS_ScaleFact  (GSptr->halftone_screen.scalefact)       /* scale factor of halftone     */
#define CGS_Patt_Size  (GSptr->halftone_screen.patt_size)       /* size of repeat pattern       */
#define CGS_Cell_Size  (GSptr->halftone_screen.cell_size)       /* size of halftone cell        */
#define CGS_No_Pixels  (GSptr->halftone_screen.no_pixels)       /* number of halftone pixels    */
#define CGS_SpotIndex  (GSptr->halftone_screen.spotindex)       /* spot order index             */
#define CGS_SpotOrder  (&spot_table[CGS_SpotIndex])             /* spot order entry             */
#define CGS_SpotUsage  (spot_usage)                             /* spot order usage             */

#define BinaryInitial  ((fix16) 0x8000)                         /* 09-12-88 */
#define CGS_HT_Binary  (GSptr->halftone_screen.ht_binary)       /* 02-03-88  for binary pattern */
#define CGS_BG_Pixels  (GSptr->halftone_screen.bg_pixels)       /* 02-03-88  for binary pattern */
#define CGS_Back_Gray  (GSptr->halftone_screen.back_gray)       /* 02-03-88  for binary pattern */
#define CGS_FG_Pixels  (GSptr->halftone_screen.fg_pixels)       /* 02-03-88  for binary pattern */
#define CGS_Fore_Gray  (GSptr->halftone_screen.fore_gray)       /* 02-03-88  for binary pattern */
#define CGS_No_Whites  (GSptr->halftone_screen.no_whites)       /* 02-03-88  for binary pattern */


#define CORD_SCALE     (1 << 10)                /* scale factor of coordinate   */
#define SPOT_SCALE     (1 << 14)                /* scale factor of spot value   */
#define SPOT_RANGE    ((1 << 14) * 2)           /* range factor of spot value   */
#define SPOT_ERROR     (1 <<  4)                /* error factor of spot value   */

#define LOWERBOUND     (-SPOT_SCALE+4)          /* lowerbound of cellspace 10-21-87 */
#define UPPERBOUND     ( SPOT_SCALE-4)          /* upperbound of cellspace 10-21-87 */

#define EPSILON        (   4)                   /* epsilon for cell range  10-30-87 */

#define LOWERRANGE     (-SPOT_SCALE-EPSILON)    /* lowerlimit of spotvalue 10-30-87 */
#define UPPERRANGE     ( SPOT_SCALE+EPSILON)    /* upperlimit of spotvalue 10-30-87 */


struct  angle_entry
{
    real32              alpha;          /* alpha angle                  */
    real32              cos;            /* cos(alpha)                   */
    real32              sin;            /* sin(alpha)                   */
    fix16               major;          /* major side                   */
    fix16               minor;          /* minor side                   */
    fix16               sum;            /* sum of major and minor       */
    fix16               sos;            /* sum of square                */
    real32              scale;          /* scaling factor               */
};


#define SELF_INDEX     (MAXCELLSIZE+1)
#define DONE_INDEX     (MAXCELLSIZE+2)
#define LINK_INDEX     (MAXCELLSIZE+3)


struct  spot_index
{
    ufix8               si_row;
    ufix8               si_col;
    fix16               sv_row;
    fix16               sv_col;
};


#define MAX_SPOT_STACK    64                                    /* 02-10-88 */

struct  spot_stack                                              /* 02-10-88 */
{
    fix16               p, q;
};


#define MAX_SPOT_VALUE  0x7FFF                                  /* 02-10-88 */

struct  spot_value
{
    fix16               value;
    ufix8               sv_row;
    ufix8               sv_col;
};


#define MAX_GROUP                 64
#define MAX_ENTRY                256

struct  group_entry
{
    struct cache_entry FAR *first;
    struct cache_entry FAR *last;
};

struct  cache_entry
{
    fix16               white;
    gmaddr              cache;
    struct cache_entry FAR *next;
};

/* greyscale - by Jack Liaw 7-26-90 */

#define WORD_LENGTH (sizeof(ufix) * 8)   /* # of bits per word */
#define MAX_BPP  4                       /* max. # of bits per pixel */
#define RIGH_SHIFT(D, S) ((D) >> (S))
#define LEFT_SHIFT(D, S) ((D) << (S))

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\path.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *      Name:       path.c
 *      Developer:  S.C.Chen
 *      History:
 *      Version     Date        Comments
 *                  4/7/88      @INV_CTM: pre-set inverse CTM
 *                  4/11/88     @EHS_JOIN: enhance linejoin by
 *                              pre-calculating miter limit
 *                  4/14/88     @END_DASH: revise endpoint drawing
 *                              of dash line
 *                  4/22/88     @EHS_ROUND: enhance round_join and
 *                              round_cap
 *                  4/28/88     @DOT_PRO: put calculation of dot product
 *                              in linejoin routine
 *                  5/19/88     perform scan-conversion for each dash
 *                              line segment
 *                  5/27/88     @CNTCLK: strokepath in countclockwise
 *                              direction
 *                  6/7/88      delete @DFR_SCAN; not defer performing
 *                              scan_conversion
 *                  6/16/88     @STKDIR: update the direction of the
 *                              outline of stroke/strokepath in clock-
 *                              wise direction
 *                  6/17/88     @DASH: revise drawing of dash pattern:
 *                              1. Correct initial dpat_on flag
 *                              2. Don't skip pattern of zero length
 *                  6/17/88     @CIR_FLAT: use current flatness to
 *                              approximate the circle of linejoin/cap
 *                              instead of refined flatness(stroke_flat)
 *                  6/22/88     @BIG_CIR: not flatten the circle of the
 *                              linejoin/cap if the linewidth is too
 *                              large
 *                  7/19/88     update data types:
 *                              1) F2LONG ==> F2LFX
 *                                 LONG2F ==> LFX2F
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           lfix_t, for long fixed real
 *                                           long32, for parameter
 *                              6) add compiling option: LINT_ARGS
 *                  7/20/88     @ALIGN_W: word alignment of bounding box
 *      3.0         8/13/88     @SCAN_EHS: scan conversion enhancement
 *                  8/18/88     @OUT_PAGE: enhancement of out_page checking
 *                  8/20/88     @TOUR: linetour enhancement, calculating in
 *                              device space
 *                  9/06/88     @STK_INFO: collect parameters used by stroke to
 *                              a structure stk_info, and re-calculate those
 *                              values only they have been changed instead of
 *                              each op_stroke command
 *      3.0         9/10/88     @STK_INT: stroke enhancement for stroking under
 *                              interger operations
 *                              1)Add structures of integer version:
 *                                struct line_seg_i, stroke_ctm, inverse_ctm_i
 *                              2)Update stk_info
 *                              3)Add routines of integer version:
 *                                path_to_outline_i, linetour_i, linecap_i,
 *                                linejoin_i, get_rect_points_i, paint_or_save_i
 *                                round_point_i
 *      3.0         10/5/88     seperate stroke related routines from this file
 *                              to stroke.c
 *                  10/20/88    update calling sequence: fix far copy_subpath()
 *                              => void far copy_subpath()
 *                  10/24/88    get_path(): move code of assigning ret_list to
 *                              the end for skipping LIMITCHECK
 *                  10/27/88    change routine check_infinity() to
 *                              macro CHECK_INFINITY()
 *                  10/27/88    update dump_subpath: check infinity coordinates
 *                              before calling fast_inv_transform
 *                  11/18/88    set_inverse_ctm(): move setting of inverse_ctm_i
 *                              to init_stroke() for preventing floating point
 *                              exception.
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/25/88    @STK_CHK: check if operand stack no free space
 *                  11/30/88    @ET: delete get_edge(), free_edge()
 *                  12/14/88    arc(): update error torlance 1e-4 => 1e-3
 *                  12/20/88    @SFX_BZR: provides a SFX version of
 *                              bezier interpolation: bezier_to_line_sfx()
 *                  01/31/89    move arc_to_bezier() declaration to GRAPHICS.EXT
 *                  11/8/89     fix reverse_subpath() bug: for subpath contains
 *                              only one moveto node; tail pointer undefined
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  11/27/89    @DFR_GS: defer copying nodes of gsave operator
 *                  2/20/90     fix @NODE bug in reverse_subpath()
 *                  12/4/90     @CPPH: free_path(): needs to free cp_path when
 *                              clipping trapezoids has freed from clip_path.
 *                  1/7/91      change < (real32)UNDRTOLANCE to <= (real32)UNDRTOLANCE
 *                  3/20/91     refine the tolerance check:
 *                              f <= UNDRTOLANCE --> IS_ZERO(f)
 *                              f == 0 --> IS_ZERO(f)
 *                              f <  0 --> SIGN_F(f)
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* **************** static variables *************** */

/* local variables for bezier curve approximation
 * used by "bezier_to_line" and "bezier_split"
 */
static  fix near bezier_depth;                  /* recursive depth */
static  real32 near bezier_x, near bezier_y;     /* reference point */
static  lfix_t near bezier_flatness;              /* flatness */

/* *************** Macro definition *************** */
#define DIV2(a)         ((a) >> 1)

/* property of CTM */
#define NORMAL_CTM      1
#define LEFT_HAND_CTM   2


/* ********** static function declartion ********** */

#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static void near bezier_split(VX_IDX, lfix_t, lfix_t, lfix_t, lfix_t, lfix_t,
              lfix_t, lfix_t, lfix_t);
static void near bezier_split_sfx(VX_IDX, lfix_t, lfix_t, lfix_t, lfix_t, lfix_t,
              lfix_t, lfix_t, lfix_t);          /* @SFX_BZR */
static void far copy_subpath (VX_IDX, struct sp_lst *);
static struct coord * near fast_inv_transform(long32, long32);  /* @INV_CTM */

#else

/* for no type checks of the parameters in function declarations */
static void near bezier_split();
static void near bezier_split_sfx();          /* @SFX_BZR */
static void far copy_subpath ();
static struct coord * near fast_inv_transform();

#endif

/***********************************************************************
 * This module creates a path contains some Bezier curves, each curve
 * represents a sector of 90 degrees, to approximate an arc. The
 * direction of the arc may be clockwise or countclockwise, and its
 * degree may over 360 degrees.
 *
 * TITLE:       arc
 *
 * CALL:        arc(direction, lx0, ly0, lr, lang1, lang2)
 *
 * PARAMETERS:
 *              direction    -- (CLKWISE/CNTCLK)
 *              lx0, ly0     -- coordinate of root
 *              lr           -- radius of arc
 *              lang1, lang2 -- starting and ending angles
 *
 * INTERFACE:   op_arc, op_arcn, op_arcto, linejoin, linecap
 *
 * CALLS:       arc_to_bezier
 *
 * RETURN:      none
 **********************************************************************/
SP_IDX arc(direction, lx0, ly0, lr, lang1, lang2)
ufix direction;
long32 lx0, ly0, lr, lang1, lang2;
{
        fix    NEG;
        bool   done;
        real32  d, t;
        real32  ang1, ang2;
        SP_IDX bezier_list;
        SP_IDX arc_list;
        real32  tmp;

        ang1 = L2F(lang1);
        ang2 = L2F(lang2);

        /* initilize arc_list */
        arc_list = NULLP;                      /* @NODE */

        /* Set NEG constant due to direction */
        if(direction == CLKWISE)
                NEG = -1;
        else
                NEG = 1;

        /* Draw a Bezier curve for each sector of 90 degrees */
        done = FALSE;
        while (!done) {
                d = NEG * (ang2-ang1);
                /*while (d < zero_f) d += (real32)360; 3/20/91; scchen */
                while (SIGN_F(d)) d += (real32)360.0;

                /* degernated case */
                FABS(tmp, d);
                if (tmp < (real32)1e-3) break;  /* 1e-4 => 1e-3;  12/14/88 */

                if(d <= (real32)90.) {
                        t = ang1 + NEG * d;
                        done = TRUE;
                } else
                        t = ang1 + NEG*90;

                /* create a bezier curve */
                bezier_list = arc_to_bezier (lx0, ly0, lr,
                                             F2L(ang1),F2L(t));

                if( ANY_ERROR() == LIMITCHECK ){
                        if (arc_list != NULLP) free_node(arc_list);
                        return (NULLP);
                }

                /* append it to arc_list */
                if (arc_list == NULLP) {
                        arc_list = bezier_list;
                } else {
                        node_table[(node_table[arc_list].SP_TAIL)].next =
                                bezier_list;
                        node_table[arc_list].SP_TAIL =
                                node_table[bezier_list].SP_TAIL;
                }
                ang1 = t;
        }
        return (arc_list);
}


/***********************************************************************
 * This module converts an arc, whose expanding angle is not larger than
 * 90 degrees, to a Bezier curve, and appends it to the input subpath.
 *
 * TITLE:       arc_to_bezier
 *
 * CALL:        arc_to_bezier(subpath, lx0, ly0, lr, lang1, lang2)
 *
 * PARAMETERS:  subpath    -- index to node_table, a subpath header
 *              x0, y0     -- coordinate of root
 *              r          -- radius of arc
 *              ang1, ang2 -- starting and ending angles
 *
 * INTERFACE:   arc
 *
 * CALLS:       transform, curveto
 *
 * RETURN:
 **********************************************************************/
/* struct vx_lst * arc_to_bezier (lx0, ly0, lr, lang1, lang2) @NODE */
SP_IDX arc_to_bezier (lx0, ly0, lr, lang1, lang2)
long32   lx0, ly0, lr, lang1, lang2;
{
        real32 x0, y0, r, ang1, ang2;
        real32 p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, tx, ty;
        real32 m1, m2;
        struct coord cp[3];
        struct nd_hdr FAR *pre_ptr;
        VX_IDX  first_vtx;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;   /* index to node_table for vertex */
        struct coord FAR *p;
        fix     i;
        real32  tmp;    /* @FABS */

        x0   = L2F(lx0);
        y0   = L2F(ly0);
        r    = L2F(lr);

        /* transform degrees to radius degree */
        ang1 = L2F(lang1) * PI / 180;
        ang2 = L2F(lang2) * PI / 180;

        /* Compute 4 control points of the approximated Bezier curve */
        /* First and last control points */
        p0x = x0 + r * (real32)cos(ang1);
        p0y = y0 + r * (real32)sin(ang1);
        p3x = x0 + r * (real32)cos(ang2);
        p3y = y0 + r * (real32)sin(ang2);

        /* Temporary point */
        tx = x0 + r * (real32)cos((ang1+ang2)/2);
        ty = y0 + r * (real32)sin((ang1+ang2)/2);

        /* Compute the other 2 control points (p1x, p1y) and (p2x, p2y)
         */
        tmp = (real32)cos(ang1);
        FABS(tmp, tmp);
        if(tmp < (real32)1e-4) {          /* cos(ang1) == 0 */
                m2 = (real32)tan(ang2);
                p2y = (8*ty - 4*p0y - p3y) / 3;
                p1y = p0y;
                p2x = p3x + m2*p3y - m2*p2y;
                p1x = (8*tx - p0x - p3x - 3*p2x) / 3;
        } else {
            tmp = (real32)cos(ang2);
            FABS(tmp, tmp);
            if (tmp < (real32)1e-4) {         /* cos(ang2) == 0 */
                m1 = (real32)tan(ang1);
                p2y = p3y;
                p1y = (8*ty - p0y - 4*p3y) / 3;
                p1x = p0x + m1 * (p0y-p1y);
                p2x = (8*tx - p0x - p3x - 3*p1x) / 3;
            } else {
                /* General case */
                m1 = (real32)tan(ang1);
                m2 = (real32)tan(ang2);
                p2y = (-8*tx - 8*m1*ty + 4*p0x + 4*m1*p0y + 4*p3x
                        + (3*m2 + m1) * p3y) / (3*(m2-m1));
                p1y = (-3*p2y + 8*ty - p0y - p3y) / 3;
                p1x = p0x + m1*p0y - m1*p1y;
                p2x = (8*tx - p0x - p3x - 3*p1x) /3;
            } /* @FABS */
        }

        /* Append the approximated curve to subpath */
        p = transform(F2L(p1x), F2L(p1y));
        cp[0].x = p->x;
        cp[0].y = p->y;
        p = transform(F2L(p2x), F2L(p2y));
        cp[1].x = p->x;
        cp[1].y = p->y;
        p = transform(F2L(p3x), F2L(p3y));
        cp[2].x = p->x;
        cp[2].y = p->y;

        /* loop to create 3 CURVETO nodes */
        for (i=0; i<3; i++) {
                /*
                 * Create a CURVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        if (i) free_node (first_vtx);
                        return (NULLP);
                }
                vtx = &node_table[ivtx];

                /* Set up a CURVETO node */
                vtx->VX_TYPE = CURVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = cp[i].x;
                vtx->VERTEX_Y = cp[i].y;

                if (i == 0) {
                        first_vtx = ivtx;
                } else {
                        pre_ptr->next = ivtx;
                }
                pre_ptr = vtx;
        }
        node_table[first_vtx].SP_NEXT = NULLP;
        node_table[first_vtx].SP_TAIL = ivtx;
        return (first_vtx);
}


/***********************************************************************
 * Given a Bezier curve which is represented by 4 control points, this
 * module creates a path contains several straight line segments to
 * approximate the curve. The input flatness will affect the accuracy of
 * the approximation.
 *
 * TITLE:       bezier_to_line
 *
 * CALL:        bezier_to_line (lflatness, lp0x, lp0y, lp1x, lp1y,
 *                              lp2x, lp2y, lp3x, lp3y)
 *
 * PARAMETERS:  lflatness -- accurency of approximation
 *              lp0x, lp0y .. lp3x, lp3y -- 4 control points of bezier curve
 *
 * INTERFACE:   Path_to_outline, flatten_subpath
 *
 * CALLS:       Bezier_split
 *
 * RETURN:      pointer to a vertex list, contains approximated line
 *              segments.
 **********************************************************************/
SP_IDX bezier_to_line(lflatness, lp0x, lp0y, lp1x, lp1y, lp2x,
                              lp2y, lp3x, lp3y)
long32    lflatness, lp0x, lp0y, lp1x, lp1y, lp2x, lp2y, lp3x, lp3y;
{
        SP_IDX b_vlist;
        struct  nd_hdr FAR *fcp, FAR *lcp;  /* first and last control points */
        VX_IDX  ifcp, ilcp;
        real32  flatness, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
        lfix_t  p1x_i, p1y_i, p2x_i, p2y_i, p3x_i, p3y_i;

        flatness = L2F(lflatness);
        p0x = L2F(lp0x);
        p0y = L2F(lp0y);
        p1x = L2F(lp1x);
        p1y = L2F(lp1y);
        p2x = L2F(lp2x);
        p2y = L2F(lp2y);
        p3x = L2F(lp3x);
        p3y = L2F(lp3y);

        /* Initialization */
        b_vlist = NULLP;

        /* Allocate a MOVETO node, fcp, for 1st control point */
        if((ifcp = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return (b_vlist);
        }
        fcp = &node_table[ifcp];

        fcp->VX_TYPE = MOVETO;
        fcp->next = NULLP;
        fcp->VERTEX_X = p0x;
        fcp->VERTEX_Y = p0y;

        /* Allocate a LINETO node, lcp, for last control point */
        if((ilcp = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                free_node (ifcp);
                return (b_vlist);
        }
        lcp = &node_table[ilcp];

        lcp->VX_TYPE = LINETO;
        lcp->next = NULLP;
        lcp->VERTEX_X = p3x;
        lcp->VERTEX_Y = p3y;

        /* chain these 2 nodes */
        fcp->next = ilcp;

        bezier_flatness = F2LFX (flatness);

        bezier_depth = 0;       /* initialization */

        /* Bezier curve approximation; by splitting Bezier hull into
         * smaller hulls recursively
         */
        bezier_x = p0x;
        bezier_y = p0y;
        p1x_i = F2LFX (p1x - p0x);
        p1y_i = F2LFX (p1y - p0y);
        p2x_i = F2LFX (p2x - p0x);
        p2y_i = F2LFX (p2y - p0y);
        p3x_i = F2LFX (p3x - p0x);
        p3y_i = F2LFX (p3y - p0y);
        bezier_split(ifcp, (lfix_t) 0, (lfix_t) 0, p1x_i, p1y_i, p2x_i,
                                                     p2y_i, p3x_i, p3y_i);
        if( ANY_ERROR() == LIMITCHECK ){
                free_node (ifcp);
                return (b_vlist);
        }

        /* save return b_vlist */
        b_vlist = fcp->next;
        node_table[b_vlist].SP_TAIL = ilcp;
        node_table[b_vlist].SP_NEXT = NULLP;

        /* remove the initial MOVETO node */
        fcp->next = NULLP;
        free_node (ifcp);

        return (b_vlist);
}


/*
 * SFX version of bezier interpolation                  @SFX_BZR
 * i.e. 4 control points in SFX format
 */
/* struct vx_lst  *bezier_to_line_sfx (flatness, @NODE */
SP_IDX bezier_to_line_sfx (flatness,
                                  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
lfix_t          flatness;
sfix_t          p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{

    lfix_t  p0x_i, p0y_i, p1x_i, p1y_i, p2x_i, p2y_i, p3x_i, p3y_i;
    /* real32  flatness; */
    struct nd_hdr   FAR *fcp, FAR *lcp; /* first and last control points */
    VX_IDX          ifcp, ilcp; /* index to node_table */
    /* static  struct vx_lst b_vlist;   (* should be static *) @NODE */
    SP_IDX b_vlist;

    /* Initialization */
    b_vlist = NULLP;

    /* Allocate a MOVETO node, fcp, for 1st control point */
    if ((ifcp = get_node()) == NULLP) {
        ERROR(LIMITCHECK);
        return (b_vlist);
    }
    fcp = &node_table[ifcp];

    fcp->VXSFX_TYPE = MOVETO;
    fcp->VXSFX_X    = p0x;
    fcp->VXSFX_Y    = p0y;
    fcp->next       = NULLP;

    /* Allocate a LINETO node, lcp, for last control point */
    if ((ilcp = get_node()) == NULLP) {
        ERROR(LIMITCHECK);
        free_node (ifcp);
        return (b_vlist);
    }
    lcp = &node_table[ilcp];

    lcp->VXSFX_TYPE = LINETO;
    lcp->VXSFX_X    = p3x;
    lcp->VXSFX_Y    = p3y;
    lcp->next       = NULLP;

    /* chain these 2 nodes */
    fcp->next = ilcp;

    bezier_flatness = flatness;

    bezier_depth = 0;           /* initialization */

    /* Bezier curve approximation; by splitting Bezier hull into
     * smaller hulls recursively
     */
    p0x_i = SFX2LFX (p0x);
    p0y_i = SFX2LFX (p0y);
    p1x_i = SFX2LFX (p1x);
    p1y_i = SFX2LFX (p1y);
    p2x_i = SFX2LFX (p2x);
    p2y_i = SFX2LFX (p2y);
    p3x_i = SFX2LFX (p3x);
    p3y_i = SFX2LFX (p3y);
    bezier_split_sfx (ifcp, p0x_i, p0y_i, p1x_i, p1y_i,
                                          p2x_i, p2y_i, p3x_i, p3y_i);
    if (ANY_ERROR() == LIMITCHECK) {
        free_node (ifcp);
        return (b_vlist);       /* return (&b_vlist); @NODE */
    }

    /* save return b_vlist */
    b_vlist = fcp->next;               /* skip 1st MOVETO node */
    node_table[b_vlist].SP_TAIL = ilcp;
    node_table[b_vlist].SP_NEXT = NULLP;

    /* remove the initial MOVETO node */
    fcp->next = NULLP;
    free_node (ifcp);

    return (b_vlist);
}

/***********************************************************************
 * Split a Bezier hull into 2 hulls
 *    (p0, p1, p2, p3) --> (q0, q1, q2, q3) and (r0, r1, r2, r3)
 *
 * TITLE:       bezier_split
 *
 * CALL:        bezier_split(ptr, flatness, p0x, p0y, p1x, p1y, p2x,
 *              p2y, p3x, p3y)
 *
 * PARAMETERS:  ifcp     -- index to node_table, the node of 1st control
 *                          point; a new approximated point will be
 *                          inserted after it.
 *              flatness -- accuracy to approximate curve
 *              p0x, p0y -- 1st control point of a bezier curve
 *              p1x, p1y -- 2nd control point of a bezier curve
 *              p2x, p2y -- 3rd control point of a bezier curve
 *              p3x, p3y -- 4th control point of a bezier curve
 *
 * INTERFACE:   Bezier_slpit
 *
 * CALLS:       Bezier_split
 *
 * RETURN:
 **********************************************************************/
static void near bezier_split(ifcp, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
VX_IDX ifcp;
lfix_t p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{
        lfix_t q1x, q1y, q2x, q2y;
        lfix_t r1x, r1y, r2x, r2y;
        lfix_t pmx, pmy;         /* new approximated point */
        lfix_t distance;
        lfix_t tempx, tempy;

        struct nd_hdr FAR *fcp, FAR *vtx;
        VX_IDX ivtx;

        /* initialize; get pointer of first control point */
        fcp = &node_table[ifcp];

        /* Compute a new approximated point (pmx, pmy) */
         pmx = DIV2(p1x + p2x);         pmy = DIV2(p1y + p2y);
         q1x = DIV2(p0x + p1x);         q1y = DIV2(p0y + p1y);
         r2x = DIV2(p2x + p3x);         r2y = DIV2(p2y + p3y);
         q2x = DIV2(q1x + pmx);         q2y = DIV2(q1y + pmy);
         r1x = DIV2(r2x + pmx);         r1y = DIV2(r2y + pmy);
         pmx = DIV2(r1x + q2x);         pmy = DIV2(r1y + q2y);

         /* Bezier curve function :
          * p(t) = (1-t)**3 * p0  +
          *     3 * t * (1-t)**2 * p1 +
          *     3 * t**2 * (1-t) * p2 +
          *     t**3 * p3
          */

        /* Compute the distance between point pm and line p0,p3 */
/*      temp =  pmx*p0y + p3x*pmy + p0x*p3y - p3x*p0y - pmx*p3y - p0x*pmy;
 *      distance = ABS(temp) / sqrt((p0x-p3x)*(p0x-p3x) +
 *                                  (p0y-p3y)*(p0y-p3y));
 */

        /* distance between point pm and midpoint of p0, p3 */
        tempx = pmx - DIV2(p0x + p3x);
        tempy = pmy - DIV2(p0y + p3y);
        distance = ABS(tempx) + ABS(tempy);

        /* Check exit condition */
        if((bezier_depth != 0) && (distance < bezier_flatness)) return;

        /* increase recurcive_depth */
        bezier_depth ++;

        /* Save the new approximated point */
        /* Allocate a node */
        if ((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VX_TYPE = LINETO;
        vtx->VERTEX_X = LFX2F(pmx) + bezier_x;
        vtx->VERTEX_Y = LFX2F(pmy) + bezier_y;

        /* insert this node to first control point(fcp) */
        vtx->next = fcp->next;
        fcp->next = ivtx;

        /* Split left portion recurcively */
        bezier_split (ifcp, p0x, p0y, q1x, q1y, q2x, q2y, pmx, pmy);
        if( ANY_ERROR() == LIMITCHECK ) return;

        /* Split right portion recurcively */
        bezier_split (ivtx, pmx, pmy, r1x, r1y, r2x, r2y, p3x, p3y);
}


/*
 * SFX version of bezier interpolation          @SFX_BZR
 * i.e. 4 control points in SFX format
 */
static void near bezier_split_sfx (ifcp, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
VX_IDX  ifcp;
lfix_t  p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y;
{
        lfix_t q1x, q1y, q2x, q2y;
        lfix_t r1x, r1y, r2x, r2y;
        lfix_t pmx, pmy;         /* new approximated point */
        lfix_t distance;
        lfix_t tempx, tempy;

        struct nd_hdr FAR *fcp, FAR *vtx;
        VX_IDX ivtx;

        /* initialize; get pointer of first control point */
        fcp = &node_table[ifcp];

        /* Compute a new approximated point (pmx, pmy) */
         pmx = DIV2(p1x + p2x);         pmy = DIV2(p1y + p2y);
         q1x = DIV2(p0x + p1x);         q1y = DIV2(p0y + p1y);
         r2x = DIV2(p2x + p3x);         r2y = DIV2(p2y + p3y);
         q2x = DIV2(q1x + pmx);         q2y = DIV2(q1y + pmy);
         r1x = DIV2(r2x + pmx);         r1y = DIV2(r2y + pmy);
         pmx = DIV2(r1x + q2x);         pmy = DIV2(r1y + q2y);

         /* Bezier curve function :
          * p(t) = (1-t)**3 * p0  +
          *     3 * t * (1-t)**2 * p1 +
          *     3 * t**2 * (1-t) * p2 +
          *     t**3 * p3
          */

        /* Compute the distance between point pm and line p0,p3 */
/*      temp =  pmx*p0y + p3x*pmy + p0x*p3y - p3x*p0y - pmx*p3y - p0x*pmy;
 *      distance = ABS(temp) / sqrt((p0x-p3x)*(p0x-p3x) +
 *                                  (p0y-p3y)*(p0y-p3y));
 */

        /* distance between point pm and midpoint of p0, p3 */
        tempx = pmx - DIV2(p0x + p3x);
        tempy = pmy - DIV2(p0y + p3y);
        distance = ABS(tempx) + ABS(tempy);

        /* Check exit condition */
        if((bezier_depth != 0) && (distance < bezier_flatness)) return;

        /* increase recurcive_depth */
        bezier_depth ++;

        /* Save the new approximated point */
        /* Allocate a node */
        if ((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VXSFX_TYPE = LINETO;
        vtx->VXSFX_X    = LFX2SFX_T(pmx);
        vtx->VXSFX_Y    = LFX2SFX_T(pmy);

        /* insert this node to first control point(fcp) */
        vtx->next = fcp->next;
        fcp->next = ivtx;

        /* Split left portion recurcively */
        bezier_split_sfx (ifcp, p0x, p0y, q1x, q1y, q2x, q2y, pmx, pmy);
        if( ANY_ERROR() == LIMITCHECK ) return;

        /* Split right portion recurcively */
        bezier_split_sfx (ivtx, pmx, pmy, r1x, r1y, r2x, r2y, p3x, p3y);
}


/***********************************************************************
 * This module creates a MOVETO node, and appends it to current path.
 *
 * TITLE:       moveto
 *
 * CALL:        moveto(lx, ly)
 *
 * PARAMETERS:  lx, ly -- coordinate to create a MOVETO node
 *
 * INTERFACE:   op_moveto, op_rmoveto, op_arc, op_arcn
 *
 * CALLS:       none
 *
 * RETURN:      none
 **********************************************************************/
void moveto(long32 lx, long32 ly)
/* long32   lx, ly;     @WIN */
{
        real32  x0, y0;
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;             /* index to node_table for vertex */

        x0 = L2F(lx);
        y0 = L2F(ly);
        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag; do nothing */
                /* 05/06/91 Peter */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;      /* new path */
        tail_sp = &node_table[path->tail];
        vtx = &node_table[tail_sp->SP_TAIL];

        /* Just update current node if current position is a MOVETO type
         * otherwise, create a new subpath
         */
        if (vtx->VX_TYPE == MOVETO) {
                /* Replace contents of current_node */
                vtx->VERTEX_X = x0;
                vtx->VERTEX_Y = y0;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                        tail_sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }
        } else {
                /*
                 * create a subpath header
                 */
create_node:
                /*
                 * Create a MOVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                vtx = &node_table[ivtx];

                /* Set up a MOVETO node */
                vtx->VX_TYPE = MOVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = x0;
                vtx->VERTEX_Y = y0;
                vtx->SP_FLAG = FALSE;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                        vtx->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* @NODE */
                /* Setup subpath header, and append current path */
                vtx->SP_TAIL = ivtx;
                vtx->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        /* tail_sp->next = ivtx; @NODE */
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;
        }

        /* Update current position */
        GSptr->position.x = x0;
        GSptr->position.y = y0;
}


/***********************************************************************
 *
 * This module creates a LINETO node, and appends it to current path.
 *
 * TITLE:       lineto
 *
 * CALL:        lineto(lx, ly)
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_lineto
 *              op_rlineto
 *              op_arc
 *              op_arcn
 *              op_arcto
 *
 * CALLS:
 *
 * RETURN:
 *
 **********************************************************************/
void lineto(long32 lx, long32 ly)       /*@WIN*/
/* long32   lx, ly;     @WIN */
{
        real32  x0, y0;
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp, FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx;

        x0 = L2F(lx);
        y0 = L2F(ly);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;
        tail_sp = sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* create a new subpath if last node is a CLOSEPATH */
        if (vtx->VX_TYPE == CLOSEPATH) {
create_node:
                /* Create a pseudo moveto(PSMOVE) node */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                sp = vtx = &node_table[ivtx];

                /* Set up a PSMOVE node of current position */
                vtx->VX_TYPE = PSMOVE;
                vtx->next = NULLP;
                vtx->VERTEX_X = GSptr->position.x;
                vtx->VERTEX_Y = GSptr->position.y;
                vtx->SP_FLAG = FALSE;    /* @NODE */

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* @NODE */
                /* Setup subpath header, and append current path */
                sp->SP_TAIL = ivtx;
                sp->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;

        } /* if CLOSEPATH */

        /*
         * Create a LINETO node
         */
        /* Allocate a node */
        ivtx = get_node();
        if(ivtx == NULLP) {
                ERROR(LIMITCHECK);
                return;
        }
        vtx = &node_table[ivtx];

        /* Set up a LINETO node */
        vtx->VX_TYPE = LINETO;
        vtx->next = NULLP;
        vtx->VERTEX_X = x0;
        vtx->VERTEX_Y = y0;

        /* set sp_flag @SP_FLG */
        if (out_page(F2L(x0)) || out_page(F2L(y0))) { /* @OUT_PAGE */
                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
        }

        /* Append this node to current_subpath */
        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        /* Update current position */
        GSptr->position.x = x0;
        GSptr->position.y = y0;
}



/***********************************************************************
 * This module creates 3 CURVETO nodes, and appends it to current path.
 *
 * TITLE:       curveto
 *
 * CALL:        curveto(subpath, cp)
 *
 * PARAMETERS:  cp      -- an array contains 3 coordinates of a bezier
 *                         curve
 *
 * INTERFACE:   op_curveto, arc_to_bezier
 *
 * CALLS:
 *
 * RETURN:      none
 **********************************************************************/
void curveto (long32 lx0, long32 ly0, long32 lx1,
long32 ly1, long32 lx2, long32 ly2)     /*@WIN*/
/* long32     lx0, ly0, lx1, ly1, lx2, ly2;     @WIN */
{
        struct coord cp[3];
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp, FAR *tail_sp;
        struct nd_hdr FAR *vtx;
        VX_IDX  ivtx, tail_ivtx;
        fix     i;

        cp[0].x = L2F(lx0);
        cp[0].y = L2F(ly0);
        cp[1].x = L2F(lx1);
        cp[1].y = L2F(ly1);
        cp[2].x = L2F(lx2);
        cp[2].y = L2F(ly2);

        path = &path_table[GSptr->path];

        /* copy last incompleted subpath if defer flag is true @DFR_GS */
        if (path->rf & P_DFRGS) {
                path->rf &= ~P_DFRGS;       /* clear defer flag */
                copy_last_subpath(&path_table[GSptr->path - 1]);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_path();
                        return;
                }
        }

        if (path->tail == NULLP) goto create_node;
        tail_sp = sp = &node_table[path->tail];
        vtx = &node_table[sp->SP_TAIL];

        /* create a new subpath if last node is a CLOSEPATH */
        if (vtx->VX_TYPE == CLOSEPATH) {
create_node:
                /* Create a pseudo moveto(PSMOVE) node */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                sp = vtx = &node_table[ivtx];

                /* Set up a PSMOVE node of current position */
                vtx->VX_TYPE = PSMOVE;
                vtx->next = NULLP;
                vtx->VERTEX_X = GSptr->position.x;
                vtx->VERTEX_Y = GSptr->position.y;
                vtx->SP_FLAG = FALSE;    /* @NODE */

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* Setup subpath header, and append current path */
                sp->SP_TAIL = ivtx;
                sp->SP_NEXT = NULLP;
                if (path->tail == NULLP)
                        path->head = ivtx;
                else
                        /* tail_sp->next = ivtx; @NODE */
                        tail_sp->SP_NEXT = ivtx;
                path->tail = ivtx;
        } else {
                tail_ivtx = sp->SP_TAIL;
        } /* if CLOSEPATH */

        /* loop to create 3 CURVETO nodes */
        for (i=0; i<3; i++) {
                /*
                 * Create a CURVETO node
                 */
                /* Allocate a node */
                ivtx = get_node();
                if(ivtx == NULLP) {
                        ERROR(LIMITCHECK);
                        return;
                }
                vtx = &node_table[ivtx];

                /* Set up a CURVETO node */
                vtx->VX_TYPE = CURVETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = cp[i].x;
                vtx->VERTEX_Y = cp[i].y;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                /* Append this node to current_subpath */
                node_table[sp->SP_TAIL].next = ivtx;
                sp->SP_TAIL = ivtx;
        }

        /* set sp_flag @SP_FLG */
        sp->SP_FLAG |= SP_CURVE;

        /* Update current position */
        GSptr->position.x = cp[2].x;
        GSptr->position.y = cp[2].y;
}


/***********************************************************************
 * This module creates a path that reverses the direction and order of
 * the given subpath.
 *
 * TITLE:       reverse_subpath
 *
 * CALL:        reverse_subpath(in_subpath)
 *
 * PARAMETERS:
 *
 * INTERFACE:   op_reversepath
 *
 * CALLS:
 *
 * RETURN:
 **********************************************************************/
SP_IDX reverse_subpath (first_vertex)
VX_IDX first_vertex;
{
        SP_IDX ret_vlist;
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx, inode, tail;
        real32   last_x, last_y;

        /* Initialize ret_vlist */
        ret_vlist = tail = NULLP;

        /* Traverse the input subpath, and create a new reversed subpath */
        for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {
                case MOVETO :
                case PSMOVE :
                        /* keep last position */
                        last_x = vtx->VERTEX_X;
                        last_y = vtx->VERTEX_Y;
                        break;
                case LINETO :
                case CURVETO :
                        /* Create a LINETO/CURVETO node with (last_x, last_y)*/
                        if((inode = get_node()) == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = vtx->VX_TYPE;
                        node->VERTEX_X = last_x;
                        node->VERTEX_Y = last_y;

                        /* preppend the node to ret_vlist */
                        if (ret_vlist == NULLP)
                                tail = inode;
                        else
                                node->next = ret_vlist;
                        ret_vlist = inode;

                        /* keep last position */
                        last_x = vtx->VERTEX_X;
                        last_y = vtx->VERTEX_Y;
                        break;
                case CLOSEPATH :
                        /* Create a CLOSEPATH node */
                        if((inode = get_node()) == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = CLOSEPATH;

                        /* append the node to ret_vlist */
                        if (tail == NULLP)
                                ret_vlist = inode;
                        else
                                node_table[tail].next = inode;
                        tail = inode; /* ret_vlist always not empty */
                        break;
                } /* switch */
        } /* for loop */

        /* Create a MOVETO node(last_x, last_y) for end of subpath */
        if((inode = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                return (ret_vlist);
        }
        node = &node_table[inode];

        node->VX_TYPE = MOVETO;
        node->VERTEX_X = last_x;
        node->VERTEX_Y = last_y;
        node->SP_FLAG = node_table[first_vertex].SP_FLAG;

        /* preppend the node to ret_vlist */
        node->next = ret_vlist;
        node->SP_NEXT = NULLP;
        ret_vlist = inode;
        if (tail == NULLP)
                tail = inode;
        node->SP_TAIL = tail;
        return (ret_vlist);
}



/***********************************************************************
 * This module creates a path that preserves all straight line segments
 * but has all curve segments replaced by sequences of line segments
 * that approximate the given subpath.
 *
 * TITLE:       flatten_subpath
 *
 * CALL:        flatten_subpath(in_subpath)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Op_flattenpath
 *
 * CALLS:       Bezier_to_line
 *
 * RETURN:
 **********************************************************************/
SP_IDX flatten_subpath (first_vertex, lflatness)
VX_IDX first_vertex;
long32   lflatness;
{
        SP_IDX ret_vlist; /* should be static */
        SP_IDX b_vlist;
        struct nd_hdr FAR *vtx, FAR *node;
        VX_IDX ivtx, inode, tail;
        real32   x1=0, y1=0, x2=0, y2=0, x3=0, y3=0, x4=0, y4=0;

        /* Initialize ret_vlist */
        ret_vlist = tail = NULLP;

        /* Traverse the input subpath, and create a new flattened subpath */
        for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {
                case MOVETO :
                case PSMOVE :
                case LINETO :
                case CLOSEPATH :
                        /* Copy the node */
                        inode = get_node();
                        if(inode == NULLP) {
                                ERROR(LIMITCHECK);
                                return (ret_vlist);
                        }
                        node = &node_table[inode];

                        node->next = NULLP;
                        node->VX_TYPE = vtx->VX_TYPE;
                        node->VERTEX_X = vtx->VERTEX_X;
                        node->VERTEX_Y = vtx->VERTEX_Y;

                        /* Append the node to ret_vlist */
                        if (ret_vlist == NULLP) {
                                ret_vlist = inode;
                                node->SP_FLAG =
                                    node_table[first_vertex].SP_FLAG;
                        } else
                                node_table[tail].next = inode;
                        tail = inode;
                        break;
                case CURVETO :
                        x1 = x2;
                        y1 = y2;
                        x2 = vtx->VERTEX_X;
                        y2 = vtx->VERTEX_Y;

                        /* Get next two nodes: x3, y3, x4, y4 */
                        vtx = &node_table[vtx->next];
                        x3 = vtx->VERTEX_X;
                        y3 = vtx->VERTEX_Y;
                        vtx = &node_table[vtx->next];
                        x4 = vtx->VERTEX_X;
                        y4 = vtx->VERTEX_Y;

                        b_vlist = bezier_to_line(lflatness,F2L(x1),F2L(y1),
                             F2L(x2), F2L(y2),F2L(x3),F2L(y3),F2L(x4),F2L(y4));

                        if( ANY_ERROR() == LIMITCHECK ) return(ret_vlist);

                        /* append b_vlist to ret_vlist */
                        node_table[tail].next = b_vlist;
                        tail = node_table[b_vlist].SP_TAIL;
                        break;
                } /* switch */
                x2 = vtx->VERTEX_X;
                y2 = vtx->VERTEX_Y;
        } /* for */
        node_table[ret_vlist].SP_TAIL = tail;
        node_table[ret_vlist].SP_NEXT = NULLP;
        return (ret_vlist);
}



/***********************************************************************
 * This module enumerates the current subpath in order, executes one of
 * the four given procedures for each element in the subpath.
 *
 * TITLE:       dump_subpath
 *
 * CALL:        dump_subpath(moveto_proc, lineto_proc, curveto_proc,
 *              closepath_proc)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Op_pathforall
 *
 * CALLS:       Execute
 *
 * RETURN:
 **********************************************************************/
void dump_subpath (isubpath, objects)
SP_IDX isubpath;
struct object_def FAR objects[];
{
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;
        struct coord *p;
        union  four_byte x4, y4;
        fix     i;

        /* Traverse the current subpath, and dump all nodes */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {

                case MOVETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 2){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        /* Transform to user's space, and push to
                         * operand stack
                         */
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE (REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

                        if (interpreter(&objects[0])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }

                        break;

                case LINETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 2){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        /* Transform to user's space, and push to
                         * operand stack
                         */
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, x4.ll);
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL, 0, y4.ll);

                        if (interpreter(&objects[1])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }

                        break;

                case CURVETO :
                        /* check if operand stack no free space */
                        if(FRCOUNT() < 6){                      /* @STK_CHK */
                                ERROR(STACKOVERFLOW);
                                return;
                        }

                        for (i=0; i<2; i++) {
                            /* check infinity 10/27/88 */
                            if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                                (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                    x4.ff = infinity_f;
                                    y4.ff = infinity_f;
                            } else {
                                    p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                          F2L(vtx->VERTEX_Y));
                                    x4.ff = p->x;
                                    y4.ff = p->y;
                            }
                            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                       0, x4.ll);
                            PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                       0, y4.ll);
                            vtx = &node_table[vtx->next];
                        }
                        /* check infinity 10/27/88 */
                        if ((F2L(vtx->VERTEX_X) == F2L(infinity_f)) ||
                            (F2L(vtx->VERTEX_Y) == F2L(infinity_f))) {
                                x4.ff = infinity_f;
                                y4.ff = infinity_f;
                        } else {
                                p = fast_inv_transform(F2L(vtx->VERTEX_X),
                                                      F2L(vtx->VERTEX_Y));
                                x4.ff = p->x;
                                y4.ff = p->y;
                        }
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                   0, x4.ll);
                        PUSH_VALUE(REALTYPE, UNLIMITED, LITERAL,
                                   0, y4.ll);

                        if (interpreter(&objects[2])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }
                        break;
                case CLOSEPATH :
                        if (interpreter(&objects[3])) {
                                if(ANY_ERROR() == INVALIDEXIT)
                                        CLEAR_ERROR();
                                return;
                        }
                        break;
                } /* switch */
        } /* for loop */
}


void bounding_box (isubpath, bbox)
VX_IDX isubpath;
real32 far *bbox;                            /* real32 far bbox[]; */
{
        struct nd_hdr FAR *vtx;
        VX_IDX ivtx;

        /* find min. and max. values of current path */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                /* ignore single moveto node and under charpath 1/2/91; scchen */
                if (vtx->VX_TYPE == MOVETO &&
                    vtx->next == NULLP &&
                    path_table[GSptr->path].rf & P_NACC ) break;

                if (vtx->VX_TYPE == CLOSEPATH) break;
                        /* coord. in CLOSEPATH node is meaningless */

                if (vtx->VERTEX_X > bbox[2])            /* max_x */
                        bbox[2] = vtx->VERTEX_X;
                else if (vtx->VERTEX_X < bbox[0])       /* min_x */
                        bbox[0] = vtx->VERTEX_X;
                if (vtx->VERTEX_Y > bbox[3])            /* max_y */
                        bbox[3] = vtx->VERTEX_Y;
                else if (vtx->VERTEX_Y < bbox[1])       /* min_y */
                        bbox[1] = vtx->VERTEX_Y;
        } /* for each vertex */
}


/***********************************************************************
 *
 * TITLE:       get_node
 *
 * CALL:        get_node()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      node -- index of node_table contains a node
 *              -1   -- fail (no more nodes to get)
 *
 **********************************************************************/
VX_IDX get_node()
{
        fix     inode;
        struct nd_hdr FAR *node;

        if(freenode_list == NULLP) {
#ifdef DBG1
                printf("\07Warning, out of node_table\n");
#endif
                return(NULLP);
        }
        node = &node_table[freenode_list];
        inode = freenode_list;
        freenode_list = node->next;
        node->next = NULLP;
#ifdef DBG2
        printf("get node#%d\n", inode);
#endif
        return ((VX_IDX)inode);
}



/***********************************************************************
 *
 * TITLE:       free_node
 *
 * CALL:        free_node (inode)
 *
 * PARAMETERS:  inode -- a list of nodes to be freed
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void free_node (inode)
fix     inode;
{
        fix ind, inext;
        struct nd_hdr FAR *nd;

#ifdef DBG2
        printf("free nodes#");
#endif

        for (ind = inode; ind != NULLP; ind = inext) {
                nd = &node_table[ind];
                inext = nd->next;
                nd->next = freenode_list;
                freenode_list = (VX_IDX)ind;
#ifdef DBG2
                printf("%d, ", ind);
#endif
        }

#ifdef DBG2
        printf("\n");
#endif
}


/***********************************************************************
 * This module frees current path on current gsave level
 *
 * TITLE:       free_path
 *
 * CALL:        free_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   procedures want to free current path
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
void free_path()
{
        struct ph_hdr FAR *path;
        VX_IDX next;
        SP_IDX  isp;

        path = &path_table[GSptr->path];

        /* Free current path */
        for (isp = path->head; isp != NULLP; isp = next) {
                next = node_table[isp].SP_NEXT;
                free_node(isp);
        }
        path->head = path->tail = NULLP;

        /* initilize current path */
        path->previous = NULLP;
        path->rf = 0;

        /* free clip trazepoids which used by current path but has been freed
         * by clip_path @CPPH; 12/1/90
         */
        if (path->cp_path != NULLP) {
                if (path->cp_path != GSptr->clip_path.head)
                        free_node (path->cp_path);
                path->cp_path = NULLP;
        }
}


/***********************************************************************
 * This module gets current path.
 *
 * TITLE:       get_path
 *
 * CALL:        get_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   procedures want to free current path
 *
 * CALLS:       free_node
 *
 * RETURN:      none
 **********************************************************************/
void get_path(sp_list)
struct sp_lst FAR *sp_list;
{
        /* copy all subpaths to ret_list */
// DJC        traverse_path (copy_subpath, (fix FAR *)sp_list);
        traverse_path ((TRAVERSE_PATH_ARG1)(copy_subpath), (fix FAR *)sp_list);
}

static void far copy_subpath (isubpath, ret_list)    /* @TRVSE */
SP_IDX isubpath;
struct sp_lst *ret_list;
{
        struct nd_hdr FAR *vtx, FAR *nvtx;
        VX_IDX ivtx, invtx;
        VX_IDX head, tail;

        head = tail = NULLP;

        /* Traverse the current subpath, and copy all nodes */
        for (ivtx = isubpath;
             ivtx != NULLP; ivtx = vtx->next) {
                vtx = &node_table[ivtx];

                /* Allocate a node */
                if((invtx = get_node()) == NULLP) {
                        ERROR(LIMITCHECK);
                        free_node (head);
                        return;
                }
                nvtx = &node_table[invtx];

                /* copy contents of the node */
                nvtx->VX_TYPE = vtx->VX_TYPE;
                nvtx->next = NULLP;
                nvtx->VERTEX_X = vtx->VERTEX_X;
                nvtx->VERTEX_Y = vtx->VERTEX_Y;

                /* Append this node to current_subpath */
                if (tail == NULLP) {
                        head = invtx;
                        nvtx->SP_FLAG = vtx->SP_FLAG;
                        nvtx->SP_NEXT = NULLP;
                } else
                        node_table[tail].next = invtx;
                tail = invtx;
        } /* for loop */
        node_table[head].SP_TAIL = tail;

        /* Append this subpath to ret_list */
        if (ret_list->tail == NULLP)
                ret_list->head = head;
        else
                node_table[ret_list->tail].SP_NEXT = head;
        ret_list->tail = head;
}


/***********************************************************************
 * This module appends input subpaths to current path.
 *
 * TITLE:       append_path
 *
 * CALL:        append_path()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      none
 **********************************************************************/
void append_path(sp_list)
struct sp_lst FAR *sp_list;
{
        struct ph_hdr FAR *path;
        struct nd_hdr FAR *sp;

        path = &path_table[GSptr->path];

        if (path->tail == NULLP)
                path->head = sp_list->head;
        else {
                /* current path not empty, append sp_list */
                sp = &node_table[path->tail];   /* current subpath */
                if (node_table[sp->SP_TAIL].VX_TYPE == MOVETO) {
                        struct nd_hdr FAR *headsp;

                        /* the tail vertex is a MOVETO node,
                         * combine the current subpath with sp_list->head
                         */
                        /* free_node (sp->SP_TAIL); @NODE */

                        /* copy header of first subpath of sp_list
                         * to current subpath
                         */
                        headsp = &node_table[sp_list->head];
                        /* @NODE
                         * sp->SP_HEAD = headsp->SP_HEAD;
                         * sp->SP_TAIL = headsp->SP_TAIL;
                         * sp->next = headsp->next;
                         * sp->SP_FLAG = headsp->SP_FLAG;       (* 1/14/88 *)
                         */
                        *sp = *headsp;

                        /* free subpath header of sp_list->head */
                        headsp->next = NULLP;
                        free_node (sp_list->head);

                        /* update sp_list->tail, if it has been removed */
                        if (sp_list->tail == sp_list->head) {
                                sp_list->tail = path->tail;
                                if (headsp->SP_TAIL == sp_list->head)/* @NODE */
                                        sp->SP_TAIL = path->tail;
                        }
                } else
                        /* chain sp_list to current path normally */
                        /* node_table[path->tail].next = sp_list->head; @NODE */
                        node_table[path->tail].SP_NEXT = sp_list->head;
        }
        /* update the tail of current path */
        path->tail = sp_list->tail;

}




void set_inverse_ctm()
{
        real32  det_matrix;

        /* calculate the det(CTM) */
        _clear87() ;
        det_matrix = GSptr->ctm[0] * GSptr->ctm[3] -
                     GSptr->ctm[1] * GSptr->ctm[2];
        CHECK_INFINITY(det_matrix);

        /* check undefinedresult error */
        /*FABS(tmp, det_matrix);
        if(tmp <= (real32)UNDRTOLANCE){   3/20/91; scchen*/
        if(IS_ZERO(det_matrix)) {
                ERROR(UNDEFINEDRESULT);
                return;
        }

        /* calculate the value of INV(CTM) */
        inverse_ctm[0] =  GSptr->ctm[3] / det_matrix;
        CHECK_INFINITY(inverse_ctm[0]);

        inverse_ctm[1] = -GSptr->ctm[1] / det_matrix;
        CHECK_INFINITY(inverse_ctm[1]);

        inverse_ctm[2] = -GSptr->ctm[2] / det_matrix;
        CHECK_INFINITY(inverse_ctm[2]);

        inverse_ctm[3] =  GSptr->ctm[0] / det_matrix;
        CHECK_INFINITY(inverse_ctm[3]);

        inverse_ctm[4] = (GSptr->ctm[2] * GSptr->ctm[5] -
              GSptr->ctm[3] * GSptr->ctm[4]) / det_matrix;
        CHECK_INFINITY(inverse_ctm[4]);

        inverse_ctm[5] = (GSptr->ctm[1] * GSptr->ctm[4] -
              GSptr->ctm[0] * GSptr->ctm[5]) / det_matrix;
        CHECK_INFINITY(inverse_ctm[5]);

        /* set ctm_flag */
/*      if ((F2L(GSptr->ctm[1]) == F2L(zero_f)) &&      3/20/91; scchen
 *          (F2L(GSptr->ctm[2]) == F2L(zero_f))) {
 */
        if (IS_ZERO(GSptr->ctm[1]) && IS_ZERO(GSptr->ctm[2])){
                ctm_flag |= NORMAL_CTM;
        } else {
                ctm_flag &= ~NORMAL_CTM;
        }

        /* left-handed or right-handed system; @STKDIR */
        /*if (GSptr->ctm[0] < zero_f) {                  3/20/91; scchen
         *       if (GSptr->ctm[3] > zero_f)
         *               ctm_flag |= LEFT_HAND_CTM;      (* different signs *)
         *       else
         *               ctm_flag &= ~LEFT_HAND_CTM;     (* same signs *)
         *} else {
         *       if (GSptr->ctm[3] > zero_f)
         *               ctm_flag &= ~LEFT_HAND_CTM;     (* same signs *)
         *       else
         *               ctm_flag |= LEFT_HAND_CTM;      (* different signs *)
         *}
         */
        if (SIGN_F(GSptr->ctm[0]) == SIGN_F(GSptr->ctm[3]))
                ctm_flag &= ~LEFT_HAND_CTM;     /* same signs */
        else
                ctm_flag |= LEFT_HAND_CTM;      /* different signs */

}



static struct coord * near fast_inv_transform(lx, ly)
long32   lx, ly;
{
        real32  x, y;
        static struct coord p;  /* should be static */

        x = L2F(lx);
        y = L2F(ly);

        _clear87() ;

        if (ctm_flag&NORMAL_CTM) {
                p.x = inverse_ctm[0]*x + inverse_ctm[4];
                CHECK_INFINITY(p.x);

                p.y = inverse_ctm[3]*y + inverse_ctm[5];
                CHECK_INFINITY(p.y);
        } else {
                p.x = inverse_ctm[0]*x + inverse_ctm[2]*y + inverse_ctm[4];
                CHECK_INFINITY(p.x);

                p.y = inverse_ctm[1]*x + inverse_ctm[3]*y + inverse_ctm[5];
                CHECK_INFINITY(p.y);
        }

        return(&p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\init.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/***********************************************************************
 *
 *      File Description
 *
 *      File Name:   init.c
 *
 *      Purpose: This file contains an initialization routine to be
 *               called by Interpreter at system start-up time.
 *
 *      Developer:      S.C.Chen
 *
 *      Modifications:
 *      Version     Date        Comment
 *                  5/23/88     @DEVICE: update framedevice & nulldevice
 *                              for correct operation under gsave/grestore.
 *                              append 4 fields in dev_hdr: width, hight,
 *                              chg_flg, and nuldev_flg.
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           long32, for parameter
 *                              4) introduce ATTRIBUTE_SET & TYPE_SET
 *                  7/22/88     rename init_Intel786 to init_physical (Y.C.)
 *      3.0         8/13/88     @SCAN_EHS: scan conversion enhancement
 *                              delete clip_et, clip_xt, fill_et, fill_ht
 *                  11/24/88    add GRAYUNIT & GRAYSCALE; value of transfer
 *                              is "* 16384" instead of "* 4096"
 *                  11/29/88    @ET: update edge_table structure
 *                              1) add edge_ptr structure
 *                              2) delete shape_et, shape_xt, shape_ht_first
 *                              3) delete init_edgetable()
 *                  8/22/89     init_gstack(): initialize device width &
 *                              height at depth 0 of graphics stack for
 *                              robustness.
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  12/4/90     @CPPH: init_pathtable(): Initialize cp_path to
 *                              be NULLP at system initializaton.
 *                  3/19/91     init_graphics(): call op_clear to clear stack
 *                              init_graytable(): directly init. gray_table,
 *                              not go through interpreter.
 *                  11/23/91    upgrade for higher resolution @RESO_UPGR
 *
 *    04-07-92   SCC   Add global allocate for gs_stack & gray_may tables
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include <math.h>
#include <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "graphics.def"

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
static void near init_pathtable(void);
static void near init_nodetable(void);
static void near init_gstack(void);
static void near init_graytable(void);
static void near alloc_memory(void);
#else
static void near init_pathtable();
static void near init_nodetable();
static void near init_gstack();
static void near init_graytable();
static void near alloc_memory();
#endif

extern real32 FAR * gray_map;    /* global allocate for image.c @WIN */

/***********************************************************************
 * Called once by initerpreter at system start-up time to initialize
 * tables.
 *
 * TITLE:       init_graphics
 *
 * CALL:        init_graphics()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
void FAR init_graphics()
{
        /* allocate memory(fardata) for graphics tables */
        alloc_memory();

        current_save_level = 0;
        /* opnstktop = 0; scchen; 3/19/91 */
        op_clear();

        /* init. graphics tables */
        init_pathtable();
        init_nodetable();
        init_gstack();
        init_graytable();
        init_physical();
        init_halftone();

        op_initgraphics();
}


/**********************************************************************
 * Allocate space for tables.
 *
 * TITLE:       alloc_memory
 *
 * CALL:        alloc_memory()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near alloc_memory()
{
        path_table = (struct ph_hdr far *)
                     fardata((ufix32)(MAXGSL * sizeof(struct ph_hdr)));
        node_table = (struct nd_hdr far *)
                     fardata((ufix32)(MAXNODE * sizeof(struct nd_hdr)));
        edge_table = (struct edge_hdr far *)
                     fardata((ufix32)(MAXEDGE * sizeof(struct edge_hdr)));
        isp_table = (struct isp_data FAR *) edge_table; /* 3-16-91, Jack */
        last_isp_index = ((MAXEDGE * sizeof(struct edge_hdr)) / sizeof (struct isp_data)) - 1; /* 3-16-91, Jack */
        edge_ptr   = (struct edge_hdr far * far *)
                     fardata((ufix32)(MAXEDGE * sizeof(struct edge_hdr far *)));
        gray_table = (struct gray_hdr far *)
                     fardata((ufix32)(MAXGRAY * sizeof(struct gray_hdr)));
        spot_table = (ufix16 far *)
                     fardata((ufix32)(MAXSPOT * sizeof(ufix16)));
        gray_chain = (struct gray_chain_hdr far *)
                     fardata((ufix32)(MAXGRAYVALUE *
                     sizeof(struct gray_chain_hdr)));

        /* Global allocate for gs_stack & gray_map; @WIN */
        gs_stack = (struct gs_hdr far *)  /* takes from graphics.def */
                     fardata((ufix32)(MAXGSL * sizeof(struct gs_hdr)));
        gray_map = (real32 FAR *)         /* takes from image.c */
                     fardata((ufix32)(256 * sizeof(real32)));
}



/***********************************************************************
 * To initialize path-table.
 *
 * TITLE:       init_pathtable
 *
 * CALL:        init_pathtable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_pathtable()
{
        struct ph_hdr FAR *path;        /* @WIN */

        path = &path_table[0];
        path->rf = 0;
        path->flat = zero_f;
        path->head = path->tail = NULLP;
        path->previous = NULLP;
        path->cp_path = NULLP;          /* @CPPH */
}


/***********************************************************************
 * To initialize node-table.
 *
 * TITLE:       init_nodetable
 *
 * CALL:        init_nodetable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_nodetable()
{
        ufix  i;

        for(i=0; i<MAXNODE; i++) node_table[i].next = i + 1;
        node_table[MAXNODE-1].next = NULLP;
        freenode_list = 0;
}


/***********************************************************************
 * To initialize graphics-stack.
 *
 * TITLE:       init_gstack
 *
 * CALL:        init_gstack()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_gstack()
{
        GSptr = gs_stack;

        GSptr->path = 0;
        GSptr->clip_path.head = NULLP;
        GSptr->clip_path.tail = NULLP;
        GSptr->clip_path.inherit = FALSE;

        /* The following codes are to set up default graphics state.
         * It may be redundent, since at start-up time there is a PostScript
         * procedure to be loaded in the system for setting up the default
         * graphics state
         */

        /* set default CTM */
        GSptr->device.default_ctm[0] = (real32)(300. / 72.);
        GSptr->device.default_ctm[1] = (real32)0.0;
        GSptr->device.default_ctm[2] = (real32)0.0;
        GSptr->device.default_ctm[3] = (real32)(-300. / 72.);
        GSptr->device.default_ctm[4] = (real32)(-75.0);
        GSptr->device.default_ctm[5] = (real32)3268.0;

        GSptr->device.default_clip.lx = 0;
        GSptr->device.default_clip.ly = 0;
        /* @RESO_UPGR
        GSptr->device.default_clip.ux = 2399*8;
        GSptr->device.default_clip.uy = 3235*8;
        */
        GSptr->device.default_clip.ux = 2399 * ONE_SFX;
        GSptr->device.default_clip.uy = 3235 * ONE_SFX;

        GSptr->device.width  = 2400;            /* 8/22/89 */
        GSptr->device.height = 3236;            /* 8/22/89 */

        GSptr->device.chg_flg = TRUE;           /* @DEVICE */
        GSptr->device.nuldev_flg = NULLDEV;     /* 8-1-90 Jack Liaw */

        create_array(&GSptr->device.device_proc, 0);
        ATTRIBUTE_SET(&GSptr->device.device_proc, EXECUTABLE);

        GSptr->color.adj_gray = 0;       /* 9/22/1987 */
        GSptr->color.gray = (real32)0.0;
        TYPE_SET(&GSptr->font, NULLTYPE);
        GSptr->halftone_screen.chg_flag = TRUE;
        GSptr->halftone_screen.freq = (real32)60.0;
        GSptr->halftone_screen.angle = (real32)45.0;
        GSptr->halftone_screen.no_whites = -1;

        create_array(&GSptr->halftone_screen.proc, 0);
        ATTRIBUTE_SET(&GSptr->halftone_screen.proc, EXECUTABLE);

        GSptr->halftone_screen.spotindex = 0;

        create_array(&GSptr->transfer, 0);
        ATTRIBUTE_SET(&GSptr->transfer, EXECUTABLE);
        GSptr->flatness = (real32)1.0;

        /* dash pattern */
        GSptr->dash_pattern.pat_size = 0;       /* no dash pattern */
        GSptr->dash_pattern.dpat_on = TRUE;     /* solid line */

        /* gray mode 7-26-90 Jack Liaw */
        GSptr->graymode = FALSE;
        GSptr->interpolation = FALSE;
}

/***********************************************************************
 *
 * TITLE:       init_graytable
 *
 * CALL:        init_graytable()
 *
 * PARAMETERS:  none
 *
 * INTERFACE:   init_graphics
 *
 * CALLS:       none
 *
 * RETURN:      none
 *
 **********************************************************************/
static void near init_graytable()
{
        fix     i;
        real32  tmp;

        for(i = 0; i < 256; i++){
           tmp = (real32)(i/255.);
           gray_table[GSptr->color.adj_gray].val[i] = (fix16)(tmp * GRAYSCALE);
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\savetpzd.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 * This file contains routines to save a trapezoid as new clippath or
 * stroe in command buffer for performing scan conversion and rendering
 * rendering the image by the lower level graphics primitives.
 *
 *      Name:       savetpzd.c
 *
 *      Purpose:
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         8/13/88     Scan conversion enhancement :
 *                              This file is to replace the original "gfill.c"
 *                              for scan conversion enhancement.
 *                  10/18/88    source file reorganization for saving trapezoids
 *                              in command buffer instead of scanlines, i.e.
 *                              defer scan conversion at lower level graphics
 *                              primitives:
 *                              split scanconv.c => savetpzd.c & fillgb.c
 *                              savetpzd -- save trapezoid in command buffer
 *                              fillgb   -- perform scan conversion
 *                  11/09/88    modify save_tpzd for checking if the format of
 *                              the trapezoid is correct; Temp. solution, should
 *                              be revised later
 *                  1/12/89     modify save_tpzd(): not need to truncate
 *                              endpoints to pixels
 *                  1/25/89     save_tpzd(): expand bounding box of trapezoid :
 *                              get floor of topy & ceil of btmy
 *                  11/19/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include        <math.h>
#include        <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "font.h"
#include "font.ext"

static struct  tpzd_info near fill_info;

/* ********** static function declartion ********** */

#ifdef LINT_ARGS
/* for type checks of the parameters in function declarations */
static void near add_clip (struct tpzd FAR *);

#else
/* for no type checks of the parameters in function declarations */
static void near add_clip ();
#endif


/***********************************************************************
 * According to the type(fill_destination), this routine appends the input
 * trapezoid to current clip path, or calls lower level graphics primitives
 * fill_tpzd to render it to appropriate destination(cache, page, mask, or
 * seed pattern).
 *
 * TITLE:       save_tpzd
 *
 * CALL:        save_tpzd(tpzd)
 *
 * PARAMETERS:
 *              tpzd: a trapezoid
 *
 *              global variable: fill_destination
 *                      F_TO_CACHE -- fill to cache memory
 *                      F_TO_PAGE  -- fill to page
 *                      F_TO_CLIP  -- fill to clip mask
 *                      F_TO_IMAGE -- fill for image(build seed pattern)
 *                      SAVE_CLIP  -- save the tpzd as a new clip path
 *
 * INTERFACE:
 *
 * CALLS:       fill_tpzd
 *
 * RETURN:      None
 **********************************************************************/
void save_tpzd(tpzd)
struct tpzd FAR *tpzd;
{

        /* fix     lx, ux; */
        sfix_t  lx, ux; /* @RESO_UPGR */

#ifdef DBG
        printf("save_tpzd(): dest=%d\n\ttpzd=\n", fill_destination);
        printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
        printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif

        /* modify trapezoid if it is generated by shape_reduction incorrectly.
         * for error recovery
         */
        if (tpzd->topxl > tpzd->topxr) {
#ifdef DBGwarn
                printf("\07save_tpzd() error!");
                printf("topy=%f, topxl=%f, topxr=%f\n", SFX2F(tpzd->topy),
                        SFX2F(tpzd->topxl), SFX2F(tpzd->topxr));
                printf("btmy=%f, btmxl=%f, btmxr=%f\n", SFX2F(tpzd->btmy),
                        SFX2F(tpzd->btmxl), SFX2F(tpzd->btmxr));
#endif
                tpzd->topxl = tpzd->topxr;
        }

        /* save to current clip path */
        if (fill_destination == SAVE_CLIP) {
                add_clip(tpzd);
                return;
        }

        /* set bounding box of the trapezoid, used for lower level graphics
         * primitives
         */
        if (fill_destination == F_TO_CACHE) {
                /* bounding box is defined by cache mechanism */
                fill_info.BMAP = cache_info->bitmap;
                fill_info.box_w = cache_info->box_w;
                fill_info.box_h = cache_info->box_h;
        } else {
                lx = (tpzd->topxl < tpzd->btmxl) ? tpzd->topxl : tpzd->btmxl;
                ux = (tpzd->topxr > tpzd->btmxr) ? tpzd->topxr : tpzd->btmxr;
                lx = SFX2I_T(lx);  /* be consistent with gp_scanconv 2/12/92 */
                ux = SFX2I_T(ux);  /* be consistent with gp_scanconv 2/12/92 */
                fill_info.BOX_X = ALIGN_L(lx);
                fill_info.BOX_Y = SFX2I_T(tpzd->topy);  /* 1/25/89 */
                fill_info.box_w = ALIGN_R(ux) - fill_info.BOX_X + 1;
                /* fill_info.box_h = SFX2I(tpzd->btmy - tpzd->topy) + 1; */
                fill_info.box_h = SFX2I_T(tpzd->btmy + ONE_SFX - 1)
                                  - fill_info.BOX_Y + 1; /* 1/25/89 */
        }

        fill_tpzd (fill_destination, &fill_info, tpzd);

}


/***********************************************************************
 * Appends the input trapezoid to the new_clip structure. The new_clip is a
 * global variable, initialized by op_clip and op_eoclip, and will be set as
 * the new clip path in the graphics state after it has been set up.
 *
 * TITLE:       add_clip
 *
 * CALL:        add_clip(tpzd)
 *
 * PARAMETERS:
 *              tpzd: a trapezoid
 *
 *              global variable: new_clip, to save the new clip path
 *
 * INTERFACE:   Save_tpzd
 *
 * CALLS:       None
 *
 * RETURN:      None
 **********************************************************************/
static void near add_clip (tpzd)
struct tpzd FAR *tpzd;
{
        CP_IDX edge;
        struct nd_hdr FAR *ep;

        /* get a node */
        edge = get_node();
        if(edge == NULLP) {     /* 05/07/91, Out of node table */
                ERROR(LIMITCHECK);
                return;
        }
        ep = &node_table[edge];

        /* set up a new clip trapezoid */
        ep->CP_TOPY = tpzd->topy;
        ep->CP_TOPXL = tpzd->topxl;
        ep->CP_TOPXR = tpzd->topxr;
        ep->CP_BTMY = tpzd->btmy;
        ep->CP_BTMXL = tpzd->btmxl;
        ep->CP_BTMXR = tpzd->btmxr;
        if(new_clip.head == NULLP)
                new_clip.head = edge;
        else
                node_table[new_clip.tail].next = edge;
        new_clip.tail = edge;

        /* update bounding box of new_clip */
        if (ep->CP_TOPY < new_clip.bb_ly)
                new_clip.bb_ly = ep->CP_TOPY;
        if (ep->CP_TOPXL < new_clip.bb_lx)
                new_clip.bb_lx = ep->CP_TOPXL;
        if (ep->CP_TOPXR > new_clip.bb_ux)
                new_clip.bb_ux = ep->CP_TOPXR;
        if (ep->CP_BTMY > new_clip.bb_uy)
                new_clip.bb_uy = ep->CP_BTMY;
        if (ep->CP_BTMXL < new_clip.bb_lx)
                new_clip.bb_lx = ep->CP_BTMXL;
        if (ep->CP_BTMXR > new_clip.bb_ux)
                new_clip.bb_ux = ep->CP_BTMXR;

}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\scaling.c ===
/*
 * Copyright (c) 1991 Microsoft Corporation
 */

/***************************************************************************
 *
 *      Name:      scaling.c
 *
 *      Purpose:
 *
 *      Developer: S.Zhang
 *
 *      History:
 *         4/17/91      image_alloc(): return NIL if size not avavilabe
 *                      caller of image_alloc() should set ERROR(LIMITCHECK)
 *                      if return(NIL) from image_alloc.
 *      Version    Date        Comments
 *****************************************************************************/



// DJC added global include
#include "psglobal.h"



#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "image.h"
#include "halftone.h"
#include "fillproc.h"
#include "fillproc.ext"
#include                "win2ti.h"     /* @WIN */


#define     W_ALIGN(size) (((size) + sizeof(fix) - 1) & ~(sizeof(fix) - 1))
#define  register

/* macro for short word swap; @WIN 04-17-92 YM */
#ifdef  bSwap
#define ORSWAP(L)       ((ufix32) ((L) << 24) | ((L) >> 24) |            \
                (((L) << 8) & 0x00ff0000) | (((L) >> 8) & 0x0000ff00))
#define ANDNOTSWAP(L)   ((ufix32) ~(((L) << 24) | ((L) >> 24) |          \
                (((L) << 8) & 0x00ff0000) | (((L) >> 8) & 0x0000ff00)))
#else
#define ORSWAP(L)        (L)
#define ANDNOTSWAP(L)    (~L)
#endif  /*bSwap @WIN*/

// DJC move this structure definition above references by prototypes
struct OUTBUFFINFO
{
    fix16   repeat_y;       /* number of repeat in row */
    fix16  FAR *newdivc;    /* array of number of repeat in col for a pixel */
    ubyte  FAR *valptr0;    /* pointer to data */
    fix16   clipcol;        /* input col size */
    fix16   clipnewc;       /* output col size */
    fix16   clipx;          /* start data after clipping */
    ufix16  htsize;         /* halftone repeat pattern size */
    ufix16  httotal;        /* halftone size */
    ufix16  fbwidth;        /* frame buffer width in word */
    ufix16  fbheight;       /* height of the image @WIN_IM */
    ufix16  start_shift;    /* start position in a word */
    ubyte  FAR *htbound;    /* halftone pattern boundary in col */
    ubyte  FAR *htmin;      /* halftone pattern upper boundary in row */
    ubyte  FAR *htmax;      /* halftone pattern lower boundary in row */
    ubyte  FAR *htptr0;     /* halftone pattern pointer corresponding to data */
    ubyte  FAR *htmax0;     /* halftone pattern lower boundary in row for landscape*/
    ubyte  FAR *htmin0;     /* halftone pattern upper boundary in row for landscape*/
    ufix32 huge *outbuff0;   /* starting word of a line in frame buffer @WIN*/
    fix16   yout;           /* current line count of frame buffer */
    fix16   xout;           /* current col count of frame buffer */
    ubyte   gray[256];           /* convert gray_table for settransfer */
    ubyte   gray0;          /* gray value for 0 */
    ubyte   gray1;          /* gray value for 1 */
    ubyte   grayval;        /* current gray value */
};
/*********** functions declaration **********/
/* @WIN; add prototype */
void     Compress(IMAGE_INFOBLOCK FAR *);
void     Amplify(IMAGE_INFOBLOCK FAR *);
void     AmpInY(IMAGE_INFOBLOCK FAR *);
void     AmpInX(IMAGE_INFOBLOCK FAR *);
void     Calcmp(fix16 FAR *, fix16, float, fix16 FAR *, float);
void     Calamp(fix16 FAR *, fix16, float, fix16 FAR *, float);
void     Getdiv(fix16 FAR *, fix16, fix16, fix16 FAR *, fix16 FAR *);
void     CheckClip(fix16 FAR *, fix16 FAR *, fix16 FAR *,
         fix16 FAR *, fix16 FAR *, fix16 FAR * FAR *);
void     WriteImage(struct OUTBUFFINFO FAR *);
void     WriteImage1(struct OUTBUFFINFO FAR *);
byte     FAR *image_alloc(fix);      /*mslin*/

/***********  global vars  ***************/
#ifdef DBG_MS
  ufix32 dbgtm1,dbgtm2;
#endif


fix16         row, col;     /* raw image height(row) and width(col) */
float         xscale, yscale;       /* scale factor in x and y              */
static ubyte FAR *string;       /* pointer to I/O input  string         */
static int    cChar=0;      /* number of byte in string             */
static fix16 FAR *divr, FAR *divc;  /* pointer to the scaling factor array  */
static fix16  newc, newr;    /* new row and col value after scaling  */
static IMAGE_INFOBLOCK  FAR *image_scale_info;      /*mslin*/
static ubyte  smp_p_b;      /* samples per byte                     */
static ubyte  op_mode;      /* specify scale combinations,          */
static fix    RP_size;      /* repeat pattern size                  */
static ubyte FAR *HTRP;         /* repeat pattern                       */
static ubyte  xmove;        /* for rotation, draw from L->R or R->L */
static ubyte  ymove;        /* for rotation, draw from U->D or D->U */
byte         FAR *image_heap;       /* availabe free buffer                 */
ufix32        outbit;

/***********  extern declaration *********/

extern ubyte   image_dev_flag;     /*defined in image.c */
extern ubyte   image_logic_op;     /*defined in image.c */




/******************************************************************************
* This module read from the infoptr the matrix and other data for image scaling
* and rotation, prepare the halftone repeat pattern and call corresponding
* procedure to do the scale.

* TITLE      :  image_PortrateLandscape

* CALL       :  image_PortrateLandscape(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  scale_image_process()

* CALLS      :  Compress(), Amplify(), AmpInY(), AmpInX(), Calamp(), Calcmp()
                image_alloc()

* RETURN     : none

******************************************************************************/
void image_PortrateLandscape(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;

{
   fix16 i,j,k,l,m,n,ox,oy,x,y;
   ubyte FAR *gray;

/*mslin*/
#ifdef DBG
        {
        lfix_t       FAR *mtxptr;
        real32  m0, m1, m2, m3, m4, m5;

        mtxptr = infoptr->lfxm;
        m0 = LFX2F(mtxptr[0]);
        m1 = LFX2F(mtxptr[1]);
        m2 = LFX2F(mtxptr[2]);
        m3 = LFX2F(mtxptr[3]);
        m4 = LFX2F(mtxptr[4]);
        m5 = LFX2F(mtxptr[5]);
        printf("Enter image_PortrateLandscape\n");
        printf("[%f  %f  %f  %f  %f  %f]\n",
                m0, m1, m2, m3, m4, m5
        );
        printf("width=%d, height=%d, dev_buffer=%lx, dev_buffer_size=%lx\n",
                infoptr->raw_width, infoptr->raw_height, infoptr->dev_buffer,
                infoptr->dev_buffer_size);
        }

#endif

         image_scale_info = infoptr; /*mslin*/
         image_heap = (byte FAR *)image_scale_info->dev_buffer +
                image_scale_info->dev_buffer_size;

        /********  read first input data string ******************/

         if (interpreter(&infoptr->obj_proc))
            {
                ERROR(STACKUNDERFLOW);
                infoptr->ret_code = STACKUNDERFLOW;
                return;
            };
         /*mslin 5/02/91*/
         CHECK_STRINGTYPE();

         string = (ubyte FAR *) VALUE_OPERAND(0);
         if ((cChar = LENGTH_OPERAND(0)) == (ufix) 0)
            {
                infoptr->ret_code = NO_DATA;
                return;
            };

        /*********  Initialization       ***********************/

         smp_p_b = (ubyte) (8/infoptr->bits_p_smp);     //@WIN
         xmove = ymove =1;
         row = infoptr->raw_height;        /* original image height and width */
         col = infoptr->raw_width;
         RP_size = CGS_Patt_Size;

        /********* Build a gray table to map the spotorder
                      from 0 - (CGS_No_Pixels-1) to grayvalue from 0 - 255 ***/

         if ((gray = (ubyte FAR *)image_alloc(CGS_No_Pixels*sizeof(ubyte)))==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
         for(i=1; i<=CGS_No_Pixels;i++)
                   gray[i-1] = (ubyte) ((ufix32)(i*255)/CGS_No_Pixels); //@WIN

        /******** Build the halftone repeat pattern from the spotorder
                                       table CGS_SpotOrder *****************/

         HTRP = (ubyte FAR *)image_alloc(RP_size*RP_size*sizeof(ubyte));
         if (HTRP ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
         m = CGS_MajorFact*CGS_ScaleFact;
         n = CGS_MinorFact*CGS_ScaleFact;
         oy = 0;                                /* 5-2-91, shenzhi */
         ox = ((m==0)||(n==0)) ? 0:(RP_size-n); /* 5-2-91, shenzhi */
         for (k = 0; k < (RP_size/CGS_ScaleFact); k++)
               {
/*                ox = k*n; * 5-2-91, shenzhi */
/*                oy = k*m; * 5-2-91, shenzhi */
                  for (i=0; i< n; i++)
                    {
                       for (j=0; j< n; j++)
                         {
                           x = (ox+j)%(RP_size);
                           y = (oy+i)%(RP_size);
                           HTRP[y*RP_size+x] = gray[CGS_SpotOrder[i*n+j]];
                         };
                   };
                 l = n*n;
                 for (i=0; i< m; i++)
                   {
                      for (j=0; j< m; j++)
                        {
                          x = (ox+j+n)%(RP_size);
                          y = (oy+i)%(RP_size);
                          HTRP[y*RP_size+x] = gray[CGS_SpotOrder[i*m+l+j]];
                        };
                   };
                 ox+=n; /* 5-2-91, shenzhi */
                 oy+=m; /* 5-2-91, shenzhi */
               };

         if (image_dev_flag == PORTRATE)
          {
              /* [A 0 0 D Tx Ty] */
              xscale = LFX2F(infoptr->lfxm[0]);
              yscale = LFX2F(infoptr->lfxm[3]);
              if (xscale <0)
                     xmove = 0;           /*right to left */
              if (yscale <0)
                     ymove = 0;           /*bottom to top */
//            xscale = fabs(xscale);  @WIN
//            yscale = fabs(yscale);
              FABS(xscale, xscale);
              FABS(yscale, yscale);

          }
         else
          {
              /*[0 B C 0 Tx Ty] */
              xscale = LFX2F(infoptr->lfxm[1]);   /*x y scale is for image space */
              yscale = LFX2F(infoptr->lfxm[2]);   /* so read data remain unchanged */
              if (xscale <0)
                     ymove = 0;           /*bottom to top */
              if (yscale <0)
                     xmove = 0;           /*right to left */
//            xscale = fabs(xscale);    @WIN
//            yscale = fabs(yscale);
              FABS(xscale, xscale);
              FABS(yscale, yscale);

          };

        /************ alloc and init scaling factor arrays *****************/

         divr = (fix16 FAR *)image_alloc(sizeof(fix16)*row);        /* for row */
         if (divr==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

         divc = (fix16 FAR *)image_alloc(sizeof(fix16)*col);        /* for col */
         if (divc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

         for(i=0; i<row; i++)
            divr[i] = 0;
         for(i=0; i<col; i++)
            divc[i] = 0;
         if ((yscale >=(float)0.995) && (xscale >= (float)0.995)) //@WIN
           {
               if (yscale < (float)1.005)  /* if scaling within 1+- 0.005, regard it as 1 @WIN*/
                        yscale = (float)1.0;    //@WIN
                if (xscale < (float)1.005)      //@WIN
                        xscale = (float)1.0;    //@WIN
               //UPD055
               //Calamp(divr,row,yscale,&newr);
               Calamp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

               //UPD055
               //Calamp(divc,col,xscale,&newc);
               Calamp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));
               op_mode = 1;        /* amplify */
           }
          else
           {
               if ((yscale < (float)1.0) && (xscale < (float)1.0)) //@WIN
                 {
                    //UPD055
                    //Calcmp(divr,row,yscale,&newr);
                    Calcmp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                    //UPD055
                    //Calcmp(divc,col,xscale,&newc);
                    Calcmp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));

                    op_mode = 2;   /* compress */
                 }
                    else
                         if (yscale >=(float)1.0)       //@WIN
                            {
                               //UPD055
                               //Calamp(divr,row,yscale,&newr);
                               Calamp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                               //UPD055
                               //Calcmp(divc,col,xscale,&newc);
                               Calcmp(divc,col,xscale,&newc,LFX2F(infoptr->lfxm[4]));

                               op_mode = 3;  /* amplify in y only */
                            }
                         else
                            {
                               //UPD055
                               //Calcmp(divr,row,yscale,&newr);
                               Calcmp(divr,row,yscale,&newr, LFX2F(infoptr->lfxm[5]));

                               //UPD055
                               //Calamp(divc,col,xscale,&newc);
                               Calamp(divc,col,xscale,&newc, LFX2F(infoptr->lfxm[4]));

                                op_mode = 4;   /* amplify in x only */
                            };

           };
/* shenzhi
   printf("raw width high %d %d \n",col, row);
   printf("newc newr  %d %d  \n",newc, newr);
   printf("xscale yscale %f %f \n",xscale,yscale);
   printf("smp_p_b op_mode %d %d \n",smp_p_b, op_mode);
   printf("xorig,yorig %d %d\n",infoptr->xorig,infoptr->yorig);
*/

/****** according to op_mode value, call different procedure   ****/
/* these procedures are almost identical and they are seperated
   only for performance consideration                          ****/

   switch(op_mode)
    {
     case 0:
     case 1:
          Amplify(infoptr);
          break;
     case 2:
          Compress(infoptr);
          break;
     case 3:
          AmpInY(infoptr);
          break;
     case 4:
          AmpInX(infoptr);
    };
}


/******************************************************************************
* This module read input data and process the case xscale <1 and yscale <1.

* TITLE      :  Compress

* CALL       :  Compress(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/
void Compress(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,FAR *divcol,dx,ctIn,samps;
    fix16 i;
    fix16 y;
    fix16  slen;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16 xorig,yorig;
    struct OUTBUFFINFO writebuff;

    /************* initialization ***************/

    colval =newc;
      /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;        /* length of input string */
    ctIn =0;
    str = string;       /* begining of input string */
    samps = smp_p_b-1;  /* samples per byte -1 */
    /* alloc array for input data */
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

    strmax = string+slen;   /* end of input string */
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;  /* frame buffer width in word */
    writebuff.htsize = (ufix16)RP_size;       /* halftone repeat pattern size */
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.clipnewc = newc;
    writebuff.newdivc = (fix16 FAR *)image_alloc(newc*sizeof(fix16));
    if (writebuff.newdivc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };

    writebuff.clipx = 0;
    /* default clipping bounding box */

    /***********if clipping, calculate new origin, width, starting data,etc ***/
    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));
    for (i=0; i< writebuff.clipnewc; i++)
        writebuff.newdivc[i] = 1;                /* compress, each pixel has at most only one output */
    writebuff.clipcol =writebuff.clipnewc ;

#ifdef DBG
    printf("new xyorig clipx clipnewc %d %d %d %d\n",xorig,yorig,writebuff.clipx,writebuff.clipnewc);
#endif
/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout =yorig;
    writebuff.xout = xorig;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;       /* up right boundary */
            writebuff.htmax = HTRP + writebuff.httotal;    /* bottom right boundary */
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);    /* corresponding to starting pixel */
            writebuff.htbound +=writebuff.htsize;          /* right boundary */
       }
    else
       {
            writebuff.htmin = HTRP-1;            /* up left boundary */
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;     /* bottom left */
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;               /* left boundary */
       };
    writebuff.htmin0 = HTRP;            /* htmin0 and htmax0 are for landscape */
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;    /* starting pixel position in a word (0 if at left most )*/
    outbit = ONE1_32 LSHIFT writebuff.start_shift;

    /************* mapping graylevel of input data to the gray_table ****/

    j= 1<<infoptr->bits_p_smp;      /****input data graylevel ***/
    for (i=0; i<j; i++)
      {
       writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
      };

    writebuff.gray1 = writebuff.gray[j-1]; /*gray1 and gray0 is the grayvalue for 1 bit case: 0, 1***/
    writebuff.gray0 = writebuff.gray[0];

    /************draw one line each time. ***********/
    /************for line i, there are divr[i] lines of input data for it****/

    writebuff.repeat_y = 1;
    for(i=0; i< newr; i++)
     {
             divcol = divc;
             valptr = writebuff.valptr0;
             colval=newc;
             do
              {
                *valptr++ = 0;           /* initialization */
              } while (--colval);
             switch(infoptr->bits_p_smp)
              {
                    case 1:               /* 1 bit case */
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;        /* count the # of pixel in a input byte */
                               divcol = divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;     /* number of input data */
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };

                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if((x==0) && (y==1))
                                     {
                                        if (val &0x80)
                                          *valptr = 1;
                                        valptr++;
                                     };
                                     val <<=1;
                                   };
                                } while (--colval);
                           };      /* end of preparing a output line */
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC          PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);

                          break;
                    case 2:           /*****2 bit case *******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol= divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/


                                     if((x==0) &&(y==1))
                                      {
                                        *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                      };
                                     val <<=2;
                                   };
                                } while (--colval);
                           };

                          break;
                    case 4:                    /**** 4 bit case *******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if ((x==0)&&(y==1))
                                      {
                                        *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                      };
                                     val <<=4;
                                   };
                                } while (--colval);
                           };
                          break;
                    case 8:                /***8 bit case ******/
                          for (y=divr[i]; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol=divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                    /******for a input line of length col
                                    * only data at position 0, divc[0],...
                                    *are used others are discarded   ***/

                                     if ((x==0)&&(y==1))
                                        *valptr++ = *str;
                                     str++;
                                   };
                                } while (--colval);
                           };
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                  // WriteImage(&writebuff);      // @WIN_IM
                  if(bGDIRender)
                    // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                    // DJC                PROC_IMAGE, (LPSTR)&writebuff);
                    ; // DJC
                  else
                    WriteImage(&writebuff);
               };
     };

}


/******************************************************************************
* This module read input data and process the case xscale >=1 and yscale >=1.

* TITLE      :  Amplify

* CALL       :  Amplify(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void Amplify(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,ctIn,samps,FAR *divcol;
    fix16 i;
//  fix16 y;    @WIN
    fix16  slen;
    register ubyte FAR *valptr,val;
    register ubyte FAR *str,FAR *strmax;
    fix16 xorig,yorig;
    struct OUTBUFFINFO writebuff;
    fix16 WinXorig;                           // @WIN
    fix16 WinYorig;                           // @WIN

    /*******initiate **************/
    colval =col;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0= (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    WinXorig = xorig;                           // @WIN
    WinYorig = yorig;                           // @WIN
    writebuff.newdivc = divc;
    writebuff.clipnewc = newc;
    writebuff.clipcol = col;
    writebuff.clipx = 0;
    /* clipping bounding box */

    /***********if clipping, calculate new origin, width, starting data,etc ***/

    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
x = xorig;
    writebuff.yout = yorig;
    writebuff.xout = xorig;

    /***************same as Compress(), see comments of Compress() ****/

//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
    writebuff.gray1 = writebuff.gray[j-1];   /* 1 bit case, gray corresponding 1 */
    writebuff.gray0 = writebuff.gray[0];     /* 1 bit case, gray corresponding 0 */
#ifdef DBG_MS
    dbgtm1 = curtime();
#endif
    for(i=0; i< row; i++)
     {
             valptr = writebuff.valptr0;
             ctIn =0;
             colval = col;
             writebuff.repeat_y = divr[i];
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (val >=128)  /* equal to (val & 0x80) */
                                        *valptr++ = 1;
                                     else
                                        *valptr++ = 0;
                                     val <<=1;
                             } while (--colval);
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                            if (image_dev_flag == PORTRATE) {     //@WIN_IM
                               // DJC GDIBitmap(WinXorig, WinYorig,
                               // DJC          newc, writebuff.repeat_y, (ufix16)NULL,
                               // DJC          PROC_IMAGE1, (LPSTR)&writebuff);
                               WinYorig += writebuff.repeat_y;
                            } else {
                               // DJC GDIBitmap(WinXorig, WinYorig,
                               // DJC           writebuff.repeat_y, newc, (ufix16)NULL,
                               // DJC           PROC_IMAGE1, (LPSTR)&writebuff);
                               WinXorig += writebuff.repeat_y;
                            }
                          else
                            WriteImage1(&writebuff);
                          break;
                    case 2:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     *valptr++ = (ubyte)((val & 0xc0)>>6);//@WIN
                                     val <<=2;
                             } while (--colval);
                          break;
                    case 4:
                          do
                             {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     *valptr++ = (ubyte)((val & 0xf0)>>4); //@WIN
                                     val <<=4;

                             } while (--colval);
                          break;
                    case 8:
                          do
                             {
                                        if (str ==strmax )
                                          {
                                            /* pop last string on operand stack */
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          }
                                        *valptr++ = *str++;
                             } while (--colval);
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                  // WriteImage(&writebuff);      // @WIN_IM
                  if(bGDIRender)
                      if (image_dev_flag == PORTRATE) {     //@WIN_IM
                         // DJC GDIBitmap(WinXorig, WinYorig,
                         // DJC           newc, writebuff.repeat_y, (ufix16)NULL,
                         // DJC           PROC_IMAGE, (LPSTR)&writebuff);
                         WinYorig += writebuff.repeat_y;
                      } else {
                         // DJC GDIBitmap(WinXorig, WinYorig,
                         // DJC           writebuff.repeat_y, newc, (ufix16)NULL,
                         // DJC          PROC_IMAGE, (LPSTR)&writebuff);
                         WinXorig += writebuff.repeat_y;
                      }
                  else
                      WriteImage(&writebuff);
               };
     };
#ifdef DBG_MS
     dbgtm2=curtime();
#endif
}

/******************************************************************************
* This module calculate the new origins, new size of col, starting point
* of input data, etc after clipping.

* TITLE      :  CheckClip

* CALL       :  CheckClip(xorig,yorig,clipnewc,clipcol,clipx,newdivc)

* PARAMETERS :  xorig,yorig: the x y origin of the image in frame buffer
                clipnewc   : new scaled width after clipping
                clipcol    : new non_sclaed width after clipping
                clipx      : new starting point of input data
                newdivc    : new scale factor array after clipping
* INTERFACE  :  Compress(), Amplify(), AmpInY(), AmpInX()

* CALLS      :  Getdiv()

* RETURN     : none

******************************************************************************/

void CheckClip(xorig,yorig,clipnewc,clipcol,clipx,newdivc)
fix16 FAR *xorig,FAR *yorig,FAR *clipnewc,FAR *clipcol,FAR *clipx,FAR * FAR *newdivc;
{
           fix16 lx,ly,ux,uy;
           fix16 x,y;

           ux = SFX2I(GSptr->clip_path.bb_ux);
           lx = SFX2I(GSptr->clip_path.bb_lx);
           uy = SFX2I(GSptr->clip_path.bb_uy);
           ly = SFX2I(GSptr->clip_path.bb_ly);

           if (image_dev_flag == PORTRATE)
              {
                 if (xmove)
                   {
                      x = *xorig +newc-1;
                      if ((*xorig >ux)|| (x < lx))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*xorig < lx)
                              {
                               *clipx = lx-*xorig;
                               *xorig = lx;
                              };
                            if (x>ux)
                              *clipnewc = ux - *xorig+1;
                            else
                              *clipnewc = x - *xorig+1;

          /*****scale factor needs to be recalculated only for amplifying case ***/
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };

                       };
                   }
                 else
                   {
                      x = *xorig -newc+1;
                      if ((*xorig <lx)|| (x >ux))
                         {
                            *clipcol = 0;
                            *clipnewc =0;
                         }
                      else
                       {
                            if (*xorig > ux)
                              {
                               *clipx = *xorig-ux;
                               *xorig = ux;
                              };
                            if (x<lx)
                              *clipnewc = *xorig-lx+1;
                            else
                              *clipnewc = *xorig-x+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   };
              }
           else
              {
                if (ymove)
                   {
                      y = *yorig +newc-1;
                      if ((*yorig >uy)|| (y <ly))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*yorig < ly)
                              {
                               *clipx = ly-*yorig;
                               *yorig = ly;
                              };
                            if (y>uy)
                              *clipnewc = uy - *yorig+1;
                            else
                              *clipnewc = y - *yorig+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                               *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                               Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   }
                else
                   {
                      y = *yorig -newc+1;
                      if ((*yorig <ly)|| (y >uy))
                         {
                            *clipnewc =0;
                            *clipcol = 0;
                         }
                      else
                       {
                            if (*yorig > uy)
                              {
                               *clipx = *yorig - uy;
                               *yorig = uy;
                              };
                            if (y<ly)
                              *clipnewc = *yorig -ly+1;
                            else
                              *clipnewc = *yorig -y+1;
                            if ((op_mode !=2) && (op_mode !=3))
                            {
                                *newdivc = (fix16 FAR *)image_alloc(col*sizeof(fix16));
                                if (*newdivc ==NIL)
                                 {
                                   ERROR(LIMITCHECK);
                                   return;
                                 };
                                Getdiv(*newdivc,*clipx,*clipnewc,clipcol,clipx);
                            };
                       };
                   };
              };

}


/******************************************************************************
* This module calculate new scale factor array from the scalefactor array
* divc or divr by applying clipping to it.

* TITLE      :  Getdiv

* CALL       :  Getdiv(div, clipx,clipnewc,clipcol,newclipx)

* PARAMETERS :  div        : pointer to the new scale factor array
                clipx      : starting point of clipped output(0 if no clipping)
                clipnew    : clipped out put width.
                clipcol    : clipped input width
                newclipx   : starting point of clipped input(0 if no clipping)


* INTERFACE  :  CheckClip()

* CALLS      :  none

* RETURN     :  none

******************************************************************************/

void Getdiv(div, clipx,clipnewc,clipcol,newclipx)
fix16 FAR * div;
fix16 clipx;
fix16 clipnewc;
fix16 FAR *clipcol;
fix16 FAR *newclipx;
{
//  ufix16 a,b,i,j;     //@WIN
    fix16 a,b,i,j;

    a=b=i=j=0;
    while (a < clipx)
     {
        a+=divc[i++];
     };
    *newclipx = i;
    if (a>clipx)
         {
           div[j++] = a-clipx;
           *newclipx -=1;
           b = div[0];
         };
    while (b < clipnewc)
      {
         b+=divc[i];
         div[j++] = divc[i++];
      };
    if (b>clipnewc)
      div[j-1] -=(b-clipnewc);
    *clipcol = j;
}


/******************************************************************************
* This module calculate for each input pixel i, the number of output
* pixels div[i] corresponding to it.

* TITLE      :  Calamp

* CALL       :  Calamp(div,size,scale,newsize)

* PARAMETERS :  div    : pointer to scale factor array
                size   : input size(width or height)
                scale  : scale factor
                newsize: size after scaling

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  none

* RETURN     : none

******************************************************************************/

//void Calamp(div,size,scale,newsize)???@WIN; void the waring message from C6.0
//fix16 FAR * div;
//fix16 size;
//float scale;
//fix16 FAR *newsize;
void Calamp(fix16 FAR * div, fix16 size, float scale, fix16 FAR *newsize,float disp)
{
  fix32 cReal;
  fix32 cOut,cIn,scale1;
  //UPD055
  fix32 divsum;
  float f1;
  fix32 cOuttune;

  if ( disp < 0.0 ) {
      disp = (float)0.0;
  }


  scale1 = (fix32)(scale*256);
  cOut = (fix32)((((fix16)(disp / scale)) * scale) + .5);
  cOut = cOut << 8;

  cReal = (fix32) (disp * 256 + .5 );

  if ((cReal - cOut ) > 256 ) {
     f1 = scale / (fix32)(scale+.5);
     cOuttune = (fix32)(f1*256 + .5);
     cOut += cOuttune * ((fix32)floor((cReal - cOut) / cOuttune));
  }


  *newsize = 0;
  divsum = 0;


  for(cIn =0; cIn<size; cIn++)
      {
          cReal +=scale1;
          div[cIn] = (fix16) ((cReal+128 -cOut)>>8);    //@WIN
          //DJC cOut +=div[cIn]<<8;
          divsum += div[cIn];

          cOut +=((fix32)div[cIn]) << 8;
      };
  *newsize = (fix16)(divsum);  //@WIN
}



/******************************************************************************
* This module calculate for each output pixel i, the position of input
* pixel div[i] corresponding to it.

* TITLE      :  Calcmp

* CALL       :  Calcmp(div,size,scale,newsize)

* PARAMETERS :  div    : pointer to scale factor array
                size   : input size(width or height)
                scale  : scale factor
                newsize: size after scaling

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  none

* RETURN     : none

******************************************************************************/

//void Calcmp(div,size,scale,newsize)???@WIN; void the waring message from C6.0
//fix16 FAR * div;
//fix16 size;
//float scale;
//fix16 FAR *newsize;
void Calcmp(fix16 FAR * div, fix16 size, float scale, fix16 FAR *newsize, float disp)
{
  fix32 scale1,cReal;
  fix32 cIn, cOut,size1,cOut1;
  float f1;
  fix32 cOuttune;



  //UPD055
  scale1 = (fix32)(256.0 / scale + .5);
  cOut = ((lfix_t)(floor(((ROUND(disp) - disp)) * 256 + 0.5)));

  cOuttune = cOut;
  cReal = 0;
  cIn = 0;
  size1 = ((fix32)size << 8) + cOut;
  while( cOut < size1) {

     cReal += scale1;
     div[cIn] = (fix16) ((cReal + 128 - cOut) >> 8);
     cOut += (fix32) div[cIn++] << 8;
  }
  cOut = (cOut - cOuttune) >> 8;
  if (cOut > size) {
     div[cIn-1] -= (fix16)(cOut - size);
  }
  *newsize = (fix16)cIn;



#ifdef DJC_OLD_CODE
  cReal = 0;
  cOut = 0;
  cIn =0;
  //DJC size1 = size<<8;
  size1 = (fix32) size<<8;
  scale1 = (fix32)(256.0 /scale+0.5);
  while (cOut < size1 )
   {
       cReal +=scale1;
       div[cIn] = (fix16) ((cReal+cIn%5 - cOut)>>8);    //@WIN
       //DJC cOut +=div[cIn++]<<8;
       cOut +=(fix32)div[cIn++]<<8;
   };
  cOut >>=8;
  if (cOut > size)
       div[cIn-1] -=(fix16)(cOut-size); //@WIN
  *newsize = (fix16)cIn;        //@WIN
#endif

}


/******************************************************************************
* This module read input data and process the case xscale < 1 and yscale >=1.

* TITLE      :  AmpInY

* CALL       :  AmpInY(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void AmpInY(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,dx,ctIn,samps,FAR *divcol;
    fix16 i;
//  fix16 y;    @WIN
    fix16  slen;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16  xorig,yorig;
    struct OUTBUFFINFO writebuff;

    /* shenzhi */

    colval =newc;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.clipnewc = newc;
    writebuff.newdivc = (fix16 FAR *)image_alloc(newc*sizeof(fix16));
    if (writebuff.newdivc==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    writebuff.clipx =0;
    /* clipping bounding box */

    if (image_logic_op & IMAGE_CLIP_BIT)
       CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));
    for (i=0; i< writebuff.clipnewc; i++)
        writebuff.newdivc[i] = 1;                /* compress, each pixel has at most only one output */
    writebuff.clipcol =writebuff.clipnewc ;

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout =yorig;
    writebuff.xout = xorig;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
    writebuff.gray1 = writebuff.gray[j-1];
    writebuff.gray0 = writebuff.gray[0];
    for(i=0; i< row; i++)
     {
             writebuff.repeat_y = divr[i];
             valptr = writebuff.valptr0;
             divcol = divc;
             colval=newc;
             do
              {
                *valptr++ = 0;
              } while (--colval);
             valptr = writebuff.valptr0;
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          ctIn =0;
                          divcol = divc;
                          colval=newc;
                          do
                           {
                            dx = *divcol++;
                            for(x=0; x<dx;x++)
                              {
                                if (ctIn-- ==0)
                                  {
                                   if (str ==strmax )
                                     {
                                       POP(1);

                                       if (interpreter(&(infoptr->obj_proc)))
                                        {

                                           ERROR(STACKUNDERFLOW);
                                           infoptr->ret_code = STACKUNDERFLOW;
                                           return;
                                        }
                                       /*mslin 5/02/91*/
                                       CHECK_STRINGTYPE();
                                       str = (ubyte FAR *) VALUE_OPERAND(0);
                                       if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                        {
                                           infoptr->ret_code = NO_DATA;
                                           return;
                                        }
                                       strmax = str+slen;

                                     };
                                    val = *str++;
                                    ctIn = samps;
                                  };
                                if (x ==0)
                                 {
                                  if (val &0x80)
                                    *valptr = 1;
                                  valptr++;
                                 };
                                val <<=1;
                              };
                           } while (--colval);
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC        PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);
                          break;
                    case 2:
                               ctIn =0;
                               divcol= divc;
                               colval=newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx;x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (x==0)
                                         *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                     val <<=2;
                                   };
                                } while (--colval);

                          break;
                    case 4:
                               ctIn =0;
                               divcol = divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (x==0)
                                        *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                     val <<=4;
                                   };
                                } while (--colval);
                          break;
                    case 8:
                               divcol=divc;
                               colval = newc;
                               do
                                {
                                 dx = *divcol++;
                                 for(x=0; x<dx; x++)
                                   {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                     if (x==0)
                                          *valptr++ = *str;
                                     str++;
                                   };
                                } while (--colval);
                          break;
              };
             if (infoptr->bits_p_smp !=1)
                {
                     // WriteImage(&writebuff);      // @WIN_IM
                     if(bGDIRender)
                        // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                        // DJC       PROC_IMAGE, (LPSTR)&writebuff);
                        ; // DJC
                     else
                        WriteImage(&writebuff);
                };
     };

}






/******************************************************************************
* This module read input data and process the case xscale >= 1 and yscale < 1

* TITLE      :  AmpInX

* CALL       :  AmpInX(infoptr)

* PARAMETERS :  infoptr : is a data structure defined in image.h

* INTERFACE  :  image_PortrateLandscape()

* CALLS      :  image_alloc(), CheckClip()

* RETURN     : none

******************************************************************************/

void AmpInX(infoptr)
IMAGE_INFOBLOCK FAR *infoptr;
{
    register fix16 j,x,colval,ctIn,samps,FAR *divcol;
    fix16 i;
    fix16 y;
    fix16  slen,thres;
    register ubyte FAR *valptr;
    register ubyte FAR *str,FAR *strmax,val;
    fix16  xorig,yorig;
    struct OUTBUFFINFO writebuff;
    /* shenzhi */



    colval =col;
    /* current gray used for imagemask */
    writebuff.grayval = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[CGS_GrayIndex])*255)>>14);
                                                        /* @WIN */
    slen = (fix16)cChar;
    ctIn =0;
    str = string;
    samps = smp_p_b-1;
    writebuff.valptr0 = (ubyte FAR *)image_alloc(colval*sizeof(ubyte));
    if ( writebuff.valptr0 ==NIL)
         {
               ERROR(LIMITCHECK);
               return;
         };
    strmax = string+slen;
    divcol = divc;
    writebuff.fbwidth = FB_WIDTH>>5;
    writebuff.htsize = (ufix16)RP_size;
    writebuff.httotal = writebuff.htsize*writebuff.htsize;
    xorig = infoptr->xorig;
    yorig = infoptr->yorig;
    writebuff.newdivc = divc;
    writebuff.clipnewc = newc;
    writebuff.clipcol = col;
    writebuff.clipx = 0;

    if (image_logic_op & IMAGE_CLIP_BIT)
        CheckClip(&xorig,&yorig,&(writebuff.clipnewc),&(writebuff.clipcol),&(writebuff.clipx),&(writebuff.newdivc));

/****************************************************************************

          note: 1. '*' is the pixel we want to set in frame buffer.
                2. '*' in Halftone repeatpattern is the pixel corresponding
                   to '*' in frame buffer.
                3. outbuff1 is the pointer to the word in frame buffer that
                   the pixel is going to write.
                4. htptr1 is the pointer to the halftone value corresponding
                   to the pixel.
                5. the pixel is set by doing *outbuff1 |=bt, while bt is a word
                   with only one bit set.
          ___________________________________________
FB_ADDR-> |           frame buffer                  |
          |                                         |
          |                                         |
          |                                         |
          |                                         |
          |       (xorig, yorig)                    |
          |             \                           |
          |   outbuff0 -> \ ______________          |
          |                 |  image     |          |
          |                 |            |          |
          |                 |            |          |
          |       outbuff1 -|--> *       |          |
          |                 |            |          |
          |                 |            |          |
          |                 |____________|          |
          |                                         |
          |                                         |
          |_________________________________________|



case xmove:     =1(L->R)                                     =0(R->L)

    HTRP->__________________ <-htmin               HTRP->_________________
          |                |                      htmin->|               |
          |                |                             |               |
   htptr1 |  --->*         |<--htbound         htbound ->|     * <-htptr1|
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |                |                             |               |
          |________________| <-htmax              htmax->|_______________|


****************************************************************************/
    writebuff.yout = yorig;
    writebuff.xout = xorig;
    x = xorig;
//  writebuff.outbuff0 = (ufix32 FAR *)FB_ADDR +yorig*writebuff.fbwidth;@WIN
    writebuff.outbuff0 = (ufix32 huge *)FB_ADDR +(ufix32)yorig*(ufix32)writebuff.fbwidth;
    writebuff.outbuff0 += x>>5;
    if (xmove)
       {
            writebuff.htmin = HTRP+writebuff.htsize;
            writebuff.htmax = HTRP + writebuff.httotal;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound +=writebuff.htsize;
       }
    else
       {
            writebuff.htmin = HTRP-1;
            writebuff.htmax = HTRP -1+ writebuff.httotal-writebuff.htsize;
            writebuff.htbound = HTRP + (yorig % writebuff.htsize)*writebuff.htsize;
            writebuff.htptr0 = writebuff.htbound + (x%writebuff.htsize);
            writebuff.htbound -=1;
       };
    writebuff.htmin0 = HTRP;
    writebuff.htmax0 = HTRP+writebuff.httotal-1;
    writebuff.start_shift = x & 0x1f;
    outbit = ONE1_32 LSHIFT writebuff.start_shift;
    j= 1<<infoptr->bits_p_smp;
    for (i=0; i<j; i++)
        writebuff.gray[i] = (ubyte)(((ufix32)(gray_table[GSptr->color.adj_gray].val[i*255/(j-1)])*255)>>14);
                                                        /* @WIN */
                            /*** grayscale is 0x4000 */
    writebuff.gray1 = writebuff.gray[j-1];
    writebuff.gray0 = writebuff.gray[0];
    writebuff.repeat_y = 1;

    for(i=0; i< newr; i++)
     {
             divcol = divc;
             valptr = writebuff.valptr0;
             colval=col;
             thres = divr[i];
             do
              {
                *valptr++ = 0;
              } while (--colval);
             switch(infoptr->bits_p_smp)
              {
                    case 1:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval=col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y == 1)
                                       {
                                         if (val & 0x80)
                                                *valptr = 1;
                                         valptr++;
                                       };
                                     val <<=1;
                                } while (--colval);
                           };
                          // WriteImage1(&writebuff);      // @WIN_IM
                          if(bGDIRender)
                             // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                             // DJC       PROC_IMAGE1, (LPSTR)&writebuff);
                             ; // DJC
                          else
                             WriteImage1(&writebuff);
                          break;
                    case 2:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol= divc;
                               colval=col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y==1)
                                         *valptr++ = (ubyte)((val &0xc0)>>6);//@WIN
                                     val <<=2;
                                } while (--colval);
                           };

                          break;
                    case 4:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               ctIn =0;
                               divcol = divc;
                               colval = col;
                               do
                                {
                                     if (ctIn-- ==0)
                                       {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                         val = *str++;
                                         ctIn = samps;
                                       };
                                     if (y==1)
                                         *valptr++ = (ubyte)((val &0xf0) >>4);//@WIN
                                     val <<=4;
                                } while (--colval);
                           };
                          break;
                    case 8:
                          for (y=thres; y>0; y--)
                           {
                               valptr = writebuff.valptr0;
                               divcol=divc;
                               colval = col;
                               do
                                {
                                        if (str ==strmax )
                                          {
                                            POP(1);

                                            if (interpreter(&(infoptr->obj_proc)))
                                             {

                                                ERROR(STACKUNDERFLOW);
                                                infoptr->ret_code = STACKUNDERFLOW;
                                                return;
                                             }
                                            /*mslin 5/02/91*/
                                            CHECK_STRINGTYPE();
                                            str = (ubyte FAR *) VALUE_OPERAND(0);
                                            if ((slen = LENGTH_OPERAND(0)) == (ufix)0)
                                             {
                                                infoptr->ret_code = NO_DATA;
                                                return;
                                             }
                                            strmax = str+slen;

                                          };
                                     if (y==1)
                                        *valptr++ = *str;
                                      str++;
                                } while (--colval);
                           };
                          break;
              };
             if (infoptr->bits_p_smp !=1)
               {
                     // WriteImage(&writebuff);      // @WIN_IM
                     if(bGDIRender)
                        // DJC GDIBitmap(xorig, yorig, newc, newr, (ufix16)NULL,
                        // DJC       PROC_IMAGE, (LPSTR)&writebuff);
                        ; // DJC
                     else
                        WriteImage(&writebuff);
               };
     };

}


/******************************************************************************
* This procedure receives a data structure containing : number of repeat in row,
* number of repeat for a data in col, col length, pointer to data,
* starting word in frame buffer, starting position in a word,
* halftone pointer, halftone boundaries.
* Then output the data to frame buffer.

* TITLE      :  WriteImage

* CALL       :  WriteImage(writebuffptr)

* PARAMETERS :  writebuffptr: pointer to a data struct containing all infos
                for writing a line(or several lines) for a dataline.

* INTERFACE  :  Compress(), Amplify(), AmpInY(), ampInX()

* CALLS      :  none

* RETURN     : none

******************************************************************************/
void WriteImage(writebuffptr)
struct OUTBUFFINFO FAR *writebuffptr;
{
//  ufix16           y;         @WIN
    fix16           y;
    fix16           FAR *divcol;        /* array of number of repeat in col for a pixel */
    fix16            colval;
    register ubyte  FAR *valptr;        /* pointer to data */
    ufix16           htsize;         /* halftone repeat pattern size */
    ufix16           httotal;        /* halftone size */
    ufix16           fbwidth;        /* frame buffer width in word */
    register ubyte  FAR *htbound;        /* halftone pattern boundary in col */
    ubyte           FAR *htmin;          /* halftone pattern upper boundary in row */
    ubyte           FAR *htmax;          /* halftone pattern lower boundary in row */
    register ubyte  FAR *htptr1;
    ubyte           FAR *htmax0;         /* halftone pattern lower boundary in row for landscape*/
    ubyte           FAR *htmin0;         /* halftone pattern upper boundary in row for landscape*/
    register ufix32 huge *outbuff1;      /* starting word of a line in frame buffer @WIN*/
    register ufix32  dx,bt;
    register ubyte   val;
    register ubyte  FAR *gray;           /* convert gray_table for settransfer */
    fix16            ux,uy,lx,ly;


    htsize =writebuffptr->htsize;
    httotal =writebuffptr->httotal;
    fbwidth =writebuffptr->fbwidth;
    htbound =writebuffptr->htbound;
    htmin =writebuffptr->htmin;
    htmax =writebuffptr->htmax;
    htmax0 =writebuffptr->htmax0;
    htmin0 =writebuffptr->htmin0;
    gray =writebuffptr->gray;
    /* clipping bounding box */
    ux = SFX2I(GSptr->clip_path.bb_ux);
    lx = SFX2I(GSptr->clip_path.bb_lx);
    uy = SFX2I(GSptr->clip_path.bb_uy);
    ly = SFX2I(GSptr->clip_path.bb_ly);
    bt = outbit;
    if ((image_dev_flag == PORTRATE) && (xmove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0 + writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            bt = ONE1_32 LSHIFT writebuffptr->start_shift;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                /*check clipping in image row */
            if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
              {
               do
                  {
                                /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1++ > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         if ((bt LSHIFTEQ 1) ==0)
                           {
                              outbuff1++;
                              bt = ONE1_32;
                           };
                         if (htptr1 ==htbound)
                               htptr1 -=htsize;
                      } while (--dx);
                 } while (--colval);
              };
            if (ymove)
              {
                  htbound +=htsize;
                  writebuffptr->htptr0 += htsize;
                  writebuffptr->outbuff0 +=fbwidth;
                  if (htbound > htmax)
                     {
                         htbound = htmin;
                         writebuffptr->htptr0 -=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout++;
              }
            else
              {
                  htbound -=htsize;
                  writebuffptr->htptr0 -= htsize;
                  writebuffptr->outbuff0 -=fbwidth;
                  if (htbound < htmin)
                     {
                         htbound = htmax;
                         writebuffptr->htptr0 +=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout--;
              };
         };                           /* end if portrait */
    if ((image_dev_flag == PORTRATE)&& (!xmove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            bt = ONE1_32 LSHIFT writebuffptr->start_shift;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                      /*check clipping in image row */
            if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
             {
               do
                  {
                                      /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1-- > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         if ((bt RSHIFTEQ 1) ==0)
                           {
                              outbuff1--;
                              bt = ONE8000;
                           };
                         if (htptr1 ==htbound)
                               htptr1 +=htsize;
                      } while (--dx);
                 } while (--colval);
             };
            if (ymove)
              {
                  htbound +=htsize;
                  writebuffptr->htptr0 += htsize;
                  writebuffptr->outbuff0 +=fbwidth;
                  if (htbound > htmax)
                     {
                         htbound = htmin;
                         writebuffptr->htptr0 -=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout++;
              }
            else
              {
                  htbound -=htsize;
                  writebuffptr->htptr0 -= htsize;
                  writebuffptr->outbuff0 -=fbwidth;
                  if (htbound < htmin)
                     {
                         htbound = htmax;
                         writebuffptr->htptr0 +=httotal;
                     };
                  writebuffptr->htbound = htbound;
                  writebuffptr->yout--;
              };
         };                    /* end if updown */
    if ((image_dev_flag == LANDSCAPE)&&(ymove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                      /*check clipping in image row */
            if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
             {
               do
                  {
                                      /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1 > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         outbuff1 +=fbwidth;
                         if ((htptr1+=htsize) > htmax0)
                               htptr1 -=httotal;
                      } while (--dx);
                 } while (--colval);
             };
            if (xmove)
              {
                  if (++writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 -=htsize;
                  if ((bt LSHIFTEQ 1)==0)
                     {
                           bt = ONE1_32;
                           writebuffptr->outbuff0 +=1;
                     };
                  writebuffptr->xout++;
              }
            else
              {
                  if (--writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 +=htsize;
                  if ((bt RSHIFTEQ 1)==0)
                     {
                           bt = ONE8000;
                           writebuffptr->outbuff0 -=1;
                     };
                  writebuffptr->xout--;
              }

         };             /* end if top->down land */
    if ((image_dev_flag == LANDSCAPE) && (!ymove))
        for (y=0; y<writebuffptr->repeat_y; ++y)
         {
            colval = writebuffptr->clipcol;
            valptr = writebuffptr->valptr0+writebuffptr->clipx;
            divcol = writebuffptr->newdivc;
            outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                if(!xmove) outbuff1 += fbwidth-1;
                if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
            htptr1 = writebuffptr->htptr0;
                                     /*check clipping in image row */
            if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
              {
               do
                  {
                                     /* consider settransfer */
                     val = gray[*valptr++];
                     dx = *divcol++;
                     do
                      {
                         if (*htptr1 > val)
//                                *outbuff1 |=bt;     @WIN_IM; swap it
                                  *outbuff1 |= ORSWAP(bt);
                         outbuff1 -=fbwidth;
                         if ((htptr1-=htsize) < htmin0)
                               htptr1 +=httotal;
                      } while (--dx);
                 } while (--colval);
              };
            if (xmove)
              {
                  if (++writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 -=htsize;
                  if ((bt LSHIFTEQ 1)==0)
                     {
                           bt = ONE1_32;
                           writebuffptr->outbuff0 +=1;
                     };
                  writebuffptr->xout++;
              }
            else
              {
                  if (--writebuffptr->htptr0 ==htbound)
                           writebuffptr->htptr0 +=htsize;
                  if ((bt RSHIFTEQ 1)==0)
                     {
                           bt = ONE8000;
                           writebuffptr->outbuff0 -=1;
                     };
                  writebuffptr->xout--;
              }

         };             /* end if bottom->up land */
         outbit = bt;


}



/******************************************************************************
* This procedure receives a data structure containing : number of repeat in row,
* number of repeat for a data in col, col length, pointer to data,
* starting word in frame buffer, starting position in a word,
* halftone pointer, halftone boundaries.
* Then output the data to frame buffer.
* This is the same as WriteImage except it for 1 bit case.

* TITLE      :  WriteImage1

* CALL       :  WriteImage1(writebuffptr)

* PARAMETERS :  writebuffptr: pointer to a data struct containing all infos
                for writing a line(or several lines) for a dataline.

* INTERFACE  :  Compress(), Amplify(), AmpInY(), ampInX()

* CALLS      :  none

* RETURN     : none

******************************************************************************/
void WriteImage1(writebuffptr)
struct OUTBUFFINFO FAR *writebuffptr;
{
//  ufix16           y;         @WIN
    fix16           y;
    fix16           FAR *divcol;        /* array of number of repeat in col for a pixel */
    fix16            colval;
    register ubyte  FAR *valptr;        /* pointer to data */
    ufix16           htsize;         /* halftone repeat pattern size */
    ufix16           httotal;        /* halftone size */
    ufix16           fbwidth;        /* frame buffer width in word */
    register ubyte  FAR *htbound;        /* halftone pattern boundary in col */
    ubyte           FAR *htmin;          /* halftone pattern upper boundary in row */
    ubyte           FAR *htmax;          /* halftone pattern lower boundary in row */
    register ubyte  FAR *htptr1;
    ubyte           FAR *htmax0;         /* halftone pattern lower boundary in row for landscape*/
    ubyte           FAR *htmin0;         /* halftone pattern upper boundary in row for landscape*/
    register ufix32 huge *outbuff1;      /* starting word of a line in frame buffer @WIN*/
    register ufix32  dx,bt;
    register ubyte   val;
    register ubyte  FAR *gray;           /* convert gray_table for settransfer */
    register ubyte   gray0;          /* gray value for 0 */
    register ubyte   gray1;          /* gray value for 1 */
    register ubyte   grayval;        /* current gray value */
    fix16            ux,uy,lx,ly;
    ubyte            fastflag =0;

    htsize =writebuffptr->htsize;
    httotal =writebuffptr->httotal;
    fbwidth =writebuffptr->fbwidth;
    htbound =writebuffptr->htbound;
    htmin =writebuffptr->htmin;
    htmax =writebuffptr->htmax;
    htmax0 =writebuffptr->htmax0;
    htmin0 =writebuffptr->htmin0;
    gray =writebuffptr->gray;
    gray0 =writebuffptr->gray0;
    gray1 =writebuffptr->gray1;
    grayval =writebuffptr->grayval;
    htptr1 = writebuffptr->htptr0;
    ux = SFX2I(GSptr->clip_path.bb_ux);
    lx = SFX2I(GSptr->clip_path.bb_lx);
    uy = SFX2I(GSptr->clip_path.bb_uy);
    ly = SFX2I(GSptr->clip_path.bb_ly);
    bt = outbit;
    if ((gray1 ==255) && (gray0==0) &&(image_logic_op & IMAGE_BIT))
        fastflag = 1;         /* in 1 bit case , no settransfer, no halftone */
    if ((grayval<=2) && !(image_logic_op & IMAGE_BIT)) /* grayval is black*/
        fastflag =1;          /* in 1 bit case , no settransfer, no halftone */


    if (fastflag)  /* no halftone needed */
       {
         if ((image_dev_flag == PORTRATE)&&(xmove))
           for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                            /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&& colval)
                    {
                     if (image_logic_op & IMAGE_BIT)
                      {
                       do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt LSHIFTEQ 1)==0)
                                     {
                                       bt = ONE1_32;
                                       outbuff1++;
                                     };
                               } while (--dx);
                         } while (--colval);
                      }
                     else
                      {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                                 /* if 0, apply current gray */
                                       if (val==0)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                       if (val)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                    } while (--dx);
                              } while (--colval);
                      };
                    };
                  if (ymove)
                    {
                      writebuffptr->outbuff0 +=writebuffptr->fbwidth;
                      writebuffptr->yout++;
                    }
                  else
                    {
                       writebuffptr->outbuff0 -=writebuffptr->fbwidth;
                       writebuffptr->yout--;
                    };
             };

         if ((image_dev_flag == PORTRATE)&&(!xmove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                              /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                     *outbuff1 |= ORSWAP(bt);
                                  if ((bt RSHIFTEQ 1)==0)
                                     {
                                       bt = ONE8000;
                                       outbuff1--;
                                     };
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                           if (image_logic_op & IMAGEMASK_FALSE_BIT)
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                              /* if 0, apply current gray */
                                        if (val==0)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                     } while (--dx);
                               } while (--colval);
                           else
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                        if (val )
                                          if (grayval <*htptr1)
//                                           *outbuff1 |=bt;     @WIN_IM; swap it
                                             *outbuff1 |= ORSWAP(bt);
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                     } while (--dx);
                               }  while (--colval);
                        };
                   };
                  if (ymove)
                            {
                               writebuffptr->outbuff0 +=writebuffptr->fbwidth;
                               writebuffptr->yout++;
                            }
                  else
                            {
                               writebuffptr->outbuff0 -=writebuffptr->fbwidth;
                               writebuffptr->yout--;
                            };
             };
         if ((image_dev_flag == LANDSCAPE)&& (ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0 + writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                                /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&& colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                       {
                        do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 +=fbwidth;
                               } while (--dx);
                         } while (--colval);
                       }
                     else
                       {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                           /* if 0, apply current gray */
                                       if (val==0)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       outbuff1 +=fbwidth;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                       if (val)
//                                         *outbuff1 |=bt;     @WIN_IM; swap it
                                           *outbuff1 |= ORSWAP(bt);
                                       outbuff1 +=fbwidth;
                                    } while (--dx);
                              } while (--colval);

                       };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                         writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                         writebuffptr->xout--;
                     }
             };
         if ((image_dev_flag == LANDSCAPE)&& (!ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                                    /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            val = *valptr++;
                            dx = *divcol++;
                            do
                               {
                                  if (val==0)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 -=fbwidth;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                            if (image_logic_op & IMAGEMASK_FALSE_BIT)
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                              /* if 0, apply current gray */
                                         if (val==0)
//                                            *outbuff1 |=bt;     @WIN_IM; swap it
                                              *outbuff1 |= ORSWAP(bt);
                                         outbuff1 -=fbwidth;
                                      } while (--dx);
                                } while (--colval);
                            else
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                         if (val)
//                                            *outbuff1 |=bt;     @WIN_IM; swap it
                                              *outbuff1 |= ORSWAP(bt);
                                         outbuff1 -=fbwidth;
                                      } while (--dx);
                                } while (--colval);
                        };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                        writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                        writebuffptr->xout--;
                     }
             };
         outbit = bt;
         return;
       };

    if ((image_dev_flag == PORTRATE)&&(xmove))
           for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                   /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&& colval)
                    {
                     if (image_logic_op & IMAGE_BIT)
                      {
                       do
                         {
                            if (*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1++ > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt LSHIFTEQ 1)==0)
                                     {
                                       bt = ONE1_32;
                                       outbuff1++;
                                     };
                                  if (htptr1 ==htbound)
                                      htptr1 -=htsize;
                               } while (--dx);
                         } while (--colval);
                      }
                     else
                      {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                              /* if 0, apply current gray */
                                       if (!val)
                                        {                    /* 5-2-91, shenzhi */
                                         if (grayval <*htptr1)
//                                          *outbuff1 |=bt;     @WIN_IM; swap it
                                            *outbuff1 |= ORSWAP(bt);
                                         else                /* 5-2-91, shenzhi */
//                                          *outbuff1 &=~bt;    @WIN_IM; swap it
                                            *outbuff1 &= ANDNOTSWAP(bt);
                                        };                   /* 5-2-91, shenzhi */
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                       if (++htptr1 ==htbound)
                                          htptr1 -=htsize;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 1 , apply current gray */
                                       if (val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                                    *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       if ((bt LSHIFTEQ 1)==0)
                                          {
                                            bt = ONE1_32;
                                            outbuff1++;
                                          };
                                       if (++htptr1 ==htbound)
                                          htptr1 -=htsize;
                                    } while (--dx);
                              } while (--colval);
                      };
                    };
                  if (ymove)
                    {
                      writebuffptr->outbuff0 +=fbwidth;
                      writebuffptr->htptr0 +=htsize;
                      htbound +=htsize;
                      if (htbound > htmax)
                       {
                           htbound = htmin;
                           writebuffptr->htptr0 -=httotal;
                       };
                      writebuffptr->htbound = htbound;
                      writebuffptr->yout++;
                    }
                  else
                    {
                       writebuffptr->htptr0 -=htsize;
                   /*  writebuffptr->htbound -=htsize;    */
                       htbound -=htsize;     /* 4-26-91, shenzhi */
                       if (htbound < htmin)
                        {
                            htbound = htmax;
                            writebuffptr->htptr0 +=httotal;
                        };
                       writebuffptr->htbound = htbound;
                       writebuffptr->outbuff0 -=fbwidth;
                       writebuffptr->yout--;
                    };
             };
    if ((image_dev_flag == PORTRATE)&&(!xmove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr = writebuffptr->valptr0+writebuffptr->clipx;
                  bt = ONE1_32  LSHIFT writebuffptr->start_shift;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                               /*check clipping in image row */
                  if ((writebuffptr->yout>=ly)&&(writebuffptr->yout<=uy)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            if(*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1-- > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  if ((bt RSHIFTEQ 1)==0)
                                     {
                                       bt = ONE8000;
                                       outbuff1--;
                                     };
                                  if (htptr1 ==htbound)
                                      htptr1 +=htsize;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                           if (image_logic_op & IMAGEMASK_FALSE_BIT)
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                         /* if 0, apply current gray */
                                        if (!val)
                                                  {                   /* 5-2-91, shenzhi */
                                                   if (grayval <*htptr1)
//                                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                                     *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                  };                  /* 5-2-91, shenzhi */
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                        if (--htptr1 ==htbound)
                                           htptr1 +=htsize;
                                     } while (--dx);
                               } while (--colval);
                           else
                             do
                               {
                                  val = *valptr++;
                                  dx = *divcol++;
                                  do
                                     {
                                           /* if 1 , apply current gray */
                                        if (val )
                                                   {                  /* 5-2-91, shenzhi */
                                                   if (grayval <*htptr1)
//                                                    *outbuff1 |=bt;     @WIN_IM; swap it
                                                      *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                   };                 /* 5-2-91, shenzhi */
                                        if ((bt RSHIFTEQ 1)==0)
                                           {
                                             bt = ONE8000;
                                             outbuff1--;
                                           };
                                        if (--htptr1 ==htbound)
                                           htptr1 +=htsize;
                                     } while (--dx);
                               }  while (--colval);
                        };
                   };
                  if (ymove)
                            {
                               writebuffptr->htptr0 +=htsize;
                               htbound +=htsize;
                               if (htbound > htmax)
                                {
                                    htbound = htmin;
                                    writebuffptr->htptr0 -=httotal;
                                };
                               writebuffptr->htbound = htbound;
                               writebuffptr->outbuff0 +=fbwidth;
                               writebuffptr->yout++;
                            }
                  else
                            {
                               writebuffptr->htptr0 -=htsize;
                               htbound -=htsize;
                               if (htbound < htmin)
                                {
                                    htbound = htmax;
                                    writebuffptr->htptr0 +=httotal;
                                };
                               writebuffptr->htbound = htbound;
                               writebuffptr->outbuff0 -=fbwidth;
                               writebuffptr->yout--;
                            };
             };
    if ((image_dev_flag == LANDSCAPE)&& (ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                 /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&& colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                       {
                        do
                         {
                            if (*valptr++)
                               val=gray1;
                            else
                               val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1 > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 +=fbwidth;
                                  if ((htptr1+=htsize) > htmax0)
                                        htptr1 -=httotal;
                               } while (--dx);
                         } while (--colval);
                       }
                     else
                       {
                          if (image_logic_op & IMAGEMASK_FALSE_BIT)
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 0, apply current gray */
                                       if (!val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                                    *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       outbuff1 +=fbwidth;
                                       if ((htptr1+=htsize) > htmax0)
                                             htptr1 -=httotal;
                                    } while (--dx);
                              } while (--colval);
                          else
                            do
                              {
                                 val = *valptr++;
                                 dx = *divcol++;
                                 do
                                    {
                                        /* if 1 , apply current gray */
                                       if (val)
                                                 {                    /* 5-2-91, shenzhi */
                                                  if (grayval <*htptr1)
//                                                   *outbuff1 |=bt;     @WIN_IM; swap it
                                                     *outbuff1 |= ORSWAP(bt);
                                                  else                /* 5-2-91, shenzhi */
//                                                   *outbuff1 &=~bt;    @WIN_IM; swap it
                                                     *outbuff1 &= ANDNOTSWAP(bt);
                                                 };                   /* 5-2-91, shenzhi */
                                       outbuff1 +=fbwidth;
                                       if ((htptr1+=htsize) > htmax0)
                                             htptr1 -=httotal;
                                    } while (--dx);
                              } while (--colval);

                       };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                         if (++writebuffptr->htptr0 ==htbound)
                                  writebuffptr->htptr0 -=htsize;
                         writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                         if (--writebuffptr->htptr0 ==htbound)
                                  writebuffptr->htptr0 +=htsize;
                         writebuffptr->xout--;
                     }
             };
    if ((image_dev_flag == LANDSCAPE)&& (!ymove))
            for (y=0; y<writebuffptr->repeat_y; y++)
             {
                  colval = writebuffptr->clipcol;
                  valptr=writebuffptr->valptr0+writebuffptr->clipx;
                  divcol = writebuffptr->newdivc;
                  outbuff1 = writebuffptr->outbuff0;
            if(bGDIRender) {    /*@WIN_IM */
                  if(!xmove) outbuff1 += fbwidth-1;
                  if(!ymove) outbuff1 += fbwidth * (writebuffptr->fbheight - 1);
            }
                  htptr1 = writebuffptr->htptr0;
                                    /*check clipping in image row */
                  if ((writebuffptr->xout>=lx)&&(writebuffptr->xout<=ux)&&colval)
                   {
                     if (image_logic_op & IMAGE_BIT)
                        {
                         do
                         {
                            if (*valptr++)
                              val = gray1;
                            else
                              val = gray0;
                            dx = *divcol++;
                            do
                               {
                                  if (*htptr1 > val)
//                                  *outbuff1 |=bt;     @WIN_IM; swap it
                                    *outbuff1 |= ORSWAP(bt);
                                  outbuff1 -=fbwidth;
                                  if ((htptr1-=htsize) < htmin0)
                                        htptr1 +=httotal;
                               } while (--dx);
                         } while (--colval);
                        }
                     else
                        {
                            if (image_logic_op & IMAGEMASK_FALSE_BIT)
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                               /* if 0, apply current gray */
                                         if (!val)
                                                     {                  /* 5-2-91, shenzhi */
                                                    if (grayval < *htptr1)
//                                                     *outbuff1 |=bt;     @WIN_IM; swap it
                                                       *outbuff1 |= ORSWAP(bt);
                                                    else                /* 5-2-91, shenzhi */
//                                                     *outbuff1 &=~bt;    @WIN_IM; swap it
                                                       *outbuff1 &= ANDNOTSWAP(bt);
                                                     };                 /* 5-2-91, shenzhi */
                                         outbuff1 -=fbwidth;
                                         if ((htptr1-=htsize) < htmin0)
                                               htptr1 +=httotal;
                                      } while (--dx);
                                } while (--colval);
                            else
                              do
                                {
                                   val = *valptr++;
                                   dx = *divcol++;
                                   do
                                      {
                                                         /* if 1 , apply current gray */
                                         if (val)
                                                     {                  /* 5-2-91, shenzhi */
                                                    if (grayval <*htptr1)
//                                                     *outbuff1 |=bt;     @WIN_IM; swap it
                                                       *outbuff1 |= ORSWAP(bt);
                                                    else                /* 5-2-91, shenzhi */
//                                                     *outbuff1 &=~bt;    @WIN_IM; swap it
                                                       *outbuff1 &= ANDNOTSWAP(bt);
                                                     };                 /* 5-2-91, shenzhi */
                                         outbuff1 -=fbwidth;
                                         if ((htptr1-=htsize) < htmin0)
                                               htptr1 +=httotal;
                                      } while (--dx);
                                } while (--colval);
                        };
                   };
                  if (xmove)
                     {
                        if ((bt  LSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 +=1;
                               bt = ONE1_32;
                           };
                        if (++writebuffptr->htptr0 ==htbound)
                                 writebuffptr->htptr0 -=htsize;
                        writebuffptr->xout++;
                     }
                  else
                     {
                        if ((bt  RSHIFTEQ 1)==0)
                           {
                               writebuffptr->outbuff0 -=1;
                               bt = ONE8000;
                           };
                        if (--writebuffptr->htptr0 ==htbound)
                                 writebuffptr->htptr0 +=htsize;
                        writebuffptr->xout--;
                     }
             };
             outbit = bt;

}






/******************************************************************************

* TITLE      :  image_alloc

* CALL       :  image_alloc(p_size)

* PARAMETERS :  p_size: number of bytes required

* INTERFACE  :

* CALLS      :  none

* RETURN     : none

******************************************************************************/

/*mslin*/

byte    FAR *image_alloc(p_size)
fix     p_size;
{
//  byte        FAR *p1;        @WIN
    p_size = W_ALIGN(p_size);

    image_heap -= p_size;               /* update free heap pointer */
    if( (image_scale_info->dev_buffer_size -= p_size) < 0)
      return(NIL);
    return((byte FAR *)image_heap);

} /*image_alloc*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\shape.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:   shape.c
 *
 *      Purpose: This file contains the following major modules:
 *               1) shape_approximation -- approximate current path if it
 *                  contains some curves, and set up edge table for shape_
 *                  reduction,
 *               2) shape_reduction -- reduce current path into a set of
 *                  trapezoids,
 *               3) convex_clipper -- clip a convex polygon against current
 *                  clip path, which is a set of trapezoids
 *               4) pgn_reduction -- reduce a clockwised polygon into a set
 *                  of trapezoids
 *
 *      Developer:      S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *
 *                  04/11/90    cross_with_horiz_line(): Fixed bug; set them as
 *                              cross points when the intersect points are same;
 *                              not need to be identical edges.
 *                  03/26/91    convex_clipper(): fix bug for very sharp clipping
 *                              triangle for case "doesall.cap".
 *                  04/17/91    change scany_table size from MAXEDGE(1500) to
 *                              2000.
 *                  04/19/91    Add a shell sort to replace quick sort for
 *                              sorintg edge_table; @SH_SORT
 *                  04/30/91    cross_with_horiz_line(): fix bug of shape
 *                              reduction for case "train.ps"
 *                  11/18/91    Add check node after get node and fix circle
 *                              at bottom coner ref: CNODE
 *                              Add fix very large circle for example:
 *                              "30000 30000 10000 0 360 arc fill"
 *                              We don't recommand to do this, but we keep the
 *                              code there. ref : @LC
 *                  11/18/91    upgrade for higher resolution @RESO_UPGR
 ***********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>
#include        <stdio.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* -------------------- macro definition -------------- */

/* @INSIDE1 */
#define IN_CLIP 1
#define ON_CLIP -1
#define OUT_CLIP 0

/* -------------------- static function declartion ----------------- */
#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static bool near page_inside (struct coord, fix);
static struct coord * near page_intersect (struct coord,
                            struct coord, fix);
static struct edge_hdr FAR * near put_edge_table (sfix_t, sfix_t, sfix_t, sfix_t);
static void near sort_edge_table(void);     /* @ET */
static void near qsort (fix, fix);          /* @ET */
static void near shellsort(fix);        /* @SH_SORT */
static void near setup_intersect_points(void);      /* @ET; @WIN; prototype */
static void near put_in_xpnt_table(sfix_t, sfix_t, struct edge_hdr FAR *,
                                   struct edge_hdr FAR *);
static void near put_in_scany_table(sfix_t);    /* @XPNT */
static void near sort_scany_table(void);        /* @XPNT */
static void near scany_qsort (fix, fix);        /* @XPNT */
static void near horiz_partition (ufix);
static fix near cross_with_horiz_line (sfix_t);         /* @ET */
static void near set_wno (ufix);        /* @ET */
static void near get_pairs (sfix_t, fix);       /* @ET */
static void near degen_tpzd (sfix_t, sfix_t, sfix_t);   /* @ET */
static void near find_trapezoid (sfix_t, sfix_t, sfix_t, struct edge_hdr FAR *,
                                 struct edge_hdr FAR *);
static bool near inside(struct coord_i, fix);      /* @INSIDE */
static struct coord_i * near intersect (struct coord_i, struct coord_i,
                              fix);             /* @INSIDE */

#else

/* for no type checks of the parameters in function declarations */
static bool near page_inside ();
static struct coord * near page_intersect ();
static struct edge_hdr FAR * near put_edge_table (); /*@ET*/
static void near sort_edge_table();     /* @ET */
static void near qsort ();          /* @ET */
static void near shellsort();           /* @SH_SORT */
static void near setup_intersect_points();
static void near put_in_xpnt_table();
static void near put_in_scany_table();
static void near sort_scany_table();    /* @XPNT */
static void near scany_qsort ();        /* @XPNT */
static void near horiz_partition ();
static fix near cross_with_horiz_line ();
static void near set_wno ();
static void near get_pairs ();
static void near degen_tpzd ();                /* @ET */
static void near find_trapezoid ();
static bool near inside();
static struct coord_i * near intersect ();

#endif

/* ------------------------ static variables --------------------- */
struct clip_region {
            struct coord_i cp;
};                                              /* @INSIDE */
static struct clip_region clip[5];

static fix et_start, et_end, et_first, et_last;         /* @ET */
static fix xt_start, xt_end, xt_first;                  /* @ET */
/*
 * et_start   et_first    et_last    et_end   xt_end     xt_first    xt_start
 *    +-------------------------------+--------+---------------------------+
 *    |   |   |   |   |   |   |   |   | (free) |   |   |   |   |   |   |   |
 *    +-------------------------------+--------+---------------------------+
 *    0  ===> (et table grow)                      (xt table grow) <==== MAXEDGE
 */

/* distinct y-coord of endpoints (or intersect points) of edges @XPT */
/* static sfix_t scany_table[2000];        |* 04/17/91  phchen */
#define SCANY_TABLE_SZ 2000
static sfix_t scany_table[SCANY_TABLE_SZ];      /* @RESO_UPGR */
static fix st_end, st_first;

fix QSORT = 0;      /* for debugging; @SH_SORT */



//#define DBG1
//#define DBG2


/***********************************************************************
 * Given a subpath, a list of vertices, this module traverses it,
 * converts curves into lines, and places all edges to edge_table and
 * endpoint to cross-point-table(xpnt_table).
 * All the coordinates are under short fixed points domain. If the coordinate
 * is outside the domain it will be pre-clipped against a rectangle that covers
 * entire short fixed point domain.
 *
 * TITLE:       shape_approximation
 *
 * CALL:        shape_approximation (isubpath, param)
 *
 * PARAMETERS:  isubpath -- index to node_table, the header of
 *                          the input subpath(a list of vertices).
 *
 * INTERFACE:   op_clip, op_eoclip, op_fill, op_eofill, linejoin,
 *              linecap
 *
 * CALLS:       flatten_subpath, put_edge_table, put_in_scany_table
 *
 * RETURN:      none
 **********************************************************************/
void shape_approximation (isubpath, param)
SP_IDX isubpath;
fix FAR *   param;
{
        sfix_t  last_x, last_y, cur_x, cur_y;
        sfix_t  first_x, first_y;                       /* @ET */

        VX_IDX  ivtx, iflt_vtx;
        struct  nd_hdr FAR *vtx, FAR *fvtx;
        /* struct  vx_lst *vlist; @NODE */
        SP_IDX vlist;
        struct  nd_hdr FAR *sp;             /* TRVSE */

        VX_IDX  first_vertex;
        struct  edge_hdr FAR *first_edge, FAR *cur_edge, FAR *last_edge;
        bool    first_flag = TRUE;

/* @FCURVE --- BEGIN */
        sfix_t  x3, y3, x4, y4;
        struct  nd_hdr FAR *node;
        VX_IDX  inode, vlist_head;
        lfix_t flat;
/* @FCURVE --- END */

#ifdef DBG1
        printf("Shape_approximation():\n");
        dump_all_path (isubpath);
#endif

        sp = &node_table[isubpath];

        /* flatten the subpath before shape-approximation @PRE_CLIP @TRVSE */
        if (!(sp->SP_FLAG&SP_CURVE)) {         /* subpath contains no curves */
                /* iflt_vtx = sp->SP_HEAD; @NODE */
                iflt_vtx = isubpath;
        } else {

/* @FCURVE --- BEGIN */
#ifdef XXX
                /* vlist = flatten_subpath (sp->SP_HEAD, @NODE */
                vlist = flatten_subpath (isubpath,
                        F2L(GSptr->flatness));
                if( ANY_ERROR() == LIMITCHECK ){
                        /* free_node (vlist->head); @NODE */
                        free_node (vlist);
                        return;
                }
                /* iflt_vtx = vlist->head; @NODE */
                iflt_vtx = vlist;
#endif
                iflt_vtx = isubpath;
                flat = F2LFX(GSptr->flatness);
/* @FCURVE --- END */

        }

        /* pre-clip subpath into page boundary @PRE_CLIP @TRVSE */
        if (!(sp->SP_FLAG & SP_OUTPAGE)) {      /* inside page boundary */
                first_vertex = iflt_vtx;
        } else {
            /* flatten curves before calling page_clipper() 11/18/91 CNODE */
                if (sp->SP_FLAG&SP_CURVE) {  /* subpath contains curves */
                   vlist = flatten_subpath (isubpath, F2L(GSptr->flatness));
                   if( ANY_ERROR() == LIMITCHECK ){
                      extern SP_IDX iron_subpath(VX_IDX); /* @WIN prototype */
                          free_node (vlist);
                          /*  return;             @LC 11/18/91 */
                          CLEAR_ERROR();                    /* @LC */
                          vlist = iron_subpath (isubpath);  /* @LC */
                          if( ANY_ERROR() == LIMITCHECK ){  /* @LC */
                                  free_node (vlist);        /* @LC */
                                  return;                   /* @LC */
                          }                                 /* @LC */
                   }
                   iflt_vtx = vlist;
                }
                first_vertex = page_clipper (iflt_vtx);
                if( ANY_ERROR() == LIMITCHECK || first_vertex == NULLP){ /* 11/18/91 CNODE */
                        /* @NODE
                         *if(sp->SP_FLAG&SP_CURVE) free_node (vlist->head);
                         */
/* @FCURVE --- BEGIN */
/*                      if(sp->SP_FLAG&SP_CURVE) free_node (vlist); */
/* @FCURVE --- END */
                        return;
                }
#ifdef DBG2
                /* @NODE
                 * printf("After page_clipper, original subpath =\n");
                 * ivtx = get_node();
                 * node_table[ivtx].next = NULLP;
                 * node_table[ivtx].SP_HEAD =node_table[ivtx].SP_TAIL =iflt_vtx;
                 * dump_all_path (ivtx);
                 */
                dump_all_path (iflt_vtx);

                printf(" new subpath =\n");
                /* @NODE
                 * node_table[ivtx].SP_HEAD = node_table[ivtx].SP_TAIL =
                 *                            first_vertex;
                 * dump_all_path (ivtx);
                 * free_node (ivtx);
                 */
                dump_all_path (first_vertex);
#endif
        }

        /* just return if the whole path has been clipped out 2/5/88 */
        if (first_vertex == NULLP) return;

        /* initialization */
        fvtx = &node_table[first_vertex];

        /* Traverse each edge of the path, and convert it to
         * edge_table
         */
        for (ivtx=first_vertex; ivtx!=NULLP; ivtx=vtx->next) {

                vtx = &node_table[ivtx];

                switch (vtx->VX_TYPE) {

                case MOVETO :
                case PSMOVE :
                      cur_x = F2SFX (vtx->VERTEX_X);  /* rounding for qty */
                      cur_y = F2SFX (vtx->VERTEX_Y);
                      first_x = cur_x;          /* @ET */
                      first_y = cur_y;
                      break;

                case LINETO :
                      cur_x = F2SFX (vtx->VERTEX_X);    /* @PRE_CLIP */
                      cur_y = F2SFX (vtx->VERTEX_Y);

                      cur_edge = put_edge_table(last_x, last_y, cur_x, cur_y);
                                                /* @SCAN_EHS, delete action */
                      if (first_flag) {                 /* @XPNT_TBL */
                          first_edge = cur_edge;
                          first_flag = FALSE;
                      } else {
                          /* @XPNT
                           * put_in_xpnt_table (last_x, last_y, last_edge,
                           *      cur_edge);   (* @ET ,&shape_xt.first); *)
                           */
                      }
                      break;

/* @FCURVE --- BEGIN */
                case CURVETO :
                    cur_x = F2SFX (vtx->VERTEX_X);
                    cur_y = F2SFX (vtx->VERTEX_Y);

                    /* Get next two nodes: x3, y3, x4, y4 */
                    vtx = &node_table[vtx->next];
                    x3 = F2SFX(vtx->VERTEX_X);
                    y3 = F2SFX(vtx->VERTEX_Y);
                    vtx = &node_table[vtx->next];
                    x4 = F2SFX(vtx->VERTEX_X);
                    y4 = F2SFX(vtx->VERTEX_Y);

                    vlist_head = bezier_to_line_sfx(flat, last_x, last_y,
                              cur_x, cur_y, x3, y3, x4, y4);

                    for (inode = vlist_head; inode != NULLP;
                        inode = node->next) {
                        node = &node_table[inode];

                        cur_x = node->VXSFX_X;
                        cur_y = node->VXSFX_Y;

#ifdef DBG
                        printf("%f %f clineto\n", SFX2F(cur_x), SFX2F(cur_y));
#endif

                        cur_edge = put_edge_table(last_x, last_y, cur_x, cur_y);
                        if (first_flag) {
                            first_edge = cur_edge;
                            first_flag = FALSE;
                        }
                        last_x = cur_x;
                        last_y = cur_y;
                        last_edge = cur_edge;

                        /* put y-coord in scany_table @XPNT */
                        put_in_scany_table (cur_y);

                    } /* for */

                    /* free vlist */
                    free_node (vlist_head);
                    break;
/* @FCURVE --- END */

                case CLOSEPATH :
                      goto close_edge;          /* @PRE_CLIP */

#ifdef DBGwarn
                default :
                    printf("\007Fatal error, shape_approximation(): node type =%d\n",
                           vtx->VX_TYPE);
#endif

                } /* switch */

                last_x = cur_x;
                last_y = cur_y;
                last_edge = cur_edge;   /* @XPNT_TBL */

                /* put y-coord in scany_table @XPNT */
                put_in_scany_table (cur_y);

        } /* for loop */

        /* Put close edge into edge_table if it is an open subpath */
close_edge:
        /* if ((fvtx->next != NULLP) &&
         *   (node_table[fvtx->next].VX_TYPE != CLOSEPATH)) {
         */
        /* should not contain only a MOVETO node, but if there are a MOVETO
         * and a CLOSEPATH then need to fill it.        1/10/89
         */
        if (fvtx->next != NULLP) {
                /* add a edge from first point to last point 1/10/89 */
                if (node_table[fvtx->next].VX_TYPE == CLOSEPATH) {
                    last_x++;
                    last_edge = first_edge = put_edge_table (first_x, first_y,
                        last_x, last_y);
                }

                cur_edge = put_edge_table (last_x, last_y,
                       first_x, first_y);

                /* @XPNT
                 * put_in_xpnt_table (last_x, last_y, last_edge, cur_edge);
                 * put_in_xpnt_table (first_x, first_y, cur_edge, first_edge);
                 */
        }

        /* release temp. subpaths @PRE_CLIP @TRVSE */
/* @FCURVE --- BEGIN */
/*      if (sp->SP_FLAG&SP_CURVE) {
 *              free_node (iflt_vtx);
 *      }
 */
/* @FCURVE --- END */
        if (sp->SP_FLAG&SP_OUTPAGE) {
                free_node (first_vertex);
                if (sp->SP_FLAG&SP_CURVE)   /* 11/18/91 CNODE */
                    free_node (vlist);
        }

#ifdef DBG2
        printf(" edge_list(after shape_approximation)-->\n");
        dump_all_edge (et_start, et_end);
#endif

}


void init_edgetable ()
{
        et_start = 0;
        et_end = -1;
        xt_start = MAXEDGE - 1;
        xt_end = MAXEDGE;
        st_end = -1;            /* @XPNT */
}

/***********************************************************************
 * Given a list of vertices, this routine clip it against a rectangle
 * that covers the entire short fixed point domain.
 *
 * TITLE:       page_clipper
 *
 * CALL:        page_clipper(ifvtx)
 *
 * PARAMETERS:  ifvtx -- index to node_table, the first vertex of
 *                       the input subpath(a list of vertices).
 *
 * INTERFACE:   shape_approximation
 *
 * CALLS:       page_inside, page_intersect
 *
 * RETURN:      a list of vertices
 **********************************************************************/
VX_IDX page_clipper (ifvtx)               /* 1/5/88 */
VX_IDX  ifvtx;
{
        fix     cb;     /* clip boundary(top, right, bottom, or left) */
        VX_IDX  head, tail, ivtx, inode;
        struct  nd_hdr  FAR *vtx, FAR *lvtx;
        bool    done;
        struct coord cp, lp, *isect;        /* current point, last point */

        /* copy the original subpath except the closepath node */
        inode = get_node();
        if (inode == NULLP) {                   /* 9/14/91 CNODE */
            ERROR(LIMITCHECK);
            return(NULLP);
        }
        node_table[inode] = node_table[ifvtx];
        head = tail = inode;
        for (ivtx = node_table[ifvtx].next; ivtx != NULLP;
                ivtx = node_table[ivtx].next) {
                if (node_table[ivtx].VX_TYPE == CLOSEPATH) break;
                                        /* skip close node */
                inode = get_node();
                if (inode == NULLP) {                   /* 9/14/91 CNODE */
                    ERROR(LIMITCHECK);
                    node_table[tail].next = NULLP;
                    free_node(head);
                    return(NULLP);
                }
                node_table[inode] = node_table[ivtx];
                node_table[tail].next = inode;
                tail = inode;
        }  /* for */
        node_table[tail].next = NULLP;

        /* clip subject to each clip boundary of the page */
        for (cb = 0; cb < 4; cb++) {    /* top, right, bottom, left */

            done = FALSE;
            lp.x = node_table[head].VERTEX_X;
            lp.y = node_table[head].VERTEX_Y;
            lvtx = &node_table[head];
            /* for each edge of subject(in_polygon) */
            for (ivtx = node_table[head].next; !done; ivtx = vtx->next) {
                if (ivtx == NULLP) {
                        ivtx = head;
                        done = TRUE;
                }
                vtx = &node_table[ivtx];
                cp.x = vtx->VERTEX_X;
                cp.y = vtx->VERTEX_Y;

                if (page_inside(cp, cb)) {

                    if (page_inside(lp, cb)) {
                            /* inside -> inside */
                            /* reserve original node */
                    } else {     /* outside -> inside */
                            /* output intersect point */
                            isect = page_intersect (lp, cp, cb);

                            /* preppend a node */
                            inode = get_node();
                            if (inode == NULLP) {
                                ERROR(LIMITCHECK);
                                free_node(head);        /* 9/14/91 CNODE */
                                return(NULLP);
                            }

                            node_table[inode].VERTEX_X = isect->x;
                            node_table[inode].VERTEX_Y = isect->y;
                            node_table[inode].VX_TYPE = LINETO;
                            node_table[inode].next = lvtx->next;
                            lvtx->next = inode;
                    }
                    lp = cp;    /* structure copy */
                } else {
                    if (page_inside(lp, cb)) {
                            /* inside -> outside */
                            /* output intersect point */
                            isect = page_intersect (lp, cp, cb);

                            /* update original node to new intersect node */
                            lp.x = vtx->VERTEX_X;
                            lp.y = vtx->VERTEX_Y;
                            vtx->VERTEX_X = isect->x;
                            vtx->VERTEX_Y = isect->y;


                    } else {    /* outside -> outside */
                            /* delete original node */
                            if (lvtx->next == NULLP) {
                                head = node_table[head].next;
                            } else {
                                lvtx->next = vtx->next;
                            }

                            lp.x = vtx->VERTEX_X;
                            lp.y = vtx->VERTEX_Y;
                            vtx->next = NULLP;
                            free_node(ivtx);
                            vtx = lvtx;
                    }
                }

                lvtx = vtx;

                /* return if the clipped path is empty 2/10/88 */
                if (head == NULLP) return(NULLP);

            } /* for each node of the subject */

#ifdef DBG2
                printf("In page_clipper, phase#%d  subpath =\n", cb);
                /* @NODE
                 * ivtx = get_node();
                 * node_table[ivtx].next = NULLP;
                 * node_table[ivtx].SP_HEAD = node_table[ivtx].SP_TAIL = head;
                 * dump_all_path (ivtx);
                 * free_node (ivtx);
                 */
                dump_all_path (head);
#endif

        } /* for each clip boundary */

        /* set first node being MOVETO node */
        node_table[head].VX_TYPE = MOVETO;
        return(head);
}


/*
 * Check if coordinate p is inside the clipping boundary cb.
 */
static bool near page_inside (p, cb)
struct coord p;
fix     cb;
{
        switch (cb) {
        case 0 :        /* top clip boundary */
                if (p.y >= (real32)PAGE_TOP) return(TRUE);
                else                return(FALSE);

        case 1 :        /* right clip boundary */
                if (p.x <= (real32)PAGE_RIGHT) return(TRUE);
                else                return(FALSE);

        case 2 :        /* bottom clip boundary */
                if (p.y <= (real32)PAGE_BTM) return(TRUE);
                else                return(FALSE);

        case 3 :        /* left clip boundary */
                if (p.x >= (real32)PAGE_LEFT) return(TRUE);
                else                return(FALSE);
        }

        // this should never happen!
        return(FALSE);
}


/*
 * Calculate the intersect point of the line(lp, cp) with clipping boundary cb.
 */
static struct coord * near page_intersect ( lp, cp, cb)
struct coord lp, cp;
fix     cb;
{
        static struct coord isect;  /* should be static */

        switch (cb) {
        case 0 :        /* top clip boundary */
                isect.x = lp.x + ((real32)PAGE_TOP - lp.y) *
                                 (cp.x - lp.x) / (cp.y - lp.y);
                isect.y = (real32)PAGE_TOP;
                break;

        case 1 :        /* right clip boundary */
                isect.x = (real32)PAGE_RIGHT;
                isect.y = lp.y + ((real32)PAGE_RIGHT - lp.x) *
                                 (cp.y - lp.y) / (cp.x - lp.x);
                break;

        case 2 :        /* bottom clip boundary */
                isect.x = lp.x + ((real32)PAGE_BTM - lp.y) *
                                 (cp.x - lp.x) / (cp.y - lp.y);
                isect.y = (real32)PAGE_BTM;
                break;

        case 3 :        /* left clip boundary */
                isect.x = (real32)PAGE_LEFT;
                isect.y = lp.y + ((real32)PAGE_LEFT - lp.x) *
                                 (cp.y - lp.y) / (cp.x - lp.x);
        }

        return (&isect);

}

/*
 * Some tricky routines to check if coordinates outside the boundary of SFX
 * format                                                        @OUT_PAGE
 */
bool too_small(f)
long32 f;
{
        ufix32 i;

        if (!SIGN(f)) return(FALSE);

        i = EXP(f);
/*      if ((i > 0x45800000L) || ((i == 0x45800000L) && MAT(f)))
                return (TRUE);          |* f < -4096 */
        if ((i > PG_CLP_IEEE) || ((i == PG_CLP_IEEE) && MAT(f)))
                return (TRUE);          /* @RESO_UPGR */
        return(FALSE);
}

bool too_large(f)
long32 f;
{
        ufix32 i;

        if (SIGN(f)) return(FALSE);

        i = EXP(f);
/*      if ((i > 0x45000000L) || ((i == 0x45000000L) && (MAT(f) > 0x7ff000)))
                return (TRUE);          |* f > 4095 */
        if ((i > PG_CLP_HALF_IEEE) ||
                ((i == PG_CLP_HALF_IEEE) && (MAT(f) > 0x7ff000)))
                return (TRUE);          /* @RESO_UPGR */
        return(FALSE);
}

bool out_page(f)
long32 f;
{
        ufix32 i;

        i = EXP(f);
        if (SIGN(f)) {  /* negtive */
                /* if ((i > 0x45800000L) || ((i == 0x45800000L) && MAT(f)))
                        return (TRUE);          |* f < -4096 */
                if ((i > PG_CLP_IEEE) || ((i == PG_CLP_IEEE) && MAT(f)))
                        return (TRUE);          /* @RESO_UPGR  */
        } else {
                /* if ((i > 0x45000000L) || ((i == 0x45000000L) && (MAT(f) > 0x7ff000)))
                        return (TRUE);          |* f > 4095 */
                if ((i > PG_CLP_HALF_IEEE) ||
                        ((i == PG_CLP_HALF_IEEE) && (MAT(f) > 0x7ff000)))
                        return (TRUE);          /* @RESO_UPGR */
        }
        return(FALSE);
}



/***********************************************************************
 * Depending on whether the given edge is horizontal, this module puts
 * the edge into edge_table in y_coordinates non_decreasing order.
 *
 * TITLE:       put_edge_table
 *
 * CALL:        put_edge_table(x0, y0, x1, y1)
 *
 * PARAMETERS:  x0, y0  -- starting point of edge
 *              x1, y1  -- ending point of edge
 *
 * INTERFACE:   shape_approximation
 *
 * CALLS:       none
 *
 * RETURN:      edge -- generated edge
 **********************************************************************/
static struct edge_hdr FAR * near put_edge_table (x0, y0, x1, y1)
sfix_t  x0, y0, x1, y1; /* @SCAN_EHS, delete action */
{
        struct  edge_hdr FAR *ep;

        /* Remove the degenerate edge */
        if((x0==x1) && (y0==y1)) return((struct edge_hdr FAR *) -1);

        /* allocate an entry of edge_table @ET */
        if (++et_end >= xt_end) {
                ERROR(LIMITCHECK);
                return((struct edge_hdr FAR *) -1);
        }
        ep = &edge_table[et_end];
        edge_ptr[et_end] = ep;
        ep->ET_FLAG = 0;        /* init */

        /* Put edge into edge_table or horiz_table in y_coordnate
         * non_decreasing order
         */
        if (y0 == y1) {         /* horizontal edge */

                ep->HT_Y = ep->ET_ENDY = y0;            /* ??? */
                if (x0 > x1) {
                        ep->HT_XR = x0;
                        ep->HT_XL = x1;
                } else {
                        ep->HT_XR = x1;
                        ep->HT_XL = x0;
                }

                /* set flag of horizontal edge @ET */
                ep->ET_FLAG |= HORIZ_EDGE;

        } else {
                /* Construct an entry of edge_table */
                if (y0 > y1) {
                    ep->ET_TOPY = ep->ET_LFTY = y1;
                    ep->ET_XINT = ep->ET_TOPX = ep->ET_LFTX = ep->ET_RHTX = x1;
                                                                /* @SRD */
                    ep->ET_ENDY = y0;
                    ep->ET_ENDX = x0;
                    ep->ET_FLAG |= WIND_UP;
                } else {
                    ep->ET_TOPY = ep->ET_LFTY = y0;
                    ep->ET_XINT = ep->ET_TOPX = ep->ET_LFTX = ep->ET_RHTX = x0;
                                                                /* @SRD */
                    ep->ET_ENDY = y1;
                    ep->ET_ENDX = x1;

                    ep->ET_FLAG &= ~WIND_UP;
                }

                /* set flag of horizontal edge @ET */
                ep->ET_FLAG &= ~HORIZ_EDGE;

        }
        return(ep);             /* @ET: et */
}



/*
 * sort edge_table: et_start => et_end
 */
static void near sort_edge_table()
{
        /* initialization for quick sort */
        if (et_end+1 >= xt_end) {
                ERROR(LIMITCHECK);
                return;
        }
        edge_table[et_end+1].ET_TOPY = MAX_SFX;  /* Important !!! */
        edge_ptr[et_end+1] = &edge_table[et_end+1];     /* 12/30/88 */

        if (QSORT)                  /* @SH_SORT */
            qsort (et_start, et_end);
        else
            shellsort(et_end+1);
}

/*
 * quick sort
 */
static void near qsort (m, n)
fix     m, n;
{
        fix     i, j;
        sfix_t  key;
        register struct edge_hdr far *t;        /* for swap */

        if (m < n) {
                i = m;
                j = n + 1;
                key = edge_ptr[m]->ET_TOPY;
                while(1) {
                        for (i++;edge_ptr[i]->ET_TOPY < key; i++);
                        for (j--;edge_ptr[j]->ET_TOPY > key; j--);
                        if (i < j) {
                                /* swap (i, j); */
                                t = edge_ptr[i];
                                edge_ptr[i] = edge_ptr[j];
                                edge_ptr[j] = t;
                        } else
                                break;
                }

                /* swap (m, j); */
                t = edge_ptr[m];
                edge_ptr[m] = edge_ptr[j];
                edge_ptr[j] = t;

                qsort (m, j-1);
                qsort (j+1, n);
        }
}

/*
 * shell sort           (* @SH_SORT *)
 */
/*void shellsort (v,n)
 *register int v[], n;
 */
static void near shellsort(n)
register fix n;
{
        register fix gap, i, j;
        register sfix_t temp;   /* @RESO_UPGR */
        register struct edge_hdr far *t;        /* for swap */

        gap = 1;
        do (gap = 3*gap + 1); while (gap <= n);
        for (gap /= 3; gap > 0; gap /= 3)
           for (i = gap; i < n; i++) {
              /*temp = v[i];*/
              temp = edge_ptr[i]->ET_TOPY;
              t = edge_ptr[i];
              /* for (j=i-gap; (j>=0)&&(v[j]>temp); j-=gap)
               *    v[j+gap] = v[j];
               * v[j+gap] = temp;
               */
              for (j=i-gap; (j>=0)&&(edge_ptr[j]->ET_TOPY>temp); j-=gap)
                 edge_ptr[j+gap] = edge_ptr[j];
              edge_ptr[j+gap] = t;
           }
}

/***********************************************************************
 * This module reduces the shape in edge_table to a set of trapezoids,
 * and clips each trapezoid to the current clipping path.
 *
 * TITLE:       shape_reduction
 *
 * CALL:        shape_reduction(winding_type)
 *
 * PARAMETERS:  winding_type -- NON_ZERO/EVEN_ODD
 *
 * INTERFACE:   op_clip, op_eoclip, op_fill, op_eofill, linejoin,
 *              linecap
 *
 * CALLS:       setup_intersect_points, horiz_partition
 *
 * RETURN:      none
 **********************************************************************/
void shape_reduction(winding_type)           /* @SCAN_EHS, delete action */
ufix    winding_type;
{

        /* do nothing for degenerate case, ie. just one point; @WIN */
        if (et_start > et_end) return;

        /* sort edge_table @ET */
        sort_edge_table();
#ifdef DBG1
        printf("After sort_edge_table():\n");
        printf(" et_start=%d, et_end=%d\n", et_start, et_end);
        dump_all_edge (et_start, et_end);
#endif

        /* Split intersecting edges: complicated graph ==> simple graphs */
        setup_intersect_points();

        if ( ANY_ERROR() == LIMITCHECK ) /* 05/07/91, Peter, out of scany_table */
            return;

        /* sort scany_table @XPNT */
        sort_scany_table();

#ifdef DBG1
        {
            fix     ixp;
            struct  edge_hdr FAR *xp;
            printf(" xpnt_table -->\n");
            printf("        X        Y        EDGE1        EDGE2\n");
            for (ixp = xt_start; ixp >= xt_end; ixp--) {
                xp = edge_ptr[ixp];
                printf(" %d)   %f   %f   %lx  %lx\n", ixp, xp->XT_X/8.0,
                        xp->XT_Y/8.0, xp->XT_EDGE1, xp->XT_EDGE2);
            }
            printf(" scany_table -->\n");
            printf("        X        Y        EDGE1        EDGE2\n");
            for (ixp = 0; ixp <= st_end; ixp++) {
                printf(" %d)   %f\n", ixp, SFX2F(scany_table[ixp]));
            }
        }
#endif

        /* partition the shape into a set of trapezoides, and paint or
         * save it due to action
         */
        horiz_partition (winding_type);

}



/***********************************************************************
 * This module splits inter_cross edges in edge_table.
 *
 * TITLE:       setup_intersect_points
 *
 * CALL:        setup_intersect_points()
 *
 * PARAMETERS:
 *
 * INTERFACE:   shape_reduction
 *
 * CALLS:       put_in_xpnt_table
 *
 * RETURN:      none
 **********************************************************************/
static void near setup_intersect_points()
{
        fix     current_edge, cross_edge;   /* @ET: ET_IDX */
        struct  edge_hdr FAR *cp, FAR *xp;

//      ET_IDX   first_horiz, horiz_edge;   /* HORZ_CLIP 3/28/88 */ @WIN
//      struct  edge_hdr FAR *hp;                                   @WIN

        sfix_t      x0, y0, x1, y1, x2, y2, x3, y3;     /* @PRE_CLIP */

        fix32    delta_x1, delta_y1, delta_x2, delta_y2;        /* 1/8/88 */
        fix32    delta_topx, delta_topy;
        sfix_t   int_x, int_y;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32 divider;
        fix32 s1, t1;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], dest3[2], dest4[2], dest5[2], dest6[2], dest7[2];
        long div_dif[2], s1_dif[2], t1_dif[2];
        real32 dividend, divider;
        real32 div_dif_f, s1_dif_f, t1_dif_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2], dest3[2], dest4[2], dest5[2], dest6[2], dest7[2];
        long div_dif[2], s1_dif[2], t1_dif[2];
        real32 dividend, divider;
        real32 div_dif_f, s1_dif_f, t1_dif_f;
#endif
        real32   s;             //@WIN

        /* Initialization */
        et_first = et_start;

        /* Get intersecting points of edges */
        for (current_edge=et_start; current_edge <= et_end; current_edge++) {
            cp = edge_ptr[current_edge];

            /* advance first_edge if it is impossible to intersect
             * with current edge
             */
            while ((et_first < et_end) &&
                   (cp->ET_TOPY >= edge_ptr[et_first]->ET_ENDY)) et_first++;

            /* special processing of horizontal edge(current_edge) @ET */
            if (cp->ET_FLAG & HORIZ_EDGE) {

                /* Get intersect points of current edge(horizontal) with all
                 * edges from et_first to current_edge - 1      @ET
                 */
                for (cross_edge = et_first; cross_edge < current_edge;
                     cross_edge++) {
                        xp = edge_ptr[cross_edge];

                        /* skip horizontal edges @ET */
                        if (xp->ET_FLAG & HORIZ_EDGE) continue;

                        /* Get end points of cross edge */
                        x2 = xp->ET_TOPX;
                        y2 = xp->ET_TOPY;
                        x3 = xp->ET_ENDX;
                        y3 = xp->ET_ENDY;

                        /* skip the horizontal edge if it can not intersect
                         * with current edge
                         */
                        if (((cp->HT_XL >= x2) && (cp->HT_XL >= x3)) ||
                            ((cp->HT_XR <= x2) && (cp->HT_XR <= x3))) {
                                continue;        /* x1 => x3,  1/13/89 */
                        }

                        /*
                         * Find cross point of current_edge and
                         * horizontal edge
                         */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        int_x = x2 + (sfix_t)((fix32)(x3 - x2) * (cp->HT_Y - y2) /
                                     (real32)(y3 - y2));
#elif  FORMAT_16_16
                        LongFixsMul((x3 - x2), (cp->HT_Y - y2), dest1);
                        int_x = x2 + LongFixsDiv((y3 - y2), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((x3 - x2), (cp->HT_Y - y2), dest1);
                        int_x = x2 + LongFixsDiv((y3 - y2), dest1);
#endif
                        if (int_x >= cp->HT_XL && int_x <= cp->HT_XR) {
                                /* put intersect point in xpnt_table */
                                put_in_xpnt_table(int_x, cp->HT_Y, cp, xp);
                                put_in_scany_table(cp->HT_Y);   /* @XPNT */

                        }
                } /* for */

            } else {    /* current edge is non-horizontal edge */

                /* Get end points of current edge */
                x0 = cp->ET_TOPX;
                y0 = cp->ET_TOPY;
                x1 = cp->ET_ENDX;
                y1 = cp->ET_ENDY;

                /* Get intersect points of current edge with all edges from
                 * first_edge to current_edge - 1
                 */
                for (cross_edge = et_first; cross_edge < current_edge;
                     cross_edge++) {
                        xp = edge_ptr[cross_edge];

                        /* skip horizontal edges @ET */
                        if (xp->ET_FLAG & HORIZ_EDGE) continue;

                        /* Get end points of cross edge */
                        x2 = xp->ET_TOPX;
                        y2 = xp->ET_TOPY;
                        x3 = xp->ET_ENDX;
                        y3 = xp->ET_ENDY;

                        /* Skip the edge coincides with current_edge at
                         * end point
                         */
                        if(y3 <= y0) {       /* end point1 < start point2 */
                                continue;
                        } else if ((x2 == x0) && (y2 == y0)) {
                                /* same start point */
                                continue;
                        } else if ((x3 == x1) && (y3 == y1)) {
                                /* same end point */
                                continue;
                        }

                        /*
                         * Find cross point of current_edge and
                         * cross_edge using parametric formula:
                         * current_edge = u + s * delta_u
                         * cross_edge   = v + t * delta_v
                         */

                        delta_x1 = (fix32)x1 - x0;
                        delta_y1 = (fix32)y1 - y0;
                        delta_x2 = (fix32)x3 - x2;
                        delta_y2 = (fix32)y3 - y2;
                        delta_topx = (fix32)x0 - x2;
                        delta_topy = (fix32)y0 - y2;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = (fix32)delta_x1 * delta_y2 -   /* @RPE_CLIP */
                                  (fix32)delta_x2 * delta_y1;

                        /* Collinear edges */
                        if(divider == 0) {               /* @PRE_CLIP */
                                continue;
                        }
#elif  FORMAT_16_16
                        LongFixsMul(delta_x1, delta_y2, dest2);
                        LongFixsMul(delta_x2, delta_y1, dest3);
                        if (dest2[0] == dest3[0] && dest2[1] == dest3[1])
                                continue;
#elif FORMAT_28_4
                        LongFixsMul(delta_x1, delta_y2, dest2);
                        LongFixsMul(delta_x2, delta_y1, dest3);
                        if (dest2[0] == dest3[0] && dest2[1] == dest3[1])
                                continue;
#endif
                        /* Solved parameters */
/* Enhancement of intersection point of line segments 4/19/89
 *
 *                      s = (((fix32)delta_x2 * delta_topy) -
 *                           ((fix32)delta_y2 * delta_topx) ) / (real32)divider;
 *                      t = (((fix32)delta_x1 * delta_topy) -
 *                           ((fix32)delta_y1 * delta_topx) ) / (real32)divider;
 *
 *                      (* Intersect just at one point *)
 *                      if(s>=(real32)0.0 && s<=(real32)1.0 &&
 *                         t>=(real32)0.0 && t<=(real32)1.0) {
 *                              (* Intersection point *)
 *                              int_x =(sfix_t)(x0 + s * delta_x1);
 *                              int_y =(sfix_t)(y0 + s * delta_y1);
 *
 *                              (* put intersect point in xpnt_table *)
 *                              put_in_xpnt_table(int_x, int_y, cp, xp);
 *                              put_in_scany_table(int_y);      (* @XPNT *)
 *
 *                      } (* if *)
 */

                        {
                                fix d_sign, s1_sign, t1_sign;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                s1 = ((fix32)delta_x2 * delta_topy) -
                                     ((fix32)delta_y2 * delta_topx);
                                t1 = ((fix32)delta_x1 * delta_topy) -
                                     ((fix32)delta_y1 * delta_topx);
                                d_sign = (divider >= 0) ? 0 : 1;
                                s1_sign = (s1 >= 0) ? 0 : 1;
                                t1_sign = (t1 >= 0) ? 0 : 1;
#elif  FORMAT_16_16
                                LongFixsMul(delta_x2, delta_topy, dest4);
                                LongFixsMul(delta_y2, delta_topx, dest5);
                                LongFixsMul(delta_x1, delta_topy, dest6);
                                LongFixsMul(delta_y1, delta_topx, dest7);

                                LongFixsSub(dest2, dest3, div_dif);
                                LongFixsSub(dest4, dest5, s1_dif);
                                LongFixsSub(dest6, dest7, t1_dif);

                                d_sign = (div_dif[0] < 0) ? 1 : 0;
                                s1_sign = (s1_dif[0] < 0) ? 1 : 0;
                                t1_sign = (t1_dif[0] < 0) ? 1 : 0;
#elif  FORMAT_28_4
                                LongFixsMul(delta_x2, delta_topy, dest4);
                                LongFixsMul(delta_y2, delta_topx, dest5);
                                LongFixsMul(delta_x1, delta_topy, dest6);
                                LongFixsMul(delta_y1, delta_topx, dest7);

                                LongFixsSub(dest2, dest3, div_dif);
                                LongFixsSub(dest4, dest5, s1_dif);
                                LongFixsSub(dest6, dest7, t1_dif);

                                d_sign = (div_dif[0] < 0) ? 1 : 0;
                                s1_sign = (s1_dif[0] < 0) ? 1 : 0;
                                t1_sign = (t1_dif[0] < 0) ? 1 : 0;
#endif

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                if ((d_sign ^ s1_sign) ||
                                    (d_sign ^ t1_sign) ||
                                    (LABS(s1) > LABS(divider)) ||
                                    (LABS(t1) > LABS(divider)))
                                    continue;

                                s = s1 / (real32)divider;
#elif  FORMAT_16_16
                                change_to_real(div_dif, &div_dif_f);
                                change_to_real(s1_dif,  &s1_dif_f);
                                change_to_real(t1_dif,  &t1_dif_f);

                                if ((d_sign ^ s1_sign)                  ||
                                    (d_sign ^ t1_sign)                  ||
                                    (LABS(s1_dif_f) > LABS(div_dif_f))  ||
                                    (LABS(t1_dif_f) > LABS(div_dif_f)))
                                        continue;
                                s = s1_dif_f / div_dif_f;
#elif  FORMAT_28_4
                                change_to_real(div_dif, &div_dif_f);
                                change_to_real(s1_dif,  &s1_dif_f);
                                change_to_real(t1_dif,  &t1_dif_f);

                                if ((d_sign ^ s1_sign)                  ||
                                    (d_sign ^ t1_sign)                  ||
                                    (LABS(s1_dif_f) > LABS(div_dif_f))  ||
                                    (LABS(t1_dif_f) > LABS(div_dif_f)))
                                        continue;
                                s = s1_dif_f / div_dif_f;
#endif
                                /* Intersection point */
                                int_x =(sfix_t)(x0 + s * delta_x1);
                                int_y =(sfix_t)(y0 + s * delta_y1);

                                /* put intersect point in xpnt_table */
                                put_in_xpnt_table(int_x, int_y, cp, xp);
                                put_in_scany_table(int_y);      /* @XPNT */
                        }
                } /* for cross edge */
            } /* if current_edge == horizontal */
        } /* for current edge */
        return;
}

/***********************************************************************
 * This module puts a point in xpnt_table.
 *
 * TITLE:       put_in_xpnt_table
 *
 * CALL:        put_in_xpnt_table(x, y, edge1, edge2, xt_addr)
 *
 * PARAMETERS:  x, y -- point
 *              edge1, edge2 -- point(x, y) is an endpoint of the edge
 *
 * INTERFACE:   setup_intersect_points
 *
 * CALLS:       none
 *
 * RETURN:      none
 **********************************************************************/
static void near put_in_xpnt_table(x, y, edge1, edge2)
sfix_t     x, y;
struct edge_hdr FAR *edge1, FAR *edge2;
{
        fix         i;
        struct      edge_hdr FAR *xp;

        /* create a new cross point, and put into xpnt_table
         */
        /* allocate an entry of edge_table @ET */
        if (--xt_end <= et_end) {
                ERROR(LIMITCHECK);
                return;
        }
        xp = &edge_table[xt_end];

        xp->XT_X = x;
        xp->XT_Y = y;
        xp->XT_EDGE1 = edge1;
        xp->XT_EDGE2 = edge2;

        /* Put it into xpnt_table in non_decreasing order */
        for (i=xt_end+1; i<=xt_start; i++) {
                if (y >= edge_ptr[i]->XT_Y) break;
                edge_ptr[i-1] = edge_ptr[i];
        }
        edge_ptr[i-1] = xp;

        /* add error tolerance of calculation of line intersection 4/19/89 */
        if ((i <= xt_start) && (y == edge_ptr[i]->XT_Y)) { /* check i 5/18/89 */
                if (ABS(x - edge_ptr[i]->XT_X) <= 3)
                        xp->XT_X = edge_ptr[i]->XT_X;
        }

        return;
}


static void near put_in_scany_table(y)          /* @XPNT */
sfix_t  y;
{

/*      (* Put it into scany_table in non_decreasing order *)
 *      for (i=st_end++; i>=0; i--) {
 *              if (y >= scany_table[i]) break;
 *              scany_table[i+1] = scany_table[i];
 *      }
 *      scany_table[i+1] = y;
 */
        if (st_end < (SCANY_TABLE_SZ - 1)) {
            scany_table[++st_end] = y;
        }
        else            /* 05/07/91, Peter */
        {
           ERROR(LIMITCHECK);
        }
}

/*
 * sort scany_table: 0 => st_end
 */
static void near sort_scany_table()
{
        /* initialization for quick sort */
        scany_table[st_end+1] = MAX_SFX;  /* Important !!! */

        scany_qsort (0, st_end);
}

/*
 * quick sort
 */
static void near scany_qsort (m, n)
fix     m, n;
{
        fix     i, j;
        sfix_t  key;
        register sfix_t t;    /* @RESO_UPGR */

        if (m < n) {
                i = m;
                j = n + 1;
                key = scany_table[m];
                while(1) {
                        for (i++;scany_table[i] < key; i++);
                        for (j--;scany_table[j] > key; j--);
                        if (i < j) {
                                /* swap (i, j); */
                                t = scany_table[i];
                                scany_table[i] = scany_table[j];
                                scany_table[j] = t;
                        } else
                                break;
                }

                /* swap (m, j); */
                t = scany_table[m];
                scany_table[m] = scany_table[j];
                scany_table[j] = t;

                scany_qsort (m, j-1);
                scany_qsort (j+1, n);
        }
}


/***********************************************************************
 * This module applies horizontal edges to partition the shape in
 * edge_table to a set of trapezoids.
 *
 * TITLE:       horiz_partition
 *
 * CALL:        horiz_partition(winding_type)
 *
 * PARAMETERS:  winding_type -- NON_ZERO/EVEN_ODD
 *
 * INTERFACE:   shape_reduction
 *
 * CALLS:       find_trapezoid, degen_trapezoid,
 *              convex_clipper
 *
 * RETURN:
 *
 * NOTE:        After calling this module, the caller should clear
 *              edge_tables.
 **********************************************************************/
static void near horiz_partition (winding_type) /* @SCAN_EHS, delete action */
ufix    winding_type;
{
        sfix_t   scan_y;                /* @ET, *bottom_scan; */
        fix      x_int_count, next, i, j, horiz_cnt;
        struct edge_hdr FAR *ep;

        /* Initialization */
        et_first = et_start;
        et_last = et_start - 1;
        xt_first = xt_start;
        st_first = 0;           /* @XPNT */

#ifdef DBG1
        printf(" horiz_partition():\n");
        printf(" et_start=%d, et_end=%d\n", et_start, et_end);
        dump_all_edge (et_start, et_end);
#endif

        /* Main loop, for each disjoint y_coordinate in edge_table */
        /* while (xt_first >= xt_end) { */
        while (st_first <= st_end) {    /* @XPNT */

            /* Find next horizontal scan line */
            /* scan_y = edge_ptr[xt_first]->XT_Y; */
            scan_y = scany_table[st_first];     /* @XPNT */

#ifdef DBG2
            printf(" scan_y = %f\n", scan_y/8.0);
#endif

            /* Advance last_edge to the next first entry with the
             * different y_coordinate
             */
            while (((next=et_last+1) <= et_end) &&
                   (edge_ptr[next]->ET_TOPY < scan_y)) et_last++;

            /* advance first edge @ET */
            //DJC The code below caused access problems, if the array was made
            //    up of  ALL FREE_EDGE bits then the array would be accesed beyond
            //    the end.
            //DJC ORIG while (edge_ptr[et_first]->ET_FLAG & FREE_EDGE) et_first++;

            //UPD059
            while (et_first < et_end && edge_ptr[et_first]->ET_FLAG & FREE_EDGE) et_first++;

            /*
             * Non-horizontal edges processing
             */
            if (et_first < et_last) {   /* Non-horizontal edges processing */

                /*
                 * the scan_y will try to intersect with all edges from
                 * et_first(included) to et_last(included).
                 */

                x_int_count = cross_with_horiz_line (scan_y);

                /* Assign winding_no for each intersecting edges */
                set_wno (winding_type);

                get_pairs (scan_y, x_int_count);

#ifdef DBG2
                printf(" edge_list(after trapedizing)-->\n");
                printf(" et_first=%d, et_last=%d\n", et_first, et_last);
                /*dump_all_edge (first_edge); @ET */
                dump_all_edge (et_first, et_last);
#endif
            }

            /*
             * Horizontal edges processing
             */
            /* sort horizontal edges in x-coord then non-horizontal ones */
            horiz_cnt=0;
            i = et_last + 1;
            while (((next=et_last+1) <= et_end) &&
                   (edge_ptr[next]->ET_TOPY == scan_y)) {
                et_last++;

                if (!(edge_ptr[et_last]->ET_FLAG & HORIZ_EDGE)) continue;

                ep = edge_ptr[et_last];

                /* free this hozizontal edge */
                ep->ET_FLAG |= FREE_EDGE;
                horiz_cnt++;

                for (j = et_last-1; j >= i; j--) {
                    if ((edge_ptr[j]->ET_FLAG & HORIZ_EDGE) &&
                        (ep->HT_XL >= edge_ptr[j]->HT_XL)) break;
                    edge_ptr[j+1] = edge_ptr[j];
                }
                edge_ptr[j+1] = ep;
            }
#ifdef DBG2
            printf(" edge_list(after sort horiz edges)-->\n");
            printf(" et_first=%d, et_last=%d\n", et_first, et_last);
            dump_all_edge (et_first, et_last);
#endif

            while ((--horiz_cnt) > 0) {      /* more than 2 horizontal edges */
                struct edge_hdr FAR *ep1, FAR *ep2;
                sfix_t xl, xr;

                /* the 2 consective horizontal edges that overay each other
                 * will construct a degnerate trapezoid
                 */

                ep1 = edge_ptr[i];
                ep2 = edge_ptr[++i];
                if ((ep1->HT_XR > ep2->HT_XL) &&
                    (ep1->HT_XL < ep2->HT_XR)) {
                    /* create a trapezoid:
                     *              (ep1->HT_XL, ep1->HT_Y),
                     *              (ep1->HT_XR, ep1->HT_Y),
                     *              (ep2->HT_XR, ep2->HT_Y),
                     *              (ep2->HT_XL, ep2->HT_Y)
                     */

                    /* get endpoints of the horizontal edge */
                    xl = (ep1->HT_XL < ep2->HT_XL) ?
                         ep1->HT_XL : ep2->HT_XL;
                    xr = (ep1->HT_XR > ep2->HT_XR) ?
                         ep1->HT_XR : ep2->HT_XR;
                    degen_tpzd (ep1->HT_Y, xl, xr);
                } /* if */
            } /* while */

            /* update xt_table @ET */
            /* while ((xt_first >= xt_end) &&           @XPNT
             *      (edge_ptr[xt_first]->XT_Y <= scan_y)) xt_first--;
             */
            while ((st_first <= st_end) &&
                   (scany_table[st_first] <= scan_y)) st_first++;

            /* update et_table @ET */
            for (i = et_first; i <= et_last; i++) {
                if ((ep=edge_ptr[i])->ET_ENDY <= scan_y)
                    ep->ET_FLAG |= FREE_EDGE;
            }

        } /* main loop */

        return;
}


static fix near cross_with_horiz_line (scan_y)
sfix_t  scan_y;
{
        struct   edge_hdr FAR *ep;
        ET_IDX   edge;
        fix      x_int_count = 0;
//      real32    temp;         @WIN

        struct  edge_hdr FAR *xp, FAR *ip;
        fix     i;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif  FORMAT_16_16
        long dest1[2];
#elif  FORMAT_28_4
        long dest1[2];
#endif


        /* initialize all edges */
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                edge_ptr[edge]->ET_FLAG &= ~CROSS_PNT;
        }

        while ((xt_first >= xt_end) &&                  /* Jul-18-91 SC */
               ((xp=edge_ptr[xt_first])->XT_Y < scan_y)) {
                xt_first--;
        }

        /* set intersect x_coordinate due to xpnt_table */
        while ((xt_first >= xt_end) &&
            ((xp=edge_ptr[xt_first])->XT_Y == scan_y)) {
            register struct edge_hdr FAR *p;

            if (!((p=xp->XT_EDGE1)->ET_FLAG & CROSS_PNT)) { /* once only */
                p->ET_XINT0 = p->ET_XINT;           /* @SRD */
                p->ET_XINT = xp->XT_X;
                p->ET_FLAG |= CROSS_PNT;
            } else {    /* @OLXPNT 7-31-91 scchen */
                if (p->ET_XINT0 > p->ET_XINT) { /* get max xint */
                    if (p->ET_XINT < xp->XT_X) p->ET_XINT = xp->XT_X;
                } else {
                    if (p->ET_XINT > xp->XT_X) p->ET_XINT = xp->XT_X;
                }
            }
            if (!((p=xp->XT_EDGE2)->ET_FLAG & CROSS_PNT)) { /* once only */
                p->ET_XINT0 = p->ET_XINT;           /* @SRD */
                p->ET_XINT = xp->XT_X;
                p->ET_FLAG |= CROSS_PNT;
            } else {    /* @OLXPNT 7-31-91 scchen */
                if (p->ET_XINT0 > p->ET_XINT) { /* get max xint */
                    if (p->ET_XINT < xp->XT_X) p->ET_XINT = xp->XT_X;
                } else {
                    if (p->ET_XINT > xp->XT_X) p->ET_XINT = xp->XT_X;
                }
            }
            xt_first--;
        }

        /* Intersect all edges with scan_y
         */
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                ep = edge_ptr[edge];

#ifdef DBG2
                printf("&edge:%lx   (%f, %f)  (%f, %f) %f  ", ep,
                       SFX2F(ep->ET_TOPX),
                       SFX2F(ep->ET_TOPY), SFX2F(ep->ET_ENDX),
                       SFX2F(ep->ET_ENDY), SFX2F(ep->ET_XINT));

                if (ep->ET_FLAG & HORIZ_EDGE) printf("- ");
                else if (ep->ET_FLAG & WIND_UP) printf("^ ");
                else printf("v ");
                if (ep->ET_FLAG & FREE_EDGE) printf("F ");
                if (ep->ET_FLAG & CROSS_PNT) printf("X ");
                if (ep->ET_WNO) printf("W ");
                printf("\n");
#endif

                /*
                 * intersect edge with scan_y
                 */
                if(ep->ET_FLAG & FREE_EDGE) {
                        continue;
                } else if (!(ep->ET_FLAG & CROSS_PNT)) {

                    /* check if end point @XPNT */
                    if (ep->ET_ENDY == scan_y) {
                        ep->ET_XINT0 = ep->ET_XINT;
                        ep->ET_XINT = ep->ET_ENDX;
                        ep->ET_FLAG |= CROSS_PNT;
                    } else {
#ifdef DBG2
                        printf(" Not end point\n");
#endif

                        /* Enhancement of intersection point of line segments
                         * 4/19/89
                         */
                        /*temp = (real32)(ep->ET_ENDX - ep->ET_TOPX) /
                         *             (ep->ET_ENDY - ep->ET_TOPY);
                         *ep->ET_XINT0 = ep->ET_XINT;
                         *ep->ET_XINT = ep->ET_TOPX +
                         *       ROUND((scan_y - ep->ET_TOPY) * temp);
                         */
                        ep->ET_XINT0 = ep->ET_XINT;             /* @SRD */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        ep->ET_XINT = (sfix_t)(ep->ET_TOPX +    /*@WIN*/
                                      (scan_y - ep->ET_TOPY) *
                                      (fix32)(ep->ET_ENDX - ep->ET_TOPX) /
                                      (fix32)(ep->ET_ENDY - ep->ET_TOPY));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - ep->ET_TOPY),
                                (ep->ET_ENDX - ep->ET_TOPX), dest1);
                        ep->ET_XINT = ep->ET_TOPX + LongFixsDiv(
                                        (ep->ET_ENDY - ep->ET_TOPY), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - ep->ET_TOPY),
                                (ep->ET_ENDX - ep->ET_TOPX), dest1);
                        ep->ET_XINT = ep->ET_TOPX + LongFixsDiv(
                                        (ep->ET_ENDY - ep->ET_TOPY), dest1);
#endif
                    } /* if end point @XPNT */
                } /* if FREE_EDGE */

#ifdef DBG2
                printf(" intersect scan_y(%f) with edge#%d at x_int =%f\n",
                        scan_y/8.0, edge, ep->ET_XINT/8.0);
#endif

                /* accumulate x_int_count */
                x_int_count++;

                /* Adjust the entry of edge in edge_table due to
                 * its value of intersect field;
                 */
                for (i=edge-1; i>=et_first; i--) {
                    ip = edge_ptr[i];

                    /* Skip non_intersecting edges @FRE_PAR */
                    if (!(ip->ET_FLAG & FREE_EDGE)) {
                        if (ep->ET_XINT > ip->ET_XINT) break;

/*                      (* Fixed bug; set them as cross points when the
 *                       * intersect points are same; not need to be identical
 *                       * edges. 4/11/90 *)
 *                      else if (ep->ET_XINT == ip->ET_XINT) {
 *                          if (ep->ET_XINT0 > ip->ET_XINT0) break;
 *                          else if (ep->ET_XINT0 == ip->ET_XINT0) {
 *                              (* identical edges; always partition *)
 *                              ep->ET_FLAG |= CROSS_PNT;
 *                              ip->ET_FLAG |= CROSS_PNT;
 *                              break;
 *                          } (* if == *)
 *                      } (* if > *)
 */
                        else if (ep->ET_XINT == ip->ET_XINT) {
                            ep->ET_FLAG |= CROSS_PNT;
                            ip->ET_FLAG |= CROSS_PNT;
                            /*if (ep->ET_XINT0 >= ip->ET_XINT0) break;4/30/91*/
                            if (ep->ET_XINT0 > ip->ET_XINT0) break;
                            if (ep->ET_XINT0 == ip->ET_XINT0 &&
                                !ip->ET_WNO) break;
                        } /* if > */

                    } /* if ! */
                    edge_ptr[i+1] = edge_ptr[i];
                }
                edge_ptr[i+1] = ep;

        } /* for */

#ifdef DBG2
        printf(" edge_list(After sorting in x_int)-->\n");
        printf(" et_first=%d, et_last=%d\n", et_first, et_last);
        dump_all_edge (et_first, et_last);
#endif

        return(x_int_count);

}


static void near set_wno (winding_type)
ufix    winding_type;
{
        fix     w_no;
        bool    done = FALSE;
        struct  edge_hdr FAR *ep;
        ET_IDX  edge;

        w_no = 0;
        for (edge = (ET_IDX)et_first; edge <= et_last; edge++) {
                ep = edge_ptr[edge];

                /* check exit condition */
                /* Skip free edges @FRE_PAR */
                if (ep->ET_FLAG & FREE_EDGE) {
                        continue;
                }

                /* Accumulate winding_no due to its direction */
                if (ep->ET_FLAG & WIND_UP)
                        w_no++;
                else
                        w_no--;

                if (((winding_type == NON_ZERO) && (w_no != 0))
                    || ((winding_type == EVEN_ODD) &&
                    (w_no & 0x1))) {
                        ep->ET_WNO = 1;
                } else
                        ep->ET_WNO = 0;

        }
        return;
}


static void near get_pairs (scan_y, x_int_count)
sfix_t  scan_y;
fix     x_int_count;
{
        bool    split_flag;
        bool    split1, split2;         /* @SPLIT */
        ET_IDX  edge;
        struct  edge_hdr FAR *ep1, FAR *ep2;
        fix     cnt;

        for (cnt=0, edge = (ET_IDX)et_first; cnt < (x_int_count - 1); cnt++) {

            while ((ep1=edge_ptr[edge])->ET_FLAG & FREE_EDGE) edge++;

            while ((ep2=edge_ptr[++edge])->ET_FLAG & FREE_EDGE);

            /* Check winding number of the area between
             * edge1 and edge2
             */
            if (ep1->ET_WNO) {

                /* check endpoints:
                 * join at endpoint of either edges, then the area is required
                 */
                if (ep1->ET_FLAG & CROSS_PNT) {
                    /* Join at endpoint of edge1 */
                    /* get the trapezoid, and perform the action */
                    find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                   ep1, ep2);

                    /* check if need to modify edge2 */
                    /* if (!(ep2->ET_FLAG & CROSS_PNT)) { always setting @SRD */
                            /* not join at cross point; needs to modify */
                            ep2->ET_LFTX = ep2->ET_XINT;
                            ep2->ET_LFTY = scan_y;
                    /* } */

                } else { /* not join at endpoint of edge1 */
                    if (ep2->ET_FLAG & CROSS_PNT) {
                        /* Join at endpoint of edge2 */
                        /* get the trapezoid, and perform the action */
                        find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                       ep1, ep2);

                        /* modify edge1 */
                        ep1->ET_RHTX = ep1->ET_XINT;

                    } else {
                        /* not join at either endpoints */
                         fix i;
                         struct edge_hdr FAR *ip;

                         /* not join at either endpoints */
                         split_flag = FALSE;
                         split1 = split2 = FALSE;       /* @SPLIT */
                         for (i = et_last; i <= et_end; i++) {
                             ip = edge_ptr[i];
                             if (ip->ET_TOPY > scan_y) break;
                             if ((ip->ET_TOPX > ep1->ET_XINT) &&
                                 (ip->ET_TOPX < ep2->ET_XINT)) {
                                 split_flag = TRUE;
                                 break;
                             } else {   /* @SPLIT */
                                if (ip->ET_TOPX == ep1->ET_XINT) {
                                   split1 = TRUE;
                                   split_flag = TRUE;
                                }
                                if (ip->ET_TOPX == ep2->ET_XINT) {
                                   split2 = TRUE;
                                   split_flag = TRUE;
                                }
                                if (split_flag) break;
                             }
                         }

                         if (split_flag) {
                             /* slpit edge1 and edge2 */
                             find_trapezoid(scan_y, ep1->ET_XINT, ep2->ET_XINT,
                                            ep1, ep2);

                             /* modify edge1 and edge2 */
                             ep1->ET_RHTX = ep1->ET_XINT;
                             ep2->ET_LFTX = ep2->ET_XINT;
                             ep2->ET_LFTY = scan_y;
                             /* @SPLIT; 7/29/91 */
                             if (split1) ep1->ET_LFTX = ep1->ET_XINT;
                             if (split2) ep2->ET_RHTX = ep2->ET_XINT;
                         } /* if split_flag */

                    } /* if endpoint of ep2 */
                } /* if endpoint of ep1 */
            } /* if winding_type */

            /* modify edge1 that is a cross point */
            if (ep1->ET_FLAG & CROSS_PNT) {
                /* modify edge1 */
                ep1->ET_RHTX = ep1->ET_LFTX = ep1->ET_XINT;
                ep1->ET_LFTY = scan_y;
            }

        } /* for */

        /* modify the last edge2 that is a cross point */
        if (ep2->ET_FLAG & CROSS_PNT) {
            /* modify edge2 */
            ep2->ET_RHTX = ep2->ET_LFTX = ep2->ET_XINT;
            ep2->ET_LFTY = scan_y;
        }

        return;
}



static void near degen_tpzd (y, xl, xr)                 /* @ET */
sfix_t  y, xl, xr;
{
        CP_IDX icp;
        struct nd_hdr FAR *cp;
        sfix_t  cp_xl, cp_xr, max_xl, min_xr;

#ifdef DBG2
                printf(" degen_tpzd(): y=%f, xl=%f, xr=%f\n", SFX2F(y),
                        SFX2F(xl), SFX2F(xr));
#endif
                /* Clip the edge to each clip trapezoid */
                for (icp = GSptr->clip_path.head; icp != NULLP;
                    icp = cp->next) {

                    cp = &node_table[icp];

#ifdef DBG2
                    printf(" Sub_clip#%d:", icp);
                    printf("(%f, %f, %f), ", cp->CP_TOPY/8.0,
                           cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0);
                    printf("(%f, %f, %f)\n", cp->CP_BTMY/8.0,
                           cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif
                    if ((y >= cp->CP_TOPY) &&
                        (y <= cp->CP_BTMY)) {
                        /* inside the clip trapezoid */

                        /* get endpoints  */
                        if ((cp->CP_TOPXL == cp->CP_BTMXL) &&      /* @EHS_HOZ */
                            (cp->CP_TOPXR == cp->CP_BTMXR)) {
                                cp_xl = cp->CP_TOPXL;
                                cp_xr = cp->CP_TOPXR;
                        } else if (cp->CP_TOPY == cp->CP_BTMY) {
                                cp_xl = (cp->CP_TOPXL < cp->CP_BTMXL) ?
                                         cp->CP_TOPXL : cp->CP_BTMXL;
                                cp_xr = (cp->CP_TOPXR < cp->CP_BTMXR) ?
                                         cp->CP_TOPXR : cp->CP_BTMXR;
                        } else {
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                                real32  r;
                                r = (real32)(y - cp->CP_TOPY) /
                                     (cp->CP_BTMY - cp->CP_TOPY);
                                cp_xl = cp->CP_TOPXL +
                                      (sfix_t)(r * (cp->CP_BTMXL-cp->CP_TOPXL));
                                cp_xr = cp->CP_TOPXR +
                                      (sfix_t)(r * (cp->CP_BTMXR-cp->CP_TOPXR));
#elif  FORMAT_16_16
                                long dest1[2];
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                                cp_xl = cp->CP_TOPXL +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                                cp_xr = cp->CP_TOPXR +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
#elif  FORMAT_28_4
                                long dest1[2];
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXL - cp->CP_TOPXL), dest1);
                                cp_xl = cp->CP_TOPXL +
                                        LongFixsDiv(
                                           (cp->CP_BTMY - cp->CP_TOPY), dest1);
                                LongFixsMul((y - cp->CP_TOPY),
                                        (cp->CP_BTMXR - cp->CP_TOPXR), dest1);
                                cp_xr = cp->CP_TOPXR +
                                        LongFixsDiv(
                                          (cp->CP_BTMY - cp->CP_TOPY), dest1);
#endif
                        }

                        /* check if intersect */
                        max_xl = (xl > cp_xl) ? xl : cp_xl;
                        min_xr = (xr < cp_xr) ? xr : cp_xr;
                        if (max_xl <= min_xr) {
                                /* the clipped edge: max_xl -> min_xr */
                                struct tpzd tpzd;

                                tpzd.topy = tpzd.btmy = y;
                                tpzd.topxl = tpzd.btmxl = max_xl;
                                tpzd.topxr = tpzd.btmxr = min_xr;
                                save_tpzd (&tpzd);

                                /* break if edge totally inside the clip */
                                if ((max_xl == xl) && (min_xr == xr)) break;
                        } /* if max_xl */
                    } /* if y */
                } /* for icp */
}



/***********************************************************************
 * Given two edges, this module finds a trapezoid confined by the two
 * edges, and saves the trapezoid or clips it against current clip according to
 * if it is totally inside the clipping region.
 *
 * TITLE:       find_trapezoid
 *
 * CALL:        find_trapezoid(winding_type, paint_flag, result_path)
 *
 * PARAMETERS:
 *
 * INTERFACE:   horiz_partition
 *
 * CALLS:       save_tpzd, convex_clipper
 *
 * RETURN:
 **********************************************************************/
static void near find_trapezoid (btm_y, btm_xl, btm_xr, ep1, ep2)
sfix_t btm_y, btm_xl, btm_xr;
struct edge_hdr FAR *ep1, FAR *ep2;
{
        struct polygon_i  t_polygon;

        /* Error recovery: modify left, right coord of edges that have
         * computation errors arose from integer arithmatics operations on
         * nearly-horizontal edges      @SRD
         */
        if (ep1->ET_RHTX > ep2->ET_LFTX) {
            sfix_t tmp, t1, t2;
#ifdef DBGwarn
            printf("\n\07find_trapezoid() warning!\n");
            printf("&edge1:%lx  RHTX=%f, LFTX=%f, LEFTY=%f, XINT0=%f\n", ep1,
                    SFX2F(ep1->ET_RHTX), SFX2F(ep1->ET_LFTX),
                    SFX2F(ep1->ET_LFTY), SFX2F(ep1->ET_XINT0));
            printf("&edge2:%lx  RHTX=%f, LFTX=%f, LEFTY=%f, XINT0=%f\n", ep2,
                    SFX2F(ep2->ET_RHTX), SFX2F(ep2->ET_LFTX),
                    SFX2F(ep2->ET_LFTY), SFX2F(ep2->ET_XINT0));
            printf("btm_y=%f, btm_xl=%f, btm_xr=%f\n",
                    SFX2F(btm_y), SFX2F(btm_xl), SFX2F(btm_xr));
#ifdef DBG1
            dump_all_edge (et_first, et_last);
#endif
#endif
            /* select the nearest point 4/19/89 */
            tmp = btm_xl/2 + btm_xr/2;
            t1 = ABS(ep1->ET_RHTX - tmp);
            t2 = ABS(ep2->ET_LFTX - tmp);
            if (t1 > t2)
                ep1->ET_RHTX = ep2->ET_LFTX;
            else
                ep2->ET_LFTX = ep1->ET_RHTX;

#ifdef DBGwarn
            printf("After modification: top left_x =%f, right_x =%f\n",
                    SFX2F(ep1->ET_RHTX), SFX2F(ep2->ET_LFTX));
#endif
        }

        /* save the trapezoid if it is inside the single rectangle clip */
        if ((GSptr->clip_path.single_rect) &&
            (ep2->ET_LFTY >= GSptr->clip_path.bb_ly) &&         /* top_y */
            (ep1->ET_RHTX >= GSptr->clip_path.bb_lx) &&         /* top_xl */
            (ep2->ET_LFTX <= GSptr->clip_path.bb_ux) &&         /* top_xr */
            (btm_y        <= GSptr->clip_path.bb_uy) &&         /* btm_y */
            (btm_xl       >= GSptr->clip_path.bb_lx) &&         /* btm_xl */
            (btm_xr       <= GSptr->clip_path.bb_ux)   ) {      /* btm_xr */
                struct tpzd tpzd;

#ifdef DBG1
        printf(" inside single rectangle clip\n");
#endif
                /* totally inside the clip region */
                tpzd.topy = ep2->ET_LFTY;
                tpzd.topxl = ep1->ET_RHTX;
                tpzd.topxr = ep2->ET_LFTX;
                tpzd.btmy = btm_y;
                tpzd.btmxl = btm_xl;
                tpzd.btmxr = btm_xr;
                save_tpzd(&tpzd);

        } else {
                /* clip the trapezoid against current clip path */

                /* Create a polygon contains the trapezoid:
                 */
                t_polygon.size = 4;
                t_polygon.p[0].x = ep1->ET_RHTX;
                t_polygon.p[1].x = ep2->ET_LFTX;
                t_polygon.p[0].y = t_polygon.p[1].y = ep2->ET_LFTY;
                t_polygon.p[2].x = btm_xr;
                t_polygon.p[3].x = btm_xl;
                t_polygon.p[2].y = t_polygon.p[3].y = btm_y;

                convex_clipper (&t_polygon, CC_TPZD);
                                /* CC_TPZD: a trapezoid */
        }
        return;
}


/***********************************************************************
 * Given a convex polygon, this module clips it against the clipping region, and
 * saves the result(clipped polygon) or calls pgn_reduction to reduce it to
 * a set of trapezoids.
 *
 * TITLE:       Convex_clipper
 *
 * CALL:        Convex_clipper(in_polygon, flag)
 *
 * PARAMETERS:  in_polygon -- polygon to be clipped
 *              flag -- CC_IMAGE : called from image operator
 *                      CC_TPZD  : in_polygon is a trapezoid
 *
 * INTERFACE:
 *
 * CALLS:       save_tpzd, pgn_reduction
 *
 * RETURN:      FALSE -- out of node table when sets up sample list for image
 *              TRUE  -- normal
 **********************************************************************/
bool convex_clipper (in_polygon, flag)     /* @SCAN_EHS, delete action */
struct polygon_i FAR *in_polygon;
bool    flag;
{
    fix i, ix, s, p;
    sfix_t cp_lx, cp_ly, cp_ux, cp_uy;
    sfix_t in_lx, in_ly, in_ux, in_uy;
    sfix_t min_x, max_x, min_y, max_y;

    struct polygon_i polygon1, polygon2;  /* working polygon */
    struct polygon_i FAR *in, FAR *out, FAR *tmp;   /*@WIN*/
    ET_IDX icp;
//  SP_IDX isp; /* index of sample list */      @WIN
    struct nd_hdr FAR *cp;
    struct tpzd tpzd;           /* @SCAN_EHS */

    ufix16  plcode, pucode;   /* pcode for checking if bounding box of
                               * in_polygon totally outside or inside the
                               * clip region.
                               * 4 bits for each variable:(see below)
                               *   bit 0: BOTTOM
                               *   bit 1: TOP
                               *   bit 2: RIGHT
                               *   bit 3: LEFT
                               */
#define BOTTOM 1
#define TOP    2
#define RIGHT  4
#define LEFT   8

    struct coord_i *isect;

#ifdef DBG1
        printf ("Convex_clipper(): flag=");
        if (flag == CC_IMAGE)
                printf("CC_IMAGE\n");
        else if (flag == CC_TPZD)
                printf("CC_TPZD\n");
        else
                printf("Not a TPZD\n");
        printf("polygon=");
        for (i=0; i < in_polygon->size; i++) {
                printf(" (%f,%f)", in_polygon->p[i].x/8.0,
                                   in_polygon->p[i].y/8.0);
        }
        printf("\n");
#endif

    /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of current clip */
    cp_lx = GSptr->clip_path.bb_lx;
    cp_ly = GSptr->clip_path.bb_ly;
    cp_ux = GSptr->clip_path.bb_ux;
    cp_uy = GSptr->clip_path.bb_uy;

    /* find bounding box(in_lx, in_ly), (in_ux, in_uy) of in_polygon
     */
    /* for in_ly & in_uy */
    if (flag == CC_TPZD) {                  /* if(tpzd_flag) {   @SCAN_EHS */
        /* trapezoid, boundary of y-coordinates is trival */
        in_ly = in_polygon->p[0].y;
        in_uy = in_polygon->p[2].y;

    } else {
        /* otherwise, needs to calculate */
        if (in_polygon->p[0].y >= in_polygon->p[1].y) {
                max_y = in_polygon->p[0].y;
                min_y = in_polygon->p[1].y;
        } else {
                max_y = in_polygon->p[1].y;
                min_y = in_polygon->p[0].y;
        }
        if (in_polygon->p[2].y >= in_polygon->p[3].y) {
                in_uy = in_polygon->p[2].y;
                in_ly = in_polygon->p[3].y;
        } else {
                in_uy = in_polygon->p[3].y;
                in_ly = in_polygon->p[2].y;
        }
        in_uy = (in_uy > max_y) ? in_uy : max_y;
        in_ly = (in_ly < min_y) ? in_ly : min_y;
    } /* if flag */

    /* for in_lx & in_ux */
    if (in_polygon->p[0].x >= in_polygon->p[1].x) {
            max_x = in_polygon->p[0].x;
            min_x = in_polygon->p[1].x;
    } else {
            max_x = in_polygon->p[1].x;
            min_x = in_polygon->p[0].x;
    }
    if (in_polygon->p[2].x >= in_polygon->p[3].x) {
            in_ux = in_polygon->p[2].x;
            in_lx = in_polygon->p[3].x;
    } else {
            in_ux = in_polygon->p[3].x;
            in_lx = in_polygon->p[2].x;
    }
    in_ux = (in_ux > max_x) ? in_ux : max_x;
    in_lx = (in_lx < min_x) ? in_lx : min_x;

    /* set up Pcode for (in_lx, in_ly), and (in_ux, in_uy) */
    /* initialization */
    plcode = pucode = 0;
    if (in_lx < cp_lx) plcode |= LEFT;
    if (in_lx > cp_ux) plcode |= RIGHT;
    if (in_ly < cp_ly) plcode |= TOP;
    if (in_ly > cp_uy) plcode |= BOTTOM;

    if (in_ux < cp_lx) pucode |= LEFT;
    if (in_ux > cp_ux) pucode |= RIGHT;
    if (in_uy < cp_ly) pucode |= TOP;
    if (in_uy > cp_uy) pucode |= BOTTOM;

    /* check if totally outside clip polygon */
    if (plcode && pucode && (plcode & pucode)) {
#ifdef DBG1
        printf(" outside clip\n");
#endif
            return(TRUE);   /* fine, do nothing */
    }

    /* Check if in_path totally inside the rectangle current clip */
    if (((plcode == 0) && (pucode == 0)) &&
            GSptr->clip_path.single_rect) {
#ifdef DBG1
        printf(" inside single rectangle clip\n");
#endif

            /*if (flag == CC_IMAGE) {     (* @IAMGE: move to image.c 1/16/89 *)
             *  (* set up sample list of image *)
             *  if((isp = get_node()) == NULLP) return(FALSE);
             *          (* out of node table, need to render sample list *)
             *  node_table[isp].SAMPLE_BB_LX = image_info.bb_lx;
             *  node_table[isp].SAMPLE_BB_LY = image_info.bb_ly;
             *  node_table[isp].SEED_INDEX   = image_info.seed_index;
             *                                  (* @#IMAGE 04-27-88  Y.C. *)
             *  node_table[isp].next =
             *          gray_chain[image_info.gray_level].start_seed_sample;
             *  gray_chain[image_info.gray_level].start_seed_sample = isp;
             *
             *} else if (flag == CC_TPZD) {
             */
            if (flag == CC_TPZD) {
                /* the polygon is a trapezoid, just need to save the trapezoid
                 */
                tpzd.topy = in_polygon->p[0].y;
                tpzd.topxl = in_polygon->p[0].x;
                tpzd.topxr = in_polygon->p[1].x;
                tpzd.btmy = in_polygon->p[3].y;
                tpzd.btmxl = in_polygon->p[3].x;
                tpzd.btmxr = in_polygon->p[2].x;
                save_tpzd(&tpzd);
            } else {
                /* in_polygon not a trapezoid, to reduce it to trapezoids */
                pgn_reduction(in_polygon);
            }

            return(TRUE);
    }

    /* Clip in_path to each clip trapezoid */
    for (icp = GSptr->clip_path.head; icp != NULLP; icp = cp->next) {

        cp = &node_table[icp];

#ifdef DBG2
        printf(" Sub_clip#%d:", icp);
        printf("(%f, %f, %f), ", cp->CP_TOPY/8.0,
               cp->CP_TOPXL/8.0, cp->CP_TOPXR/8.0);
        printf("(%f, %f, %f)\n", cp->CP_BTMY/8.0,
               cp->CP_BTMXL/8.0, cp->CP_BTMXR/8.0);
#endif

        /* Check if in_polygon totally outside the bounding box
         * of sub_clipping trapezoid
         */

        /* find bounding box(cp_lx, cp_ly), (cp_ux, cp_uy) of
         * the trapezoid
         */
        cp_lx = (cp->CP_TOPXL < cp->CP_BTMXL) ?
                cp->CP_TOPXL : cp->CP_BTMXL;
        cp_ly = cp->CP_TOPY;
        cp_ux = (cp->CP_TOPXR > cp->CP_BTMXR) ?
                cp->CP_TOPXR : cp->CP_BTMXR;
        cp_uy = cp->CP_BTMY;

        /* set up Pcode for (in_lx, in_ly), and (in_ux, in_uy) */
        /* initialization */
        plcode = pucode = 0;
        if (in_lx < cp_lx) plcode |= LEFT;
        if (in_lx > cp_ux) plcode |= RIGHT;
        if (in_ly < cp_ly) plcode |= TOP;
        if (in_ly > cp_uy) plcode |= BOTTOM;

        if (in_ux < cp_lx) pucode |= LEFT;
        if (in_ux > cp_ux) pucode |= RIGHT;
        if (in_uy < cp_ly) pucode |= TOP;
        if (in_uy > cp_uy) pucode |= BOTTOM;

        if (plcode && pucode && (plcode & pucode)) {
#ifdef DBG2
        printf(" outside sub_clip#%d\n", icp);
#endif
                continue;
        }

        /* Check if in_polygon totally inside the rectangle
         * clipping trapezoid
         */
        if ((plcode == 0) && (pucode == 0) &&
                (cp->CP_TOPXL == cp->CP_BTMXL) &&
                (cp->CP_TOPXR == cp->CP_BTMXR)) {
#ifdef DBG2
                printf(" inside sub_clip#%d\n", icp);
#endif

                if (flag == CC_TPZD) {
                    /* the polygon is a trapezoid, just need to save the tpzd
                     */
                    tpzd.topy = in_polygon->p[0].y;
                    tpzd.topxl = in_polygon->p[0].x;
                    tpzd.topxr = in_polygon->p[1].x;
                    tpzd.btmy = in_polygon->p[3].y;
                    tpzd.btmxl = in_polygon->p[3].x;
                    tpzd.btmxr = in_polygon->p[2].x;
                    save_tpzd(&tpzd);
                } else {
                    /* in_polygon not a trapezoid, to reduce it to trapezoids */
                    pgn_reduction(in_polygon);
                }

                return(TRUE);   /* in_polygon totally inside a clipping
                                 * trapezoid, so it cannot intersect
                                 * with other clipping trapezoids.
                                 */
        }


        /*
         * Perform Sutherland-Hodgeman clipping algorithm
         */

        clip[0].cp.x = cp->CP_TOPXL;
        clip[0].cp.y = cp->CP_TOPY;
        clip[1].cp.x = cp->CP_TOPXR;
        clip[1].cp.y = cp->CP_TOPY;
        clip[2].cp.x = cp->CP_BTMXR;
        clip[2].cp.y = cp->CP_BTMY;
        clip[3].cp.x = cp->CP_BTMXL;
        clip[3].cp.y = cp->CP_BTMY;
        clip[4].cp.x = cp->CP_TOPXL;
        clip[4].cp.y = cp->CP_TOPY;

        polygon1.size = in_polygon->size;
        for (i = 0; i < in_polygon->size; i++) {
                polygon1.p[i].x = in_polygon->p[i].x;
                polygon1.p[i].y = in_polygon->p[i].y;
        }

        in = (struct polygon_i FAR *)&polygon1; /*@WIN*/
        out = (struct polygon_i FAR *)&polygon2;

        /* clip subject to each clip boundary of the clip trapezoid */
        for (i = 0; i < 4; i++) {
            bool flag;           /* @INSIDE1 */

            /* let s = last vertex of the subject polygon */
            s = (in->size) - 1;
            ix = 0;

            /* for each edge of subject(in_polygon) */
            for (p = 0; p < in->size; p++) {

                if (flag = inside(in->p[p], i)) {

                    if (inside(in->p[s], i)) {
                            /* inside -> inside */
                            out->p[ix].x = in->p[p].x;
                            out->p[ix].y = in->p[p].y;
                            ix++;

                    } else {     /* outside -> inside */
                            /* output intersect point */
                            if (flag != ON_CLIP) {      /* @INDISE1 */
                                /* create a intersect point only when the end
                                 * point(in->p[p]) is not on the clipping
                                 * boundary
                                 */
                                isect = intersect (in->p[s], in->p[p], i);
                                out->p[ix].x = isect->x;
                                out->p[ix].y = isect->y;
                                ix++;
                            }

                            /* output p */
                            out->p[ix].x = in->p[p].x;
                            out->p[ix].y = in->p[p].y;
                            ix++;

                    }
                } else {
                    if (flag = inside(in->p[s], i)) {
                            /* inside -> outside */
                            /* output intersect point */
                            if (flag != ON_CLIP) {      /* @INSIDE1 */
                                /* create a intersect point only when the start
                                 * point(in->p[s]) is not on the clipping
                                 * boundary
                                 */
                                isect = intersect (in->p[s], in->p[p], i);
                                out->p[ix].x = isect->x;
                                out->p[ix].y = isect->y;
                                ix++;
                            }

                    } /* else,  outside -> outside, do nothing */
                }

                s = p;

            } /* for each node of the subject */

            /* set up out polygon */
            out->size = (fix16)ix;

            /* swap in and out polygon */
            tmp = in;
            in = out;
            out = tmp;
#ifdef DBG2
            printf(" After clipping over clip edge:\n (%f, %f) --> (%f, %f)\n",
                clip[i].cp.x/8.0, clip[i].cp.y/8.0,
                clip[i+1].cp.x/8.0, clip[i+1].cp.y/8.0);
            printf(" polygon:");
            for (p = 0; p < in->size; p++) {
                printf(" (%f, %f),", in->p[p].x/8.0, in->p[p].y/8.0);
            }
            if (in->size > 8)
                printf("\n\07 size of polygon too large");
            printf("\n");
#endif

        } /* for each clip boundary */

        /* skip it if it is empty 12/11/87 */
        if (in->size == 0) continue;

        /* Fixed the bug for very sharp clipping triangle for case "doesall.cap"
           3/26/91 phchen */
        for (p = 0; p < in->size; p++) {
           if (in->p[p].x > cp_ux) in->p[p].x = cp_ux;
        }

        /* a clipped polygon has been generated, to reduce it to trapezoids */
        pgn_reduction(in);

    } /* for each trapezoid */
    return(TRUE);
}



/***********************************************************************
 * Given a point, to check if it is inside the clipping boundary. The
 * clipping boundary(a vector) is specified by the input parameter idx,
 * which is a index of the clipping region(global variable clip).
 *
 * TITLE:       Inside
 *
 * CALL:        Inside(p, idx)
 *
 * PARAMETERS:  p -- point
 *              idx -- index of global variable clip
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      IN_CLIP(1)  -- inside
 *              ON_CLIP(-1) -- on clipping boundary
 *              OUT_CLIP(0) -- outside
 **********************************************************************/
static bool near inside (p, idx)
struct coord_i p;
fix     idx;
{
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32    f;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], diff[2];
#elif  FORMAT_28_4
        long dest1[2], dest2[2], diff[2];
#endif
        struct coord_i s2, p2;

        /* clipping region is a trapezoid:
         * idx = 0 -- top clip boundary
         *       1 -- right clip boundary
         *       2 -- right clip boundary
         *       3 -- right clip boundary
         */

        switch (idx) {
        case 0 :        /* top clip boundary, trivial */
                if (p.y > clip[idx].cp.y) return(IN_CLIP);
                else if (p.y == clip[idx].cp.y) return(ON_CLIP);
                else    return(OUT_CLIP);

        case 2 :        /* bottom clip boundary, trivial */
                if (p.y < clip[idx].cp.y) return(IN_CLIP);
                else if (p.y == clip[idx].cp.y) return(ON_CLIP);
                else    return(OUT_CLIP);

        default :       /* right & left clipping boundaries */
                /* special treatment for degenerated clipping boundary */
                if (clip[0].cp.y == clip[3].cp.y) {     /* horizontal line */
                        if (idx == 1) {         /* right clip boundary */
                                if (p.x < clip[1].cp.x) return(IN_CLIP);
                                else if (p.x == clip[1].cp.x) return(ON_CLIP);
                                else    return(OUT_CLIP);
                        } else {                /* left clip boundary */
                                if (p.x > clip[0].cp.x) return(IN_CLIP);
                                else if (p.x == clip[0].cp.x) return(ON_CLIP);
                                else    return(OUT_CLIP);
                        }
                }

                /* condition :
                 *  f = vect(s2, p2) (*) vect(p2, p);
                 *  if f >= 0 --> inside
                 *  where, (*) is a operator of cross_product.
                 */
                s2 = clip[idx].cp;
                p2 = clip[idx+1].cp;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                f = (fix32)(p2.x - s2.x) * ((fix32)p.y - p2.y) -
                    (fix32)(p2.y - s2.y) * ((fix32)p.x - p2.x);
                if (f > 0 )  return (IN_CLIP);
                else if (f == 0 )  return (ON_CLIP);
                else    return (OUT_CLIP);
#elif  FORMAT_16_16
                LongFixsMul((p2.x - s2.x), (p.y - p2.y), dest1);
                LongFixsMul((p2.y - s2.y), (p.x - p2.x), dest2);
                LongFixsSub(dest1, dest2, diff);
                if (diff[0] == 0 && diff[1] == 0)
                        return (ON_CLIP);
                else if (diff[0] < 0)
                        return (OUT_CLIP);
                else
                        return (IN_CLIP);
#elif  FORMAT_28_4
                LongFixsMul((p2.x - s2.x), (p.y - p2.y), dest1);
                LongFixsMul((p2.y - s2.y), (p.x - p2.x), dest2);
                LongFixsSub(dest1, dest2, diff);
                if (diff[0] == 0 && diff[1] == 0)
                        return (ON_CLIP);
                else if (diff[0] < 0)
                        return (OUT_CLIP);
                else
                        return (IN_CLIP);
#endif
        }
}


/***********************************************************************
 * Given a line segment, to intersect it with the specified clipping
 * boundary(idx) of the clipping region.
 *
 * TITLE:       Intersect
 *
 * CALL:        Intersect(s1, p1, idx)
 *
 * PARAMETERS:  s1 -- starting point of the line segment
 *              p1 -- ending point of the line segment
 *              idx -- index of clipping region
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:      intersect point
 **********************************************************************/
static struct coord_i * near intersect (s1, p1, idx)
struct coord_i s1, p1;
fix     idx;
{
        static struct coord_i isect;  /* should be static */
        fix32   dx1, dx2, dy1, dy2, dx, dy;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32    divider;
#elif  FORMAT_16_16
        long dest1[2], dest2[2], dest3[2], dest4[2];
        long diff1[2], diff2[2];
        float diff1_f, diff2_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2], dest3[2], dest4[2];
        long diff1[2], diff2[2];
        float diff1_f, diff2_f;
#endif
        real32   s;

        struct coord_i s2, p2;

        s2 = clip[idx].cp;
        p2 = clip[idx+1].cp;

        switch (idx) {
        case 0 :        /* top clip boundary */
        case 2 :        /* bottom clip boundary */
                /* intersect with a horizontal line */
/*                               ((fix32)p1.x - s1.x) /(real32)(p1.y - s1.y);
 *                               (p1.y - s1.y) may exceed integer range @OVR_SFX
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                s =  ((fix32)s2.y - s1.y) *
                                 ((fix32)p1.x - s1.x) /((real32)p1.y - s1.y);
                isect.x = s1.x + ROUND(s);
#elif  FORMAT_16_16
                LongFixsMul((s2.y - s1.y), (p1.x - s1.x), dest1);
                isect.x = s1.x + LongFixsDiv((p1.y - s1.y), dest1);
#elif  FORMAT_28_4
                LongFixsMul((s2.y - s1.y), (p1.x - s1.x), dest1);
                isect.x = s1.x + LongFixsDiv((p1.y - s1.y), dest1);
#endif
                isect.y = s2.y;
                break;

        default :        /* right & left clip boundary */
                if ((dy2 = (fix32)p2.y - s2.y) == 0) {   /* vector is zero */
                        /* intersect with a vertical line */
/*                           ((fix32)p1.y - s1.y) /(real32)(p1.x - s1.x);
 *                             (p1.x - s1.x) may exceed integer range @OVR_SFX
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        s =  ((fix32)s2.x - s1.x) *
                             ((fix32)p1.y - s1.y) /((real32)p1.x - s1.x);
                        isect.y = s1.y + ROUND(s);
#elif  FORMAT_16_16
                        LongFixsMul((s2.x - s1.x), (p1.y - s1.y), dest1);
                        isect.y = s1.y + LongFixsDiv((p1.x - s1.x),dest1);
#elif  FORMAT_28_4
                        LongFixsMul((s2.x - s1.x), (p1.y - s1.y), dest1);
                        isect.y = s1.y + LongFixsDiv((p1.x - s1.x),dest1);
#endif
                        isect.x = s2.x;
                        break;
                } else {
                        dx1 = (fix32)p1.x - s1.x;
                        dx2 = (fix32)p2.x - s2.x;
                        dy1 = (fix32)p1.y - s1.y;
/*                      dy2 = (fix32)p2.y - s2.y; set at previous if statement*/
                        dx = (fix32)s1.x - s2.x;
                        dy = (fix32)s1.y - s2.y;

#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = (fix32)dx1 * dy2 - (fix32)dx2 * dy1;
                        s = ((fix32)dx2 * dy - (fix32)dy2 * dx) / (real32)divider;
#elif  FORMAT_16_16
                        LongFixsMul(dx1, dy2, dest1);
                        LongFixsMul(dx2, dy1, dest2);
                        LongFixsMul(dx2, dy,  dest3);
                        LongFixsMul(dx,  dy2, dest4);
                        LongFixsSub(dest3, dest4, diff1);
                        LongFixsSub(dest1, dest2, diff2);
                        change_to_real(diff1, &diff1_f);
                        change_to_real(diff2, &diff2_f);
                        s = diff1_f / diff2_f;
#elif  FORMAT_28_4
                        LongFixsMul(dx1, dy2, dest1);
                        LongFixsMul(dx2, dy1, dest2);
                        LongFixsMul(dx2, dy,  dest3);
                        LongFixsMul(dx,  dy2, dest4);
                        LongFixsSub(dest3, dest4, diff1);
                        LongFixsSub(dest1, dest2, diff2);
                        change_to_real(diff1, &diff1_f);
                        change_to_real(diff2, &diff2_f);
                        s = diff1_f / diff2_f;
#endif
                        isect.x = s1.x + ROUND(s * dx1);
                        isect.y = s1.y + ROUND(s * dy1);
                } /* if */
        } /* switch */

        return (&isect);

}


/***********************************************************************
 * This module reduces the input clockwised polygon to a set of trapezoids,
 * and saves each trapezoid.
 *
 * TITLE:       pgn_reduction
 *
 * CALL:        pgn_reduction(in_pgn)
 *
 * PARAMETERS:  in_pgn -- input clockwised polygon
 *
 * INTERFACE:   convex_clipper
 *
 * CALLS:       save_tpzd
 *
 * RETURN:      none
 **********************************************************************/
void pgn_reduction(in_pgn)
struct polygon_i FAR *in_pgn;
{

        struct {
                sfix_t  x0;             /* starting x coordinate */
                sfix_t  y0;             /* starting y coordinate */
                sfix_t  x1;             /* ending x coordinate */
                sfix_t  y1;             /* ending y coordinate */
                sfix_t  xint;           /* x coordinate that goes with scan_y */
        } left[4], right[4];
        fix     left_idx, right_idx;

        struct tpzd tpzd;

        sfix_t  scan_y, last_x, last_y;
        struct  coord_i FAR *ip;
        fix     i;
        fix     l, r;
        bool    done;
#ifdef FORMAT_13_3 /* @RESO_UPGR */
#elif  FORMAT_16_16
        long dest1[2];
#elif  FORMAT_28_4
        long dest1[2];
#endif
#ifdef DBG1
        printf("pgn_reduction():\n");
        for( i =0; i < in_pgn->size; i++) {
                printf(" (%f, %f),", in_pgn->p[i].x/8.0, in_pgn->p[i].y/8.0);
        }
        printf("\n");
#endif

        /* set up left and right edges for polygon reduction */

        last_x = in_pgn->p[0].x;
        last_y = in_pgn->p[0].y;
        left_idx = right_idx = -1;      /* init */

        done = FALSE;
        for (i = 1; !done;
             i++, last_x = ip->x, last_y = ip->y) {
                if (i == in_pgn->size) {
                        /* last edge */
                        ip = &in_pgn->p[0];
                        done = TRUE;
                } else {
                        ip = &in_pgn->p[i];
                }

                /* ignord horiz. edge */
                if (ip->y == last_y) continue;

                /* build edge_table */
                if (ip->y < last_y) {   /* left edge */
                        fix     j;

                        for (j=left_idx; j>=0; j--) {
                                if (ip->y < left[j].y0) {
                                        left[j+1] = left[j];
                                } else {
                                        break;
                                }
                        }
                        j++;

                        left[j].x0 = left[j].xint = ip->x;
                        left[j].y0 = ip->y;
                        left[j].x1 = last_x;
                        left[j].y1 = last_y;
                        left_idx++;

                } else {        /* right edge */
                        fix     j;

                        for (j=right_idx; j>=0; j--) {
                                if (last_y < right[j].y0) {
                                        right[j+1] = right[j];
                                } else {
                                        break;
                                }
                        }
                        j++;

                        right[j].x0 = right[j].xint = last_x;
                        right[j].y0 = last_y;
                        right[j].x1 = ip->x;
                        right[j].y1 = ip->y;
                        right_idx++;
                }

        } /* for */


#ifdef DBG1
        printf("Edge table:\n  idx)    x0     y0     x1     y1\n");
        printf("left edge[0:%d] :", left_idx);
        for (i = 0; i <= left_idx; i++) {
                printf("\t%d     %f      %f      %f      %f\n", i,
                        SFX2F(left[i].x0), SFX2F(left[i].y0),
                        SFX2F(left[i].x1), SFX2F(left[i].y1));
        }
        printf("right edge[0:%d] :", right_idx);
        for (i = 0; i <= right_idx; i++) {
                printf("\t%d     %f      %f      %f      %f\n", i,
                        SFX2F(right[i].x0), SFX2F(right[i].y0),
                        SFX2F(right[i].x1), SFX2F(right[i].y1));
        }
#endif

        /* special processing for degernate polygon: just a horiz. line */
        if (left_idx == -1) {
                sfix_t min_x, max_x;

                min_x = max_x = in_pgn->p[0].x;
                for( i =1; i < in_pgn->size; i++) {
                        if (in_pgn->p[i].x < min_x)
                                min_x = in_pgn->p[i].x;
                        else if (in_pgn->p[i].x > max_x)
                                max_x = in_pgn->p[i].x;
                }

                tpzd.topxl = tpzd.btmxl = min_x;
                tpzd.topxr = tpzd.btmxr = max_x;
                tpzd.btmy = tpzd.topy = in_pgn->p[0].y;
                save_tpzd(&tpzd);
                return;
        }


        /* Main loop, for each disjoint y_coordinate in edge_table */
        l = r = 0;
        for (last_y = left[0].y0; l <= left_idx; last_y = scan_y) {

                if (left[l].y1 == right[r].y1) {
                        scan_y = left[l].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;
                        tpzd.btmxl = left[l].x1;
                        tpzd.btmxr = right[r].x1;
                        l++;
                        r++;
                } else if (left[l].y1 < right[r].y1) {
                        scan_y = left[l].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;

/*                      temp = (real32)(right[r].x1 - right[r].x0) /
 *                                    (right[r].y1 - right[r].y0);
 *                      right[r].xint = right[r].x0 +
 *                              ROUND((scan_y - right[r].y0) * temp);
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        right[r].xint = right[r].x0 + (sfix_t)
                               (((fix32)(scan_y - right[r].y0)) *
                                (right[r].x1 - right[r].x0) /
                                (right[r].y1 - right[r].y0));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - right[r].y0),
                                (right[r].x1 - right[r].x0), dest1);
                        right[r].xint = right[r].x0 +
                           LongFixsDiv((right[r].y1 - right[r].y0), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - right[r].y0),
                                (right[r].x1 - right[r].x0), dest1);
                        right[r].xint = right[r].x0 +
                           LongFixsDiv((right[r].y1 - right[r].y0), dest1);
#endif

                        tpzd.btmxl = left[l].x1;
                        tpzd.btmxr = right[r].xint;
                        l++;
                } else {
                        scan_y = right[r].y1;
                        tpzd.topxl = left[l].xint;
                        tpzd.topxr = right[r].xint;

/*                      temp = (real32)(left[l].x1 - left[l].x0) /
 *                                    (left[l].y1 - left[l].y0);
 *                      left[l].xint = left[l].x0 +
 *                              ROUND((scan_y - left[l].y0) * temp);
 */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        left[l].xint = left[l].x0 + (sfix_t)
                               (((fix32)(scan_y - left[l].y0)) *
                                (left[l].x1 - left[l].x0) /
                                (left[l].y1 - left[l].y0));
#elif  FORMAT_16_16
                        LongFixsMul((scan_y - left[l].y0),
                                        (left[l].x1 - left[l].x0), dest1);
                        left[l].xint = left[l].x0 +
                            LongFixsDiv((left[l].y1 - left[l].y0), dest1);
#elif  FORMAT_28_4
                        LongFixsMul((scan_y - left[l].y0),
                                        (left[l].x1 - left[l].x0), dest1);
                        left[l].xint = left[l].x0 +
                            LongFixsDiv((left[l].y1 - left[l].y0), dest1);
#endif
                        tpzd.btmxl = left[l].xint;
                        tpzd.btmxr = right[r].x1;
                        r++;
                }

                tpzd.btmy = scan_y;
                tpzd.topy = last_y;

                save_tpzd(&tpzd);

        } /* for */

}


/***********************************************************************
 * This module change CURVETO to LINETO nodes. This routine is for fixing
 * very large circle. @LC
 *
 * TITLE:       iron_subpath
 *
 * CALL:        shape_approximation()
 *
 * PARAMETERS:  first_vertex
 *
 * INTERFACE:   none
 *
 * CALLS:       none
 *
 * RETURN:      SP_IDX
 **********************************************************************/
SP_IDX iron_subpath (first_vertex)
VX_IDX first_vertex;
{
   SP_IDX ret_vlist; /* should be static */
   struct nd_hdr FAR *vtx, FAR *node;
   VX_IDX ivtx, inode, tail;

   printf ("Enter iron_subpath\n");
   st_countnode();

   /* Initialize ret_vlist */
   ret_vlist = tail = NULLP;

   /* Traverse input subpath, and create a new flattened subpath */
   for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
           vtx = &node_table[ivtx];
                   /* Copy the node */
                   inode = get_node();
                   if(inode == NULLP) {
                           ERROR(LIMITCHECK);
                           return (ret_vlist);
                   }
                   node = &node_table[inode];

                   node->next = NULLP;
                   if (vtx->VX_TYPE == CURVETO)
                       node->VX_TYPE = LINETO;
                   else
                       node->VX_TYPE = vtx->VX_TYPE;

                   node->VERTEX_X = vtx->VERTEX_X;
                   node->VERTEX_Y = vtx->VERTEX_Y;

                   /* Append the node to ret_vlist */
                   if (ret_vlist == NULLP) {
                           ret_vlist = inode;
                           node->SP_FLAG =
                               node_table[first_vertex].SP_FLAG;
                   } else
                           node_table[tail].next = inode;
                   tail = inode;
   } /* for */
   node_table[ret_vlist].SP_TAIL = tail;
   node_table[ret_vlist].SP_NEXT = NULLP;

   return (ret_vlist);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\stroke.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/**********************************************************************
 *
 *      Name:       stroke.c
 *
 *      Purpose:
 *
 *      Developer:  S.C.Chen
 *
 *      History:
 *      Version     Date        Comments
 *      3.0         10/5/88     seperate this file from path.c
 *                              @STK_CIR: stroke enhancement of round linejoin
 *                              & linecap by caching the bitmap of the circle:
 *                              add routines: circle_ctl_points, circle_list,
 *                              flatten_circle
 *                  10/12/88    add a trick of comparision with float 1.0
 *                  10/19/88    update linetour_i of dash line:
 *                              still use floating point arith for each starting
 *                              and end point of dash segment
 *                  10/20/88    add an error tolerance to length of line segment
 *                              for dash line
 *                  10/20/88    round_point(): revise calculation of bounding
 *                              box of the circle cache
 *                  10/21/88    @THIN_STK: add routines for thin stroke:
 *                              1. is_thinstroke: check if thin linewidth
 *                              2. path_to_outline_t(): thin stroke
 *                              3. calling new routine: fill_line();
 *                  10/24/88    paint_or_save(): add checking of infinitive
 *                              numbers
 *                  10/26/88    linetour & linetour_i: set rect2.vct_u for
 *                              calling linecap
 *                  10/27/88    change x = y = z; ==> x = z; y = z;
 *                              when x, y, and z are float numbers
 *                  10/28/88    @CRC: update circle cache for putting bitmap in
 *                              correct position:
 *                              1. revise
 *                                 1) round_point for setting ref_x & ref_y,
 *                                    and calling fill_shape(.., F_FROM_CRC)
 *                                 2) fill_shape: add another type F_FROM_CRC
 *                  10/28/88    update path_to_outline_i & path_to_outline_t:
 *                              F2SFX ==> F2SFX_T, truncation instead of
 *                              rounding for circle cache in correct position
 *                  10/28/88    F_SFX ==> F2SFX_T
 *                  11/07/88    initialize status87 at init_stroke
 *                  11/08/88    update flatten_circle(): for big circle
 *                              flt_vlist just a pointer; no structure space
 *                  11/18/88    init_stroke():
 *                              clear status87 after each inst. that may arouse
 *                              integer overflow
 *                  11/21/88    delete inverse_ctm_i:
 *                              1) get_rect_points(), get_rect_points_i():
 *                                 calculate slope m from ctm instead of inverse
 *                                 ctm.  ==> not need to use inverse_ctm_i
 *                              2) linetour(), linetour_i():
 *                                 derive ratio of advanving units from
 *                                 rect_info to enhance dash line
 *                              3) linecap_i():
 *                                 use floating inverse_ctm[]
 *                  11/24/88    @FABS: update fabs ==> macro FABS
 *                  11/30/88    round_point(): call init_edgetable before
 *                              shape_approximation
 *                  12/19/88    @FLT_CVE: path_to_outline, path_to_outline_i,
 *                              path_to_outline_t: flatten and process each
 *                              curveto node instead of flattening the whole
 *                              subpath
 *                  12/23/88    update round_point => circle_cache only for
 *                              from_cache_to_page, i.e. if to_cache then
 *                              no circle_cache
 *                  1/5/89      update get_rect_point_i(): multiply of long
 *                              integer for more acuracy
 *                  1/5/89      linetour() & linetour_i(): revise the
 *                              calculation of length of line segment for
 *                              thin line with dash pattern
 *                  1/9/89      path_to_outline_t: skip degenerated case of path
 *                              containing only a moveto and closepath node
 *                  1/12/89     round_point(): shrink circle cache 1 pixel for
 *                              quality
 *                  1/26/89     init_stroke(): add checking of inifinity
 *                  1/26/89     @CAP: update linetour & linetour_i() -- revise
 *                              SQUARE_CAP rectangle of dash line
 *                  1/27/89     linecap_i(): revise tolrence of computing
 *                              expansion of SQUARE_CAP for consistency with
 *                              linecap()
 *                  1/28/89     path_to_outline, path_to_outline_i &
 *                              path_to_outline_t(): save value of return
 *                              structure after calling bezier_to_line
 *                  4/22/89     @RND: F2SFX_T => F2SFX
 *                  5/9/89      update coord. of fill_line() from pixel to
 *                              1/8 pixel
 *                  5/9/89      round_point(): adjust flatness of circle cache
 *                              for quality
 *                  5/26/89     apply new macro for zero comparison of floating
 *                              points; macro: IS_ZERO()
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  1/10/90     init_stroke(): modify stroke flatness; not needs
 *                              so accurate
 *                  4/6/90      linejoin_i(): fixed the bug of short integer
 *                              overflow; sfix_t ==> lfix_t.
 *                  7/26/90     Jack Liaw, update for grayscale
 *                  10/15/90    updated for one point thin line stroke of round cap
 *                  11/29/90    updated for negative offset of init_dash_pattern
 *                  12/8/90     Dash pattern changed with the array
 *                  12/18/90    draw_line(): update for single point
 *                  02/04/91    update circle_ctl_points, [r, c] * CTM, not
 *                              CTM * [r, c]
 *                  3/20/91     refine the tolerance check:
 *                              f <  0 --> SIGN_F(f)
 *                  4/17/91     round_point(): limit check for edge table
 *                  11/11/91    upgrade for higher resolution @RESO_UPGR
 **********************************************************************/


// DJC added global include
#include "psglobal.h"



#include <stdio.h>
#include <math.h>
#include "global.ext"
#include "graphics.h"
#include "graphics.ext"
#include "fillproc.h"
#include "fillproc.ext"
#include "font.h"
#include "font.ext"

/* @WIN; prototype */
void fill_box (struct coord_i FAR *, struct coord_i FAR *);     /*@WIN*/
void fill_rect (struct line_seg_i FAR *);                       /*@WIN*/

/* **************** local structure *************** *)
(* line_segment structure:
 *                      pgn[1]                           pgn[2]
 *                            +------------------------+
 *                      p0    +------------------------+ p1
 *                            +------------------------+
 *                      pgn[0]                           pgn[3]
 *)
struct  line_seg {
        struct coord p0;        (* starting point of central line *)
        struct coord p1;        (* ending point of central line *)
        struct coord vct_u;     (* vector of p0 -> pgn[0] in user space *)
        struct coord vct_d;     (* vector of p0 -> pgn[0] in device space *)
        struct coord pgn[4];    (* outline of the line segment *)
};
struct  line_seg_i {      (* @STK_INT *)
        struct coord_i p0;        (* starting point of central line *)
        struct coord_i p1;        (* ending point of central line *)
        struct coord   vct_u;     (* vector of p0 -> pgn[0] in user space *)
        struct coord_i vct_d;     (* vector of p0 -> pgn[0] in device space *)
        struct coord_i pgn[4];    (* outline of the line segment *)
};      * commented due to enhancement by jwm, 3-28-91, Jack */


/* **************** static variables *************** */
/* parameters used by stroke/strokepath @STK_INFO */
static struct {
        real32 ctm[4];         /* CTM */
        real32 width;          /* line width */
        real32 limit;          /* miter limit */
        real32 flatness;       /* flatness */
                               /* above items are copied from graphics
                                * state for checking if this structure
                                * need to re-calculate for the stroke
                                */
        real32 half_width;     /* half of line width */
        sfix_t half_width_i;   /* half of line width, SFX format @STK_INT */
        real32 flat;           /* flatness for stroke */
        lfix_t flat_l;         /* LFX format of flatness @FLT_CVE */
        real32 miter;          /* internal miter value */
        real32 miter0;         /* internal min. miter value */
        bool   change_circle;  /* circle need to re-generate */
        real32 exp_widthx,     /* max expanding width in device space 11/22/88*/
               exp_widthy;
        real32 exp_miterx,     /* max expanding miter in device space 11/22/88*/
               exp_mitery;

} stk_info = {  /* set init values */
        (real32)0., (real32)0., (real32)0., (real32)0.,
        (real32)0.,
        (real32)0.,
        (real32)0.,
        (real32)0.,
        (sfix_t)0,              /* @STK_INT */
        (real32)0.,
        (lfix_t)0,              /* @FLT_CVE */
        (real32)0.,
        (real32)0.,
        TRUE,
        (real32)0., (real32)0.,
        (real32)0., (real32)0.
};

/* variables to save the circle for ronud join and cap */
static struct coord curve[4][3];        /* 4 bezier curves of the circle */
static real32 near circle_bbox[4];      /* bounding box */
static SP_IDX near circle_sp = NULLP;   /* subpath of flattened circle */
static struct coord circle_root;        /* root of the circle @TOUR */
static ufix circle_flag;                /* flag of circle bitmap; see below */


/* variables for circle cache */
static struct Char_Tbl near cir_cache_info;    /* cache_info of circle bitmap */
static struct Char_Tbl FAR * near save_cache_info; /* saved cache information */
static struct cp_hdr save_clip;
static ufix near save_dest;

static sfix_t near stroke_ctm[6];       /* interger version of current CTM;
                                         * SFIX13 format, @STK_INT
                                         */
//static  ufix near inside_clip_flag; /* inside single clip region @STK_INT */
static  ULONG_PTR inside_clip_flag;     /* inside single clip region @STK_INT @WIN*/

/* local variables for specifing paint type(ACT_PAINT)
 * initialized by "path_to_outline", referenced by "paint_or_save"
 */
// static  ufix near paint_flag;
static  ULONG_PTR paint_flag;              /* @WIN */

/* side selection of two sides of the line segment to derive the join point */
#define LINE03  0
#define LINE12  1

/* selection of endpoint for linecap */
#define START_POINT     0
#define END_POINT       1

/* property of CTM */
#define NORMAL_CTM      1
#define LEFT_HAND_CTM   2

/* flag of circle bitmap */
#define CIR_UNSET_CACHE 0       /* circle does not generate yet */
#define CIR_IN_CACHE    1       /* circle in cache */
#define CIR_OUT_CACHE   2       /* circle too large to put in cache */

/* ********** static function declartion ********** */

#ifdef LINT_ARGS

/* for type checks of the parameters in function declarations */
static void near draw_line (sfix_t, sfix_t, sfix_t, sfix_t); /* @FLT_CVE */
static void near linetour (struct line_seg FAR *);      /*@WIN*/
static void near linetour_i (struct line_seg_i FAR *);      /*@WIN*/
static void near linejoin (struct line_seg FAR*, struct line_seg FAR*);
static void near linejoin_i (struct line_seg_i FAR*, struct line_seg_i FAR*);
static void near linecap (struct line_seg FAR *, fix);  /*@WIN*/
static void near linecap_i (struct line_seg_i FAR *, fix);      /*@WIN*/
static void near get_rect_points (struct line_seg FAR*);        /*@WIN*/
static void near get_rect_points_i (struct line_seg_i FAR*);    /*@WIN*/
static void near paint_or_save (struct coord FAR *);            /*@WIN*/
static void near paint_or_save_i (struct coord_i FAR *);        /*@WIN*/
static void near round_point(long32, long32);
static void near circle_ctl_points(void);
/* static struct vx_lst * near circle_list(long32, long32); @NODE */
static SP_IDX near circle_list(long32, long32);
/* static void near flatten_circle (struct vx_lst *); @NODE */
static void near flatten_circle (SP_IDX);
/* static SP_IDX near vlist_to_subp (struct vx_lst *); @NODE */
static SP_IDX near subpath_gen(struct coord FAR *);     /*@WIN*/
#ifdef  _AM29K
static void near   dummy(void);
#endif
#else

/* for no type checks of the parameters in function declarations */
static void near draw_line (); /* @FLT_CVE */
static void near linetour ();
static void near linetour_i ();
static void near linejoin ();
static void near linejoin_i ();
static void near linecap ();
static void near linecap_i ();
static void near get_rect_points ();
static void near get_rect_points_i ();
static void near paint_or_save ();
static void near paint_or_save_i ();
static void near round_point();
static void near circle_ctl_points();
/* static struct vx_lst * near circle_list(); @NODE */
static SP_IDX near circle_list();
static void near flatten_circle ();
/* static SP_IDX near vlist_to_subp (); @NODE */
static SP_IDX near subpath_gen();
#ifdef  _AM29K
static void near   dummy();
#endif

#endif


/***********************************************************************
 * Given a subpath and a paint_flag, this module constructs an outline
 * of the subpath, and fills the outline in case of paint_flag is true,
 * otherwise creates a new path of the outline.
 * For performance consideration, there are 3 routines provided:
 * 1) path_to_outline   -- for strokepath & worse case of stroke; floating points
 *                         arith.
 * 2) path_to_outline_i -- for integer stroke; fixed points arith.
 * 3) path_to_outline_t -- for thin stroke; fixed points arith. & no
 *                         linejoin/linecap
 *
 * TITLE:       path_to_outline
 *              path_to_outline_i
 *              path_to_outline_t
 *
 * CALL:        path_to_outline  (isubpath, param)
 *              path_to_outline_i(isubpath, param)
 *              path_to_outline_t(isubpath, param)
 *
 * PARAMETERS:  isubpath -- input subpath
 *              param -- TRUE : stroke command
 *                       FALSE: strokepath command
 *
 * INTERFACE:   op_strokepath
 *              stroke_shape
 *
 * CALLS:       flatten_subpath, linetour, linejoin, linecap, get_rect_points
 *
 * RETURN:      None
 **********************************************************************/
void path_to_outline (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    real32   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;
    real32   first_x, first_y;
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_pat_on;   /* if first line segment not a gap */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg rect0, rect1, rect_first;
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    real32  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = (ULONG_PTR) param;  /* initialize paint_flag @WIN */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("%f %f moveto\n", x2, y2);
#endif

            /*
             * Set up starting dash pattern in actdp struct
             * (copy from init_dash_pattern to active_dash_pattern)
             *  initdp => actdp
             */
            actdp.dpat_on = GSptr->dash_pattern.dpat_on;
            actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
            actdp.dpat_index = GSptr->dash_pattern.dpat_index;

            /* keep first dpat_on flag, for last line cap testing */
            first_pat_on = actdp.dpat_on;

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("%f %f lineto\n", x2, y2);
#endif

            /* ignore this node if it coincides with the next node */
            if ((F2L(x1) == F2L(x2)) && (F2L(y1) == F2L(y2))){
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points ((struct  line_seg FAR *)&rect1);   /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                /* Create a linejoin path for last_node
                 */
                linejoin ((struct  line_seg FAR *)&rect0,       /*@WIN*/
                        (struct  line_seg FAR *)&rect1);        /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */
            linetour ((struct  line_seg FAR *)&rect1);  /*@WIN*/

            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = vtx->VERTEX_X;
            y2 = vtx->VERTEX_Y;
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif

            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = vtx->VERTEX_X;
            y3 = vtx->VERTEX_Y;
            vtx = &node_table[vtx->next];
            x4 = vtx->VERTEX_X;
            y4 = vtx->VERTEX_Y;

            /* @NODE
             * vlist = bezier_to_line(F2L(stk_info.flat), F2L(x1), F2L(y1),
             */
            vlist_head = bezier_to_line(F2L(stk_info.flat), F2L(x1), F2L(y1),
                      F2L(x2), F2L(y2), F2L(x3), F2L(y3), F2L(x4), F2L(y4));

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VERTEX_X;
                y2 = node->VERTEX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", x2, y2);
#endif

                /* ignore this node if it coincides with the next node */
                if ((F2L(x1) == F2L(x2)) && (F2L(y1) == F2L(y2))){
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points ((struct  line_seg FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin ((struct  line_seg FAR *)&rect0, /*@WIN*/
                            (struct  line_seg FAR *)&rect1);  /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
                linetour ((struct  line_seg FAR *)&rect1);      /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :
#ifdef DBG3
            printf("closepath\n");
#endif

            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((F2L(x1) != F2L(x2)) || (F2L(y1) != F2L(y2))){
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;
                    get_rect_points ((struct  line_seg FAR *)&rect1); /*@WIN*/
                                /* input: p0, p1; output: pgn[4] */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             */
                            linejoin ((struct  line_seg FAR *)&rect0, /*@WIN*/
                                (struct  line_seg FAR *)&rect1); /*@WIN*/
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    linetour ((struct  line_seg FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin ((struct  line_seg FAR *)&rect1,   /*@WIN*/
                (struct  line_seg FAR *)&rect_first);   /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        /* make sure the last line segment is not a gap */
        if (GSptr->dash_pattern.pat_size == 0) {
                /* solid line, always creates a cap */
                linecap ((struct  line_seg FAR *)&rect1, END_POINT); /*@WIN*/

        } else {
                /* check dpat_on flag of last segment */
                if(IS_ZERO(actdp.dpat_offset)) {        /* 5/26/89 */
                    /* actdp.dpat_on is for next line segment, so
                     * its inverse is ones for last line segment
                     */
                    if(!actdp.dpat_on)          /*@WIN*/
                        linecap ((struct  line_seg FAR *)&rect1, END_POINT);
                } else {
                    if(actdp.dpat_on)           /*@WIN*/
                        linecap ((struct  line_seg FAR *)&rect1, END_POINT);
                }
        }

        /* Create a linecap_path for sub_head node; */
        /* make sure the first line segment is not a gap */
        if (first_pat_on) {     /*@WIN*/
            linecap ((struct  line_seg FAR *)&rect_first, START_POINT);
                    /* create a cap at starting point */
        } /* if first_pat_on */

    } /* if !close_flag */

}


/*
 * Integer operation version
 */
void path_to_outline_i (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    /* struct  vx_lst *b_vlist; @NODE */
    sfix_t   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y;                                  /* @STK_INT */
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_pat_on;   /* if first line segment not a gap */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg_i rect0, rect1, rect_first;                /* @STK_INT */
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = (ULONG_PTR) param;/* initialize inside_clip_flag @STK_INT */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);          /* use rounding for quality */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f moveto\n", SFX2F(x2), SFX2F(y2));
#endif

            /*
             * Set up starting dash pattern in actdp struct
             * (copy from init_dash_pattern to active_dash_pattern)
             *  initdp => actdp
             */
            actdp.dpat_on = GSptr->dash_pattern.dpat_on;
            actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
            actdp.dpat_index = GSptr->dash_pattern.dpat_index;

            /* keep first dpat_on flag, for last line cap testing */
            first_pat_on = actdp.dpat_on;

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f lineto\n", SFX2F(x2), SFX2F(y2));
#endif


            /* ignore this node if it coincides with the next node */
            if ((x1 == x2) && (y1 == y2)){              /* @STK_INT */
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points_i((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1);  /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */
            linetour_i ((struct  line_seg_i FAR *)&rect1);      /*@WIN*/

            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif


            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                      x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", SFX2F(x2), SFX2F(y2));
#endif


                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)){          /* @STK_INT */
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                        /* Create a linejoin path for last_node
                         */
                        linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1); /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
                linetour_i ((struct  line_seg_i FAR *)&rect1);  /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :

#ifdef DBG3
            printf("closepath\n");
#endif


            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((x1 != x2) || (y1 != y2)){              /* @STK_INT */
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;
                    get_rect_points_i ((struct  line_seg_i FAR *)&rect1);
                                /* input: p0, p1; output: pgn[4] @WIN */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             */
                            linejoin_i (&rect0, &rect1);
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    linetour_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin_i ((struct  line_seg_i FAR *)&rect1,       /*@WIN*/
                    (struct  line_seg_i FAR *)&rect_first);     /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        /* make sure the last line segment is not a gap */
        if (GSptr->dash_pattern.pat_size == 0) {
                /* solid line, always creates a cap @WIN*/
                linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);

        } else {
                /* check dpat_on flag of last segment */
                if(IS_ZERO(actdp.dpat_offset)) {        /* 5/26/89 */
                    /* actdp.dpat_on is for next line segment, so
                     * its inverse is ones for last line segment
                     */
                    if(!actdp.dpat_on)          /*@WIN*/
                        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);
                } else {
                    if(actdp.dpat_on)           /*@WIN*/
                        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT);
                }
        }

        /* Create a linecap_path for sub_head node; */
        /* make sure the first line segment is not a gap */
        if (first_pat_on) {             /*@WIN*/
            linecap_i ((struct  line_seg_i FAR *)&rect_first, START_POINT);
                    /* create a cap at starting point */
        } /* if first_pat_on */

    } /* if !close_flag */

}


/*
 * 'quick' version : integer operation, solid line  -jwm, 3/18/91, -begin-
 */
void path_to_outline_q (isubpath, param)
SP_IDX  isubpath;
fix     *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx, FAR *f_vtx;
    /* struct  vx_lst *b_vlist; @NODE */
    sfix_t   x0=0, y0=0, x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y, i;                                  /* @STK_INT */
    ufix    last_node_type;
    bool    close_flag;     /* if a closed subpath */
    bool    first_seg_exist;   /* if first line segment has been created */
    struct  line_seg_i rect0, rect1, rect_first;
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */
    struct  coord_i ul_coord, lr_coord;

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    close_flag = FALSE;
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = TRUE;          /* inside_clip_flag always true */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     * f_vtx = &node_table[first_vertex]; (* pointer to first vertex *)
     */
    first_vertex = isubpath;
    f_vtx = sp;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);          /* use rounding for quality */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f moveto\n", SFX2F(x2), SFX2F(y2));
#endif

            break;

        case LINETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("%f %f lineto\n", SFX2F(x2), SFX2F(y2));
#endif


            /* ignore this node if it coincides with the next node */
            if ((x1 == x2) && (y1 == y2)){              /* @STK_INT */
                    break;
            }

            /* save last rectangle information */
            rect0 = rect1;

            /* get current rectangle information */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                        /* input: p0, p1; output: pgn[4] */

            if (first_seg_exist) {
                    /* Create a linejoin path for last_node
                     */
                    linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                        (struct  line_seg_i FAR *)&rect1);      /*@WIN*/
            } else {
                    /* save rect for linecap of the last line segment */
                    rect_first = rect1;

                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;

                    first_seg_exist = TRUE;
            }

            /* Create a retangle path for last_node to
             * this_node
             */

            if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91*/
                ul_coord = rect1.pgn[0];
                lr_coord = rect1.pgn[0];
                for (i = 1; i < 4; i++) {
                    if (rect1.pgn[i].x < ul_coord.x)
                        ul_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y < ul_coord.y)
                        ul_coord.y = rect1.pgn[i].y;
                    if (rect1.pgn[i].x > lr_coord.x)
                        lr_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y > lr_coord.y)
                        lr_coord.y = rect1.pgn[i].y;
                    }
                fill_box ((struct coord_i FAR *)&ul_coord,      /*@WIN*/
                    (struct coord_i FAR *)&lr_coord);           /*@WIN*/
                }
            else
                fill_rect ((struct  line_seg_i FAR *)&rect1);   /*@WIN*/
            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);
#ifdef DBG3
            printf("curveto -- after flatten:\n");
#endif


            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                        x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;
            x1 = x0;
            y1 = y0;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x0 = x1;
                y0 = y1;
                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;
#ifdef DBG3
                printf("%f %f clineto\n", SFX2F(x2), SFX2F(y2));
#endif


                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)){          /* @STK_INT */
                        continue;
                }

                /* save last rectangle information */
                rect0 = rect1;

                /* get current rectangle information */
                rect1.p0.x = x1;
                rect1.p0.y = y1;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                get_rect_points_i ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
                            /* input: p0, p1; output: pgn[4] */

                if (first_seg_exist) {
                        /* Create a linejoin path for last_node
                         */
                        linejoin_i ((struct  line_seg_i FAR *)&rect0, /*@WIN*/
                            (struct  line_seg_i FAR *)&rect1);  /*@WIN*/
                } else {
                        /* save rect for linecap of the last line segment */
                        rect_first = rect1;

                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;

                        first_seg_exist = TRUE;
                }

                /* Create a retangle path for last_node to
                 * this_node
                 */
            if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91 */
                ul_coord = rect1.pgn[0];
                lr_coord = rect1.pgn[0];
                for (i = 1; i < 4; i++) {
                    if (rect1.pgn[i].x < ul_coord.x)
                        ul_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y < ul_coord.y)
                        ul_coord.y = rect1.pgn[i].y;
                    if (rect1.pgn[i].x > lr_coord.x)
                        lr_coord.x = rect1.pgn[i].x;
                    if (rect1.pgn[i].y > lr_coord.y)
                        lr_coord.y = rect1.pgn[i].y;
                    }
                fill_box ((struct coord_i FAR *)&ul_coord,      /*@WIN*/
                    (struct coord_i FAR *)&lr_coord);       /*@WIN*/
                }
            else
                fill_rect ((struct  line_seg_i FAR *)&rect1);   /*@WIN*/
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */

            break;

        case CLOSEPATH :

#ifdef DBG3
            printf("closepath\n");
#endif


            close_flag = TRUE;  /* indicate not need to generate linecap
                                 * for the endpoint
                                 */
            if (!first_seg_exist) break;     /* degernated case; just return */

            x0 = x1;
            y0 = y1;
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            /* create a close_segment if the first and last nodes don't
             * coincide.
             */
            if ((x1 != x2) || (y1 != y2)){              /* @STK_INT */
                    /* save last rectangle information */
                    rect0 = rect1;

                    /* get current rectangle information */
                    rect1.p0.x = x1;
                    rect1.p0.y = y1;
                    rect1.p1.x = x2;
                    rect1.p1.y = y2;                    /*@WIN*/
                    get_rect_points_i ((struct  line_seg_i FAR *)&rect1);
                                /* input: p0, p1; output: pgn[4] */

                    if ((last_node_type != MOVETO) &&
                        (last_node_type != PSMOVE)) {
                            /* Create a linejoin path for last_node
                             @WIN */
                            linejoin_i ((struct  line_seg_i FAR *)&rect0,
                                (struct  line_seg_i FAR *)&rect1);
                    }

                    /* Create a retangle path for last_node to
                     * this_node
                     */
                    if ((x1 == x2) || (SFX2I(y1) == SFX2I(y2))) {       /* jwm, 2/6/91 */
                        ul_coord = rect1.pgn[0];
                        lr_coord = rect1.pgn[0];
                        for (i = 1; i < 4; i++) {
                            if (rect1.pgn[i].x < ul_coord.x)
                                ul_coord.x = rect1.pgn[i].x;
                            if (rect1.pgn[i].y < ul_coord.y)
                                ul_coord.y = rect1.pgn[i].y;
                            if (rect1.pgn[i].x > lr_coord.x)
                                lr_coord.x = rect1.pgn[i].x;
                            if (rect1.pgn[i].y > lr_coord.y)
                                lr_coord.y = rect1.pgn[i].y;
                            }
                        fill_box ((struct coord_i FAR *)&ul_coord, /*@WIN*/
                            (struct coord_i FAR *)&lr_coord);  /*@WIN*/
                        }
                    else
                        fill_rect ((struct  line_seg_i FAR *)&rect1); /*@WIN*/
            }


            /* determine the lines of rect1, and rect_first to
             * calculate join point. rect1: close segment
             *                       rect_first: first line segment
             */
            linejoin_i ((struct  line_seg_i FAR *)&rect1,       /*@WIN*/
                (struct  line_seg_i FAR *)&rect_first);         /*@WIN*/

            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif

        } /* switch */

        last_node_type = vtx->VX_TYPE;

    } /* subpath loop */

    /* Create linecap for last node of subpath */
    if ((!close_flag) && (last_node_type!=MOVETO)
        && (first_seg_exist || (GSptr->line_cap==ROUND_CAP))) {
                        /* last node should not be a MOVETO node */
                        /* first line segment should exist or it is a round cap
                         * e.g. 100 100 moveto 100 100 lineto stroke
                         *      linecap == 0 --> no caps
                         *      linecap == 1 --> has caps
                         *      linecap == 2 --> no caps
                         */

        /* set up rectangle values for degerneted cases */
        if (!first_seg_exist) {
                rect_first.p0.x = x2;
                rect_first.p0.y = y2;
                rect1.p1.x = x2;
                rect1.p1.y = y2;
                        /* for special case: x y moveto
                         *                   x y lineto
                         *                   0 setlinewidth
                         *                   stroke
                         */
        }

        /* Create a linecap_path for last_node; */
        linecap_i ((struct  line_seg_i FAR *)&rect1, END_POINT); /*@WIN*/

        /* Create a linecap_path for sub_head node; */
        linecap_i ((struct  line_seg_i FAR *)&rect_first, START_POINT); /*@WIN*/

    } /* if !close_flag */

}
/*
 * 'quick' version : integer operation, solid line  -jwm, 3/18/91, -end-
 */

/*
 * Thin stroke version
 * Features: 1. always in clip region, ie. no clipping
 *           2. no linejoin, linecap
 *           3. should delt with dash
 */
void path_to_outline_t (isubpath, param)
SP_IDX  isubpath;
fix     FAR *param;
{
    VX_IDX  ivtx;
    struct  nd_hdr FAR *vtx;
    sfix_t   x1=0, y1=0, x2=0, y2=0;            /* @STK_INT */
    sfix_t   first_x, first_y;                                  /* @STK_INT */
    bool    first_seg_exist;   /* if first line segment has been created */
    VX_IDX  first_vertex;
    /* struct  vx_lst *vlist; @NODE */
    struct  nd_hdr FAR *sp;             /* TRVSE */

    struct  nd_hdr FAR *node;       /* @FLT_CVE 12/19/88 */
    VX_IDX  inode, vlist_head;          /* 1/28/89 */
    sfix_t  x3, y3, x4, y4;

    /* initilization */
    first_seg_exist = FALSE;
    paint_flag = TRUE;                /* paint_flag always true @STK_INT */
    inside_clip_flag = (ULONG_PTR) param;  /* initialize inside_clip_flag @STK_INT */

#ifdef DBG1
    dump_all_path (isubpath);
#endif

    sp = &node_table[isubpath];
    /* @NODE
     * first_vertex = sp->SP_HEAD;
     */
    first_vertex = isubpath;

    /* Traverse edges in subpath */
    for (ivtx = first_vertex; ivtx != NULLP; ivtx = vtx->next) {
        vtx = &node_table[ivtx];

        switch (vtx->VX_TYPE) {

        case MOVETO :
        case PSMOVE :
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            if (GSptr->dash_pattern.pat_size != 0) { /* dash line */
                /*
                 * Set up starting dash pattern in actdp struct
                 * (copy from init_dash_pattern to active_dash_pattern)
                 *  initdp => actdp
                 */
                actdp.dpat_on = GSptr->dash_pattern.dpat_on;
                actdp.dpat_offset = GSptr->dash_pattern.dpat_offset;
                actdp.dpat_index = GSptr->dash_pattern.dpat_index;
            }
            continue;   /* jump to for loop */

        case LINETO :
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            if (!first_seg_exist) {
                    /* save coord. of first node for closepath usage */
                    first_x = x1;
                    first_y = y1;
                    first_seg_exist = TRUE;
            }

            /* ignore this node if it coincides with the next node */
            /* the following line is corrected by Jack, degenerate case,
               ref. p.229 of PLRM, 10-15-90 */
/*          if ((x1 == x2) && (y1 == y2)) continue;     (* jump to for loop */

//DJC UPD050, delete following line
//            if ((x1 == x2) && (y1 == y2) && (GSptr->line_cap != 1)) continue;

            draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            break;

        /* @FLT_CVE 12/19/88 */
        case CURVETO :
            x1 = x2;
            y1 = y2;
            x2 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y2 = F2SFX(vtx->VERTEX_Y);

            /* Get next two nodes: x3, y3, x4, y4 */
            vtx = &node_table[vtx->next];
            x3 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y3 = F2SFX(vtx->VERTEX_Y);
            vtx = &node_table[vtx->next];
            x4 = F2SFX(vtx->VERTEX_X);                  /* @STK_INT */
            y4 = F2SFX(vtx->VERTEX_Y);

            /* @NODE
             * vlist = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
             */
            vlist_head = bezier_to_line_sfx(stk_info.flat_l, x1, y1,
                      x2, y2, x3, y3, x4, y4);

            /* keep head of the returned vertex list, otherwise the contain
             * of the return structure may be destroyed in the case of calling
             * bezier_to_line_sfx again before freeing this vertex list
             * (eg. linejoin = 1)       1/28/89
             */
            /* vlist_head = vlist->head; @NODE */

            x2 = x1;
            y2 = y1;

            for (inode = vlist_head; inode != NULLP;            /* 1/28/89 */
                 inode = node->next) {
                node = &node_table[inode];

                x1 = x2;
                y1 = y2;
                x2 = node->VXSFX_X;                  /* @STK_INT */
                y2 = node->VXSFX_Y;

                if (!first_seg_exist) {
                        /* save coord. of first node for closepath usage */
                        first_x = x1;
                        first_y = y1;
                        first_seg_exist = TRUE;
                }

                /* ignore this node if it coincides with the next node */
                if ((x1 == x2) && (y1 == y2)) continue;
                draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            } /* for */

            /* free vlist */
            free_node (vlist_head);             /* 1/28/89 */
            break;

        case CLOSEPATH :
            if (!first_seg_exist) break;
                                   /* degernated case; just return 1/9/89 */
            x1 = x2;
            y1 = y2;

            /* get first vertex coord. */
            x2 = first_x;
            y2 = first_y;

            draw_line (x1, y1, x2, y2);                 /* @FLT_CVE */
            break;

#ifdef DBGwarn
        default :
            printf("\007Fatal error, path_to_outline(): node type =%d",
                   vtx->VX_TYPE);
            printf("node# =%d, x, y =%f, %f\n", ivtx, vtx->VERTEX_X,
                   vtx->VERTEX_Y);
#endif
        } /* switch */
    } /* subpath loop */

}



/*
 * Draw line segment (x1, y1) => (x2, y2)
 */
static void near draw_line (x1, y1, x2, y2)
sfix_t  x1, y1, x2, y2;
{
        struct  line_seg_i rect1;                /* @STK_INT */

/*      if (GSptr->dash_pattern.pat_size == 0) { (* solid line */
        if ((GSptr->dash_pattern.pat_size == 0) ||      /* solid line */
            ((x1==x2) && (y1==y2))) {   /* or just a single point 12/18/90 */
            struct  tpzd_info fill_info;

            /* if not to fill a thin line(degernated trapezoid), but to
             * calculate the true rectangle outline for filling, then use the
             * following code
             *   rect1.p0.x = x1;
             *   rect1.p0.y = y1;
             *   rect1.p1.x = x2;
             *   rect1.p1.y = y2;
             *   get_rect_points_i (&rect1);
             *   paint_or_save_i (rect1.pgn);
             */

            /* set cache info */
            if (fill_destination == F_TO_CACHE) {
                    /* bounding box is defined by cache mechanism */
                    fill_info.BMAP = cache_info->bitmap;
                    fill_info.box_w = cache_info->box_w;
                    fill_info.box_h = cache_info->box_h;
            }

            fill_line (fill_destination, &fill_info, x1, y1, x2, y2);

        } else {        /* dash line, needs to call linetour */

            /* generate a degernated rectangle(a line) for filling */
            rect1.p0.x = x1;
            rect1.p0.y = y1;
            rect1.p1.x = x2;
            rect1.p1.y = y2;
            rect1.vct_u.x = zero_f;
            rect1.vct_u.y = zero_f;
            rect1.vct_d.x = rect1.vct_d.y = 0;
            rect1.pgn[0].x = rect1.pgn[1].x = x1;
            rect1.pgn[0].y = rect1.pgn[1].y = y1;
            rect1.pgn[2].x = rect1.pgn[3].x = x2;
            rect1.pgn[2].y = rect1.pgn[3].y = y2;
            linetour_i ((struct  line_seg_i FAR *)&rect1);      /*@WIN*/
        } /* if */
}

/***********************************************************************
 * This module is to check if the linewidth is thin enough to apply special
 * stroke routine.
 *
 * TITLE:       is_thinstroke
 *
 * CALL:        is_thinstroke()
 *
 * PARAMETERS:
 *
 * INTERFACE:   stroke_shape
 *
 * CALLS:       None
 *
 * RETURN:      TRUE  -- Yes, may use thin stroke approach
 *              FALSE -- No
 *
 **********************************************************************/
bool is_thinstroke()
{
        /* thin stroke only for no halftoning */
        if (HTP_Type != HT_WHITE && HTP_Type != HT_BLACK) return(FALSE);

        if ((MAGN(stk_info.exp_widthx) > 0x3f000000L) || /*trick:0.5 11/23/88 */
            (MAGN(stk_info.exp_widthy) > 0x3f000000L)) return(FALSE);

        return(TRUE);
}


/***********************************************************************
 * This module is to initialize the dash pattern for each setdash command
 *
 * TITLE:       init_dash_pattern
 *
 * CALL:        init_dash_pattern()
 *
 * PARAMETERS:  None
 *
 * INTERFACE:   op_setdash
 *
 * CALLS:       None
 *
 * RETURN:      None
 **********************************************************************/
void  init_dash_pattern()
{
        fix     i;
        real32   total_length;
        real32  pattern[11];             /* 12-8-90, compatibility */

        /* return for solid line */
        if (GSptr->dash_pattern.pat_size == 0) {
                return;
        }

        /* initialization */
        GSptr->dash_pattern.dpat_on = TRUE;

        if( !get_array_elmt(&GSptr->dash_pattern.pattern_obj,
             GSptr->dash_pattern.pat_size, pattern, G_ARRAY) )
             return;                     /* 12-8-90, compatibility */
        for(i = 0; i < GSptr->dash_pattern.pat_size; i++){
            GSptr->dash_pattern.pattern[i] = pattern[i];
        }                                /* 12-8-90, compatibility */

        /*
         * Set up starting dash pattern in initdp struct
         * Initialize current dash pattern element :
         * dpat_index, dpat_offset, and dpat_on
         */
        /* Accumulate total length in pattern array */
        total_length = zero_f;
        for (i=0; i<GSptr->dash_pattern.pat_size; i++) {
                total_length +=
                GSptr->dash_pattern.pattern[i];
        }

        /*
         * Find starting point of pattern array
         */
        /* wrap around offset over pattern size */
/*      GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;*/
        if (GSptr->dash_pattern.offset >= 0)   /* -begin- */
            GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;
        else {                                 /* negative offset, 11-29-90 */
            for (GSptr->dash_pattern.dpat_offset = GSptr->dash_pattern.offset;
                 GSptr->dash_pattern.dpat_offset < 0;
                 GSptr->dash_pattern.dpat_offset += total_length,
                 GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on);
        }                                      /* -end- */

        if (IS_NOTZERO(total_length)) {  /* only for non_empty pattern 5/26/89*/
                real32   wrap;
                fix     iwrap;

                if (GSptr->dash_pattern.dpat_offset >= total_length) {
                        wrap = (real32)(floor (GSptr->dash_pattern.dpat_offset /
                                              total_length));
                        if (wrap < (real32)65536.0)
                                iwrap = (fix) wrap;
                        else
                                iwrap = 0;
                        GSptr->dash_pattern.dpat_offset -= wrap * total_length;
                        if ((iwrap & 0x1) &&
                            (GSptr->dash_pattern.pat_size & 0x1))
                            GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on;
                            /* when numbers of pattern elements and wraps
                             * are odds, inverse the dpat_on flag @DASH
                             */
                } /* if */
        }

        for (i=0; i < GSptr->dash_pattern.pat_size; i++) {
                GSptr->dash_pattern.dpat_offset -=
                        GSptr->dash_pattern.pattern[i];
                if(GSptr->dash_pattern.dpat_offset <= zero_f){
                        GSptr->dash_pattern.dpat_offset +=
                                GSptr->dash_pattern.pattern[i];
                        break;
                }
                GSptr->dash_pattern.dpat_on = ! GSptr->dash_pattern.dpat_on;
        }
        GSptr->dash_pattern.dpat_index = (i >= GSptr->dash_pattern.pat_size) ?
                           0 : i;
}



/*
 * Initialize stroke parameters; called by stroke_shape(from op_stroke) and
 * op_strokepath
 */
#define CHANGE_WIDTH    1
#define CHANGE_MITER    2
#define CHANGE_FLAT     4
#define CHANGE_CTM      8

void init_stroke()
{
    real32      ctm_scale, tmp;         /* @EHS_STK */
    bool        change_flg = FALSE;
    fix         i;
    static real32 w2;           /* line_width ** 2 */
    real32      tmp0, tmp1;     /* @FABS */

    /* set parameters only circumstance has changed @STK_INFO */
    if (F2L(GSptr->line_width) != F2L(stk_info.width)) {
        stk_info.width = GSptr->line_width;
        change_flg |= CHANGE_WIDTH;     /* change_width = TRUE; */
    }
    if (F2L(GSptr->miter_limit) != F2L(stk_info.limit)) {
        stk_info.limit = GSptr->miter_limit;
        change_flg |= CHANGE_MITER;     /* change_miter = TRUE; */
    }
    if (F2L(GSptr->flatness) != F2L(stk_info.flatness)) {
        stk_info.flatness = GSptr->flatness;
        change_flg |= CHANGE_FLAT;      /* change_flat = TRUE; */
    }
    if ((F2L(GSptr->ctm[0]) != F2L(stk_info.ctm[0])) ||
        (F2L(GSptr->ctm[1]) != F2L(stk_info.ctm[1])) ||
        (F2L(GSptr->ctm[2]) != F2L(stk_info.ctm[2])) ||
        (F2L(GSptr->ctm[3]) != F2L(stk_info.ctm[3]))) {
        stk_info.ctm[0] = GSptr->ctm[0];
        stk_info.ctm[1] = GSptr->ctm[1];
        stk_info.ctm[2] = GSptr->ctm[2];
        stk_info.ctm[3] = GSptr->ctm[3];
        change_flg |= CHANGE_CTM;       /* change_ctm = TRUE; */
    }

    /* init dash pattern, 12-8-90, compatibility */
    init_dash_pattern();

    /* calculate flatness for stroke */
    if (change_flg & (CHANGE_WIDTH|CHANGE_FLAT|CHANGE_CTM)) {

        /* Calculate flatness of the curve which depends on the
         * linewidth.       (??? should be revised later)
         */
        ctm_scale = (real32)sqrt (GSptr->ctm[0] * GSptr->ctm[0] +
                                 GSptr->ctm[3] * GSptr->ctm[3]);
        /* tmp = (real32)(GSptr->line_width * ctm_scale); 1/10/90 */
        tmp = (real32)sqrt (GSptr->line_width * ctm_scale * 4);
        if (tmp <= one_f)
                /* stroke_flatness should not greater than flatness 3/11/88 */
                stk_info.flat = GSptr->flatness;        /* stroke_flat = */
        else
                stk_info.flat = GSptr->flatness / tmp;

        /* adjust flatness value */
        if( stk_info.flat < (real32)0.2 )        stk_info.flat = (real32)0.2;
        else if( stk_info.flat > (real32)100.  ) stk_info.flat = (real32)100.;
        stk_info.flat_l = F2LFX(stk_info.flat);       /* @FLT_CVE 12/19/88 */

        /* circle defined in curve[][] array cannont use for this stroke */
        stk_info.change_circle = TRUE;
        circle_flag = CIR_UNSET_CACHE;  /* circle not put in cache yet */
    }

    /* pre-set half of linewidth */
    if (change_flg & CHANGE_WIDTH) {
        stk_info.half_width = GSptr->line_width / 2;
        stk_info.half_width_i = F2SFX(stk_info.half_width);     /* @STK_INT */
        _clear87();    /* clear the status87 of last inst. 11/18/88 */

        w2 = (GSptr->line_width * GSptr->line_width) /4;
        stk_info.miter0 = w2 * (real32)0.9659258;       /* cos(15) */
    }

    /* calculate miter limit value */
    if (change_flg & (CHANGE_WIDTH|CHANGE_MITER)) {
        /* pre-calculate miter limit value  @EHS_JOIN
         *    miter_value = (2/(m*m) - 1) * w*w
         *    where, m: miter limit
         *           w: linewidth / 2
         */
        FABS(tmp0, GSptr->miter_limit);
        if (tmp0 < (real32)TOLERANCE)
             stk_info.miter = (real32)EMAXP;    /* @STK_INFO: miter_value */
        else
             stk_info.miter =  (2 / (GSptr->miter_limit * GSptr->miter_limit) - 1)
                          * w2;
    }

    /* set up inverse CTM[0:3], extracted from set_inverse_ctm(); @STK_INFO */
    if (change_flg & CHANGE_CTM) {
       set_inverse_ctm();   /* ???to be updated later, for deleting ctm[4:5] */
       for (i=0; i<4; i++) {                            /* @STK_INT */
               stroke_ctm[i] = (sfix_t)F2SFX12_T(GSptr->ctm[i]); //@WIN
       }
    }

    /* calculate expanding coord of line width 11/22/88 */
    if (change_flg & (CHANGE_WIDTH|CHANGE_CTM)) {
        FABS(tmp0, GSptr->ctm[0]);
        FABS(tmp1, GSptr->ctm[2]);
        stk_info.exp_widthx = stk_info.half_width * (tmp0 + tmp1);
        CHECK_INFINITY(stk_info.exp_widthx);    /* check inifinity 1/26/89 */
        FABS(tmp0, GSptr->ctm[1]);
        FABS(tmp1, GSptr->ctm[3]);
        stk_info.exp_widthy = stk_info.half_width * (tmp0 + tmp1);
        CHECK_INFINITY(stk_info.exp_widthy);    /* check inifinity 1/26/89 */
    }

    /* calculate max expanding coord of miter join 11/22/88 */
    if (change_flg & (CHANGE_WIDTH|CHANGE_CTM|CHANGE_MITER)) {
        stk_info.exp_miterx = GSptr->miter_limit * stk_info.exp_widthx;
        CHECK_INFINITY(stk_info.exp_miterx);    /* check inifinity 1/26/89 */
        stk_info.exp_mitery = GSptr->miter_limit * stk_info.exp_widthy;
        CHECK_INFINITY(stk_info.exp_mitery);    /* check inifinity 1/26/89 */
    }

    /* setup cache_info for circle cache @CIR_CACHE */
    if (circle_flag == CIR_IN_CACHE) {
        save_cache_info = cache_info;   /* save old cache_info */
        cache_info = &cir_cache_info;
    }

    /* clear the status87 for initialization 11/07/88 */
    _clear87();
}


/*
 * end of stroke; called by stroke_shape(from op_stroke)
 */
void end_stroke()
{
    /* restore cache_info */
    if (circle_flag == CIR_IN_CACHE) {
        cache_info = save_cache_info;
    }

}


/*
 * calculate the max expanding bounding box when performs stroking
 * called by stroke_shape(from op_stroke)
 */
void expand_stroke_box (bbox)
real32    FAR bbox[];
{
    /* add with the max expanding points of join points */
    bbox[0] -= stk_info.exp_miterx;
    bbox[1] -= stk_info.exp_mitery;
    bbox[2] += stk_info.exp_miterx;
    bbox[3] += stk_info.exp_mitery;
}


/***********************************************************************
 * This module is to create a dash_line of a line segment.
 *
 * TITLE:       linetour
 *
 * CALL:        linetour(dx0, dy0, dx1, dy1)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *
 * CALLS:       Inverse_transform
 *              Rectangle
 *              Linecap
 *
 * RETURN:
 *
 **********************************************************************/
static void near linetour (rect1)
struct line_seg FAR *rect1;     /*@WIN*/
{
    struct  line_seg rect2;
    real32       cx, cy, nx, ny; /* current and next point */
    real32       dx, dy;         /* for calculating distance btwn
                                  * (cx, cy) and (x1, y1) only
                                  */
    real32      w, d, tx, ty;
    bool        done;
    real32      tmp;    /* @FABS */
    bool        first_seg;               /* first line segment @CAP */

    /* if solid line just fill it */
    if (GSptr->dash_pattern.pat_size == 0) { /* solid line */
        /* create a polygon contains the
         * rectangle
         */
        paint_or_save (rect1->pgn);

        return;
    }


    dx = rect1->p1.x - rect1->p0.x;                 /* device space */
    dy = rect1->p1.y - rect1->p0.y;

    /* derive tx, ty from rect information 11/21/88
     * since,
     *      rect1->vct_u.x == (w0 * |uy|) / sqrt(ux*ux + uy*uy)
     *                                  (* ref. get_rect_points() *)
     * so,  w = sqrt(ux*ux + uy*uy)
     *        = (w0 * |uy|) / rect1->vct_u.x
     * or,    = |ux| (when rect1->vct_u.x == 0)
     * where, w0 = half of line width
     */

    FABS(tmp, rect1->vct_u.x);
    if (tmp < (real32)1e-3) {
        if (IS_ZERO(rect1->vct_d.y) && IS_ZERO(rect1->vct_d.x)) { /* 5/26/89 */
            /* for thin line, need to compute the actual length under user space
             * scince rect1->vct_u.x is always zero     (* 1/5/89 *)
             */
            real32 ux, uy;
            ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
            w = (real32)sqrt(ux*ux + uy*uy);
        } else {
            w = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            FABS(w, w);
        }
    } else {
        w = (dx * inverse_ctm[1] + dy * inverse_ctm[3]) *
            stk_info.half_width / rect1->vct_u.x;
        FABS(w, w);
    }

    tx = dx / w;        /* vector of advancing a user unit */
    ty = dy / w;

    cx = rect1->p0.x;
    cy = rect1->p0.y;
    rect2.vct_d = rect1->vct_d;
    rect2.vct_u = rect1->vct_u;

    /* add an error tolerance to length of line segment 10/20/88 */
    w = w + (real32)1e-3;               /* For case:
                                 * [10 5] 5 setdash
                                 * 480 650 moveto
                                 * 10 0 rlineto
                                 * stroke
                                 */
    done = FALSE;
    first_seg = TRUE;   /* for SQUARE_CAP & ROUND_CAP @CAP */

    while (1) {
        d = GSptr->dash_pattern.pattern[actdp.dpat_index] - actdp.dpat_offset;
        if (d > w) {
            d = w;
            done = TRUE;
        }

        nx = cx + tx * d;
        ny = cy + ty * d;

        if (actdp.dpat_on) {
                /* set current rectangle information */
                if (GSptr->line_cap == SQUARE_CAP) {
                        /* expand rectangle for square cap @CAP */
                        real32  x0, y0, x1, y1, tmpx, tmpy;

                        /* offset of expansion */
                        tmpx = tx * stk_info.half_width;
                        tmpy = ty * stk_info.half_width;

                        /* not expand line segment at start point */
                        if (first_seg) {
                            x0 = cx;
                            y0 = cy;
                        } else {
                            x0 = cx - tmpx;
                            y0 = cy - tmpy;
                        }

                        /* not expand line segment at end point */
                        if (done) {
                            x1 = nx;
                            y1 = ny;
                        } else {
                            x1 = nx + tmpx;
                            y1 = ny + tmpy;
                        }

                        rect2.p0.x = x0;
                        rect2.p0.y = y0;
                        rect2.p1.x = x1;
                        rect2.p1.y = y1;

                        rect2.pgn[0].x = x0 + rect1->vct_d.x;
                        rect2.pgn[0].y = y0 + rect1->vct_d.y;
                        rect2.pgn[1].x = x0 - rect1->vct_d.x;
                        rect2.pgn[1].y = y0 - rect1->vct_d.y;
                        rect2.pgn[2].x = x1 - rect1->vct_d.x;
                        rect2.pgn[2].y = y1 - rect1->vct_d.y;
                        rect2.pgn[3].x = x1 + rect1->vct_d.x;
                        rect2.pgn[3].y = y1 + rect1->vct_d.y;

                } else {        /* for BUTT & ROUND cap */
                        rect2.p0.x = cx;
                        rect2.p0.y = cy;
                        rect2.p1.x = nx;
                        rect2.p1.y = ny;

                        rect2.pgn[0].x = cx + rect1->vct_d.x;
                        rect2.pgn[0].y = cy + rect1->vct_d.y;
                        rect2.pgn[1].x = cx - rect1->vct_d.x;
                        rect2.pgn[1].y = cy - rect1->vct_d.y;
                        rect2.pgn[2].x = nx - rect1->vct_d.x;
                        rect2.pgn[2].y = ny - rect1->vct_d.y;
                        rect2.pgn[3].x = nx + rect1->vct_d.x;
                        rect2.pgn[3].y = ny + rect1->vct_d.y;
                }

                /* put a circle at start point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!first_seg)) {
                        /* no circle cap at start point @WIN*/
                        linecap ((struct line_seg FAR *)&rect2, START_POINT);
                }

                /* create a rectangle covers (cx, cy) -> (nx, ny) @CAP */
                paint_or_save ((struct coord FAR *)rect2.pgn);  /*@WIN*/

                /* put a circle at end point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!done)) {
                        /* no circle cap at end point @WIN*/
                        linecap ((struct line_seg FAR *)&rect2, END_POINT);
                }

        }

        /* Update next pattern element */
        if (done) {
            actdp.dpat_offset += w;    /* this line segment took more w units */
            break;
        } else {
            actdp.dpat_offset = zero_f;
            actdp.dpat_on = ! actdp.dpat_on;
            actdp.dpat_index++;
            if (actdp.dpat_index >= GSptr->dash_pattern.pat_size)
                    actdp.dpat_index = 0;
        }

        cx = nx;
        cy = ny;
        w -= d;
        first_seg = FALSE;              /* @CAP */
    } /* while */

}


/*
 * Integer operation version
 */
static void near linetour_i (rect1)
struct line_seg_i FAR *rect1;           /*@WIN*/
{
    struct  line_seg_i rect2;                   /* @STK_INT */
    real32       cx, cy, nx, ny; /* current and next point, @STK_INT */
    sfix_t       cx_i, cy_i, nx_i, ny_i;        /* SFX format */

    fix32        dx, dy;         /* for calculating distance btwn @STK_INT
                                  * (cx, cy) and (x1, y1) only
                                  */
    real32   w, d, tx, ty;
    bool        done;
    real32      tmp;    /* @FABS */
    bool        first_seg;               /* first line segment @CAP */

    /* if solid line just fill it */
    if (GSptr->dash_pattern.pat_size == 0) { /* solid line */
        /* create a polygon contains the
         * rectangle
         */
        paint_or_save_i (rect1->pgn);

        return;
    }

    dx = (fix32)rect1->p1.x - rect1->p0.x;              /* @STK_INT */
    dy = (fix32)rect1->p1.y - rect1->p0.y;

    /* derive tx, ty from rect information 11/21/88
     * since,
     *      rect1->vct_u.x == (w0 * |uy|) / sqrt(ux*ux + uy*uy)
     *                                  (* ref. get_rect_points() *)
     * so,  w = sqrt(ux*ux + uy*uy)
     *        = (w0 * |uy|) / rect1->vct_u.x
     * or,    = |ux| (when rect1->vct_u.x == 0)
     * where, w0 = half of line width
     */

    FABS(tmp, rect1->vct_u.x);
    if (tmp < (real32)1e-3) {

        if ((rect1->vct_d.y == 0) && (rect1->vct_d.x == 0)) {
            /* for thin line, need to compute the actual length under user space
             * scince rect1->vct_u.x is always zero     (* 1/5/89 *)
             */
            real32 ux, uy;
            ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
            uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
            w = (real32)sqrt(ux*ux + uy*uy) / ONE_SFX;
        } else {
            w = (dx * inverse_ctm[0] + dy * inverse_ctm[2]) / ONE_SFX;
            FABS(w, w);
        }
    } else {
        w = ((dx * inverse_ctm[1] + dy * inverse_ctm[3]) *
             stk_info.half_width / rect1->vct_u.x) / ONE_SFX;
        FABS(w, w);
    }

    tx = dx / w;        /* vector of advancing a user unit */
    ty = dy / w;

    cx = (real32)rect1->p0.x;
    cy = (real32)rect1->p0.y;
    rect2.vct_d = rect1->vct_d;
    rect2.vct_u = rect1->vct_u;

    /* add an error tolerance to length of line segment 10/20/88 */
    w = w + (real32)1e-3;               /* For case:
                                 * [10 5] 5 setdash
                                 * 480 650 moveto
                                 * 10 0 rlineto
                                 * stroke
                                 */
    done = FALSE;
    first_seg = TRUE;   /* for SQUARE_CAP & ROUND_CAP @CAP */

    while (1) {
        d = GSptr->dash_pattern.pattern[actdp.dpat_index] - actdp.dpat_offset;
        if (d > w) {
            d = w;
            done = TRUE;
        }

        nx = cx + tx * d;
        ny = cy + ty * d;

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif

        cx_i = (sfix_t)cx;      /* SFX format */
        cy_i = (sfix_t)cy;
        nx_i = (sfix_t)nx;
        ny_i = (sfix_t)ny;

        if (actdp.dpat_on) {
                /* set current rectangle information */
                if (GSptr->line_cap == SQUARE_CAP) {
                        /* expand rectangle for square cap @CAP */
                        sfix_t  x0, y0, x1, y1, tmpx, tmpy;

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif
                        /* offset of expansion */
                        tmpx = (sfix_t)(tx * stk_info.half_width);
                        tmpy = (sfix_t)(ty * stk_info.half_width);

                        /* not expand line segment at start point */
                        if (first_seg) {
                            x0 = cx_i;
                            y0 = cy_i;
                        } else {
                            x0 = cx_i - tmpx;
                            y0 = cy_i - tmpy;
                        }

                        /* not expand line segment at end point */
                        if (done) {
                            x1 = nx_i;
                            y1 = ny_i;
                        } else {
                            x1 = nx_i + tmpx;
                            y1 = ny_i + tmpy;
                        }

                        rect2.p0.x = x0;
                        rect2.p0.y = y0;
                        rect2.p1.x = x1;
                        rect2.p1.y = y1;

                        rect2.pgn[0].x = x0 + rect1->vct_d.x;
                        rect2.pgn[0].y = y0 + rect1->vct_d.y;
                        rect2.pgn[1].x = x0 - rect1->vct_d.x;
                        rect2.pgn[1].y = y0 - rect1->vct_d.y;
                        rect2.pgn[2].x = x1 - rect1->vct_d.x;
                        rect2.pgn[2].y = y1 - rect1->vct_d.y;
                        rect2.pgn[3].x = x1 + rect1->vct_d.x;
                        rect2.pgn[3].y = y1 + rect1->vct_d.y;

                } else {        /* for BUTT & ROUND cap */
                        rect2.p0.x = cx_i;
                        rect2.p0.y = cy_i;
                        rect2.p1.x = nx_i;
                        rect2.p1.y = ny_i;

                        rect2.pgn[0].x = cx_i + rect1->vct_d.x;
                        rect2.pgn[0].y = cy_i + rect1->vct_d.y;
                        rect2.pgn[1].x = cx_i - rect1->vct_d.x;
                        rect2.pgn[1].y = cy_i - rect1->vct_d.y;
                        rect2.pgn[2].x = nx_i - rect1->vct_d.x;
                        rect2.pgn[2].y = ny_i - rect1->vct_d.y;
                        rect2.pgn[3].x = nx_i + rect1->vct_d.x;
                        rect2.pgn[3].y = ny_i + rect1->vct_d.y;
                }

                /* put a circle at start point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!first_seg)) {
                    /* no circle cap at start point @WIN*/
                    linecap_i ((struct  line_seg_i FAR *)&rect2, START_POINT);
                }

                /* create a rectangle covers (cx_i, cy_i) -> (nx_i, ny_i) @CAP*/
                paint_or_save_i ((struct coord_i FAR *)rect2.pgn);

                /* put a circle at end point for round cap @CAP */
                if ((GSptr->line_cap == ROUND_CAP) && (!done)) {
                    /* no circle cap at end point @WIN*/
                    linecap_i ((struct line_seg_i FAR *)&rect2, END_POINT);
                }

        }

        /* Update next pattern element */
        if (done) {
            actdp.dpat_offset += w;    /* this line segment took more w units */
            break;
        } else {
            actdp.dpat_offset = zero_f;
            actdp.dpat_on = ! actdp.dpat_on;
            actdp.dpat_index++;
            if (actdp.dpat_index >= GSptr->dash_pattern.pat_size)
                    actdp.dpat_index = 0;
        }

        cx = nx;
        cy = ny;
        w -= d;
        first_seg = FALSE;              /* @CAP */
    } /* while */

}




/***********************************************************************
 * Given 3 points (dx0, dy0), (dx1, dy1), and (dx2, dy2), this module
 * creates a appropriate path at the corner(dx1, dy1).
 *
 * TITLE:       linejoin
 *
 * CALL:        linejoin(dx0, dy0, dx1, dy1, dx2, dy2)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *
 * CALLS:       transform, inverse_transform, endpoint, arc,
 *              shape_approximation, shape_reduction, convex_clipper
 *
 * RETURN:
 **********************************************************************/
static void near linejoin (rect0, rect1)
struct  line_seg FAR *rect0, FAR *rect1;        /*@WIN*/
{
        real32 px0, py0, px1, py1, px2, py2;
        real32 miter;

        real32 sx0, sy0, sx1, sy1;
        real32 delta_x1, delta_y1, delta_x2, delta_y2;
        real32 delta_topx, delta_topy, divider, s;

        struct coord pgn[4];

        real32   dot_product;            /* @DOT_PRO */
        fix     select;                 /* @DOT_PRO */
        real32  tmp1, tmp2;

        /* Check if null line join,
         * i.e. the last line segment is a gap
         */
        if (GSptr->dash_pattern.pat_size != 0) {
                /* not for solid line */

               if(IS_ZERO(actdp.dpat_offset)) {         /* 5/26/89 */
                       /* actdp.dpat_on is for next line segment, so
                        * its inverse is ones for last line segment
                        */
                       if(actdp.dpat_on) return;

                               /* i.e. if (!(!actdp.doat_on)) return;*/
               } else {
                       if(!actdp.dpat_on) return;
               }
        }

        /* initialization for miter and bevel joins */
        if (GSptr->line_join != ROUND_JOIN) {   /* miter or bevel join */

                /* determine the lines of rect0, and rect1 to calculate join
                 * point for bevel and miter joins            @DOT_PRO
                 */
                dot_product = (rect0->p1.x - rect0->p0.x) *     /* 10/4/88 */
                              (rect1->p1.y - rect1->p0.y) -
                              (rect0->p1.y - rect0->p0.y) *
                              (rect1->p1.x - rect1->p0.x);
                /*select = (dot_product < zero_f) ? LINE03 : LINE12; 3/20/91 */
                select = (SIGN_F(dot_product)) ? LINE03 : LINE12;
        }

        /* Create line joint due to the type of current_linejoin */
        switch (GSptr->line_join) {

        case ROUND_JOIN :    /* for round linejoin */

                round_point(F2L(rect0->p1.x), F2L(rect0->p1.y));

                break;

        case BEVEL_JOIN :    /* for bevel linejoin */

                if (select == LINE03) {
                        pgn[0] = rect0->pgn[3];
                        pgn[1] = pgn[2] = rect0->p1;
                        pgn[3] = rect1->pgn[0];

                } else {        /* select == LINE12 */
                        pgn[0] = rect0->pgn[2];
                        pgn[1] = rect1->pgn[1];
                        pgn[2] = pgn[3] = rect0->p1;
                }

                /* Fill the outline or save it */
                paint_or_save ((struct coord FAR *)pgn);
                break;

        case MITER_JOIN :
                /* Find end points of edge1, edge2:
                 * edge1: (sx0, sy0) --> (px0, py0)
                 * edge2: (sx1, sy1) --> (px1, py1)
                 */
                if (select == LINE03) {
                        sx0 = rect0->pgn[0].x;
                        sy0 = rect0->pgn[0].y;
                        px0 = rect0->pgn[3].x;
                        py0 = rect0->pgn[3].y;
                        px1 = rect1->pgn[0].x;
                        py1 = rect1->pgn[0].y;
                        sx1 = rect1->pgn[3].x;
                        sy1 = rect1->pgn[3].y;
                } else {        /* select == LINE12 */
                        sx0 = rect0->pgn[1].x;
                        sy0 = rect0->pgn[1].y;
                        px0 = rect0->pgn[2].x;
                        py0 = rect0->pgn[2].y;
                        px1 = rect1->pgn[1].x;
                        py1 = rect1->pgn[1].y;
                        sx1 = rect1->pgn[2].x;
                        sy1 = rect1->pgn[2].y;
                }

                /* check if join point is too small 8/24/88 */
                tmp1 = rect0->vct_d.x - rect1->vct_d.x;     /* 10/5/88 */
                tmp2 = rect0->vct_d.y - rect1->vct_d.y;
                if ((EXP(F2L(tmp1)) < 0x3f800000L) &&
                    (EXP(F2L(tmp2)) < 0x3f800000L)) goto bevel_miter;

                /* Check if the expanded segment is too sharp @EHS_JOIN */
                /* if  dot(a, b) < stk_info.miter
                 *      where a = rect0->vct_u          (* (px0-x1, py0-y1) *)
                 *            b = rect1->vct_u          (* (px1-x1, py1-y1) *)
                 */
                miter = rect0->vct_u.x * rect1->vct_u.x +
                        rect0->vct_u.y * rect1->vct_u.y;

                if ((miter < stk_info.miter) || (miter > stk_info.miter0)) {
                        /* Create a bevel triangle polygon contains
                         * (dx1, dy1), (px0, py0)', and (px1, py1)'.
                         */
bevel_miter:
                        pgn[0].x = px0;
                        pgn[0].y = py0;

                        if(select == LINE03) {
                                pgn[1] = pgn[2] = rect0->p1;
                                pgn[3].x = px1;
                                pgn[3].y = py1;
                        }
                        else{   /* select == LINE12 */
                                pgn[1].x = px1;
                                pgn[1].y = py1;
                                pgn[2] = pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it */
                        paint_or_save ((struct coord FAR *)pgn);

                } else { /* miter join */

                        /* Find the third point(px2, py2) */
                        /*
                         * Find cross point of edge1 and
                         * edge2 using parametric formula:
                         * edge1 = u + s * delta_u
                         * edge2 = v + t * delta_v
                         */
                        delta_x1 = px0 - sx0;
                        delta_y1 = py0 - sy0;
                        delta_x2 = px1 - sx1;
                        delta_y2 = py1 - sy1;
                        delta_topx = sx0 - sx1;
                        delta_topy = sy0 - sy1;
                        divider = delta_x1 * delta_y2 - delta_x2 *
                                  delta_y1;

                        /* Collinear edges */
                        FABS(tmp1, divider);
                        if(tmp1 < (real32)1e-3) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;       /* 10/30/87 */
                        } else {

                                /* Solved parameters */
                                s = ((delta_x2 * delta_topy) -
                                      (delta_y2 * delta_topx) ) / divider;
                                if (EXP(F2L(s)) < 0x3f800000L) {   /* s < 1.0 */
#ifdef DBGwarn
                                        printf("\07Linejoin(), s <= 1\n");
#endif
                                        goto bevel_miter;       /* 02/29/88 */
                                }

                                px2 = sx0 + s * delta_x1;
                                py2 = sy0 + s * delta_y1;
                        }

                        /* Create a miter rectangle subpath */
                        pgn[0].x = px0;
                        pgn[0].y = py0;
                        pgn[2].x = px1;
                        pgn[2].y = py1;
                        if(select == LINE03) {
                                pgn[1] = rect0->p1;
                                pgn[3].x = px2;
                                pgn[3].y = py2;
                        } else {   /* select == LINE12 */
                                pgn[1].x = px2;
                                pgn[1].y = py2;
                                pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save ((struct coord FAR *)pgn);
                } /* if miter */
        } /* switch */
}


/*
 * Integer operation version
 */
static void near linejoin_i (rect0, rect1)
struct  line_seg_i FAR *rect0, FAR *rect1;      /*@WIN*/
{
        sfix_t px0, py0, px1, py1, px2, py2;                    /* @STK_INT */
        real32 miter;

        sfix_t sx0, sy0, sx1, sy1;                    /* @STK_INT */
        fix32  delta_x1, delta_y1, delta_x2, delta_y2;          /* @STK_INT */
        fix32  delta_topx, delta_topy;                          /* @STK_INT */
        real32 s;                                               /* @STK_INT */

        struct coord_i pgn[4];                                  /* @STK_INT */

        fix32    dot_product;                                   /* @STK_INT */
        fix     select;                 /* @DOT_PRO */
/*      real32  tmp;                                               @STK_INT */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        fix32 divider;
#elif  FORMAT_16_16
        long dest1[2], dest2[2];
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 divider, dividend;

        long temp1[2], temp2[2];
        real32 temp1_f, temp2_f;
#elif  FORMAT_28_4
        long dest1[2], dest2[2];
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 divider, dividend;

        long temp1[2], temp2[2];
        real32 temp1_f, temp2_f;
#endif
        /* Check if null line join,
         * i.e. the last line segment is a gap
         */
        if (GSptr->dash_pattern.pat_size != 0) {
                /* not for solid line */

               if(IS_ZERO(actdp.dpat_offset)) {         /* 5/26/89 */
                       /* actdp.dpat_on is for next line segment, so
                        * its inverse is ones for last line segment
                        */
                       if(actdp.dpat_on) return;

                               /* i.e. if (!(!actdp.doat_on)) return;*/
               } else {
                       if(!actdp.dpat_on) return;
               }
        }

        /* initialization for miter and bevel joins */
        if (GSptr->line_join != ROUND_JOIN) {   /* miter or bevel join */

                /* determine the lines of rect0, and rect1 to calculate join
                 * point for bevel and miter joins            @DOT_PRO
                 */
                /* dot_product = ((fix32)rect0->p1.x - rect0->p0.x) *  |* 10/4/88 *|
                              ((fix32)rect1->p1.y - rect1->p0.y) -
                              ((fix32)rect0->p1.y - rect0->p0.y) *
                              ((fix32)rect1->p1.x - rect1->p0.x);
                */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                dot_product = ((fix32)rect0->p1.x - rect0->p0.x) *
                              ((fix32)rect1->p1.y - rect1->p0.y) -
                              ((fix32)rect0->p1.y - rect0->p0.y) *
                              ((fix32)rect1->p1.x - rect1->p0.x);
                select = (dot_product < 0) ? LINE03 : LINE12;   /* @STK_INT */
#elif  FORMAT_16_16
                LongFixsMul((rect0->p1.x - rect0->p0.x),
                            (rect1->p1.y - rect1->p0.y), dest1);
                LongFixsMul((rect0->p1.y - rect0->p0.y),
                            (rect1->p1.x - rect1->p0.x), dest2);

                LongFixsSub(dest1, dest2, temp1);

                if (temp1[0] < 0)
                        select = LINE03;
                else
                        select = LINE12;
#elif  FORMAT_28_4
                LongFixsMul((rect0->p1.x - rect0->p0.x),
                            (rect1->p1.y - rect1->p0.y), dest1);
                LongFixsMul((rect0->p1.y - rect0->p0.y),
                            (rect1->p1.x - rect1->p0.x), dest2);

                LongFixsSub(dest1, dest2, temp1);

                if (temp1[0] < 0)
                        select = LINE03;
                else
                        select = LINE12;
#endif
        }

        /* Create line joint due to the type of current_linejoin */
        switch (GSptr->line_join) {
        real32 tx, ty;

        case ROUND_JOIN :    /* for round linejoin */

                tx = SFX2F(rect0->p1.x);               /* @CIR_CACHE */
                ty = SFX2F(rect0->p1.y);
                round_point(F2L(tx), F2L(ty));

                break;

        case BEVEL_JOIN :    /* for bevel linejoin */

                if (select == LINE03) {
                        pgn[0] = rect0->pgn[3];
                        pgn[1] = pgn[2] = rect0->p1;
                        pgn[3] = rect1->pgn[0];

                } else {        /* select == LINE12 */
                        pgn[0] = rect0->pgn[2];
                        pgn[1] = rect1->pgn[1];
                        pgn[2] = pgn[3] = rect0->p1;
                }

                /* Fill the outline or save it @WIN*/
                paint_or_save_i ((struct coord_i FAR *)pgn);
                break;

        case MITER_JOIN :
                /* Find end points of edge1, edge2:
                 * edge1: (sx0, sy0) --> (px0, py0)
                 * edge2: (sx1, sy1) --> (px1, py1)
                 */
                if (select == LINE03) {
                        sx0 = rect0->pgn[0].x;
                        sy0 = rect0->pgn[0].y;
                        px0 = rect0->pgn[3].x;
                        py0 = rect0->pgn[3].y;
                        px1 = rect1->pgn[0].x;
                        py1 = rect1->pgn[0].y;
                        sx1 = rect1->pgn[3].x;
                        sy1 = rect1->pgn[3].y;
                } else {        /* select == LINE12 */
                        sx0 = rect0->pgn[1].x;
                        sy0 = rect0->pgn[1].y;
                        px0 = rect0->pgn[2].x;
                        py0 = rect0->pgn[2].y;
                        px1 = rect1->pgn[1].x;
                        py1 = rect1->pgn[1].y;
                        sx1 = rect1->pgn[2].x;
                        sy1 = rect1->pgn[2].y;
                }
#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif

                /* check if join point is too small 8/24/88 */
                if ((ABS(rect0->vct_d.x - rect1->vct_d.x) < ONE_SFX) &&
                    (ABS(rect0->vct_d.y - rect1->vct_d.y) < ONE_SFX))
                        goto bevel_miter;
                                        /* ONE_SFX: 1 unit in SFX @STK_INT */

                /* Check if the expanded segment is too sharp @EHS_JOIN */
                /* if  dot(a, b) < stk_info.miter
                 *      where a = rect0->vct_u          (* (px0-x1, py0-y1) *)
                 *            b = rect1->vct_u          (* (px1-x1, py1-y1) *)
                 */
                miter = rect0->vct_u.x * rect1->vct_u.x +
                        rect0->vct_u.y * rect1->vct_u.y;

                if ((miter < stk_info.miter) || (miter > stk_info.miter0)) {
                        /* Create a bevel triangle polygon contains
                         * (dx1, dy1), (px0, py0)', and (px1, py1)'.
                         */
bevel_miter:
                        pgn[0].x = px0;
                        pgn[0].y = py0;

                        if(select == LINE03) {
                                pgn[1] = pgn[2] = rect0->p1;
                                pgn[3].x = px1;
                                pgn[3].y = py1;
                        }
                        else{   /* select == LINE12 */
                                pgn[1].x = px1;
                                pgn[1].y = py1;
                                pgn[2] = pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save_i ((struct coord_i FAR *)pgn);

                } else { /* miter join */

                        /* Find the third point(px2, py2) */
                        /*
                         * Find cross point of edge1 and
                         * edge2 using parametric formula:
                         * edge1 = u + s * delta_u
                         * edge2 = v + t * delta_v
                         */
                        delta_x1 = (fix32)px0 - sx0;            /* @STK_INT */
                        delta_y1 = (fix32)py0 - sy0;            /* @STK_INT */
                        delta_x2 = (fix32)px1 - sx1;            /* @STK_INT */
                        delta_y2 = (fix32)py1 - sy1;            /* @STK_INT */
                        delta_topx = (fix32)sx0 - sx1;          /* @STK_INT */
                        delta_topy = (fix32)sy0 - sy1;          /* @STK_INT */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                        divider = delta_x1 * delta_y2 - delta_x2 *
                                  delta_y1;                     /* @STK_INT */

                        /* Collinear edges */
                        if(divider == 0) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;       /* 10/30/87 */
                        } else {

                                /* Solved parameters */
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                                                /* @STK_INT */
                                if (EXP(F2L(s)) < 0x3f800000L) {   /* s < 1.0 */

                                        goto bevel_miter;       /* 02/29/88 */
                                }
#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif

                                /* px2 = sx0 + (sfix_t)(s * delta_x1);
                                 * py2 = sy0 + (sfix_t)(s * delta_y1);
                                 *    (fixing short_fixed overflow bugs 4/6/90)
                                 */
                                px2 = (sfix_t)(sx0 + (lfix_t)(s * delta_x1));//@WIN
                                py2 = (sfix_t)(sy0 + (lfix_t)(s * delta_y1));//@WIN
                        }
#elif  FORMAT_16_16
                        LongFixsMul(delta_x1, delta_y2, dest3);
                        LongFixsMul(delta_x2, delta_y1, dest4);
                        if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;
                        }
                        else {
                                /* Solved parameters
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                */
                                LongFixsMul(delta_x2, delta_topy, dest5);
                                LongFixsMul(delta_y2, delta_topx, dest6);

                                LongFixsSub(dest5, dest6, temp1);
                                LongFixsSub(dest3, dest4, temp2);

                                change_to_real(temp1, &temp1_f);
                                change_to_real(temp2, &temp2_f);

                                if (LABS(temp1_f) < LABS(temp2_f))
                                        goto bevel_miter;

#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif

                                s = temp1_f / temp2_f;
                                px2 = sx0 + (lfix_t)(s * delta_x1); /*@STK_INT*/
                                py2 = sy0 + (lfix_t)(s * delta_y1); /*@STK_INT*/
                        }
#elif  FORMAT_28_4
                        LongFixsMul(delta_x1, delta_y2, dest3);
                        LongFixsMul(delta_x2, delta_y1, dest4);
                        if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                                px2 = px0;
                                py2 = py0;
                                goto bevel_miter;
                        }
                        else {
                                /* Solved parameters
                                s = ((delta_x2 * delta_topy) -
                                    (delta_y2 * delta_topx) ) / (real32)divider;
                                */
                                LongFixsMul(delta_x2, delta_topy, dest5);
                                LongFixsMul(delta_y2, delta_topx, dest6);

                                LongFixsSub(dest5, dest6, temp1);
                                LongFixsSub(dest3, dest4, temp2);

                                change_to_real(temp1, &temp1_f);
                                change_to_real(temp2, &temp2_f);

                                if (LABS(temp1_f) < LABS(temp2_f))
                                        goto bevel_miter;

#ifdef _AM29K
        dummy ();               /* Weird stuff, compiler bug */
#endif
                                s = temp1_f / temp2_f;
                                px2 = sx0 + (lfix_t)(s * delta_x1); /*@STK_INT*/
                                py2 = sy0 + (lfix_t)(s * delta_y1); /*@STK_INT*/
                        }
#endif

                        /* Create a miter rectangle subpath */
                        pgn[0].x = px0;
                        pgn[0].y = py0;
                        pgn[2].x = px1;
                        pgn[2].y = py1;
                        if(select == LINE03) {
                                pgn[1] = rect0->p1;
                                pgn[3].x = px2;
                                pgn[3].y = py2;
                        } else {   /* select == LINE12 */
                                pgn[1].x = px2;
                                pgn[1].y = py2;
                                pgn[3] = rect0->p1;
                        }

                        /* Fill the outline or save it @WIN*/
                        paint_or_save_i ((struct coord_i FAR *)pgn);
                } /* if miter */
        } /* switch */
}


/***********************************************************************
 * Given a line segment whose 2 end points are (dx1, dy1) and (dx2, dy2)
 * respectively, this module creates an rectangle that expands at point
 * (dx2, dy2).
 *
 * TITLE:       linecap
 *
 * CALL:        linecap(dx1, dy1, dx2, dy2)
 *
 * PARAMETERS:
 *
 * INTERFACE:   Path_to_outline
 *              Linetour
 *
 * CALLS:       Inverse_transform
 *              Rectangle
 *              Arc
 *              Shape_approximation
 *              Shape_painting
 *              Convex_clipper
 *              Filler
 *
 * RETURN:
 *
 **********************************************************************/
static void near linecap (rect1, select)
struct  line_seg FAR *rect1;    /*@WIN*/
fix     select;
{
        real32 x1, y1, x2, y2, dx, dy, nx, ny, t;
        struct coord pgn[4];
        real32 ux, uy;
        real32 abs;     /* @FABS */

        /* ignore butt linecap */
        if (GSptr->line_cap == BUTT_CAP) return;

        /* ignore linecap for too small line width */
        if (GSptr->line_width < (real32)1e-3) return;

        /* get endpoint */
        if (select == END_POINT) {
                x1 = rect1->p0.x;
                y1 = rect1->p0.y;
                x2 = rect1->p1.x;
                y2 = rect1->p1.y;
        } else {
                x1 = rect1->p1.x;
                y1 = rect1->p1.y;
                x2 = rect1->p0.x;
                y2 = rect1->p0.y;
        }
                /* create linecap at point (x2, y2) */

        /* Create line cap due to the type of current_linecap */
        switch (GSptr->line_cap) {

        case ROUND_CAP :    /* for round linecap, ROUND = 1 */
                round_point(F2L(x2), F2L(y2));
                break;

        case SQUARE_CAP :   /* for square linecap, SQUARE = 2 */
                dx = x2 - x1;
                dy = y2 - y1;
                /* derive t from rect information 9/8/88 */
                uy = dx * inverse_ctm[1] + dy * inverse_ctm[3];
                FABS(abs, uy);
                if (abs < (real32)1e-3) {
                        ux = dx * inverse_ctm[0] + dy * inverse_ctm[2];
                        t = stk_info.half_width / ux;
                        FABS(t, t);
                        t += one_f;
                } else {
                        t = rect1->vct_u.x / uy;
                        FABS(t, t);
                        t += one_f;
                }

                /* create a rectangle covers (x2, y2) -> (x1+t*dx, y1+t*dy) */
                nx = x1 + t * dx;
                ny = y1 + t * dy;
                if (select == END_POINT) {
                        ux = rect1->vct_d.x;  /* unit vector of countour points */
                        uy = rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[3].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[3].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[2].x;
                        pgn[1].y = rect1->pgn[2].y;
                } else {
                        ux = -rect1->vct_d.x;
                        uy = -rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[1].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[1].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[0].x;
                        pgn[1].y = rect1->pgn[0].y;
                }
                pgn[2].x = nx - ux;
                pgn[2].y = ny - uy;
                pgn[3].x = nx + ux;
                pgn[3].y = ny + uy;
                paint_or_save ((struct coord FAR *)pgn); /*@WIN*/

                break;
        }
}


/*
 * Integer operation version
 */
static void near linecap_i (rect1, select)
struct  line_seg_i FAR *rect1;          /*@WIN*/
fix     select;
{
        sfix_t x1, y1, x2, y2, nx, ny, ux, uy;          /* @STK_INT */
        fix32  dx, dy;                                  /* @STK_INT */
        real32 t;                                       /* @STK_INT */
        struct coord_i pgn[4];                          /* @STK_INT */
        real32 tmp;

        /* ignore butt linecap */
        if (GSptr->line_cap == BUTT_CAP) return;

        /* ignore linecap for too small line width */
        if (GSptr->line_width < (real32)1e-3) return;

        /* get endpoint */
        if (select == END_POINT) {
                x1 = rect1->p0.x;
                y1 = rect1->p0.y;
                x2 = rect1->p1.x;
                y2 = rect1->p1.y;
        } else {
                x1 = rect1->p1.x;
                y1 = rect1->p1.y;
                x2 = rect1->p0.x;
                y2 = rect1->p0.y;
        }
                /* create linecap at point (x2, y2) */

        /* Create line cap due to the type of current_linecap */
        switch (GSptr->line_cap) {
        real32 tx, ty;

        case ROUND_CAP :    /* for round linecap, ROUND = 1 */
                tx = SFX2F(x2);                        /* @CIR_CACHE */
                ty = SFX2F(y2);
                round_point(F2L(tx), F2L(ty));
                break;

        case SQUARE_CAP :   /* for square linecap, SQUARE = 2 */
                dx = (fix32)x2 - x1;            /* @STK_INT */
                dy = (fix32)y2 - y1;            /* @STK_INT */
                /* derive t from rect information 9/8/88 */
                tmp = dx * inverse_ctm[1] + dy * inverse_ctm[3];
                FABS(tmp, tmp);
                /* if (tmp < (real32)1e-3) {
                 *                dx, dy in SFX format(multiplied by 8),
                 *                so tolrence should also be *8 for consistency
                 *                with floating version 1/27/89
                 */
                /* if (tmp < (real32)8e-3) { */
                if (tmp < ((real32)1e-3 * (real32)ONE_SFX)) {  /* @RESO_UPGR */
                        tmp = dx * inverse_ctm[0] + dy * inverse_ctm[2];
                        FABS(tmp, tmp);
                        t = one_f + (stk_info.half_width / tmp) * ONE_SFX;
                } else {
                        t = (rect1->vct_u.x / tmp) * ONE_SFX;
                        FABS(t, t);
                        t += one_f;
                }

#ifdef _AM29K
                dummy ();               /* Weird stuff, compiler bug */
#endif
                /* create a rectangle covers (x2, y2) -> (x1+t*dx, y1+t*dy) */
                nx = x1 + (sfix_t)(t * dx);             /* @STK_INT */
                ny = y1 + (sfix_t)(t * dy);
                if (select == END_POINT) {
                        ux = rect1->vct_d.x;  /* unit vector of countour points */
                        uy = rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[3].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[3].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[2].x;
                        pgn[1].y = rect1->pgn[2].y;
                } else {
                        ux = -rect1->vct_d.x;
                        uy = -rect1->vct_d.y;
                        pgn[0].x = rect1->pgn[1].x;     /* get from rect info */
                        pgn[0].y = rect1->pgn[1].y;     /* 9/8/88 */
                        pgn[1].x = rect1->pgn[0].x;
                        pgn[1].y = rect1->pgn[0].y;
                }
                pgn[2].x = nx - ux;
                pgn[2].y = ny - uy;
                pgn[3].x = nx + ux;
                pgn[3].y = ny + uy;
                paint_or_save_i ((struct coord_i FAR *)pgn);    /*@WIN*/

                break;
        }
}


static void near get_rect_points (rect1)
struct line_seg FAR *rect1;     /*@WIN*/
{
        real32   m, c, mc;
        bool16   horiz_line;
        real32   dx, dy, ux, uy, tmp;
        real32   abs;   /* @FABS */

        /* Compute 4 endpoints of the rectangle */

        /*
         * compute delta-vector in user space
         * delta-vector = (c, mc)
         * m = (u0x - u1x) / (u1y - u0y)
         *   = ((a*x0 + c*y0 + e) - (a*x1 + c*y1 + e)) /
         *     ((b*x1 + d*y1 + f) - (b*x0 + d*y0 + f))
         *   = (a * (x0-x1) + c * (y0-y1)) /
         *     (b * (x1-x0) + d * (y1-y0))
         *
         * where, (ux0, uy0) in user space = (x0, y0) in device space
         *        inverse_ctm = [a b c d e f]
         *
         * Revised for using ctm to get slope instead of inverse_ctm  11/21/88
         * since, inverse_ctm = [a b c d] = [D/M -B/M -C/M A/M]
         *        where, ctm = [A B C D],
         *               M = A * D - B * C
         * so,
         * m = (D/M * (x0-x1) + (-C/M) * (y0-y1)) /
         *     ((-B/M) * (x1-x0) + A/M * (y1-y0))
         *   = (-D * dx + C * dy) /
         *     (-B * dx + A * dy)
         */

        dx = rect1->p1.x - rect1->p0.x;
        dy = rect1->p1.y - rect1->p0.y;

        horiz_line = FALSE;
        if (ctm_flag&NORMAL_CTM) {      /* CTM = [a 0 0 d e f] */
                tmp = dy * GSptr->ctm[0];
                FABS(abs, tmp);
                if (abs < (real32)TOLERANCE) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * GSptr->ctm[3]) / tmp;
                }
        } else {
                tmp = -dx * GSptr->ctm[1] + dy * GSptr->ctm[0];
                FABS(abs, tmp);
                if (abs < (real32)TOLERANCE) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * GSptr->ctm[3] + dy * GSptr->ctm[2])
                            / tmp;
                }
        }

        /* get vector(ux, uy) that is perpendicular with (dx, dy) */
        if ( horiz_line) {
                /* transform delta-vector(0, stk_info.half_width) to device space */
                ux = GSptr->ctm[2] * stk_info.half_width;
                uy = GSptr->ctm[3] * stk_info.half_width;
                rect1->vct_u.x = zero_f;             /* vector in user space */
                rect1->vct_u.y = stk_info.half_width;

        } else {
                c = stk_info.half_width * (real32)sqrt(1 / (1 + m*m));
                mc = m * c;

                /* transform delta-vector(c, mc) to device space */
                ux = c*GSptr->ctm[0] + mc*GSptr->ctm[2];
                uy = c*GSptr->ctm[1] + mc*GSptr->ctm[3];

                rect1->vct_u.x = c;             /* vector in user space */
                rect1->vct_u.y = mc;            /* for check miter limit */
        }

        /* set clockwise direction */
        /* condition:
         *      (dx, dy) * (ux, uy) > 0,        *: cross product
         *
         *      =>   dx * uy - dy * ux > 0
         */
        if ((dx * uy) < (dy * ux)) {    /* reverse direction */
                ux = -ux;
                uy = -uy;
                rect1->vct_u.x = -rect1->vct_u.x;
                rect1->vct_u.y = -rect1->vct_u.y;
        }
        rect1->vct_d.x = ux;
        rect1->vct_d.y = uy;

        /* put in rect1 */
        rect1->pgn[0].x = rect1->p0.x + ux;
        rect1->pgn[0].y = rect1->p0.y + uy;
        rect1->pgn[1].x = rect1->p0.x - ux;
        rect1->pgn[1].y = rect1->p0.y - uy;
        rect1->pgn[2].x = rect1->p1.x - ux;
        rect1->pgn[2].y = rect1->p1.y - uy;
        rect1->pgn[3].x = rect1->p1.x + ux;
        rect1->pgn[3].y = rect1->p1.y + uy;

}



/*
 * Integer operation version
 */
static void near get_rect_points_i (rect1)
struct line_seg_i FAR *rect1;   /*@WIN*/
{
        real32   m;
        real32   c, mc;
        bool16   horiz_line;
        fix32    dx, dy, tmp;
        sfix_t   ux, uy;        /* @STK_INT */
#ifdef FORMAT_13_3
#elif FORMAT_16_16
        long dest1[2], dest2[2];   /* @RESO_UPGR */
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 dividend, divider;
        long quotient;
        long temp1[2], temp2[2];
#elif FORMAT_28_4
        long dest1[2], dest2[2];   /* @RESO_UPGR */
        long dest3[2], dest4[2], dest5[2], dest6[2];
        real32 dividend, divider;
        long quotient;
        long temp1[2], temp2[2];
#endif
        /* Compute 4 endpoints of the rectangle */

        /*
         * compute delta-vector in user space
         * delta-vector = (c, mc)
         * m = (u0x - u1x) / (u1y - u0y)
         *   = ((a*x0 + c*y0 + e) - (a*x1 + c*y1 + e)) /
         *     ((b*x1 + d*y1 + f) - (b*x0 + d*y0 + f))
         *   = (a * (x0-x1) + c * (y0-y1)) /
         *     (b * (x1-x0) + d * (y1-y0))
         *
         * where, (ux0, uy0) in user space = (x0, y0) in device space
         *        inverse_ctm = [a b c d e f]
         *
         * Revised for using ctm to get slope instead of inverse_ctm  11/21/88
         * since, inverse_ctm = [a b c d] = [D/M -B/M -C/M A/M]
         *        where, ctm = [A B C D],
         *               M = A * D - B * C
         * so,
         * m = (D/M * (x0-x1) + (-C/M) * (y0-y1)) /
         *     ((-B/M) * (x1-x0) + A/M * (y1-y0))
         *   = (-D * dx + C * dy) /
         *     (-B * dx + A * dy)
         */

        dx = (fix32)rect1->p1.x - rect1->p0.x;
        dy = (fix32)rect1->p1.y - rect1->p0.y;

        horiz_line = FALSE;
        if (ctm_flag&NORMAL_CTM) {      /* CTM = [a 0 0 d e f] */
                /* some code improvement. @RESO_UPGR */
                if (dy == 0 || stroke_ctm[0] == 0) {
                        horiz_line = TRUE;
                } else {
#ifdef FORMAT_13_3
                        tmp = dy * stroke_ctm[0];
                        m = (-dx * stroke_ctm[3]) / (real32)tmp;
#elif FORMAT_16_16
                        LongFixsMul(-dx, stroke_ctm[3], dest1);
                        quotient = LongFixsDiv(stroke_ctm[0], dest1);
                        m = (real32)quotient / (real32)dy;
#elif FORMAT_28_4
                        LongFixsMul(-dx, stroke_ctm[3], dest1);
                        quotient = LongFixsDiv(stroke_ctm[0], dest1);
                        m = (real32)quotient / (real32)dy;
#endif
                }
        } else {
#ifdef FORMAT_13_3
                tmp = -dx * stroke_ctm[1] + dy * stroke_ctm[0];
                if (tmp == 0) {
                        horiz_line = TRUE;
                } else {
                        m = (-dx * stroke_ctm[3] + dy * stroke_ctm[2])
                            / (real32)tmp;      /* @STK_INT */
                }
#elif FORMAT_16_16
                LongFixsMul(dx, stroke_ctm[1], dest3);
                LongFixsMul(dy, stroke_ctm[0], dest4);

                if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                        horiz_line = TRUE;
                } else {
                        LongFixsMul(dx, stroke_ctm[3], dest5);
                        LongFixsMul(dy, stroke_ctm[2], dest6);

                        LongFixsSub(dest6, dest5, temp1);
                        LongFixsSub(dest4, dest3, temp2);

                        change_to_real(temp1, &dividend);
                        change_to_real(temp2, &divider);
                        m = dividend / divider;
                }
#elif FORMAT_28_4
                LongFixsMul(dx, stroke_ctm[1], dest3);
                LongFixsMul(dy, stroke_ctm[0], dest4);

                if (dest3[0] == dest4[0] && dest3[1] == dest4[1]) {
                        horiz_line = TRUE;
                } else {
                        LongFixsMul(dx, stroke_ctm[3], dest5);
                        LongFixsMul(dy, stroke_ctm[2], dest6);

                        LongFixsSub(dest6, dest5, temp1);
                        LongFixsSub(dest4, dest3, temp2);

                        change_to_real(temp1, &dividend);
                        change_to_real(temp2, &divider);

                        m = dividend / divider;
                }
#endif
        }

        /* get vector(ux, uy) that is perpendicular with (dx, dy) */
        if ( horiz_line) {
                /* transform delta-vector(0, stk_info.half_width) to device space
                */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                */
                tmp = (fix32)(stk_info.half_width_i << 1);
                ux = LFX2SFX(stroke_ctm[2] * tmp); /* @STK_INT*/
                uy = LFX2SFX(stroke_ctm[3] * tmp);
#elif FORMAT_16_16
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                   ....... ATTENTION ........  The hard-coded constant 12.
                */
                LongFixsMul(stk_info.half_width_i, stroke_ctm[2], dest1);
                ux = LongFixsDiv((1L << 12), dest1);
                LongFixsMul(stk_info.half_width_i, stroke_ctm[3], dest1);
                uy = LongFixsDiv((1L << 12), dest1);
#elif FORMAT_28_4
                /* stk_info.half_width_i is in SFX format and stroke_ctm[2] is
                   in .12 format
                   ....... ATTENTION ........  The hard-coded constant 12.
                */
                LongFixsMul(stk_info.half_width_i, stroke_ctm[2], dest1);
                ux = LongFixsDiv((1L << 12), dest1);
                LongFixsMul(stk_info.half_width_i, stroke_ctm[3], dest1);
                uy = LongFixsDiv((1L << 12), dest1);
#endif
                rect1->vct_u.x = zero_f;          /* vector in user space */
                rect1->vct_u.y = stk_info.half_width;

        } else {
                lfix_t tmpc, tmpmc;     /* for more acuracy 1/5/89 */
                c = stk_info.half_width * (real32)sqrt(1 / (1 + m*m));
                mc = m * c;
                tmpc = F2LFX8_T(c);
                tmpmc = F2LFX8_T(mc);

                /* transform delta-vector(c, mc) to device space */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                */
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
#elif FORMAT_16_16
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
                The (16 - L_SHIFT) is for if LFX is not .16 format
                */
                ux = LFX2SFX(((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
                uy = LFX2SFX(((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
#elif FORMAT_28_4
                /* stroke_ctm[2] is in .12 format, tmpc and tmpmc are in .8 formats
                ux = LFX2SFX((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc);
                uy = LFX2SFX((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc);
                The (16 - L_SHIFT) is for if LFX is not .16 format
                */
                ux = LFX2SFX(((stroke_ctm[0]>>4)*tmpc +(stroke_ctm[2]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
                uy = LFX2SFX(((stroke_ctm[1]>>4)*tmpc +(stroke_ctm[3]>>4)*tmpmc)
                                 >> (16 - L_SHIFT));
#endif
                rect1->vct_u.x = c;      /* tmpc >> 1; vector in user space */
                rect1->vct_u.y = mc;     /* tmpmc >> 1; for check miter limit */
        }

        /* set clockwise direction */
        /* condition:
         *      (dx, dy) * (ux, uy) > 0,        *: cross product
         *
         *      =>   dx * uy - dy * ux > 0
         */
#ifdef FORMAT_13_3 /* @RESO_UPGR */
        if ((dx * uy) < (dy * ux)) {    /* reverse direction */
#elif FORMAT_16_16
        LongFixsMul(dx, uy, dest1);
        LongFixsMul(dy, ux, dest2);
        LongFixsSub(dest1, dest2, temp1);
        if (temp1[0] < 0) {
#elif FORMAT_28_4
        LongFixsMul(dx, uy, dest1);
        LongFixsMul(dy, ux, dest2);
        LongFixsSub(dest1, dest2, temp1);
        if (temp1[0] < 0) {
#endif
                ux = -ux;
                uy = -uy;
                rect1->vct_u.x = -rect1->vct_u.x;
                rect1->vct_u.y = -rect1->vct_u.y;
        }
        rect1->vct_d.x = ux;
        rect1->vct_d.y = uy;

        /* put in rect1 */
        rect1->pgn[0].x = rect1->p0.x + ux;
        rect1->pgn[0].y = rect1->p0.y + uy;
        rect1->pgn[1].x = rect1->p0.x - ux;
        rect1->pgn[1].y = rect1->p0.y - uy;
        rect1->pgn[2].x = rect1->p1.x - ux;
        rect1->pgn[2].y = rect1->p1.y - uy;
        rect1->pgn[3].x = rect1->p1.x + ux;
        rect1->pgn[3].y = rect1->p1.y + uy;

}

/***********************************************************************
 * Given a paint_flag and a polygon, this module creates a subpath of
 * the polygon and appends it to new_path, or clips it to clipping path
 * and paints it out.
 *
 * TITLE:       paint_or_save
 *
 * CALL:        paint_or_save (pgn);
 *
 * PARAMETERS:
 *              pgn
 *
 * INTERFACE:   Linetour
 *
 * CALLS:       Transform
 *              Convex_clipper
 *              Filler
 *
 * RETURN:
 **********************************************************************/
static void near paint_or_save (pgn)
struct coord FAR *pgn;          /*@WIN*/
{
        SP_IDX  subpath;
        fix     i;

        /* check infinitive number 10/24/88 */
        if(_status87() & PDL_CONDITION){
                /* do nothing for stroking infinitive coords */
                if (paint_flag) {
                        _clear87();
                        return;
                }

                for (i=0; i<4; i++) {
                        pgn[i].x = infinity_f;
                        pgn[i].y = infinity_f;
                }
                _clear87();
        }


        if (paint_flag) {
            bool    outpage = FALSE;
            struct  polygon_i ipgn;
            VX_IDX  head, tail, inode, ivtx, first_vertex;
            struct  nd_hdr  FAR *vtx;

            /* check if polygon inside the page */
            for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                    if (out_page(F2L(pgn[i].x)) ||     /* @OUT_PAGE */
                        out_page(F2L(pgn[i].y))) {     /* @TOUR */
                            outpage = TRUE;
                            break;
                    }
            }

            if (outpage) {

                /* transform polygon to subpath */
                inode = get_node();
                node_table[inode].VX_TYPE = MOVETO;        /* 2/9/88 */
                node_table[inode].VERTEX_X = pgn[0].x;  /* @TOUR */
                node_table[inode].VERTEX_Y = pgn[0].y;
                head = tail = inode;
                for (i=1; i<4; i++) {           /* pgn->size @TOUR */
                        inode = get_node();
                        node_table[inode].VX_TYPE = LINETO; /* 2/9/88 */
                        node_table[inode].VERTEX_X = pgn[i].x; /*@TOUR*/
                        node_table[inode].VERTEX_Y = pgn[i].y;
                        node_table[tail].next = inode;
                        tail = inode;
                }  /* for */
                node_table[tail].next = NULLP;

                /* clip to page boundary */
                first_vertex = page_clipper (head);
                if( ANY_ERROR() == LIMITCHECK ){
                        free_node(head);
                        return;
                }

                /* just return if the whole path has been clipped out */
                if (first_vertex == NULLP) {    /* 2/10/88 */
                        /* release temp. subpath */
                        free_node(head);
                        return;
                }


                /* transform clipped subpath to polygon */
                for (i=0, ivtx=first_vertex; ivtx!=NULLP;
                        i++, ivtx=vtx->next) {
                        vtx = &node_table[ivtx];
                        ipgn.p[i].x = F2SFX(vtx->VERTEX_X);     /* @RND */
                        ipgn.p[i].y = F2SFX(vtx->VERTEX_Y);
                }
                ipgn.size = (fix16)i;

                /* release temp. subpaths */
                free_node(head);
                free_node(first_vertex);

            } else {
                for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                        ipgn.p[i].x = F2SFX(pgn[i].x);          /* @RND */
                        ipgn.p[i].y = F2SFX(pgn[i].y);
                }
                ipgn.size = 4;

                /* check if totally inside clip region, then
                 * call pgn_reduction() directly 9/6/88
                 */
                if (GSptr->clip_path.single_rect) {
                    for (i=0; i<4; i++) {
                        if (ipgn.p[i].x < GSptr->clip_path.bb_lx) break;
                        else if (ipgn.p[i].x > GSptr->clip_path.bb_ux) break;

                        if (ipgn.p[i].y < GSptr->clip_path.bb_ly) break;
                        else if (ipgn.p[i].y > GSptr->clip_path.bb_uy) break;
                    } /* for */

                    if (i>=4) {
#ifdef DBG1
                        printf(" inside single rectangle clip\n");
#endif
                        pgn_reduction(&ipgn);
                        return;
                    } /* if i<4 */
                } /* if single_rect */

            } /* if outpage */

            /* clip and fill the polygon */
            convex_clipper(&ipgn, FALSE);
                            /* FALSE: the polygon is not a trapezoid */

        } else {
            /* Create a subpath */
            if ((subpath = subpath_gen(pgn)) == NULLP) {
                            ERROR(LIMITCHECK);
                            return;
            }

            /* Append subpath to new_path */
            if (new_path.head == NULLP)
                    new_path.head = subpath;
            else
                    /* node_table[new_path.tail].next = @NODE */
                    node_table[new_path.tail].SP_NEXT =
                    subpath;
            new_path.tail = subpath;
        }
}


/*
 * Integer operation version
 */
static void near paint_or_save_i (pgn)
struct coord_i FAR *pgn;    /* @WIN STK_INT */
{

        fix     i;
        struct  polygon_i ipgn;

        for (i=0; i<4; i++) {   /* pgn->size @TOUR */
                ipgn.p[i].x = pgn[i].x;                 /* @STK_INT */
                ipgn.p[i].y = pgn[i].y;
        }
        ipgn.size = 4;

        /* check if totally inside clip region, then
         * call pgn_reduction() directly 9/6/88
         */
        if (inside_clip_flag) {
#ifdef DBG1
                printf(" inside single rectangle clip\n");
#endif
                pgn_reduction(&ipgn);
                return;
        }

        if (GSptr->clip_path.single_rect) {
            for (i=0; i<4; i++) {
                if (ipgn.p[i].x < GSptr->clip_path.bb_lx) break;
                else if (ipgn.p[i].x > GSptr->clip_path.bb_ux) break;

                if (ipgn.p[i].y < GSptr->clip_path.bb_ly) break;
                else if (ipgn.p[i].y > GSptr->clip_path.bb_uy) break;
            } /* for */

            if (i>=4) {
#ifdef DBG1
                printf(" inside single rectangle clip\n");
#endif
                pgn_reduction(&ipgn);
                return;
            } /* if i<4 */
        } /* if single_rect */


        /* clip and fill the polygon */
        convex_clipper(&ipgn, FALSE);
                        /* FALSE: the polygon is not a trapezoid */

}



/***********************************************************************
 *
 * TITLE:       round_point
 *
 * CALL:        round_point (paint_flag, x, y)
 *
 * PARAMETERS:  paint_flag -- paint/save
 *              x, y -- coordinate of root
 *
 * INTERFACE:
 *
 * CALLS:
 *
 * RETURN:
 **********************************************************************/
static void near round_point(lx0, ly0)
long32 lx0, ly0;
{
        fix    dx_i, dy_i, width, heigh;
        real32  x0, y0;
        real32  dx, dy;
        /* struct  vx_lst *arc_vlist; @NODE */
        SP_IDX arc_vlist;
        VX_IDX ivtx;
        struct nd_hdr FAR *vtx, FAR *sp;
        SP_IDX subpath;
        real32 save_flat;

        x0   = L2F(lx0);
        y0   = L2F(ly0);

        /* check if circle has changed */
        if (stk_info.change_circle) {
                            /* stk_info.change_circle:
                             *   set by "init_stroke"
                             */
            /* set up control points of the circle */
            circle_ctl_points();

            /* clear stk_info.change_circle flag */
            stk_info.change_circle = FALSE;
        }

        /* paint a circle or save it due to paint_flag */
        if (paint_flag) {

            /* try to set circle in cache */
            if (circle_flag == CIR_UNSET_CACHE) {
                fix i, j;

                /* only for cache_to_page 12/23/88 */
                if (fill_destination == F_TO_CACHE) goto out_cache;

                /* bounding box of the circle */
                dx = curve[0][0].x;     /* init. */
                dy = curve[0][0].y;
                for (i=0; i<2; i++) {
                        for (j=0; j<3; j++) {
                                if (MAGN(curve[i][j].x) > MAGN(dx))
                                        dx = curve[i][j].x;
                                if (MAGN(curve[i][j].y) > MAGN(dy))
                                        dy = curve[i][j].y;
                        }
                }

                F2L(dx) = MAGN(dx);      /* absolute value */
                F2L(dy) = MAGN(dy);
                dx_i = ROUND(dx);
                dy_i = ROUND(dy);

                /* check if circle bitmap is too large to cache */
                if (dx*dy <= (real32)(CRC_SIZE * 8 / 4)) {
                                        /* dx*dx is 1/4 of the whole bitmap */

                        /* setup cache information of circle bitmap */
                        width = ALIGN_R(dx_i * 2) + 1;
                        heigh = (dy_i * 2) + 1;
                        cir_cache_info.ref_x = F2SFX(dx);
                        cir_cache_info.ref_y = F2SFX(dy);
                                                /* F2SFX should be consistent
                                                 * with getting of linewidth
                                                 * in init_stroke()
                                                 */

                        cir_cache_info.box_w = (fix16)width;
                        cir_cache_info.box_h = (fix16)heigh;
                        cir_cache_info.bitmap = CRC_BASE;

                        /* save old graphics state */
                        save_cache_info = cache_info;   /* cache information */
                        save_clip = GSptr->clip_path;   /* clip path */
                        save_dest = fill_destination;
#ifdef DBG1
                        printf("To build a circle cache, cache_info =\n");
                        printf("\tref_x=%d, ref_y=%d, box_w=%d, box_h=%d\n",
                               cir_cache_info.ref_x, cir_cache_info.ref_y,
                               cir_cache_info.box_w, cir_cache_info.box_h);
                        printf("\tbitmap=%lx\n", cir_cache_info.bitmap);
#endif
                        /* clear circle cache */
                        init_char_cache (&cir_cache_info);

                        /* set new graphics state for caching */
                        cache_info = &cir_cache_info;   /* cache information */
                        GSptr->clip_path.bb_ly = 0;     /* clip path */
                        GSptr->clip_path.bb_lx = 0;
                        GSptr->clip_path.bb_ux = I2SFX(width);
                        GSptr->clip_path.bb_uy = I2SFX(heigh);
                        GSptr->clip_path.single_rect = TRUE;
                        fill_destination = F_TO_CACHE;

                        /* build circle bitmap */
                        /* shrink circle 1 pixel for quality 1/12/89 */
                        dy += (real32)0.5;
                        dx += (real32)0.5;
                        curve[0][0].x -= (real32)0.5;
                        curve[0][0].y -= (real32)0.5;
                        curve[0][1].x -= (real32)0.5;
                        curve[0][1].y -= (real32)0.5;
                        curve[0][2].y -= (real32)0.5;

                        curve[1][0].x += (real32)0.5;
                        curve[1][0].y -= (real32)0.5;
                        curve[1][1].x += (real32)0.5;
                        curve[1][1].y -= (real32)0.5;
                        curve[1][2].x += (real32)0.5;

                        curve[2][0].x += (real32)0.5;
                        curve[2][0].y += (real32)0.5;
                        curve[2][1].x += (real32)0.5;
                        curve[2][1].y += (real32)0.5;
                        curve[2][2].y += (real32)0.5;

                        curve[3][0].x -= (real32)0.5;
                        curve[3][0].y += (real32)0.5;
                        curve[3][1].x -= (real32)0.5;
                        curve[3][1].y += (real32)0.5;
                        curve[3][2].x -= (real32)0.5;

                        arc_vlist = circle_list (F2L(dx), F2L(dy));
                        if( ANY_ERROR() == LIMITCHECK ) return;

                        /* create a subpath consists of arc_vlist for
                         * shape_approxiamtion
                         */
                        /* subpath = vlist_to_subp (arc_vlist); @NODE */
                        subpath = arc_vlist;

                        if( ANY_ERROR() == LIMITCHECK ) return;
                        sp = &node_table[subpath];
                        sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */

                        /* initialize edge table 11/30/88 */
                        init_edgetable();       /* in "shape.c" */

                        /* adjust flatness for smoothing the circle 5/9/89 */
                        save_flat = GSptr->flatness;
                        GSptr->flatness *= (real32)0.7;

                        shape_approximation (subpath, (fix *)NULLP);

                        /* restore flatness 5/9/89 */
                        GSptr->flatness = save_flat;

                        if(ANY_ERROR() == LIMITCHECK){ /* out of edge table */
                                 return;                        /* 4/17/91 */
                        }

                        shape_reduction (NON_ZERO);

                        if(ANY_ERROR() == LIMITCHECK){ /* out of scany_table */
                                 return;               /* 05/07/91, Peter */
                        }

                        /* restore graphics state */
                        GSptr->clip_path = save_clip;
                        fill_destination = save_dest;
                                        /* cache_info will be restored at end
                                         * of stroke command
                                         */
                        /* free the curve circle */
                        /* free_node (sp->SP_HEAD); @NODE */
                        free_node (subpath);

                        /* now cicle bitmap is in cache */
                        circle_flag = CIR_IN_CACHE;

                } else {        /* circle too big to cache */
out_cache:
                        circle_flag = CIR_OUT_CACHE;

                        /* create a list of circle consists of curves */
                        arc_vlist = circle_list (lx0, ly0);
                        if( ANY_ERROR() == LIMITCHECK ) return;

                        /* set up a flattened circle as a pattern for stroke */
                        flatten_circle (arc_vlist);
                                /* the flattened circle been set up in
                                 * circle_sp and circle_bbox @STK_INFO
                                 * arc_vlist was freed
                                 */

                        /* free the curve circle @STK_INFO */
                        /* free_node (arc_vlist->head);
                         *                (* be freed in flatten_circle() *)
                         *                10/12/88
                         */

                        /* keep root of the circle */
                        circle_root.x = x0;
                        circle_root.y = y0;
                }

            } /* if circle_flag == CIR_UNSET_CACHE */

            if (circle_flag == CIR_IN_CACHE) {

                GSptr->position.x = x0;
                GSptr->position.y = y0;
                fill_shape (NON_ZERO, F_FROM_CRC, F_TO_PAGE);

            } else {

                /* get the new circle by adding offset from circle
                 * pattern
                 */
                sp = &node_table[circle_sp];

                /* offset */
                dx = x0 - circle_root.x;
                dy = y0 - circle_root.y;

                /* for (ivtx = sp->SP_HEAD; ivtx!=NULLP; @NODE */
                for (ivtx = circle_sp; ivtx!=NULLP;
                     ivtx = vtx->next) {
                        vtx = &node_table[ivtx];
                        /* set sp_flag @SP_FLG */
                        vtx->VERTEX_X += dx;
                        vtx->VERTEX_Y += dy;
                }

                /* modify root coord of the circle @TOUR */
                circle_root.x = x0;
                circle_root.y = y0;

                /* update the bounding box */
                circle_bbox[0] += dx;
                circle_bbox[1] += dy;
                circle_bbox[2] += dx;
                circle_bbox[3] += dy;

                /* check if the circle is outside the page boundary */
                if (too_small(F2L(circle_bbox[0])) ||   /* @OUT_PAGE */
                    too_small(F2L(circle_bbox[1])) ||
                    too_large(F2L(circle_bbox[2])) ||
                    too_large(F2L(circle_bbox[3])))
                        node_table[circle_sp].SP_FLAG |= SP_OUTPAGE;

                /* initialize edge table 11/30/88 */
                init_edgetable();       /* in "shape.c" */

                shape_approximation (circle_sp, (fix *)NULLP);
                if(ANY_ERROR() == LIMITCHECK){  /* out of edge table; 4/17/91 */
                       return;
                }
                shape_reduction (NON_ZERO);
                                /* should not free circle_sp */
            } /* if circle_flag */



        } else { /* save */

            /* save the circle in new_path */
            /* Create an arc at the join point */
            arc_vlist = circle_list (lx0, ly0);
            if( ANY_ERROR() == LIMITCHECK ) return;

            /* create a subpath consists of arc_vlist */
            /* subpath = vlist_to_subp (arc_vlist); @NODE */
            subpath = arc_vlist;
            if( ANY_ERROR() == LIMITCHECK ) return;

            sp = &node_table[subpath];
            /* set sp_flag @SP_FLG 1/8/88 */
            sp->SP_FLAG |= SP_CURVE;        /* set CURVE flag */
            sp->SP_FLAG &= ~SP_OUTPAGE;     /* init. in page */
            /* for (ivtx = sp->SP_HEAD; ivtx!=NULLP; @NODE */
            for (ivtx = subpath; ivtx!=NULLP; /* check OUTPAGE flag */
                 ivtx = vtx->next) {
                    vtx = &node_table[ivtx];

                    /* break if closepath node 9/07/88 */
                    if (vtx->VX_TYPE == CLOSEPATH) break;

                    /* set sp_flag @SP_FLG */
                    if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                        out_page(F2L(vtx->VERTEX_Y))) {
                            sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
#ifdef DBG1
                            printf("Outpage\n");
                            dump_all_path (subpath);
#endif
                            break;                  /* 1/29/88 */
                    }
            }


            /* Append the subpath to new_path */
            if (new_path.head == NULLP)
                    new_path.head = subpath;
            else
                    /* node_table[new_path.tail].next = subpath; @NODE */
                    node_table[new_path.tail].SP_NEXT = subpath;
            new_path.tail = subpath;

        }
}





/*
 * setup control points of a circle
 */
static void near circle_ctl_points()
{
        real32 h0, h1, h2, h3, c0, c1, c2, c3;
        real32  ctl_pnt_width;  /* @STK_INFO */

        ctl_pnt_width = (real32)0.5522847 * stk_info.half_width;
                        /* 0.5522847 = 4 / 3 * (sqrt(2) -1) */

        /* set up control points of curvetoes: in device space
         *
         *                   +--------+--------+         y1
         *                  /         |         \
         *                /           |           \
         *               /            |            \
         *              +             |              +   y2
         *              |             |              |
         *              +-------------+--------------+   y0
         *              |             |              |
         *              +             |              +   y4
         *               \            |             /
         *                \           |            /
         *                  \         |          /
         *                    +-------+---------+        y3
         *
         *             x3     x4      x0        x2   x1
         */
        /* 12 control point vectors: in user space => device space
         *      ( h,  0)       -( h,  0)
         *      ( h, -c)       -( h, -c)
         *      ( c, -h)       -( c, -h)
         *      ( 0, -h)       -( 0, -h)
         *      (-c, -h)       -(-c, -h)
         *      (-h, -c)       -(-h, -c)
         */

        h0 = stk_info.half_width * GSptr->ctm[0];
        h1 = stk_info.half_width * GSptr->ctm[1];
        h2 = stk_info.half_width * GSptr->ctm[2];
        h3 = stk_info.half_width * GSptr->ctm[3];
        c0 = ctl_pnt_width * GSptr->ctm[0];
        c1 = ctl_pnt_width * GSptr->ctm[1];
        c2 = ctl_pnt_width * GSptr->ctm[2];
        c3 = ctl_pnt_width * GSptr->ctm[3];

        /* for clockwise direction */
        if (ctm_flag & LEFT_HAND_CTM) {         /* @STKDIR */
/*              curve[0][0].x =  h0 - c1;     curve[0][0].y =  h2 - c3;
                curve[0][1].x =  c0 - h1;     curve[0][1].y =  c2 - h3;
                curve[0][2].x =      -h1;     curve[0][2].y =      -h3;

                curve[1][0].x = -c0 - h1;     curve[1][0].y = -c2 - h3;
                curve[1][1].x = -h0 - c1;     curve[1][1].y = -h2 - c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h2     ;

                curve[2][0].x = -h0 + c1;     curve[2][0].y = -h2 + c3;
                curve[2][1].x = -c0 + h1;     curve[2][1].y = -c2 + h3;
                curve[2][2].x =       h1;     curve[2][2].y =       h3;

                curve[3][0].x =  c0 + h1;     curve[3][0].y =  c2 + h3;
                curve[3][1].x =  h0 + c1;     curve[3][1].y =  h2 + c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h2     ;*/

                /* user space => device space, - begin -, 2-4-91 */
                curve[0][0].x =  h0 - c2;     curve[0][0].y =  h1 - c3;
                curve[0][1].x =  c0 - h2;     curve[0][1].y =  c1 - h3;
                curve[0][2].x =      -h2;     curve[0][2].y =      -h3;

                curve[1][0].x = -c0 - h2;     curve[1][0].y = -c1 - h3;
                curve[1][1].x = -h0 - c2;     curve[1][1].y = -h1 - c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h1     ;

                curve[2][0].x = -h0 + c2;     curve[2][0].y = -h1 + c3;
                curve[2][1].x = -c0 + h2;     curve[2][1].y = -c1 + h3;
                curve[2][2].x =       h2;     curve[2][2].y =       h3;

                curve[3][0].x =  c0 + h2;     curve[3][0].y =  c1 + h3;
                curve[3][1].x =  h0 + c2;     curve[3][1].y =  h1 + c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h1     ;
                /* user space => device space, - end -, 2-4-91 */
        } else {
/*              curve[0][0].x =  h0 + c1;     curve[0][0].y =  h2 + c3;
                curve[0][1].x =  c0 + h1;     curve[0][1].y =  c2 + h3;
                curve[0][2].x =       h1;     curve[0][2].y =       h3;

                curve[1][0].x = -c0 + h1;     curve[1][0].y = -c2 + h3;
                curve[1][1].x = -h0 + c1;     curve[1][1].y = -h2 + c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h2     ;

                curve[2][0].x = -h0 - c1;     curve[2][0].y = -h2 - c3;
                curve[2][1].x = -c0 - h1;     curve[2][1].y = -c2 - h3;
                curve[2][2].x =      -h1;     curve[2][2].y =      -h3;

                curve[3][0].x =  c0 - h1;     curve[3][0].y =  c2 - h3;
                curve[3][1].x =  h0 - c1;     curve[3][1].y =  h2 - c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h2     ;*/

                /* user space => device space, - begin -, 2-4-91 */
                curve[0][0].x =  h0 + c2;     curve[0][0].y =  h1 + c3;
                curve[0][1].x =  c0 + h2;     curve[0][1].y =  c1 + h3;
                curve[0][2].x =       h2;     curve[0][2].y =       h3;

                curve[1][0].x = -c0 + h2;     curve[1][0].y = -c1 + h3;
                curve[1][1].x = -h0 + c2;     curve[1][1].y = -h1 + c3;
                curve[1][2].x = -h0     ;     curve[1][2].y = -h1     ;

                curve[2][0].x = -h0 - c2;     curve[2][0].y = -h1 - c3;
                curve[2][1].x = -c0 - h2;     curve[2][1].y = -c1 - h3;
                curve[2][2].x =      -h2;     curve[2][2].y =      -h3;

                curve[3][0].x =  c0 - h2;     curve[3][0].y =  c1 - h3;
                curve[3][1].x =  h0 - c2;     curve[3][1].y =  h1 - c3;
                curve[3][2].x =  h0     ;     curve[3][2].y =  h1     ;
                /* user space => device space, - end -, 2-4-91 */
        }

#ifdef DBG1
        {
                fix     i, j;
                printf("circle_ctl_points():\n");
                for (i=0; i<4; i++) {
                        printf("curve[%d] = ", i);
                        for (j=0; j<3; j++) {
                            printf("  (%f, %f)", curve[i][j].x, curve[i][j].y);
                        }
                        printf("\n");
                }

        }
#endif

}



/* static struct vx_lst * near circle_list(lx0, ly0) @NODE */
static SP_IDX near circle_list(lx0, ly0)
long32 lx0, ly0;
{
        fix    i, bz;
        real32  x0, y0;
        /* static struct vx_lst ret_list; @NODE */
        SP_IDX ret_list;                /* return data; should be static
                                         * otherwise, it will be erased
                                         * after returns
                                         */
        VX_IDX  ivtx;
        struct nd_hdr FAR *vtx;
        VX_IDX tail;            /* @NODE */

        x0   = L2F(lx0);
        y0   = L2F(ly0);

        /* ret_list.head = ret_list.tail = NULLP; @NODE */
        ret_list = tail = NULLP;
        /*
         * Create a MOVETO node
         */
        /* Allocate a node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                /* return (&ret_list); @NODE */
                return (ret_list);
        }
        vtx = &node_table[ivtx];

        /* Set up a MOVETO node */
        vtx->VX_TYPE = MOVETO;
        /* ret_list.head = ret_list.tail = ivtx; @NODE */
        ret_list = tail = ivtx;

        vtx->VERTEX_X = x0 + curve[3][2].x;
        vtx->VERTEX_Y = y0 + curve[3][2].y;

        /* loop to generate 4 bezier curvetoes */
        for (bz = 0; bz < 4; bz++) {

            /* loop to create 3 CURVETO nodes */
            for (i=0; i<3; i++) {
                    /*
                     * Create a CURVETO node
                     */
                    /* Allocate a node */
                    ivtx = get_node();
                    if(ivtx == NULLP) {
                            ERROR(LIMITCHECK);

                            /* @NODE
                             * free_node (ret_list.head);
                             * ret_list.head = ret_list.tail = NULLP;
                             * return (&ret_list);
                             */
                            free_node (ret_list);
                            ret_list = NULLP;
                            return (ret_list);
                    }
                    vtx = &node_table[ivtx];

                    /* Set up a CURVETO node */
                    vtx->VX_TYPE = CURVETO;
                    vtx->next = NULLP;

                    vtx->VERTEX_X = x0 + curve[bz][i].x;
                    vtx->VERTEX_Y = y0 + curve[bz][i].y;

                    /* Append this node to bezier_list */
                    /* @NODE
                     * node_table[ret_list.tail].next = ivtx;
                     * ret_list.tail = ivtx;
                     */
                    node_table[tail].next = ivtx;
                    tail = ivtx;

            } /* for i */
        } /* for bz */

        /* return (&ret_list); @NODE */
        node_table[ret_list].SP_TAIL = tail;    /* @NODE */
        node_table[ret_list].SP_NEXT = NULLP;   /* @NODE */
        node_table[ret_list].SP_FLAG = SP_CURVE;/* @NODE */
        return (ret_list);                      /* @NODE */

}

static void near flatten_circle (arc_vlist)
/* struct vx_lst *arc_vlist; @NODE */
SP_IDX arc_vlist;
{
        /* struct vx_lst *flt_vlist; @NODE */
        SP_IDX flt_vlist;
        VX_IDX ivtx;
        struct nd_hdr FAR *vtx;

        /*  free old subpath of circle for round join & cap @STK_INFO */
        if (circle_sp != NULLP) {
                /* free_node (node_table[circle_sp].SP_HEAD); @NODE */
                free_node (circle_sp);
        }

        /* @NODE
         * (* allocate a subpath header    @TRVSE *)
         * circle_sp = get_node();
         * if(circle_sp == NULLP) {
         *         ERROR(LIMITCHECK);
         *         return;
         * }
         * node_table[circle_sp].next = NULLP;
         * node_table[circle_sp].SP_HEAD = arc_vlist->head;
         * node_table[circle_sp].SP_TAIL = arc_vlist->tail;
         * node_table[circle_sp].SP_FLAG = SP_CURVE; (* 10/12/88 *)
         */
        circle_sp = arc_vlist;
        node_table[circle_sp].SP_FLAG = SP_CURVE; /* 10/12/88 */

#ifdef DBG1
        printf("flatten_circle():\nOrig. circle_sp =\n");
        dump_all_path (circle_sp);
#endif
        /* calculate the bounding_box of the circle
         */
        /* initialize bounding_box */
        circle_bbox[0] = (real32)EMAXP;
        circle_bbox[1] = (real32)EMAXP;
        circle_bbox[2] = (real32)EMINN;
        circle_bbox[3] = (real32)EMINN;
//      bounding_box (circle_sp, (real32 far *)circle_bbox);    @C6.0
        bounding_box (circle_sp, (real32     *)circle_bbox);
                        /* may place after flattened for more
                         * accurate
                         */

        /*
         * flatten the circle:
         * if the radius is too large then just treat the control
         * points of the curves as lineto points and does not
         * need to flatten it. @BIG_CIR
         */
        if (stk_info.half_width > (real32)4096.0) {
                                /* 4096: any larger number, tunable */
            /* change curveto nodes to lineto nodes in the circle */
            /* for (ivtx = arc_vlist->head; ivtx != NULLP; @NODE */
            for (ivtx = circle_sp; ivtx != NULLP;
                    ivtx = vtx->next) {
                    vtx = &node_table[ivtx];

                    if (vtx->VX_TYPE == CURVETO)
                            vtx->VX_TYPE = LINETO;
            } /* for */

            /* set outpage flag 10/12/88 */
            node_table[circle_sp].SP_FLAG |= SP_OUTPAGE;    /* outside page */

        } else {
            /* flatten the circle @CIR_FLAT*/
            /* flt_vlist = flatten_subpath(node_table[circle_sp].SP_HEAD,@NODE*/
            flt_vlist = flatten_subpath (circle_sp,
                    F2L(GSptr->flatness)); /* use current flatness */

            if( ANY_ERROR() == LIMITCHECK ){
                    /* free_node (arc_vlist->head); @NODE */
                    free_node (circle_sp);
                    circle_sp = NULLP;          /* @NODE */
                    return;
            }

            /* @NODE
             * free the curve circle, only need to save flattened
             * circle
             *
             * free_node (arc_vlist->head);
             *
             * arc_vlist->head = flt_vlist->head;  (* 11/09/88 *)
             * arc_vlist->tail = flt_vlist->tail;
             */
            free_node (circle_sp);                              /* @NODE */
            circle_sp = flt_vlist;  /* 11/09/88 */              /* @NODE */
        }

        /* save the flattened circle
         */
        /* use the previous subpath header */
        /* @NODE
         * node_table[circle_sp].next = NULLP;
         * node_table[circle_sp].SP_HEAD = arc_vlist->head;     (* 11/09/88 *)
         * node_table[circle_sp].SP_TAIL = arc_vlist->tail;     (* 11/09/88 *)
         * node_table[circle_sp].SP_FLAG &= ~SP_CURVE;
         */
        node_table[circle_sp].SP_FLAG &= ~SP_CURVE;         /* @NODE */

#ifdef DBG1
        printf("Flattened circle_sp =\n");
        dump_all_path (circle_sp);
#endif

}


/***********************************************************************
 * Given a polygon, this module generates a subpath of the polygon.
 *
 * TITLE:       subpath_gen
 *
 * CALL:        subpath_gen(pgn)
 *
 * PARAMETERS:  polygon -- a quadrangle contains 4 coordinates
 *
 * INTERFACE:
 *
 * CALLS:       get_node
 *
 * RETURN:      subpath -- index of node_table contains a subpath
 *              NULLP   -- fail (no more nodes to generate subpath)
 **********************************************************************/
static SP_IDX near subpath_gen(pgn)
struct coord FAR *pgn;                  /*@WIN*/
{
        struct nd_hdr FAR *sp, FAR *vtx;
        SP_IDX isp;
        VX_IDX ivtx;
        fix    i;

        /* @NODE
         * (* subpath header *)
         * if((isp = get_node()) == NULLP){
         *         ERROR(LIMITCHECK);
         *         return(NULLP);
         * }
         * sp = &node_table[isp];
         * sp->next = NULLP;
         * sp->SP_FLAG = FALSE;    (* initialization 1/19/88 *)
         */

        /* create MOVETO node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                /* free_node (isp); @NODE */
                return(NULLP);
        }
        vtx = &node_table[ivtx];

        vtx->VX_TYPE = MOVETO;
        vtx->next = NULLP;
        vtx->VERTEX_X = pgn[0].x;       /* @TOUR */
        vtx->VERTEX_Y = pgn[0].y;

        /* initialize list @NODE */
        isp = ivtx;
        sp = vtx;
        sp->SP_NEXT = NULLP;
        sp->SP_FLAG = FALSE;    /* initialization 1/19/88 */

        /* set sp_flag @SP_FLG 1/19/88 */
        if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
            out_page(F2L(vtx->VERTEX_Y))) {
                sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
        }

        /* sp->SP_HEAD = ivtx; @NODE */
        sp->SP_TAIL = ivtx;

        /* loop to create LINETO nodes */
        for(i = 1; i < 4; i++) {                /* pgn->size @TOUR */
                if((ivtx = get_node()) == NULLP) {
                        ERROR(LIMITCHECK);
                        free_node (isp);
                        /* free_node (sp->SP_HEAD); @NODE */
                        return(NULLP);
                }
                vtx = &node_table[ivtx];

                vtx->VX_TYPE = LINETO;
                vtx->next = NULLP;
                vtx->VERTEX_X = pgn[i].x;       /* @TOUR */
                vtx->VERTEX_Y = pgn[i].y;

                /* set sp_flag @SP_FLG */
                if (out_page(F2L(vtx->VERTEX_X)) ||     /* @OUT_PAGE */
                    out_page(F2L(vtx->VERTEX_Y))) {
                        sp->SP_FLAG |= SP_OUTPAGE;    /* outside page */
                }

                node_table[sp->SP_TAIL].next = ivtx;
                sp->SP_TAIL = ivtx;
        }

        /* create a CLOSEPATH node */
        if((ivtx = get_node()) == NULLP) {
                ERROR(LIMITCHECK);
                free_node (isp);
                /* free_node (sp->SP_HEAD); @NODE */
                return(NULLP);
        }
        vtx = &node_table[ivtx];

        vtx->VX_TYPE = CLOSEPATH;
        vtx->next = NULLP;

        node_table[sp->SP_TAIL].next = ivtx;
        sp->SP_TAIL = ivtx;

        return(isp);

}

#ifdef  _AM29K
static void near
dummy()
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\2eq.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              2EQ.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * 7/13/90 ; ccteng ; add fontnotfound in op_findfont
 * 8/8/90 ; scchen ; changed op_findfont(): added substitutefont feature
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <string.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geierr.h"
#include    "language.h"
#include    "user.h"
#include    "file.h"

#ifdef LINT_ARGS
static bool near typeprint(struct object_def) ;
static void near tprint(byte FAR *, ufix) ;
static void near one_typeprint(void) ;
#else
static bool near typeprint() ;
static void near tprint() ;
static void near one_typeprint() ;
#endif /* LINT_ARGS */

static  ufix16 near cp, tp_depth ;

/************************************
 *  two_equal
 ************************************/
fix
two_equal()
{
    struct object_def   l_obj ;

    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    tp_depth = 0 ;
    cp = 0 ;

    if(! typeprint(l_obj)) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        POP(1) ;
    }

    return(0) ;
}   /* two_equal */

/************************************
 *  tprint
 ************************************/
static void near
tprint(p_str, p_len)
byte    FAR *p_str ;
ufix    p_len ;
{
    ufix16  tcp ;

    tcp = cp ;
    cp += (ufix16)p_len ;
    if(cp >= 80) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        GEIio_write(GEIio_stdout, p_str, 80 - tcp) ;
        p_str += (80 - tcp) ;
        cp -= 80 ;
        while(cp/80) {
            GEIio_write(GEIio_stdout, p_str, 80) ;
            p_str += 80 ;
            cp -= 80 ;
        }
        GEIio_write(GEIio_stdout, p_str, cp) ;
        GEIio_write(GEIio_stdout, "\n", 1) ;
    } else
        GEIio_write(GEIio_stdout, p_str, p_len) ;

    return ;
}   /* tprint */

/************************************
 *  typeprint
 ************************************/
static bool near
typeprint(p_obj)
struct object_def p_obj ;
{
    fix     l_i ;
    ufix16  l_type ;
    byte    FAR *l_str, l_buffer[30] ;
    real64  l_double ;
    struct  object_def  l_anyobj ;
    union   four_byte   l_num ;

    if(++tp_depth > 100) {
        ERROR(LIMITCHECK) ;
        return(1) ;
    }

    l_type = TYPE(&p_obj) ;
    switch(l_type) {
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            if( ACCESS(&p_obj) <= READONLY ) {
                if( ATTRIBUTE(&p_obj) == EXECUTABLE ) {
                    tprint("{", 1) ;
                    for(l_i=0 ; (ufix)l_i < LENGTH(&p_obj) ; l_i++) { //@WIN
                        get_array(&p_obj, l_i, &l_anyobj) ;
                        if(typeprint(l_anyobj))
                            return(1) ;
                        else
                            tp_depth-- ;
                    }   /* for(l_i) */
                    tprint("}", 1) ;
                } else {
                    tprint("[", 1) ;
                    for(l_i=0 ; (ufix)l_i < LENGTH(&p_obj) ; l_i++) { //@WIN
                        get_array(&p_obj, l_i, &l_anyobj) ;
                        if(typeprint(l_anyobj))
                            return(1) ;
                        else
                            tp_depth-- ;
                    }   /* for(l_i) */
                    tprint("]", 1) ;
                }
                return(0) ;
            }   /* access */
            else {
                if(l_type == ARRAYTYPE)
                    l_str = "-array-" ;
                else
                    l_str = "-packedarray-" ;
            }
            break ;

        case BOOLEANTYPE:
            if(VALUE(&p_obj) == TRUE)
                l_str = "true" ;
            else
                l_str = "false" ;
            break ;

        case DICTIONARYTYPE:
            l_str = "-dictionary-" ;
            break ;

        case FILETYPE:
            l_str = "-filestream-" ;
            break ;

        case FONTIDTYPE:
            l_str = "-fontid-" ;
            break ;

        case INTEGERTYPE:
            l_str = (byte FAR *)ltoa( (fix32)VALUE(&p_obj),
                                      (char FAR *)l_buffer, 10) ;  /*@WIN*/
            break ;

        case MARKTYPE:
            l_str = "-mark-" ;
            break ;

        case NAMETYPE:
            l_i = (fix)VALUE(&p_obj) ;
            l_str = name_table[l_i]->text ;
            if(ATTRIBUTE(&p_obj) != EXECUTABLE)
                tprint("/", 1) ;
            tprint(l_str, name_table[l_i]->name_len) ;
            tprint(" ", 1) ;
            return(0) ;

        case NULLTYPE:
            l_str = "-null-" ;
            break ;

        case OPERATORTYPE:
            l_i = LENGTH(&p_obj) ;
/* qqq, begin */
            /*
            switch( ROM_RAM(&p_obj) ) {
                case RAM:
                    l_str = systemdict_table[l_i].key ;
                    break ;

                case ROM:
                    l_str = oper_table[l_i].name ;
                    break ;

                default:
                    l_str = "Error: OPERATORTYPE" ;
            }   |* switch *|
            */
            l_str = systemdict_table[l_i].key ;
/* qqq, end */

            tprint("--", 2) ;
            tprint(l_str, lstrlen(l_str)) ;     /* @WIN */
            tprint("--", 2) ;
            return(0) ;

        case REALTYPE:
            l_num.ll = (fix32)VALUE(&p_obj) ;
            if(l_num.ll == INFINITY)
                l_str = "Infinity.0" ;
            else {
                l_double = l_num.ff ;
                l_str = (byte FAR *)gcvt(l_double, 6, (byte FAR *)l_buffer) ;
            }
            break ;

        case SAVETYPE:
            l_str = "-savelevel-" ;
            break ;

        case STRINGTYPE:
            if( ACCESS(&p_obj) <= READONLY ) {
                tprint("(", 1) ;
                l_str = (byte FAR *)VALUE(&p_obj) ;
                if( LENGTH(&p_obj) )
                    tprint(l_str, LENGTH(&p_obj)) ;
                tprint(")", 1) ;
                return(0) ;
            }
            else
                l_str = "-string-" ;
            break ;

        default:
            l_str = "%%[ Error: in typeprint ]%%" ;
    }   /* switch */

    tprint(l_str, lstrlen(l_str)) ;     /* @WIN */
    tprint(" ", 1) ;

    return(0) ;
}   /* typeprint */

/************************************
 *  op_pstack
 ************************************/
fix
op_pstack()
{
    fix     l_i ;
    struct  object_def  l_anyobj ;

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* copy and print out the content of operand stack from top most */
    for(l_i=0 ; (ufix)l_i < COUNT() ; l_i++) {          //@WIN
        COPY_OBJ(GET_OPERAND(l_i), &l_anyobj) ;
        PUSH_OBJ(&l_anyobj) ;
        two_equal() ;
    }   /* for */

    return(0) ;
}   /* op_pstack */

/************************************
 *  one_equal
 ************************************/
fix
one_equal()
{
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    one_typeprint() ;

    if( ! ANY_ERROR() ) {
        GEIio_write(GEIio_stdout, "\n", 1) ;
        POP(1) ;
    }

    return(0) ;
}   /* one_equal */

/************************************
 *  one_typeprint
 ************************************/
static void near
one_typeprint()
{
    fix     l_i ;
    ufix16  l_type ;
    byte    FAR *l_str, l_buffer[30] ;
    real64  l_double ;
    union   four_byte   l_num ;

    l_type = TYPE_OP(0) ;
    switch(l_type) {
        case STRINGTYPE:
            if( ACCESS_OP(0) <= READONLY ) {
                l_str = (byte FAR *)VALUE_OP(0) ;
                GEIio_write(GEIio_stdout, l_str, LENGTH_OP(0)) ;
            } else
                ERROR(INVALIDACCESS) ;
            return ;

        case BOOLEANTYPE:
            if(VALUE_OP(0) == TRUE)
                l_str = "true" ;
            else
                l_str = "false" ;
            break ;

        case INTEGERTYPE:
            l_str = (byte FAR *)ltoa( (fix32)VALUE_OP(0),
                                      (char FAR *)l_buffer, 10) ;    /*@WIN*/
            break ;

        case NAMETYPE:
            l_i = (fix)VALUE_OP(0) ;
            l_str = name_table[l_i]->text ;
            GEIio_write(GEIio_stdout, l_str, name_table[l_i]->name_len) ;
            return ;

        case OPERATORTYPE:
            l_i = LENGTH_OP(0) ;
/* qqq, begin */
            /*
            switch( ROM_RAM_OP(0) ) {
                case RAM:
                    l_str = systemdict_table[l_i].key ;
                    break ;

                case ROM:
                    l_str = oper_table[l_i].name ;
                    break ;

                default:
                    l_str = "Error: OPERATORTYPE" ;
            }   |* switch *|
            */
            l_str = systemdict_table[l_i].key ;
/* qqq, end */
            break ;

        case REALTYPE:
            l_num.ll = (fix32)VALUE_OP(0) ;
            if(l_num.ll == INFINITY)
                l_str = "Infinity.0" ;
            else {
                l_double = l_num.ff ;
                l_str = (byte FAR *)gcvt(l_double, 6, (byte FAR *)l_buffer) ;
            }
            break ;

        default:
            l_str = "--nostringval--" ;
    }   /* switch */

    GEIio_write(GEIio_stdout, l_str, lstrlen(l_str)) ;          /* @WIN */

    return ;
}   /* one_typeprint */

/************************************
 *  op_stack
 ************************************/
fix
op_stack()
{
    fix     l_i ;
    struct  object_def  l_anyobj ;

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* copy and print out the content of operand stack from top most */
    for(l_i=0 ; (ufix)l_i < COUNT() ; l_i++) {          //@WIN
        COPY_OBJ(GET_OPERAND(l_i), &l_anyobj) ;
        PUSH_OBJ(&l_anyobj) ;
        one_equal() ;
    }   /* for */

    return(0) ;
}   /* op_stack */

/************************************
 *  one_equal_print
 ************************************/
fix
one_equal_print()
{
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    /* without a new line */
    one_typeprint() ;

    if( ! ANY_ERROR() )
        POP(1) ;

    return(0) ;
}   /* one_equal_print */

/************************************
 *  op_findfont
 ************************************/
fix
op_findfont()
{
    struct  object_def  FAR *l_fontdir, FAR *l_fontdict ;
    struct  object_def  l_newfont, FAR *l_tmpobj ;

    l_newfont.bitfield = 0;     /*@WIN; add for init*/
    /* push FontDirectory on the operand stack */
    get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir) ;

#ifdef FIND_SUB
    {
    struct  object_def  str_obj, key_obj ;
    ufix32  key_idx ;
    char    string1[80], string2[80] ;
    char    FAR *string ;

    COPY_OBJ(GET_OPERAND(0), &key_obj) ;
    POP(1) ;

    /* check if font name was found */
    if ( !get_dict(l_fontdir, &key_obj, &l_fontdict) ) {

        /* do open_file and using selectfont */
        /* AppendName */
        key_idx = VALUE(&key_obj) ;
        string = (byte FAR *)alloc_vm((ufix32)80) ;
        memcpy(string2, name_table[(fix)key_idx]->text,
                        name_table[(fix)key_idx]->name_len) ;
        string2[name_table[(fix)key_idx]->name_len] = '\0' ;
        lstrcpy(string, (char FAR *)"fonts/") ;         /* @WIN */
        strcat(string, string2) ;

        /* put file name into operandstack */
        TYPE_SET(&str_obj, STRINGTYPE) ;
        ACCESS_SET(&str_obj, UNLIMITED) ;
        ATTRIBUTE_SET(&str_obj, LITERAL) ;
        ROM_RAM_SET(&str_obj, RAM) ;
        LEVEL_SET(&str_obj, current_save_level) ;
        LENGTH(&str_obj) = lstrlen(string) ;            /* @WIN */
        VALUE(&str_obj) = (ufix32)string ;
        PUSH_OBJ(&str_obj) ;

        /* run disk file 'fonts/XXX' */
        op_run() ;
        if (ANY_ERROR()){      /* if file not found */
            if (ANY_ERROR() != UNDEFINEDFILENAME)
                return(0) ;
            CLEAR_ERROR() ;
            POP(1) ;            /* pop the file name */

           /* not found, using subsitute font */
            PUSH_OBJ(&key_obj) ;
            st_selectsubstitutefont() ;   /* call font_op5.c of msfont */

            key_idx = VALUE(GET_OPERAND(0)) ;
            memcpy(string1, name_table[(fix)key_idx]->text,
                            name_table[(fix)key_idx]->name_len) ;
            string1[name_table[(fix)key_idx]->name_len] = '\0' ;
            get_dict_value(FONTDIRECTORY, string1, &l_fontdict) ;
            POP(1) ;

            GEIio_write(GEIio_stdout, string2, lstrlen(string2)) ; /* @WIN */
            GEIio_write(GEIio_stdout, " not found, using ", (fix)18) ;
            GEIio_write(GEIio_stdout, string1, lstrlen(string1)) ; /* @WIN */
            GEIio_write(GEIio_stdout, ".\n", (fix)2) ;
            op_flush() ;
         }    /* if -- any error */
         else {
             /* Disk font is found & executed */
             /* get the font name from fontdirectory */
             if( !get_dict(l_fontdir, &key_obj, &l_fontdict) ){
                 PUSH_OBJ(&key_obj) ;
                 ERROR(UNDEFINED) ;
                 return(0) ;
             }
             if (COUNT() > 0)    POP(1) ;
             else {
                 ERROR(STACKUNDERFLOW) ;
                 return(0) ;
             }
         }  /* else --any error */
    }       /* fontname not found in FontDirectory  */

    /* push the font dictionary */
    PUSH_ORIGLEVEL_OBJ(l_fontdict) ;
    return(0) ;
    }
}
#else
    /* check if font name was found */
    if ( get_dict(l_fontdir, GET_OPERAND(0), &l_fontdict) ) {
        /* found */
        POP(1) ;
    } else {
        if (FRCOUNT() < 1) {
            ERROR(STACKOVERFLOW) ;
            return(0) ;
        }
        get_name(&l_newfont, "Courier", 7, FALSE) ;
        PUSH_OBJ(&l_newfont) ;
        get_dict_value(MESSAGEDICT, "fontnotfound", &l_tmpobj) ;
        interpreter(l_tmpobj) ;
        get_dict(l_fontdir, &l_newfont, &l_fontdict) ;
    } /* if */
    op_flush() ;
    /* push the font dictionary */
    PUSH_ORIGLEVEL_OBJ(l_fontdict) ;

    return(0) ;
}   /* op_findfont */
#endif /* FIND_SUB */

/************************************
 *  np_Run
 ************************************/
fix
np_Run()
{
    struct object_def   l_obj ;

    /* print the input string name (file name): dup == */
    if( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    tp_depth=0 ;
    cp = 0 ;

    if(! typeprint(l_obj))
        GEIio_write(GEIio_stdout, "\n", 1) ;

    op_flush() ;

    /* execute "run" operator */
    op_run() ;

    return(0) ;
}   /* np_Run */

/*
 *----------------------------------------------------------------------
 * change_status()
 *----------------------------------------------------------------------
 */
void
change_status()
{
    struct object_def   FAR *l_tmpobj, l_job ;
    ufix16 l_len ;

    get_dict_value(STATUSDICT, "jobname", &l_tmpobj) ;
    if ((l_len = LENGTH(l_tmpobj)) > 0) {
        //DJC add from history.log UPD023
        if (l_len > MAXJOBNAME-3) l_len = MAXJOBNAME-3;
        lstrncpy(job_name, (byte FAR *)VALUE(l_tmpobj), l_len) ; /*@WIN*/
        job_name[l_len] = ';' ;
        job_name[l_len + 1] = ' ' ;
        job_name[l_len + 2] = '\0' ;
    }
    else job_name[0] = '\0' ;

    l_len = lstrlen(job_state) - 2 ;            /* @WIN */
    TYPE_SET(&l_job, STRINGTYPE) ;
    ATTRIBUTE_SET(&l_job, LITERAL) ;
    ACCESS_SET(&l_job, READONLY) ;
    LENGTH(&l_job) = l_len ;
    VALUE(&l_job) = (ULONG_PTR)job_state ;
    put_dict_value1(STATUSDICT, "jobstate", &l_job) ;

#ifdef  DBG
    get_dict_value(STATUSDICT, "jobname", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
    get_dict_value(STATUSDICT, "jobstate", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
    get_dict_value(STATUSDICT, "jobsource", &l_tmpobj) ;
    PUSH_OBJ(l_tmpobj) ;
    two_equal() ;
#endif  /* DBG */

    return ;
}   /* change_status */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\arith.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */



// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <math.h>
#include        "global.ext"
#include        "arith.h"

#ifdef  _AM29K
#define FMIN31  -2147483648.0
#endif

static ufix32  random_seed = 1 ;
static ufix32  random_number ;

/* static function declaration */
#ifdef LINT_ARGS
/*
static  void    near  fraction_proc(fix16) ;
*/
static  void    near  ln_log(fix) ;
#else
/*
static  void    near  fraction_proc() ;
*/
static  void    near  ln_log() ;
#endif /* LINT_ARGS */

/***********************************************************************
**
** This module is used to return the sum of num1 and num2. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_add              Date:   00/00/87
** CALL:        op_add()            UpDate: 08/06/87
** PARAMETERS:  num1     ;  pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result   ;  pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_add()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       l_result.ll = kk1.ll + kk2.ll ;
       if ((!(kk1.ll & SIGNPATTERN) && !(kk2.ll & SIGNPATTERN) &&
           (l_result.ll & SIGNPATTERN)) || ((kk1.ll & SIGNPATTERN) &&
           (kk2.ll & SIGNPATTERN) && !(l_result.ll & SIGNPATTERN))) {
          /* overflow (+,+ => - or -,- => +) */
          is_float = REALTYPE ;
          kk1.ff = (real32)kk1.ll ;
          kk2.ff = (real32)kk2.ll ;
       } else
          goto exit_add ;
    } else {
       is_float = REALTYPE ;
       if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
          l_result.ll = INFINITY ;
          goto exit_add ;
       } else if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       else if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;
    }

    _clear87() ;
    l_result.ff = kk1.ff + kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_add:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_add() */

/***********************************************************************
**
** This operator is used to divides num1 by num2. The result is
** always a real.
**
** TITLE:       op_div              Date:   00/00/87
** CALL:        op_div()            Update: 08/13/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:
** RETURN:      quotient ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_div()
{
    struct  object_def  FAR *num1, FAR *num2 ;
    union   four_byte   l_quotient, kk1, kk2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;

    /* divide by zero  */
    if (!kk2.ll) {  /* == 0 */
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
    if (IS_INFINITY(num1))
       l_quotient.ll = INFINITY ;
    else if (IS_INFINITY(num2))
       l_quotient.ff = (real32)0.0 ;
    else {
       if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;

       _clear87() ;
       l_quotient.ff = kk1.ff / kk2.ff ;
       if (_status87() & PDL_CONDITION) {
          l_quotient.ll = INFINITY ;
          _clear87() ;
       }
    }
    POP(1) ;
    opnstack[opnstktop-1].value=l_quotient.ll;
    TYPE_SET(&opnstack[opnstktop-1],REALTYPE);

    return(0) ;
}   /* op_div() */

/***********************************************************************
**
** This operator is used to divide num1 by num2, and return the
** integer part of the quotient.
**
** TITLE:       op_idiv             Date:   00/00/87
** CALL:        op_idiv()           Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       error, float_div
** RETURN:      quotient ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_idiv()
{
    struct  object_def  FAR *num1, FAR *num2 ;
    union   four_byte   l_quotient, kk1, kk2 ;
    ufix32  l_temp ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;

    /* divide by zero  */
    if (!kk2.ll) { /* == 0 */
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
    if (IS_INFINITY(num1)) {
       if (kk2.ll) /* < 0 */
          l_quotient.ll = MIN31 ;
       else
          l_quotient.ll = MAX31 ;
    } else if (IS_INFINITY(num2))
       l_quotient.ll = 0 ;
    else {
       if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
          l_quotient.ll = kk1.ll / kk2.ll ;
          if (((fix32)l_quotient.ll == SIGNPATTERN) && ((fix32)kk2.ll == -1L)) {
             ERROR(UNDEFINEDRESULT) ;
             return(0) ;
          }
       } else {
          if (IS_INTEGER(num1))
             kk1.ff = (real32)kk1.ll ;
          else if (IS_INTEGER(num2))
             kk2.ff = (real32)kk2.ll ;

          l_quotient.ff = kk1.ff / kk2.ff ;
          l_temp = l_quotient.ll & VALUEPATTERN ;
          if (l_temp > MAX31PATTERN){
             if(l_quotient.ll & SIGNPATTERN)
                l_quotient.ll = MIN31 ;
             else
                l_quotient.ll = MAX31 ;
          }
          else
             l_quotient.ll = (fix32)l_quotient.ff ;
       }
    }

    POP(1) ;
    opnstack[opnstktop-1].value=l_quotient.ll;
    TYPE_SET(&opnstack[opnstktop-1],INTEGERTYPE);

    return(0) ;
}   /* op_idiv() */

/***********************************************************************
**
** This operator is used to return the remainder that results from
** dividing num1 by num2. Both operands must be integers ; the result
** is an integer.
**
** TITLE:       op_mod              Date:   00/00/87
** CALL:        op_mod()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       any_error, error
** RETURN:      remainder ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_mod()
{
    struct object_def FAR *num1 ;
    fix32   l_kk2 ;

    num1 = GET_OPERAND(1) ;
    l_kk2 = (fix32)VALUE(GET_OPERAND(0)) ;

    /* check if divided by zero */
    if (!l_kk2) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }

    VALUE(num1) = (ufix32) ((fix32)VALUE(num1) % l_kk2) ;
    POP(1) ;

    return(0) ;
}   /* op_mod() */

/***********************************************************************
**
** This operator is used to return the product of num1 and num2. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_mul              Date:   00/00/87
** CALL:        op_mul()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_mul()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;
    real64  d_result ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       if (IS_ARITH_MUL(kk1.ll) && IS_ARITH_MUL(kk2.ll))
          l_result.ll = kk1.ll * kk2.ll ;
       else {
          d_result = (real64)kk1.ll * (real64)kk2.ll ;
#ifdef  _AM29K
          if ((d_result > (real64)MAX31) || (d_result < (real64)FMIN31)) {
#else
          if ((d_result > (real64)MAX31) || (d_result < (real64)MIN31)) {
#endif
             l_result.ff = (real32)d_result ;
             is_float = REALTYPE ;
          } else
             l_result.ll = (fix32)d_result ;
       }
       goto exit_mul ;
    }

    /* either one is a real, or integer 'mul' overflow */
    is_float = REALTYPE ;
    if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
       l_result.ll = INFINITY ;
       goto exit_mul ;
    } else if (IS_INTEGER(num1))
       kk1.ff = (real32)kk1.ll ;
    else if (IS_INTEGER(num2))
       kk2.ff = (real32)kk2.ll ;

    _clear87() ;
    l_result.ff = kk1.ff * kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_mul:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_mul() */

/***********************************************************************
**
** This operator is used to subtract num2 from num1. If both
** operands are integers and the result is within integer range, the
** result is an integer ; otherwise, the result is a real.
**
** TITLE:       op_sub              Date:   00/00/87
** CALL:        op_sub()            Update: 08/06/87
** PARAMETERS:  num1     ; pointer (4-byte) to object on operand stack
**              num2     ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALL:
** RETURN:      result       ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_sub()
{
    ufix16  is_float ;
    union   four_byte   kk1, kk2, l_result ;
    struct  object_def  FAR *num1, FAR *num2 ;

    num1 = GET_OPERAND(1) ;
    num2 = GET_OPERAND(0) ;
    kk1.ll = (fix32)VALUE(num1) ;
    kk2.ll = (fix32)VALUE(num2) ;
    is_float = INTEGERTYPE ;

    if (IS_INTEGER(num1) && IS_INTEGER(num2)) {
       l_result.ll = kk1.ll - kk2.ll ;
       if ((!(kk1.ll & SIGNPATTERN) && (kk2.ll & SIGNPATTERN) &&
           (l_result.ll & SIGNPATTERN)) || ((kk1.ll & SIGNPATTERN) &&
           !(kk2.ll & SIGNPATTERN) && !(l_result.ll & SIGNPATTERN))) {
          /* overflow (+,- => - or -,+ => +) */
          is_float = REALTYPE ;
          kk1.ff = (real32)kk1.ll ;
          kk2.ff = (real32)kk2.ll ;
       } else
          goto exit_sub ;
    } else {
       is_float = REALTYPE ;
       if (IS_INFINITY(num1) || IS_INFINITY(num2)) {
          l_result.ll = INFINITY ;
          goto exit_sub ;
       } else if (IS_INTEGER(num1))
          kk1.ff = (real32)kk1.ll ;
       else if (IS_INTEGER(num2))
          kk2.ff = (real32)kk2.ll ;
    }

    _clear87() ;
    l_result.ff = kk1.ff - kk2.ff ;
    if (_status87() & PDL_CONDITION) {
       l_result.ll = INFINITY ;
       _clear87() ;
    }

exit_sub:
    POP(1) ;
    opnstack[opnstktop-1].value=l_result.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_sub() */

/***********************************************************************
**
** This operator is used to return the absolute value of num. The type
** of the result is the same as the type of num.
**
** TITLE:       op_abs              Date:   00/00/87
** CALL:        op_abs()            Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       error
** RETURN:      absnum   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_abs()
{
    ufix16  is_float ;
    struct  object_def  FAR *num ;
    union   four_byte   l_num ;

    num = GET_OPERAND(0) ;
    l_num.ll = (fix32)VALUE(num) ;

    /* initialize */
    is_float = REALTYPE ;

    /*  num is an INFINITY.0 or greater than or equal to zero */
    if (IS_INFINITY(num) || l_num.ll >= 0L)
       return(0) ;   /* nothing to do */

    if (IS_INTEGER(num)) {                  /* Integer */
       if (l_num.ll == MIN31) {             /* Max. negative integer */
          l_num.ff = (real32)l_num.ll ;
          l_num.ll &= MAX31 ;                /* clear sign bit */
       } else if( l_num.ll < 0L ) {
          l_num.ll = - l_num.ll ;            /* 2's complement */
          is_float = INTEGERTYPE ;
       }
    } else                                  /* Real */
        l_num.ll &= MAX31 ;                  /* clear sign bit */

    opnstack[opnstktop-1].value=l_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_abs() */

/***********************************************************************
**
** This operator is used to get the negative of num. The type of the
** result is the same as the type of the operand.
**
** TITLE:       op_neg              Date:   00/00/87
** CALL:        op_neg()            Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:
** RETURN:      negnum   ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_neg()
{
    ufix16  is_float ;
    struct  object_def  FAR *num ;
    union   four_byte   l_num ;

    num = GET_OPERAND(0) ;
    l_num.ll = (fix32)VALUE(num) ;

    /* initialize */
    is_float = REALTYPE ;

    /*  num is an INFINITY.0  */
    if (IS_INFINITY(num))
       return(0) ;    /* nothing to do */

    if (IS_INTEGER(num)) {                  /* Integer */
       if (l_num.ll == MIN31) {             /* Max. negative integer */
          l_num.ff = (real32)l_num.ll ;
          l_num.ll &= MAX31 ;               /* clear sign bit */
       } else {
          l_num.ll = - l_num.ll ;           /* 2's complement */
          is_float = INTEGERTYPE ;
       }
    } else                                  /* Real */
       l_num.ll ^= SIGNPATTERN ;            /* complement sign bit */

    opnstack[opnstktop-1].value=l_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],is_float);

    return(0) ;
}   /* op_neg() */

/***********************************************************************
**
** This operator is used to get the value greater than or equal to num.
** The type of the result is the same as the type of the operand.
**
** TITLE:       op_ceiling          Date:   00/00/87
** CALL:        op_ceiling()        Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      ceilnum ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_ceiling()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)ceil(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_ceiling() */

/***********************************************************************
**
** This operator is used to get the greatest integer value less
** than or equal to num. The type of the result is the same as the type
** of the operand.
**
** TITLE:       op_floor            Date:   00/00/87
** CALL:        op_floor()          Update: 08/06/87
** PARAMETERS:
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      floornum    ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_floor()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)floor(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_floor() */

/***********************************************************************
**
** This operator is used to get the integer value nearest to num.
** if num is equally close to its two nearest integers, Round_op
** returns the greater of the two. The type of the result is the same
** as the type of the operand.
**
** TITLE:       op_round            Date:   00/00/87
** CALL:        op_round()          Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      roundnum ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_round()  /* not complete */
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    l_ff.ff = (real32)floor(5.0e-1 + l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_round() */

/***********************************************************************
**
** This operator is used to truncate num toward zero by removing its
** fractional part. The type of the result is the same as the type
** of the operand.
**
** TITLE:       op_truncate         Date:   00/00/87
** CALL:        op_truncate()       Update: 08/06/87
** PARAMETERS:  num      ; pointer (4-byte) to object on operand stack
** INTERFACE:
** CALLS:       fraction_proc
** RETURN:      truncatenum  ; pointer (4-byte) to object on operand stack
***********************************************************************/
fix
op_truncate()
{
    union   four_byte   l_ff ;

    l_ff.ll = (fix32)VALUE(GET_OPERAND(0)) ;
    if (IS_INTEGER(GET_OPERAND(0)) || (l_ff.ll == INFINITY)) {
       return(0) ; /* nothing to do */
    }

    if (l_ff.ff >= (real32)0.0)
       l_ff.ff = (real32)floor(l_ff.ff) ;
    else
       l_ff.ff = (real32)ceil(l_ff.ff) ;
    opnstack[opnstktop-1].value = l_ff.ll ;

    return(0) ;
}   /* op_truncate() */

/* **********************************************************************
 *
 *  This operator is used to return the square root of num, which must
 *  be a non-negative number.
 *
 *  TITLE :     op_sqrt                 Date : 08/21/87
 *  CALL:       op_sqrt()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      sqrt(), ERROR()
 *  RETURN:     lf_num   ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_sqrt()
{
    struct  object_def  FAR *num ;
    union   four_byte   lf_num, l_ff ;

    num = GET_OPERAND(0) ;
    l_ff.ll = (fix32)VALUE(num) ;
/*
 *   operand is a negative number
 */
    if (l_ff.ll & SIGNPATTERN) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }
/*
 *   operand is infinity.0
 */
    if (IS_INFINITY(num))
       lf_num.ll = INFINITY ;
    else {
       if (IS_INTEGER(num))
          l_ff.ff = (real32)l_ff.ll ;
       lf_num.ff = (real32)sqrt(l_ff.ff) ;     /* double */
    }

    opnstack[opnstktop-1].value=lf_num.ll;
    TYPE_SET(&opnstack[opnstktop-1],REALTYPE);

    return(0) ;
}   /* op_sqrt() */

/* **********************************************************************
 *
 *  This operator is used to return the angle(in degrees between 0 and 360)
 *  whose tangent is num/den. Either num or den may be zero, but not both.
 *  The signs of num and den determine the quadrant in which the result
 *  is lie: a positive num yields a result in the positive y plane ; a
 *  positive den yields a result in the positive x plane.
 *
 *  TITLE :     op_atan                 Date : 08/21/87
 *  CALL:       op_atan()
 *  PARAMETERS: num, den ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      atan2(), ERROR()
 *  RETURN:     lf_angle ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_atan()
{
    struct  object_def  FAR *num, FAR *den ;
    union   four_byte   lf_angle, lf_1, lf_2 ;
#ifdef _AM29K
    bool AMDCase = FALSE ;
#endif  /* _AM29K */
/*
 *  get 2 operands from stack
 */
    den = GET_OPERAND(0) ;
    num = GET_OPERAND(1) ;
    lf_2.ll = (fix32)VALUE(num) ;  /* y */
    lf_1.ll = (fix32)VALUE(den) ;  /* x */
/*
 *   either num and den may be zero, but not both
 */
    if (!lf_2.ll && !lf_1.ll) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
/*
 *   num is infinity.0
 */
    if (IS_INFINITY(num))
       lf_angle.ff = (real32)90.0 ;
/*
 *   den is infinity.0
 */
    else if (IS_INFINITY(den))
       lf_angle.ff = (real32)0.0 ;
/*
 *  call library atan2(y, x)
 */
    else {
#ifdef _AM29K
/* Bad handling of special cases in AMD29K atan2 function -- do it by hand */
       if (VALUE (num) == 0) {
         if (VALUE(den) & SIGNPATTERN) {
           lf_angle.ff = (real32)180. ;
         }
         else {
           lf_angle.ff = (real32)0. ;
         }
         AMDCase = TRUE ;
       }
       else if (VALUE (den) == 0) {
         if (VALUE(num) & SIGNPATTERN) {
           lf_angle.ff = (real32)270. ;
         }
         else {
           lf_angle.ff = (real32)90. ;
         }
         AMDCase = TRUE ;
       }

       if (AMDCase) {
          POP(2) ;
          PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_angle.ll) ;
          return(0) ;
       }
#endif  /* _AM29K */

       if (IS_INTEGER(num))
          lf_2.ff = (real32)lf_2.ll ;
       if (IS_INTEGER(den))
          lf_1.ff = (real32)lf_1.ll ;
       lf_angle.ff = (real32)atan2(lf_2.ff, lf_1.ff) ;
       lf_angle.ff *= (real32)180.0 / (real32)PI ;
/*
 *   the range of result is from 0 to 360
 */
       if (lf_angle.ll & SIGNPATTERN)
          lf_angle.ff = lf_angle.ff + (real32)360.0 ;
    }

    POP(2) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_angle.ll) ;

    return(0) ;
}   /* op_atan() */

/* *********************************************************************
 *
 *  This operator is used to return the cosine of angle, which is
 *  interpreted as an angle in degrees.
 *
 * TITLE:       op_cos              Date:   00/00/87
 * CALL:        op_cos()            UpDate: 08/06/87
 * PARAMETERS:  angle    ; pointer (4-byte) to object on operand stack
 * INTERFACE:
 * CALL:        ERROR(), cos()
 * RETURN:      lf_real  ; pointer (4-byte) to object on operand stack
 **********************************************************************/
fix
op_cos()
{
    struct  object_def  FAR *angle ;
    union   four_byte   lf_real, lf_1 ;
/*
 * get angle operand
 */
    angle = GET_OPERAND(0) ;
    lf_1.ll = (fix32)VALUE(angle) ;
/*
 *   ANGLE is infinity.0
 */
    if (IS_INFINITY(angle))
       lf_real.ll = INFINITY ;
    else {
       /* degree -> radius */
       if (IS_INTEGER(angle))
          lf_1.ff = (real32)(lf_1.ll % 360) ;
       else
          lf_1.ff -= (real32)floor(lf_1.ff / 360.0) * (real32)360.0 ;
       lf_real.ff = (real32)cos(lf_1.ff / 180.0 * PI) ;  /* double */
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_cos() */

/* *********************************************************************
 *
 *  This operator is used to return the sine of angle, which is
 *  interpreted as an angle in degrees.
 *
 * TITLE:       op_sin              Date:   08/21/87
 * CALL:        op_sin()
 * PARAMETERS:  angle    ; pointer (4-byte) to object on operand stack
 * INTERFACE:
 * CALL:        ERROR(), sin()
 * RETURN:      result   ; pointer (4-byte) to object on operand stack
 **********************************************************************/
fix
op_sin()
{
    struct  object_def  FAR *angle ;
    union   four_byte   lf_real, lf_1 ;
    union   four_byte   temp ;
/*
 * get angle operand
 */
    angle = GET_OPERAND(0) ;
    temp.ll = lf_1.ll = (fix32)VALUE(angle) ;

/*
 *   ANGLE is infinity.0
 */
    if (IS_INFINITY(angle))
       lf_real.ll = INFINITY ;
    else {
       /* degree -> radius */
       if (IS_INTEGER(angle)) {
          lf_1.ff = (real32)(lf_1.ll % 360) ;
          if (temp.ll && lf_1.ff == (real32)0.0)  /* N * 360, N > 1 */
             lf_1.ff = (real32)360.0 ;
       } else {                           /* TYPE == REAL */
          lf_1.ff -= (real32)floor(lf_1.ff / 360.0) * (real32)360.0 ;
          if (temp.ff != (real32)0.0 && lf_1.ff == (real32)0.0) /* N * 360.0, N > 1 */
             lf_1.ff = (real32)360.0 ;
       }
       lf_real.ff = (real32)sin(lf_1.ff / 180.0 * PI) ; /* double */
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_sin() */

/* *********************************************************************
 *
 *  This operator is used to raise base to the exponent power.
 *  The operands may be either integers or reals (if the exponent has
 *  a fractional part, the result is meaningful only if the base is
 *  non-negative).
 *
 *  TITLE :     op_exp                  Date : 08/21/87
 *  CALL:       op_exp()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      pow(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_exp()
{
    struct  object_def  FAR *base, FAR *exp ;
    union   four_byte   lf_real, l_num1, l_num2 ;

    base = GET_OPERAND(1) ;
    exp  = GET_OPERAND(0) ;
    l_num1.ll = (fix32)VALUE(base) ;
    l_num2.ll = (fix32)VALUE(exp) ;
/*
 *   BASE is zero and EXPONENT is zero
 */
    if (!l_num1.ll && !l_num2.ll) {
       ERROR(UNDEFINEDRESULT) ;
       return(0) ;
    }
/*
 *   BASE is zero
 */
    if (!l_num1.ll) {
       lf_real.ff = (real32)0.0 ;
       goto l_exp1 ;
    }
/*
 *   EXPONENT is zero
 */
    if (!l_num2.ll) {
       lf_real.ff = (real32)1.0 ;
       goto l_exp1 ;
    }
/*
 *  one of operand is infinity.0
 */
    if (IS_INFINITY(base) || IS_INFINITY(exp)) {
       lf_real.ll = INFINITY ;
       goto l_exp1 ;
    }
/*
 *  BASE is zero, EXPONENT is negative
 */
 /*
 /*
    if (!l_num1.ll && (l_num2.ll & SIGNPATTERN)) {
       lf_real.ll = INFINITY ;
       ERROR(RANGECHECK) ;
       return(0) ;
    }
 */
/*
 *  BASE is negative, and EXPONENT has fraction part
 */
 /*
    if (((IS_INTEGER(base) && (l_num1.ll < 0L)) ||
        (IS_REAL(base) && (l_num1.ff < (real32)0))) && IS_REAL(exp)) {
  */
    if ((l_num1.ll & SIGNPATTERN) && IS_REAL(exp) &&
                             (l_num2.ff != (real32)floor(l_num2.ff))) {
          /* error returned on C library call */
          lf_real.ll = INFINITY ;
          ERROR(UNDEFINEDRESULT) ;
          return(0) ;
    }

    if (IS_INTEGER(base))
       l_num1.ff = (real32)l_num1.ll ;
    if (IS_INTEGER(exp))
       l_num2.ff = (real32)l_num2.ll ;

    _clear87() ;
    lf_real.ff = (real32)pow(l_num1.ff, l_num2.ff) ;
/*
 *   condition occur at operation
 */
    if (_status87() & PDL_CONDITION) {
       lf_real.ll = INFINITY ;
       _clear87() ;
    }

l_exp1:
    POP(2) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_exp() */

/* *********************************************************************
 *
 * This operator is used to return the natural logarithm(base e) of num.
 *  The result is a real.
 *
 *  TITLE :     op_ln                   Date : 08/21/87
 *  CALL:       op_ln()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      ln_log(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_ln()
{
    ln_log(LN) ;

    return(0) ;
}   /* op_ln() */

/* *********************************************************************
 *
 *  This operator is used to return the common logarithm(base 10) of num.
 *  The result is a real.
 *
 *  TITLE :     op_log                  Date : 08/24/87
 *  CALL:       op_log()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      ln_log(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
fix
op_log()
{
    ln_log(LOG) ;

    return(0) ;
}   /* op_log() */

/***********************************************************************
**
** This operator is used to return a random integer in the range 0 to
** 2**31-1, produced by a pseudo-random number generator. The random
** number generator's state can be  reset by srand and interrogated
** by rrand.
** random_number = u1(high word)  u2(low word)
** g(D) = 1 + D**3 + D**7 + D**11 + D**15 + D**19 + D*23 + D**27 + D**31
**            bit29  bit25  bit21   bit17   bit13   bit9   bit5    bit1
**
** TITLE:       op_rand()           Date:   10/13/87
** CALL:        op_rand()
** PARAMETERS:  none.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      random number on the operand stack.
** update: 7-12-88 change bitfield
***********************************************************************/
fix
op_rand()
{
    ufix32  u1, temp ;
    fix     i, rand_shift ;

    if (random_seed == 1) {
        random_number = 2011148374L ;
        rand_shift = 7 ;
    } else {
        if (random_seed & SIGNPATTERN)
            rand_shift = 13 ;
        else
            rand_shift = 7 ;
        random_number = random_seed & 0x7FFFFFFF ;

        for (i = 0 ; i < rand_shift ; i++) {
            u1 = random_number ;

            /* operate on LSB of temp */
            temp = u1 ^ (u1 >> 4) ^ (u1 >> 8) ^
                   (u1 >> 12) ^ (u1 >> 16) ^ (u1 >> 20) ^
                   (u1 >> 24) ^ (u1 >> 28) ;
            u1 = u1 >> 1 ;
            u1 |= (temp & 0x1) << 30 ;    /* bit feedback into bit31 */
            u1 &= 0x7FFFFFFF ;            /* clear MSB of u1 */

            random_number = u1 ;
            if (random_number == 0)
               random_number = 0x0F0F0F0F ;
        } /* for */
    } /* else */
    /*
     * push random_number to operand stack.
     */
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, random_number) ;

    if (rand_shift == 13)
       random_seed = random_number ;
    else
       random_seed = random_number | SIGNPATTERN ;

    return(0) ;
}   /* op_rand() */

/***********************************************************************
**
** This operator is used to initialize the random number generators
** with the seed integer number on operand stack.
**
** TITLE:       op_srand()           Date:   10/13/87
** CALL:        op_srand()
** PARAMETERS:  seed integer number.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      none.
***********************************************************************/
fix
op_srand()
{
/*
 * get seed number and store to static global variable : random_seed
 */
    random_seed = (fix32)VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_srand() */

/***********************************************************************
**
** This operator is used to return an integer representing the current
** state of the random number generator used by rand operator.
**
** TITLE:       op_rrand()           Date:   10/13/87
** CALL:        op_rrand()
** PARAMETERS:  none.
**
** INTERFACE:
** CALLS:       none.
** RETURN:      random generator's seed number.
***********************************************************************/
fix
op_rrand()
{
/*
 * push random number seed to operand stack
 */
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, random_seed) ;

    return(0) ;
}   /* op_rrand() */


/***********************************************************************
**
**  This routine called by op_ceiling(), op_floor(),
**  op_truncate().
**  It get one operand from operand stack, then calculate the result
**  according to the parameter : mode selection and push the result
**  to operand stack.
**
** TITLE:       fraction_proc
** CALL:        fraction_proc(mode)
** PARAMETERS:  mode    ; 1  for ceiling
**                      ; 2  for floor
**                      ; 3  for round
**                      ; 4  for truncate
** CALLS:       any_error, error, gauss_num
** RETURN:      none
***********************************************************************/
/*
static void near
fraction_proc(mode)
 fix16   mode ;
{
    struct  object_def  FAR *num ;
    union   four_byte   l_ff ;

    num = GET_OPERAND(0) ;
    if (IS_INTEGER(num) || IS_INFINITY(num)) {
       return ; |* nothing to do *|
    }

    |* initialize *|
    l_ff.ll = (fix32)VALUE(num) ;

    |* num is real and not an INFINITY *|
    _clear87() ;
    switch(mode) {
    case CEIL:
         l_ff.ff = (real32)ceil(l_ff.ff) ;
         break ;

    case FLOOR:
         l_ff.ff = (real32)floor(l_ff.ff) ;
         break ;

    case ROND:
         l_ff.ff = (real32)floor(5.0e-1 + l_ff.ff) ;
         break ;

    case TRUNCATE:
         if (l_ff.ff >= (real32)0)
            l_ff.ff = (real32)floor(l_ff.ff) ;
         else
            l_ff.ff = (real32)ceil(l_ff.ff) ;
    } |* switch *|

    if (_status87() & PDL_CONDITION) {
       l_ff.ll = INFINITY ;
       _clear87() ;
    }

    VALUE(num) = l_ff.ll ;

    return ;
} *//* fraction_proc() */

/* *********************************************************************
 *
 *  This routine is called by op_ln(), op_log() to do the natural and
 *  common logarithm. If mode = 1, then do natural logarithm
 *                       mode = 2, then do common logarithm.
 *  It get the operand from operand stack, then push the result value
 *  to operand stack after calcultion completed.
 *
 *  TITLE :     ln_log                  Date : 08/24/87
 *  CALL:       ln_log()
 *  PARAMETERS: num      ; pointer (4-byte) to object on operand stack
 *  INTERFACE:
 *  CALLS:      log(), log10(), ERROR()
 *  RETURN:     lf_real  ; pointer (4-byte) to object on operand stack
 * **********************************************************************/
static void near
ln_log(mode)
 fix     mode ;
{
    struct  object_def  FAR *num ;
    union   four_byte   lf_real, lf_num1 ;

    num = GET_OPERAND(0) ;
    lf_num1.ll = (fix32)VALUE(num) ;
/*
 *   operand is zero or negative
 */
    if ((!lf_num1.ll) || (lf_num1.ll & SIGNPATTERN)) {
       ERROR(RANGECHECK) ;
       return ;
    }
/*
 *   operand is Infinity
 */
    if (IS_INFINITY(num))
       lf_real.ll = INFINITY ;
/*
 *   base e , normal value process
 */
    else {
       _clear87() ;
       if (IS_INTEGER(num))
          lf_num1.ff = (real32)lf_num1.ll ;
       if (mode == LN)
          lf_real.ff = (real32)log(lf_num1.ff) ;
       else
          lf_real.ff = (real32)log10(lf_num1.ff) ;
       if (_status87() & PDL_CONDITION) {
          lf_real.ll = INFINITY ;
          _clear87() ;
       }
    }

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0, LITERAL, 0, lf_real.ll) ;

    return ;
}   /* ln_log() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\graph\trvse.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/***********************************************************************
 *
 *      File Name:   trvse.c
 *
 *      Purpose: This file contains routines to traverse current path,
 *               and execute the input routine for each subpath.
 *
 *      Developer:      S.C.Chen
 *
 *      Modifications:
 *      Version     Date        Comment
 *                  7/19/88     update data types:
 *                              1) float ==> real32
 *                              2) int
 *                                 short ==> fix16 or fix(don't care the length)
 *                              3) long  ==> fix32, for long integer
 *                                           long32, for parameter
 *                              4) add compiling option: LINT_ARGS
 *                  8/11/88     add LINT_ARGS for traverse_path(), trvse_nest()
 *                  8/29/88     add global variables of floating constants:
 *                              zero_f, one_f.
 *                              fix trvse_nest() ==> void trvse_nest()
 *                              optimize trvse_nest() by deleting unnecessary
 *                              assignment of floating numbers: flat, n_flat
 *                  11/15/89    @NODE: re-structure node table; combine subpath
 *                              and first vertex to one node.
 *                  12/4/90     @CPPH: trvse_nest: traverse cp_path(clipping
 *                              trazepozids) if path stored in it.
 **********************************************************************/


// DJC added global include
#include "psglobal.h"


#include        <math.h>

#include "global.ext"
#include "graphics.h"
#include "graphics.ext"

/* ********** static function declartion ********** */
#ifdef LINT_ARGS
//      static void near trvse_nest (void (*)(SP_IDX, fix *), fix *, PH_IDX, ufix, long32, fix);
        static void near trvse_nest (void (*)(SP_IDX, fix FAR *), fix FAR *,
               PH_IDX, ufix, long32, fix);
#else
        static void near trvse_nest ();
#endif

/***********************************************************************
 * This module traverses current path, and calls the input function for
 * each subpath traversed.
 *
 * TITLE:       traverse_path
 *
 * CALL:        traverse_path (fun, param)
 *
 * PARAMETERS:  fun   -- a function to be executed when traverses a
 *                       complete subpath
 *              param -- input parameter of fun
 *
 * INTERFACE:   op_pathforall -- &dump_subpath
 *              op_stroke, op_strokepath -- &path_to_outline
 *              op_clip, op_eoclip, op_fill, op_eofill --
 *                      &shape_approximation
 *
 * CALLS:       trvse_nest
 *
 * RETURN:
 **********************************************************************/
void traverse_path (fun, param)
#ifdef LINT_ARGS
//      void    (*fun)(SP_IDX, fix *);          @WIN
// DJC        void    (*fun)();
        void    (*fun)(SP_IDX, fix FAR *);
#else
        void    (*fun)();
#endif
fix     FAR *param;
{
// DJC        trvse_nest (fun, param, GSptr->path, 0, F2L(zero_f), 0);
        trvse_nest (fun,
                     param,
                     (PH_IDX)(GSptr->path),
                     (ufix)0,
                     (long32)(F2L(zero_f)),
                     (fix)0);
}


/***********************************************************************
 * A recurcive procedure to traverse path
 *
 * TITLE:       trvse_nest
 *
 * CALL:        trvse_nest (fun, param, path, ref, l_flat, depth)
 *
 * PARAMETERS:  fun     -- a function to be executed when traverses a
 *                         complete subpath
 *              param   -- input parameter of fun
 *              path    -- path header of a gsave level
 *              ref     -- reference flag
 *              l_flat  -- flatness
 *              depth   -- recursive depath
 *
 * INTERFACE:   traverse_path
 *
 * CALLS:       trvse_nest, flatten_subpath, reverse_subpath, *fun()
 *
 * RETURN:
 **********************************************************************/
static void near trvse_nest (fun, param, path, ref, l_flat, depth)
#ifdef LINT_ARGS
        void    (*fun)(SP_IDX, fix FAR *);
//      void    (*fun)();                       /* @WIN */
#else
        void    (*fun)();
#endif
fix     FAR *param;
PH_IDX  path;
ufix    ref;
long32    l_flat;
fix     depth;
{
        ufix    n_ref;
        long32  n_flat;
        struct  ph_hdr FAR *p;
        struct  nd_hdr FAR *sp;
        SP_IDX  isp;

        p = &path_table[path];
        if (p->previous != NULLP) {
                /* generate next reverse flag */
                n_ref = (ref & P_RVSE) ^ p->rf;

                /* generate next flat flag */
                n_ref = (n_ref & P_FLAT) | p->rf;
                if (ref & P_FLAT) n_flat = l_flat;
                if (p->rf & P_FLAT) n_flat = F2L(p->flat);

                /* traverse recursively */
                trvse_nest (fun, param, p->previous, n_ref, n_flat, depth+1);
        }

#ifdef DBG1
        printf(" Traverse all subpath on this level, p->head=%d\n",
               p->head);
#endif

        /* traverse cp_path, if path defined in it (by op_clippath) @CPPH */
        if (p->cp_path != NULLP) {
            CP_IDX itpzd;
            struct nd_hdr FAR *tpzd;
            real32 x[3], y[3];
            struct nd_hdr FAR *vtx;
            VX_IDX  ivtx, isp;
            fix i;

            /*
             * create current path that transforms from clipping trapezoids
             * each trapezoid generates one subpath :
             *      (TOP_XL, TOPY) +--------+ (TOPXR, TOPY)
             *                    /          \
             *                   /            \
             *    (BTMXL, BTMY) +--------------+ (BTMXR, BTMY)
             */
            for (itpzd = p->cp_path; itpzd != NULLP; itpzd = tpzd->next) {

                tpzd = &node_table[itpzd];

                x[0] = SFX2F(tpzd->CP_TOPXR);
                y[0] = SFX2F(tpzd->CP_TOPY);
                x[1] = SFX2F(tpzd->CP_BTMXR);
                y[1] = SFX2F(tpzd->CP_BTMY);
                x[2] = SFX2F(tpzd->CP_BTMXL);
                y[2] = SFX2F(tpzd->CP_BTMY);

                /* Create 5 nodes */
                for (i=0, isp=NULLP; i<5; i++) {
                        ivtx = get_node();
                        if(ivtx == NULLP) {
                            free_node(isp);
                            ERROR(LIMITCHECK);
                            return;
                        }
                        node_table[ivtx].next = isp;
                        isp = ivtx;
                }

                /* Set up a MOVETO node */
                vtx = &node_table[isp];
                vtx->VX_TYPE = MOVETO;
                vtx->VERTEX_X = SFX2F(tpzd->CP_TOPXL);
                vtx->VERTEX_Y = SFX2F(tpzd->CP_TOPY);
                vtx->SP_FLAG = FALSE;
                vtx->SP_NEXT = NULLP;

                /* 3 LINETO nodes */
                for (i=0, ivtx=vtx->next; i<3; i++) {
                        vtx = &node_table[ivtx];
                        vtx->VX_TYPE = LINETO;
                        vtx->VERTEX_X = x[i];
                        vtx->VERTEX_Y = y[i];
                        ivtx = vtx->next;
                }
                node_table[ivtx].VX_TYPE = CLOSEPATH;
                node_table[isp].SP_TAIL = ivtx;

                (*fun) (isp, param);

                free_node(isp);
            } /* for */
        } /* if */

        /* traverse all subpaths on this level */
        for (isp = p->head; isp != NULLP; isp = sp->SP_NEXT) {/* @NODE: next */
                /* struct vx_lst *vlist;       @NODE */
                SP_IDX iflt_sp, irvs_sp;       /* @TRVSE */

                sp = &node_table[isp];

                /* ignore incomplete tail subpath */
                if ((depth > 0) && (isp == p->tail) &&
                    ((sp->SP_FLAG & SP_DUP))) break;

                /* approximate a flattened subpath */
                if (ref & P_FLAT) {
                     /* @NODE
                      * vlist = flatten_subpath (sp->SP_HEAD, l_flat);
                      * (* allocate a subpath header    @SP_FLG *)
                      * iflt_sp = get_node();
                      * if(iflt_sp == NULLP) {
                      *         ERROR(LIMITCHECK);
                      *         return;
                      * }
                      * node_table[iflt_sp].next = NULLP;
                      * node_table[iflt_sp].SP_HEAD = vlist->head;
                      * node_table[iflt_sp].SP_TAIL = vlist->tail;
                      * node_table[iflt_sp].SP_FLAG = sp->SP_FLAG & (~SP_CURVE);
                      * isp = iflt_sp;
                      */
                        isp = iflt_sp = flatten_subpath (isp, l_flat);
                }

                /* approximate a reversed subpath */
                if (ref & P_RVSE) {
                     /* @NODE
                      * vlist = reverse_subpath (node_table[isp].SP_HEAD);
                      * (* allocate a subpath header    @SP_FLG *)
                      * irvs_sp = get_node();
                      * if(irvs_sp == NULLP) {
                      *         ERROR(LIMITCHECK);
                      *         return;
                      * }
                      * node_table[irvs_sp].next = NULLP;
                      * node_table[irvs_sp].SP_HEAD = vlist->head;
                      * node_table[irvs_sp].SP_TAIL = vlist->tail;
                      * isp = irvs_sp;
                      */
                        isp = irvs_sp = reverse_subpath (isp);
                }

                (*fun) (isp, param);

                if (ref & P_FLAT) {             /* @PRE_CLIP */
                        /* free_node (node_table[iflt_sp].SP_HEAD); @NODE */
                        free_node (iflt_sp);
                }

                if (ref & P_RVSE) {             /* @PRE_CLIP */
                        /* free_node (node_table[irvs_sp].SP_HEAD); @NODE */
                        free_node (irvs_sp);
                }

        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\arith.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/* arith.h */

/* set 87 control word to a default value */
#ifdef _AM29K
#define     CW_PDL              0
#define     PDL_INFINITY        4+8
/* Define or appropriate bits for 29027 -- zero divide (bit 5),
 * overflow (bit 2), reserved (bit 1), and invalid (bit 0).
 */
#define PDL_CONDITION   32+4+2+1        /* phchen 03/26/91 */
#define     _clear87()          _clear_fp()
#define     _status87()         _status_fp()
extern      _clear_fp(), _status_fp();
#else
#define     CW_PDL              IC_AFFINE+RC_NEAR+PC_64+MCW_EM
#define     PDL_INFINITY        SW_OVERFLOW+SW_UNDERFLOW
#define     PDL_CONDITION       SW_ZERODIVIDE+SW_OVERFLOW+SW_INVALID
#endif  /* _AM29K */

#define     IS_INFINITY(obj)\
            ((TYPE(obj) == REALTYPE) && (VALUE(obj) == INFINITY))
#define     IS_NUM_OBJ(obj)\
            ((TYPE(obj) == REALTYPE) || (TYPE(obj) == INTEGERTYPE))
#define     IS_INTEGER(obj)\
            (TYPE(obj) == INTEGERTYPE)
#define     IS_REAL(obj)\
            (TYPE(obj) == REALTYPE)
#define     IS_ARITH_MUL(val)\
            (!(val & 0xFFFF8000) || ((val & 0xFFFF8000) == 0xFFFF8000))

#define     CEIL                1
#define     FLOOR               2
#define     ROND                3
#define     TRUNCATE            4

#define     LN                  1
#define     LOG                 2

#define     MAX31PATTERN        0x4F000000
#define     VALUEPATTERN        0x7FFFFFFF
#define     SIGNPATTERN         0x80000000


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\array.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              ARRAY.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/***********************************************************************
**
** This operator is used to create an array of length num, each of
** whose elements is initialized with a null object, and pushes this
** string on the operand stack. The num operand must be a non-negative
** integer not greater than the maximum allowable array length.
**
** TITLE:       op_array                    Date:   08/01/87
** CALL:        op_array()                  UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS        create_array:   5.3.1.3.1.1
***********************************************************************/
fix
op_array()
{
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) )
        ERROR(RANGECHECK) ;
    /*
     *  this operand must be a non-negative integer and not greater
     *  than the maximum allowable array length
     */
    else
        if( create_array(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;

    return(0) ;
}   /* op_array */

/***********************************************************************
**
** This operator is used to push a mark object on the operand stack.
**
** TITLE:       op_l_bracket                Date:   08/01/87
** CALL:        op_l_bracket()              UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_l_bracket()
{
    if( FRCOUNT() < 1  )
        ERROR(STACKOVERFLOW) ;
    else
        /*  push 'markobj' to operand stack */
        PUSH_VALUE(MARKTYPE, 0, LITERAL, 0, LEFTMARK) ;

    return(0) ;
}   /* op_l_bracket */

/***********************************************************************
**
**  This operator is used to create a new array of n elements, where n is
**  the number of elements above the topmost mark on the operand stack,
**  store those elements into the array, and return the array on the
**  operand stack.The R_bracket_op operator stores the topmost object
**  from the stack into element n-1 of array and the bottommost one into
**  element 0 of array. It removes all the array elements from the stack,
**  as well as the mark object.
**
** TITLE:       op_r_bracket                Date:   08/01/87
** CALL:        op_r_bracket()              UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       alloc_vm:       5.3.1.10.5
***********************************************************************/
fix
op_r_bracket()
{
    fix     l_i, l_j ;
    ubyte   FAR *l_array ;
    struct  object_def  huge *l_temp ;

    for (l_i = 0 ; (ufix)l_i < COUNT() ; l_i++) {       //@WIN
        /*
         *   SEARCH FIRST LEFT MARK && count l_i
         */
        if( (TYPE_OP(l_i) == MARKTYPE) &&
            (VALUE_OP(l_i) == LEFTMARK) ) {
            if(l_i == 0)
                l_array = NIL ;
            else {  /* l_i > 0 */
                l_array = (ubyte FAR *)extalloc_vm((ufix32)l_i *
                                   sizeof(struct object_def)) ;
                if( (l_array != NIL) ) {
                    /*
                     *   BUILD 'ary_obj'
                     *
                     *  array: from bottom to top(l_k)
                     *  stack: from top to bottom(l_j)
                     */
                    l_temp = (struct object_def huge *)l_array + (l_i - 1) ;
                    for(l_j = 0 ; l_j < l_i ; l_j++, l_temp--) {
                        COPY_OBJ( GET_OPERAND(0),
                                  (struct object_def FAR *)l_temp ) ;
                        LEVEL_SET(l_temp, current_save_level) ;
                        POP(1) ;
                    }
                } else
                    return(0) ;         /* VMERROR */
            }   /* else */

            POP(1) ;                    /* pop left mark */
            PUSH_VALUE(ARRAYTYPE, UNLIMITED, LITERAL, l_i, l_array) ;
            return(0) ;
        }    /* if */
    }   /* for(l_i) */

    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_r_bracket */

/***********************************************************************
**
** This operator is used to create a new array or string object whose
** value consists of some subsequence of the original array or string.
** The subsequence consists of count elements starting at the specified
** index in the original array or string. The elements in the subsequence
** are shared between the original and new objects.
**
** Getinterval_op requires index to be a valid index in the original array
** or string and count to be a non-negative integer such that index+count
** is not greater than the length of the original array or string.
**
** TITLE:       op_getinterval                  Date:   08/01/87
** CALL:        op_getinterval()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              getinterval_array:  5.3.1.3.7.1
**              getinterval_string: 5.3.1.5.12
***********************************************************************/
fix
op_getinterval()
{
    ufix16  l_index, l_count ;
    struct  object_def  l_save ;
    bool    l_bool = FALSE ;

    if( ((fix32)VALUE_OP(1) < 0) ||
        ((ufix32)VALUE_OP(1) > MAXARYCAPSZ) ||
        ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    /* executeonly or noaccess */
    if( ACCESS_OP(2) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
    } else {
        l_index = (ufix16)VALUE_OP(1) ;
        l_count = (ufix16)VALUE_OP(0) ;
        if( TYPE_OP(2) == STRINGTYPE )
            l_bool = getinterval_string(GET_OPERAND(2), l_index,
                                        l_count, &l_save ) ;
        else
            l_bool = getinterval_array(GET_OPERAND(2), l_index,
                                        l_count, &l_save ) ;
    }
    /*
     *  SUCCESS
     */
    if(  ! ANY_ERROR() && l_bool ) {
        POP(3) ;
        PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }

    return(0) ;
}   /* op_getinterval */

/***********************************************************************
**
**  This operator is used to replace a subsequence of the elements of
**  the first array or string by the entire contents of the second
**  array or string. The subsequence that is replaced begins at the
**  specified index in the first array or string ; its length is the
**  same as the length of the second array or string.
**
**  Putinterval_op requires index to be a valid index in ary_str1 such
**  that index plus the length of ary_str2 is not greater than the length
**  of ary_str1.
**
** TITLE:       op_putinterval                  Date:   08/01/87
** CALL:        op_putinterval()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              putinterval_array:  5.3.1.3.8.1
**              putinterval_string: 5.3.1.5.13
***********************************************************************/
fix
op_putinterval()
{
    bool    l_bool ;
    ufix16  l_index ;

    /* index */
    if( ((fix32)VALUE_OP(1) < 0) ||
        ((ufix32)VALUE_OP(1) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    /* executeonly or noaccess */
    if( (ACCESS_OP(2) != UNLIMITED) ||
        (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_index = (ufix16)VALUE_OP(1) ;

    if( TYPE_OP(0) == STRINGTYPE )
        l_bool = putinterval_string( GET_OPERAND(2),
                                     l_index, GET_OPERAND(0) ) ;
    else
        l_bool = putinterval_array( GET_OPERAND(2),
                                    l_index, GET_OPERAND(0) ) ;

    /* SUCCESS */
    if( (! ANY_ERROR()) && l_bool )
        POP(3) ;

    return(0) ;
}   /* op_putinterval */

/***********************************************************************
**
** This operator is used to push all n elements of array on the operand
** stack successively, and finally push array itself.
**
** TITLE:       op_aload                        Date:   08/01/87
** CALL:        op_aload()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_pk_object:      5.3.1.3.25
***********************************************************************/
fix
op_aload()
{
    ubyte   FAR *l_pointer ;
    ufix16  l_index, l_length ;
    struct  object_def  l_save ;
    struct  object_def  FAR *l_array, huge *l_temp ;

    /* executeonly or noaccess */
    if( ACCESS_OP(0) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if((ufix)FRCOUNT() <= LENGTH_OP(0)) { /* cauesd by opn_stack is 501 @WIN*/
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    l_length = LENGTH_OP(0) ;
    l_array = (struct object_def FAR *)VALUE_OP(0) ;
    COPY_OBJ(GET_OPERAND(0), &l_save) ;     /* save this array object */
    POP(1) ;

    /* push object to operand stack */
    if(TYPE(&l_save) == ARRAYTYPE) {
        for(l_index = 0, l_temp = l_array ; l_index++ < l_length ; l_temp++)
                PUSH_ORIGLEVEL_OBJ((struct object_def FAR *)l_temp) ;
#ifdef  DBG
    printf("ALOAD<level:%d>\n", LEVEL(l_temp)) ;
#endif  /* DBG */
    } else {
        for(l_index = 0, l_pointer = (ubyte FAR *)l_array ; l_index++ < l_length ; )
/* qqq, begin */
            /*
            l_pointer = get_pk_object(l_pointer, &opnstack[opnstktop++], LEVEL(&l_save)) ;
            */
        {
            l_pointer = get_pk_object(l_pointer, opnstkptr, LEVEL(&l_save)) ;
            INC_OPN_IDX();
        }
/* qqq, end */
    }

    PUSH_ORIGLEVEL_OBJ(&l_save) ;

    return(0) ;
}   /* op_aload */

/***********************************************************************
**
** This operator is used to store the object any0 through any(n-1) from
** the operand stack into array, where n is the length of array. The
** Astore_op operator first removes the array operand from the stack and
** determines its length. It then removes that number of objects from
** the stack, storing the topmost one into element n-1 of array and the
** bottonmost one into element 0 of array. Finally, it pushes array back
** on the stack.
**
** TITLE:       op_astore                       Date:   08/01/87
** CALL:        op_astore()                     UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       astore_array:   5.3.1.3.18
***********************************************************************/
fix
op_astore()
{
    struct  object_def  l_save ;

    if( COUNT() <= LENGTH_OP(0) ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( ACCESS_OP(0) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    COPY_OBJ(GET_OPERAND(0), &l_save) ;
    POP(1) ;                                      /* pop array object */

    astore_array(&l_save) ;
    PUSH_ORIGLEVEL_OBJ(&l_save) ;

    return(0) ;
}   /* op_astore */

/***********************************************************************
**
** TITLE:       getinterval_array               Date:   08/01/87
** CALL:        getinterval_array()             UpDate: Jul/12/88
** INTERFACE:   op_getinterval: 5.3.1.3.7
** CALLS:       get_pk_array:   5.3.1.3.26
***********************************************************************/
bool
getinterval_array(p_array, p_index, p_count, p_retobj)
struct  object_def  FAR *p_array, FAR *p_retobj ;
ufix  p_index, p_count ;
{
    struct  object_def  huge *l_temp ;

    /*
    **  index must be a valid index in the original array and
    **  count to be a non-negative integer, and index+count is not
    **  greater than the length of the original array
    */
    if( ((ufix32)p_count + p_index) > LENGTH(p_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (struct object_def huge *)VALUE(p_array) ;

    if(TYPE(p_array) == ARRAYTYPE)
        l_temp += p_index ;
    else
        l_temp = (struct object_def huge *)get_pk_array((ubyte FAR*)l_temp, p_index) ;
   /*
    **  MAKE A NEW OBJECT
    */
    COPY_OBJ(p_array, p_retobj) ;
    VALUE(p_retobj) = (ULONG_PTR)l_temp ;
    /* LEVEL(p_retobj) = current_save_level ; */
    LENGTH(p_retobj) = (ufix16)p_count ;

    return(TRUE) ;
}   /* getinterval_array */

/***********************************************************************
**
** TITLE:       putinterval_array               Date:   08/01/87
** CALL:        putinterval_array()             UpDate: Jul/12/88
** INTERFACE:   op_putinterval:         5.3.1.3.8
**              op_copy:                5.3.1.1.4
** CALLS:       create_new_saveobj:     5.3.1.1.12
**              get_pk_object:          5.3.1.3.25
***********************************************************************/
bool
putinterval_array(p_d_array, p_index, p_s_array)
struct  object_def  FAR *p_s_array, FAR *p_d_array ;
ufix  p_index ;
{
    fix     l_i, l_length ;
    struct  object_def  huge *l_sptr, huge *l_dptr ;

    l_length = LENGTH(p_s_array) ;

    /*
    **  index to be a valid index in array1, index plus the length
    **  of p_d_array is not greater than the length of p_s_array
    */
    /* ?? if overflow */
    if( ((ufix32)p_index + l_length) > LENGTH(p_d_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_dptr = (struct object_def huge *)VALUE(p_d_array) + p_index ;

    l_sptr = (struct object_def huge *)VALUE(p_s_array) ;

    /* SOURCE ARRAY ==> DESTINATION ARRAY */
    if(TYPE(p_s_array) == ARRAYTYPE) {
        /* Apr-29-88 by PJSu, whether save or not */
        /* 10-24-1990 by Erik */
        if ((l_sptr + l_length) < l_dptr) {
            for(l_i = 0 ; l_i < l_length ; l_i++, l_sptr++, l_dptr++) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_dptr) != current_save_level )
                if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                    if(! save_obj(l_dptr) ) return(FALSE) ;
                COPY_OBJ( (struct object_def FAR *)l_sptr,
                          (struct object_def FAR *)l_dptr ) ;
                //DJC UPD046
                LEVEL_SET(l_dptr, current_save_level);
            }   /* for */
        } else {
            l_sptr += l_length - 1 ;
            l_dptr += l_length - 1 ;
            for(l_i = l_length ; l_i > 0 ; l_i--, l_sptr--, l_dptr--) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_dptr) != current_save_level )
                if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                    if(! save_obj(l_dptr) ) return(FALSE) ;
                COPY_OBJ( (struct object_def FAR *)l_sptr,
                          (struct object_def FAR *)l_dptr ) ;
                //DJC UPD046
                LEVEL_SET(l_dptr, current_save_level);
            }   /* for */
        }
    } else {
        for(l_i = 0 ; l_i < l_length ; l_i++, l_dptr++) {
// DJC signed/unsigned mismatch warning
// DJC      if( LEVEL(l_dptr) != current_save_level )
            if( (ufix16)(LEVEL(l_dptr)) != current_save_level )
                if(! save_obj(l_dptr) ) return(FALSE) ;
            l_sptr = (struct object_def huge *)get_pk_object((ubyte FAR*)l_sptr, l_dptr, LEVEL(p_s_array)) ;

            //DJC UPD046
            LEVEL_SET(l_dptr, current_save_level);
        }
    }

    return(TRUE) ;
}   /* putinterval_array */

/***********************************************************************
**
** TITLE:       forall_array                    Date:   08/01/87
** CALL:        forall_array()                  UpDate: Jul/12/88
** INTERFACE:   op_forall:      5.3.1.4.13
***********************************************************************/
bool
forall_array(p_array, p_proc)
struct  object_def  FAR *p_array, FAR *p_proc ;
{
    if( FREXECOUNT() < 3 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_OBJ(p_array) ;
    PUSH_EXEC_OP(AT_ARRAYFORALL) ;

    return(TRUE) ;
}   /* forall_array */

/***********************************************************************
**
** TITLE:       create_array                    Date:   08/01/87
** CALL:        create_array(obj, size)         UpDate: Jul/12/88
** INTERFACE:   op_array:       5.3.1.3.1
** CALLS:       alloc_vm:       5.3.1.10.5
***********************************************************************/
bool
create_array(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix  p_size ;
{
    ubyte   FAR *l_array ;
    ufix16  l_i  ;
    struct  object_def  huge *l_temp ;

    if( p_size != 0 ) {
        l_array = (ubyte FAR *)extalloc_vm( (ufix32)p_size *
                                         sizeof(struct object_def) ) ;
        if(l_array != NIL) {
            l_temp = (struct object_def huge *)l_array ;
            for(l_i=0 ; l_i < p_size ; l_i++, l_temp++) {
                TYPE_SET(l_temp, NULLTYPE) ;
                LEVEL_SET(l_temp, current_save_level) ;
                ROM_RAM_SET(l_temp, RAM) ;

                //UPD057
                P1_ATTRIBUTE_SET( l_temp, P1_LITERAL);
                LENGTH(l_temp) = 0;

            }
        } else
            return(FALSE) ;
    } else
        l_array = NULL_OBJ ;

    TYPE_SET(p_obj, ARRAYTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = (ufix16)p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_array ;

    return(TRUE) ;
}   /* create_array */

/***********************************************************************
**
** This function is used to copy objects from operand stack to
** an empty array.
**
** TITLE:       astore_array                    Date:   08/01/87
** CALL:        astore_array(p_array)           UpDate: Jul/12/88
** INTERFACE:   op_astore:      5.3.1.3.10
***********************************************************************/
bool
astore_array(p_array)
struct  object_def  FAR *p_array ;
{
    ufix16  l_length, l_i ;

    l_i = l_length = LENGTH(p_array) ;
    while (l_length--) {
          put_array(p_array, --l_i, GET_OPERAND(0)) ;
          POP(1) ;
    }

    return(TRUE) ;
}   /* astore_array */

/***********************************************************************
**
** TITLE:       get_array                   Date:   08/01/87
** CALL:        get_array()                 UpDate: Jul/12/88
** PARAMETERS:
** INTERFACE:   op_get:             5.3.1.4.9
** CALLS:       get_pk_array:       5.3.1.3.26
**              get_pk_object:      5.3.1.3.25
***********************************************************************/
bool
get_array(p_array, p_index, p_any)
struct  object_def  FAR *p_array, FAR *p_any ;
ufix  p_index ;
{
    struct  object_def  huge *l_temp ;

    l_temp = (struct object_def huge *)VALUE(p_array) ;

    if(TYPE(p_array) == ARRAYTYPE) {
        l_temp += p_index ;
        COPY_OBJ( (struct object_def FAR *)l_temp, p_any ) ;
    } else
        get_pk_object(get_pk_array((ubyte FAR *)l_temp, p_index), p_any,
                                   LEVEL(p_array)) ;

    return(TRUE) ;
}   /* get_array */

/***********************************************************************
**
** TITLE:       put_array                   Date:   08/01/87
** CALL:        put_array()                 UpDate: Jul/12/88
** INTERFACE:   op_put:     5.3.1.4.10
***********************************************************************/
bool
put_array(p_array, p_index, p_any)
struct  object_def  FAR *p_array, FAR *p_any ;
ufix  p_index ;
{
    struct  object_def  huge *l_temp ;

    /*  readonly ? executeonly ? noaccess ? */
    if( ACCESS(p_array) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    /* the index is greater than the array length */
    if( p_index >= LENGTH(p_array) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (struct object_def huge *)VALUE(p_array) + p_index ;
// DJC signed/unsigned mismatch warning
// DJC if( LEVEL(l_temp) != current_save_level )
    if( (ufix16)(LEVEL(l_temp)) != current_save_level )
        if(! save_obj(l_temp) ) return(FALSE) ;
    COPY_OBJ( p_any, (struct object_def FAR *)l_temp ) ;
    LEVEL_SET(l_temp, current_save_level) ;

    return(TRUE) ;
}   /* put_array */

/***********************************************************************
**
** TITLE:       op_setpacking               Date:   08/01/87
** CALL:        op_setpacking()             UpDate: Jul/12/88
** INTERFACE:   interpreter:
** History: Add compile option for NO packing, 11-24-88
***********************************************************************/
fix
op_setpacking()
{
#ifdef  NOPK
    packed_flag = (bool8)FALSE ;
#else
    packed_flag = (bool8)VALUE_OP(0) ;
#endif  /* NOPK */
    POP(1) ;

    return(0) ;
}   /* op_setpacking */

/***********************************************************************
**
** TITLE:       op_currentpacking           Date:   08/01/87
** CALL:        op_currentpacking()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_currentpacking()
{
    if( FRCOUNT() < 1  )
        ERROR(STACKOVERFLOW) ;
    else {
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, (ufix32)packed_flag) ;
    }

    return(0) ;
}   /* op_currentpacking */

/***********************************************************************
**
** TITLE:       op_packedarray              Date:   08/01/87
** CALL:        op_packedarray()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_pk_array:    5.3.1.3.24
***********************************************************************/
fix
op_packedarray()
{
#ifndef NOPK
    ufix16  l_n ;
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXARYCAPSZ) ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    l_n = (ufix16)VALUE_OP(0) ;
// DJC signed/unsigned mismatch
// DJC    if( l_n > COUNT() - 1 ) {
    if( l_n > (ufix16)(COUNT() - 1 )) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    /*
     *  this operand must be a non-negative integer and not greater
     *  than the maximum allowable array length
     */
    if( create_pk_array(&l_save, (ufix16)l_n) ) {
        POP(l_n + 1) ;
        PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }
#endif  /* NOPK */

    return(0) ;
}   /* op_packedarray */

/***********************************************************************
**
** THis function is used to create a packed array with n objects.
**
** TITLE:       create_pk_array                  Date:   08/01/87
** CALL:        create_pk_array()                UpDate: Jul/12/88
** INTERFACE:   op_packedarray:     5.3.1.3.23
***********************************************************************/
bool
create_pk_array(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix16  p_size ;
{
    fix     l_objsize ;
    ufix16  l_i ;
    ULONG_PTR   l_value;
    ufix32  l_vmsize, l_j ;
    ubyte   huge *l_array, huge *l_pointer ;

    if(p_size == 0)
        l_array = NULL_OBJ ;
    else {
        l_vmsize = 0 ;
        for(l_i=p_size ; l_i>0 ; l_i-- ) {   /* l_i > 0 */
            l_value = VALUE_OP(l_i) ;
            switch(TYPE_OP(l_i)) {
                case INTEGERTYPE:
                    if( ((fix32)l_value < -1) ||        /* ?? 0 ~ 31 */
                        ((fix32)l_value > 18) ) {
                        l_objsize = PK_C_SIZE ;
                        break ;
                    }
                case BOOLEANTYPE:
                    l_objsize = PK_A_SIZE ;
                    break ;

                case NAMETYPE:
                case OPERATORTYPE:
                    l_objsize = PK_B_SIZE ;
                    break ;

                case REALTYPE:
                case NULLTYPE:
                case FONTIDTYPE:
                case MARKTYPE:
                case SAVETYPE:
                    l_objsize = PK_C_SIZE ;
                    break ;

                default:
                    l_objsize = PK_D_SIZE ;

            }   /* switch */
            l_vmsize += l_objsize ;
        }   /* for */
        l_array = (ubyte huge *)extalloc_vm(l_vmsize) ;

        if( (l_array != NIL) ) {
            /*
             *   BUILD 'ary_obj'
             */
            l_pointer = l_array ;
            for(l_j=0 ; l_j < l_vmsize ; l_j++)   /* initialize */
                *l_pointer++ = 0 ;

            l_pointer = l_array ;
            for(l_i=p_size ; l_i>0 ;l_i-- ) {  /* l_i > 0 */
                l_value = VALUE_OP(l_i) ;
                switch(TYPE_OP(l_i)) {

                /* A_TYPE */
                    case INTEGERTYPE:
                        if( ((fix32)l_value < -1) ||
                            ((fix32)l_value > 18) ) {
                            ubyte       huge *l_stemp, huge *l_dtemp ;
                            *l_pointer++ = (ubyte)LINTEGERPACKHDR ;
                            l_stemp = (ubyte huge *)&l_value ;   /*@WIN*/
                            l_dtemp = l_pointer ;
                            COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def) ;
                            l_pointer += (PK_C_SIZE - 1) ;
                            break ;
                        }
                        l_value++ ;
                        *l_pointer++ = (ubyte)(l_value | SINTEGERPACKHDR);//@WIN
                        break ;
                    case BOOLEANTYPE:
                        *l_pointer++ = (ubyte)(l_value | BOOLEANPACKHDR);//@WIN
                        break ;

                /* B_TYPE */
                    case NAMETYPE:
                        *l_pointer = (ubyte)(l_value >> 8) ;
                        if(ATTRIBUTE_OP(l_i) == LITERAL)
                            *l_pointer++ |= (ubyte)LNAMEPACKHDR ;
                        else
                            *l_pointer++ |= (ubyte)ENAMEPACKHDR ;
                        *l_pointer++ = (ubyte)l_value ;
                        break ;

                    case OPERATORTYPE:
                        *l_pointer = (ubyte)(LENGTH_OP(l_i) >> 8) ;
                        *l_pointer++ |= (ubyte)SYSOPERATOR ; /* systemdict */
                        *l_pointer++ = (ubyte)LENGTH_OP(l_i) ;
                        break ;

                /* C_TYPE */
                    case REALTYPE:
                        *l_pointer = (ubyte)REALPACKHDR ;
                        goto label_c ;
                    case NULLTYPE:
                        *l_pointer = (ubyte)NULLPACKHDR ;
                        goto label_c ;
                    case FONTIDTYPE:
                        *l_pointer = (ubyte)FONTIDPACKHDR ;
                        goto label_c ;
                    case MARKTYPE:
                        *l_pointer = (ubyte)MARKPACKHDR ;
   label_c:
                    {
                        ubyte   huge *l_stemp, huge *l_dtemp ;

                        l_stemp = (ubyte huge *)&l_value ;      /*@WIN*/
                        l_dtemp = ++l_pointer ;
                        COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
                        l_pointer += (PK_C_SIZE - 1) ;
                        break ;
                    }

                /* D_TYPE */
                    case SAVETYPE:
                        *l_pointer = (ubyte)SAVEPACKHDR ;
                        goto label_d ;
                    case ARRAYTYPE:
                        *l_pointer = (ubyte)ARRAYPACKHDR ;
                        goto label_d ;
                    case PACKEDARRAYTYPE:
                        *l_pointer = (ubyte)PACKEDARRAYPACKHDR ;
                        goto label_d ;
                    case DICTIONARYTYPE:
                        *l_pointer = (ubyte)DICTIONARYPACKHDR ;
                        goto label_d ;
                    case FILETYPE:
                        *l_pointer = (ubyte)FILEPACKHDR ;
                        goto label_d ;
                    case STRINGTYPE:
                        *l_pointer = (ubyte)STRINGPACKHDR ;
   label_d:
                    {
                        ubyte   huge *l_stemp, huge *l_dtemp ;

                        l_stemp = (ubyte FAR *)GET_OPERAND(l_i) ;
                        l_dtemp = ++l_pointer ;
                        COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def ) ;
                        l_dtemp = l_pointer ;
                        LEVEL_SET_PK_OBJ(l_dtemp, current_save_level) ;

                        l_pointer += (PK_D_SIZE - 1) ;
                    }
                }   /* switch */
            }   /* for */
        } else
            return(FALSE) ;             /* VMERROR */
    }   /* else */

    TYPE_SET(p_obj, PACKEDARRAYTYPE) ;
    ACCESS_SET(p_obj, READONLY) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_array ;

    return(TRUE) ;
}   /* create_pk_array */

/***********************************************************************
**
** This function is used to get an ordinary object that is encoding from
** a packed object, and it returns an address of next packed object.
**
** TITLE:       get_pk_object                    Date:   08/01/87
** CALL:        get_pk_object                    UpDate: Jul/12/88
** INTERFACE:   putinterval_array:  5.3.1.3.14
**              get_array:          5.3.1.3.19
**              op_aload:           5.3.1.3.9
**              op_get:             5.3.1.4.9
***********************************************************************/
ubyte
FAR *get_pk_object(p_position, p_retobj, p_level)
 ubyte   FAR *p_position ;
 ufix    p_level ;
struct  object_def  FAR *p_retobj ;
{
    ufix16  l_attribute, l_length ;
    ULONG_PTR  l_value ;
    ufix16  l_type = 0 ;

    ROM_RAM_SET(p_retobj, RAM) ;

    /* initialize */
    l_attribute = LITERAL ;
    l_length = 0 ;

    switch(*p_position & 0xE0) {
        case SINTEGERPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f)  ;
            l_value-- ;
            l_type = INTEGERTYPE ;
            break ;

        case BOOLEANPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) ;
            l_type = BOOLEANTYPE ;
            break ;

        case LNAMEPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) << 8 ;
            l_value |= *p_position++ ;
            l_type = NAMETYPE ;
            break ;

        case ENAMEPACKHDR:
            l_value = (ULONG_PTR)(*p_position++ & 0x1f) << 8 ;
            l_value |= *p_position++ ;
            l_attribute = EXECUTABLE ;
            l_type = NAMETYPE ;
            break ;

        case OPERATORPACKHDR:
            l_length = (ufix16)(*p_position++ & 0x07) << 8 ;
            l_length |= *p_position++ ;
            l_attribute = EXECUTABLE ;
            l_value = (ULONG_PTR)VALUE(&systemdict_table[l_length]) ;
            l_type = OPERATORTYPE ;
            break ;

        case _5BYTESPACKHDR:
            switch(*p_position) {
                case LINTEGERPACKHDR:
                    l_type = INTEGERTYPE ;
                    goto label_c ;
                case REALPACKHDR:
                    l_type = REALTYPE ;
                    goto label_c ;
                case FONTIDPACKHDR:
                    l_type = FONTIDTYPE ;
                    goto label_c ;
                case NULLPACKHDR:
                    l_type = NULLTYPE ;
                    goto label_c ;
                case MARKPACKHDR:
                    l_type = MARKTYPE ;
            }   /* switch */
label_c:
        {
            ubyte   huge *l_stemp, huge *l_dtemp ;

            l_stemp = ++p_position ;
            l_dtemp = (ubyte huge *)&l_value ;  /*@WIN*/
            COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
            p_position += (PK_C_SIZE - 1) ;
            break ;
        }

        default:
        {
            ubyte   huge *l_stemp, huge *l_dtemp ;

            l_stemp = ++p_position ;
            l_dtemp = (ubyte FAR *)p_retobj ;
            COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def) ;
            p_position += (PK_D_SIZE - 1) ;
            return(p_position) ;
        }
    }   /* switch */

    TYPE_SET(p_retobj, l_type) ;
    ATTRIBUTE_SET(p_retobj, l_attribute) ;
    LEVEL_SET(p_retobj, p_level) ;
    ACCESS_SET(p_retobj, 0) ;
    LENGTH(p_retobj) = l_length ;
    VALUE(p_retobj) = l_value ;

    return(p_position) ;
}   /* get_pk_object */

/***********************************************************************
**
** This function is used to get the address of the nth object
** of a packedarray.
**
** TITLE:       get_pk_array                     Date:   08/01/87
** CALL:        get_pk_array                     UpDate: Jul/12/88
** INTERFACE:   getinterval_array:  5.3.1.3.13
**              get_array:          5.3.1.3.19
**              op_get:             5.3.1.4.9
***********************************************************************/
ubyte
FAR *get_pk_array(p_position, p_index)
 ubyte   FAR *p_position ;
 ufix  p_index ;
{
    ufix16  l_i ;
    ufix32  l_objsize ;

    for(l_i= 0 ; l_i < p_index ; l_i++) {
        switch(*p_position & 0xE0) {
            case SINTEGERPACKHDR:
            case BOOLEANPACKHDR:
                l_objsize = PK_A_SIZE ;
                break ;

            case LNAMEPACKHDR:
            case ENAMEPACKHDR:
            case OPERATORPACKHDR:
                l_objsize = PK_B_SIZE ;
                break ;

            case LINTEGERPACKHDR:
            case REALPACKHDR:
            case FONTIDPACKHDR:
            case NULLPACKHDR:
            case MARKPACKHDR:
                l_objsize = PK_C_SIZE ;
                break ;

            default:
                l_objsize = PK_D_SIZE ;
        }   /* switch */
        p_position += l_objsize ;
    }   /* for(l_i) */

    return(p_position) ;
}   /* get_pk_array */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\async.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
**********************************************************************
*  File:        ASYNC.C
*
*  History:
**********************************************************************
*/
/*
*   Function:
*       init_asyncio
*       check_interrupt     ?? current port
*       check_Control_C
*       ctrlC_report
*       stdingetc           ?? delete
*       getline
*       linegetc
*       getstatement
*       statementgetc
*       set_echo
*       reset_cookbuf
*       line_editor
*       stmt_editor
*       kputc
*       kgetc
*       kskipc
*       echo_a_char
*       echo_BS
*       echo_ctrlR
*       kskipc
*       kskipc
*/


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>
#include    <string.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geierr.h"
#include    "language.h"
#include    "file.h"

/* special chars */
#define         Crtl_C_Char     3
#define         EOF_Char        -1
#define         BELL_Char       7
#define         BS_Char         8
#define         NL_Char         10
#define         CR_Char         13
#define         Crtl_R_Char     18
#define         Crtl_U_Char     21
#define         US_Char         31
#define         DEL_Char        127

/* define variables */
static  fix16   cook_head = 0 ;
static  fix16   cook_tail = 0 ;
static  fix16   cook_count = 0 ;
static  fix16   line_head = 0 ;
static  fix16   line_count = 0 ;

static  fix16   echo_flag = 0 ;
static  fix16   line_del = 0 ;
static  fix16   stmt_del = 0 ;

static  fix16   lpair = 0 ;          /* indicator for { } pair */
static  fix16   spair = 0 ;          /* indicator for ( ) pair */
static  fix16   hpair = 0 ;          /* indicator for < > pair */
static  fix16   comment_flag = 0 ;   /* indicator for % */
static  fix16   bslash_flag = 0 ;    /* indicator for \ */

static  fix16   crlf_flag = 0 ;

#define         MAXCOOKBUFSZ    4096

static  byte    far * near cookbuf ; /* for fardata version */

#define         NL_TERM         0
#define         EOF_TERM        1
static  byte    near NL_or_EOF ;

extern  bool16  int_flag ;
extern  bool16  eable_int ;
extern  bool16  chint_flag ;

#ifdef LINT_ARGS
   static  fix   near  line_editor(byte) ;
   static  bool  near  stmt_editor(byte) ;
   static  void  near  echo_a_char(byte) ;
   static  void  near  echo_crtlR(void) ;
   static  void  near  echo_BS(void) ;
   static  void  near  kputc(byte) ;
   static  fix16 near  kgetc(void) ;
   static  void  near  kskipc(void) ;
#else
   static  fix   near  line_editor() ;
   static  bool  near  stmt_editor() ;
   static  void  near  echo_a_char() ;
   static  void  near  echo_crtlR() ;
   static  void  near  echo_BS() ;
   static  void  near  kputc() ;
   static  fix16 near  kgetc() ;
   static  void  near  kskipc() ;
#endif /* LINT_ARGS */

/*
       **********************************
       *                                *
       *  init & close serial I/O port  *
       *                                *
       **********************************
*/
/*
**********************************************************************
*   Name:       init_sio
*   Called:
*   Calling:
**********************************************************************
*/
void
init_asyncio()
{
    cookbuf = fardata((ufix32)MAXCOOKBUFSZ) ;
} /* init_sio */

/*
**********************************************************************
*   Name:       check_interrupt
*   Called:
*   Calling:
*
*   Output:     bool
**********************************************************************
*/
bool
check_interrupt()
{
    fix16  flag ;

    flag = int_flag && eable_int ;

    if (flag) {
        GEIio_write(GEIio_stdout, "^C\n", 3) ;
        GEIio_flush(GEIio_stdout) ;
        int_flag = 0 ;
        chint_flag = flag ;
    }

    //return(flag) ;            @WIN; always no interrupt
    return 0;
}   /* check_interrupt */

/*
**********************************************************************
*   Name:       check_Control_C
*   Called:
*   Calling:    -
*
*   Output:     bool
**********************************************************************
*/
bool
check_Control_C()
{
    return(int_flag && eable_int) ;
}   /* check_Control_C */

/*
**********************************************************************
*   Name:       ctrlC_report
*   Called:
*   Calling:    -
*
**********************************************************************
*/
void
ctrlC_report()
{
    int_flag = TRUE ;

    return ;
}   /* ctrlC_report */

/*
**********************************************************************
*
*   This module get a line from the cook buffer.
*         nchar > 0 : OK and return number of character in line,
*                     line delimiter is newline
*         nchar = 0 : no line
*         nchar < 0 : OK and return number of character in line,
*                     line delimiter is Control-D
*
*   Name:       getline
*   Called:
*   Calling:    stream_input
*               line_editor
*               reset_cookbuf
*               create_string
*               strncpy
*
*   Input:      fix16 *
*   Output:     bool
*
*   ?? ^C, ^D, CR
**********************************************************************
*/
bool
getline(nbyte)
fix  FAR *nbyte ;
{
    byte   c1 ;
    struct object_def   l_obj ;

    if (line_del) {
        if (NL_or_EOF == NL_TERM)
            *nbyte = cook_count ;
        else
            *nbyte = -cook_count ;
        return(TRUE) ;
    } else {
        /* ?? Big Change */
        /* Can we get ^C */
        for( ; ;) {
            if( c1 = GEIio_getc(GEIio_stdin) ) {
                switch(line_editor((byte)(c1 & 0xFF))) {
                case 0:             /* edit command char */
                    continue ;

                case 1:             /* NL, CR, or ^C(??) */
                    line_del++ ;
                    NL_or_EOF = NL_TERM ;
                    *nbyte = cook_count ;
                    return(TRUE) ;

                case 2:             /* S/W IOERROR */
                    reset_cookbuf() ;
                    return(FALSE) ;

                case 3:
                    NL_or_EOF = EOF_TERM ;
                    *nbyte = -cook_count ;
                    if (cook_count)
                        line_del++ ;
                    return(TRUE) ;

                case 4:         /* ERROR */
                    break ;
                }   /* switch */
            }

            /*
            * timeout
            * ioerror
            * EOF
            */
            if( ! ANY_ERROR() ) {
                if(cook_count) {
                    line_del++ ;
                    *nbyte = -cook_count ;
                } else
                    *nbyte = 0 ;
                return(TRUE) ;               /* ?? EOF */
            }

            reset_cookbuf() ;
            if( ANY_ERROR() == TIMEOUT ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if (create_string(&l_obj, (ufix16)7)) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            }
            /* ?? need close file */
            return(TRUE) ;
        }   /* for */
    }
}   /* getline */

/*
**********************************************************************
*
*   This module get a char from the cook buffer.
*   The return integer is used as the following descriptions:
*
*            c = -1 : no character in line
*            c = ASCII code (low byte)
*
*   Name:       linegetc
*   Called:
*   Calling:    kgetc
*               reset_cookbuf
*
*   Output:     fix16
*
**********************************************************************
*/
fix16
linegetc()
{
    fix16  c ;

    if (line_del) {
        c = kgetc() ;
        if (!cook_count) {
            line_del-- ;
            reset_cookbuf() ;
        }
        return(c) ;
    } else
        return(-1) ;
}   /* linegetc */

/*
**********************************************************************
*
*   This module get a statement from the cook buffer.
*         nchar > 0 : OK and return number of character in line,
*                     line delimiter is newline
*         nchar = 0 : no line
*         nchar < 0 : OK and return number of character in line,
*                     line delimiter is Control-D
*
*   Name:       getstatement
*   Called:
*   Calling:    stream_input
*               stmt_editor
*               reset_cookbuf
*               create_string
*               strncpy
*
*   Input:      fix *
*   Output:     bool
*
*   ?? ^C, ^D, CR
**********************************************************************
*/
bool
getstatement(nbyte)
fix  FAR *nbyte ;
{
    byte   c1 ;
    struct object_def   l_obj ;

    if (stmt_del) {
        if (NL_or_EOF == NL_TERM)
            *nbyte = cook_count ;
        else
            *nbyte = -cook_count ;
        return(TRUE) ;
    } else {
        for( ; ;) {
            if( c1 = GEIio_getc(GEIio_stdin) ) {
                switch(stmt_editor((byte)(c1 & 0xFF))) {
                case 0:             /* edit command char/special char */
                    continue ;

                case 1:             /* NL, CR, or ^C(flag ??) */
                    stmt_del++ ;
                    NL_or_EOF = NL_TERM ;
                    *nbyte = cook_count ;
                    return(TRUE) ;

                case 2:             /* S/W IOERROR */
                    reset_cookbuf() ;
                    return(FALSE) ;

                case 3:
                    NL_or_EOF = EOF_TERM ;
                    *nbyte = -cook_count ;
                    if (cook_count)
                        stmt_del++ ;
                    return(TRUE) ;

                case 4:         /* ERROR */
                    break ;
                }   /* switch */
            }

            /*
            * timeout
            * ioerror
            * EOF
            */
            if( ! ANY_ERROR() ) {
                if(cook_count) {
                    stmt_del++ ;
                    *nbyte = -cook_count ;
                } else
                    *nbyte = 0 ;
                return(TRUE) ;
            }

            reset_cookbuf() ;
            if( ANY_ERROR() == TIMEOUT ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if (create_string(&l_obj, (ufix16)7)) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            }
            /* ?? need close file */
            return(FALSE) ;
        }   /* for */
    }   /* else */
}   /* getstatement */

/*
**********************************************************************
*
*   This module get a char from the cook buffer.
*   The return integer is used as the following descriptions:
*
*            c = -1 : no character in line
*            c = ASCII code (low byte)
*
*   Name:       statementgetc
*   Called:
*   Calling:    kgetc
*               reset_cookbuf
*
*   Output:     fix16
**********************************************************************
*/
fix16
statementgetc()
{
    fix16  c ;

    if (stmt_del) {
        c = kgetc() ;
        if (!cook_count) {
            stmt_del-- ;
            reset_cookbuf() ;
        }
        return(c) ;
    } else
        return(-1) ;
}   /* statementgetc */

/*
**********************************************************************
*
*   This module is used to set/reset the echo mode.
*
*            mode = 0 :  no echo
*            mode != 0 : echo
*
*   Name:       set_echo
*   Called:
*   Calling:    -
*
*   Input:      bool16
**********************************************************************
*/
void
set_echo(mode)
bool16  mode ;
{
    echo_flag = mode ;

    return ;
}   /* set_echo */

/*
**********************************************************************
*   Name:       reset_cookbuf
*   Called:
*   Calling     -
**********************************************************************
*/
void
reset_cookbuf()
{
    cook_head = cook_tail = line_head = 0 ;
    cook_count = line_count = 0 ;
    lpair = spair = hpair = 0 ;
    comment_flag = bslash_flag = 0 ;

    return ;
}   /* reset_cookbuf */

/*
       *******************************************
       *                                         *
       *  editor related manipulation routines   *
       *                                         *
       *******************************************
*/
/*
**********************************************************************
*   Name:       line_editor
*   Called:
*   Calling:    kputc
*               echo_ctrlR
*               echo_BS
*               kskipc
*               echo_a_char
*
*   Input:      byte
*   Output:     fix
*
*   c != ^C  &&  c != ^D
**********************************************************************
*/
static fix near
line_editor(c)
byte  c ;
{
    switch (c) {
    case Crtl_C_Char :
            if(check_interrupt()) {
                reset_cookbuf();
            }
            kputc((byte)NL_Char) ;
            return(1) ;

    case Crtl_R_Char :
            echo_crtlR() ;
            break ;
    case Crtl_U_Char :
            while( line_count ) {
                echo_BS() ;
                kskipc() ;
            }
            break ;
    case BS_Char :
    case DEL_Char :
            echo_BS() ;
            kskipc() ;
            break ;

    default :
            if (c == NL_Char && crlf_flag) {
                crlf_flag = 0 ;
                return(0) ;
            } else crlf_flag = 0 ;

            if( c == CR_Char ) {
                c = NL_Char ;
                crlf_flag = 1 ;
            }

            if( GEIio_eof(GEIio_stdin) )
                return(3) ;

            kputc(c) ; echo_a_char(c) ;

            if ( c == NL_Char && cook_tail > 1 )
                return(1) ;
            else if (cook_tail > MAXCOOKBUFSZ) {
                ERROR(IOERROR) ;
                return(2) ;
            }
    } /* switch */

    return(0) ;
}   /* line_editor */

/*
**********************************************************************
*   Name:       stmt_editor
*   Called:
*   Calling:    kputc
*               echo_ctrlR
*               echo_BS
*               kskipc
*               echo_a_char
*
*   Input:      byte
*   Output:     bool
*
*   ?? ^C, ^D, CR
*   c != ^C  &&  c != ^D
**********************************************************************
*/
static fix near
stmt_editor(c)
byte  c ;
{
    switch (c) {
    case Crtl_C_Char :
            if(check_interrupt()) {
                reset_cookbuf();
            }
            kputc((byte)NL_Char) ;
            return(1) ;

    case Crtl_R_Char :
            echo_crtlR() ;
            break ;

    case Crtl_U_Char :
            while (line_count) {
                echo_BS() ;
                kskipc() ;
            }
            break ;

    case BS_Char :
    case DEL_Char :
            if( cook_count && (cookbuf[cook_tail - 1] == NL_Char) ) {
                fix16  i, back ;

                kskipc() ;
                back = cook_tail - 1 ;
                while (1) {
                    if (back == cook_head)
                        break ;
                    else if( cookbuf[back] == NL_Char ) {
                        back++ ; break ;
                    } else
                        back-- ;
                }   /* while */
                GEIio_putc(GEIio_stdout, NL_Char) ;
                for (i = back ; i < cook_tail ; i++)
                    echo_a_char(cookbuf[i]) ;
                line_count = cook_tail - back ;
                line_head = back ;
            } else {
                echo_BS() ; kskipc() ;
            }
            break ;

    default:
            if (c == NL_Char && crlf_flag) {
                crlf_flag = 0 ;
                return(0) ;
            } else crlf_flag = 0 ;

            if( c == CR_Char ) {
                c = NL_Char ;
                crlf_flag = 1 ;
            }

            if( GEIio_eof(GEIio_stdin) )
                return(3) ;

            kputc(c) ; echo_a_char(c) ;

            if (cook_tail > MAXCOOKBUFSZ) {
                ERROR(IOERROR) ;
                return(2) ;
            }
            if (hpair) {
                switch (c) {
                case '>' :
                     hpair-- ;
                     break ;
                case NL_Char:
                     line_count = 0 ;
                     line_head = cook_tail ;
                     break ;
                default :
                     if (!ISHEXDIGIT(c) && !ISWHITESPACE(c))
                        hpair-- ;
                     break ;
                } /* switch */
            } else {
                switch (c) {
                case '(' :
                    if (!comment_flag && !bslash_flag)
                        spair++ ;
                    break ;
                case ')' :
                    if (!comment_flag && !bslash_flag)
                        spair-- ;
                    break ;
                case '{' :
                    if (spair <= 0 && !comment_flag)
                        lpair++ ;
                    break ;
                case '}' :
                    if (spair <= 0 && !comment_flag)
                        lpair-- ;
                    break ;
                case '<' :
                    if (spair <= 0 && !comment_flag)
                        hpair++ ;
                    break ;
                case '%' :
                    if (spair <= 0 && !comment_flag)
                        comment_flag++ ;
                    break ;
                case '\\' :
                    if (!comment_flag && spair && !bslash_flag)
                        bslash_flag += 2 ;
                    break ;
                case '\f' :
                    if (comment_flag)
                        comment_flag-- ;
                    break ;
                case NL_Char:
                    if (comment_flag)
                        comment_flag-- ;
                    if (lpair <= 0 && spair <= 0)
                        return(1) ;
                    else {
                        line_count = 0 ;
                        line_head = cook_tail ;
                    }
                default :
                    break ;
                } /* switch */
                if (bslash_flag)
                    bslash_flag-- ;
            }   /* else */
    }   /* switch */

    return(0) ;
} /* stmt_editor */

/*
**********************************************************************
*   Name:       kputc
*   Called:
*   Calling:
**********************************************************************
*/
static void near
kputc(c)
byte  c ;
{
    if (cook_tail <= MAXCOOKBUFSZ) {
        cookbuf[cook_tail++] = c ;
        cook_count++ ; line_count++ ;
    }

    return ;
}   /* kputc */

/*
**********************************************************************
*   Name:       kgetc
*   Called:
*   Calling:    -
**********************************************************************
*/
static fix16 near
kgetc()
{
    if (cook_count) {
        cook_count-- ;
        return(cookbuf[cook_head++]) ;
    } else
        return(-1) ;
} /* kgetc */

/*
**********************************************************************
*   Name:       kskipc
*   Called:
*   Calling:    -
**********************************************************************
*/
static void near
kskipc()
{
    byte  c ;

    if (cook_count) {
        c = cookbuf[cook_tail - 1] ;
        switch (c) {
        case '{' :
            if (!spair)
                lpair-- ;
            break ;
        case '}' :
            if (!spair)
                lpair++ ;
            break ;
        case '(' :
        case ')' :
        {
            fix16  i, j, k ;
            if (cook_count > 1 && cookbuf[cook_tail - 2] == '\\') {
                for (i = cook_head, j = cook_tail - 1, k = 0 ; i < j ; i++)
                    if (cookbuf[i] == '(')
                        k++ ;
                if (!k) {
                    if (c == '(')
                        spair-- ;
                    else
                        spair++ ;
                }
            } else {
                if (c == '(')
                    spair-- ;
                else
                    spair++ ;
            }
            break ;
        }
        case '<' :
            if (!spair)
                hpair-- ;
        default :
            break ;
        }   /* switch */
        cook_tail-- ;
        cook_count-- ; line_count-- ;
    }

    return ;
}   /* kskipc */

/*
**********************************************************************
*   Name:       echo_a_char
*   Called:
*
*   Input:      byte
**********************************************************************
*/
static void near
echo_a_char(c)
byte  c ;
{
    if (echo_flag) {
        if (c == EOF_Char)
            return ;
        if ( ((ubyte)c > US_Char) || (c == '\t') || (c == '\n') )
            GEIio_putc(GEIio_stdout, c) ;
        else {
            c = c + (byte)64 ;          //@WIN
            GEIio_putc(GEIio_stdout, '^') ;
            GEIio_putc(GEIio_stdout, c) ;
        }
        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_a_char */

/*
**********************************************************************
*   Name:       echo_BS
*   Called:
**********************************************************************
*/
static void near
echo_BS()
{
    byte  c ;

    if (echo_flag) {
        if (line_count) {
            if ((c = cookbuf[cook_tail - 1]) > US_Char || c == '\t') {
                GEIio_write(GEIio_stdout, "\010 \010", 3) ;
            } else {         /* control chars */
                GEIio_write(GEIio_stdout, "\010 \010\010 \010", 6) ;
            }
        } else
            GEIio_putc(GEIio_stdout, BELL_Char) ;

        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_BS */

/*
**********************************************************************
*   Name:       echo_ctrlR
*   Called:
*               echo_a_char
**********************************************************************
*/
static void near
echo_crtlR()
{
    fix16  i, j ;

    if (echo_flag) {
        GEIio_putc(GEIio_stdout, NL_Char) ;
        for (i = 0, j = line_head ; i < line_count ; i++, j++)
            echo_a_char(cookbuf[j]) ;

        GEIio_flush(GEIio_stdout) ;
    }

    return ;
}   /* echo_crtlR */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\com.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              COM.H
 *      Author:                 Jonesw
 *      Owner:                  Microsoft Co.
 *      Description: header file for communication operators
 *
 * revision history:
 ************************************************************************
 */
#define B0              0
#define B110            110
#define B300            300
#define B600            600
#define B1200           1200
#define B2400           2400
#define B4800           4800
#define B9600           9600
#define B19200          19200
#define B38400          38400
#define B57600          57600

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\com.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              COM.C
 *      Author:                 Jones
 *      Date:                   11/20/90
 *      Owner:                  Microsoft Co.
 *      Description: this file contains communication operators
 *
 * revision history:
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        "global.ext"
#include        "language.h"
#include        "geiioctl.h"
#include        "com.h"
#include        "geipm.h"
#include        "geisig.h"
#include        <string.h>

#ifdef  _AM29K
extern unsigned char         sccbatch_set ;
#endif

fix
st_setsccbatch()
{
    GEIioparams_t     ioparams ;
    fix8              l_options ;
    ufix8             l_byte ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_options = (ufix8)VALUE_OP(0) ;
    /*
    if ((l_options ==0) || (l_options ==3) ||
       (l_options ==7) || (l_options ==67))
       l_options = 64;
    */
#ifdef  _AM29K
    ioparams.u.s.parity=l_options & 0x03 ;
    ioparams.u.s.flowcontrol=(l_options & 0x0C)>>2 ;
    ioparams.u.s.stopbits=(l_options & 0x80)>>7 ;
    ioparams.u.s.databits=(l_options & 0x60)>>5 ;
    ioparams.u.s.baudrate= (ufix8)VALUE_OP(1) ;
#else
    ioparams.s.parity=(unsigned char)(l_options & 0x03);           //@WIN
    ioparams.s.flowcontrol=(unsigned char)((l_options & 0x0C)>>2); //@WIN
    ioparams.s.stopbits=(unsigned char)((l_options & 0x80)>>7);    //@WIN
    ioparams.s.databits=(unsigned char)((l_options & 0x60)>>5);    //@WIN
    ioparams.s.baudrate= (ufix8)VALUE_OP(1) ;
#endif

     switch ((ufix16)VALUE_OP(1)) {
#ifdef  _AM29K
        case B0:
            ioparams.u.s.baudrate=0 ;
            break ;
        case B110:
            ioparams.u.s.baudrate=1 ;
            break ;
        case B300:
            ioparams.u.s.baudrate=2 ;
            break ;
        case B1200:
            ioparams.u.s.baudrate=3 ;
            break ;
        case B2400:
            ioparams.u.s.baudrate=4 ;
            break ;
        case B4800:
            ioparams.u.s.baudrate=5 ;
            break ;
        case B9600:
            ioparams.u.s.baudrate=6 ;
            break ;
        case B19200:
            ioparams.u.s.baudrate=7 ;
            break ;
        case B38400:
            ioparams.u.s.baudrate=8 ;
            break ;
        case B57600:
            ioparams.u.s.baudrate=9 ;
            break ;
#else
        case B0:
            ioparams.s.baudrate=0 ;
            break ;
        case B110:
            ioparams.s.baudrate=1 ;
            break ;
        case B300:
            ioparams.s.baudrate=2 ;
            break ;
        case B1200:
            ioparams.s.baudrate=3 ;
            break ;
        case B2400:
            ioparams.s.baudrate=4 ;
            break ;
        case B4800:
            ioparams.s.baudrate=5 ;
            break ;
        case B9600:
            ioparams.s.baudrate=6 ;
            break ;
        case B19200:
            ioparams.s.baudrate=7 ;
            break ;
        case B38400:
            ioparams.s.baudrate=8 ;
            break ;
        case B57600:
            ioparams.s.baudrate=9 ;
            break ;
#endif
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */

    switch (VALUE_OP(2)) {
        case 9:
//          GEIpm_ioparams_write("%SERIAL9%",(char *)&ioparams,1) ; @WIN; wrong cast
            GEIpm_ioparams_write("%SERIAL9%",&ioparams,1) ;
            break ;
        case 25:
//          GEIpm_ioparams_write("%SERIAL25%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_write("%SERIAL25%",&ioparams,1) ;
            break ;
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */
        l_byte = (ufix8)VALUE_OP(0);    //@WIN
        GEIpm_write(PMIDofSCCBATCH,&l_byte,sizeof(unsigned char)) ;
    POP(3) ;
    /*
    GEIsig_raise(GEISIGSCC, 1) ;  */     /* Raise SCC changed */
#ifdef  _AM29K
    sccbatch_set=1 ;
#endif

    return(0) ;
}   /* st_setsccbatch */

fix
st_sccbatch()
{
    ufix8               l_options ;
    GEIioparams_t       ioparams ;
//  fix16               tmp_baudrate = 0 ;      @WIN
    ufix32              tmp_baudrate = 0 ;

    if (FRCOUNT()<1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    switch (VALUE_OP(0)) {
        case 9:
//          GEIpm_ioparams_read("%SERIAL9%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_read("%SERIAL9%",&ioparams,1) ;
            break ;
        case 25:
//          GEIpm_ioparams_read("%SERIAL25%",(char *)&ioparams,1) ;@WIN; wrong cast
            GEIpm_ioparams_read("%SERIAL25%",&ioparams,1) ;
            break ;
        default:
            ERROR(RANGECHECK) ;
            return(0) ;
    }   /* switch */

#ifdef  _AM29K
    l_options = ioparams.u.s.parity | ioparams.u.s.flowcontrol<<2 |
                ioparams.u.s.stopbits<<7 | ioparams.u.s.databits<<5 ;
    POP(1) ;
#else
    l_options = (unsigned char)(ioparams.s.parity |
                ioparams.s.flowcontrol<<2 |
                ioparams.s.stopbits<<7 |
                ioparams.s.databits<<5);                //@WIN
    POP(1) ;
#endif

#ifdef  _AM29K
    switch (ioparams.u.s.baudrate){
#else
    switch (ioparams.s.baudrate){
#endif
    case _B110:
        tmp_baudrate= 110 ;
        break ;
    case _B300:
        tmp_baudrate= 300 ;
        break ;
    case _B600:
        tmp_baudrate= 600 ;
        break ;
    case _B1200:
        tmp_baudrate= 1200 ;
        break ;
    case _B2400:
        tmp_baudrate= 2400 ;
        break ;
    case _B4800:
        tmp_baudrate= 4800 ;
        break ;
    case _B9600:
        tmp_baudrate= 9600 ;
        break ;
    case _B19200:
        tmp_baudrate= 19200 ;
        break ;
    case _B38400:
        tmp_baudrate= 38400 ;
        break ;
    case _B57600:
        tmp_baudrate= 57600 ;
        break ;
    default:
        ERROR(RANGECHECK) ;
    }

/*  GEIpm_read(PMIDofSCCBATCH,&l_options,sizeof(unsigned char)) ; */
    PUSH_VALUE(INTEGERTYPE, 0, 0, 0, (ufix32)tmp_baudrate) ;
    PUSH_VALUE(INTEGERTYPE, 0, 0, 0, (ufix32)l_options) ;

    return(0) ;
}   /* st_sccbatch */

fix
st_setsccinteractive()
{
    return(st_setsccbatch()) ;
}   /* st_setsccinteractive */

fix
st_sccinteractive()
{
    return(st_sccbatch()) ;
}   /* st_sccinteractive */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\blib.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              BLIB.C
 *
 * revision history:
 *    04-07-92   SCC   Move out fardata() to setvm.c
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include "global.ext"

#ifdef _AM29K
#include        <stdarg.h>
#include        <float.h>
#define va_dcl va_list va_alist ;
#endif  /* _AM29K */

#ifndef NULL
#define NULL    0
#endif

/*
 * added by M. S. Lin, Date : 11/20/87
 *                            1/14/88  fardata()
 */
/* ************************************************************************ *
 *                                                                          *
 *   Module : fardata                                                       *
 *                                                                          *
 *   Date   : Jan. 8, 1988     By  M. S. Lin                                *
 *                                                                          *
 *   Function : Allocates a memory block of at least size bytes.            *
 *                                                                          *
 *   Declaration : ubyte        far  *fardata(unsigned long) ;               *
 *                 ( in \pdl\include\global.ext )                           *
 *                                                                          *
 *   Call     : fardata(size)                                               *
 *                                                                          *
 *   Input    : unsigned long size of bytes                                 *
 *                                                                          *
 *   Return Value : The storage space pointed to by the return value is     *
 *                  guaranteed to be suitably aligned for storage of        *
 *                  any type of object. To get a pointer to a type other    *
 *                  than char, use a type cast on the return value.         *
 *                  Return 4 bytes far pointer with allignment to even      *
 *                  address if successful.                                  *
 *                  Return NULL if insufficient memory.                     *
 *                                                                          *
 *   Example : allocate space for 20 integers array.                        *
 *                                                                          *
 *      #include        "..\..\include\global.ext"                          *
 *      int  far   *intarray ;                                               *
 *                                                                          *
 *      intarray = (int far *)fardata(20 * sizeof(int)) ;                    *
 *                                                                          *
 *   Note : You must use as far pointer, otherwise will get the wrong       *
 *          pointer since compiler option /AM will be used.                 *
 *                                                                          *
 * ************************************************************************ */

#ifdef LINT_ARGS
static  byte FAR * near  printfield(byte FAR *, ufix32, ufix32, ufix32) ;
#else
static  byte FAR * near  printfield() ;
#endif /* LINT_ARGS */

/* @WIN move this function to "setvm.c" for function consistency */
#ifdef XXX
byte FAR *
fardata(size)
ufix32  size ;
{
    ufix32  ret_val, old_ptr, p1 ;
    fix32   l_diff ;

#ifdef DBG
   printf("Fardata(%lx): old fardata_ptr=%lx\n", size, fardata_ptr) ;
#endif

    old_ptr = fardata_ptr ;

   /*
    * make sure even allignment, allocate at least size bytes
    */
    size = WORD_ALIGN(size) ;

#ifdef  SOADR
   /*
    * if size > 0xfff0, make paragraph allignment, i.e, offset = 0
    * for cannonical form
    */
    if ((size > 0xfff0L) && (fardata_ptr & 0xf))
       fardata_ptr = (fardata_ptr & 0xffff0000) + 0x10000L ;
#endif  /* SOADR */

   /*
    * save current location as return value if successful
    */
    ret_val = fardata_ptr ;

    DIFF_OF_ADDRESS(l_diff, fix32, FARDATA_END, fardata_ptr) ;
    if (l_diff <= size) {
       fardata_ptr = old_ptr ;
       printf("Fatal Error : fardata() cannot allocate enough memory\n") ;
       return(NULL) ;
    } else {
       fardata_ptr += size ;
       ADJUST_SEGMENT(fardata_ptr, p1) ;
       fardata_ptr = p1 ;
#ifdef  DBG
   printf("\n\tfardata() : allocate address = %lx\n", ret_val) ;
   printf("\t                     size    = %lx\n", size) ;
#endif
      return((byte FAR *)ret_val) ;
    }
}   /* fardata() */
#endif

static byte far  digit[] =
{
    '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V',
    'W','X','Y','Z'
} ;

static byte FAR * near
printfield(cursor, number, divide, radix)
byte      FAR *cursor ;
ufix32    number ;
ufix32    divide ;
ufix32    radix ;
{
    byte      c ;
    fix       notzero = 0 ;

    for ( ; divide >= 1L ;) {
        c = digit[(fix)(number / divide)] ;
        if (c != '0' || notzero) {
           notzero = 1 ;
           *cursor++ = c ;
        }
        number = number % divide ;
        divide = divide / radix ;
    }

    if (!notzero)
       *cursor++ = '0' ;

    return(cursor) ;
}   /* printfield() */

/*
 ***************************************
 *                                     *
 *     gcvt()                          *
 *                                     *
 ***************************************
 */
byte FAR *
gcvt(val, sig, buf)
real64 val ;
fix    sig ;       /* no used, it is always 6 in following using */
byte   FAR *buf ;
{
    fix    sign, exp ;
    fix32  long_val, base ;
    byte   FAR *dest, FAR *src, FAR *end_ptr ;

    /* get absolute value */
    if (val == (real64)0.0) {
       lstrcpy(buf, (byte FAR *)"0.0") ;            /* @WIN */
       return(buf) ;
    } else if (val > (real64)0.0)
       sign = 0 ;
    else {
       sign = 1 ;
       val = -val ;
    }

    /* get EXP value */
    exp = 0 ;
    if (val >= (real64)10000000.0)
       while ((real32)val >= (real32)10000000.0) {
             val /= 10.0 ;
             exp++ ;
       }
    else
       while ((real32)val < (real32)1000000.0) {
             val *= 10.0 ;
             exp-- ;
       }
    exp += 6 ;

    /* insert sign byte */
    dest = buf ;
    if (sign == 1) {
       *dest = '-' ;
       dest++ ;
    }
    *dest = '.' ;

    /* transform into string */
    long_val = (fix32)val ;
    base = 1000000 ;
    while (base > 0) {
          dest++ ;
          *dest = (byte)((long_val / base) + '0') ;
          long_val %= base ;
          base /= 10 ;
    } /* get precision = 7 */

    end_ptr = dest ;
    /* reduce precision */
    if (*dest >= '5') {
       do {
          *dest = '0' ; dest-- ;
       } while (*dest == '9') ;
       if (*dest != '.')
          (*dest)++ ;
       else { /* carrying... */
          exp++ ;
          *(++dest) = '1' ;
          *(++dest) = '0' ;
       }
    }

    /* expand EXP +5 -- -4 */
    if (exp < 6 && exp > -5) {
       if (exp > 0) { /* expand +5 -- +1 (change "." position) */
          if (exp == 5)
             end_ptr++ ;
          dest = buf ;
          if (*dest == '-')
             dest++ ;
          while (exp >= 0) {
                *dest = *(dest + 1) ;
                dest++ ;
                exp-- ;
          }
          *dest = '.' ;
          exp++ ;
       } /* if */
       else if (exp < 0) { /* expand -4 -- -1 */
          src = dest = end_ptr ;
          dest -= exp ;
          end_ptr = dest ;
          while (*src != '.')
                *dest-- = *src-- ;
          while (exp < -1) {
                *dest-- = '0' ;
                exp++ ;
          }
          *src++ = '0' ;
          *src = '.' ;
          exp++ ;
       } else { /* EXP 0 */
           dest = buf ;
           if (*buf == '-')
              dest++ ;
           *dest = *(dest + 1) ;
           dest++ ;
           *dest = '.' ;
       }
    } else {
       dest = buf ;
       if (*buf == '-')
          dest++ ;
       *dest = *(dest + 1) ;
       dest++ ;
       *dest = '.' ;
    }

    src = end_ptr ;
    src-- ;

    if (*src == '0') { /* suppress tailing 0 */
       src-- ;
       while (*src == '0')
             src-- ;
       if (*src == '.')
          if (exp)     /* exp != 0 */
             src-- ;
          else         /* leave one '0' in exp == 0 */
             src++ ;
    }
    src++ ;

    if (exp == 0) {
       *src = '\0' ;
       return(buf) ;
    }

    dest = src ;
    /* append EXP into string */
    *dest = 'e' ;
    dest++ ;

    if (exp > 0)
       *dest = '+' ;
    else {
       *dest = '-' ;
       exp = -exp ;
    }

    *(++dest) = (byte )('0' + exp / 10) ;
    *(++dest) = (byte )('0' + exp % 10) ;
    *(++dest) = (byte )'\0' ;

    return(buf) ;
}   /* gcvt() */

byte FAR *ltoa(number, buffer, radix)
fix32 number ;
byte FAR *buffer ;
fix   radix ;
{
    byte       FAR *cursor ;
    ufix32     divide, maxdiv ;

    cursor = buffer ;
    if ( (number < 0) && (radix == 10) ) {
        number = -number ;
        *cursor++= '-' ;
    }

    divide = 1 ;
    maxdiv = MAX31 / radix ;

    while(divide < maxdiv)
        divide *= radix ;

    cursor = printfield(cursor, (ufix32)number, divide, (ufix32)radix) ;
    *cursor = '\0' ;

    return(buffer) ;
}   /* *ltoa() */

real64 strtod(str, endptr)
char FAR *str ;
char FAR * FAR *endptr ;
{
    fix     i, eminus ,minus ;
    real64  eresult, result ,exp_10, float10 ;
    byte    FAR *nptr ;

    eminus = minus = 0 ;
    nptr = str ;
    result = eresult = 0 ;
    float10 = .1 ;
    exp_10 = 1 ;

l1:
    if (*nptr == ' ') {
        nptr++ ;
        goto l1 ;
    }

    if (*nptr == '-' ) {
        minus++ ;
        nptr++ ;
    } else if (*nptr == '+') {
        nptr++ ;
    }

l2:
    if (*nptr >= 48 && *nptr <= 57) {
        result = result * 10 + (*nptr) - 48 ;
        nptr++ ;
        goto l2 ;
    } else if (*nptr == '.') {
        nptr++ ;
    }

l3:
    if (*nptr >= 48 && *nptr <= 57) {
        result = result + ((*nptr) - 48) * float10 ;
        float10 = float10 / 10 ;
        nptr++ ;
        goto l3 ;
    }

    if (*nptr == 'e' || *nptr == 'E' || *nptr == 'd' || *nptr == 'D') {
        nptr++ ;
    }

    if (*nptr == '-' ) {
        eminus++ ;
        nptr++ ;
    } else if (*nptr == '+') {
        nptr++ ;
    }

l4:
    if (*nptr >= 48 && *nptr <= 57) {
        eresult = eresult * 10 + (*nptr) - 48 ;
        nptr++ ;
        goto l4 ;
    }

    for (i = 1 ; i <= (int)eresult ; i++) {       /* @WIN; add cast */
        exp_10 = exp_10 * 10 ;
    }

    if (eminus)
        exp_10 = 1/exp_10 ;

    result = result * exp_10 ;

    if (minus)
        result = -result ;

    *endptr = nptr ;

    return result ;
}   /* strtod() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\dict.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DICT.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"

#include  <stdio.h>
#include    "global.ext"
#include    "language.h"
#include    "dict.h"

#ifdef MYPSDEBUG
VOID DJC_testerror( int x )
{
   global_error_code = (ufix16)x;
}
#endif

/***********************************************************************
**
** This submodule implements the operator dict.
** Its operand and result objects are:
**     integer  -dict- dictioanry
** It creates a dictionary object in which the number of key-value pairs,
** specified by the input integer object, is defined.
**
** TITLE:       op_dict             Date:   08/01/87
** CALL:        op_dict()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_dict:    5.3.1.4.23
***********************************************************************/
fix
op_dict()
{
    struct  object_def  l_save ;

    /*
    ** check operands
    ** the key-value pairs in the dictionary must be less than 64K
    */
    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXDICTCAPSZ) )
        ERROR(RANGECHECK) ;
    else {
        /* SUCCESS */
        if( create_dict(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;
    }

    return(0) ;
}   /* op_dict */

/***********************************************************************
**
** This submodule implements the operator length.
** Its operand and result objects are:
**     dictionary -length- integer
**     string     -length- integer
**     array      -length- integer
** It returns the number of the characters if the input object is a
** string object.
** It returns the number of the elements if the input object is a array.
** It returns the number of the defined key-value pairs if the input object
** is a dictionary object.
**
** TITLE:       op_length           Date:   08/01/87
** CALL:        op_length()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_length()
{
    struct  object_def  FAR *l_composite ;
    struct  dict_head_def   FAR *l_dhead ;
    ufix16  l_count = 0 ;

    l_composite = GET_OPERAND(0) ;
    switch(TYPE(l_composite)) {
        case DICTIONARYTYPE:
            l_dhead = (struct dict_head_def FAR *)VALUE(l_composite) ;
            if(DACCESS(l_dhead) == NOACCESS) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }
            l_count = l_dhead->actlength ;
            break ;

        case STRINGTYPE:
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            /* executeonly or noaccess */
            if(ACCESS(l_composite) >= EXECUTEONLY) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            l_count = LENGTH(l_composite) ;
            break ;

        case NAMETYPE:
            l_count =name_table[VALUE_OP(0)]->name_len ;

    }   /* switch */

    /* pop the operand object off the operand stack
    ** make and push the integer object
    */
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_count) ;

    return(0) ;
}   /* op_length */

/***********************************************************************
**
** This submodule implements the operator maxlength.
** Its operand and result objects are:
**     dictionary -maxlength- integer
** It returs the maximum key-value pairs that that dictionary can hold.
**
** TITLE:       op_maxlength        Date:   08/01/87
** CALL:        op_maxlength()      UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_maxlength()
{
    ufix16  l_maxlength ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE_OP(0) ;

    if( DACCESS(l_dhead) == NOACCESS )
        ERROR(INVALIDACCESS) ;
    else {
        /*
         * pop the operand object off the operand stack
         * and make and push the length object
         */
        l_maxlength = LENGTH_OP(0) ;
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_maxlength) ;
    }

    return(0) ;
}   /* op_maxlength */

/***********************************************************************
**
** This submodule implements the operator begin.
** Its operand and result objects are:
**     dictionary  -begin-
** It pushes the dictionary on the dictionary stack,
** making it the currrent dictionary.
**
** TITLE:       op_begin            Date:   08/01/87
** CALL:        op_begin()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       change_dict_stack:      5.3.1.4.24
***********************************************************************/
fix
op_begin()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dictobj = GET_OPERAND(0) ;
    /* check operand and the depth of the dictionary stack */
    if( FRDICTCOUNT() < 1 )  {
        POP(1) ;                                /* reserve space */
        ERROR(DICTSTACKOVERFLOW) ;
    }
    else {
        l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
        if( DACCESS(l_dhead) == NOACCESS )
            ERROR(INVALIDACCESS) ;
        else {
            /*
             * push the dictionary object onto the dictionary stack
             * pop the dictionary operand off the operand stack
             */
            PUSH_DICT_OBJ(l_dictobj) ;
#ifdef  DBG
    printf("BEGIN<level:%d>\n", LEVEL(l_dictobj)) ;
#endif  /* DBG */
            POP(1) ;

            /* change the global_dictstkchg to indicate some dictionaries
             * in the dictionary stack have been changed
             */
            change_dict_stack() ;
        }   /* else */
    }

    return(0) ;
}   /* op_begin */

/***********************************************************************
**
** This submodule implements the operator end.
** The operator has no operands and result objects.
** It pops the current dictionary off the dictionary stack,
** making the dictionary below it the current dictionary.
**
** TITLE:       op_end              Date:   08/01/87
** CALL:        op_end()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       change_dict_stack:      5.3.1.4.24
***********************************************************************/
fix
op_end()
{
    /*
     *  it can't pop the last two dictioanries, userdict and systemdict,
     *  off the operand stack
     */
    if( dictstktop <= 2 )
        ERROR(DICTSTACKUNDERFLOW) ;
    else {
        /*
         *  change the confirm number to indicate some dictionaries
         *  in the dictionary stack have been changed
         */
        POP_DICT(1) ;
        change_dict_stack() ;
    }

    return(0) ;
}   /* op_end */

/***********************************************************************
**
** This submodule implements the operator def.
** Its operand and result objects are:
**     key  value -def-
** It defines the key and value on the current dictionary.
**
** TITLE:       op_def                          Date:   08/01/87
** CALL:        op_def()                        UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       put_dict1:      5.3.1.4.26
***********************************************************************/
fix
op_def()
{
    struct  object_def  FAR *l_dictobj, l_value ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dictobj = &dictstack[dictstktop - 1] ;
    l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
    if( DACCESS(l_dhead) >= READONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    COPY_OBJ(GET_OPERAND(0), &l_value) ;
    /* TRUE -> dict_found field is true */
    /* SUCCESS */
    if( put_dict1(l_dictobj, GET_OPERAND(1), &l_value, TRUE) )
        POP(2) ;

    return(0) ;
}   /* op_def */

/***********************************************************************
**
** This submodule implements the operator load.
** Its operand and result objects are:
**     key -load- value
** It searches the dictionary stack for the given key and push
** the value object on the operand stack if found.
**
** TITLE:       op_load             Date:   08/01/87
** CALL:        op_load()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       load_dict1:     5.3.1.4.27
**              free_new_name:
***********************************************************************/
fix
op_load()
{
    bool    l_flag ;
    struct  object_def   FAR *l_value ;

    l_flag = (bool)FALSE ;
    /*
     * SUCCESS
     */
    if( load_dict1(GET_OPERAND(0), &l_value, (bool FAR *)&l_flag) ) { /*@WIN*/
        /* found but invalidaccess */
        if(l_flag)
            ERROR(INVALIDACCESS) ;
        else {
            /*
             *  pop the key object off the operand stack
             *  push the value object onto the operand stack
             */
            POP(1) ;
            PUSH_ORIGLEVEL_OBJ(l_value) ;
        }
    }

    return(0) ;
}   /* op_load */

/***********************************************************************
**
** This submodule implements the operator store.
** Its operand and result objects are:
**     key value -store-
** It searches the dictionary stack for the given key object.
** If found, it replaces the vlaue with a new one ; otherwise,
** it defines the key and the value object in the current dictionary.
**
** TITLE:       op_store            Date:   08/01/87
** CALL:        op_store()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              put_dict1:  5.3.1.4.26
**              where:      5.3.1.4.21
***********************************************************************/
fix
op_store()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    /*
     *  l_dictobj is pointer to a dictionary object
     *
     *  the key has not be defined, defined the key on
     *  the current dictioanry
     */
    if( where(&l_dictobj, GET_OPERAND(1)) ) {
        if(global_error_code != NOERROR) return(0) ;
    } else
        l_dictobj = &dictstack[dictstktop-1] ;  /* strore to current dict */
    l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
    if( DACCESS(l_dhead) >= READONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /*
     *  put this key-value pair to current dictionary
     *  this dict is in dictionary stack, so TRUE (do change dict_found)
     *
     *  SUCCESS
     */
    if( put_dict1(l_dictobj, GET_OPERAND(1), GET_OPERAND(0), TRUE) )
        POP(2) ;

    return(0) ;
}   /* op_store */

/***********************************************************************
**
** This submodule implements the operator get.
** Its operand and result objects are:
**     dictionary key   -get- value
**     array      index -get- value
**     string     index -get- value
** If the first operand is an array or string, it treats the second operand
** as an index and returns the array or string element identified by the index.
** If the first operand is a dictionary, it looks up the second as a key in
** the dictionary and returns the associated value.
**
** TITLE:       op_get              Date:   08/01/87
** CALL:        op_get()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_dict        5.3.1.4.17
**              get_array       5.3.1.3.19
**              free_new_name:
**              get_pk_array:   5.3.1.3.26
**              get_pk_object:  5.3.1.3.25
***********************************************************************/
fix
op_get()
{
    ufix16  l_index ;
    struct  object_def  FAR *l_composite, FAR *l_value ;
    union   obj_value   l_ptr ;

    l_composite = GET_OPERAND(1) ;
    switch( TYPE(l_composite) ) {
        case DICTIONARYTYPE:
            l_ptr.dd = (struct dict_head_def FAR *)VALUE(l_composite) ;
            if( DACCESS(l_ptr.dd) == NOACCESS ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }

            /* the key object cannot be a null object */
            /* no key in dict */
            if( l_ptr.dd->actlength == 0 ) {
                /* POP_KEY ; 12-3-87 */
                /* POP(1) ;  12-9-87 */
                /* only leave key in stack for compatible with NTX; @WIN */

                POP(2);				//UPD044, by printer group
                PUSH_ORIGLEVEL_OBJ(l_composite);

                ERROR(UNDEFINED) ;
                break ;
            }

            /*
            ** GET A VALUE OBJECT
            **
            **  SUCCESS
            */
            if( get_dict(l_composite, GET_OPERAND(0), &l_value) ) {
                POP(2) ;
                PUSH_ORIGLEVEL_OBJ(l_value) ;
            }  else {
                /* leave the key in stack if UNDEFINED error */
                if(ANY_ERROR() != LIMITCHECK)
                    /* only leave key in stack for compatible with NTX; @WIN */

                    POP(2) ;			//UPD044, by printer group
                    PUSH_ORIGLEVEL_OBJ(l_composite);

                    ERROR(UNDEFINED) ;
            }
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case STRINGTYPE:
            /* the index is greater than the length of array or string */
            if( ((fix32)VALUE_OP(0) < 0) ||
                ((ufix32)VALUE_OP(0) >= (ufix32)LENGTH(l_composite)) ) {
                ERROR(RANGECHECK) ;
                break ;
            }

            /* executeonly ? noacces ? */
            if( ACCESS(l_composite) >= EXECUTEONLY ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }
            l_ptr.oo = (struct object_def FAR *)VALUE(l_composite) ;
            l_index = (ufix16)VALUE_OP(0) ;
            POP(2) ;

            /*
             *  STRING
             */
            if( TYPE(l_composite) == STRINGTYPE ) {
                l_ptr.ss += l_index ;
                /*  push the integer object representing the character */
                PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0,
                           ((ufix32)*l_ptr.ss & 0x000000FF)) ;
            }
            /*
             *  ARRAY
             */
            else if( TYPE(l_composite) == ARRAYTYPE ) {
                l_ptr.oo += l_index ;
                PUSH_ORIGLEVEL_OBJ((struct object_def FAR *)l_ptr.oo) ;
            }
            /*
             *  PACKEDARRAY
             */
            else {
                l_ptr.ss = get_pk_array(l_ptr.ss, l_index) ;
/* qqq, begin */
                /*
                get_pk_object( l_ptr.ss, &opnstack[opnstktop++],
                               LEVEL(l_composite) ) ;
                */
                get_pk_object( l_ptr.ss, opnstkptr, LEVEL(l_composite) ) ;
                INC_OPN_IDX();
/* qqq, end */
            }
    }   /* switch */

    return(0) ;
}   /* op_get */

/***********************************************************************
**
** This submodule implements the operator put.
** Its operand and result objects are:
**     dictionary key   value -put-
**     array      index value -put-
**     string     index value -put-
** It defines a key-value pair in the current dictionary.
**
** TITLE:       op_put              Date:       08/01/87
** CALL:        op_put()            UpDate:     Jul/12/88
** INTERFACE:   interpreter:
** CALL:
**              put_dict1:  5.3.1.4.26
**              put_array:  5.3.1.3.20
** Modified by J. Lin, 9-02-1988
***********************************************************************/
fix
op_put()
{
    ufix16  l_index ;
    struct  object_def  FAR *l_composite ;
    union   obj_value   l_ptr ;

    l_composite = GET_OPERAND(2) ;
    switch(TYPE(l_composite)) {
        case DICTIONARYTYPE:
            /* pointer to a dictionary structure */
            l_ptr.dd = (struct dict_head_def FAR *)VALUE(l_composite) ;

            /* the key cannot be a null object */
            if (DACCESS(l_ptr.dd) != UNLIMITED) {
                ERROR(INVALIDACCESS) ;
                break ;
            }
            /*
             * change dict_found filed of name_table
             * dict may be not in dictctionary stack
             * SUCCESS
             */
            if( put_dict1(l_composite, GET_OPERAND(1), GET_OPERAND(0), FALSE) )
                POP(3) ;
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case STRINGTYPE:
            /* the index is greater than the array length */
            if( ((fix32)VALUE_OP(1) < 0) ||
                ((ufix32)VALUE_OP(1) >= (ufix32)LENGTH(l_composite)) ) {
                ERROR(RANGECHECK) ;
                break ;
            }

            /*  readonly ? executeonly ? noaccess ? */
            if( ACCESS(l_composite) != UNLIMITED ) {
                ERROR(INVALIDACCESS) ;
                break ;
            }

            l_ptr.oo = (struct object_def FAR *)VALUE(l_composite) ;
            l_index = (ufix16)VALUE_OP(1) ;
            /*
            **  STRING
            */
            if (TYPE(l_composite) == STRINGTYPE) {
                /* the value is out of the arrange of character code */
                if((ufix32)VALUE_OP(0) > 255) {
                    ERROR(RANGECHECK) ;
                    return(0) ;
                }
                l_ptr.ss += l_index ;
                *l_ptr.ss = (ubyte)VALUE_OP(0) ;
            }   /* string */
            /*
            **  ARRAY
            */
            else {
                l_ptr.oo += l_index ;
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_ptr.oo) != current_save_level )
                if( (ufix16)(LEVEL(l_ptr.oo)) != current_save_level )
                    if(! save_obj(l_ptr.oo) ) return(FALSE) ;
                COPY_OBJ(GET_OPERAND(0), (struct object_def FAR *)l_ptr.oo) ;
                LEVEL_SET(l_ptr.oo, current_save_level) ;
            }   /* array */

            POP(3) ;
    }   /* switch */

    return(0) ;
}   /* op_put */

/***********************************************************************
**
** This submodule implements the operator known.
** Its operand and result objects are:
**     dictionary key -known- boolean
** It returns a boolean object indicating if the key is defined in
** the dictionary.
**
** TITLE:       op_known            Date:   08/01/87
** CALL:        op_known()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       get_dict:           5.3.1.4.17
**              free_new_name:
***********************************************************************/
fix
op_known()
{
    struct  object_def  FAR *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE_OP(1) ;
    if( DACCESS(l_dhead) == NOACCESS) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if( get_dict(GET_OPERAND(1), GET_OPERAND(0), &l_vtemp) ) {
        POP(2) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    } else {
        if(global_error_code == NOERROR) {      /* undefined */
            POP(2) ;                            /* pop dict & key */
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    }

    return(0) ;
}   /* op_known */

/***********************************************************************
**
** This submodule implements the operator where.
** Its operand and result objects are:
**     key -where- dictionary true
**                 or false
** It searches the dictioanry stack for a given key. If the key is defined in
** some dictionary, it returns the dictionary and a boolean object ; otherwise,
** it returns a false object.
**
** TITLE:       op_where            Date:   08/01/87
** CALL:        op_where()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       where:      5.3.1.4.21
***********************************************************************/
fix
op_where()
{
    struct  object_def  FAR *l_dictobj ;
    struct  dict_head_def   FAR *l_dhead ;

    if( where(&l_dictobj, GET_OPERAND(0)) ) {
        if(global_error_code != NOERROR) return(0) ;
        l_dhead = (struct dict_head_def FAR *)VALUE(l_dictobj) ;
        if( DACCESS(l_dhead) == NOACCESS ) {
            ERROR(INVALIDACCESS) ;
            return(0) ;
        }

        if( FRCOUNT() < 1 ) {
            POP(1) ;                /* ?? */
            ERROR(STACKOVERFLOW) ;
        }
        else {
            POP(1) ;
            PUSH_ORIGLEVEL_OBJ(l_dictobj) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        }
    } else {
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_where */

/***********************************************************************
**
** This submodue implements the operator forall
** Its operand and result objects are:
**     array      proc -forall-
**     dictionary proc -forall-
**     string     proc -forall-
** It enumerates the elements of the first operand, executing the procedure
** for each element.
**
** TITLE:       op_forall           Date:   08/01/87
** CALL:        op_forall()         UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:
**              forall_array:   5.3.1.3.16
**              forall_dict:    5.3.1.4.20
**              forall_string:  5.3.1.5.15
***********************************************************************/
fix
op_forall()
{
    struct  dict_head_def   FAR *l_dhead ;

    if( ACCESS_OP(0) == NOACCESS ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /* if success, pop elements are executed by subprocedure */
    switch( TYPE_OP(1) ) {
        case DICTIONARYTYPE:
            l_dhead = (struct dict_head_def FAR *)VALUE_OP(1) ;
            if( DACCESS(l_dhead) == NOACCESS ) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            /* NOTHING in dict */
            if( l_dhead->actlength == 0 ) {
                POP(2) ;
                return(0) ;
            }

            forall_dict(GET_OPERAND(1), GET_OPERAND(0)) ;
            break ;

        case STRINGTYPE:
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
            if( ACCESS_OP(1) >= EXECUTEONLY ) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
            }

            if( LENGTH_OP(1) == 0 ) {
                POP(2) ;
                return(0) ;
            }

            if( TYPE_OP(1) == STRINGTYPE )
                forall_string( GET_OPERAND(1), GET_OPERAND(0) ) ;
            else
                forall_array( GET_OPERAND(1), GET_OPERAND(0) ) ;
    }   /* switch */

    if( ! ANY_ERROR() )
        POP(2) ;

    return(0) ;
}   /* op_forall */

/***********************************************************************
**
** This submodue implements the operator currentdict.
** This operator has no operands or result objects.
** It returns the current dictionary on the operand stack.
**
** TITLE:       op_currentdict              Date:   08/01/87
** CALL:        op_currentdict()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_currentdict()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;

    /*  push the current dictionary object onto the opernad stack */
    else
        PUSH_ORIGLEVEL_OBJ(&dictstack[dictstktop-1]) ;

    return(0) ;
}   /* op_currentdict */

/***********************************************************************
**
** This submodule implements the operator countdictstack.
** It returns the number of dictionaries on the dictionary stack.
** This operator has no operands or result objects.
**
** TITLE:       op_countdictstack               Date:   08/01/87
** CALL:        op_countdictstack()             UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_countdictstack()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    /*
    **  push the integer object, its the depth of dictionary stack,
    **  onto operand stack
    */
    else
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)dictstktop) ;

    return(0) ;
}   /* op_countdictstack */

/***********************************************************************
**
** This submodule implements the operator dictstack.
** Its operand and result objects are:
**     array  -dictstack- subarray
** It copies the dictionaries on the dictionary stack to a given array.
**
** TITLE:       op_dictstack                    Date:   08/01/87
** CALL:        op_dictstack()                  UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_dictstack()
{
    if( ACCESS_OP(0) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    /*
     *  the length of array is less than the
     *  depth of the dictionary stack
     */
    if( (ufix16)LENGTH_OP(0) < dictstktop )     /* may be deleted */
        ERROR(RANGECHECK) ;

    /*
    ** copy the dictionaries in dictionary stack
    ** to the array in the operand stack
    */
    /* for dictstackoverflow */
    else
        astore_stack(GET_OPERAND(0), DICTMODE) ;

    return(0) ;
}   /* op_dictstack */

/***********************************************************************
**
**  This submodule searches the dictionary stack for a key object.
**
** TITLE:       where                       Date:   08/01/87
** CALL:        where(p_dict,p_key,p_flag)  UpDate: Jul/12/88
** INTERFACE:   op_store:   5.3.1.4.8
**              op_where:   5.3.1.4.12
** CALLS:       get_dict:   5.3.1.4.17
***********************************************************************/
static bool near
where(p_dict, p_key)
struct  object_def  FAR * FAR *p_dict, FAR *p_key ;
{
    fix     l_i ;
    struct  object_def  FAR *l_dvalue ;

    /* search the key in the dictionary stack */
    for(l_i=dictstktop - 1 ; l_i >= 0 ; l_i-- ) {
        *p_dict = &dictstack[l_i] ;
        /*
         * FOUND
         */
        if ( (get_dict(*p_dict, p_key, &l_dvalue)) ||
             (global_error_code != NOERROR) ) return(TRUE) ;
    }

    return(FALSE) ;
}   /* where */

/***********************************************************************
**
** This submodule defines a given key and value pair in the
** specified dictionary.
**
** TITLE:       put_dict1           Date:   08/01/87
** CALL:        put_dict1()         UpDate: Jul/12/88
** INTERFACE:
** CALLS:       equal_key:          5.3.1.4.30
**              save_obj:           5.3.1.10.4
**              sobj_to_nobj:       5.3.1.4.25
**              update_same_link:   5.3.1.10.7
***********************************************************************/
bool
put_dict1(p_dict, p_key, p_value, p_dstack)
struct object_def  FAR *p_dict, FAR *p_key, FAR *p_value ;
fix    p_dstack ;
{
    ufix16  l_j, l_maxlength, l_actlength ;
    fix     l_id ;
    struct object_def l_newkey, l_value ;
    struct object_def huge *l_newp = &l_newkey ;
    struct dict_head_def   FAR *l_dhead ;
    struct dict_content_def  huge *l_dcontain, huge *l_dtemp, huge *l_curptr,
                             huge *l_lastptr, huge *l_fstptr ;
    /*
     * set the save level of the object
     */
    COPY_OBJ( p_value, &l_value ) ;
    LEVEL_SET(&l_value, current_save_level) ;

    /* change string key to name key and create a new key object */
    if(! check_key_type(p_key, l_newp) ) return(FALSE) ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    l_actlength = l_dhead->actlength ;
    l_maxlength = LENGTH(p_dict) ;

    /* CHECK LENGTH */
    if( l_maxlength == 0 ) {
        ERROR(DICTFULL) ;
        return(FALSE) ;
    }

    LEVEL_SET(l_newp, current_save_level) ;

    l_dcontain = (struct dict_content_def huge *)
                 ( (ubyte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    /*
     *  key is NAMETYPE && dict is a RAM dictionary
     */
    if( (TYPE(l_newp) == NAMETYPE) && (!DROM(l_dhead))) {
        l_id = (fix)VALUE(l_newp) ;
#ifdef  DBG
        printf("put_dict1(RAM):<") ;
        GEIio_write(GEIio_stdout, name_table[l_id]->text, name_table[l_id]->name_len) ;
        printf(">(%lx)\n",VALUE(p_dict)) ;
#endif  /* DBG */
        l_curptr = name_table[l_id]->dict_ptr ;
        if((ULONG_PTR)l_curptr < SPECIAL_KEY_VALUE) {
            /*
             * EMPTY LIST: put the key-value pair to dict and
             *             become the first element of name list
             */
            if(l_actlength >= l_maxlength) {
                ERROR(DICTFULL) ;
                return(FALSE) ;
            }
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;

            l_dcontain += l_dhead->actlength ;
            l_dhead->level = current_save_level ;
            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;

            name_table[l_id]->dict_ptr = l_dcontain ;   /* maintain DICT_LIST */

            if(p_dstack) {                      /* set dict_found, dstkchg */
                name_table[l_id]->dict_found = TRUE ;
                name_table[l_id]->dstkchg = global_dictstkchg ;
            }

            l_dhead->actlength++ ;
            LENGTH(l_newp) = LENGTH(&(l_dcontain->k_obj)) ;
            VALUE(l_newp) = (ufix32)l_id ;                    /* hash id */
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;        /* new key */
        } else {
            l_fstptr = l_curptr ;
            l_lastptr = NIL ;
            while((ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE) {
                l_dtemp = DICT_NAME(l_curptr) ;
                if(l_dtemp == l_dcontain) {
                    /*
                     * FOUND: put value to dict and update name list
                     */
// DJC signed/unsigned mismatch warning
// DJC              if( LEVEL(&l_curptr->v_obj) != current_save_level )
                    if( (ufix16)(LEVEL(&l_curptr->v_obj)) != current_save_level )
                        if(! save_obj(&(l_curptr->v_obj)) ) return(FALSE) ;
                    if (p_dstack) {
                       if (l_curptr != l_fstptr) {
                          VALUE(&l_lastptr->k_obj) = VALUE(&l_curptr->k_obj) ;
                          VALUE(&l_curptr->k_obj) = (ULONG_PTR)l_fstptr ;
                          name_table[l_id]->dict_ptr = l_curptr ;
                       }
                       name_table[l_id]->dict_found = TRUE ;
                       name_table[l_id]->dstkchg = global_dictstkchg ;
                    }
                    l_dcontain = l_curptr ;
                    goto label_1 ;
                }
                l_lastptr = l_curptr ;
                l_curptr = (struct dict_content_def huge *)VALUE(&l_curptr->k_obj) ;
            }   /* while(l_curptr) */

            /*
             *  NOT FOUND: put the key-value pair to dict and
             *             update the name list
             */
            if(l_actlength >= l_maxlength) {
                ERROR(DICTFULL) ;
                return(FALSE) ;
            }
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;
            l_dcontain += l_dhead->actlength ;
            l_dhead-> level = current_save_level ;

            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;
            name_table[l_id]->dict_ptr = l_dcontain ;
            l_dhead->actlength++ ;

            if (p_dstack) {                     /* set dict_found, dstkchg */
                name_table[l_id]->dict_found = TRUE ;
                name_table[l_id]->dstkchg = global_dictstkchg ;
            } else                             /* reset dict_found */
               name_table[l_id]->dict_found = FALSE ;

            LENGTH(l_newp) = LENGTH(&(l_dcontain->k_obj)) ;
            VALUE(l_newp) = (ULONG_PTR)l_fstptr ;
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;      /* new key */
        }

label_1:
        COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
/* qqq, begin */
        if( ! cache_name_id.over )
            vm_cache_index(l_id);
/* qqq, end */
        return(TRUE) ;

    }   /*  NAMETYPE && RAM dictionary */
    /*
     *  OTHERS
     *
     *  linear search: first in first service
     */
    else {

#ifdef  DBG
        printf("put_dict1(others):<") ;
        /* 3/7/91
        print_string(name_table[VALUE(l_newp)]->text, name_table[VALUE(l_newp)]->name_len) ;
        */
        GEIio_write(GEIio_stdout, name_table[VALUE(l_newp)]->text, name_table[VALUE(l_newp)]->name_len) ;
        printf(">(%lx)\n",VALUE(p_dict)) ;
#endif  /* DBG */

        for(l_j=0 ; l_j < l_actlength ; l_j++, l_dcontain++) {
            /* find the SAME KEY */
            if( equal_key(&(l_dcontain->k_obj), l_newp) ) {
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(&l_dcontain->v_obj) != current_save_level ) {
                if( (ufix16)(LEVEL(&l_dcontain->v_obj)) != current_save_level ) {
                    if( ! save_obj(&(l_dcontain->v_obj)) )
                        return(FALSE) ;
                }
                COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
                return(TRUE) ;
            }
        }   /* for */

        if(l_dhead->actlength >= l_maxlength) {
            ERROR(DICTFULL) ;
            return(FALSE) ;
        } else {
            if (l_dhead->level != current_save_level)
                if (!save_obj((struct object_def FAR *)l_dhead))
                    return(FALSE) ;
            l_dhead->level = current_save_level ;

            if( ! save_obj(&(l_dcontain->k_obj)) ) return(FALSE) ;
            COPY_OBJ( l_newp, &(l_dcontain->k_obj) ) ;          /* new key */
            COPY_OBJ( &l_value, &(l_dcontain->v_obj) ) ;
            l_dhead->actlength++ ;              /* increase actual length */
            return(TRUE) ;
        }
    }   /* others */
}   /* put_dict1 */

/***********************************************************************
**
** This submodule loads the value of the given key from a dictionary stack.
**
** TITLE:       load_dict1          Date:   08/01/87
** CALL:        load_dict1()        UpDate: Jul/12/88
** INTERFACE:
** CALL:        get_dict:           5.3.1.4.17
**              check_key_type:     5.3.1.4.33
***********************************************************************/
static bool near
load_dict1(p_key, p_value, p_flag)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
bool    FAR *p_flag ;   /*@WIN*/
{
    fix     l_id, l_index ;
    struct  object_def      l_newkey, FAR *l_newp = &l_newkey ;
    struct  object_def  huge *l_dictobj, huge *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr,
                                huge *l_dold, huge *l_fstptr ;

    if( ! check_key_type(p_key, l_newp) )
        return(FALSE) ;

    if( TYPE(l_newp) == NAMETYPE ) {
        l_id = (fix)VALUE(l_newp) ;
        /*
         * if the name object is defined in a RAM dictionary,
         * it will be in the object lists in the name table.
         *
         * the dictionary cell is linked in the header entry
         */
        if( (name_table[l_id]->dstkchg == global_dictstkchg) &&
            (name_table[l_id]->dict_found) ) {

            /* get first element */
            *p_value = &(name_table[l_id]->dict_ptr->v_obj) ;
            return(TRUE) ;
        }
        /*
         *  RESCHEDULE NAME LIST
         */
        else {

            /*  link list */
            l_index = dictstktop -1 ;
            l_fstptr = name_table[l_id]->dict_ptr ;

            /*  get dictionary from dictionary stack */
            while( l_index >= 0 ) {
                l_dictobj = &dictstack[l_index] ;
                l_dhead = (struct dict_head_def huge *)VALUE(l_dictobj) ;

                if(DROM(l_dhead)) {
                    /*
                     *  ROM
                     */
                    if( get_dict(l_dictobj, l_newp,
                          (struct object_def FAR * FAR *)&l_vtemp) ) {
                        name_table[l_id]->dict_found = FALSE ;
                        if(DACCESS(l_dhead) == NOACCESS)
                            *p_flag = TRUE ;

                        *p_value = l_vtemp ;
                        return(TRUE) ;
                    }
                    /* else: to next dict */
                }   /* ROM */
                else {
                    /*
                     *  RAM
                     *
                     * search this RAM dictionary's address in link list
                     */
                    if((ULONG_PTR)l_fstptr < SPECIAL_KEY_VALUE) {
                        l_index-- ;
                        continue ;
                    }
                    l_dict = l_fstptr ;                     /* name list */
                    l_dold = NIL ;
                    l_dptr = (struct dict_content_def huge *)
                        ((byte FAR *)l_dhead + sizeof(struct dict_head_def));
                    for( ; ;) {
                        if( (ULONG_PTR)l_dict < SPECIAL_KEY_VALUE )  break ;

                        /*
                         * FOUND, this key in l_dictobj
                         */
                        if( DICT_NAME(l_dict) == l_dptr ) {
                            /* CHANGE THIS ELEMENT TO FRONT OF LIST */
                            if( l_dold != NIL ) {
                                VALUE(&l_dold->k_obj) = VALUE(&l_dict->k_obj) ;
                                VALUE(&l_dict->k_obj) = (ULONG_PTR)l_fstptr ;
                                name_table[l_id]->dict_ptr = l_dict ;
                            }
                            name_table[l_id]->dict_found = TRUE ;
                            name_table[l_id]->dstkchg = global_dictstkchg ;

                            if( DACCESS(l_dhead) == NOACCESS )
                                *p_flag = TRUE ;
                            *p_value = &(l_dict->v_obj) ;
                            return(TRUE) ;
                        } else {
                            /* to next element of name list */
                            l_dold = l_dict ;
                            l_dict = (struct dict_content_def huge *)
                                     VALUE(&l_dict->k_obj) ;
                        }
                    }   /* for */
                }   /* RAM */
                l_index-- ;
            }   /* while(l_index) */

            /* names in ROM dict are not chain to namelist */
            ERROR(UNDEFINED) ;
            return(FALSE) ;
        }   /* else */
    }   /* NAMETYPE */
    /*
     * if the key is NOT A NAME OBJECT,
     * search all dictionaries in the dictionary stack.
     * LINEAR SEARCH
     */
    l_index = dictstktop - 1 ;
    while( l_index >= 0 ) {
        if( get_dict(&dictstack[l_index], l_newp,
                    (struct object_def FAR * FAR *)&l_vtemp) ) {
            l_dhead = (struct dict_head_def FAR *)VALUE(&dictstack[l_index]) ;
            if( DACCESS(l_dhead) == NOACCESS)
                *p_flag = TRUE ;
            *p_value = l_vtemp ;
            return(TRUE) ;
        }
        l_index-- ;
    }   /* while(l_index) */

    ERROR(UNDEFINED) ;

    return(FALSE) ;
}   /* load_dict1 */

/***********************************************************************
**
** This function is used to change value field of a key object,
** (to get the name's id)
** if it is a nametype and belongs to RAM dictionary.
**
** TITLE:       change_namekey              Date:   08/01/87
** CALL:        change_namekey()            UpDate: Jul/12/88
** INTERFACE:
***********************************************************************/
static void near
change_namekey(p_oldkey, p_newkey)
struct  object_def  huge *p_oldkey ;
struct  object_def FAR *p_newkey ;
{
    struct  object_def  huge *l_curptr ;

    l_curptr = (struct object_def huge *)VALUE(p_oldkey) ;
    while( (ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE )
        l_curptr = (struct object_def huge *)VALUE(l_curptr) ;

    VALUE(p_newkey) = (ULONG_PTR)l_curptr ;

    return ;

}   /* change_namekey */

/***********************************************************************
**
** TITLE:       check_key_type              Date:   08/01/87
** CALL:        check_key_type()            UpDate: Jul/12/88
** INTERFACE:   get_dict:       5.3.1.4.17
**              load_dict1:     5.3.1.4.27
** CALLS:       sobj_to_nobj    5.3.1.4.25
***********************************************************************/
static bool near
check_key_type(p_key, p_newkey)
struct object_def  FAR *p_key, FAR *p_newkey ;
{
    COPY_OBJ(p_key, p_newkey) ;
    switch( TYPE(p_key) ) {
    case STRINGTYPE:
        if( ! sobj_to_nobj(p_key, p_newkey) )
            return(FALSE) ;             /* system error: name_to_id */
        break ;

    }   /* switch */

    return(TRUE) ;
}   /* check_key_type */

/***********************************************************************
**
** TITLE:       init_dict           Date:   08/01/87
** CALL:        init_dict()         UpDate: 08/27/87
** INTERFACE:   start:
***********************************************************************/
void
init_dict()
{
    dictstktop = 0 ;
    dictstkptr = dictstack;                     /* qqq */
    global_dictstkchg = 0 ;

    return ;
}   /* init_dict */

/***********************************************************************
**
** This submodule is actually to get the value object of a key object in a
** dictionary.
**
** TITLE:       get_dict                        Date:   08/01/87
** CALL:        get_dict()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
**              op_get:         5.3.1.4.9
**              op_known:       5.3.1.4.11
**              where:          5.3.1.4.21
** CALLS:       sobj_to_nobj:   5.3.1.4.25
**              equal_key:      5.3.1.4.30
**              get_pack_dict:
***********************************************************************/
bool
get_dict(p_dictobj, p_key, p_value)
struct object_def  FAR *p_dictobj, FAR *p_key, FAR * FAR *p_value ;
{
    bool    l_ram ;
    ufix16  l_index, l_actlength ;
    fix     l_id ;
    struct  object_def      l_newkey ;
    struct  object_def      huge *l_newp = &l_newkey ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr, huge *l_dtemp ;

    if(! check_key_type(p_key, l_newp) ) return(FALSE) ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dictobj) ;
    l_dptr = (struct dict_content_def huge *)
             ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    if( ! DROM(l_dhead) )
        l_ram = TRUE ;
    else  {
        l_ram = FALSE ;

        /* for get_pack_dict */
        if(DPACK(l_dhead)) {
            if( get_pack_dict(p_dictobj, p_key, p_value) )
                return(TRUE) ;
            else
                return(FALSE) ;
        }
    }   /* else */

    /*
     *  key is NAMETYPE && dict is a RAM dictionary
     */
    if( (TYPE(l_newp) == NAMETYPE) && l_ram ) {
        /*
         * search the name object list of name table
         * for the dictioanry's key-value pair
         */
        l_id = (fix)VALUE(l_newp) ;
        l_dict = name_table[l_id]->dict_ptr ;

        for( ; ;){
            /* LAST ENTRY is encountered: not found */
            if((ULONG_PTR)l_dict < SPECIAL_KEY_VALUE) return(FALSE) ;

            /* get the head address(content) of this dictionary structure */
            l_dtemp = DICT_NAME(l_dict) ;

            /* FOUND */
            if(l_dtemp == l_dptr) {
                *p_value = &(l_dict->v_obj) ;
                return(TRUE) ;
            }

            /* go to the next cell */
            l_dict = (struct dict_content_def huge *)VALUE(&l_dict->k_obj) ;

        }   /* end for */
    }   /* end if: NAMETYPE && RAM dictionary */

    /*
     *  OTHERS
     *
     *  find the key-value pair with LINEAR SEARCH
     */
    else {
        l_actlength = l_dhead->actlength ;

        /* LINEAR SEARCH */
        /* ?? get_virtual_data */
        for(l_index=0 ; l_index < l_actlength ; l_index++, l_dptr++) {
            switch( TYPE(&(l_dptr->k_obj)) ) {
                case NULLTYPE:              /* no element */
                    return(FALSE) ;

                case NAMETYPE:
                    if(l_ram) break ;       /* to next pair */

                default:
                    if( equal_key(&(l_dptr->k_obj), l_newp) ) {
                        *p_value = &(l_dptr->v_obj) ;
                        return(TRUE) ;
                    }
            }   /* switch */
        }   /* for */

        return(FALSE) ;
    }   /* else */
}   /* get_dict */

/***********************************************************************
**
** This submodule loads the value of the given key from a dictionary stack.
**
** TITLE:       load_dict                       Date:   08/01/87
** CALL:        load_dict()                     UpDate: Jul/12/88
** INTERFACE:   op_load:
** CALLS:       load_dict1      5.3.1.4.27
***********************************************************************/
bool
load_dict(p_key, p_value)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
{
    fix     l_flag = FALSE ;

    if( load_dict1(p_key, p_value, (fix FAR *)&l_flag) )
        return(TRUE) ;
    else
        return(FALSE) ;

}   /* load_dict */

/***********************************************************************
**
** This submodule defines a given key and value pair in the
** specified dictionary.
**
** TITLE:       put_dict            Date:   08/01/87
** CALL:        put_dict()          UpDate: Jul/12/88
** INTERFACE:
** CALLS:       put_dict1:      5.3.1.4.26
***********************************************************************/
bool
put_dict(p_dict, p_key, p_value)
struct  object_def  FAR *p_dict, FAR *p_key, FAR *p_value ;
{
    /* dict may be not in dictionary stack */
    if( put_dict1(p_dict, p_key, p_value, FALSE) )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* put_dict */

/***********************************************************************
**
** This submodule pushes various object onto the execution stack to
** establish the environment executing the dictionary forall.
**
** TITLE:       forall_dict         Date:   08/01/87
** CALL:        forall_dict()       UpDate: Jul/12/88
** INTERFACE:   op_forall:      5.3.1.4.13
***********************************************************************/
static bool near
forall_dict(p_dict, p_proc)
struct  object_def  FAR *p_dict, FAR *p_proc ;
{
    if( FREXECOUNT() < 4 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_dict) ;
    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0L) ;
    PUSH_EXEC_OP(AT_DICTFORALL) ;

    return(TRUE) ;
}   /* forall_dict */

/***********************************************************************
**
** This submodule copy the key-value pairs in a dictionary to
** another dictionary.
**
** TITLE:       copy_dict                       Date:   08/01/87
** CALL:        copy_dict()                     UpDate: Jul/12/88
** INTERFACE:   op_copy:            5.3.1.1.4
** CALLS:       get_dict:           5.3.1.4.17
**              change_namekey:     5.3.1.4.31
**              create_new_saveobj: 5.3.1.1.12
***********************************************************************/
bool
copy_dict(p_source, p_dest)
struct  object_def  FAR *p_source, FAR *p_dest ;
{
    ufix16  l_sactlength, l_index ;
    struct  object_def  l_otemp ;
    struct  dict_head_def   FAR *l_sdhead, FAR *l_ddhead ;
    struct  dict_content_def    huge *l_sdict ;

    /*
    ** check the second dictionary.
    ** It will not be defined with any key-value pairs
    */
    l_sdhead = (struct dict_head_def FAR *)VALUE(p_source) ;
    l_ddhead = (struct dict_head_def FAR *)VALUE(p_dest) ;

    /* check access right */
    if( (DACCESS(l_sdhead) == NOACCESS) ||
        (DACCESS(l_ddhead) != UNLIMITED) ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }
    if( (l_ddhead->actlength != 0) ||
        (l_sdhead->actlength > LENGTH(p_dest)) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    /*
     * copy the key-value pairs in the first dictionary
     * to the second dictionary
     */
    l_index = 0 ;
    l_sdict = (struct dict_content_def huge *)
              ( (byte FAR *)l_sdhead + sizeof(struct dict_head_def) ) ;

    l_sactlength = l_sdhead->actlength ;
    while( l_index++ < l_sactlength ) {

        COPY_OBJ( &(l_sdict->k_obj), &l_otemp ) ;
        /* get hash id of key object */
        if( (TYPE(&l_otemp) == NAMETYPE) && (! DROM(l_ddhead)) )
            change_namekey( &(l_sdict->k_obj), &l_otemp ) ;

        put_dict1(p_dest, &l_otemp, &(l_sdict->v_obj), FALSE) ;
        l_sdict++ ;
    }
    /* dict2's access right is same as the dict1 */
    DACCESS_SET(l_ddhead, DACCESS(l_sdhead)) ;

    return(TRUE) ;
}   /* copy_dict */

/***********************************************************************
**
** TITLE:       create_dict                     Date:   08/01/87
** CALL:        create_dict(obj, size)          UpDate: Jul/12/88
** INTERFACE:   op_dict:            5.3.1.4.1
** CALLS:       alloc_vm:           5.3.1.10.5
***********************************************************************/
bool
create_dict(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix    p_size ;
{
    ubyte    huge *l_dict ;
    ufix16  l_i ;
    struct  object_def  huge *l_otemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_contain ;

    l_dict = (ubyte huge *)
             extalloc_vm( (ufix32)p_size * sizeof(struct dict_content_def) +
                        sizeof(struct dict_head_def) ) ;


    if(l_dict != NIL) {
        l_dhead = (struct dict_head_def FAR *)l_dict ;
        DACCESS_SET(l_dhead, UNLIMITED) ;
        DPACK_SET(l_dhead, FALSE) ;
        DFONT_SET(l_dhead, FALSE) ;
        DROM_SET(l_dhead, FALSE) ;
        l_dhead->level = current_save_level ;
        l_dhead->actlength = 0 ;

        l_contain = (struct dict_content_def huge *)
                    ( l_dict + sizeof(struct dict_head_def) ) ;
        /*
         * INITIALIZE
         */
        for(l_i=0 ; l_i < p_size ; l_i++, l_contain++) {
            l_otemp = &(l_contain->k_obj) ;
            TYPE_SET(l_otemp, NULLTYPE) ;
            ATTRIBUTE_SET(l_otemp, LITERAL) ;
            ROM_RAM_SET(l_otemp, KEY_OBJECT) ;
            LEVEL_SET(l_otemp, current_save_level) ;

            LENGTH(l_otemp) = l_i ;
            VALUE(l_otemp) = NIL ;

            l_otemp = &(l_contain->v_obj) ;
            TYPE_SET(l_otemp, NULLTYPE) ;
            ATTRIBUTE_SET(l_otemp, LITERAL) ;
            ROM_RAM_SET(l_otemp, RAM) ;
            LEVEL_SET(l_otemp, current_save_level) ;

            LENGTH(l_otemp) = 0 ;
            VALUE(l_otemp) = NIL ;
        }   /* for */
    }  else
        return(FALSE) ;

    TYPE_SET(p_obj, DICTIONARYTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;

    LENGTH(p_obj) = (ufix16)p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_dict ;

    return(TRUE) ;
}   /* create_dict */

/***********************************************************************
**
** TITLE:       extract_dict                    Date:   08/01/87
** CALL:        extract_dict()                  UpDate: Jul/12/88
** INTERFACE:
** CALLS:       change_namekey:         5.3.1.4.31
**              extract_pack_dict:
***********************************************************************/
bool
extract_dict(p_dict, p_index, p_key, p_value)
struct  object_def  FAR *p_dict, FAR *p_key, FAR * FAR *p_value ;
ufix    p_index ;
{
    struct  object_def      FAR *l_key ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    if(p_index >= l_dhead->actlength) return(FALSE) ;
    l_dict = (struct dict_content_def huge *)
             ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    /* for extract_pack_dict */
    if( DROM(l_dhead) ) {
        if(DPACK(l_dhead)) {
            if( extract_pack_dict(p_dict, p_index, &l_key, p_value) ) {
            /*  @HC29 bug
                COPY_OBJ(l_key, p_key) ;
            */
                //DJC COPY_OBJ_1 causes data missaligne FAULT on MIPS
                //    because assumption was made about casting
                //    to double. Put back to COPY_OBJ and all seems
                //    fine.
                //DJC COPY_OBJ_1(l_key, p_key) ;       /* @HC29 */

                COPY_OBJ(l_key,p_key);
                return(TRUE) ;
            } else
                return(FALSE) ;
        }
    }

    l_dict += p_index ;
    COPY_OBJ( &(l_dict->k_obj), p_key ) ;

    if( (TYPE(p_key) == NAMETYPE) && (! DROM(l_dhead)) )
        change_namekey( p_key, p_key ) ;

    *p_value = &(l_dict->v_obj) ;

    return(TRUE) ;
}   /* extract_dict */

/***********************************************************************
**
** TITLE:       equal_key           Date:   08/01/87
** CALL:        equal_key()         UpDate: Jul/12/88
** INTERFACE:
** CALLS:       sobj_to_nobj:       5.3.1.4.25
***********************************************************************/
bool
equal_key(p_obj1, p_obj2)
struct  object_def  FAR *p_obj1, FAR *p_obj2 ;
{
    ufix16  l_type1, l_type2 ;
    ubyte   huge *l_str1, huge *l_str2 ;
    union   four_byte   l_num1, l_num2 ;
    struct  object_def  l_new1, l_new2 ;

    COPY_OBJ(p_obj1, &l_new1) ;
    COPY_OBJ(p_obj2, &l_new2) ;

    if( (TYPE(p_obj1) == STRINGTYPE) && (TYPE(p_obj2) == STRINGTYPE) )
        goto label_0 ;

    /*
     * STRINGTYPE ==> NAMETYPE
     */
    if( TYPE(p_obj1) == STRINGTYPE ) {
        if( ! sobj_to_nobj(p_obj1, &l_new1) )
            return(FALSE) ;     /* system error: name_to_id */
    } else {
        if( TYPE(p_obj2) == STRINGTYPE ) {
            if( ! sobj_to_nobj(p_obj2, &l_new2) )
                return(FALSE) ;             /* system error: name_to_id */
        }
    }

label_0:
    l_type1 = TYPE(&l_new1) ;
    l_type2 = TYPE(&l_new2) ;

    switch(l_type1) {
        case NAMETYPE:
        case BOOLEANTYPE:
        case OPERATORTYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) )
                return(TRUE) ;
            break ;

        case STRINGTYPE:    /* type1 = type2 */
            if( (l_type1 == l_type2) && (LENGTH(&l_new1) == LENGTH(&l_new2)) ) {
                if( (ACCESS(&l_new1) == NOACCESS) ||
                    (ACCESS(&l_new2) == NOACCESS) ) {
                    ERROR(INVALIDACCESS) ;
                    return(FALSE) ;
                }
                l_str1 = (ubyte huge *)VALUE(&l_new1) ;
                l_str2 = (ubyte huge *)VALUE(&l_new2) ;
                for( ; l_new1.length-- && (*l_str1++ == *l_str2++) ; ) ;
                if(LENGTH(&l_new1) == 0xFFFF)
                    return(TRUE) ;
            }
            break ;

        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case FILETYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) &&
                (LENGTH(&l_new1) == LENGTH(&l_new2)) )
                return(TRUE) ;
            break ;

        case DICTIONARYTYPE:
            if( (l_type1 == l_type2) && (VALUE(&l_new1) == VALUE(&l_new2)) ) {
                /*
                l_dhead1 = (struct dict_head_def huge *)VALUE(&l_new1) ;
                l_dhead2 = (struct dict_head_def huge *)VALUE(&l_new2) ;
                */
                return(TRUE) ;
            }
            break ;
        /*
        **  if object1 is a number object: convert to FLOAT
        */
        case INTEGERTYPE:
            l_num1.ll = (fix32)VALUE(&l_new1) ;
            l_num1.ff = (real32)l_num1.ll ;
            goto label_1 ;
        case REALTYPE:
            l_num1.ll = (fix32)VALUE(&l_new1) ;
            goto label_1 ;

        case FONTIDTYPE:
        case SAVETYPE:
            break ;

        case MARKTYPE:
        case NULLTYPE:
            if( l_type1 == l_type2 )
                return(TRUE) ;
    }   /* switch */

    return(FALSE) ;

label_1:
    /*
    **  if object2 is a number object: convert to FLOAT
    */
    switch(l_type2) {
        case INTEGERTYPE:
            l_num2.ll = (fix32)VALUE(&l_new2) ;
            l_num2.ff = (real32)l_num2.ll ;
            goto label_2 ;
        case REALTYPE:
            l_num2.ll = (fix32)VALUE(&l_new2) ;
            goto label_2 ;

        default:
            return(FALSE) ;
    }   /* switch */

label_2:
    if( l_num1.ff == l_num2.ff )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* equal_key */

/***********************************************************************
**
** TITLE:       check_key_object            Date:   08/01/87
** CALL:        check_key_object()          UpDate: Jul/12/88
** INTERFACE:   op_restore:     5.3.1.10.2
***********************************************************************/
void
check_key_object(p_object)
struct  object_def  FAR *p_object ;
{
    struct  dict_head_def   FAR *l_dhead ;

    if( (TYPE(p_object) == NULLTYPE) &&
        (ROM_RAM(p_object) == KEY_OBJECT) ) {

        l_dhead = (struct dict_head_def FAR *)
                  ( (byte huge *)p_object -
                    LENGTH(p_object) * sizeof(struct dict_content_def) -
                    sizeof(struct dict_head_def) ) ;

        /* restore actual length of dictionary */
        l_dhead->actlength-- ;
    }
}   /* check_key_object */

/***********************************************************************
**
** TITLE:       change_dict_stack           Date:   08/01/87
** CALL:        change_dict_stack()         UpDate: Jul/12/88
** INTERFACE:   op_begin:   5.3.1.4.4
**              op_end:     5.3.1.4.5
***********************************************************************/
void
change_dict_stack()
{
    fix     l_index ;

    global_dictstkchg++ ;
    if(global_dictstkchg == 0) {            /* wrap around */
        global_dictstkchg++ ;

        /* change dict_found field of name_table ? */
        for(l_index=0 ; l_index < MAXHASHSZ ; l_index++)
            //DJC, added a check here for NULL dereference
            if (name_table[l_index] != (struct ntb_def *) NULL) {
               name_table[l_index]->dict_found = FALSE ;
            }else{
               printf("Warning....... Nane table[%d] is null",l_index); //TODO take out
            }
    }

    return ;
}   /* change_dict_stack */

/***********************************************************************
**
** TITLE:       sobj_to_nobj                Date:   08/01/87
** CALL:        sobj_to_nobj()              UpDate: Jul/12/88
** INTERFACE:
** CALLS:       name_to_id:
***********************************************************************/
bool
sobj_to_nobj(p_sobj, p_nobj)
struct  object_def  FAR *p_sobj, FAR *p_nobj ;
{
    fix16   l_id ;
    byte    FAR *l_str ;

    if( ACCESS(p_sobj) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    if( LENGTH(p_sobj) >= MAXNAMESZ ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    COPY_OBJ(p_sobj, p_nobj) ;
    if( LENGTH(p_sobj) == 0 )
        l_id = 0 ;
    else  {
        l_str = (byte FAR *)VALUE(p_sobj) ;
        if( ! name_to_id((byte FAR *)l_str,
                       (ufix16)LENGTH(p_sobj), &l_id, TRUE) )
            return(FALSE) ;
    }

    VALUE(p_nobj) = (ufix32)l_id ;
    TYPE_SET(p_nobj, NAMETYPE) ;

    return(TRUE) ;
}   /* sobj_to_nobj */

/***********************************************************************
**
** TITLE:       astore_stack                    Date:   12/03/87
** CALL:        astore_stack()                  UpDate: Jul/12/88
** INTERFACE:   op_dictstack
**              op_execstack
***********************************************************************/
bool
astore_stack(p_array, p_mode)
 struct  object_def  FAR *p_array ;
 fix     p_mode ;
{
    fix     l_index, l_i ;
    struct  object_def  FAR *l_obj ;

    /*
    ** copy the object in stack
    ** to the array in the operand stack
    */
    if(p_mode == DICTMODE) {
        l_obj = dictstack ;
        LENGTH(p_array) = dictstktop ;
    } else {
        l_obj = execstack ;
        LENGTH(p_array) = execstktop ;
    }
    l_i = (fix)LENGTH(p_array) ;
    for (l_index = 0 ; l_index < l_i ; l_index++, l_obj++)
        put_array(p_array, l_index, l_obj) ;

    return(TRUE) ;
}   /* astore_stack */

/***********************************************************************
**
** TITLE:       get_dict_valobj                 Date:   02/04/87
** CALL:        get_dict_valobj()               UpDate: Jul/12/88
** INTERFACE:
**
***********************************************************************/
bool
get_dict_valobj(p_value, p_dict, p_valobj)
ufix32  p_value ;
struct  object_def  FAR *p_dict, FAR * FAR *p_valobj ;
{
    ufix16  l_j, l_actlength ;
    struct  dict_content_def    huge *l_dcontain ;
    struct  dict_head_def   FAR *l_dhead ;

    l_dhead = (struct dict_head_def FAR *)VALUE(p_dict) ;
    l_actlength = l_dhead->actlength ;
    l_dcontain = (struct dict_content_def huge *)
                 ( (byte FAR *)l_dhead + sizeof(struct dict_head_def) ) ;

    for(l_j=0 ; l_j < l_actlength ; l_j++, l_dcontain++) {
        if( p_value == VALUE(&l_dcontain->v_obj) ) {
            *p_valobj = &(l_dcontain->v_obj) ;
            return(TRUE) ;
        }
    }   /* for(l_j) */

    return(FALSE) ;
}   /* get_dict_valobj */

/* qqq, begin */
/*
************************************************************************
*
*   This submodule loads the value of the given key from a dictionary
*   stack.
*
*   Name:       load_name_obj
*
************************************************************************
*/
#ifdef  LINT_ARGS
bool    load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
#else
bool    load_name_obj();
#endif
bool
load_name_obj(p_key, p_value)
struct  object_def  FAR *p_key, FAR * FAR *p_value ;
{
    fix     l_id, l_index ;
    struct  object_def  huge *l_dictobj, huge *l_vtemp ;
    struct  dict_head_def   FAR *l_dhead ;
    struct  dict_content_def    huge *l_dict, huge *l_dptr,
                                huge *l_dold, huge *l_fstptr ;

    l_id = (fix)VALUE(p_key) ;
    /*
     * if the name object is defined in a RAM dictionary,
     * it will be in the object lists in the name table.
     *
     * the dictionary cell is linked in the header entry
     */
    if( (name_table[l_id]->dstkchg == global_dictstkchg) &&
        (name_table[l_id]->dict_found) ) {
        /* get first element */
        *p_value = &(name_table[l_id]->dict_ptr->v_obj) ;
        return(TRUE) ;
    }
    /*
     *  RESCHEDULE NAME LIST
     */
    else {
        /*  link list */
        l_index = dictstktop -1 ;
        l_fstptr = name_table[l_id]->dict_ptr ;

        /*  get dictionary from dictionary stack */
        while( l_index >= 0 ) {
            l_dictobj = &dictstack[l_index] ;
            l_dhead = (struct dict_head_def huge *)VALUE(l_dictobj) ;

            if(DROM(l_dhead)) {
                /*
                 *  ROM
                 */
                if( get_dict(l_dictobj, p_key,
                            (struct object_def FAR * FAR*)&l_vtemp) ) {
                    name_table[l_id]->dict_found = FALSE ;
                    *p_value = l_vtemp ;
                    return(TRUE) ;
                }
                /* else: to next dict */
            }   /* ROM */
            else {
                /*
                 *  RAM
                 *
                 * search this RAM dictionary's address in link list
                 */
                if((ULONG_PTR)l_fstptr < SPECIAL_KEY_VALUE) {
                    l_index-- ;
                    continue ;
                }
                l_dict = l_fstptr ;                     /* name list */
                l_dold = NIL ;
                l_dptr = (struct dict_content_def huge *)
                         ((byte FAR *)l_dhead + sizeof(struct dict_head_def));
                for(;;) {
                    if( (ULONG_PTR)l_dict < SPECIAL_KEY_VALUE )  break ;
                    /*
                     * FOUND, this key in l_dictobj
                     */
                    if( DICT_NAME(l_dict) == l_dptr ) {
                        /* CHANGE THIS ELEMENT TO FRONT OF LIST */
                        if( l_dold != NIL ) {
                            VALUE(&l_dold->k_obj) = VALUE(&l_dict->k_obj) ;
                            VALUE(&l_dict->k_obj) = (ULONG_PTR)l_fstptr ;
                            name_table[l_id]->dict_ptr = l_dict ;
                        }
                        name_table[l_id]->dict_found = TRUE ;
                        name_table[l_id]->dstkchg = global_dictstkchg ;
                        *p_value = &(l_dict->v_obj) ;
                        return(TRUE) ;

                    } else {
                        /* to next element of name list */
                        l_dold = l_dict ;
                        l_dict = (struct dict_content_def huge *)
                                 VALUE(&l_dict->k_obj) ;
                    }
                }   /* for */
            }   /* RAM */
            l_index-- ;
        }   /* while(l_index) */

        /* names in ROM dict are not chain to namelist */
        ERROR(UNDEFINED) ;
        return(FALSE) ;
    }   /* else */
}   /* load_name_obj */
/* qqq, end */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\control.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              CONTROL.C
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include  "global.ext"
#include  <string.h>
#include  <stdio.h>
#include        "user.h"                  /* include by Falco for SYSTEMDICT */
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"

extern void GEIio_restart(void);        /* @WIN */
/* Submodule op_exec
**
** Function Description
**
** This submodule implement the operator exec.
** its operand and result on the operand stack are:
**     proc -exec-
** it push the operand onto the execution stack, and executing it immediately.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_exec()
{
    struct object_def  FAR *cur_obj ;

    if (FREXECOUNT() < 1)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       cur_obj = GET_OPERAND(0) ;
       if (ACCESS(cur_obj) == NOACCESS)
          ERROR(INVALIDACCESS) ;
       else {
/* qqq, begin */
          /*
          PUSH_EXEC_OBJ(cur_obj) ;
          POP(1) ;
          */
          if( P1_ATTRIBUTE(cur_obj) == P1_EXECUTABLE ) {
              PUSH_EXEC_OBJ(cur_obj);
              POP(1);
          }
/* qqq, end */
       }
    }

    return(0) ;
}   /* op_exec() */

/* Submodule op_if
**
** Function Description
**
** This submodule implement the operator if.
** its operands on the operand stack are:
**     boolean proc -if-
** it remove operands from the operand stack, and then executes the proc
** if the boolean is true.
**
** Interface with Other Modules
**     Input   :
**         1. A boolean and a procedure objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_if()
{
    if (VALUE(GET_OPERAND(1)) == TRUE) {
          if (FREXECOUNT() < 1)
             ERROR(EXECSTACKOVERFLOW) ;
          else {
             PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
             POP(2) ;
          }
    } else
      POP(2) ;

    return(0) ;
}   /* op_if() */

/* Submodule op_ifelse
**
** Function Description
**
** This submodule implement the operator ifelse.
** its operands on the operand stack are:
**     bool proc1 proc2 -ifelse-
** it removes all operands from the operand stack, executes proc1
** if the bool is true or proc2 if bool is false.
**
** Interface with Other Modules
**     Input   :
**         1. Two procedure and a boolean objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_ifelse()
{
    if (FREXECOUNT() < 1)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       if (VALUE(GET_OPERAND(2)) == TRUE) {
          PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
       } else
          PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
       POP(3) ;
    }

    return(0) ;
}   /* op_ifelse() */

/* Submodule op_for
**
** Function Description
**
** This submodule implement the operator for.
** its operands on the operand stack are:
**     init incr limit proc -for-
** it executes the proc repeatedly, passing it a sequence of values
** from initial by steps of increment to limit.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure and three number objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_for()
{
    ufix16  type1, type2, type3 ;
    union four_byte  temp ;
    struct object_def  temp_obj ;

    type1 = TYPE(GET_OPERAND(1)) ;
    type2 = TYPE(GET_OPERAND(2)) ;
    type3 = TYPE(GET_OPERAND(3)) ;
    if (FREXECOUNT() < 5)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
       if (type2 == REALTYPE || type3 == REALTYPE) {
          if (type1 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(1))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(1), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
          if (type2 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(2))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(2), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(2)) ;
          if (type3 == INTEGERTYPE) {
             temp.ff = (real32)((fix32)VALUE(GET_OPERAND(3))) ;  /* cast to real */
             COPY_OBJ(GET_OPERAND(3), &temp_obj) ;
             TYPE_SET(&temp_obj, REALTYPE) ;
             temp_obj.value = temp.ll ;
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(3)) ;
          PUSH_EXEC_OP(AT_RFOR) ;          /* push @rfor */
       } else {         /* integer for */
          if (type1 == REALTYPE) {
             temp.ll = (fix32)VALUE(GET_OPERAND(1)) ;
             COPY_OBJ(GET_OPERAND(1), &temp_obj) ;
             TYPE_SET(&temp_obj, INTEGERTYPE) ;
             temp_obj.value = (ufix32)temp.ff ;          /* cast to integer */
             PUSH_EXEC_OBJ(&temp_obj) ;
          } else
             PUSH_EXEC_OBJ(GET_OPERAND(1)) ;
          PUSH_EXEC_OBJ(GET_OPERAND(2)) ;   /* push incr */
          PUSH_EXEC_OBJ(GET_OPERAND(3)) ;   /* push init */
          PUSH_EXEC_OP(AT_IFOR) ;           /* push @ifor */
       }
       POP(4) ;
    } /* else */

    return(0) ;
}   /* op_for() */

/* Submodule op_repeat
**
** Function Description
**
** This submodule implement the operator repeat.
** its operands on the operand stack are:
**     int proc -repeat-
** it executes the proc int times.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure and an integer objects on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_repeat()
{
    if ((fix32)VALUE(GET_OPERAND(1)) < 0)
       ERROR(RANGECHECK) ;
    else if (FREXECOUNT() < 3)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
      PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
      PUSH_EXEC_OBJ(GET_OPERAND(1)) ;   /* push int */
      PUSH_EXEC_OP(AT_REPEAT) ;         /* push @repeat */
      POP(2) ;
    }

    return(0) ;
}   /* op_repeat() */

/*
** Submodule op_loop
**
** Function Description
**
** This submodule implement the operator loop.
** its operand on the operand stack is:
**     proc -loop-
** it repeatedly executes proc until a operator exit is executed in the
** procedure.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_loop()
{
    if (FREXECOUNT() < 2)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
      PUSH_EXEC_OBJ(GET_OPERAND(0)) ;   /* push proc */
      PUSH_EXEC_OP(AT_LOOP) ;           /* push @loop */
      POP(1) ;
    }

    return(0) ;
}   /* op_loop() */

/* Submodule op_exit
**
** Function Description
**
** This submodule implement the operator exit.
**     -exit-
** it terminates execution of innermost dynamically enclosing instance of
** a looping context. A looping context is a procedure invoked repeatedly
** by one of the control operators for, loop, repeat, forall, pathforall.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         None
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_exit()
{
    struct object_def  FAR *cur_obj ;

    for ( ; ;) {
        /*
        ** remove the topmost object of the execution stack until
        ** a looping operator is encourdered.
        */
/* qqq, begin */
        /*
        cur_obj = &execstack[execstktop - 1];
        if ((TYPE(cur_obj) == OPERATORTYPE) && (ROM_RAM(cur_obj) == ROM)) {
        */
        cur_obj = GET_EXECTOP_OPERAND();
        if( (P1_ROM_RAM(cur_obj) == P1_ROM) &&
            (TYPE(cur_obj) == OPERATORTYPE) ) {
/* qqq, end */
        /*
         * special treatment for @_operator
         */
           switch (LENGTH(cur_obj)) {

           case AT_EXEC :
                ERROR(INVALIDEXIT) ;
               /*
                * set access field be NOACESSS for following operators
                * in case of invalidexit, in order to distinguish from
                * normally exit.
                *
                * ATT : the handling for run is different from LaserWriter.
                *
                * -- image, imagemask, settransfer, kshow, BuildChar,
                *    setscreen, pathforall, run(*)
                */
                ACCESS_SET(cur_obj, NOACCESS) ;
                return(-4) ;          /* op_exit-2 */

           case AT_STOPPED :
                ERROR(INVALIDEXIT) ;
                break ;

           case AT_IFOR :
           case AT_RFOR :
                POP_EXEC(5) ;
                break ;

           case AT_LOOP :
                POP_EXEC(2) ;
                break ;

           case AT_REPEAT :
                POP_EXEC(3) ;
                break ;

           case AT_DICTFORALL :
                POP_EXEC(4) ;
                break ;

           case AT_ARRAYFORALL :
           case AT_STRINGFORALL :
                POP_EXEC(3) ;

           default :
                break ;
           } /* switch */
           break ;
        } else
           POP_EXEC(1) ;
    } /* for */

    return(0) ;
}   /* op_exit() */

/*
** Submodule  op_stop
**
** Function Description
**
** This submodule implement the operator stop.
**      -stop-
** it terminates execution of the innermost dynamically enclosing instance
** of a stopped context.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_stop()
{
    struct object_def FAR *cur_obj, FAR *temp_obj ;

/* qqq, begin */
    /*
    cur_obj = &execstack[execstktop];      |* get this "op_stop" object *|
    */
    cur_obj = execstkptr;
/* qqq, end */
    while (1) {
       if (execstktop) {
/* qqq, begin */
          /*
          temp_obj = &execstack[execstktop - 1];   |* get next object *|
          if ((TYPE(temp_obj) == OPERATORTYPE) && (ROM_RAM(temp_obj) == ROM)) {
          */
          temp_obj = GET_EXECTOP_OPERAND();
          if( (P1_ROM_RAM(temp_obj) == P1_ROM) &&
              (TYPE(temp_obj) == OPERATORTYPE) ) {
/* qqq, end */
             if (LENGTH(temp_obj) == AT_EXEC) {
/* qqq, begin */
                /*
                POP_EXEC(1);
                PUSH_EXEC_OBJ(cur_obj);    |* replaced @exec by op_stop *|
                */
                COPY_OBJ(cur_obj, GET_EXECTOP_OPERAND());
/* qqq, end */
                return(-1) ;                /* error code - stop happen */
             } else if (LENGTH(temp_obj) == AT_STOPPED) {
                ACCESS_SET(temp_obj, NOACCESS) ;
                return(0) ;                 /* normal exit */
             }
          }
          POP_EXEC(1) ;
       } else                   /* no enclosing stopped is found til bottom */
          return(op_quit()) ;    /* terminate operation of the interpreter */
    } /* while */
}   /* op_stop() */

/*
 * terminate operation of the interpreter permanently, the precise action
 * of this quit depends on the environment in which the PostScript interpreter
 * is running
 */
fix
op_quit()
{
#ifdef DBG
    printf("PostScript Interpreter Requested Printer To Reboot.\n") ;
#endif

    if (current_save_level) {
        struct object_def FAR *l_stopobj;
        get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
        PUSH_EXEC_OBJ(l_stopobj) ;
        return(0) ;
    }

    GEIio_restart(); /* erik chen 5-13-1991 */

    return(0) ;
/*  return(-3) ; */
}   /* op_quit() */

/*
** Submodule op_stopped
**
** Function Description
**
** This submodule implement the operator stopped.
** its operand and result on the operand stack are:
            GEIio_ioctl(GEIio_stdout, _FIONRESET, (char*)0) ;
**     any -stopped- boolean
** the any is a stopped context, if this any runs to completion normally,
** it returns false, if any terminates prematurely as a result of executing
** stop, it return true.
**
** Interface with Other Modules
**     Input   :
**         1. A procedure object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_stopped()
{
    if (FREXECOUNT() < 2)
       ERROR(EXECSTACKOVERFLOW) ;
    else {
       PUSH_EXEC_OP(AT_STOPPED) ;
       PUSH_EXEC_OBJ(GET_OPERAND(0)) ;
       POP(1) ;
    }

    return(0) ;
}   /* op_stopped() */

/*
** Submodule op_countexecstack
**
** Function Description
**
** This submodule implement the operator countexecstack.
** its result on the operand stack is:
**     -countexcstack- integer
** it counts the number of object on the execution stack, and pushes this
** this count on the operand stack.
**
** Interface with Other Modules
**     Input   :
**         1. interpreter()
**
**     Output  :
**         1. An integer object on the operand stack
**         2. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Modified
*/
fix
op_countexecstack()
{
    if (FRCOUNT() < 1)
       ERROR(STACKOVERFLOW) ;
    else
     /*
      * push an integer object indicating the depth of the execution stack
      */
       PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, execstktop) ;

    return(0) ;
}   /* op_countexecstack() */

/*
** Submodule op_execstack
**
** Function Description
**
** This submodule implement the operator execstack.
** its operand and result on the operand stack are:
**     array -execstack- subarray
** it stores all elements of the execution stack into the array and
** returns an object describing the initial n-element subarray of array.
**
** Interface with Other Modules
**     Input   :
**         1. An array object on the operand stack
**         2. interpreter()
**
**     Output  :
**         1. ERROR()
**
** Data Items Accessed, Created, and/or Modified
**     1. operand stack - Modified
**     2. execution stack - Accessed
*/
fix
op_execstack()
{
    if (TYPE(GET_OPERAND(0)) == PACKEDARRAYTYPE)
       ERROR(INVALIDACCESS) ;
    else if (LENGTH(GET_OPERAND(0)) < execstktop)
       ERROR(RANGECHECK) ;
    else        /* execstackoverflow */
       astore_stack(GET_OPERAND(0), EXECMODE) ;

    return(0) ;
}   /* op_execstack() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\constant.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * "Constant.h"
 *  Date:       08/11/87
 *              4/2/91: Move floating point flag from "float.h"; scchen
 */

/* @WIN: turn near, huge, and huge on */
//#define     near
//#define     far
//#define     huge

#ifndef TRUE
#define     TRUE        1
#define     FALSE       0
#endif

#define     NIL         0L         /* nil pointer */

#define     MAX15       32767
#define     MIN15       -32768
#define     UMAX16      65535

#define     MAX31       2147483647L
#define     MIN31       0x80000000
#define     UMAX32      4294967295L

#define     EMAXP       1e38
#define     EMINP       1e-38
#define     EMAXN       -1e-38
#define     EMINN       -1e38
#define     INFINITY    0x7f800000L   /* infinity number: IEEE format */
/*
#define     INFINITY    0x7f7fffffL   |* infinity number, for FPa option */
#define     PI          (float)3.1415926

/*****************
 |  OBJECT TYPE  |
 *****************/
#define     EOFTYPE             0
#define     ARRAYTYPE           1
#define     BOOLEANTYPE         2
#define     DICTIONARYTYPE      3
#define     FILETYPE            4
#define     FONTIDTYPE          5
#define     INTEGERTYPE         6
#define     MARKTYPE            7
#define     NAMETYPE            8
#define     NULLTYPE            9
#define     OPERATORTYPE        10
#define     REALTYPE            11
#define     SAVETYPE            12
#define     STRINGTYPE          13
#define     PACKEDARRAYTYPE     14

/***************
 |  ATTRIBUTE  |
 ***************/
#define     LITERAL             0
#define     EXECUTABLE          1
#define     IMMEDIATE           2       /* use by scanner */

#define     P1_LITERAL          0               /* qqq */
#define     P1_EXECUTABLE       0x0010          /* qqq */
#define     P1_IMMEDIATE        0x0020          /* qqq */
/************
 |  ACCESS  |
 ************/
/*
 * ATT:
 * for @_stopped object, the access field is used to record the result of
 * executing stopped context, UNLIMITED means it runs to completion normally,
 * and NOACCESS means it terminates prematurely by executing stop
 */
#define     UNLIMITED           0
#define     READONLY            1
#define     EXECUTEONLY         2
#define     NOACCESS            3

#define     P1_UNLIMITED        0               /* qqq */
#define     P1_READONLY         0x2000          /* qqq */
#define     P1_EXECUTEONLY      0x4000          /* qqq */
#define     P1_NOACCESS         0x6000          /* qqq */
/*************
 |  RAM/ROM  |
 *************/
/*
 * ATT:
 * for operator object, the rom_ram field is used to indicate operator type,
 * ROM means @_operator, RAM means normal PostScript operator, and
 * STA means status_dict resident operator
 */
#define     RAM                 0
#define     ROM                 1
#define     KEY_OBJECT          2       /* used by key object of dictionary */

#define     P1_RAM              0               /* qqq */
#define     P1_ROM              0x0040          /* qqq */
#define     P1_KEY_OBJECT       0x0080          /* qqq */

/*
 * position of object's bitfield
 *
 *   1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 *   5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *  | ACCESS | LEVEL        | ROM | ATT | TYPE      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *
 */
#define     TYPE_BIT            0
#define     ATTRIBUTE_BIT       4
#define     ROM_RAM_BIT         6
#define     LEVEL_BIT           8
#define     ACCESS_BIT          13

#define     TYPE_ON             0x000F
#define     ATTRIBUTE_ON        0x0003
#define     ROM_RAM_ON          0x0003
#define     LEVEL_ON            0x001F
#define     ACCESS_ON           0x0007

#define     TYPE_OFF            0xFFF0
#define     ATTRIBUTE_OFF       0xFFCF
#define     ROM_RAM_OFF         0xFF3F
#define     LEVEL_OFF           0xE0FF
#define     ACCESS_OFF          0x1FFF

#define     P1_TYPE_ON          0x000F          /* qqq */
#define     P1_ATTRIBUTE_ON     0x0030          /* qqq */
#define     P1_ROM_RAM_ON       0x00C0          /* qqq */
#define     P1_LEVEL_ON         0x01F0          /* qqq */
#define     P1_ACCESS_ON        0xE000          /* qqq */

/************
 |  STACK   |
 ************/
#define     OPNMODE             0
#define     DICTMODE            1
#define     EXECMODE            2

/********************************
 |  PACKED ARRAY OBJECT HEADER  |
 ********************************/
#define     SINTEGERPACKHDR     0x00    /* -1 ~ 18, 1 byte */
#define     BOOLEANPACKHDR      0x20
#define     LNAMEPACKHDR        0x40    /* Literal Name */
#define     ENAMEPACKHDR        0x60    /* Executable Name */
#define     OPERATORPACKHDR     0x80    /* 5 bytes objects */
#define     LINTEGERPACKHDR     0xA0
#define     REALPACKHDR         0xA1
#define     FONTIDPACKHDR       0xA2
#define     NULLPACKHDR         0xA4
#define     MARKPACKHDR         0xA5
#define     _9BYTESPACKHDR      0xC0    /* 9 bytes objects */
#define     SAVEPACKHDR         0xC0
#define     ARRAYPACKHDR        0xC0
#define     PACKEDARRAYPACKHDR  0xC0
#define     DICTIONARYPACKHDR   0xC0
#define     FILEPACKHDR         0xC0
#define     STRINGPACKHDR       0xC0


// DJC DJC
// moved to PSGLOBAL.H to allow for common error codes
// between PSTODIB and interpreter
#ifdef MOVED_ERROR_CODES
/****************
 |  ERROR CODE  |
 ****************/
#ifndef	NOERROR
#define     NOERROR             0
#endif
#define     DICTFULL            1
#define     DICTSTACKOVERFLOW   2
#define     DICTSTACKUNDERFLOW  3
#define     EXECSTACKOVERFLOW   4
#define     HANDLEERROR         5
#define     INTERRUPT           6
#define     INVALIDACCESS       7
#define     INVALIDEXIT         8
#define     INVALIDFILEACCESS   9
#define     INVALIDFONT         10
#define     INVALIDRESTORE      11
#define     IOERROR             12
#define     LIMITCHECK          13
#define     NOCURRENTPOINT      14
#define     RANGECHECK          15
#define     STACKOVERFLOW       16
#define     STACKUNDERFLOW      17
#define     SYNTAXERROR         18
#define     TIMEOUT             19
#define     TYPECHECK           20
#define     UNDEFINED           21
#define     UNDEFINEDFILENAME   22
#define     UNDEFINEDRESULT     23
#define     UNMATCHEDMARK       24
#define     UNREGISTERED        25
#define     VMERROR             26

#endif // DJC ifdef MOVED_ERROR_CODES

/**************************
 |  @_OPERATOR TYPE CODE  |
 **************************/
#define     AT_EXEC             0
#define     AT_IFOR             1
#define     AT_RFOR             2
#define     AT_LOOP             3
#define     AT_REPEAT           4
#define     AT_STOPPED          5
#define     AT_ARRAYFORALL      6
#define     AT_DICTFORALL       7
#define     AT_STRINGFORALL     8

/**********************
 |  SYSTEM PARAMETER  |
 **********************/
#define     HASHPRIME           7600   /* hash prime no# -- 85% * MAXHASHSZ */
#define     MAXHASHSZ           8980   /* Max. no# of the name table */

#define     MAXOPERSZ           9      /* Max. no# of the @_operator table */
#define     MAXSYSDICTSZ        280    /* Max. key_value pair on systemdict */
#define     MAXSTATDICTSZ       180    /* Max. key_value pair on statusdict */
#define     MAXUSERDICTSZ       200    /* Max. key_value pair on userdict */
#define     MAX_VM_CACHE_NAME   30     /* qqq */

#define     MAXARYCAPSZ         65535  /* Max. length of an array */
#define     MAXDICTCAPSZ        65535  /* Max. capacity of a dictionary */
#define     MAXSTRCAPSZ         65535  /* Max. length of a string */
#define     MAXNAMESZ           128    /* Max. no# of chars in a name */
#define     MAXFILESZ           11     /* Max. no# of open files */
#define     MAXOPNSTKSZ         500    /* Max. depth of the operand stack */
#define     MAXDICTSTKSZ        20     /* Max. depth of the dictionary stack */
#define     MAXEXECSTKSZ        250    /* Max. depth of the execution stack */
#define     MAXINTERPRETSZ      15     /* Max. no# of re_call interpreter */
#define     MAXSAVESZ           15     /* Max. no# of active save */
#define     MAXGSAVESZ          31     /* Max. no# of active gsave */

//DJCold#define     MAXPATHSZ           1500   /* Max. no# of points in path descr. */
#define     MAXPATHSZ           2500   /* Max. no# of points in path descr. */
#define     MAXDASHSZ           11     /* Max. no# of element in dash patt. */


/*******************************
 |  Floating point status flag |
 *******************************/
/* define for PDL _control87 routine */
#define     IC_AFFINE           0x1000          /*   affine */
#define     RC_NEAR             0x0000          /*   near */
#define     PC_64               0x0300          /*    64 bits */
#define     MCW_EM              0x003f          /* interrupt Exception Masks */

/* define for PDL CHECK_INFINITY macro */
/*  User Status Word Bit Definitions  */
#define SW_INVALID              0x0001          /*   invalid */
#define SW_DENORMAL             0x0002          /*   denormal */
#define SW_ZERODIVIDE           0x0004          /*   zero divide */
#define SW_OVERFLOW             0x0008          /*   overflow */
#define SW_UNDERFLOW            0x0010          /*   underflow */
#define SW_INEXACT              0x0020          /*   inexact (precision) */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\dict.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DICT.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#define     DICT_NAME(contain)\
            (contain - (contain->k_obj.length))

#define     POP_KEY\
            {\
                free_new_name(GET_OPERAND(0)) ;\
                POP(1) ;\
            }

/* for the value field of composite object */
union   obj_value  {
    struct  object_def      huge *oo ;   /* for general object */
    struct  dict_head_def   far  *dd ;   /* for dictionary object */
    ubyte                   far  *ss ;   /* for string object */
} ;

#ifdef  LINT_ARGS
static bool near forall_dict(struct object_def FAR*, struct object_def FAR*),
            near where(struct object_def FAR* FAR*, struct object_def FAR*),
            near load_dict1(struct object_def FAR *,
                            struct object_def FAR * FAR*, bool FAR*), /*@WIN*/
            near check_key_type(struct object_def FAR *, struct object_def FAR *);
static void near
            change_namekey(struct object_def huge *, struct object_def FAR *) ;
#else
static bool near forall_dict(),
            near where(),
            near load_dict1(),
            near check_key_type() ;
static void near
            change_namekey() ;
#endif  /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\dict_tab.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * !!!IMPORTANT!!!
 *      1)please comment when you add or delete anything
 *      2)change exec.h
 *
 * revision history:
 *      7/13/90; ccteng; define #copies, manualfeedtimeout here
 *                      rename $printerdict to pagedict
 *      7/20/90; ccteng; 1)include language.h
 *                       2)redefine struct dicttab_def in global.ext
 *                       3)delete length element in every entries
 *                       4)clean out junks
 *                       5)delete internaldict, version, revision
 *                       6)add currentport, channelconfig, setchannelconfig
 *                         defaultchannelconfig, setdefaultchannelconfig
 *      7/21/90; ccteng; 1)move following stuff to PSPrep:
 *                         appletalktype, jobsource, jobname, manualfeed,
 *                         eerom
 *                       2)delete following for server change:
 *                         checkinputport, portarray, stdinname, PCbus,
 *                         Serial, Parallel, Network, Gio, execstdin,
 *                         enterserver, protectserver
 *      8/7/90; scchen;  1) added op_setfilecachelimit, op_filecachelimit
 *                       2) added st_selectsubstitutefont,
 *                                st_setsubstitutefonts,
 *                                st_substitutefonts
 *                       3) added op_readsfnt
 *      9/19/90; ccteng; add op_readhexsfnt
 */


// DJC added global include file
#include "psglobal.h"


#include "constant.h"
#include "global.ext"
#include "language.h"

/*
 *   1  1  1  1  1  1  0  0  0  0  0  0  0  0  0  0
 *   5  4  3  2  1  0  9  8  7  6  5  4  3  2  1  0
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *  | ACCESS | LEVEL        | ROM | ATT | TYPE      |
 *  +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
 *
 * access: UNLIMITED ==> 0
 * level: 0 ==> 0
 * rom_ram: RAM ==> 0
 * att: LITERAL ==> 0
 */

#define     SYSOPREUBFD  (OPERATORTYPE | (EXECUTABLE << ATTRIBUTE_BIT))
#define     SYSPKAEUBFD  (PACKEDARRAYTYPE | (EXECUTABLE << ATTRIBUTE_BIT)
#define     SYSPKAERBFD  (PACKEDARRAYTYPE | (EXECUTABLE << ATTRIBUTE_BIT) | (READONLY << ACCESS_BIT))
#define     SYSDCTLUBFD  (DICTIONARYTYPE)
#define     SYSDCTLRBFD  (DICTIONARYTYPE | (READONLY << ACCESS_BIT))
#define     SYSDCTEUBFD  (DICTIONARYTYPE | (EXECUTABLE << ATTRIBUTE_BIT))
#define     SYSBOLLUBFD  (BOOLEANTYPE)
#define     SYSINTLUBFD  (INTEGERTYPE)
#define     SYSSTRLUBFD  (STRINGTYPE)
#define     SYSSTRLRBFD  (STRINGTYPE | (READONLY << ACCESS_BIT))
#define     SYSNULLUBFD  (NULLTYPE)
#define     SYSARYLRBFD  (ARRAYTYPE | (READONLY << ACCESS_BIT))

/* qqq, begin */
#define     INTOPREUBFD  ((OPERATORTYPE | P1_EXECUTABLE) | P1_ROM)
/* qqq, end */

// DJC DJC commented out
// #ifdef  _AM29K
// const
// #endif
struct dicttab_def far systemdict_table[] =
{
/* qqq, begin */
/* BEGIN @_operator */
{ TRUE , INTOPREUBFD, at_exec, "@exec" },
{ TRUE , INTOPREUBFD, at_ifor, "@ifor" },
{ TRUE , INTOPREUBFD, at_rfor, "@rfor" },
{ TRUE , INTOPREUBFD, at_loop, "@loop" },
{ TRUE , INTOPREUBFD, at_repeat, "@repeat" },
{ TRUE , INTOPREUBFD, at_stopped, "@stopped" },
{ TRUE , INTOPREUBFD, at_arrayforall, "@arrayforall" },
{ TRUE , INTOPREUBFD, at_dictforall, "@dictforall" },
{ TRUE , INTOPREUBFD, at_stringforall, "@stringforall" },
/* END   @operator */
/* qqq, end */

/* BEGIN systemdict */
{ FALSE, SYSOPREUBFD, two_equal, "==" },
{ FALSE, SYSOPREUBFD, op_pstack, "pstack" },
{ TRUE , SYSOPREUBFD, op_rcurveto, "rcurveto" },
{ TRUE , SYSOPREUBFD, op_floor, "floor" },
{ TRUE , SYSOPREUBFD, op_load, "load" },
{ TRUE , SYSOPREUBFD, op_counttomark, "counttomark" },
{ TRUE , SYSOPREUBFD, op_setlinejoin, "setlinejoin" },
{ TRUE , SYSOPREUBFD, op_write, "write" },
{ TRUE , SYSOPREUBFD, op_noaccess, "noaccess" },
{ TRUE , SYSOPREUBFD, op_scale, "scale" },
{ TRUE , SYSOPREUBFD, op_clippath, "clippath" },
{ TRUE , SYSOPREUBFD, op_setrgbcolor, "setrgbcolor" },
{ TRUE , SYSOPREUBFD, op_setscreen, "setscreen" },
{ TRUE , SYSOPREUBFD, op_exp, "exp" },
{ TRUE , SYSOPREUBFD, op_anchorsearch, "anchorsearch" },
{ TRUE , SYSOPREUBFD, op_end, "end" },
{ TRUE , SYSOPREUBFD, op_xor, "xor" },
{ TRUE , SYSOPREUBFD, op_bytesavailable, "bytesavailable" },
{ TRUE , SYSOPREUBFD, op_awidthshow, "awidthshow" },
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "true" },
{ TRUE , SYSOPREUBFD, op_dup, "dup" },
{ TRUE , SYSOPREUBFD, op_getinterval, "getinterval" },
{ TRUE , SYSOPREUBFD, op_currentdash, "currentdash" },
{ TRUE , SYSOPREUBFD, op_currentcacheparams, "currentcacheparams" },
{ TRUE , SYSOPREUBFD, op_moveto, "moveto" },
{ TRUE , SYSOPREUBFD, op_bind, "bind" },
{ TRUE , SYSOPREUBFD, op_pop, "pop" },
{ TRUE , SYSOPREUBFD, op_flattenpath, "flattenpath" },
{ TRUE , SYSOPREUBFD, op_gsave, "gsave" },
{ TRUE , SYSOPREUBFD, op_cachestatus, "cachestatus" },
{ TRUE , SYSOPREUBFD, op_definefont, "definefont" },
{ TRUE , SYSOPREUBFD, op_defaultmatrix, "defaultmatrix" },
{ TRUE , SYSOPREUBFD, op_kshow, "kshow" },
{ TRUE , SYSOPREUBFD, op_setcachedevice, "setcachedevice" },
{ TRUE , SYSOPREUBFD, op_countexecstack, "countexecstack" },
{ TRUE , SYSOPREUBFD, op_abs, "abs" },
{ TRUE , SYSOPREUBFD, op_strokepath, "strokepath" },
{ TRUE , SYSOPREUBFD, op_arcn, "arcn" },
{ TRUE , SYSOPREUBFD, op_currenttransfer, "currenttransfer" },
{ TRUE , SYSOPREUBFD, op_and, "and" },
{ TRUE , SYSOPREUBFD, op_repeat, "repeat" },
{ TRUE , SYSOPREUBFD, op_eexec, "eexec" },
{ TRUE , SYSOPREUBFD, op_xcheck, "xcheck" },
{ TRUE , SYSOPREUBFD, op_idtransform, "idtransform" },
{ TRUE , SYSOPREUBFD, op_restore, "restore" },
{ TRUE , SYSOPREUBFD, op_daytime, "daytime" },
{ FALSE, SYSDCTLUBFD, 0, "errordict" },
{ TRUE , SYSOPREUBFD, op_l_bracket, "[" },
{ TRUE , SYSOPREUBFD, op_setpacking, "setpacking" },
{ TRUE , SYSOPREUBFD, op_stop, "stop" },
{ TRUE , SYSOPREUBFD, op_file, "file" },
{ TRUE , SYSOPREUBFD, op_print, "print" },
{ TRUE , SYSOPREUBFD, op_loop, "loop" },
{ TRUE , SYSOPREUBFD, op_string, "string" },
{ TRUE , SYSOPREUBFD, op_cvx, "cvx" },
{ TRUE , SYSOPREUBFD, op_mul, "mul" },
{ FALSE, SYSNULLUBFD, 0, "null" },
{ TRUE , SYSOPREUBFD, op_roll, "roll" },
{ TRUE , SYSOPREUBFD, op_known, "known" },
{ TRUE , SYSOPREUBFD, op_idiv, "idiv" },
{ TRUE , SYSOPREUBFD, op_eq, "eq" },
{ TRUE , SYSOPREUBFD, op_sin, "sin" },
{ TRUE , SYSOPREUBFD, op_ln, "ln" },
{ TRUE , SYSOPREUBFD, op_transform, "transform" },
{ TRUE , SYSOPREUBFD, op_dtransform, "dtransform" },
{ TRUE , SYSOPREUBFD, op_currentmiterlimit,"currentmiterlimit" },
{ TRUE , SYSOPREUBFD, op_lineto, "lineto" },
{ TRUE , SYSOPREUBFD, op_neg, "neg" },
{ TRUE , SYSOPREUBFD, op_stopped, "stopped" },
{ TRUE , SYSOPREUBFD, op_r_bracket, "]" },
{ TRUE , SYSOPREUBFD, op_setlinewidth, "setlinewidth" },
{ TRUE , SYSOPREUBFD, op_rlineto, "rlineto" },
{ TRUE , SYSOPREUBFD, op_concat, "concat" },
{ TRUE , SYSOPREUBFD, op_dictstack, "dictstack" },
{ TRUE , SYSOPREUBFD, op_cos, "cos" },
{ TRUE , SYSOPREUBFD, op_clip, "clip" },
{ TRUE , SYSOPREUBFD, op_ge, "ge" },
{ TRUE , SYSOPREUBFD, op_eoclip, "eoclip" },
{ TRUE , SYSOPREUBFD, op_currentfont, "currentfont" },
{ TRUE , SYSOPREUBFD, op_sethsbcolor, "sethsbcolor" },
{ FALSE, SYSBOLLUBFD, FALSE, "false" },
{ TRUE , SYSOPREUBFD, op_currentlinewidth, "currentlinewidth" },
{ TRUE , SYSOPREUBFD, op_index, "index" },
{ TRUE , SYSOPREUBFD, op_settransfer, "settransfer" },
{ TRUE , SYSOPREUBFD, op_currentflat, "currentflat" },
{ TRUE , SYSOPREUBFD, op_currenthsbcolor, "currenthsbcolor" },
{ TRUE , SYSOPREUBFD, op_showpage, "showpage" },
{ TRUE , SYSOPREUBFD, op_makefont, "makefont" },
{ TRUE , SYSOPREUBFD, op_setcharwidth, "setcharwidth" },
{ TRUE , SYSOPREUBFD, op_setcachelimit, "setcachelimit" },
{ TRUE , SYSOPREUBFD, op_framedevice, "framedevice" },
{ FALSE, SYSOPREUBFD, op_stack, "stack" },
{ TRUE , SYSOPREUBFD, op_store, "store" },
{ FALSE, SYSOPREUBFD, one_equal, "=" },
{ TRUE , SYSOPREUBFD, op_ceiling, "ceiling" },
{ TRUE , SYSOPREUBFD, op_mark, "mark" },
{ TRUE , SYSOPREUBFD, op_setdash, "setdash" },
{ TRUE , SYSOPREUBFD, op_setlinecap, "setlinecap" },
{ TRUE , SYSOPREUBFD, op_grestoreall, "grestoreall" },
{ TRUE , SYSOPREUBFD, op_currentrgbcolor, "currentrgbcolor" },
{ TRUE , SYSOPREUBFD, op_def, "def" },
{ TRUE , SYSOPREUBFD, op_where, "where" },
{ TRUE , SYSOPREUBFD, op_clear, "clear" },
{ TRUE , SYSOPREUBFD, op_cleartomark, "cleartomark" },
{ TRUE , SYSOPREUBFD, op_truncate, "truncate" },
{ TRUE , SYSOPREUBFD, op_dict, "dict" },
{ TRUE , SYSOPREUBFD, op_gt, "gt" },
{ TRUE , SYSOPREUBFD, op_currentlinecap, "currentlinecap" },
{ TRUE , SYSOPREUBFD, op_setmiterlimit, "setmiterlimit" },
{ TRUE , SYSOPREUBFD, op_currentlinejoin, "currentlinejoin" },
{ TRUE , SYSOPREUBFD, op_maxlength, "maxlength" },
{ TRUE , SYSOPREUBFD, op_countdictstack, "countdictstack" },
{ TRUE , SYSOPREUBFD, op_ne, "ne" },
{ TRUE , SYSOPREUBFD, op_count, "count" },
{ TRUE , SYSOPREUBFD, op_lt, "lt" },
{ TRUE , SYSOPREUBFD, op_setfont, "setfont" },
{ TRUE , SYSOPREUBFD, op_setgray, "setgray" },
{ TRUE , SYSOPREUBFD, op_newpath, "newpath" },
{ TRUE , SYSDCTLUBFD, 0, "statusdict" },
{ TRUE , SYSOPREUBFD, op_exch, "exch" },
{ TRUE , SYSOPREUBFD, op_le, "le" },
{ TRUE , SYSOPREUBFD, op_vmstatus, "vmstatus" },
{ TRUE , SYSOPREUBFD, op_currentgray, "currentgray" },
{ TRUE , SYSOPREUBFD, op_setflat, "setflat"},
{ TRUE , SYSOPREUBFD, op_or, "or" },
{ TRUE , SYSOPREUBFD, op_run, "run" },
{ TRUE , SYSOPREUBFD, op_reversepath, "reversepath" },
{ TRUE , SYSOPREUBFD, op_widthshow, "widthshow" },
{ TRUE , SYSOPREUBFD, op_type, "type" },
{ TRUE , SYSOPREUBFD, op_put, "put" },
{ TRUE , SYSOPREUBFD, op_stroke, "stroke" },
{ TRUE , SYSOPREUBFD, op_execstack, "execstack" },
{ TRUE , SYSOPREUBFD, op_round, "round" },
{ TRUE , SYSOPREUBFD, op_image, "image" },
{ TRUE , SYSOPREUBFD, op_packedarray, "packedarray" },
{ TRUE , SYSOPREUBFD, op_translate, "translate" },
{ FALSE, SYSARYLRBFD, 0, "StandardEncoding" },
{ TRUE , SYSOPREUBFD, op_grestore, "grestore" },
{ TRUE , SYSOPREUBFD, op_begin, "begin" },
{ TRUE , SYSOPREUBFD, op_readline, "readline" },
{ TRUE , SYSOPREUBFD, op_findfont, "findfont" },
{ TRUE , SYSOPREUBFD, op_currentscreen, "currentscreen" },
{ TRUE , SYSOPREUBFD, op_setcacheparams, "setcacheparams" },
{ TRUE , SYSOPREUBFD, op_initclip, "initclip" },
{ TRUE , SYSOPREUBFD, op_token, "token" },
{ TRUE , SYSOPREUBFD, op_itransform, "itransform" },
{ TRUE , SYSOPREUBFD, op_currentdict, "currentdict" },
{ TRUE , SYSOPREUBFD, op_stringwidth, "stringwidth" },
{ TRUE , SYSOPREUBFD, op_currentpoint, "currentpoint" },
{ TRUE , SYSOPREUBFD, op_save, "save" },
{ TRUE , SYSOPREUBFD, op_exec, "exec" },
{ TRUE , SYSOPREUBFD, op_cvrs, "cvrs" },
{ TRUE , SYSOPREUBFD, op_rcheck, "rcheck" },
{ TRUE , SYSOPREUBFD, op_sub, "sub" },
{ TRUE , SYSOPREUBFD, op_atan, "atan" },
{ TRUE , SYSOPREUBFD, op_read, "read" },
{ TRUE , SYSOPREUBFD, op_cvs, "cvs" },
{ TRUE , SYSOPREUBFD, op_for, "for" },
{ TRUE , SYSOPREUBFD, op_search, "search" },
{ TRUE , SYSOPREUBFD, op_cvlit, "cvlit" },
{ TRUE , SYSOPREUBFD, op_currentpacking, "currentpacking" },
{ TRUE , SYSOPREUBFD, op_mod, "mod" },
{ TRUE , SYSOPREUBFD, op_log, "log" },
{ TRUE , SYSOPREUBFD, op_exit, "exit" },
{ FALSE, SYSDCTEUBFD, 0, "userdict" },
{ TRUE , SYSOPREUBFD, op_div, "div" },
{ TRUE , SYSOPREUBFD, op_length, "length" },
{ TRUE , SYSOPREUBFD, op_echo, "echo" },
{ TRUE , SYSOPREUBFD, op_cvn, "cvn" },
{ TRUE , SYSOPREUBFD, op_not, "not" },
{ TRUE , SYSOPREUBFD, op_rotate, "rotate" },
{ TRUE , SYSOPREUBFD, op_rmoveto, "rmoveto" },
{ FALSE, SYSDCTLRBFD, 0, "systemdict" },
{ TRUE , SYSOPREUBFD, op_curveto, "curveto" },
{ TRUE , SYSOPREUBFD, op_sqrt, "sqrt" },
{ TRUE , SYSOPREUBFD, op_usertime, "usertime" },
{ TRUE , SYSOPREUBFD, op_ifelse, "ifelse" },
{ TRUE , SYSOPREUBFD, op_wcheck, "wcheck" },
{ TRUE , SYSOPREUBFD, op_resetfile, "resetfile" },
{ TRUE , SYSOPREUBFD, op_add, "add" },
{ TRUE , SYSOPREUBFD, op_array, "array" },
{ TRUE , SYSOPREUBFD, op_srand, "srand" },
{ TRUE , SYSOPREUBFD, op_arc, "arc" },
{ TRUE , SYSOPREUBFD, op_arcto, "arcto" },
{ TRUE , SYSOPREUBFD, op_identmatrix, "identmatrix" },
{ TRUE , SYSOPREUBFD, op_writestring, "writestring" },
{ TRUE , SYSOPREUBFD, op_flushfile, "flushfile" },
{ TRUE , SYSOPREUBFD, op_if, "if" },
{ TRUE , SYSOPREUBFD, op_rrand, "rrand" },
{ TRUE , SYSOPREUBFD, op_readonly, "readonly" },
{ TRUE , SYSOPREUBFD, op_forall, "forall" },
{ TRUE , SYSOPREUBFD, op_closepath, "closepath" },
{ TRUE , SYSOPREUBFD, op_readhexstring, "readhexstring" },
{ TRUE , SYSOPREUBFD, op_currentmatrix, "currentmatrix" },
{ TRUE , SYSOPREUBFD, op_concatmatrix, "concatmatrix" },
{ TRUE , SYSOPREUBFD, op_setmatrix, "setmatrix" },
{ TRUE , SYSOPREUBFD, op_initmatrix, "initmatrix" },
{ TRUE , SYSOPREUBFD, op_initgraphics, "initgraphics" },
{ TRUE , SYSOPREUBFD, op_astore, "astore" },
{ TRUE , SYSOPREUBFD, op_currentfile, "currentfile" },
{ TRUE , SYSOPREUBFD, op_erasepage, "erasepage" },
{ TRUE , SYSOPREUBFD, op_copypage, "copypage" },
{ TRUE , SYSOPREUBFD, op_aload, "aload" },
{ TRUE , SYSOPREUBFD, op_writehexstring, "writehexstring" },
{ TRUE , SYSOPREUBFD, op_flush, "flush" },
{ TRUE , SYSOPREUBFD, op_readstring, "readstring" },
{ TRUE , SYSOPREUBFD, op_executeonly, "executeonly" },
{ TRUE , SYSOPREUBFD, op_get, "get" },
{ TRUE , SYSOPREUBFD, op_cvi, "cvi" },
{ TRUE , SYSOPREUBFD, op_putinterval, "putinterval" },
{ TRUE , SYSOPREUBFD, op_bitshift, "bitshift" },
{ TRUE , SYSOPREUBFD, op_rand, "rand" },
{ TRUE , SYSOPREUBFD, op_matrix, "matrix" },
{ TRUE , SYSOPREUBFD, op_invertmatrix, "invertmatrix" },
{ TRUE , SYSOPREUBFD, op_fill, "fill" },
{ TRUE , SYSOPREUBFD, op_pathforall, "pathforall" },
{ TRUE , SYSOPREUBFD, op_imagemask, "imagemask" },
{ TRUE , SYSOPREUBFD, op_quit, "quit" },
{ TRUE , SYSOPREUBFD, op_charpath, "charpath" },
{ TRUE , SYSOPREUBFD, op_pathbbox, "pathbbox" },
{ TRUE , SYSOPREUBFD, op_show, "show" },
{ TRUE , SYSOPREUBFD, op_ashow, "ashow" },
{ TRUE , SYSOPREUBFD, op_scalefont, "scalefont" },
{ FALSE, SYSDCTLRBFD, 0, "FontDirectory" },
{ FALSE, SYSDCTLUBFD, 0, "$error" },
{ TRUE , SYSOPREUBFD, op_nulldevice, "nulldevice" },
{ TRUE , SYSOPREUBFD, op_cvr, "cvr" },
{ TRUE , SYSOPREUBFD, op_status, "status" },
{ TRUE , SYSOPREUBFD, op_closefile, "closefile" },
{ TRUE , SYSOPREUBFD, op_copy, "copy" },
{ TRUE , SYSOPREUBFD, op_eofill, "eofill" },
{ FALSE, SYSOPREUBFD, op_handleerror, "handleerror" },
{ FALSE, SYSOPREUBFD, np_Run, "Run" },
{ FALSE, SYSOPREUBFD, one_equal_print, "=print" },
#ifdef KANJI
{ FALSE, SYSOPREUBFD, op_rootfont, "rootfont" },
/*{ FALSE, SYSOPREUBFD, op_cshow, "cshow" }, 5-9-1991 */
{ FALSE, SYSOPREUBFD, op_setcachedevice2, "setcachedevice2" },
{ FALSE, SYSOPREUBFD, op_findencoding, "findencoding" },
#endif  /* KANJI */
#ifdef SCSI
{ TRUE , SYSOPREUBFD, op_deletefile, "deletefile" },
{ TRUE , SYSOPREUBFD, op_devdismount, "devdismount" },
{ TRUE , SYSOPREUBFD, op_devmount, "devmount" },
{ TRUE , SYSOPREUBFD, op_devstatus, "devstatus" },
{ TRUE , SYSOPREUBFD, op_filenameforall, "filenameforall" },
{ TRUE , SYSOPREUBFD, op_renamefile, "renamefile" },
{ TRUE , SYSOPREUBFD, op_sync, "sync" },
{ TRUE , SYSOPREUBFD, op_setsysmode, "setsysmode" },
{ FALSE, SYSOPREUBFD, op_debugscsi, "debugscsi" },
{ TRUE , SYSOPREUBFD, op_setfilecachelimit, "setfilecachelimit" },
{ TRUE , SYSOPREUBFD, op_filecachelimit, "filecachelimit" },
#endif  /* SCSI */
{ FALSE, SYSOPREUBFD, op_readsfnt, "readsfnt" },
{ FALSE, SYSOPREUBFD, op_readhexsfnt, "readhexsfnt" },
/* OSS: Danny, 10/11/90 */
{ FALSE, SYSOPREUBFD, op_setsfntencoding, "setsfntencoding" },
/* OSS: end             */
#ifdef WIN
{ FALSE, SYSOPREUBFD, op_setpattern, "setpattern" },
{ FALSE, SYSOPREUBFD, op_patfill, "patfill" },
#ifdef WINF
{ FALSE, SYSOPREUBFD, op_strblt, "strblt" },
{ FALSE, SYSOPREUBFD, op_setjustify, "setjustify" },
#endif
#endif
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   systemdict */
/* BEGIN statusdict */
{ TRUE , SYSOPREUBFD, st_eescratch, "eescratch" },
{ TRUE , SYSOPREUBFD, st_printername, "printername" },
{ TRUE , SYSOPREUBFD, st_checkpassword, "checkpassword" },
{ TRUE , SYSOPREUBFD, st_defaulttimeouts, "defaulttimeouts" },
{ TRUE , SYSOPREUBFD, st_pagestackorder, "pagestackorder" },
{ FALSE, SYSINTLUBFD, (fix (*)())60, "manualfeedtimeout" },
{ TRUE , SYSOPREUBFD, st_setidlefonts, "setidlefonts" },
{ TRUE , SYSOPREUBFD, st_setdefaulttimeouts, "setdefaulttimeouts" },
{ TRUE , SYSOPREUBFD, st_sccbatch, "sccbatch" },
{ TRUE , SYSOPREUBFD, st_printererror, "printererror" },
{ TRUE , SYSOPREUBFD, st_setpassword, "setpassword" },
{ TRUE , SYSOPREUBFD, st_setsccbatch, "setsccbatch" },
{ TRUE , SYSOPREUBFD, st_setmargins, "setmargins" },
{ TRUE , SYSOPREUBFD, st_sccinteractive, "sccinteractive" },
{ TRUE , SYSOPREUBFD, st_idlefonts, "idlefonts" },
{ TRUE , SYSOPREUBFD, st_setjobtimeout, "setjobtimeout" },
{ TRUE , SYSOPREUBFD, st_setpagetype, "setpagetype" },
{ TRUE , SYSOPREUBFD, st_pagecount, "pagecount" },
{ TRUE , SYSOPREUBFD, st_dostartpage, "dostartpage" },
{ TRUE , SYSOPREUBFD, st_jobtimeout, "jobtimeout" },
{ TRUE , SYSOPREUBFD, st_setdostartpage, "setdostartpage" },
{ TRUE , SYSOPREUBFD, st_frametoprinter, "frametoprinter" },
{ FALSE, SYSINTLUBFD, 0, "waittimeout" },
{ TRUE , SYSOPREUBFD, st_setsccinteractive, "setsccinteractive" },
{ TRUE , SYSOPREUBFD, st_pagetype, "pagetype" },
{ TRUE , SYSOPREUBFD, st_margins, "margins" },
{ TRUE , SYSOPREUBFD, st_setprintername, "setprintername" },
{ TRUE , SYSOPREUBFD, st_seteescratch, "seteescratch" },
{ TRUE , SYSOPREUBFD, st_setstdio, "setstdio" },
{ TRUE , SYSOPREUBFD, st_softwareiomode   , "softwareiomode" },
{ TRUE , SYSOPREUBFD, st_setsoftwareiomode, "setsoftwareiomode" },
{ TRUE , SYSOPREUBFD, st_hardwareiomode   , "hardwareiomode" },
{ TRUE , SYSOPREUBFD, st_sethardwareiomode, "sethardwareiomode" },
{ FALSE, SYSOPREUBFD, st_countnode, "countnode" },
{ FALSE, SYSOPREUBFD, st_countedge, "countedge" },
{ FALSE, SYSOPREUBFD, st_dumpclip, "dumpclip" },
{ FALSE, SYSOPREUBFD, st_dumppath, "dumppath" },
#ifdef SCSI
{ TRUE , SYSOPREUBFD, st_cartstatus, "cartstatus" },
{ TRUE , SYSOPREUBFD, st_diskonline, "diskonline" },
{ TRUE , SYSOPREUBFD, st_diskstatus, "diskstatus" },
{ TRUE , SYSOPREUBFD, st_initializedisk, "initializedisk" },
{ TRUE , SYSOPREUBFD, st_setuserdiskpercent, "setuserdiskpercent" },
{ TRUE , SYSOPREUBFD, st_userdiskpercent, "userdiskpercent" },
{ TRUE , SYSOPREUBFD, st_dosysstart, "dosysstart" },
{ TRUE , SYSOPREUBFD, st_setsysstart, "setsysstart" },
{ TRUE , SYSOPREUBFD, st_flushcache, "flushcache" },
#endif  /* SCSI */
#ifdef SFNT
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "?_Royal" },
#endif /* SFNT */
#ifdef FIND_SUB
{ FALSE, SYSOPREUBFD, st_selectsubstitutefont, "selectsubstitutefont" },
{ FALSE, SYSOPREUBFD, st_setsubstitutefonts, "setsubstitutefonts" },
{ FALSE, SYSOPREUBFD, st_substitutefonts, "substitutefonts" },
#endif /* FIND_SUB */
{ FALSE, SYSOPREUBFD, st_checksum, "checksum" },
{ FALSE, SYSOPREUBFD, st_ramsize, "ramsize" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   statusdict */
/* BEGIN userdict */
{ FALSE, SYSINTLUBFD, (fix (*)())1, "#copies" },
{ FALSE, SYSOPREUBFD, us_cleardictstack, "cleardictstack" },
{ FALSE, SYSOPREUBFD, us_letter, "letter" },
{ FALSE, SYSOPREUBFD, us_lettersmall, "lettersmall" },
{ FALSE, SYSOPREUBFD, us_a4, "a4" },
{ FALSE, SYSOPREUBFD, us_a4small, "a4small" },
{ FALSE, SYSOPREUBFD, us_b5, "b5" },
{ FALSE, SYSOPREUBFD, us_note, "note" },
{ FALSE, SYSOPREUBFD, us_legal, "legal" },
{ FALSE, SYSOPREUBFD, us_prompt, "prompt" },
{ FALSE, SYSOPREUBFD, us_quit, "quit" },
{ FALSE, SYSOPREUBFD, us_executive, "executive" },
{ FALSE, SYSOPREUBFD, us_start, "start" },
{ FALSE, SYSDCTLUBFD, 0, "serverdict" },
{ FALSE, SYSDCTLUBFD, 0, "execdict" },
{ FALSE, SYSDCTLUBFD, 0, "printerdict" },
{ FALSE, SYSDCTLUBFD, 0, "$idleTimeDict" },

//DJC add support for dictionary to hold pstodib specific stuff
{ FALSE, SYSDCTLUBFD, 0, "psprivatedict" },

{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   userdict */
/* BEGIN errordict */
{ FALSE, SYSOPREUBFD, er_dictfull, "dictfull" },
{ FALSE, SYSOPREUBFD, er_dictstackoverflow, "dictstackoverflow" },
{ FALSE, SYSOPREUBFD, er_dictstackunderflow, "dictstackunderflow" },
{ FALSE, SYSOPREUBFD, er_execstackoverflow, "execstackoverflow" },
{ FALSE, SYSOPREUBFD, er_invalidaccess, "invalidaccess" },
{ FALSE, SYSOPREUBFD, er_invalidexit, "invalidexit" },
{ FALSE, SYSOPREUBFD, er_invalidfileaccess, "invalidfileaccess" },
{ FALSE, SYSOPREUBFD, er_invalidfont, "invalidfont" },
{ FALSE, SYSOPREUBFD, er_invalidrestore, "invalidrestore" },
{ FALSE, SYSOPREUBFD, er_ioerror, "ioerror" },
{ FALSE, SYSOPREUBFD, er_limitcheck, "limitcheck" },
{ FALSE, SYSOPREUBFD, er_nocurrentpoint, "nocurrentpoint" },
{ FALSE, SYSOPREUBFD, er_rangecheck, "rangecheck" },
{ FALSE, SYSOPREUBFD, er_stackoverflow, "stackoverflow" },
{ FALSE, SYSOPREUBFD, er_stackunderflow, "stackunderflow" },
{ FALSE, SYSOPREUBFD, er_syntaxerror, "syntaxerror" },
{ FALSE, SYSOPREUBFD, er_timeout, "timeout" },
{ FALSE, SYSOPREUBFD, er_typecheck, "typecheck" },
{ FALSE, SYSOPREUBFD, er_undefined, "undefined" },
{ FALSE, SYSOPREUBFD, er_undefinedfilename, "undefinedfilename" },
{ FALSE, SYSOPREUBFD, er_undefinedresult, "undefinedresult" },
{ FALSE, SYSOPREUBFD, er_unmatchedmark, "unmatchedmark" },
{ FALSE, SYSOPREUBFD, er_unregistered, "unregistered" },
{ FALSE, SYSOPREUBFD, er_VMerror, "VMerror" },
{ FALSE, SYSOPREUBFD, er_interrupt, "interrupt" },
{ FALSE, SYSOPREUBFD, er_handleerror, "handleerror" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   errordict */
/* BEGIN serverdict */
{ FALSE, SYSOPREUBFD, se_settimeouts, "settimeouts" },
{ FALSE, SYSOPREUBFD, se_exitserver, "exitserver" },
{ FALSE, SYSNULLUBFD, 0, "stdin" },
{ FALSE, SYSNULLUBFD, 0, "stdout" },
{ FALSE, SYSOPREUBFD, se_setrealdevice, "setrealdevice" }, /* 1/25/90 ccteng */
{ FALSE, SYSOPREUBFD, se_execjob, "execjob" }, /* 1/25/90 ccteng for LaserPrep */
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   serverdict */
/* BEGIN printerdict */
{ FALSE, SYSNULLUBFD, 0, "letter" },
{ FALSE, SYSNULLUBFD, 0, "lettersmall" },
{ FALSE, SYSNULLUBFD, 0, "a4" },
{ FALSE, SYSNULLUBFD, 0, "a4small" },
{ FALSE, SYSNULLUBFD, 0, "b5" },
{ FALSE, SYSNULLUBFD, 0, "note" },
{ FALSE, SYSNULLUBFD, 0, "legal" },
{ FALSE, SYSNULLUBFD, 0, "printerarray" },
{ FALSE, SYSNULLUBFD, 0, "defaultmtx" },
{ FALSE, SYSNULLUBFD, 0, "mtx" },
{ FALSE, SYSOPREUBFD, pr_proc, "proc" },
{ FALSE, SYSNULLUBFD, 0, "currentpagetype" },
{ FALSE, SYSINTLUBFD, 0, "width" },
{ FALSE, SYSINTLUBFD, 0, "height" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   printerdict */
/* BEGIN $idleTimeDict */
{ FALSE, SYSNULLUBFD, 0, "cachestring" },
{ FALSE, SYSNULLUBFD, 0, "stdfontname" },
{ FALSE, SYSNULLUBFD, 0, "cachearray" },
{ FALSE, SYSNULLUBFD, 0, "defaultarray" },
{ FALSE, SYSINTLUBFD, 0, "carrayindex" },
{ FALSE, SYSINTLUBFD, 0, "cstringindex" },
{ FALSE, SYSNULLUBFD, 0, "cstring" },
{ FALSE, SYSNULLUBFD, 0, "citem" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   $idleTimeDict */
/* BEGIN execdict */
{ FALSE, SYSINTLUBFD, 0, "execdepth" },
{ FALSE, SYSNULLUBFD, 0, "stmtfile" },                 /* SYSINTLUBFD -> SYSOPREUBFD */
{ FALSE, SYSOPREUBFD, ex_idleproc, "idleproc" },       /* 0 -> ex_execdepth */
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   execdict */
/* BEGIN $errordict */
{ FALSE, SYSBOLLUBFD, FALSE, "newerror" },
{ FALSE, SYSNULLUBFD, 0, "errorname" },
{ FALSE, SYSNULLUBFD, 0, "command" },
{ FALSE, SYSNULLUBFD, 0, "ostack" },
{ FALSE, SYSNULLUBFD, 0, "estack" },
{ FALSE, SYSNULLUBFD, 0, "dstack" },
{ FALSE, SYSNULLUBFD, 0, "opnstkary" },
{ FALSE, SYSNULLUBFD, 0, "dictstkary" },
{ FALSE, SYSNULLUBFD, 0, "execstkary" },
{ FALSE, SYSBOLLUBFD, (fix (*)())TRUE, "runbatch" },
{ FALSE, SYSBOLLUBFD, FALSE, "$debug" },
{ FALSE, SYSNULLUBFD, 0, "$cur_font" },
{ FALSE, SYSNULLUBFD, 0, "$cur_vm" },
{ FALSE, SYSNULLUBFD, 0, "$cur_screen" },
{ FALSE, SYSNULLUBFD, 0, "$cur_matrix" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL },
/* END   $errordict */
/* BEGIN psprivatedict */  //DJC added
//DJC added
{ FALSE, SYSINTLUBFD, 0, "psprivatepagetype" },
{ FALSE, SYSNULLUBFD, 0, (byte *)NULL }
/* END   psprivatedict */
} ; /* systemdict_table[] */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\fpexpt.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * FILE: setsp.c -- revised from setsp.asm
 * Pseudo file to provide functions:
 *      bauer_fpsignal
 *      _clear87
 *      _control87
 *      _status87
 *      set_sp
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"

void setargv()          //@WIN
{
}

void setenvp()          //@WIN
{
}

void init_fpsignal()    //@WIN
{
#ifdef  DBG
    printf("Init_fpsignal()\n");
#endif
}

void bauer_fpsignal()   //@WIN
{
#ifdef  DBG
    printf("Bauer_fpsignal()\n");
#endif
}

unsigned int _clear87()
{
    return(0);
}

unsigned int _control87(ufix arg1, ufix arg2)   /*@WIN; add prototype */
{
    return(0);
}

unsigned int _status87()
{
    return(0);
}

void setup_env() {}

void set_sp()
{
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\dumint.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              DUMINT.C
 *
 * Revision History:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geierr.h"
#include    "language.h"
#include    "file.h"
#include    "user.h"
#include    "geiioctl.h"                /*@WIN*/
#include    "geipm.h"

extern  bool16  int_flag ;
bool16  eable_int ;
bool16  int_flag ;

#define _MAXEESCRATCHARRY       64

/***********************************************************************
** TITLE:       op_clearinterrupt               Dec-05-88
***********************************************************************/
fix
op_clearinterrupt()
{
    if(int_flag)
        int_flag = 0 ;

    eable_int = 1 ;

    return(0) ;
}   /* op_clearinterrupt */

/***********************************************************************
** TITLE:       op_enableinterrupt              Dec-05-88
***********************************************************************/
fix
op_enableinterrupt()
{
    eable_int = 1 ;

    return(0) ;
}   /* op_enableinterrupt */

/***********************************************************************
** TITLE:       op_disableinterrupt             Dec-05-88
***********************************************************************/
fix
op_disableinterrupt()
{
    eable_int = 0 ;

    return(0) ;
}   /* op_disableinterrupt */

/*
 *  This operator name is not matching its usage.
 *  used to select the input interface be serial or parallel.
 *  bool daytime -
 *  bool == TRUE, using Centronics interface ;
 *  bool == FALSE, get baud rate of serial interface.
 */
fix
op_daytime()
{
    if (COUNT() < 1)
       ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != BOOLEANTYPE)
       ERROR(TYPECHECK) ;
    else {
       POP(1) ;
    }

    return(0) ;
}   /* op_daytime() */

/***********************************************************************
** TITLE:       st_seteescratch            06-21-90
***********************************************************************/
fix
st_seteescratch()
{
    char  l_temp[64] ;

    if (current_save_level)
        ERROR(INVALIDACCESS) ;
    else if (COUNT() < 2)
        ERROR(STACKUNDERFLOW) ;
    else if ((TYPE_OP(0) != INTEGERTYPE) ||
            (TYPE_OP(1) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else if (((fix32)VALUE_OP(1) > 63) || ((fix32)VALUE_OP(1) < 0) ||
            ((fix32)VALUE_OP(0) > 255))
        ERROR(RANGECHECK) ;
    else {
        GEIpm_read(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        l_temp[(fix16)VALUE_OP(1)] = (char)VALUE_OP(0) ;   //@WIN
        GEIpm_write(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        POP(2) ;
    }

    return(0) ;
}   /* st_seteescratch */

/***********************************************************************
** TITLE:       st_eescratch            06-21-90
***********************************************************************/
fix
st_eescratch()
{
    fix16 l_index ;
    char  l_temp[64] ;

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if (((VALUE_OP(0)) > 63) || ((fix32)(VALUE_OP(0)) < 0))  //@WIN
        ERROR(RANGECHECK) ;
    else {
        l_index = (fix16)VALUE_OP(0) ;
        GEIpm_read(PMIDofEESCRATCHARRY, l_temp, _MAXEESCRATCHARRY) ;
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0,
                   (ufix32)(0x000000ff)&l_temp[l_index]) ;
    }

    return(0) ;
}   /* st_eescratch */

/* statusdict stubs and will probably be removed */
fix
st_printererror()
{
    printer_error(0x10000000) ;

    return(0) ;
}   /* st_printererror */

fix
st_pagestackorder()
{
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;

    return(0) ;
}   /* st_pagestackorder */

fix
st_largelegal()
{
    /* this value is depend on system memory: Ref OPE */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    return(0) ;
}   /* st_largelegal */

/***********************************************************************
** TITLE:       op_checksum             01-11-91
***********************************************************************/
fix
st_checksum()
{
#ifdef  _AM29K
    ufix16  rom_checksum ;

    rom_checksum = GEIrom_checksum() ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, rom_checksum) ;
#else
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0) ;
#endif

    return(0) ;
}   /* op_checksum */

/***********************************************************************
** TITLE:       op_ramsize             01-11-91
***********************************************************************/
fix
st_ramsize()
{
#ifdef  _AM29K
    ufix32  ram_size ;

    ram_size = GEIram_size() ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, ram_size) ;
#else
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, 0) ;
#endif

    return(0) ;
}   /* op_checksum */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\exec.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * 02/07/90 ccteng: modify for new 1pp modules; @1PP
 * 7/21/90; ccteng; 1)change opntype array for change of dict_tab.c
 *                  2)delete internaldict, version, revision
 * 7/25/90; ccteng; 1)add typecheck info for sccbatch, setsccbatch,
 *                    sccinteractive, setsccinteractive
 * 07/26/90 Jack Liaw: update for grayscale
 * 8/7/90; scchen;  1) added op_setfilecachelimit, op_filecachelimit
 *                  2) added st_selectsubstitutefont,
 *                                st_setsubstitutefonts,
 *                                st_substitutefonts
 *                  3) added op_readsfnt
 * 9/19/90; ccteng; add op_readhexsfnt
 * 3/22/91  Ada     add op_setpattern and op_patfill
 */
#include "global.ext"
#include <string.h>

/*
 * define error table to record each error name
 */
#ifdef  _AM29K
const
#endif
byte  FAR * far error_table[] =
{
        "",                     /* NOERROR                 0    */
        "dictfull",             /* DICTFULL                1    */
        "dictstackoverflow",    /* DICTSTACKOVERFLOW       2    */
        "dictstackunderflow",   /* DICTSTACKUNDERFLOW      3    */
        "execstackoverflow",    /* EXECSTACKOVERFLOW       4    */
        "handleerror",          /* HANDLEERROR             5    */
        "interrupt",            /* INTERRUPT               6    */
        "invalidaccess",        /* INVALIDACCESS           7    */
        "invalidexit",          /* INVALIDEXIT             8    */
        "invalidfileaccess",    /* INVALIDFILEACCESS       9    */
        "invalidfont",          /* INVALIDFONT             10   */
        "invalidrestore",       /* INVALIDRESTORE          11   */
        "ioerror",              /* IOERROR                 12   */
        "limitcheck",           /* LIMITCHECK              13   */
        "nocurrentpoint",       /* NOCURRENTPOINT          14   */
        "rangecheck",           /* RANGECHECK              15   */
        "stackoverflow",        /* STACKOVERFLOW           16   */
        "stackunderflow",       /* STACKUNDERFLOW          17   */
        "syntaxerror",          /* SYNTAXERROR             18   */
        "timeout",              /* TIMEOUT                 19   */
        "typecheck",            /* TYPECHECK               20   */
        "undefined",            /* UNDEFINED               21   */
        "undefinedfilename",    /* UNDEFINEDFILENAME       22   */
        "undefinedresult",      /* UNDEFINEDRESULT         23   */
        "unmatchedmark",        /* UNMATCHEDMARK           24   */
        "unregistered",         /* UNREGISTERED            25   */
        "VMerror"               /* VMERROR                 26   */
};

/* qqq, begin */
/*
 * Reference only
 *
 * #define  ANYTYPE             \144
 * #define  NUMTYPE             \145    ; INTEGER/REAL
 * #define  PROCTYPE            \146    ; ARRAY/PACKEDARRAY
 * #define  EXCLUDE_NULLTYPE    \147
 * #define  STREAMTYPE          \150    ; FILE/STRING
 * #define  COMPOSITE1          \151    ; ARRAY/PACKEDARRAY/STRING/DICT/FILE
 * #define  COMPOSITE2          \152    ; ARRAY/PACKEDARRAY/STRING/DICT
 * #define  COMPOSITE3          \153    ; ARRAY/PACKEDARRAY/STRING

 * #define  ARRAYTYPE           \001
 * #define  BOOLEANTYPE         \002
 * #define  DICTIONARYTYPE      \003
 * #define  FILETYPE            \004
 * #define  INTEGERTYPE         \006
 * #define  SAVETYPE            \014
 * #define  STRINGTYPE          \015
 * #define  PACKEDARRAYTYPE     \016
 */
/* qqq, end */

/*
 *  Encoding format:
 *  A type checking format is a sequence of chars surrounded by double quotes,
 *  as follows:
 *  "N(types) type1 type2 ... typeN M(types) type1 type2 ... typeM"
 *  each char is represented by the backslash \ and three octal digits
 */
#ifdef  _AM29K
const
#endif
static byte  * far opntype_array[] =
{
/* BEGIN @_operator */
/*  @exec                   */ "",
/*  @ifor                   */ "",
/*  @rfor                   */ "",
/*  @loop                   */ "",
/*  @repeat                 */ "",
/*  @stopped                */ "",
/*  @arrayforall            */ "",
/*  @dictforall             */ "",
/*  @stringforall           */ "",
/* END @_operator */

/* BEGIN systemdict */
/*  0  ==                   */ "\001\144",
/*  1  pstack               */ "",
/*  2  rcurveto             */ "\006\145\145\145\145\145\145",
/*  3  floor                */ "\001\145",
/*  4  load                 */ "\001\147",
/*  5  counttomark          */ "",
/*  6  setlinejoin          */ "\001\006",
/*  7  write                */ "\002\006\004",
/*  8  noaccess             */ "\001\151",
/*  9   scale               */ "\003\001\145\145\002\145\145",
/*  10  clippath            */ "",
/*  11  setrgbcolor         */ "\003\145\145\145",
/*  12  setscreen           */ "\003\146\145\145",
/*  13  exp                 */ "\002\145\145",
/*  14  anchorsearch        */ "\002\015\015",
/*  15  end                 */ "",
/*  16  xor                 */ "\002\002\002\002\006\006",
/*  17  bytesavailable      */ "\001\004",
/*  18  awidthshow          */ "\006\015\145\145\006\145\145",
/*  DON "true"              */ "",
/*  20  dup                 */ "\001\144",
/*  21  getinterval         */ "\003\006\006\153",
/*  22  currentdash         */ "",
/*  23  currentcacheparams  */ "",
/*  24  moveto              */ "\002\145\145",
/*  25  bind                */ /* "\001\146" PJ 5-9-1991 */ "",
/*  26  pop                 */ "\001\144",
/*  27  flattenpath         */ "",
/*  28  gsave               */ "",
/*  29  cachestatus         */ "",
/*  30  definefont          */ "\002\003\147",
/*  31  defaultmatrix       */ "\001\001",
/*  32  kshow               */ "\002\015\146",
/*  33  setcachedevice      */ "\006\145\145\145\145\145\145",
/*  34  countexecstack      */ "",
/*  35  abs                 */ "\001\145",
/*  36  strokepath          */ "",
/*  37  arcn                */ "\005\145\145\145\145\145",
/*  38  currenttransfer     */ "",
/*  39  and                 */ "\002\002\002\002\006\006",
/*  40  repeat              */ "\002\146\006",
/*  41  eexec               */ "\001\150",
/*  42  xcheck              */ "\001\144",
/*  43  idtransform         */ "\003\146\145\145\002\145\145",
/*  44  restore             */ "\001\014",
/*  45  daytime             */ "",
/*  DON "errordict"         */ "",
/*  47  [                   */ "",
/*  48  setpacking          */ "\001\002",
/*  49  stop                */ "",
/*  50  file                */ "\002\015\015",
/*  51  print               */ "\001\015",
/*  52  loop                */ "\001\146",
/*  53  string              */ "\001\006",
/*  54  cvx                 */ "\001\144",
/*  55  mul                 */ "\002\145\145",
/*  DON "null"              */ "",
/*  57  roll                */ "\002\006\006",
/*  58  known               */ "\002\147\003",
/*  59  idiv                */ "\002\145\145",
/*  60  eq                  */ "\002\144\144",
/*  61  sin                 */ "\001\145",
/*  62  ln                  */ "\001\145",
/*  63  transform           */ "\003\146\145\145\002\145\145",
/*  64  dtransform          */ "\003\146\145\145\002\145\145",
/*  65  currentmiterlimit   */ "",
/*  66  lineto              */ "\002\145\145",
/*  67  neg                 */ "\001\145",
/*  68  stopped             */ "\001\144",
/*  69  ]                   */ "",
/*  70  setlinewidth        */ "\001\145",
/*  71  rlineto             */ "\002\145\145",
/*  72  concat              */ "\001\146",
/*  73  dictstack           */ "\001\146",
/*  74  cos                 */ "\001\145",
/*  75  clip                */ "",
/*  76  ge                  */ "\002\145\145\002\015\015",
/*  77  eoclip              */ "",
/*  78  currentfont         */ "",
/*  79  sethsbcolor         */ "\003\145\145\145",
/*  DON "false"             */ "",
/*  81  currentlinewidth    */ "",
/*  82  index               */ "\001\006",
/*  83  settransfer         */ "\001\146",
/*  84  currentflat         */ "",
/*  85  currenthsbcolor     */ "",
/*  86  showpage            */ "",
/*  87  makefont            */ "\002\146\003",
/*  88  setcharwidth        */ "\002\145\145",
/*  89  setcachelimit       */ "\001\006",
/*  90  framedevice         */ "\004\146\006\006\146",
/*  91  stack               */ "",
/*  92  store               */ "\002\144\147",
/*  93  =                   */ "",
/*  94  ceiling             */ "\001\145",
/*  95  mark                */ "",
/*  96  setdash             */ "\002\145\146",
/*  97  setlinecap          */ "\001\006",
/*  98  grestoreall         */ "",
/*  99  currentrgbcolor     */ "",
/*  100  def                */ "\002\144\147",
/*  101  where              */ "\001\147",
/*  102  clear              */ "",
/*  103  cleartomark        */ "",
/*  104  truncate           */ "\001\145",
/*  105  dict               */ "\001\006",
/*  106  gt                 */ "\002\145\145\002\015\015",
/*  107  currentlinecap     */ "",
/*  108  setmiterlimit      */ "\001\145",
/*  109  currentlinejoin    */ "",
/*  110  maxlength          */ "\001\003",
/*  111  countdictstack     */ "",
/*  112  ne                 */ "\002\144\144",
/*  113  count              */ "",
/*  114  lt                 */ "\002\145\145\002\015\015",
/*  115  setfont            */ "\001\003",
/*  116  setgray            */ "\001\145",
/*  117  newpath            */ "",
/*  DON  "statusdict"       */ "",
/*  119  exch               */ "\002\144\144",
/*  120  le                 */ "\002\145\145\002\015\015",
/*  121  vmstatus           */ "",
/*  122  currentgray        */ "",
/*  123  setflat            */ "\001\145",
/*  124  or                 */ "\002\002\002\002\006\006",
/*  125  run                */ "\001\015",
/*  126  reversepath        */ "",
/*  127  widthshow          */ "\004\015\006\145\145",
/*  128  type               */ "\001\144",
/*  129  put                */ "\003\144\006\146\003\144\147\003\003\006\006\015",
/*  130  stroke             */ "",
/*  131  execstack          */ "\001\146",
/*  132  round              */ "\001\145",
/*  133  image              */ "\005\153\146\006\006\006",
/*  134  packedarray        */ "\001\006",
/*  135  translate          */ "\003\001\145\145\002\145\145",
/*  DON  "StandardEncoding" */ "",
/*  137  grestore           */ "",
/*  138  begin              */ "\001\003",
/*  139  readline           */ "\002\015\004",
/*  140  findfont           */ "\001\147",
/*  141  currentscreen      */ "",
/*  142  setcacheparams     */ "",
/*  143  initclip           */ "",
/*  144  token              */ "\001\150",
/*  145  itransform         */ "\003\146\145\145\002\145\145",
/*  146  currentdict        */ "",
/*  147  stringwidth        */ "\001\015",
/*  148  currentpoint       */ "",
/*  149  save               */ "",
/*  150  exec               */ "\001\144",
/*  151  cvrs               */ "\003\015\006\145",
/*  152  rcheck             */ "\001\151",
/*  153  sub                */ "\002\145\145",
/*  154  atan               */ "\002\145\145",
/*  155  read               */ "\001\004",
/*  156  cvs                */ "\002\015\144",
/*  157  for                */ "\004\146\145\145\145",
/*  158  search             */ "\002\015\015",
/*  159  cvlit              */ "\001\144",
/*  160  currentpacking     */ "",
/*  161  mod                */ "\002\006\006",
/*  162  log                */ "\001\145",
/*  163  exit               */ "",
/*  DON  "userdict"         */ "",
/*  165  div                */ "\002\145\145",
/*  166  length             */ "\001\152\001\010",  /* erik chen 5-20-1991 */
/*  167  echo               */ "\001\002",
/*  168  cvn                */ "\001\015",
/*  169  not                */ "\001\002\001\006",
/*  170  rotate             */ "\002\001\145\001\145",
/*  171  rmoveto            */ "\002\145\145",
/*  DON  "systemdict"       */ "",
/*  173  curveto            */ "\006\145\145\145\145\145\145",
/*  174  sqrt               */ "\001\145",
/*  175  usertime           */ "",
/*  176  ifelse             */ "\003\146\146\002",
/*  177  wcheck             */ "\001\151",
/*  178  resetfile          */ "\001\004",
/*  179  add                */ "\002\145\145",
/*  180  array              */ "\001\006",
/*  181  srand              */ "\001\006",
/*  182  arc                */ "\005\145\145\145\145\145",
/*  183  arcto              */ "\005\145\145\145\145\145",
/*  184  identmatrix        */ "\001\001",
/*  185  writestring        */ "\002\015\004",
/*  186  flushfile          */ "\001\004",
/*  187  if                 */ "\002\146\002",
/*  188  rrand              */ "",
/*  189  readonly           */ "\001\151",
/*  190  forall             */ "\002\146\152",
/*  191  closepath          */ "",
/*  192  readhexstring      */ "\002\015\004",
/*  193  currentmatrix      */ "\001\001",
/*  194  concatmatrix       */ "\003\001\146\146",
/*  195  setmatrix          */ "\001\146",
/*  196  initmatrix         */ "",
/*  197  initgraphics       */ "",
/*  198  astore             */ "\001\146",
/*  199  currentfile        */ "",
/*  200  erasepage          */ "",
/*  201  copypage           */ "",
/*  202  aload              */ "\001\146",
/*  203  writehexstring     */ "\002\015\004",
/*  204  flush              */ "",
/*  205  readstring         */ "\002\015\004",
/*  206  executeonly        */ "\001\153\001\004",
/*  207  get                */ "\002\006\153\002\147\003",
/*  208  cvi                */ "\001\145\001\015",
/*  209  putinterval        */ "\003\146\006\146\003\015\006\015",
/*  210  bitshift           */ "\002\006\006",
/*  211  rand               */ "",
/*  212  matrix             */ "",
/*  213  invertmatrix       */ "\002\001\146",
/*  214  fill               */ "",
/*  215  pathforall         */ "\004\144\144\144\144",
/*  216  imagemask          */ "\005\146\146\002\006\006\005\015\146\002\006\006",
/*  217  quit               */ "",
/*  218  charpath           */ "\002\002\015",
/*  219  pathbbox           */ "",
/*  220  show               */ "\001\015",
/*  221  ashow              */ "\003\015\145\145",
/*  222  scalefont          */ "\002\145\003",
/*  DON  "FontDirectory"    */ "",
/*  DON  "$error"           */ "",
/*  225  nulldevice         */ "",
/*  226  cvr                */ "\001\145\001\015",
/*  227  status             */ "\001\150",
/*  228  closefile          */ "\001\004",
/*  229  copy               */ "\001\006\002\146\146\002\003\003\002\015\015",
/*  230  eofill             */ "",
/*  231  handleerror        */ "",
/*  232  Run                */ "\001\015",
/*  234  =print             */ "\001\144",
#ifdef KANJI
/*  237  rootfont           */ "",
/*  238  cshow              *| "\002\015\146", 5-9-1991 */
/*  239  setcachedevice2    */ "\012\145\145\145\145\145\145\145\145\145\145",
/*  240  findencoding       */ "\001\147",
#endif  /* KANJI */
#ifdef SCSI
/*  241  deletefile         */ "",
/*  242  devdismount        */ "",
/*  243  devmount           */ "",
/*  244  devstatus          */ "",
/*  245  filenameforall     */ "",
/*  246  renamefile         */ "",
/*  247  sync               */ "",
/*  248  setsysmode         */ "",
/*  249  debugscsi          */ "",
/*  250  setfilecachelimit  */ "\001\006",
/*  251  filecachelimit     */ "",
#endif  /* SCSI */
/*  252  op_readsfnt        */ "\001\150",
/*  253  op_reahexdsfnt     */ "\001\004",
/* OSS: Danny, 10/11/90 */
/*  254 op_setsfntencoding  */ "\003\006\006\003",
/* OSS: ewd                 */
#ifdef WIN
/*  255  setpattern         */ "\001\015",
/*  256  patfill            */ "\007\006\145\145\145\145\145\145",
#ifdef WINF
/*  257    strblt           */ "\006\015\145\145\145\002\002",
/*  258    setjustify       */ "\003\006\145\006",
#endif
#endif
/*  DON  NULL               */ "",
/* END   systemdict */
/* BEGIN statusdict */
/*  FIRST_STAT,    eescratch             */ "",
/*  FIRST_STAT+1,  printername           */ "",
/*  FIRST_STAT+2,  checkpassword         */ "",
/*  FIRST_STAT+3,  defaulttimeouts       */ "",
/*  FIRST_STAT+4,  pagestackorder        */ "",
/*  DON,           "manualfeedtimeout"   */ "",
/*  FIRST_STAT+6,  setidlefonts          */ "",
/*  FIRST_STAT+7,  setdefaulttimeouts    */ "",
/*  FIRST_STAT+8,  sccbatch              */ "\001\006",
/*  FIRST_STAT+9,  printererror          */ "",
/*  FIRST_STAT+10, setpassword           */ "",
/*  FIRST_STAT+11, setsccbatch           */ "\003\006\006\006",
/*  FIRST_STAT+12, setmargins            */ "",
/*  FIRST_STAT+13, sccinteractive        */ "\001\006",
/*  FIRST_STAT+14, idlefonts             */ "",
/*  FIRST_STAT+15, setjobtimeout         */ "",
/*  FIRST_STAT+16, setpagetype           */ "",
/*  FIRST_STAT+17, pagecount             */ "",
/*  FIRST_STAT+18, dostartpage           */ "",
/*  FIRST_STAT+19, jobtimeout            */ "",
/*  FIRST_STAT+20, setdostartpage        */ "",
/*  FIRST_STAT+21, frametoprinter        */ "",
/*  DON,           "waittimeout"         */ "",
/*  FIRST_STAT+23, setsccinteractive     */ "\003\006\006\006",
/*  FIRST_STAT+24, pagetype              */ "",
/*  FIRST_STAT+25, margins               */ "",
/*  FIRST_STAT+26, setprintername        */ "",
/*  FIRST_STAT+27, seteescratch          */ "",
/*  FIRST_STAT+28, setstdio              */ "",
/*  FIRST_STAT+29, softwareiomode        */ "",
/*  FIRST_STAT+30, setsoftwareiomode     */ "",
/*  FIRST_STAT+31, hardwareiomode        */ "",
/*  FIRST_STAT+32, sethardwareiomode     */ "",
/*  FIRST_STAT+40, countnode             */ "",
/*  FIRST_STAT+41, countedge             */ "\002\006\006",
/*  FIRST_STAT+42, dumpclip              */ "",
/*  FIRST_STAT+43, dumppath              */ "",
#ifdef SCSI
/*  FIRST_STAT+44, cartstatus            */ "",
/*  FIRST_STAT+45, diskonline            */ "",
/*  FIRST_STAT+46, diskstatus            */ "",
/*  FIRST_STAT+47, initializedisk        */ "",
/*  FIRST_STAT+48, setuserdiskpercent    */ "",
/*  FIRST_STAT+49, userdiskpercent       */ "",
/*  FIRST_STAT+50, dosysstart            */ "",
/*  FIRST_STAT+51, setsysstart           */ "",
/*  FIRST_STAT+52, flushcache            */ "",
#endif  /* SCSI */
#ifdef SFNT
/*  DON            "?_Royal"             */ "",
#endif  /* SFNT */
#ifdef FIND_SUB
/*  FIRST_STAT+54, selectsubstitutefont */ "\001\010",
/*  FIRST_STAT+55, setsubstitutefonts   */ "\004\006\006\006\006",
/*  FIRST_STAT+56, substitutefonts      */ "",
#endif /* FIND_SUB */
/*  FIRST_STAT+57, checksum              */ "",
/*  FIRST_STAT+58, ramsize               */ "",
/*  DON            NULL                  */ "",
/* END   statusdict */
/* BEGIN userdict */
/*  DON,           "#copies"             */ "",
/*  FIRST_USER+1,  cleardictstack        */ "",
/*  FIRST_USER+2,  letter                */ "",
/*  FIRST_USER+3,  lettersmall           */ "",
/*  FIRST_USER+4,  a4                    */ "",
/*  FIRST_USER+5,  a4small               */ "",
/*  FIRST_USER+6,  b5                    */ "",
/*  FIRST_USER+7,  note                  */ "",
/*  FIRST_USER+8,  legal                 */ "",
/*  FIRST_USER+9,  prompt                */ "",
/*  FIRST_USER+10, quit                  */ "",
/*  FIRST_USER+11, executive             */ "",
/*  FIRST_USER+12, start                 */ "",
/*  DON,           "serverdict"          */ "",
/*  DON,           "execdict"            */ "",
/*  DON,           "printerdict"         */ "",
/*  DON,           "$idleTimeDict"       */ "",
/*  DON            NULL                  */ "",
/* END   userdict */
/* BEGIN errordict */
/*  FIRST_ERRO,    dictfull              */ "",
/*  FIRST_ERRO+1,  dictstackoverflow     */ "",
/*  FIRST_ERRO+2,  dictstackunderflow    */ "",
/*  FIRST_ERRO+3,  execstackoverflow     */ "",
/*  FIRST_ERRO+4,  invalidaccess         */ "",
/*  FIRST_ERRO+5,  invalidexit           */ "",
/*  FIRST_ERRO+6,  invalidfileaccess     */ "",
/*  FIRST_ERRO+7,  invalidfont           */ "",
/*  FIRST_ERRO+8,  invalidrestore        */ "",
/*  FIRST_ERRO+9,  ioerror               */ "",
/*  FIRST_ERRO+10, limitcheck            */ "",
/*  FIRST_ERRO+11, nocurrentpoint        */ "",
/*  FIRST_ERRO+12, rangecheck            */ "",
/*  FIRST_ERRO+13, stackoverflow         */ "",
/*  FIRST_ERRO+14, stackunderflow        */ "",
/*  FIRST_ERRO+15, syntaxerror           */ "",
/*  FIRST_ERRO+16, timeout               */ "",
/*  FIRST_ERRO+17, typecheck             */ "",
/*  FIRST_ERRO+18, undefined             */ "",
/*  FIRST_ERRO+19, undefinedfilename     */ "",
/*  FIRST_ERRO+20, undefinedresult       */ "",
/*  FIRST_ERRO+21, unmatchedmark         */ "",
/*  FIRST_ERRO+22, unregistered          */ "",
/*  FIRST_ERRO+23, VMerror               */ "",
/*  FIRST_ERRO+24, interrupt             */ "",
/*  FIRST_ERRO+25, handleerror           */ "",
/*  DON            NULL                  */ "",
/* END   errordict */
/* BEGIN serverdict */
/*  FIRST_SERV,    settimeouts           */ "",
/*  FIRST_SERV+1,  exitserver            */ "",
/*  DON            "stdin"               */ "",
/*  DON            "stdout"              */ "",
/*  FIRST_SERV+4,  setrealdevice         */ "",
/*  FIRST_SERV+5,  execjob               */ "",
/*  DON            NULL                  */ "",
/* END   serverdict */
/* BEGIN printerdict */
/*  DON            "letter"              */ "",
/*  DON            "lettersmall"         */ "",
/*  DON            "a4"                  */ "",
/*  DON            "a4small"             */ "",
/*  DON            "b5"                  */ "",
/*  DON            "note"                */ "",
/*  DON            "legal"               */ "",
/*  DON            "printerarray"        */ "",
/*  DON            "defaultmatrix"       */ "",
/*  DON            "matrix"              */ "",
/*  FIRST_PRIN+10, proc                  */ "",
/*  DON            "currentpagetype"     */ "",
/*  DON            "width"               */ "",
/*  DON            "height"              */ "",
/*  DON            NULL                  */ "",
/* END   printerdict */
/* BEGIN $idleTimeDict */
/*  DON            "cachestring"         */ "",
/*  DON            "stdfontname"         */ "",
/*  DON            "cachearray"          */ "",
/*  DON            "defaultarray"        */ "",
/*  DON            "carrayindex"         */ "",
/*  DON            "cstringindex"        */ "",
/*  DON            "cstring"             */ "",
/*  DON            "citem"               */ "",
/*  DON            NULL                  */ "",
/* END   $idleTimeDict */
/* BEGIN execdict */
/*  DON            "execdepth"           */ "",
/*  DON            "stmtfile"            */ "",
/*  DON            "idleproc"            */ "",
/*  DON            NULL                  */ "",
/* END   execdict */
/* BEGIN $errordict */
/*  DON            "newerror"            */ "",
/*  DON            "errorname"           */ "",
/*  DON            "command"             */ "",
/*  DON            "ostack"              */ "",
/*  DON            "estack"              */ "",
/*  DON            "dstack"              */ "",
/*  DON            "opnstkary"           */ "",
/*  DON            "dictstkary"          */ "",
/*  DON            "execstkary"          */ "",
/*  DON            "runbatch"            */ "",
/*  DON            "$debug"              */ "",
/*  DON            "$cur_font"           */ "",
/*  DON            "$cur_vm"             */ "",
/*  DON            "$cur_screen"         */ "",
/*  DON            "$cur_matrix"         */ "",
/*  DON            NULL                  */ ""
/* END   $errordict */
} ; /* opntype_array[] */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\file.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        FILE.H
*  Author:      Ping-Jang Su
*  Date:        27-Jul-90
*
*  Update:
************************************************************************
*/
#define     FILE_MAXBUFFERSZ        24     /* 6K: block number of file spool */
#define     FILE_PERBUFFERSZ        256    /* cell size/per block */

/*
* standard file
*/
#define     F_MAXSTDSZ          3
#define     F_STDIN             0
#define     F_STDOUT            1
#define     F_STDERR            2

#define     SPECIALFILE_NO      (F_MAXSTDSZ+2)
#define     SPECIAL_STAT        3
#define     SPECIAL_LINE        4
/*
* file type
*/
#define     SEDIT_TYPE          3
#define     LEDIT_TYPE          4
#define     ORDFILE_TYPE        5
#define     FERR_TYPE           -1

#define     F_MAXNAMELEN        100

#define     F_READ              0x01
#define     F_WRITE             0x02
#define     F_RW                (F_READ | F_WRITE)

#define     READHEXSTRING       0
#define     READSTRING          1
#define     READLINE            2
#define     READ_BUF_LEN        128

#define     WRITEHEXSTRING      0
#define     WRITESTRING         1

#define     NEWLINE             '\n'
#define     TMOUT               "timeout"

#define     EVAL_ASCII(c)\
            {\
                if( c <= (ubyte)9 ) c += (ubyte)'0' ;\
                else c = c + (ubyte)'a' - (ubyte)10 ;\
            }                                   // @WIN

struct  file_buf_def {
    fix16   next ;              /* index of next file buffer */
    byte    data[FILE_PERBUFFERSZ] ;    /* data stream */
} ;

struct special_file_def {
    byte    FAR *name;              /* file name of special */
    fix16   ftype;              /* font type */
} ;

struct para_block {
    byte    FAR *fnameptr;          /* pointer of file name */
    fix     fnamelen;           /* length of file name */
    fix     ftype;              /* file type */
    fix     attr;               /* R/W attribute */
} ;

extern byte     g_mode[] ;
extern GEIFILE  FAR *g_editfile ;
extern struct para_block   fs_info ;
extern struct special_file_def  special_file_table[] ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\exec.c ===
/*
* Copyright (c) 1989,90 Microsoft Corporation
*/
/*
************************************************************************
*      File name:              EXEC.C
*
*      revision history:
************************************************************************
*/
/*
*   Function:
*       interpreter
*       error_handler
*       get_dict_value
*       put_dict_value
*       waittimeout_task
*       init_interpreter
*       at_exec
*       at_ifor
*       at_rfor
*       at_loop
*       at_repeat
*       at_stopped
*       at_arrayforall
*       at_dictforall
*       at_stringforall
*       types_check
*
*/


// DJC added global include file
#include "psglobal.h"


#include    "exec.h"
#include    "user.h"
#include    "language.h"
#include    "geitmr.h"
#include    "geierr.h"
#include    <stdio.h>
#ifdef LINT_ARGS
/* qqq, begin */
/*
static  bool near  types_check(struct object_def FAR *, fix16 *);
*/
static  bool near  types_check(fix16 FAR *);
/* qqq, end */
#else
static  bool near  types_check() ;
#endif /* LINT_ARGS */

GEItmr_t      wait_tmr;
fix16         waittimeout_set=0;
int           waittimeout_task();
ufix8         l_wait=1;
extern byte   TI_state_flag;
/*
extern struct object_def  FAR *l_waittimeout ;
*/

/* @WIN; add prototype */
bool load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
static struct object_def    s_at_exec;          /* qqq */
static ubyte  FAR *s_tpstr;                         /* qqq */
#ifdef  DBG1
void type_obj();
#endif
extern fix16      timeout_flag; /* jonesw */
/*
************************************************************************
*
*   This submodue extract the topmost object of the execution stack, and
*   execute it.
*
*   Name:       interpreter
*   Input:
*       1. proc : input object to be executed
*
*   Data Items Accessed, Created, and/or Modified
*       1. execution stack - Modified
*       2. operand stack - Modified
*
************************************************************************
*/
fix
interpreter(proc)
struct object_def FAR *proc;
{
    struct object_def FAR *cur_obj, FAR *any_obj, FAR *ldval_obj;
    struct object_def token, val_obj;
    struct object_def temp_obj;
#ifdef _AM29K
    struct object_def  FAR *l_waittimeout ;
#endif

    fix  i, cur_type;
    fix  error, (*fun)(fix);          /* @WIN: add prototype */
    //DJC fix  error, (*fun)(void);    //DJC this should NOT pass a function
    fix16  opns;
    static fix  interpreter_depth = 0;


    if( interpreter_depth >= MAXINTERPRETSZ ) {
        ERROR(LIMITCHECK);
        return(1);       /* error */
    } else if( ! FR2EXESPACE() ) {
        ERROR(EXECSTACKOVERFLOW);
        return(1);       /* error */
    } else {
        if(P1_ATTRIBUTE(proc) != P1_EXECUTABLE) {
            if( FR1SPACE() ) {
                PUSH_ORIGLEVEL_OBJ(proc);
                return(0);
            } else {
                ERROR(STACKOVERFLOW);
                return(1);
            }
        }

        interpreter_depth++;
        PUSH_EXEC_OBJ(&s_at_exec);
        PUSH_EXEC_OBJ(proc);
    }

    /*
     * repeatly execute each object on the execution stack
     */
int_begin:
    cur_obj = GET_EXECTOP_OPERAND();
    cur_type = TYPE(cur_obj);
#ifdef  DBG2
    printf("\n<begin:%d, bf:%x, len:%x, vl:%lx> ", execstktop,
        cur_obj->bitfield, cur_obj->length, cur_obj->value);
#endif

int_array:
#ifdef  DBG
    printf("<array> ");
#endif
    /* ARRAY */
    if( cur_type == ARRAYTYPE ) {
        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }
        i = LENGTH(cur_obj);

        if (i) {
            any_obj = (struct object_def huge *)VALUE(cur_obj);

int_array1:
#ifdef  DBG
    printf("<array1> ");
#endif
            cur_type = TYPE(any_obj);
            if( (P1_ATTRIBUTE(any_obj) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(any_obj);
                    if( --i ) {
                        any_obj++;
                        goto int_array1;
                    } else {
                        POP_EXEC(1);
                        goto int_begin;
                    }
                } else {
                    ERROR(STACKOVERFLOW);
                    if( --i ) {
                        VALUE(cur_obj) = (ULONG_PTR)(any_obj+1);
                        LENGTH(cur_obj) = (ufix16)i;
                    } else {
                        POP_EXEC(1);
                    }
                    cur_obj = any_obj;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                if( --i ) {
                    VALUE(cur_obj) = (ULONG_PTR)(any_obj+1);
                    LENGTH(cur_obj) = (ufix16)i;
                } else {
                    POP_EXEC(1);
                    cur_obj--;
                }
                if( cur_type == OPERATORTYPE ) {
                    cur_obj = any_obj;
                    goto int_operator1;
                } else if( cur_type == NAMETYPE ) {
                    cur_obj = any_obj;
                    goto int_name1;
                }
                if( FR1EXESPACE() ) {
                    PUSH_EXEC_OBJ(any_obj);
                    cur_obj++;
                    goto int_stream;
                    /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    cur_obj = any_obj;
                    goto int_ckerror;
                }
            }
        } else
            POP_EXEC(1);
        goto int_begin;
    }   /* ARRAYTYPE */

#ifdef  DBG
    printf("<pkarray> ");
#endif
    /* PACKEDARRAY */
    if( cur_type == PACKEDARRAYTYPE ) {
        ubyte  FAR *tmp_ptr;

        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }

        i = LENGTH(cur_obj);

        if (i) {
            tmp_ptr = (ubyte FAR *)VALUE(cur_obj);
int_pkarray1:
#ifdef  DBG
    printf("<pkarray1> ");
#endif
            get_pk_object(get_pk_array(tmp_ptr, 0), &val_obj, LEVEL(cur_obj));
            cur_type = TYPE(&val_obj);

            if( (P1_ATTRIBUTE(&val_obj) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(&val_obj);
                    if( --i ) {
                        tmp_ptr = get_pk_array(tmp_ptr, 1);
                        /* qqq
                        LENGTH(cur_obj) = i;        |* ?? *|
                        */
                        goto int_pkarray1;
                    } else {
                        POP_EXEC(1);
                        goto int_begin;
                    }
                } else {
                    ERROR(STACKOVERFLOW);
                    if( --i ) {
                        VALUE(cur_obj) = (ULONG_PTR)get_pk_array(tmp_ptr, 1);
                        LENGTH(cur_obj) = (ufix16)i;
                    } else {
                        POP_EXEC(1);
                    }
                    cur_obj = &val_obj;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                if( --i ) {
                    VALUE(cur_obj) = (ULONG_PTR)get_pk_array(tmp_ptr, 1);
                    LENGTH(cur_obj) = (ufix16)i;
                } else {
                    POP_EXEC(1);
                    cur_obj--;
                }
                if( FR1EXESPACE() ) {
                    cur_type = TYPE(&val_obj);
                    if( cur_type == OPERATORTYPE ) {
                        cur_obj = &val_obj;
                        goto int_operator1;
                    } else if( cur_type == NAMETYPE ) {
                        cur_obj = &val_obj;
                        goto int_name1;
                    } else {
                        PUSH_EXEC_OBJ(&val_obj);
                        cur_obj++;
                        goto int_stream;
                        /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                    }
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    cur_obj = &val_obj;
                    goto int_ckerror;
                }
            }
        } else
            POP_EXEC(1);
        goto int_begin;
    }   /* PACKEDARRAY */

int_stream:
#ifdef  DBG
    printf("<stream> ");
#endif

/* qqq
    |* FILE *|
    if( cur_type == FILETYPE ) {
#ifdef  DBG2
    printf("<file> ");
#endif
        if( VALUE(cur_obj) != g_stream.currentID )
            stream_changed = TRUE;
        goto int_stream1;

    }

    |* STRING *|
    if( cur_type == STRINGTYPE ) {
        if( g_stream.currentID != MAX15 )
            stream_changed = TRUE;
*/
    if( (cur_type == FILETYPE) ||
        (cur_type == STRINGTYPE) ) {

//int_stream1:         @WIN
#ifdef  DBG2
    printf("<stream1> ");
#endif

#ifdef _AM29K
                 get_dict_value(STATUSDICT,"waittimeout",&l_waittimeout);
                  if (VALUE(l_waittimeout)>0)
                  {
                    wait_tmr.handler=waittimeout_task;
                    wait_tmr.interval=VALUE(l_waittimeout)*1000;
                    waittimeout_set=1;
                    /* ***** */
                    GEItmr_start(&wait_tmr);
                 /* */
                  }
#endif  /* _AM29K */

        if( P1_ACCESS(cur_obj) == P1_NOACCESS ) {
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            ERROR(INVALIDACCESS);
            goto int_ckerror;
        }

int_stream3:
#ifdef  DBG3
    printf("\n<stream3:%lx> ", g_stream.pointer);
#endif
        TI_state_flag = 0;
        if( get_token(&token, cur_obj) ) {
            TI_state_flag = 1;
#ifdef DBG1
            type_obj(&token);
            /*
            printf("tkntype:%d, attri:%d\n", TYPE(&token),
                    ATTRIBUTE(&token));
            */
            /*
            printf("|\n");
            */
#endif
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            if( check_interrupt() ) {       /* check ^C occurred? */
                POP_EXEC(1) ;               /* ?? */
                ERROR(INTERRUPT);
                goto int_ckerror;           /* ?? */
            }

            cur_type = TYPE(&token);
            if (( cur_type == EOFTYPE ) || (timeout_flag==1)){   /* jonesw */
#ifdef  DBG2
        printf("<EOF> ");
#endif
                if( TYPE(cur_obj) == FILETYPE ) {

                    close_file(cur_obj);
                }
/*
                else {
                    update_stream();
                    g_stream.currentID = -2;
                }
*/
                POP_EXEC(1);
                goto int_ckerror;
            }
            if( (P1_ATTRIBUTE(&token) != P1_EXECUTABLE) ||
                (cur_type == ARRAYTYPE) ||
                (cur_type == PACKEDARRAYTYPE) ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(&token);
                    goto int_stream3;
                } else {
                    ERROR(STACKOVERFLOW);
                    cur_obj = &token;
                    goto int_ckerror;
                }
            } else {                     /* other object */
                cur_obj = &token;
                if( cur_type == OPERATORTYPE ) {
                    goto int_operator1;
                } else if( cur_type == NAMETYPE ) {
                    goto int_name1;
                }
                if( FR1EXESPACE() ) {
                    PUSH_EXEC_OBJ(&token);
                    goto int_stream;
                    /* pass OPERATOR, NAME, ARRAY, PACKARRAY */
                } else {
                    ERROR(EXECSTACKOVERFLOW);
                    goto int_ckerror;
                }
            }
        }   /* if */
        goto int_ckinterrupt;
    }   /* FILE/STRING */

    /* OPERATOR */
    if( cur_type == OPERATORTYPE ) {
        POP_EXEC(1);

int_operator1:
    TI_state_flag = 1;

#ifdef  DBG2
    printf("<op1:%d, name:%s> ", opnstktop,
        systemdict_table[LENGTH(cur_obj)].key);
#endif
        if( *(s_tpstr=(ubyte FAR *)opntype_array[LENGTH(cur_obj)]) )
            if( ! types_check(&opns) )
                goto int_ckerror;
#ifdef  DBG
    printf("<op2> ");
#endif
        COPY_OBJ(cur_obj, &temp_obj);
        fun = (fix (*)(fix))VALUE(cur_obj);
        error = (*fun)(opns);  /* dispatch to each action routine */
        //DJC error = (*fun)();  //DJC should NOT pass arg
        cur_obj = &temp_obj;
        /*
         * only op_stop, op_exit will return error code,
         * and put error code (1) to caller while stop happened
         */

        if( ! error )               /* 0 -- normal action routine */
            goto int_ckinterrupt;
        else if( error == -1 ) {    /* op_stop, op_exit-1 for @exec */
            interpreter_depth--;
            return(1);              /* error */
        } else if( error == -2 ) {  /* @exec -- normal exit */
            interpreter_depth--;
#ifdef  DBG2
    printf("\n");
#endif
            return(0);              /* ok */
        } else if( error == -3 ) {  /* op_quit */
            interpreter_depth--;
            return(2);              /* ok */
        } else if( error == -4 ) {  /* op_exit-2 for @exec */
            cur_obj = GET_EXECTOP_OPERAND();
            goto int_ckerror;
        }
    }   /* OPERATORTYPE */


#ifdef  DBG2
    printf("<name> ");
#endif
    /* NAME */
    if( cur_type == NAMETYPE ) {
        POP_EXEC(1);
int_name1:
#ifdef  DBG2
    printf("<name1> ");
#endif
        if( load_name_obj(cur_obj, &ldval_obj) ) {
            if( P1_ATTRIBUTE(ldval_obj) != P1_EXECUTABLE ) {
                if( FR1SPACE() ) {
                    PUSH_ORIGLEVEL_OBJ(ldval_obj);
                } else {
                    ERROR(STACKOVERFLOW);
                    cur_obj = ldval_obj;
                }
            } else {                    /* other object */
                cur_type = TYPE(ldval_obj);
                if( cur_type == OPERATORTYPE ) {
                    cur_obj = ldval_obj;
                    goto int_operator1;
                } else {
                    //DJC fix for UPD043
                    if (!FR1EXESPACE()) {
                       ERROR(EXECSTACKOVERFLOW);
                       goto int_ckerror;
                    }
                    //DJC end for fix UPD043

                    cur_obj = execstkptr;
                    PUSH_EXEC_OBJ(ldval_obj);
                    goto int_array;
                }
            }
        } else {
            /* ?? object still in execution stack */
            if( FR1SPACE() ) {
                PUSH_OBJ(cur_obj);
                ERROR(UNDEFINED);
            } else {
                ERROR(STACKOVERFLOW);
            }
        }
        goto int_ckerror;
    }   /* NAMETYPE */

    /* NULL */
    if( cur_type == NULLTYPE ) {
#ifdef  DBG2
    printf("<null> ");
#endif
        POP_EXEC(1);
        goto int_ckerror;
    }   /* NULL */

    /*
     * data equivalence objects even it has executable attribute
     * ?? impossible type
     */
#ifdef  DBG2
    printf("<others> ");
#endif
    POP_EXEC(1);
    if( FR1SPACE() ) {
        PUSH_ORIGLEVEL_OBJ(cur_obj);
        goto int_begin;
    } else {
        ERROR(STACKOVERFLOW);
        goto int_ckerror;
    }

int_ckinterrupt:
#ifdef  DBG
    printf("<ckinterrupt> ");
#endif
    if( check_interrupt() )         /* check ^C occurred? */
        ERROR(INTERRUPT);

int_ckerror:
#ifdef  DBG
    printf("<ckerror> ");
#endif
    if( global_error_code )
        error_handler(cur_obj);
    goto int_begin;

}   /* interpreter */
/*
************************************************************************
*   Name:       error_handler
************************************************************************
*/
void
error_handler(cur_obj)
struct object_def FAR *cur_obj ;
{
    struct object_def FAR *any_obj ;
    struct object_def ary_obj ;

    // DJC added
    if (global_error_code) {
      PsReportError(global_error_code);
    }
    // DJC end


    /*
     * doing for the overflow checking of opnstack, dictstack, execstack.
     */
    /**** jonesw begin ****/
    if (timeout_flag == 1)
    {
      ERROR(TIMEOUT);
      if (get_dict_value("errordict", error_table[global_error_code], &any_obj))
          PUSH_ORIGLEVEL_OBJ(any_obj) ;        /* do error handler */
    }
    /**** jonesw end   ****/
    if( ! FR1EXESPACE() )            /* qqq */
       ERROR(EXECSTACKOVERFLOW) ;

    switch (global_error_code) {

    case DICTSTACKOVERFLOW:
            //UPD045

            if(create_array(&ary_obj, dictstktop)) {
               astore_stack(&ary_obj, DICTMODE) ;
               PUSH_OBJ(&ary_obj) ;         /* op_begin reserves one location */
            }
            dictstktop = 2 ;
            dictstkptr = &dictstack[dictstktop] ;   /* qqq */
            change_dict_stack() ;
            goto label_1 ;

        case EXECSTACKOVERFLOW:
            if( ! FR1SPACE() ) {         /* qqq */
                //UPD045
                if(create_array(&ary_obj, opnstktop)){
                  astore_array(&ary_obj) ;
                  PUSH_OBJ(&ary_obj) ;
                }
            }
            //DJC fix for UPD045
            if(create_array(&ary_obj, execstktop) ){
               astore_stack(&ary_obj, EXECMODE) ;
               PUSH_OBJ(&ary_obj) ;
            }
            POP_EXEC(1);

label_1:
            if( ! FR1SPACE() )           /* qqq */
                ERROR(STACKOVERFLOW) ;

        case STACKOVERFLOW:
            if (global_error_code == STACKOVERFLOW) {
                create_array(&ary_obj, opnstktop) ;
                astore_array(&ary_obj) ;
                PUSH_OBJ(&ary_obj) ;
            }
            break ;

    }   /* switch */

    if ((global_error_code != UNDEFINED) &&
        (global_error_code != TIMEOUT) &&
        (global_error_code != INTERRUPT))
        PUSH_ORIGLEVEL_OBJ(cur_obj) ;  /* push that object into the operand stack */

    if (get_dict_value("errordict", error_table[global_error_code], &any_obj))
        PUSH_EXEC_OBJ(any_obj) ;        /* do error handler */

    timeout_flag=0;    /* jonesw */
    global_error_code = 0 ;           /* reset error code */
}   /* error_handler */
/*
************************************************************************
*   get value object associated with the specific key in specific dict,
*   the key and dict are represented in string format it get the
*   value_obj in current active dict using the dictname as key, the
*   value_obj is a dict object, then get the value in this dict using the
*   keyname as key.
*
*   Name:       get_dict_value
************************************************************************
*/
bool
get_dict_value(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR * FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj ;

    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, dictname, lstrlen(dictname), TRUE) ;     /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get the specific dict_obj */
    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, keyname, lstrlen(keyname), TRUE) ;       /* @WIN */

    return(get_dict(dict_obj, &key_obj, value)) ;
}   /* get_dict_value */
/*
************************************************************************
*   put value object associated with the specific key in specific dict,
*   the key and dict are represented in string format
*   it get the value_obj in current active dict using the dictname as key,
*   the value_obj is a dict object, then put the value into this dict using
*   the keyname as key.
*
*   Name:       put_dict_value
************************************************************************
*/
bool
put_dict_value(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj=NULL ;

    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, dictname, lstrlen(dictname), TRUE) ;     /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get execdict obj */
    key_obj.bitfield = 0;       /* qqq, CLEAR_OBJ_BITFIELD(&key_obj); */
    LEVEL_SET(&key_obj, current_save_level) ;
    get_name(&key_obj, keyname, lstrlen(keyname), TRUE) ;       /* @WIN */

    return(put_dict(dict_obj, &key_obj, value)) ;
}   /* put_dict_value */

#ifdef _AM29K
/*
************************************************************************
*   waittimeout handler routine
*
*   Name:       waittimeout_task
************************************************************************
*/
int waittimeout_task()
{
    ERROR(TIMEOUT);
    GESseterror(ETIME);
    GEItmr_stop(wait_tmr.timer_id);
    waittimeout_set=0;
    timeout_flag =1; /* jonesw */
    return(1);
}
#endif
/*
************************************************************************
*   Name:       init_interpreter
************************************************************************
*/
void
init_interpreter()
{
    execstktop = 0 ;
    execstkptr = execstack;                     /* qqq */
    global_error_code = 0 ;

    /* qqq */
    TYPE_SET(&s_at_exec, OPERATORTYPE);
    P1_ACC_UNLIMITED_SET(&s_at_exec);
    P1_ATTRIBUTE_SET(&s_at_exec, P1_EXECUTABLE);
    P1_ROM_RAM_SET(&s_at_exec, P1_ROM);
    LENGTH(&s_at_exec) = AT_EXEC;
    VALUE(&s_at_exec) = (ULONG_PTR)(systemdict_table[AT_EXEC].value);
}   /* init_interpreter */
/*
************************************************************************
*   following functions are used to implement @_operator.
*   there are:
*       1. at_exec() - to implement @exec
*       2  at_ifor() - to implement @ifor
*       3. at_rfor() - to implement @rfor
*       4. at_loop() - to implement @loop
*       5. at_repeat() - to implement @repeat
*       6. at_stopped() - to implement @stopped
*       7. at_arrayforall() - to implement @arrayforall
*       8. at_dictforall() - to implement @dictorall
*       9. at_stringforall() - to implement @stringforall
************************************************************************
*/
/*
************************************************************************
*   Name:       at_exec
*
*   Modified by J. Lin at 11-26-87, also ref to control.c
************************************************************************
*/
fix
at_exec()
{
    if( P1_ACCESS(execstkptr) == P1_UNLIMITED)          /* qqq */
       return(-2) ;     /* normal exit */
    else                /* NOACCESS */
       return(-1) ;     /* @exec for op_exit-1 -- in invalidexit case */
}   /* at_exec */
/*
************************************************************************
*   Name:       at_ifor
************************************************************************
*/
fix
at_ifor()
{
    struct object_def FAR *temp_obj ;
    ULONG_PTR   count;
    ULONG_PTR   increment, limit ;

    temp_obj = GET_EXECTOP_OPERAND();
    count = VALUE(temp_obj) ;             /* get next count */
    increment = VALUE(temp_obj - 1) ;     /* get increment */
    limit = VALUE(temp_obj - 2) ;         /* get limit */

    if ((increment > 0 && count <= limit) ||
                         (increment <= 0 && count >= limit)) {
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW) ;
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW) ;
        else {
            /* push this control variable (count) on the operand stack,
            * increase this control variable, execute the proc
            */
            PUSH_ORIGLEVEL_OBJ(temp_obj);
            count += increment;
            VALUE(temp_obj) = count;
            INC_EXEC_IDX();

            PUSH_EXEC_OBJ(temp_obj - 3);
            return(0);
        }
    }
    POP_EXEC(4);
    return(0);
}   /* at_ifor */
/*
************************************************************************
*   Name:       at_rfor
************************************************************************
*/
fix
at_rfor()
{
    struct object_def FAR *temp_obj;
    union four_byte  count, increment, limit;

    temp_obj = GET_EXECTOP_OPERAND();
    count.ll = (fix32)VALUE(temp_obj);           /* get next count */
    increment.ll = (fix32)VALUE(temp_obj - 1);   /* get increment */
    limit.ll = (fix32)VALUE(temp_obj - 2);       /* get limit */
    if ((increment.ff > (real32)0.0 && count.ff <= limit.ff) ||
                   (increment.ff <= (real32)0.0 && count.ff >= limit.ff)) {
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            * push this control variable (count) on the operand stack,
            * increase this control variable, execute the proc
            */
            PUSH_ORIGLEVEL_OBJ(temp_obj);
            count.ff += increment.ff;
            VALUE(temp_obj) = count.ll;
            INC_EXEC_IDX();
            PUSH_EXEC_OBJ(temp_obj - 3);
            return(0);
        }
    }
    POP_EXEC(4);
    return(0);
}   /* at_rfor */
/*
************************************************************************
*   Name:       at_loop
************************************************************************
*/
fix
at_loop()
{
    struct object_def FAR *temp_obj ;

    temp_obj = GET_EXECTOP_OPERAND();
    if( ! FR2EXESPACE() ) {
        ERROR(EXECSTACKOVERFLOW) ;
        POP_EXEC(1) ;
    } else {
        INC_EXEC_IDX();
        PUSH_EXEC_OBJ(temp_obj) ;
    }
    return(0) ;
}   /* at_loop */
/*
************************************************************************
*   Name:       at_repeat
************************************************************************
*/
fix
at_repeat()
{
    struct object_def FAR *temp_obj ;
    ULONG_PTR  count ;

    temp_obj = GET_EXECTOP_OPERAND();
    count = VALUE(temp_obj);
    if (count) {
        count--;
        VALUE(temp_obj) = count;
        if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            INC_EXEC_IDX();
            PUSH_EXEC_OBJ(temp_obj - 1);
            return(0);
        }
    }
    POP_EXEC(2);
    return(0);
}   /* at_repeat */
/*
************************************************************************
*   the access field of @stopped object is used to record the result
*   of executing stopped context, if it runs to completion normally,
*   the access field is coded to UNLIMITED, and the stopped operator return
*   "false" on the operand stack, otherwise, the access field is coded to
*   NOACCESS, and the stopped operator return "true" on the operand stack.
*
*   Name:       at_stopped
************************************************************************
*/
fix
at_stopped()
{
    ufix  stopped ;

    if( ! FR2SPACE() ) {
        ERROR(STACKOVERFLOW);
        INC_EXEC_IDX();
    } else {
        if( P1_ACCESS(execstkptr) != P1_NOACCESS )
            stopped = FALSE;    /* false */
        else
            stopped = TRUE;     /* true */
        /* return bool onto operand stack */
        PUSH_SIMPLE_VALUE(BOOLEANTYPE, stopped);
    }
    return(0);
}   /* at_stopped */
/*
************************************************************************
*   Name:       at_arrayforall
************************************************************************
*/
fix
at_arrayforall()
{
    struct object_def FAR *cur_obj, val_obj;
    struct object_def huge *tmp_ptr1;
    ubyte  FAR *tmp_ptr2;
    ufix   i;

    cur_obj = GET_EXECTOP_OPERAND();        /* qqq */
    if (i = LENGTH(cur_obj)) {

        if (TYPE(cur_obj) == ARRAYTYPE) {
            tmp_ptr1 = (struct object_def huge *)VALUE(cur_obj);
            COPY_OBJ((struct object_def FAR *)tmp_ptr1, &val_obj);
        } else {
            tmp_ptr2 = (ubyte FAR *)VALUE(cur_obj);
            get_pk_object(get_pk_array(tmp_ptr2, 0), &val_obj, LEVEL(cur_obj));
        }

        if (--i) {
            if (TYPE(cur_obj) == ARRAYTYPE) {
                VALUE(cur_obj) = (ULONG_PTR)(++tmp_ptr1);
            } else {
                tmp_ptr2 = get_pk_array(tmp_ptr2, 1);
                VALUE(cur_obj) = (ULONG_PTR)tmp_ptr2;
            }
            LENGTH(cur_obj) = (ufix16)i;
        } else
            LENGTH(cur_obj) = 0;
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push array element on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(cur_obj - 1);
            return(0);
        }
    }   /* if */
    POP_EXEC(2);
    return(0);
}   /* at_arrayforall */
/*
************************************************************************
*   Name:       at_dictforall
************************************************************************
*/
fix
at_dictforall()
{
    struct object_def FAR *idx_obj, FAR *dict_obj, key_obj ;
    struct object_def FAR *val_obj ;
    ufix   i ;

    idx_obj = GET_EXECTOP_OPERAND();        /* qqq */
    dict_obj = idx_obj - 2;                 /* qqq */
    i = (fix)VALUE(idx_obj);

    if (extract_dict(dict_obj, i, &key_obj, &val_obj)) {
        VALUE(idx_obj)++;
        if( ! FR2SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push key_value pair on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&key_obj);
            PUSH_ORIGLEVEL_OBJ(val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(idx_obj - 1);
            return(0);
        }
    }   /* if */
    POP_EXEC(3);
    return(0);
}   /* at_dictforall */
/*
************************************************************************
*   Name:       at_stringforall
************************************************************************
*/
fix
at_stringforall()
{
    struct object_def FAR *cur_obj, val_obj;
    ufix   i;

    cur_obj = GET_EXECTOP_OPERAND();        /* qqq */
    if (i = LENGTH(cur_obj)) {
        get_string(cur_obj, 0, &val_obj);
        if (--i) {
            byte huge *tmp_ptr;

            tmp_ptr = (byte huge *)VALUE(cur_obj);
            VALUE(cur_obj) = (ULONG_PTR)(++tmp_ptr);
            LENGTH(cur_obj) = (ufix16)i;
        } else
            LENGTH(cur_obj) = 0;
        if( ! FR1SPACE() )
            ERROR(STACKOVERFLOW);
        else if( ! FR2EXESPACE() )
            ERROR(EXECSTACKOVERFLOW);
        else {
            /*
            *  push string element on the operand stack, and execute proc
            */
            PUSH_ORIGLEVEL_OBJ(&val_obj);
            INC_EXEC_IDX();                 /* qqq */
            PUSH_EXEC_OBJ(cur_obj - 1);
            return(0);
        }
    }
    POP_EXEC(2);
    return(0);
}   /* at_stringforall */
/*
************************************************************************
*   perform type checking for operands -
*   set TYPECHECK error code, if some operand's type is different from what
*   an operator expects, otherwise return the actual no# of operands.
*
*   Name:       types_check
************************************************************************
*/
static bool near
types_check(opns)
fix16  FAR *opns;
{
    ufix  no, np, nc, found, op_type, obj_type;
    ufix  error;

#ifdef  DBG
    printf("types_check<%d>\n", (fix)*s_tpstr);
#endif
    error = 0;
    while( *s_tpstr ) {
tc_next:
        found = 0; nc = COUNT();
        no = np = *s_tpstr++;
        while( no ) {
            if( ! nc ) {        /* operands in OPNSTK < required operands */
                if (error < 2) {    /* no error, or TYPECHECK error */
                    if (found == COUNT())
                        error = 2;      /* STACKUNDERFLOW error */
                    else
                        error = 1;      /* TYPECHECK error */
                }
                if( ! *(s_tpstr += no) ) {      /* in last check path */
                    if (error == 2)
                        ERROR(STACKUNDERFLOW);
                    else
                        ERROR(TYPECHECK);
                    return(FALSE);
                } else
                   break;
            } else {
                op_type = *s_tpstr++;
                obj_type = TYPE(GET_OPERAND(np - no));

                switch (op_type) {

                case '\144' :               /* ANYTYPE */
                    found++;
                    break;

                case '\145' :               /* NUMTYPE */
                    if( (obj_type == INTEGERTYPE) || (obj_type == REALTYPE) )
                        found++;
                    break;

                case '\146' :               /* PROCTYPE */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) )
                        found++;
                    break;

                case '\147' :               /* EXCLUDE_NULLTYPE */
                    if (obj_type != NULLTYPE)
                        found++;
                    break;

                case '\150' :               /* STREAMTYPE */
                    if( (obj_type == FILETYPE) || (obj_type == STRINGTYPE) )
                        found++;
                    break;

                case '\151' :               /* COMPOSITE1 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) || (obj_type == DICTIONARYTYPE) ||
                        (obj_type == FILETYPE) )
                        found++;
                    break;

                case '\152' :               /* COMPOSITE2 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) ||
                        (obj_type == DICTIONARYTYPE) )
                        found++;
                    break;

                case '\153' :               /* COMPOSITE3 */
                    if( (obj_type == ARRAYTYPE) ||
                        (obj_type == PACKEDARRAYTYPE) ||
                        (obj_type == STRINGTYPE) )
                        found++;
                    break;

                default :                   /* other types */
                    if (obj_type == op_type)
                        found++;
                    else {
                        if (no <= 1) break;
                        error = 1;
                        s_tpstr += (no - 1);
                        goto tc_next;
                    }

                }   /* switch */
                no--; nc--;
            }   /* else */
        }   /* while */
        if( np == 0 )   break;
        if (found == np) {
            *opns = (fix16)np;                     /* pass type checking */
            return(TRUE);
        }
    }   /* while */
    ERROR(TYPECHECK);   /* operands in OPNSTK >= required operands */
    return(FALSE);
}   /* types_check */

#ifndef  DBG1
void
type_obj(p_obj)
struct object_def       FAR *p_obj;
{
    byte        FAR *l_str, l_str2[200], FAR *l_str3;
    fix         l_len;

    printf("<field: %x> ", p_obj->bitfield );
    switch(ACCESS(p_obj)) {
    case UNLIMITED:
        l_str = "unlimited";
        break;
    case READONLY:
        l_str = "readonly";
        break;
    case EXECUTEONLY:
        l_str = "executeonly";
        break;
    case NOACCESS:
        l_str = "noaccess";
        break;
    default:
        l_str = "ACCESS error";
    }
    printf("%s ", l_str);

    printf("lvl_%d ", LEVEL(p_obj));

    switch(ROM_RAM(p_obj)) {
    case ROM:
        l_str = "rom";
        break;
    case RAM:
        l_str = "ram";
        break;
    case KEY_OBJECT:
        l_str = "key_object";
        break;
    default:
        l_str = "ROM/RAM error";
    }
    printf("%s ", l_str);

    switch(ATTRIBUTE(p_obj)) {
    case LITERAL:
        l_str = "literal";
        break;
    case EXECUTABLE:
        l_str = "executable";
        break;
    case IMMEDIATE:
        l_str = "immediate";
        break;
    default:
        l_str = "ATTRIBUTE error";
    }
    printf("%s ", l_str);

    l_len = 0;
    switch(TYPE(p_obj)) {
    case EOFTYPE:
        l_str = "EOF";
        break;
    case ARRAYTYPE:
        l_str = "ARRAY";
        break;
    case BOOLEANTYPE:
        l_str = "BOOLEAN";
        break;
    case DICTIONARYTYPE:
        l_str = "DICT";
        break;
    case FILETYPE:
        l_str = "FILE";
        break;
    case FONTIDTYPE:
        l_str = "FONTID";
        break;
    case INTEGERTYPE:
        l_str = "INTEGER";
        break;
    case MARKTYPE:
        l_str = "MARK";
        break;
    case NAMETYPE:
        l_str = "NAME";
        l_str3 = name_table[(fix)VALUE(p_obj)]->text;
        l_len = name_table[(fix)VALUE(p_obj)]->name_len;
        lstrncpy(l_str2, l_str3, l_len);        /*@WIN*/
        l_str3 = l_str2;
        break;
    case NULLTYPE:
        l_str = "NULL";
        break;
    case OPERATORTYPE:
        l_str = "OPERATOR";
        l_str3 = systemdict_table[(fix)VALUE(p_obj)].key ;
        l_len = lstrlen(l_str3);        /* @WIN */
        break;
    case REALTYPE:
        l_str = "REAL";
        break;
    case SAVETYPE:
        l_str = "SAVE";
        break;
    case STRINGTYPE:
        l_str = "STRING";
        break;
    case PACKEDARRAYTYPE:
        l_str = "PACKEDARRAY";
        break;
    default:
        l_str = "TYPE error";
    }
    if(l_len) {
        printf("%s:", l_str);
        printf("%s", l_str3);
    } else
        printf("%s", l_str);

    printf(" len:%x, val:%lx\n", LENGTH(p_obj), VALUE(p_obj));
}   /* type_obj */
#endif  /* DBG1 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\error.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              ERROR.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *
 * revision history:
 *      7/13/90 ; ccteng ; add reporterror
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "user.h"
#include    <string.h>

#ifdef LINT_ARGS
static bool near    error_proc(ufix16) ;
#else
static bool near    error_proc() ;
#endif /* LINT_ARGS */

/************************************
 *  DICT: systemdict
 *  NAME: handleerror
 *  FUNCTION:
 *  11/29/89 Teng add to replace old 1pp /handleerror procedure
 ************************************/
fix
op_handleerror()
{
    struct  object_def  FAR *l_tmpobj ;

    /* call "er_doerror" in errordict */
    get_dict_value(ERRORDICT, "handleerror", &l_tmpobj) ;
    interpreter(l_tmpobj) ;

    return(0) ;
}   /* op_handleerror */

/************************************
 *  DICT: systemdict
 *  NAME: errorproc
 *  FUNCTION: ? could be an internal function
 *  11/29/89 Teng add to replace old 1pp /errorproc procedure
 ************************************/
fix
op_errorproc()
{
    struct  object_def  l_newobj, l_newobj1, l_null ;
    struct  object_def  FAR *l_tmpobj = &l_newobj, FAR *l_VMerror = &l_newobj1 ;
    struct  object_def  l_newerror = {0, 0, 0}, l_errorname, l_command, FAR *l_debug ;
    struct  object_def  l_dictstkary, l_opnstkary, l_execstkary ;
    struct  object_def  l_dstack, l_ostack, l_estack ;
    struct  object_def  FAR *l_vm, FAR *l_stopobj ;
    ufix16  l_i, l_j ;

#ifdef  DBG_1pp
    printf("errorproc()...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif  /* DBG_1pp */

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* set $error dict parameters */
    SET_TRUE_OBJ(&l_newerror) ;
    put_dict_value1(DERROR, "newerror", &l_newerror) ;
    COPY_OBJ(GET_OPERAND(0), &l_errorname) ;
    put_dict_value1(DERROR, "errorname", &l_errorname) ;
    COPY_OBJ(GET_OPERAND(1), &l_command) ;
    put_dict_value1(DERROR, "command", &l_command) ;
    POP(2) ;

#ifdef  DBG_1pp
    printf("errorname = ") ;
    PUSH_OBJ(&l_errorname) ;
    two_equal() ;
    printf("hash_id = %d\n", VALUE(&l_errorname)) ;
    printf("command = ") ;
    PUSH_OBJ(&l_command) ;
    two_equal() ;
#endif  /* DBG_1pp */

    /* update "$cur_vm" */
    get_dict_value(DERROR, "$debug", &l_debug) ;
    get_name1(l_VMerror, "VMerror", 7, TRUE) ;
    if ( VALUE(l_debug) )
        /* if "$debug" push vmstatus */
        op_vmstatus() ;
    else
        /* if not "$debug" push 3 NULLs */
        for (l_i = 0 ; l_i < 3 ; l_i++)
            PUSH_VALUE(NULLTYPE,UNLIMITED,LITERAL,0, 0) ;
    get_dict_value(DERROR, "$cur_vm", &l_vm) ;
    astore_array(l_vm) ;

    /* first error? */
    get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
    if ( ( TYPE(l_tmpobj) == NULLTYPE ) &&
         ( VALUE(&l_errorname) != VALUE(l_VMerror) ) ) {
        /* and if "errorname" != /VMerror */
        if ( ( !create_array(&l_execstkary, 250) ) ||
             ( !create_array(&l_opnstkary, 500) ) ||
             ( !create_array(&l_dictstkary, 20) ) ) {
            ERROR(VMERROR) ;
            return(0) ;
        } else {
            put_dict_value1(DERROR, "execstkary", &l_execstkary) ;
            put_dict_value1(DERROR, "opnstkary", &l_opnstkary) ;
            put_dict_value1(DERROR, "dictstkary", &l_dictstkary) ;
        } /* if-else */
    } /* if */

    get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
    if ( TYPE(l_tmpobj) != NULLTYPE ) {
        /* if "dictstkary" != NULL, update stacks */
        /* update "dstack" */
        get_dict_value(DERROR, "dictstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_dstack) ;
        astore_stack(&l_dstack, DICTMODE) ;
        put_dict_value1(DERROR, "dstack", &l_dstack) ;

        /* update "estack" */
        get_dict_value(DERROR, "execstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_estack) ;
        astore_stack(&l_estack, EXECMODE) ;
     /* 2/16/90 ccteng, don't need it
      * LENGTH(&l_estack) -= 2 ;
      */
        put_dict_value1(DERROR, "estack", &l_estack) ;

        /* update "ostack" */
        l_j = COUNT() ;
        get_dict_value(DERROR, "opnstkary", &l_tmpobj) ;
        COPY_OBJ(l_tmpobj, &l_ostack) ;
        LENGTH(&l_ostack) = l_j ;
        for (l_i = 0 ; l_i < COUNT() ; l_i++)
              put_array(&l_ostack, l_i, GET_OPERAND(--l_j)) ;
        put_dict_value1(DERROR, "ostack", &l_ostack) ;

        /*
         * if "$debug": update $cur_font, $cur_screeen, $cur_matrix.
         */
        if ( VALUE(l_debug) ) {
            struct  object_def  l_screen, l_matrix, l_font ;

            /* update "$cur_font" */
            op_currentfont() ;       /* or use GSptr with include files */
            COPY_OBJ(GET_OPERAND(0), &l_font) ;
            put_dict_value1(DERROR, "$cur_font", &l_font) ;
            POP(1) ;

#ifdef  DBG_1pp
    printf("$cur_font = ") ;
    PUSH_OBJ(&l_font) ;
    two_equal() ;
#endif  /* DBG_1pp */

            /* update "$cur_screen" */
            op_currentscreen() ;     /* or use GSptr with include files */
            l_j = 3 ;                /* 3 array */
            create_array(&l_screen, l_j) ;
            for (l_i = 0 ; l_i < l_j ; l_i++)
                  put_array(&l_screen, l_i, GET_OPERAND(--l_j)) ;
            put_dict_value1(DERROR, "$cur_screen", &l_screen) ;
            POP(3) ;

#ifdef  DBG_1pp
    printf("$cur_screen = ") ;
    PUSH_OBJ(&l_screen) ;
    two_equal() ;
#endif  /* DBG_1pp */

            /* update "$cur_matrix" */
            create_array(&l_matrix, 6) ;
            PUSH_ORIGLEVEL_OBJ(&l_matrix) ;
            op_currentmatrix() ;
            put_dict_value1(DERROR, "$cur_matrix", &l_matrix) ;
            POP(1) ;

#ifdef  DBG_1pp
    printf("$cur_matrix = ") ;
    PUSH_OBJ(&l_matrix) ;
    two_equal() ;
#endif  /* DBG_1pp */

        } else {
            SET_NULL_OBJ(&l_null) ;
            put_dict_value1(DERROR, "$cur_font", &l_null) ;
            put_dict_value1(DERROR, "$cur_screen", &l_null) ;
            put_dict_value1(DERROR, "$cur_matrix", &l_null) ;
        } /* if */

    } /* if */

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}   /* op_errorproc */

/*
 * put value object associated with the specific key in specific dict,
 * the key and dict are represented in string format
 * it get the value_obj in current active dict using the dictname as key,
 * the value_obj is a dict object, then put the value into this dict using
 * the keyname as key.
 *
 * 12/20/89 ccteng, modify from put_dict_value (EXEC.C)
 */
bool
put_dict_value1(dictname, keyname, value)
byte FAR *dictname, FAR *keyname ;
struct object_def FAR *value ;
{
    struct object_def key_obj, FAR *dict_obj ;

    get_name1(&key_obj, dictname, lstrlen(dictname), TRUE) ;    /* @WIN */
    load_dict(&key_obj, &dict_obj) ;     /* get execdict obj */
    get_name1(&key_obj, keyname, lstrlen(keyname), TRUE) ;      /* @WIN */

    return(put_dict1(dict_obj, &key_obj, value, TRUE)) ;
}   /* put_dict_value1 */

/************************************
 *  DICT: errordict
 *  NAME: dictfull
 *  FUNCTION:
 *  INTERFACE:
 ************************************/
fix
er_dictfull()
{
#ifdef  DBG_1pp
    printf("dictfull()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTFULL) ;

    return(0) ;
}   /* er_dictfull */

/************************************
 *  DICT: errordict
 *  NAME: dictstackoverflow
 *  FUNCTION:
 *  INTERFACE:
 ************************************/
fix
er_dictstackoverflow()
{
#ifdef  DBG_1pp
    printf("dictstackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTSTACKOVERFLOW) ;

    return(0) ;
}   /* er_dictstackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: dictstackunderflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_dictstackunderflow()
{
#ifdef  DBG_1pp
    printf("dictstackunderflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(DICTSTACKUNDERFLOW) ;

    return(0) ;
}   /* er_dictstackunderflow */

/************************************
 *  DICT: errordict
 *  NAME: execstackoverflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_execstackoverflow()
{
#ifdef  DBG_1pp
    printf("execstackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(EXECSTACKOVERFLOW) ;

    return(0) ;
}   /* er_execstackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: invalidaccess
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidaccess()
{
#ifdef  DBG_1pp
    printf("invalidaccess()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDACCESS) ;

    return(0) ;
}   /* er_invalidaccess */

/************************************
 *  DICT: errordict
 *  NAME: invalidexit
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidexit()
{
#ifdef  DBG_1pp
    printf("invalidexit()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDEXIT) ;

    return(0) ;
}   /* er_invalidexit */

/************************************
 *  DICT: errordict
 *  NAME: invalidfileaccess
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidfileaccess()
{
#ifdef  DBG_1pp
    printf("invalidfileaccess()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDFILEACCESS) ;

    return(0) ;
}   /* er_invalidfileaccess */

/************************************
 *  DICT: errordict
 *  NAME: invalidfont
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidfont()
{
#ifdef  DBG_1pp
    printf("invalidfont()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDFONT) ;

    return(0) ;
}   /* er_invalidfont */

/************************************
 *  DICT: errordict
 *  NAME: invalidrestore
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_invalidrestore()
{
#ifdef  DBG_1pp
    printf("invalidrestore()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(INVALIDRESTORE) ;

    return(0) ;
}   /* er_invalidrestore */

/************************************
 *  DICT: errordict
 *  NAME: ioerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_ioerror()
{
#ifdef  DBG_1pp
    printf("ioerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(IOERROR) ;

    return(0) ;
}   /* er_ioerror */

/************************************
 *  DICT: errordict
 *  NAME: limitcheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_limitcheck()
{
#ifdef  DBG_1pp
    printf("limitcheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(LIMITCHECK) ;

    return(0) ;
}   /* er_limitcheck */

/************************************
 *  DICT: errordict
 *  NAME: nocurrentpoint
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_nocurrentpoint()
{
#ifdef  DBG_1pp
    printf("nocurrentpoint()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(NOCURRENTPOINT) ;

    return(0) ;
}   /* er_nocurrentpoint */

/************************************
 *  DICT: errordict
 *  NAME: rangecheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_rangecheck()
{
#ifdef  DBG_1pp
    printf("rangecheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(RANGECHECK) ;

    return(0) ;
}   /* er_rangecheck */

/************************************
 *  DICT: errordict
 *  NAME: stackoverflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_stackoverflow()
{
#ifdef  DBG_1pp
    printf("stackoverflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(STACKOVERFLOW) ;

    return(0) ;
}   /* er_stackoverflow */

/************************************
 *  DICT: errordict
 *  NAME: stackunderflow
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_stackunderflow()
{
#ifdef  DBG_1pp
    printf("stackunderflow()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(STACKUNDERFLOW) ;

    return(0) ;
}   /* er_stackunderflow */

/************************************
 *  DICT: errordict
 *  NAME: syntaxerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_syntaxerror()
{
#ifdef  DBG_1pp
    printf("syntaxerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(SYNTAXERROR) ;

    return(0) ;
}   /* er_syntaxerror */

/************************************
 *  DICT: errordict
 *  NAME: timeout
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_timeout()
{
#ifdef  DBG_1pp
    printf("timeout()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(TIMEOUT) ;

    return(0) ;
}   /* er_timeout */

/************************************
 *  DICT: errordict
 *  NAME: typecheck
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_typecheck()
{
#ifdef  DBG_1pp
    printf("typecheck()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(TYPECHECK) ;

    return(0) ;
}   /* er_typecheck */

/************************************
 *  DICT: errordict
 *  NAME: undefined
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefined()
{
#ifdef  DBG_1pp
    printf("undefined()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINED) ;

    return(0) ;
}   /* er_undefined */

/************************************
 *  DICT: errordict
 *  NAME: undefinedfilename
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefinedfilename()
{
#ifdef  DBG_1pp
    printf("undefinedfilename()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINEDFILENAME) ;

    return(0) ;
}   /* er_undefinedfilename */

/************************************
 *  DICT: errordict
 *  NAME: undefinedresult
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_undefinedresult()
{
#ifdef  DBG_1pp
    printf("undefinedresult()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNDEFINEDRESULT) ;

    return(0) ;
}   /* er_undefinedresult */

/************************************
 *  DICT: errordict
 *  NAME: unmatchedmark
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_unmatchedmark()
{
#ifdef  DBG_1pp
    printf("unmatchedmark()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNMATCHEDMARK) ;

    return(0) ;
}   /* er_unmatchedmark */

/************************************
 *  DICT: errordict
 *  NAME: unregistered
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_unregistered()
{
#ifdef  DBG_1pp
    printf("unregistered()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(UNREGISTERED) ;

    return(0) ;
}   /* er_unregistered */

/************************************
 *  DICT: errordict
 *  NAME: VMerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_VMerror()
{
#ifdef  DBG_1pp
    printf("VMerror()...\n") ;
#endif  /* DBG_1pp */

    /* call error_proc */
    error_proc(VMERROR) ;

    return(0) ;
}   /* er_VMerror */

/************************************
 *  DICT: errordict
 *  NAME: interrupt
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_interrupt()
{
    struct  object_def  FAR *l_stopobj ;
#ifdef  DBG_1pp
    printf("interrupt()...\n") ;
#endif  /* DBG_1pp */

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}   /* er_interrupt */

/************************************
 *  DICT: errordict
 *  NAME: handleerror
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
er_handleerror()
{
    struct  object_def  FAR *l_errorname, FAR *l_newerror, FAR *l_command ;

#ifdef  DBG_1pp
    printf("er_handleerror()...\n") ;
#endif  /* DBG_1pp */

    /* 7/27/90 ccteng change FRCOUNT from 1 to 3 for messagedict reporterror */
    if (FRCOUNT() < 3) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* if "newerror", print the error message on screen */
    get_dict_value(DERROR, "newerror", &l_newerror) ;
    if ( VALUE(l_newerror) ) {

        //DJC here we must call a PSTODIB function to let the psttodib
        //DJC code know that the internal error handler was used and
        //DJC this data needs to be passed on to the caller of our DLL
        //
        PsInternalErrorCalled();   //DJC



        VALUE(l_newerror) = FALSE ;
        get_dict_value(DERROR, "command", &l_command) ;
        PUSH_ORIGLEVEL_OBJ(l_command) ;
        get_dict_value(DERROR, "errorname", &l_errorname) ;
        PUSH_ORIGLEVEL_OBJ(l_errorname) ;
        get_dict_value(MESSAGEDICT, "reporterror", &l_newerror) ;
        interpreter(l_newerror) ;
        op_flush() ;
    }

    return(0) ;
}   /* er_handleerror */

/************************************
 *  DICT: ..internal..
 *  NAME: errpr_proc
 *  FUNCTION:
 *  INTERFACE: above....
 ************************************/
static bool near
error_proc(errorname)
ufix16  errorname ;
{
    extern  byte   FAR * FAR error_table[] ;
    struct  object_def  l_errorobj ;
    byte    FAR *l_errorstring ;

#ifdef  DBG_1pp
    printf("error_proc()...\n") ;
#endif  /* DBG_1pp */

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(FALSE) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(FALSE) ;
    }

    /* push errorname */
    l_errorstring = (byte FAR *) error_table[errorname] ;
    get_name1(&l_errorobj, l_errorstring, lstrlen(l_errorstring), TRUE);/* @WIN */
    PUSH_ORIGLEVEL_OBJ(&l_errorobj) ;

#ifdef  DBG_1pp
    op_pstack() ;
    printf("end pstack...\n") ;
#endif  /* DBG_1pp */

    /* call systemdict "errorproc" */
    op_errorproc() ;

    return(TRUE) ;
}   /* error_proc */

/*
** Submodule get_name1
**
** Function Description
**
**      call get_name
*/
bool
get_name1(token, string, len, isvm)
struct  object_def FAR *token ;
byte    FAR *string ;
ufix    len ;
bool8   isvm ;
{
    /* set attribute and save_level */
    ATTRIBUTE_SET(token, LITERAL) ;
    LEVEL_SET(token, current_save_level) ;

    /* call get_name */
    if ( get_name(token, string, len, isvm) )
        return(TRUE) ;
    else
        return(FALSE) ;
} /* get_name1() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\file.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        FILE.C
*  By:          Ping-Jang Su
*  Date:        Jan-05-88
*  Owner:
*
*  History:
*   Jan-30-89 PJ: . op_token: skip one whitespace
*   06-23-90 ; Added unix support for op_run().
************************************************************************
*/
/*
*   Function:
*       op_file
*       op_closefile
*       op_read
*       op_write
*       op_readhexstring
*       op_writehexstring
*       op_readstring
*       op_writestring
*       op_readline
*       op_token
*       op_bytesavailable
*       op_flush
*       op_flushfile
*       op_resetfile
*       op_status
*       op_run
*       op_currentfile
*       op_print
*       op_echo
*       op_eexec
*       st_setstdio
*
*       init_file
*       open_file
*       open_edit
*       close_file
*       close_fd
*       read_file
*       read_fd
*       unread_file
*       write_fd
*       get_flbuffer
*       free_flbuffer
*       print_string
*       check_fname
*       wait_editin
*       read_routine
*       write_routine
*       vm_close_file
*
*       op_deletefile               ; not complete yet
*       op_renamefile               ; not complete yet
*       op_filenameforall           ; comment
*
*       port_out_string
*/


// DJC added global include file
#include "psglobal.h"


#include        <string.h>

#include        "stdio.h"
#include        "global.ext"
#include        "geiio.h"               /* @GEI */
#include        "geiioctl.h"            /* @GEI */
#include        "geierr.h"              /* @GEI */
#include        "gescfg.h"              /* @GEI */
#include        "geitmr.h"              /* @GEI */
#include        "language.h"
#include        "file.h"
#include        "user.h"

#ifdef  SCSI
#include        "scsi.h"
#include        "scsi.ext"
#endif  /* SCSI */

static  struct file_buf_def far * near   file_buffer ;
static  fix16   fspool_head ;    /* file-buffer-spool header */
static  bool8   echo_setting ;

byte    g_mode[4] ;
GEIFILE FAR *g_editfile ;
struct para_block   fs_info ;    /* parameter block used in open_file */

ufix16 eseed, old_eseed ;
//DJC fix bypass ;
fix32 bypass ; // DJC fix from SC
xbool itype ;
ybool estate = NON_EEXEC ;

struct special_file_def special_file_table[SPECIALFILE_NO] = {
    { "%stdin",          F_STDIN},
    { "%stdout",         F_STDOUT},
    { "%stderr",         F_STDERR},
    { "%statementedit",  SEDIT_TYPE},
    { "%lineedit",       LEDIT_TYPE},
} ;

static  bool    CRLF_flag = 0 ;

#ifdef  LINT_ARGS
static bool near    open_edit(struct object_def FAR *) ;
static bool near    write_fd(GEIFILE FAR *, byte) ;
static bool near    get_flbuffer(fix FAR *) ;
static bool near    free_flbuffer(fix, fix) ;
static bool near    wait_editin(fix FAR *, fix) ;
static void near    check_fname(void) ;
static void near    read_routine(fix) ;
static void near    write_routine(fix) ;
#else
static bool near    open_edit() ;
static bool near    write_fd() ;
static bool near    get_flbuffer() ;
static bool near    free_flbuffer() ;
static bool near    wait_editin() ;
static void near    check_fname() ;
static void near    read_routine() ;
static void near    write_routine() ;
#endif  /* LINT_ARGS */


#ifdef  LINT_ARGS
extern void     init_file(void) ;
extern bool     open_file(struct object_def FAR *) ;
extern bool     close_file(struct object_def FAR *) ;
extern bool     close_fd(GEIFILE FAR *) ;
extern bool     read_file(struct object_def FAR *, byte FAR *) ;
extern bool     read_fd(GEIFILE FAR *, byte FAR *) ;
extern bool     unread_file(byte, struct object_def FAR *) ;
// DJC declared in language.h
// extern void     vm_close_file(p_level) ;
#else
extern void     init_file() ;
extern bool     open_file() ;
extern bool     close_file() ;
extern bool     close_fd() ;
extern bool     read_file() ;
extern bool     read_fd() ;
extern bool     unread_file() ;
// DJC declared in language.h
// extern void     vm_close_file() ;
#endif  /* LINT_ARGS */
extern GEItmr_t      wait_tmr;   /* jonesw */
extern fix16         waittimeout_set; /*jonesw*/

//DJC UPD045
extern bool g_extallocfail;

/* @WIN; add prototype */
bool read_c_exec(byte FAR *, struct object_def FAR *) ;
bool read_c_norm(byte FAR *, struct object_def FAR *) ;
void unread_char(fix, struct object_def FAR *) ;

/*
**********************************************************************
*
*   This submodule implements the operator file.
*   Its operand and result objects on the operand stack are :
*       string1 string2 -file- file
*   This operator creates a file object for the file identifid by
*   string1, accessing it as specitied by string2. In this version,
*   only four kinds of file are implemted.
*
*   Name:       op_file
*   Called:     interpreter
*   Calling:    open_file
**********************************************************************
*/
fix
op_file()
{
    byte   FAR *l_tmptr, FAR *l_mode ;
    struct  object_def  l_fobj ;

    /*
    * check access right
    */
    if( (ACCESS_OP(0) >= EXECUTEONLY) ||
        (ACCESS_OP(1) >= EXECUTEONLY) ||
        (LENGTH_OP(0) > 3) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    l_tmptr = (byte FAR *)VALUE_OP(0) ;
    fs_info.attr = 0 ;
    l_mode = g_mode ;
    /*
    * ?? the second operand is not defined clearly
    * l_mode: a null terminate string for fopen()
    * fs_info.attr: attribute value to fill in file descriptor
    *       bit 0:  read
    *       bit 1:  write
    *       bit 2:  append
    *       bit 3:  statementedit/lineedit
    */
    if( LENGTH_OP(0) != 1 ) {
        ERROR(INVALIDACCESS) ;                   /* ?? */
        return(0) ;
    }

    switch(*l_tmptr++) {
    case 'r':
        fs_info.attr |= F_READ ;
        *l_mode++ = 'r' ;
        break ;

    case 'w':
        fs_info.attr |= F_WRITE ;
        *l_mode++ = 'w' ;
        break ;

    default:
        ERROR(INVALIDACCESS) ;                   /* ?? */
        return(0) ;
    }   /* switch */

    *l_mode = 0 ;
    fs_info.fnameptr = (byte FAR *)VALUE_OP(1) ;
    fs_info.fnamelen = LENGTH_OP(1) ;

    if ( open_file(&l_fobj) ) {
        if ( (fs_info.attr & F_RW) == F_READ ) {
            ACCESS_SET(&l_fobj, READONLY) ;
        }
        ATTRIBUTE_SET(&l_fobj, LITERAL) ;
        POP(2) ;
        PUSH_OBJ(&l_fobj) ;
    }
    return(0) ;
}   /* op_file */
/*
**********************************************************************
*
*   This submodule implements the operator closefile.
*   Its operand and result objects on the operand stack are :
*       file -closefile-
*   For an outfile, closefile first performs a flusfile.
*
*   Name:       op_closefile
*   Called:     interpreter
*   Calling:    close_file
**********************************************************************
*/
fix
op_closefile()
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if( (! GEIio_isopen(l_file)) || ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0)) ) { //@WIN
        POP(1) ;
        return(0) ;
    }

    if( close_fd(l_file) )
        POP(1) ;

    return(0) ;
}   /* op_closefile */
/*
**********************************************************************
*
*   This submodule implements the operator read.
*   Its operand and result objects on the operand stack are :
*       file -read- integer true
*                   false
*   It reads the next character from the input file, and pushes it on the
*   stack as an integer, and pushes a true object as an indication of
*   success. If an end-of-file is encountered before a character is read,
*   it closes the file and returns false on the operand stack.
*
*   Name:       op_read
*   Called:     interpreter
*   Calling:    read_char
*               close_fd
**********************************************************************
*/
fix
op_read()
{
    byte    l_c ;
    GEIFILE FAR *l_file ;

    if( (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( ! GEIio_isreadable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) { //@WIN
        if( estate == NON_EEXEC ) {
            if( read_fd(l_file, &l_c) ) {
                if (l_c == 10 && CRLF_flag) {
                    CRLF_flag = 0 ;
                    if (read_fd(l_file, &l_c)) {
                        if( l_c == 13 ) {
                            l_c = 10 ;
                            CRLF_flag = 1 ;
                        }
                    goto read_true ;
                    } else
                        goto read_false ;
                } else CRLF_flag = 0 ;

                if( l_c == 13 ) {
                    l_c = 10 ;
                    CRLF_flag = 1 ;
                }
                goto read_true ;
            } else
                goto read_false ;
        } else {
            if( read_c_exec(&l_c, GET_OPERAND(0)) )
                goto read_true ;
            else
                goto read_false ;
        }
    }

read_false:
    GEIio_clearerr(l_file) ;
    GEIclearerr() ;
    if( ! ANY_ERROR() ) {
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }
    return(0) ;

read_true:
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, ((ufix32)l_c & 0x000000FF)) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
    return(0) ;

}   /* op_read */
/*
**********************************************************************
*
*   This submodule implements the operator write.
*   Its operand and result objects on the operand stack are :
*       file integer -write-
*   It appends a single character to the output file. The integer operand
*   must be in the range 0 to 255 representing a character code.
*
*   Name:       op_write
*   Called:     interpreter
*   Calling:    write_fd
**********************************************************************
*/
fix
op_write()
{
    ubyte   l_c ;
    GEIFILE FAR *l_file ;

    if( ACCESS_OP(1) != UNLIMITED ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;

    if ( ! GEIio_iswriteable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if ( (! GEIio_isopen(l_file)) || ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) { //@WIN
        ERROR(IOERROR) ;
        return(0) ;
    }

    l_c = (ubyte)(VALUE_OP(0) % 256) ;

    if( write_fd(l_file, l_c) )
        POP(2) ;
    return(0) ;
}   /* op_write */
/*
**********************************************************************
*
*   This submodule implements the operator readhexstring.
*   Its operand and result objects on the operand stack are :
*       file string -readhexstring- substring boolean
*   It reads hexadecimal charaters from the input file to the string.
*
*   Name:       op_readhexstring
*   Called:     interpreter
*   Calling:    read_routine
**********************************************************************
*/
fix
op_readhexstring()
{
    read_routine(READHEXSTRING) ;
    return(0) ;
}   /* op_readhexstring */
/*
**********************************************************************
*
*   This submodule implements the operator writehexstring.
*   Its operand and result objects on the operand stack are :
*       file string -writehexstring-
*   It writes the characters in the string to the file as hexadecimal digits.
*
*   Name:       op_writehexstring
*   Called:     interpreter
*   Calling:    write_routine
**********************************************************************
*/
fix
op_writehexstring()
{
    write_routine(WRITEHEXSTRING) ;
    return(0) ;
}   /* op_writehexstring */
/*
**********************************************************************
*
*   This submodule implements the operator readstring.
*   Its operand and result objects on the operand stack are :
*       file string -readstring- substring boolean
*   It reads characters from the file and stores them into successive elements
*   of string until the entire string has been filled or an end-of-file
*   indication is encountered in file. It returns the substring of the string
*   that was actually filled and a boolean as a indication of the outcome.
*
*   Name:       op_readstring
*   Called:     interpreter
*   Calling     read_routine
**********************************************************************
*/
fix
op_readstring()
{
    read_routine(READSTRING) ;
    return(0) ;
}   /* op_readstring */
/*
**********************************************************************
*
*   This submodule implements the operator writestring.
*   Its operand and result objects on the operand stack are :
*       file string -writestring-
*   It writes the characters of the string to the output file.
*
*   Name:       op_writestring
*   Called:     interpreter
*   Calling:    write_routine
**********************************************************************
*/
fix
op_writestring()
{
    write_routine(WRITESTRING) ;
    return(0) ;
}   /* op_writestring */
/*
**********************************************************************
*
*   This submodule implements the operator readline.
*   Its operand and result objects on the operand stack are :
*       file string -readline-  substring bool
*   It reads a line of characters from the file and stores them
*   into successive elements of the string.
*
*   Name:       op_readline
*   Called:     interpreter
*   Calling:    read_routine
**********************************************************************
*/
fix
op_readline()
{
    read_routine(READLINE) ;
    return(0) ;
}   /* op_readline */
/*
**********************************************************************
*
*   This submodule implements the operator token.
*   Its operand and result objects on the operand stack are :
*       file   -token- any true
*                      false
*       string -token- post any true
*                      false
*   read characters from the file or the string, interpreting them according
*   to the PostScript syntax rules, until it has scanned and constructed an
*   entire object.
*
*   Name:       op_token
*   Called:     interpreter
*   Calling:    get_token
*               close_fd
**********************************************************************
*/
fix
op_token()
{
    bool    l_bool ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_token, l_obj ;

    if (ACCESS_OP(0) >= EXECUTEONLY) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (TYPE_OP(0) == FILETYPE)
        l_bool = TRUE ;
    else
        l_bool = FALSE ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if (l_bool && ((! GEIio_isopen(l_file)) ||
                     ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0))) ) {//@WIN
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        return(0) ;
    }

    /* call get token procedure to get a token */
    COPY_OBJ(GET_OPERAND(0), &l_obj) ;
    if (get_token(&l_token, &l_obj)) {
        if (TYPE(&l_token) != EOFTYPE) {
            LEVEL_SET(&l_token, LEVEL(&l_obj)); /* pjsu 3-17-1991 */
            POP(1) ;
            if (!l_bool) {
                /* ?? testing
                {
                    fix16   l_len ;
                    byte    FAR *l_ptr ;

                    switch (TYPE(&l_token)) {
                    case NAMETYPE:
                    case INTEGERTYPE:
                    case REALTYPE:
                        l_ptr = (byte FAR *)VALUE(&l_obj) ;
                        l_len = LENGTH(&l_obj) ;
                        if ((l_len-- >= 1) && (ISWHITESPACE(FAR *l_ptr))) {
                            l_ptr++ ;
                            VALUE(&l_obj) = (ufix32)l_ptr ;
                            LENGTH(&l_obj) = l_len ;
                        }
                    }
                }
                */

                PUSH_ORIGLEVEL_OBJ(&l_obj) ;
/*              PUSH_OBJ(&l_obj) ; pjsu 3-17-1991 */
                if (FRCOUNT() < 2)
                    ERROR(STACKOVERFLOW) ;
                else
                    PUSH_ORIGLEVEL_OBJ(&l_token) ;
            } else {
                PUSH_ORIGLEVEL_OBJ(&l_token) ;
                if (FRCOUNT() < 1)
                    ERROR(STACKOVERFLOW) ;
            }
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        } else {
            if (l_bool)
                close_fd(l_file) ;
            POP(1) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    } else if (ANY_ERROR() == SYNTAXERROR) {
        if (l_bool)
            close_fd(l_file) ;
        CLEAR_ERROR() ;
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0,LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_token */
/*
**********************************************************************
*
*   This submodule implements the operator file.
*   Its operand and result objects on the operand stack are :
*       file -bytesavailable integer
*   It returns the number of bytes that are immediately avaible for
*   reading from the file without waiting.
*
*   Name:       op_bytesavailable
*   Called:     interpreter
*   Calling:    ?? byteavailable
*               ioctl
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_bytesavailable()
{
    GEIFILE FAR *l_file ;
    fix32   l_i ;

    if( ACCESS_OP(0) == NOACCESS ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;
    l_i = -1 ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN

        if( GEIio_isreadable(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            if( GEIio_isedit(l_file) ) {
                l_fbuf = l_file->f_fbuf ;
                l_i = (fix32)(ufix32)l_fbuf->size + l_fbuf->incount ;
            } else
                GEIio_ioctl(l_file, _FIONREAD, (int FAR *)&l_i) ; /*@WIN add cast*/
        }
    }
    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, l_i) ;

    return(0) ;
}   /* op_bytesavailable */
/*
**********************************************************************
*
*   This submodule implements the operator flush.
*   Its operand and result objects on the operand stack are :
*       -flush-
*   It causes any buffered characters for the stardard output file to be
*   delivered immediately.
*
*   Name:       op_flush
*   Called:     interpreter
*   Calling:    fflush
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_flush()
{
    GEIio_flush(GEIio_stdout) ;
    return(0) ;
}   /* op_flush */
/*
**********************************************************************
*
*   This submodule implements the operator flushfile
*   Its operand and result objects on the operand stack are :
*       file -flushfile-
*   If the file is an output file, it causes any buffered characters for
*   that file to be delivered immediately.
*   If the file is an input file, it reads and discards data from file
*   until the end-of-file indication is encountered.
*
*   Name:       op_flushfile
*   Called:     interpreter
*   Calling:    close_fd
*               wait_stdin
*               fflush
*               create_string
*               strncpy
*               clearerr
*               free_flbuffer
**********************************************************************
*/
fix
op_flushfile()
{
    GEIFILE FAR *l_file ;
    struct object_def l_obj ;
    int  iTmp;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN
        if( GEIio_isedit(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            /* RELEASE BUFFER */
            l_fbuf = l_file->f_fbuf ;
            l_fbuf->incount = 0 ;
            if( l_fbuf->size != 0 ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->size = 0 ;
            }
            l_fbuf->rw_buffer = MINUS_ONE ;
        } else
        if( GEIio_iswriteable(l_file) ) {
            GEIio_flush(l_file) ;
        } else {
            for ( ; ;) {
                //DJC if( (char)GEIio_getc(l_file) == EOF ) { //@WIN; cast to fix bug
                iTmp = (int)GEIio_getc(l_file);
                if (iTmp == EOF) {
                    if( GEIio_err(l_file) ) {
                        if( GEIerror() == ETIME ) {
                            if ( FRCOUNT() < 1 )
                                ERROR(STACKOVERFLOW) ;
                            else if (create_string(&l_obj, (ufix16)7)) {
                                lstrncpy((byte FAR *)l_obj.value, TMOUT, 7) ;/*@WIN*/
                                PUSH_OBJ(&l_obj) ;
                            }
                        } else
                            ERROR(IOERROR) ;
                        /* ?? need close file */
                    }
                    /* ?? leave for next time */
                    GEIio_clearerr(l_file) ;
                    GEIclearerr() ;
                    close_fd(l_file) ;
                    break ;
                } /* if */
            } /* for */
        }
    }

    if( ! ANY_ERROR() ) POP(1) ;
    //DJC UPD045
    g_extallocfail=FALSE;

    return(0) ;
}   /* op_flushfile */
/*
**********************************************************************
*
*   This submodule implements the operator resetfile.
*   Its operand and result objects on the operand stack are :
*       file -resetfile-
*   It discards buffered characters belonging to a file object.
*   For an input file, it discard all the characters that have been received
*   from the source but not yet consumed ; for an out file, it discards
*   any characters that have been written to the file but not yet deliverd
*   to their destination.
*
*   Name:       op_resetfile
*   Called:     interpreter:
*   Calling:    close_fd
*               free_flbuffer
*               ?? sf_isdiskonline
**********************************************************************
*/
fix
op_resetfile()
{
    GEIFILE FAR *l_file ;
    fix     l_arg ;

    l_file = (GEIFILE FAR *)VALUE_OP(0) ;

    if ( GEIio_isopen(l_file) && ((ufix16)GEIio_opentag(l_file) == LENGTH_OP(0)) ) {//@WIN
        if( GEIio_isedit(l_file) ) {
            GEIfbuf_t   FAR *l_fbuf ;

            /* RELEASE BUFFER */
            l_fbuf = l_file->f_fbuf ;
            l_fbuf->incount = 0 ;
            if( l_fbuf->size != 0 ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->size = 0 ;
            }
            l_fbuf->rw_buffer = MINUS_ONE ;
        } else
            GEIio_ioctl(l_file, _FIONRESET, (int FAR *)&l_arg) ;  /*@WIN add cast*/
    }

    if( ! ANY_ERROR() ) POP(1) ;

    return(0) ;
}   /* op_resetfile */
/*
**********************************************************************
*
*   This submodule implements the operator status.
*   Its operand and result objects on the operand stack are :
*       *file -status- bool
*   It returns true if the file is still valid, false otherwise.
*
*   Name:       op_status
*   Called:     interpreter
*   Calling:    check_fname
*               ?? ps_status
*               ?? sf_diskonline
**********************************************************************
*/
fix
op_status()
{
    bool    l_bool ;
    GEIFILE FAR *l_file ;

    if (TYPE_OP(0) == STRINGTYPE) {
#ifdef  SCSI
        /* ?? noy complete yet */
        if(LENGTH_OP(0) > F_MAXNAMELEN) {
            ERROR(LIMITCHECK) ;
            return(0) ;
        }

        ps_status(l_buffer) ;
        } else
#endif  /* SCSI */
        {
            CLEAR_ERROR() ;
            POP(1) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    } else {
        l_file = (GEIFILE FAR *)VALUE_OP(0) ;
        l_bool = TRUE ;

        if ( (! GEIio_isopen(l_file)) ||
             ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(0)) )  //@WIN
            l_bool = FALSE ;

        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* op_status */
/*
**********************************************************************
*
*   This submodule implements the operator run.
*   Its operand and result objects on the operand stack are :
*       string -run-
*   It executes the contents of the file identified by the string.
*
*   Name:       op_run
*   Called:     interpreter
*   Calling:    open_file
*               interpreter
**********************************************************************
*/
fix
op_run()
{
    struct  object_def  l_fobj ;

    byte        FAR *pp ;
    pp = (byte FAR *)VALUE_OP(0) ;
    if (!lstrcmp(pp, "%stdout") || !lstrcmp(pp, "%stderr")) {   /* @WIN */
        ERROR(INVALIDFILEACCESS);
        return(0) ;
    }

    g_mode[0] = 'r' ;
    g_mode[1] = 0 ;
    fs_info.attr = F_READ ;

    fs_info.fnameptr = (byte FAR *)VALUE_OP(0) ;
    fs_info.fnamelen = LENGTH_OP(0) ;

    if ( open_file(&l_fobj) ) {
        ACCESS_SET(&l_fobj, READONLY) ;
        ATTRIBUTE_SET(&l_fobj, EXECUTABLE) ;
        POP(1) ;
        interpreter(&l_fobj) ;
    }
    return(0) ;
}   /* op_run */
/*
**********************************************************************
*
*   This submodule implements the operator currentfile.
*   Its operand and result objects on the operand stack are :
*       -currentfile-  file
*   It return the topmost file object in the execution stack.
*
*   Name:       op_currentfile
*   Called:     interpreter
**********************************************************************
*/
fix
op_currentfile()
{
    fix     l_i ;

    if(FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    l_i = execstktop - 1 ;

    for(l_i = execstktop - 1 ; l_i >= 0 ; l_i--)
        if( TYPE(&execstack[l_i]) == FILETYPE ) {
            PUSH_ORIGLEVEL_OBJ(&execstack[l_i]) ;
            ATTRIBUTE_OP_SET(0, LITERAL) ;
            return(0) ;
        }
    PUSH_VALUE(FILETYPE, UNLIMITED, LITERAL, 0, NULL) ; /* ?? */
    return(0) ;
}   /* op_currentfile */
/*
**********************************************************************
*
*   This submodule implements the operator print.
*   Its operand and result objects on the operand stack are :
*       string -print-
*   It writes the characters of the string to the stardard output file.
*
*   Name:       op_print
*   Called:     interpreter
*   Calling:    port_out_string
**********************************************************************
*/
fix
op_print()
{
    if( ACCESS_OP(0) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    GEIio_write(GEIio_stdout, (byte FAR *)VALUE_OP(0), (fix)LENGTH_OP(0)) ;
    POP(1) ;

/*  if( GEIio_write(GEIio_stdout, (byte *)VALUE_OP(0), (fix)LENGTH_OP(0)) !=
                EOF )
        POP(1) ;
    else {
        GEIio_clearerr(GEIio_stdout) ;
        GEIclearerr() ;
    }
*/
    return(0) ;
}   /* op_print */
/*
**********************************************************************
*   Name:       op_echo
*   Called:     interpreter
**********************************************************************
*/
fix
op_echo()
{
    echo_setting = (bool8)VALUE_OP(0) ;
    POP(1) ;
    return(0) ;
}   /* op_echo */
/*
**********************************************************************
*
*   This submodule implements the operator eexec.
*   Its operand and result objects on the operand stack are :
*       string/file -eexec- any
*   This operator reads a block of code in eexec format from a string or
*   program input, decrypts the code to postscript then executes it.
*
*   Name:       op_eexec
*   Called:     interpreter
*   Calling:    interpreter
*               op_begin
*
*   ?? if reenter
**********************************************************************
*/
fix op_eexec()
{
    fix tmp ;
    GEIFILE FAR *l_file ;
    struct object_def s_obj ;
    struct object_def   dict_obj ;

    *(&dict_obj) = *(&dictstack[0]) ;
    PUSH_OBJ(&dict_obj) ;
    op_begin() ;
    if (ANY_ERROR())
        return(0) ;

    /*
    * initialization
    */
    eseed = 0xd971 ;
    old_eseed = eseed ;
    bypass = 4 ;
    itype = UNKNOWN ;

    COPY_OBJ(GET_OPERAND(0), &s_obj) ;
    if( TYPE_OP(0) == FILETYPE ) {
        if( (l_file=GEIio_dup((GEIFILE FAR *)VALUE_OP(0))) == NULL ) {

            /* ?? */
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIio_clearerr((GEIFILE FAR *)VALUE_OP(0)) ;
            GEIclearerr() ;
            return(0) ;
        } else {
            /* ?? file type */
            LENGTH(&s_obj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(&s_obj) = (ULONG_PTR)l_file ;
        }
    //}
    //DJC else is added from history.log UPD039
    } else {   /* Transfer string to file object; @WIN */
        struct object_def  FAR *cur_obj = GET_OPERAND(0);

        if((l_file=GEIio_sopen((char FAR *)cur_obj->value,
                               cur_obj->length, _O_RDONLY)) == NULL) {
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;
            GEIclearerr() ;
            return(0) ;
        } else {
            TYPE_SET(&s_obj, FILETYPE) ;
            ACCESS_SET(&s_obj, READONLY) ;
            ATTRIBUTE_SET(&s_obj, EXECUTABLE) ;
            LENGTH(&s_obj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(&s_obj) = (ULONG_PTR)l_file ;
        }
    }
    //DJC end fix from UPD039



    POP(1) ;
    ATTRIBUTE_SET(&s_obj, EXECUTABLE) ;
    estate = EEXEC ;

    tmp = interpreter(&s_obj) ;
    /* reset */
    estate = NON_EEXEC ;

    if( dictstack[dictstktop-1].value == dictstack[0].value )
        POP_DICT(1) ;
    return(0) ;
}   /* op_eexec */

/*
**********************************************************************
*
*   Name:       st_setstdio
*   Called:     interpreter
*   Calling:
*
*   ?? close original files
**********************************************************************
*/
fix
st_setstdio()
{
    return(0) ;
}   /* st_setstdio */
/*
**********************************************************************
*
*   This module is to initialize free link list of file buffer and
*   setup file descriptor table of upper level.
*
*   Name:       init_file
*   Called:     start
*   Calling     fardata
**********************************************************************
*/
void
init_file()
{
    fix     l_i, l_j;

    file_buffer = (struct file_buf_def far * )
        fardata( (ufix32)FILE_MAXBUFFERSZ * sizeof(struct file_buf_def) ) ;

    /*
    * initialize file spool
    */
    l_j = FILE_MAXBUFFERSZ - 1 ;
    fspool_head = 0 ;

    for(l_i=0 ; l_i < l_j ; l_i++)
        file_buffer[l_i].next = l_i + 1 ;

    file_buffer[l_j].next = MINUS_ONE ;         /* nil */
    echo_setting = TRUE ;
}   /* init_file */
/*
**********************************************************************
*   Name:       open_file
*   Called:     op_file
*               op_run
*   Calling:    check_fname
*               open_edit
*
*   Input:      struct object_def FAR *
*   Output:     bool
*
*   pass block: fs_info (know: attr, usrptr, usrlen)
**********************************************************************
*/
bool
open_file(p_fileobj)
struct object_def   FAR *p_fileobj ;
{
    fix     l_j ;
    bool    l_flag ;
    GEIFILE FAR *l_file = 0;

    check_fname() ;

    l_flag = TRUE ;
    l_j = fs_info.attr & F_WRITE ;           /* ?? RW */
    switch(fs_info.ftype) {
    case F_STDIN:
        if ( ! l_j )
            l_file = GEIio_stdin ;
        else
            l_j = -1 ;
        break ;

    case F_STDOUT:
        if ( l_j )
            l_file = GEIio_stdout ;
        else
            l_j = -1 ;
        break ;

    case F_STDERR:
        if ( l_j )
            l_file = GEIio_stderr ;
        else
            l_j = -1 ;
        break ;

    case FERR_TYPE:
        l_j = -1 ;
        break ;

    default:
        l_flag = FALSE ;

    }   /* switch */

    if(l_j == -1) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    TYPE_SET(p_fileobj, FILETYPE) ;
    ACCESS_SET(p_fileobj, UNLIMITED) ;
    LEVEL_SET(p_fileobj, current_save_level) ;  /* ?? std file need */

    if(l_flag) {
        /* ?? set savelevel */
/*
printf("open_file<%d>:lstdin<%lx>, stdin<%lx>\n", fs_info.ftype, l_file,
        GEIio_stdin) ;
*/
        LENGTH(p_fileobj) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(p_fileobj) = (ULONG_PTR)l_file ;
        return(TRUE) ;
    }

    switch(fs_info.ftype) {
    case SEDIT_TYPE:
    case LEDIT_TYPE:
        if( (g_editfile=GEIio_dup(GEIio_stdin)) == NULL ) {

            /* ?? */
            if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIclearerr() ;
            return(FALSE) ;
        }

        GEIio_setedit(g_editfile) ;
        GEIio_setsavelevel(g_editfile, current_save_level) ;
        LENGTH(p_fileobj) = ++GEIio_opentag(g_editfile) ;
        VALUE(p_fileobj) = (ULONG_PTR)g_editfile ;

        if( ! (l_flag=open_edit(p_fileobj)) ) {
            GEIio_close(g_editfile) ;
        }

        break ;

    case ORDFILE_TYPE:
        if( fs_info.attr & F_READ )
            l_flag = _O_RDONLY ;
        else
            l_flag = _O_WRONLY ;
        if( (l_file=GEIio_open(fs_info.fnameptr, fs_info.fnamelen, l_flag)) ==
            NULL ) {

            /* ?? */
            if( GEIerror() == EZERO )
                ERROR(UNDEFINEDFILENAME) ;
            else if( GEIerror() == EMFILE )
                ERROR(LIMITCHECK) ;
            else
                ERROR(IOERROR) ;

            GEIclearerr() ;
            return(FALSE) ;
        } else {
            /* ?? file type */
            LENGTH(p_fileobj) = ++GEIio_opentag(l_file) ;
            GEIio_setsavelevel(l_file, current_save_level) ;
            VALUE(p_fileobj) = (ULONG_PTR)l_file ;
            l_flag = TRUE ;
        }
        break ;

    default:
        /* ??
        ERROR(UNDEFINEDFILENAME) ;
        */
        return(FALSE) ;
    }
    return(l_flag) ;
}   /* open_file */
/*
**********************************************************************
*   Name:       open_edit
*   Called:     open_file
*   Calling:    set_echo
*               wait_editin
*               statementgetc
*               linegetc
*
*   Input:      struct object_def FAR *
*   Output:     bool
*
*   Note:   ^D: UNDEFINEDFILENAME immediately
*
**********************************************************************
*/
static bool near
open_edit(p_fileobj)
struct object_def   FAR *p_fileobj ;
{
    fix l_i, l_j, l_nbyte, l_first ;
    byte l_chr ;
    fix16  (FAR *fun)(void) ;           /* @WIN; add prototype */
    bool l_flag = FALSE;

    if (echo_setting)
        set_echo(1) ;                        /* set echo mode */

    /*
    * wait first line or statement
    */
    if (!wait_editin(&l_nbyte, fs_info.ftype)) {  /* ERROR */
        set_echo(0) ;
        /* ??
        if ( ! ANY_ERROR() )
            ERROR(UNDEFINEDFILENAME) ;
        */
        return(FALSE) ;
    } else if(l_nbyte == 0) {       /* ^D */
        set_echo(0) ;
        GEIio_clearerr(GEIio_stdin) ;
        GEIclearerr() ;
        ERROR(UNDEFINEDFILENAME) ;
        return(FALSE) ;
    }
    if (fs_info.ftype == SEDIT_TYPE)
        fun = statementgetc ;
    else
        fun = linegetc ;

    /* check interrupt ^C */
    /* ?? skip the input chars */
    if (check_Control_C()) {
        for (l_i = 0 ; l_i < l_nbyte ; l_i++)
            (*fun)() ;
        POP(2) ;
        set_echo(0) ;
        return(TRUE) ;
    }

    if( get_flbuffer(&l_j) ) {
        GEIfbuf_t       FAR *l_fbuf ;

        l_first = l_j ;              /* first block no */
        l_fbuf = g_editfile->f_fbuf ;
        l_fbuf->rw_buffer = (short)l_j ;
        l_fbuf->rw_offset = 0 ;
        l_fbuf->size = 0 ;
        l_flag = TRUE ;
        if (l_nbyte < 0)
            l_nbyte = -l_nbyte ;     /* ?? eof but must leave flag to next in */

        /* copy from cook buffer to file */
        for (l_j = 0 ; l_j < l_nbyte ; l_j++) {
            l_chr = (byte)((*fun)() & 0x0FF) ;
            if( ! write_fd(g_editfile, l_chr) ) {
                for (++l_j ; l_j < l_nbyte ; l_j++)
                    (*fun)() ;                   /* ?? timeout */
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                GEIio_setsavelevel(g_editfile, 0) ;
                ERROR(LIMITCHECK) ;
                l_flag = FALSE ;
                break ;              /* ?? */
            }
        }   /* for */

        if(l_flag) {
            l_fbuf->rw_buffer = (short)l_first ;
            l_fbuf->rw_offset = MINUS_ONE ;
        }
    } else {       /* No free file descriptor */
        /* skip the input chars */
        if (l_nbyte < 0)
            l_nbyte = -l_nbyte ;
        for (l_j = 0 ; l_j < l_nbyte ; l_j++)
            (*fun)() ;
        ERROR(LIMITCHECK) ;
    }
    set_echo(0) ;
    return(l_flag) ;
}   /* open_edit */
/*
**********************************************************************
*
*   This submodule is to close a openning file.
*
*   Name:       close_file
*   Called:     op_closefile
*   Calling:    close_fd
**********************************************************************
*/
bool
close_file(p_fobj)
struct  object_def  FAR *p_fobj ;
{
    if( close_fd((GEIFILE FAR *)VALUE(p_fobj)) )
        return(TRUE) ;
    else
        return(FALSE) ;
}   /* close_file */

/*
**********************************************************************
*
*   This submodule is to close a openning file.
*
*   Name:       close_fd
*   Called:
*   Calling:    close
*               ?? sf_isdiskonline
*
*   Input:      fix
*   Output:     bool
**********************************************************************
*/
bool
close_fd(p_file)
GEIFILE FAR *p_file ;
{
    fix16     l_bitmap ;

    if( GEIio_isedit(p_file) ) {
        GEIfbuf_t       FAR *l_fbuf ;

        /* RELEASE BUFFER */
        l_fbuf = p_file->f_fbuf ;
        if( (l_fbuf->size != 0 ) ||
            (l_fbuf->rw_buffer != MINUS_ONE) ) {
            free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
            l_fbuf->size = 0 ;
            l_fbuf->rw_buffer = MINUS_ONE ;
        }
        l_fbuf->incount = 0 ;
    }
    GEIio_setsavelevel(p_file, 0) ;
    GEIio_close(p_file) ;

    l_bitmap = 0 ;
    if( p_file == GEIio_stdin )
        l_bitmap = _FORCESTDIN ;
    else if( p_file == GEIio_stdout )
        l_bitmap = _FORCESTDOUT ;
    else if( p_file == GEIio_stderr )
        l_bitmap = _FORCESTDERR ;

    if( l_bitmap ) {
        GEIio_forceopenstdios(l_bitmap) ;
    }

    return(TRUE) ;
}   /* close_fd */
/*
**********************************************************************
*
*   Name:       read_file
*   Called:
*   Calling:    read_fd
*
*   Input:      struct object_def FAR *
*               byte *
*   Output:     bool
**********************************************************************
*/
bool
read_file(p_fobj, p_chr)
struct object_def  FAR *p_fobj ;
byte   FAR *p_chr ;
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE(p_fobj) ;
    if( read_fd(l_file, p_chr) )
       return(TRUE) ;
    else
       return(FALSE) ;
}   /* read_file */
/*
**********************************************************************
*
*   Name:       read_fd
*   Called:     read_file
*   Calling:    free_flbuffer
*               close_fd
*               create_string
*               strncpy
*               clearerr
*               fread
*               ?? sf_isdiskonline
*
*   Input:      GEIFILE *
*               byte *
*   Output:     bool
**********************************************************************
*/
bool
read_fd(p_file, p_chr)
GEIFILE     FAR *p_file ;
byte        FAR *p_chr ;
{
    struct object_def l_obj ;

    fix  l_block ;
    GEIfbuf_t FAR *l_fbuf ;

    if( GEIio_isedit(p_file) ) {
        l_fbuf = p_file->f_fbuf ;
/*
printf("read_fd:edit, inc<%d>, siz<%d>, off<%d>, buf<%d>\n",
        l_fbuf->incount, l_fbuf->size, l_fbuf->rw_offset,
        l_fbuf->rw_buffer) ;
*/
/*      if ( l_block=l_fbuf->incount ) { erik chen */
        if ((l_block=l_fbuf->incount) > 0) {
            l_fbuf->incount = --l_block ;
            *p_chr = l_fbuf->inchar[l_block] ;
            return(TRUE) ;
        }
        /*
        * in case of EOF
        */
        if (! l_fbuf->size) {
            if( l_fbuf->rw_buffer != MINUS_ONE ) {
                free_flbuffer(0, (fix)l_fbuf->rw_buffer) ;
                l_fbuf->rw_buffer = MINUS_ONE ;
            }
            l_fbuf->incount = 0 ;
            *p_chr = EOF ;
            return(FALSE) ;
        }
        /*
        * if end of this block, release this block and go to next one
        */
        if (l_fbuf->rw_offset >= (FILE_PERBUFFERSZ - 1)) {
           l_block = l_fbuf->rw_buffer ;
           l_fbuf->rw_buffer = file_buffer[l_block].next ;
           l_fbuf->rw_offset = MINUS_ONE ;
           free_flbuffer(1, l_block) ;
        }
        *p_chr = file_buffer[l_fbuf->rw_buffer].data[++(l_fbuf->rw_offset)] ;
        l_fbuf->size-- ;
        return(TRUE) ;
    } else
    {

//printf("before getc, file=%lx\n", p_file) ;

        *p_chr = GEIio_getc(p_file) ;

//printf("a:getc, ch<%d>eof<%d>err<%d>\n", *p_chr, GEIio_eof(p_file), GEIio_err(p_file)) ;
        //DJC UPD054
        // if( *p_chr == 0x03 || check_Control_C() ) {
        if( check_Control_C() ) {
            return(FALSE) ;
        }

        if( GEIio_eof(p_file) )
            return(FALSE) ;

        if( GEIio_err(p_file) ) {
            if( GEIerror() == ETIME ) {
                if ( FRCOUNT() < 1 )
                    ERROR(STACKOVERFLOW) ;
                else if ( create_string(&l_obj, (ufix16)7) ) {
                    lstrncpy((byte *)l_obj.value, TMOUT, 7) ;
                    PUSH_OBJ(&l_obj) ;
                }
            } else
                ERROR(IOERROR) ;

            return(FALSE) ;
        } else
            return(TRUE) ;
    }
}   /* read_fd */
/*
**********************************************************************
*
*   Name:       unread_file
*   Called:
*   Calling:    fseek
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      struct object_def FAR *
*   Output:     bool
**********************************************************************
*/
bool
unread_file(p_ch, p_fobj)
byte    p_ch ;
struct  object_def  FAR *p_fobj ;
{
    GEIFILE FAR *l_file ;

    l_file = (GEIFILE FAR *)VALUE(p_fobj) ;

    if( GEIio_isedit(l_file) ) {
        switch(l_file->f_fbuf->incount++) {
        case 0:
            l_file->f_fbuf->inchar[0] = p_ch ;
            break ;

        case 1:
            if( estate == EEXEC ) {
                l_file->f_fbuf->inchar[1] = p_ch ;
                break ;
            }

        /* FATAL ERROR */
        default:
            l_file->f_fbuf->incount = 0 ;
            return(FALSE) ;

        }   /* switch */
    } else
        GEIio_ungetc(p_ch, l_file) ;

    return(TRUE) ;
}   /* unread_file */
/*
**********************************************************************
*
*   Name:       write_fd
*   Called:     get_statement
*               get_lineedit
*   Calling:    get_flbuffer
*               write
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      fix
*               byte
*   Output:     bool
**********************************************************************
*/
static bool near
write_fd(p_file, p_chr)
GEIFILE FAR *p_file ;
byte    p_chr ;
{
    fix   l_block ;

    if( GEIio_isedit(p_file) ) {
        GEIfbuf_t       FAR *l_fbuf ;
        /*
        * if the current block is full, allocate a new one.
        */
        l_fbuf = p_file->f_fbuf ;
        if( l_fbuf->rw_offset >= FILE_PERBUFFERSZ ) {
            if( ! get_flbuffer(&l_block) )
                return(FALSE) ;
            file_buffer[l_fbuf->rw_buffer].next = (fix16)l_block ;
            l_fbuf->rw_offset = 0 ;
            l_fbuf->rw_buffer = (short)l_block ;
        }
        /*
        * put this character to buffer
        */
        file_buffer[p_file->f_fbuf->rw_buffer].data[p_file->f_fbuf->rw_offset] = p_chr ;
        p_file->f_fbuf->rw_offset++ ;
        p_file->f_fbuf->size++ ;
    } else
    {
        if( GEIio_putc(p_file, p_chr) == EOF ) {
            GEIio_clearerr(p_file) ;     /* ?? */
            GEIclearerr() ;              /* ?? */
            ERROR(IOERROR) ;
            return(FALSE) ;
        }
    }
    return(TRUE) ;
}   /* write_fd */
/*
**********************************************************************
*
*   This module is to get a file buffer, the buffer label
*   is stored in index.
*
*   Name:       get_flbuffer
*   Called:
*   Calling:    -
*
*   Input:      fix *
*   Output      bool
**********************************************************************
*/
static bool near
get_flbuffer(p_index)
fix   FAR *p_index ;
{
    fix   l_temp ;

    /* no available buffer */
    if( fspool_head == MINUS_ONE ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    l_temp = file_buffer[fspool_head].next ;
    file_buffer[fspool_head].next = MINUS_ONE ;
    *p_index = fspool_head ;
    fspool_head = (fix16)l_temp ;
    return(TRUE) ;
}   /* get_flbuffer */
/*
**********************************************************************
*
*   This module is to get a file buffer, the buffer label
*   is stored in index.
*
*   Name:       free_flbuffer
*   Called:     open_file
*               close_fd
*               read_fd
*   Calling:    -
*
*   Iutput:     fix
*               fix
*   Output:     bool
**********************************************************************
*/
static bool near
free_flbuffer(p_flag, p_begin)
fix   p_flag, p_begin ;
{
    fix     l_temp, l_end, l_current ;

    if( (p_begin < 0) || (p_begin >= FILE_MAXBUFFERSZ)  )
        return(FALSE) ;                 /* invalid index */

    l_temp = fspool_head ;
    fspool_head = (fix16)p_begin ;
    l_end = p_begin ;

    if(p_flag != 1) {                   /* release multi-block list */
        l_current = p_begin ;
        while( (l_current=file_buffer[l_current].next) != MINUS_ONE )
            l_end = l_current ;
    }
    file_buffer[l_end].next = (fix16)l_temp ;
    return(TRUE) ;
}   /* free_flbuffer */
/*
**********************************************************************
*
*   Name:       print_string
*   Called:     op_print
*   Calling:    port_out_string
*
*   Input:      byte *
*               ufix16
*   Output:     bool
**********************************************************************
*/
/*
bool
print_string(p_string, p_length)
byte   FAR *p_string ;
ufix16  p_length ;
{
    if( port_out_string(GEIio_stdout, p_string, p_length) ) {
        return(TRUE) ;
    } else {
        return(FALSE) ;
    }

}*/ /* print_string */
/*
**********************************************************************
*   Name:       check_fname
*   Called:
*   Calling:    strncmp
*               strlen
*               ?? sf_isdiskonline
*
*   Input:      byte *
*   Output:     bool
**********************************************************************
*/
static void near
check_fname()
{
    fix l_i, l_j ;
    byte FAR *l_tmptr ;

    fs_info.ftype = -1 ;

    if(*fs_info.fnameptr == '%') {
        /*
        * search special file table
        */
        for(l_i=0 ; l_i < SPECIALFILE_NO ; l_i++) {
            l_tmptr = special_file_table[l_i].name ;
            l_j = lstrlen(l_tmptr) ;    /* @WIN */
            if( (! lstrncmp(l_tmptr, fs_info.fnameptr, l_j)) &&
                (l_j == fs_info.fnamelen) ) {
                fs_info.ftype = special_file_table[l_i].ftype ;
                return ;
            }
        }
    }

    fs_info.ftype = ORDFILE_TYPE ;

    return ;
}   /* check_fname */
/*
**********************************************************************
*
*   Name:       wait_editin
*   Called:     open_file
*               get_statement
*   Calling:    getline
*               getstatement
*
*   Input:      fix16 *
*               fix16
*   Output:     bool
**********************************************************************
*/
static bool near
wait_editin(p_num, p_mode)
fix  FAR *p_num, p_mode ;
{
    bool   l_bool = FALSE ;

        switch(p_mode) {                        /* ?? need forever loop */
        case SEDIT_TYPE:
            l_bool = getstatement(p_num) ;
            break ;

        case LEDIT_TYPE:
            l_bool = getline(p_num) ;

        }   /* switch */
        /* check ^C postponed by caller */
        if (! l_bool || ANY_ERROR() )
            return(FALSE) ;
        else
            return(TRUE) ;
}   /* wait_editin */
/*
**********************************************************************
*
*   Name:       read_routine
*   Called:     op_readhexstring
*               op_readstring
*               op_readline
*   Calling:    read_char
*               close_fd
*               unread_file
*               fread
*               ?? sf_isdiskonline
*
*   Input:      fix
*
*   . ?? this routine's performace is not good because it read char
*        byte by byte
**********************************************************************
*/
static void near
read_routine(p_mode)
fix     p_mode ;
{
    bool    l_bool, l_pair ;
    byte    l_c1;
    byte    FAR *l_stream ;
    ufix16  l_i, l_strlen ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_strobj ;
    byte    l_c2 = 0;

    if( (ACCESS_OP(0) != UNLIMITED) ||
        (ACCESS_OP(1) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

    if(! LENGTH_OP(0)) {
        ERROR(RANGECHECK) ;
        return ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;       /* index of file descriptor */

    if ( ! GEIio_isreadable(l_file) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
    COPY_OBJ( GET_OPERAND(0), &l_strobj ) ;
    l_strlen = LENGTH(&l_strobj)  ;             /* ?? less than 64K - 16B */
    l_stream = (byte FAR *)VALUE(&l_strobj) ;
    l_bool = TRUE ;

    if( (! GEIio_isopen(l_file)) ||
        ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) { //@WIN
        l_bool = FALSE ;
        LENGTH(&l_strobj) = 0 ;
    } else {
        switch(p_mode) {
        case READHEXSTRING:
            l_pair = FALSE ;
            /*
            * reads characters in hexadecimal form until end of file or
            * the string is full.
            */
            if( (estate != EEXEC) && (!GEIio_isedit(l_file)) ) {
                byte    l_buf[READ_BUF_LEN] ;
                //DJC fix     l_total, l_nbyte, l_hexno ;
                fix     l_total, l_hexno ;       //DJC fix from SC
                fix32   l_nbyte;   //DJC fix from SC

                l_total = 0 ;
                for( ; ;) {
                    //DJC l_nbyte = l_strlen << 1 ;
                    l_nbyte = (fix32) l_strlen << 1 ; //DJC fix from SC
                    if( l_pair )
                        l_nbyte-- ;
                    l_nbyte = MIN(l_nbyte, READ_BUF_LEN) ;
                    //DJC l_nbyte = GEIio_read(l_file, l_buf, l_nbyte) ;
                    l_nbyte = GEIio_read(l_file, l_buf, (fix)l_nbyte) ; // DJC fix from SC
                    l_hexno = 0 ;
                    //DJC for(l_i=0 ; l_i < (ufix16)l_nbyte ; l_i++) { //@WIN
                    for(l_i=0 ;  (fix32) l_i < l_nbyte ; l_i++) { //@WIN
                        l_c1 = l_buf[l_i] ;
                        if( ISHEXDIGIT(l_c1) ) {
                            if( l_pair ) {
                                l_c1 = (byte)EVAL_HEXDIGIT(l_c1) + l_c2 ;//@WIN
                                *l_stream++ = l_c1 ;
                                l_hexno++ ;
                                l_pair = FALSE ;        /* even */
                            } else {
                                l_c2 = (byte)(EVAL_HEXDIGIT(l_c1) << 4);//@WIN
                                l_pair = TRUE ;         /* odd */
                            }
                        }
                    }   /* for */
                    l_total += l_hexno ;
                    if( l_nbyte == EOF ) {
                        /* ?? if pair is true */
                        LENGTH(&l_strobj) = (ufix16)l_total ;
                        close_fd(l_file) ;           /* ?? clear any error */
                        l_bool = FALSE ;
                        break ;
                    } else {
                        l_strlen -= (ufix16)l_hexno ;
                        if( l_strlen )
                            continue ;
                        else
                            break ;
                    }
                }   /* for( ; ;) */
            } else {
                for(l_i=0 ; l_i < l_strlen ; ) {
                    if( READ_CHAR(&l_c1, GET_OPERAND(1)) ) {
                        if( ISHEXDIGIT(l_c1) ) {
                            if( l_pair ) {
                                l_c1 = (byte)EVAL_HEXDIGIT(l_c1) + l_c2 ;//@WIN
                                *l_stream++ = l_c1 ;
                                l_i++ ;
                                l_pair = FALSE ;        /* even */
                            } else {
                                l_c2 = (byte)(EVAL_HEXDIGIT(l_c1) << 4);//@WIN
                                l_pair = TRUE ;         /* odd */
                            }
                        } else
                            continue ;
                    } else {
                        /* ?? if pair is true */
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;           /* ?? clear any error */
                        l_bool = FALSE ;
                        break ;
                    }
                }   /* for */
            }
            break ;

        case READSTRING:
            /*
            READ_CHAR(&l_c1, GET_OPERAND(1)) ;  |* skip one char *|
            */
            if( estate == EEXEC ) {
                for(l_i=0 ; l_i < l_strlen ; l_i++) {
                    if( read_c_exec(&l_c1, GET_OPERAND(1)) ) {
                        *l_stream++ = l_c1 ;
                    } else {
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;
                        l_bool = FALSE ;
                        break ;
                    }
                }   /* for */
            }
            else if( GEIio_isedit(l_file) ) {
                for(l_i=0 ; l_i < l_strlen ; l_i++) {
                    if( read_fd(l_file, &l_c1) ) {
                        *l_stream++ = l_c1 ;
                    } else {
                        LENGTH(&l_strobj) = l_i ;
                        close_fd(l_file) ;
                        l_bool = FALSE ;
                        break ;
                    }   /* for */
                }
            }
            else {
                int  cnt ;

                //DJCcnt = GEIio_read(l_file, l_stream, l_strlen) ;
                if ((cnt = GEIio_read(l_file, l_stream, l_strlen)) == EOF ) { //DJC fix from SC
                   cnt = 0;
                }
                if(cnt < (int)l_strlen) {       //@WIN
                    LENGTH(&l_strobj) = (fix16)cnt ;
                    close_fd(l_file) ;
                    GEIio_clearerr(l_file) ;
                    GEIclearerr() ;
                    l_bool = FALSE ;
                }
            }
            break ;

        case READLINE:
            l_c2 = TRUE ;
            for(l_i=0 ; l_i <= l_strlen ; l_i++) {
/*              if( READ_CHAR(&l_c1, GET_OPERAND(1)) ) { erik chen 3-26-1991 */
                if (((l_c1 = GEIio_getc(l_file)) != EOF) &&
                    (!GEIio_eof(l_file))) {
                    /*
                    * NL
                    */
/*                  if( l_c1 == NEWLINE ) { erik chen 5-2-1991 */
                    if( (l_c1 == 0x0a) || (l_c1 == 0x0d) ) {
                        if (l_c1 == 0x0d)
                            if (((l_c1 = GEIio_getc(l_file)) != EOF) &&
                                (!GEIio_eof(l_file)))
                                if (l_c1 != NEWLINE)
                                    unread_char(l_c1, GET_OPERAND(1)) ;
                        LENGTH(&l_strobj) = l_i ;
                        l_c2 = FALSE ;
                        break ;
                    }

                    if(l_i == l_strlen) {
                        unread_char(l_c1, GET_OPERAND(1)) ;
                        break ;
                    }
                    *l_stream++ = l_c1 ;
                } else {
                    /*
                    * EOF
                    */
                    LENGTH(&l_strobj) = l_i ;
                    close_fd(l_file) ;
                    GEIio_ioctl(l_file, _FIONRESET, (int FAR *)&l_i) ; /*@WIN add cast*/
                    l_bool = FALSE ;
                    l_c2 = FALSE ;
                    break ;
                }
            }   /* for */

            /* range check */
            if( l_c2 ) {
                ERROR(RANGECHECK) ;
                return ;
            }

        }   /* switch */
    }   /* else */

    POP(2) ;
    PUSH_ORIGLEVEL_OBJ(&l_strobj) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    return ;
}   /* read_routine */
/*
**********************************************************************
*
*   Name:       write_routine
*   Called:     op_writehexstring
*   Calling:    port_out_string
*               write_fd
*               fwrite
*               clearerr
*               ?? sf_isdiskonline
*
*   Input:      fix
**********************************************************************
*/
static void near
write_routine(p_mode)
fix     p_mode ;
{
    ubyte   l_c1, l_c2 ;
    byte    FAR *l_stream ;
    ufix16  l_i, l_strlen ;
    GEIFILE FAR *l_file ;
    struct  object_def  l_strobj ;

    if( (ACCESS_OP(0) >= EXECUTEONLY) ||
        (ACCESS_OP(1) != UNLIMITED) ) {
        ERROR(INVALIDACCESS) ;
        return ;
    }

    l_file = (GEIFILE FAR *)VALUE_OP(1) ;       /* index of file descriptor */

    if ( (! GEIio_iswriteable(l_file)) ||
         (! GEIio_isopen(l_file)) ||
         ((ufix16)GEIio_opentag(l_file) != LENGTH_OP(1)) ) {    //@WIN
        ERROR(INVALIDACCESS) ;
        return ;
    }

    COPY_OBJ( GET_OPERAND(0), &l_strobj ) ;
    l_strlen = LENGTH(&l_strobj) ;          /* ?? less than 64K - 16B */
    if(l_strlen == 0)
        goto wr_1 ;

    l_stream = (byte FAR *)VALUE(&l_strobj) ;

    switch(p_mode) {

    case WRITEHEXSTRING:
        for(l_i=0 ; l_i < l_strlen ; l_i++) {
            l_c1 = *l_stream++ ;
            l_c2 = (l_c1 & (ubyte)0x0f) ;       //@WIN
            EVAL_ASCII(l_c2) ;
            l_c1 >>= 4 ;
            EVAL_ASCII(l_c1) ;
            if( (! write_fd(l_file, l_c1)) || (! write_fd(l_file, l_c2)) )
                return ;
        }   /* for */
        break ;

    case WRITESTRING:
        GEIio_write(l_file, l_stream, l_strlen) ;
/*      if( GEIio_write(l_file, l_stream, l_strlen) == EOF ) {
            GEIio_clearerr(l_file) ;
            GEIclearerr() ;
            ERROR(IOERROR) ;
            return ;
        } */
    }   /* switch */

wr_1:
    POP(2) ;
    return ;
}   /* write_routine */
/*
**********************************************************************
*   Name:       vm_close_file
*   Called:
*   Calling:    close_fd
*
*   Input:      fix16
**********************************************************************
*/
void
vm_close_file(p_level)
fix16   p_level ;
{
/*  GEIFILE *l_file ;

    l_file = GEIio_firstopen() ;

    while( l_file != NULL ) {
        if( GEIio_savelevel(l_file) >= p_level )
            close_fd(l_file) ;
        l_file = GEIio_nextopen() ;
    } */
}   /* vm_close_file */
#ifdef  SCSI
/*
**********************************************************************
*   Name:       op_deletefile
*   Called:     interpreter
*   Calling:    check_fname
*               remove
**********************************************************************
*/
fix
op_deletefile()
{
    if(LENGTH_OP(0) > F_MAXNAMELEN) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    if ( ! remove((byte *)VALUE_OP(0), (fix)LENGTH_OP(0)) )
        POP(1) ;
                                        /* ?? NULL means still open */
        return(0) ;
    }
    ERROR(UNDEFINEDFILENAME) ;           /* ?? ioerror */
    return(0) ;
}   /* op_deletefile */
/*
**********************************************************************
*   Name:       op_renamefile
*   Called:     interpreter
*   Calling:    check_fname
*               rename
**********************************************************************
*/
fix
op_renamefile()
{
    byte    l_old[F_MAXNAMELEN+1], l_new[F_MAXNAMELEN+1] ;


    if(LENGTH_OP(0) > F_MAXNAMELEN) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    /* new filename length > 0? */
    if(LENGTH_OP(0) <= 0) {
        ERROR(UNDEFINEDFILENAME) ;
        return(0) ;
    }

    if ( ! rename((byte FAR *)VALUE_OP(1), (fix)LENGTH_OP(1),
                  (byte FAR *)VALUE_OP(0), (fix)LENGTH_OP(0)) ) {
        POP(2) ;
        return(0) ;
    }
    ERROR(UNDEFINEDFILENAME) ;           /* ?? ioerror */
    return(0) ;
}   /* op_renamefile */
/*
**********************************************************************
*   Name:       op_filenameforall
*   Called:     interpreter
*   Calling:    check_fname
**********************************************************************
*|
fix
op_filenameforall()
{
    byte    l_buf[F_MAXNAMELEN+1] ;
    fix     l_len ;

    if( check_name(l_buf, (byte FAR *)VALUE_OP(2), (fix16)LENGTH_OP(2)) ) {
        if (*(byte FAR *)VALUE_OP(2) == '%') {
            l_len = file_table[F_DEF_KIND].chr_num ;
        } else {
            l_len = 0 ;
        }
        ps_filenameforall(file_table[F_DEF_KIND].fname, l_len, l_buf) ;
    }
    return(0) ;

}   |* op_filenameforall *|
*/
#endif  /* SCSI */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\ic_cfg.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ******************************************************************************
 *
 * FILE: ic_cfg.h
 *
 * HISTORY:
 ******************************************************************************
 */
/*
 *      Platform Configuration Structure
 */
struct ps_config
{
    unsigned int    FAR *PsMemoryPtr ;
    long int        PsMemorySize ;                      /* @WIN */
    int             PsDPIx ;
    int             PsDPIy ;
} ;

/*
 *      Imaging Component Error Return Codes
 */
#define PS_CONFIG_MALLOC        -1
#define PS_CONFIG_MPLANES       -2
#define PS_CONFIG_MWPP          -3
#define PS_CONFIG_DPI           -4
#define PS_FATAL_UNKNOWN        -11

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\matherr.h ===
/* Copyright 1989 Interleaf, Inc.       */
/*
 * matherr.h
 */
/*
 * matherr_handler() actions
 */
#define MEH_CLEAR   0
#define MEH_STATUS  -1

/*
 * arithmetic error conditions
 */
#define MEH_ZERODIVIDE  0x0001
#define MEH_INFINITY    0x0002
#define MEH_UNDERFLOW   0x0004
#define MEH_DOMAIN      0x0008
#define MEH_SING        0x0010
#define MEH_OVERFLOW    0x0020
#define MEH_TLOSS       0x0040
#define MEH_PLOSS       0x0080

extern fix sigFPE() ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\matherr.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"
#include "matherr.h"
#include "stdio.h"      /* to define printf() @WIN */

/*
 * Floating point exception conditions and arithmetic error conditions.
 * This flag represents the most recent condtions. Caller must clear
 * this flag by calling matherr_handler(MEH_CLEAR) before executing the
 * arithmetic operation. Then check for status via matherr_handler(MEH_STATUS).
 */
static fix matherr_cond ;

/*
 * Process the matherr_cond flag.
 */
fix
matherr_handler(action)
char action ;
{
    switch (action) {
    case MEH_CLEAR:
        matherr_cond = 0 ;
        break ;

    case MEH_STATUS:
        return(0); /* Until we get this figured out */

    default:
        printf("Error: matherr_handler() unkown action %d.\n", action) ;
        printf("PDL interpreter error... exiting\n") ;
        while(1) ;
    }

    return(0);

}   /* matherr_handler */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\init1pp.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              INIT1PP.H
 *      Author:                 CC Teng
 *      Date:                   11/21/89
 *      Owner:                  Microsoft Co.
 *      Description: this file was part of the old "global.def",
 *                   and it is only for statusdict and 1pp dicts
 *                   initialization in "user.c"
 * revision history: 2/12/90 ccteng move combine systemdict_table and
 *                      statusdict_table, then move them to dict_tab.c
 *      7/13/90 ; ccteng ; add PSPrep, delete some constant definitions
 *      7/21/90 ; ccteng ; 1)keep adding stuff in PSPrep which was in
 *                         dict_tab.c and init1pp.c
 *                       2)delete following serverdict stuff for server
 *                         change: se_stdin, STDIN_N, STDINNAME
 *      7/25/90 ; ccteng ; add startpage in serverdict (PSPrep)
 *      9/14/90 ; ccteng ; remove ALL_VM flag
 *      11/30/90  Danny  Add id_stdfont entries for 35 fonts (ref F35:)
 *      12/06/90  Danny  Change the precache & idle font array for lack
 *                       of font data -- Helvetica, Helvetica-Bold,
 *                       Times-Roman, Times-Bold.  (ref. FT19)
 *      12/17/90  Danny  CacheString is error by inserting a space (No this
 *                       error before the  12/06/90 release)
 *      03/27/91  Kason  Delete FT19 flag
 *      5/8/91    scchen Adjust page size(pr_arrays[])
 *      5/21/91   Kason  Add the option that can accept "TrueType PostScript
 *                       font Format" [ open (define) DLF42 flag ]
 ************************************************************************
 */
#define DLF42    /* feature for TrueType PostScript Font Format */
/*
 *  PSPrep
 */
#ifdef  _AM29K
const
#endif

#ifndef DLF42
byte FAR PSPrep[] = "\
systemdict begin\
/version{statusdict/versiondict get/Core get}bind def\
/=string 128 string def\
 end\
 statusdict begin\
/revision{statusdict/versiondict get/r_Core get}bind def\
/jobsource 64 string def\
/jobstate 64 string def\
/jobname 64 string def\
/manualfeed false def\
/eerom false def\
/printerstatus 8 def\
/lettertray{userdict/letter get exec}def\
/legaltray{userdict/legal get exec}def\
/a4tray{userdict/a4 get exec}def\
/b5tray{userdict/b5 get exec}def\
 end\
 userdict begin\
/startpage 0 string readonly def\
 end\
 printerdict begin\
/defspotfunc{abs exch abs 2 copy add 1 gt{1 sub dup mul exch 1 sub dup mul add\
 1 sub}{dup mul exch dup mul add 1 exch sub}ifelse}readonly def\
 end\
 serverdict begin\
/startpage{userdict/startpage get cvx exec showpage}readonly def\
 end" ;

#else /* set /type42known true in userdict */

byte FAR PSPrep[] = "\
systemdict begin\
/version{statusdict/versiondict get/Core get}bind def\
/=string 128 string def\
 end\
 statusdict begin\
/revision{statusdict/versiondict get/r_Core get}bind def\
/jobsource 64 string def\
/jobstate 64 string def\
/jobname 64 string def\
/manualfeed false def\
/eerom false def\
/printerstatus 8 def\
/lettertray{userdict/letter get exec}def\
/legaltray{userdict/legal get exec}def\
/a4tray{userdict/a4 get exec}def\
/b5tray{userdict/b5 get exec}def\
 end\
 userdict begin\
/startpage 0 string readonly def\
/type42known false def\
 end\
 printerdict begin\
/defspotfunc{abs exch abs 2 copy add 1 gt{1 sub dup mul exch 1 sub dup mul add\
 1 sub}{dup mul exch dup mul add 1 exch sub}ifelse}readonly def\
 end\
 serverdict begin\
/startpage{userdict/startpage get cvx exec showpage}readonly def\
 end" ;

#endif /*DLF42*/

/*
 ***********************************************************
 *  define the $printerdict arrays
 ***********************************************************
 */
/* different paper size name */
static byte FAR * far   pr_paper[] = {
                        "letter",
                        "lettersmall",
                        "a4",
                        "a4small",
                        "b5",
                        "note",
                        "legal"
} ;

#define     PAPER_N        (sizeof(pr_paper) / sizeof(byte FAR *))  /* @WIN */

/* arrays for different paper size */
fix16  FAR  pr_arrays[][6] = {
#ifdef _AM29K
 /* letter */           {   0,   0, 304, 3181,  59,  60},     /*  32}, */
 /* lettersmall */      {   0,   0, 288, 3048, 128, 126},     /* 126}, */
 /* a4 */               {   0,   0, 294, 3390,  54,  59},     /*  38}, */
 /* a4small */          {   0,   0, 282, 3255, 110, 126},     /* 126}, */
 /* b5 */               {   0,   0, 250, 2918,  86,  51},     /*  38}, */
 /* note */             {   0,   0, 288, 3048, 128, 126},     /* 126}, */
 /* legal */            {   0,  12, 304, 4081,  59,  60}      /*  32}  */
#else
#ifdef  DUMBO
 /* letter */           {  87, 105, 284, 3150,  59,  32},
 /* lettersmall */      { 169, 170, 288, 3048, 128, 126},
 /* a4 */               {  85, 138, 294, 3432,  54,  38},
 /* a4small */          { 173, 199, 282, 3255, 110, 126},
 /* b5 */               {  99, 325, 250, 2944,  86,  38},
 /* note */             { 169, 170, 288, 3048, 128, 126},
 /* legal */            {  87, 105, 304, 4136,  59,  32}
 /* legalsmall          { 234, 306, 252, 3852, 267, 174} */
#else
 /* letter */           {  87, 105, 304, 3236,  59,  32},
 /* lettersmall */      { 169, 170, 288, 3048, 128, 126},
 /* a4 */               {  85, 138, 294, 3432,  54,  38},
 /* a4small */          { 173, 199, 282, 3255, 110, 126},
 /* b5 */               {  99, 325, 250, 2944,  86,  38},
 /* note */             { 169, 170, 288, 3048, 128, 126},
 //DJC /* legal */            {  87, 105, 304, 4136,  59,  32}
 /* legal */            {  87, 105, 304, 4090,  59,  32}

 /* legalsmall          { 234, 306, 252, 3852, 267, 174} */
#endif
#endif
} ;

/* "matrix" in $printerdict */
static fix    FAR  pr_mtx[] = { 0, 0, 0, 0, 0, 0 } ;

/* "defaultmatrix" in $printerdict */
static fix    FAR  pr_defmtx[] = { /* resolution/ */ 72, 0, 0,/* \ */ /*
kevina4.13.90: commented backslash */
                                    /* resolution/ */ -72, -59, 3268 } ;

/*
 ***********************************************************
 *  define the $idleTimeDict arrays: "stdfont" and "cachearray"
 ***********************************************************
 */
#define             CACHESTRING     "abcdefghijklmnopqrstuvwxyzABCDEFGHIJK\
LMNOPQRSTUVWXYZ0123456789.,;?:-()\'\"!+[]$%&*/_=@#`{}<>^~|\\"  /* 94 chars */

#ifdef  _AM29K
const
#endif
static byte FAR * FAR  id_stdfont[] = {
        /*  0 */        "Courier",
        /*  1 */        "Courier-Bold",
        /*  2 */        "Courier-Oblique",
        /*  3 */        "Courier-BoldOblique",
        /*  4 */        "Times-Roman",
        /*  5 */        "Times-Bold",
        /*  6 */        "Times-Italic",
        /*  7 */        "Times-BoldItalic",
        /*  8 */        "Helvetica",
        /*  9 */        "Helvetica-Bold",
        /* 10 */        "Helvetica-Oblique",
        /* 11 */        "Helvetica-BoldOblique",
        /* 12 */        "Symbol",
/* F35: Begin, Danny, 11/30/90 */
/* Added for 35 fonts */
        /* 13 */        "AvantGarde-Book",
        /* 14 */        "AvantGarde-BookOblique",
        /* 15 */        "AvantGarde-Demi",
        /* 16 */        "AvantGarde-DemiOblique",
        /* 17 */        "Bookman-Demi",
        /* 18 */        "Bookman-DemiItalic",
        /* 19 */        "Bookman-Light",
        /* 20 */        "Bookman-LightItalic",
        /* 21 */        "Helvetica-Narrow",
        /* 22 */        "Helvetica-Narrow-Bold",
        /* 23 */        "Helvetica-Narrow-BoldOblique",
        /* 24 */        "Helvetica-Narrow-Oblique",
        /* 25 */        "NewCenturySchlbk-Roman",
        /* 26 */        "NewCenturySchlbk-Bold",
        /* 27 */        "NewCenturySchlbk-Italic",
        /* 28 */        "NewCenturySchlbk-BoldItalic",
        /* 29 */        "Palatino-Roman",
        /* 30 */        "Palatino-Bold",
        /* 31 */        "Palatino-Italic",
        /* 32 */        "Palatino-BoldItalic",
        /* 33 */        "ZapfChancery-MediumItalic",
        /* 34 */        "ZapfDingbats"
/* F35: End, Danny, 11/30/90 */
} ;

#ifdef  _AM29K
const
#endif
static fix16  FAR  id_cachearray[][6] = {
 /* font, x-scale, y-scale, rotate, 1st-cachestring, last-cachestring */
 /* Helvetica */        { 8, 10, 10, 0, 0, 81},
                        { 8, 14, 14, 0, 0, 81},
 /* Times-Roman */      { 4, 14, 14, 0, 0, 81},
 /* Helvetica-Bold */   { 9, 12, 12, 0, 0, 26},
 /* Times-Bold */       { 5, 12, 12, 0, 0, 26},
                        { 9, 10, 10, 0, 0, 26},
                        { 5, 10, 10, 0, 0, 26},
 /* Courier-Bold */     { 1, 10, 10, 0, 0, 26},
                        { 9, 14, 14, 0, 0, 26},
                        { 5, 14, 14, 0, 0, 26}
};

/*
 ***********************************************************
 *  define the pre-cache data
 ***********************************************************
 */

#ifdef  _AM29K
const
#endif
static fix16  FAR  pre_array[] = {
    /*           Font Name   Sx   Sy   Ra  nchars */
    /* Courier */        0,  10,  10,  0,    94,
    /* Times-Roman */    4,  10,  10,  0,    81,
    /* Helvetica */      8,  12,  12,  0,    81,
    /* Times-Roman */    4,  12,  12,  0,    81
    /* Times-Roman */ /*,4,  12,  12,  0,    01 */  /* debug */
};

#define     PRE_CACHE_N    ((sizeof(pre_array) / sizeof(fix16)) / 5)
/* F35: Begin, Danny, 11/30/90 */
//DJC #define     STD_FONT_N     35
#define     IDL_FONT_N     10
/* F35: End, Danny, 11/30/90 */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\operand.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              OPERAND.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/***********************************************************************
**
** This submodule implements the operator pop.
** Its operand and result objects are :
**     any -pop-
** It pop an object off the operand stack.
**
** TITLE:       op_pop              Date:   00/00/87
** CALL:        op_pop()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_pop()
{
    POP(1) ;

    return(0) ;
}   /* op_pop */

/***********************************************************************
**
** This submodule implements the operator exch.
** Its operand and result objects are :
**     any1 any2 -exch- any2 any1
** It exchanges the two most top object on the operand stack.
**
** TITLE:       op_exch             Date:   00/00/87
** CALL:        op_exch()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_exch()
{
    struct  object_def  l_temp ;

    COPY_OBJ(GET_OPERAND(0),&l_temp) ;
    COPY_OBJ(GET_OPERAND(1),GET_OPERAND(0)) ;
    COPY_OBJ(&l_temp,GET_OPERAND(1)) ;

    return(0) ;
}   /* op_exch */

/***********************************************************************
**
** This submodule implements the operator dup.
** Its operand and result objects are :
**     any  -dup-any
** It duplicates the topmost object on the operand stack.
**
** TITLE:       op_dup              Date:   00/00/87
** CALL:        op_dup()            UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
***********************************************************************/
fix
op_dup()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        PUSH_NOLEVEL_OBJ( GET_OPERAND(0) ) ;

    return(0) ;
}   /* op_dup */

/***********************************************************************
**
** This submodule implements the operator copy.
** Its operand and result objects are :
**     any1 .... anyn n -copy- any1 .... anyn any1 .... anyn
** If the top element on the operand stack is a non-negative integer n, it
** pops the integer object and deplicates the top n elements.
** If the top two elements on the operand stack is dictionaries,arrays or
** strings, it copies all the elements of the first object to the secondary
** object. In the case of arrays or strings, the length of the second object
** must be at least as great as first.
**
** TITLE:       op_copy                         Date:   00/00/87
** CALL:        op_copy()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
**              putinterval_array:
**              copy_dict:
**              putinterval_string:
***********************************************************************/
fix
op_copy(p_count)
fix     p_count ;
{
    ufix32  l_count, l_i, l_j ;
    struct  object_def  l_save ;

    /* duplicate the topmost n objects on the operand stack. */
    if (p_count == 1) {         /* operand copy */

       l_count = (ufix32)VALUE_OP(0) ;
       if (((fix32)l_count < 0) || (l_count > (ufix32)MAXDICTCAPSZ))
          ERROR(RANGECHECK) ;
       else if ((ufix32)COUNT() < (l_count + 1))
          ERROR(STACKUNDERFLOW) ;
       else if (l_count) {
          l_j = l_count - 1 ;
          if ((ufix32)FRCOUNT() < l_j) {
             POP(1) ;
             ERROR(STACKOVERFLOW) ;
          } else {
             POP(1) ;
             l_i = 0 ;
             while (l_i++ < l_count)
                   PUSH_ORIGLEVEL_OBJ(GET_OPERAND(l_j)) ;
          }
       } else {
          POP(1) ;
       }
       return(0) ;
    } else {
       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       switch(TYPE_OP(0)) {
       case DICTIONARYTYPE:
            copy_dict(GET_OPERAND(1), &l_save) ;
            break ;

       case STRINGTYPE:
            case ARRAYTYPE:
            case PACKEDARRAYTYPE:       /* ?? pack <-> array */
            /* check access right */
            if ((ACCESS_OP(1) >= EXECUTEONLY) || (ACCESS_OP(0) != UNLIMITED)) {
               ERROR(INVALIDACCESS) ;
               return(0) ;
            }

            /* copy characters in the first string to the second string. */
            if (TYPE_OP(0) == STRINGTYPE)
               putinterval_string(&l_save, 0, GET_OPERAND(1)) ;
            /* copy elements in the first array to the secornd array. */
            else
               putinterval_array(&l_save, 0, GET_OPERAND(1)) ;

            if (TYPE_OP(1) != PACKEDARRAYTYPE) {
                LENGTH(&l_save) = LENGTH_OP(1) ;
            }
       } /* switch */
    }

    if (!ANY_ERROR()) {
       POP(2) ;
       PUSH_ORIGLEVEL_OBJ(&l_save) ;
    }

    return(0) ;
}   /* op_copy() */

/***********************************************************************
**
** This submodule implements the operator index.
** Its operand and result objects are :
**     anyn .... any0 n -index- anyn
** This operator removes the non-negative integer n object from the operand
** stack, counts down to the nth element from the top of the  stack, and push
** a copy of that element on the stack.
**
** TITLE:       op_index                        Date:   00/00/87
** CALL:        op_index()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       create_new_saveobj:
***********************************************************************/
fix
op_index()
{
    fix   l_index ;

    l_index = (fix)VALUE_OP(0) ;

    if( ((fix)COUNT()-1 <= l_index) || (l_index < 0) )  //@WIN
        ERROR(RANGECHECK) ;

    else {
        /* pop the object of the operand stack */
        POP(1) ;
        /* push the nth object */
        PUSH_ORIGLEVEL_OBJ(GET_OPERAND(l_index)) ;
    }

    return(0) ;
}   /* op_index */

/***********************************************************************
**
** This submodule implements the operator roll.
** Its operand and result objects are :
**   any1 .. anyn n j -roll- any((j-1) mod n) .. any0 any(n-1) .. any(j mod n)
** This operator performs a circular shift of the top n object on the operand
** stack by amount j. Positive j indicates upward modtion on the stack whichas
** negative j indicates downward motion. n must be a non-negative integer and
** j must be an integer.
**
** TITLE:       op_roll             Date:   00/00/87
** CALL:        op_roll()           UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_roll()
{
    fix     l_n, l_j, l_i, l_to, l_from, l_saveindex ;
    struct  object_def  l_saveobj ;

    l_n = (fix)VALUE_OP(1) ;

    if( l_n < 0 ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    if( VALUE_OP(0) == 0 ) {
        POP(2) ;
        return(0) ;
    }

    if( l_n > (fix)COUNT() - 2 ) {              //@WIN
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( (l_n == 0) || (l_n == 1) ) {
        POP(2) ;
        return(0) ;
    }

    l_j = (fix) ((fix32)VALUE_OP(0) % l_n) ;

    POP(2) ;

    if( l_j == 0 ) return(0) ;

    /*
    ** compute the corresponding positive value of l_j,
    ** if l_j is negative
    */
    if( l_j < 0 ) l_j  += l_n  ;

    /* ROLL */
    l_saveindex = l_n - l_j ;
    COPY_OBJ( GET_OPERAND(l_saveindex), &l_saveobj ) ;
    l_to = l_saveindex ;

    for(l_i = 1 ; l_i <= l_n ; l_i++) {
        l_from = (l_to + l_j) % l_n ;
        /*
        ** this may occur when mod(l_n, l_i) = 0
        */
        if(l_from == l_saveindex) {
            COPY_OBJ( &l_saveobj, GET_OPERAND(l_to) ) ;

            if(l_i < l_n) {
                l_saveindex++ ;
                COPY_OBJ( GET_OPERAND(l_saveindex), &l_saveobj ) ;
                l_to = l_saveindex ;
            }
            continue ;
        }

        COPY_OBJ( GET_OPERAND(l_from), GET_OPERAND(l_to) ) ;
        l_to = l_from ;
    }

    return(0) ;
}   /* op_roll */

/***********************************************************************
**
** This submodule implements the operator clear.
** Its operand and result objects are :
**     < any1 .... anyn -clear- <
** This operator removes all the elements on the operand stack.
**
** TITLE:       op_clear            Date:   00/00/87
** CALL:        op_clear()          UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_clear()
{
    opnstktop = 0 ;
    opnstkptr = opnstack;                       /* qqq */

    return(0) ;
}   /* op_clear */

/***********************************************************************
**
** This submodule implements the operator count.
** Its operand and result objects are :
**     any1 .... anyn -count- any1 .... anyn n
** This operator count the elements on the operand stack and
** push this count on the operand stack.
**
** TITLE:       op_count                        Date:   00/00/87
** CALL:        op_count()                      UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_count()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        /* push the count object */
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)COUNT()) ;

    return(0) ;
}   /* op_count */

/***********************************************************************
**
** This submodule implements the operator mark.
** Its operand and result objects are :
**      -copy- mark
** This operator pushes a mark object on the operand stack.
**
** TITLE:       op_mark                         Date:   00/00/87
** CALL:        op_mark()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_mark()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        /* push the mark object */
        PUSH_VALUE(MARKTYPE, 0, LITERAL, 0, (ufix32)LEFTMARK) ;

    return(0) ;
}   /* op_mark */

/***********************************************************************
**
** This submodule implements the operator cleartomark.
** Its operand and result objects are :
**     mark any1 .... anyn -cleartomark-
** This operator pops the operand stack repeatedly util it encounters a mark.
**
** TITLE:       op_cleartomark      Date:   00/00/87
** CALL:        op_cleartomark()    UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_cleartomark()
{
    ufix16      l_i, l_number ;

    /* search the first mark object from top */
    l_i = 0 ;
    l_number = COUNT() ;

    while( l_i < l_number ) {
        if( TYPE_OP(l_i) == MARKTYPE ) {
            /* find the first mark object */
            /* removes all the more top obejcts than mark */
            POP(l_i+1) ;
            return(0) ;
        } else
            l_i++ ;                     /* search next */
    }   /* while */

    /* cannot find a mark object on the operand stack */
    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_cleartomark */

/***********************************************************************
**
** This submodule implements the operator countomark.
** Its operand and result objects are :
**     mark any1 .... anyn -counttomark- mark any1 .... anyn n
** This operator counts the elements from top element dowm to the first mark
** object on the operand stack.
**
** TITLE:       op_counttomark                  Date:   00/00/87
** CALL:        op_counttomark()                UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_counttomark()
{
    ufix16  l_i, l_number ;

    /* count the objects above the first mark on the operand stack */
    l_i = 0 ;
    l_number = COUNT() ;

    while( l_i < l_number ) {

        if( TYPE_OP(l_i) == MARKTYPE ) {

            if( FRCOUNT() < 1 )             /* find the first mark */
                ERROR(STACKOVERFLOW) ;
            else                            /* push the count object */
                PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, l_i) ;
            return(0) ;
        } else
            l_i++ ;
    }
    /* cannot find a mark object */
    ERROR(UNMATCHEDMARK) ;

    return(0) ;
}   /* op_counttomark */

/***********************************************************************
**
** TITLE:       init_operand                    Date:   08/01/87
** CALL:        init_operand()                  UpDate: Jul/12/88
** INTERFACE:   start:
***********************************************************************/
void
init_operand()
{
    opnstktop = 0 ;
    opnstkptr = opnstack;                       /* qqq */

    return ;
}   /* init_operand */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\language.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              LANGUAGE.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#ifndef NULL
#define     NULL            0
#endif

#define     NULL_OBJ        0L
#define     MINUS_ONE       -1

#define     MARK            0
#define     LEFTMARK        MARK

/******************
 |  TIMER SET     |
 ******************/
#define     JOB_INDEX       0
#define     WAIT_INDEX      1
#define     MANU_INDEX      2
#define     JOB_MODE        0x01
#define     WAIT_MODE       0x02
#define     MANU_MODE       0x04
#define     ALL_MODE        0x07
#define     START_MODE      0x08

/**********************
 |  MACRO DEFINITION  |
 **********************/
#define     SPECIAL_KEY_VALUE\
            (MAXHASHSZ)

/* qqq, begin */
/*
#define     TYPE_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & TYPE_OFF) |\
              (var & TYPE_ON) )
#define     ATTRIBUTE_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ATTRIBUTE_OFF) |\
              ((ufix16)((var & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) )
#define     ROM_RAM_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ROM_RAM_OFF) |\
              ((var & ROM_RAM_ON) << ROM_RAM_BIT) )
#define     LEVEL_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & LEVEL_OFF) |\
              ((var & LEVEL_ON) << LEVEL_BIT) )
#define     ACCESS_OP_SET(idx, var)\
            ( opnstack[opnstktop - (idx+1)].bitfield =\
              (opnstack[opnstktop - (idx+1)].bitfield & ACCESS_OFF) |\
              ((var & ACCESS_ON) << ACCESS_BIT) )

#define     TYPE_OP(idx)\
            ( opnstack[opnstktop - (idx+1)].bitfield & TYPE_ON )
#define     ATTRIBUTE_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ATTRIBUTE_BIT) & ATTRIBUTE_ON )
#define     ROM_RAM_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ROM_RAM_BIT) & ROM_RAM_ON )
#define     LEVEL_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> LEVEL_BIT) & LEVEL_ON )
#define     ACCESS_OP(idx)\
            ( (opnstack[opnstktop - (idx+1)].bitfield >> ACCESS_BIT) & ACCESS_ON )

#define     VALUE_OP(n)\
            ( opnstack[opnstktop - (n + 1)].value )
#define     LENGTH_OP(n)\
            ( opnstack[opnstktop - (n + 1)].length )

#define     PUSH_NOLEVEL_OBJ(obj)\
            {\
              opnstack[opnstktop] = *(obj) ;\
              opnstktop++ ;\
            }
*/
#define     TYPE_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              (opnstkptr - (idx+1))->bitfield & TYPE_OFF) |\
              (var & TYPE_ON) )
#define     ATTRIBUTE_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ATTRIBUTE_OFF) |\
              ((ufix16)((var & ATTRIBUTE_ON) << ATTRIBUTE_BIT)) )
#define     ROM_RAM_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ROM_RAM_OFF) |\
              ((var & ROM_RAM_ON) << ROM_RAM_BIT) )
#define     LEVEL_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & LEVEL_OFF) |\
              ((var & LEVEL_ON) << LEVEL_BIT) )
#define     ACCESS_OP_SET(idx, var)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ACCESS_OFF) |\
              ((var & ACCESS_ON) << ACCESS_BIT) )

#define     TYPE_OP(idx)\
            ( (opnstkptr - (idx+1))->bitfield & TYPE_ON )
#define     ATTRIBUTE_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ATTRIBUTE_BIT) & ATTRIBUTE_ON )
#define     ROM_RAM_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ROM_RAM_BIT) & ROM_RAM_ON )
#define     LEVEL_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> LEVEL_BIT) & LEVEL_ON )
#define     ACCESS_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield >> ACCESS_BIT) & ACCESS_ON )

#define     VALUE_OP(idx)\
            ( (opnstkptr - (idx+1))->value )
#define     LENGTH_OP(idx)\
            ( (opnstkptr - (idx+1))->length )

#define     PUSH_NOLEVEL_OBJ(obj)\
            {\
              COPY_OBJ(obj,opnstkptr);\
              INC_OPN_IDX();\
            }

#define     P1_TYPE_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & TYPE_OFF) | (con) )
#define     P1_ATTRIBUTE_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ATTRIBUTE_OFF) | (con) )
#define     P1_ROM_RAM_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ROM_RAM_OFF) | (con) )
#define     P1_LEVEL_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & LEVEL_OFF) | (con) )
#define     P1_ACCESS_OP_SET(idx, con)\
            ( (opnstkptr - (idx+1))->bitfield =\
              ((opnstkptr - (idx+1))->bitfield & ACCESS_OFF) | (con) )

#define     P1_TYPE_OP(idx)\
            ( (opnstkptr - (idx+1))->bitfield & P1_TYPE_ON )
#define     P1_ATTRIBUTE_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ATTRIBUTE_ON )
#define     P1_ROM_RAM_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ROM_RAM_ON )
#define     P1_LEVEL_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_LEVEL_ON )
#define     P1_ACCESS_OP(idx)\
            ( ((opnstkptr - (idx+1))->bitfield & P1_ACCESS_ON )
/* qqq, end */

/************************
 |  PACKED_OBJECT SIZE  |
 ************************/
#define     PK_A_SIZE               1           /* 1-byte */
#define     PK_B_SIZE               2           /* 2-byte */
#define     PK_C_SIZE               5           /* 5-byte */
#define     PK_D_SIZE               9           /* 9-byte */
#define     _5BYTESPACKHDR          0xA0        /* 5 bytes objects */

#define     SYSOPERATOR             OPERATORPACKHDR             /* systemdict */

/******************************************
 |  PUBLIC FUNCTION DEFINITION: language  |
 ******************************************/
#ifdef LINT_ARGS
 /* OPERAND */
bool    create_new_saveobj(struct object_def FAR*) ;

 /* ARRAY */
bool    forall_array(struct object_def FAR*, struct object_def FAR*) ;

/* STRING */
bool    putinterval_string(struct object_def FAR*, ufix16, struct object_def FAR*) ;
bool    forall_string(struct object_def FAR*, struct object_def FAR*) ;

/* VM */
bool    save_obj(struct object_def FAR*) ;
void    update_same_link(fix16) ;

/* DICT */
bool    equal_key(struct object_def FAR *, struct object_def FAR *) ;
void    check_key_object(struct object_def FAR*) ;
void    change_dict_stack(void) ;

/* @WIN; move to global.ext and add FAR */
//char *ltoa(long,char *,int) ;
//char *gcvt(double,int,char *) ;

/* FILE */
void    vm_close_file(fix16) ;
#else
 /* OPERAND */
bool    create_new_saveobj() ;

 /* ARRAY */
bool    forall_array() ;

/* STRING */
bool    putinterval_string() ;
bool    forall_string() ;

/* VM */
bool    save_obj() ;
void    update_same_link() ;

/* DICT */
bool    equal_key() ;
void    check_key_object() ;
void    change_dict_stack() ;

char *ltoa() ;
char *gcvt() ;

/* FILE */
void    vm_close_file() ;
#endif /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\misc.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              MISC.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

#ifdef LINT_ARGS
static void near bind_array(struct object_def FAR *) ;
#else
static void near bind_array() ;
#endif /* LINT_ARGS */

/***********************************************************************
**
** This operator is used to replace executable operators in proc by
** their values. For each element of proc that is an executable name,
** Bind_op looks up the name in th context of the current dictionary
** stack. If the name is found and its value is an operator object,
** Bind_op replaces the name by the operator in proc. If the name
** is not found or its value is not an operator, Bind_op makes no
** change.
**
** Additionally, for each procedure object in proc whose access is
** unrestricted, Bind_op applies itself recursively to that procedure,
** makes the procedure read-only, and stores it back into proc.
**
** The effect of Bind_op is that all operator names in proc become
** 'tightly bound' to the operators themselves.
**
** TITLE:       op_bind                         Date:   00/00/87
** CALL:        op_bind()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       bind_array:
***********************************************************************/
fix
op_bind()
{
    /*
    **   replace executable operator names in proc by their values
    */
    switch(TYPE_OP(0)) {
        case ARRAYTYPE:
            if( ACCESS_OP(0) == UNLIMITED )
                bind_array( GET_OPERAND(0) ) ;
            break ;

        case PACKEDARRAYTYPE:
            if( ACCESS_OP(0) <= READONLY ) /* ?? be careful */
                bind_array( GET_OPERAND(0) ) ;
             break;

         case OPERATORTYPE:     /* PJ 5-9-1991 */
             if( ! systemdict_table[LENGTH_OP(0)].orig_operator )
                 break;

         default:
             ERROR(TYPECHECK);
             return(0);

     }   /* switch */
    global_error_code = NOERROR ;

    return(0) ;
}   /* op_bind */

/***********************************************************************
**
** TITLE:       op_null                         Date:   00/00/87
** CALL:        op_null()                       UpDate: Jul/12/88
** INTERFACE:   interpreter:
***********************************************************************/
fix
op_null()
{
    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else
        PUSH_VALUE(NULLTYPE, 0, LITERAL, 0, 0) ;
//
// FDB last parameter changed from NULL to 0 as MIPS build requires NULL
//      to be a pointer
//

    return(0) ;
}   /* op_null */

/***********************************************************************
**
** This operator is used to return the value of a clock that increment
** by one for every millisecond of execution by the interpreter.
**
** TITLE:       op_usertime                     Date:   00/00/87
** CALL:        op_usertime()                   UpDate: Jul/12/88
** INTERFACE:   interpreter:
** CALLS:       curtime:
***********************************************************************/
fix
op_usertime()
{
    if( FRCOUNT() < 1 )
          ERROR(STACKOVERFLOW) ;
    else
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, curtime()) ;

    return(0) ;
}   /* op_usertime */

/***********************************************************************
**
** TITLE:       init_misc                       Date:   00/00/87
** CALL:        init_misc()                     UpDate: Jul/12/88
** INTERFACE:   start:
***********************************************************************/
void
init_misc()
{
    settimer( 0L ) ;

    return ;
}   /* init_misc */

/***********************************************************************
**
** TITLE:       bind_array                      Date:   00/00/87
** CALL:        bind_array()                    UpDate: Jul/12/88
** INTERFACE:   op_bind:
***********************************************************************/
static void near
bind_array(p_aryobj)
struct  object_def  FAR *p_aryobj ;
{
    bool    l_bool ;
    ufix16  l_i ;
    ubyte   huge *l_current ;
    struct  object_def  huge    *l_objptr ;
    struct  object_def  FAR *l_value, l_object ;
    ubyte   huge *l_next = 0 ;

    l_current = (ubyte huge *)VALUE(p_aryobj) ;

    if(TYPE(p_aryobj) == PACKEDARRAYTYPE) {
        l_bool = TRUE ;
        l_objptr = &l_object ;
        l_next = l_current ;
    } else {
        l_bool = FALSE ;
        l_objptr = (struct object_def huge *)l_current ;
    }

    /* get procedure's elements: l_objptr  */
    for(l_i=0 ; l_i < LENGTH(p_aryobj) ; l_i++) {
        if(l_bool) {
            l_current = l_next ;
            l_next = get_pk_object(l_current, l_objptr, LEVEL(p_aryobj)) ;
        }

        /*
        **   ARRAY
        **   1. if element is a procedure, apply itself recursively
        **   2. makes the procedure read-only
        */
        switch( TYPE(l_objptr) ) {
            case ARRAYTYPE:
                if( ACCESS(l_objptr) == UNLIMITED ) {
                    bind_array( l_objptr ) ;
                    ACCESS_SET(l_objptr, READONLY) ;
                }
                break ;

            case PACKEDARRAYTYPE:
                if( ACCESS(l_objptr) <= READONLY )
                    bind_array( l_objptr ) ;
                break ;

            case NAMETYPE:
                /* for executable name */
                if( ATTRIBUTE(l_objptr) == EXECUTABLE ) {
                    if( load_dict(l_objptr, &l_value) ) {
                        if( (TYPE(l_value) == OPERATORTYPE) &&
                            (systemdict_table[LENGTH(l_value)].orig_operator) ) { /* Pj 5-9-1991 */
                            if(l_bool) {
                                *l_current = (byte)(LENGTH(l_value) >> 8) ;
                                if( ROM_RAM(l_value) == RAM )
                                    *l_current |= SYSOPERATOR ; /* systemdict */
                                l_current++ ;
                                *l_current++ = (byte)LENGTH(l_value) ;
                            } else
                                COPY_OBJ(l_value, l_objptr) ;
                        }
                    }
                }
        }   /* switch */
        if(! l_bool)l_objptr++ ;
    }   /* for */

    return ;
}   /* bind_array */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\init1pp.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              INIT1PP.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/30/89
 *      Owner:                  Microsoft Co.
 *      Description: this file contains all the initialization functionc
 *                   for statusdict and 1pp dicts.
 *
 * revision history:
 *
 *      06-18-90 ; Added string allocation for "jobsource"
 *              dictionary string entry.
 *      7/13/90 ; ccteng ; modify init_release(), add InitVersionDict, InitMsgDict
 *                      PSPrep, and delete some others
 *      7/13/90 ; ccteng ; comment init_psf_font, init_psg_font for rtfpp
 *      7/16/90 ; ccteng ; change printerdict arrays to be literal
 *      7/20/90 ; ccteng ; 1)delete PRODUCT in init_release
 *                       2)change init_userdict, init_errordict, init_serverdict,
 *                         init_printerdict, init_idletimedict, init_execdict,
 *                         init_Derror for change of dict_tab.c structure
 *      7/21/90 ; ccteng ; change init_release, move jobstate, jobsource to PSPrep
 *      7/23/90 ; ccteng ; include "startpage.h" and add StartPage initialization
 *      8/29/90 ; ccteng ; change <stdio.h> to "stdio.h"
 *      9/14/90 ; remove ALL_VM flag
 *     11/28/90  Danny   Precache Mech. Added(ref PCH:)
 *     11/30/90  Danny   Add for idle fonts setup at initial time(ref IDLI:)
 *     11/30/90  Danny  Add id_stdfont entries for 35 fonts (ref F35:)
 *
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <stdio.h>                   /* move up @WIN */
#include    <string.h>                  /* move up @WIN */
#include    "global.ext"
#include    "geiio.h"
#include    "geiioctl.h"
#include    "geierr.h"
#include    "init1pp.h"
#include    "user.h"
#include    "release.h"
#include    "startpg.h"

#ifdef LINT_ARGS
static  void  near  init_userdict(void) ;
static  void  near  init_errordict(void) ;
static  void  near  init_serverdict(void) ;
static  void  near  init_printerdict(void) ;
static  void  near  init_idletimedict(void) ;
static  void  near  init_execdict(void) ;
static  void  near  init_Derrordict(void) ;
static  void  near  init_release(void) ;
static  void  near  init_printerdictarray(void) ;
static  void  near  init_idletimedictarray(void) ;
static  void  near  pre_cache(void) ;
//DJC
static  void  near  init_psprivatedict(void);  //DJC
#else
static  void  near  init_userdict() ;
static  void  near  init_errordict() ;
static  void  near  init_serverdict() ;
static  void  near  init_printerdict() ;
static  void  near  init_idletimedict() ;
static  void  near  init_execdict() ;
static  void  near  init_Derrordict() ;
static  void  near  init_release() ;
static  void  near  init_printerdictarray() ;
static  void  near  init_idletimedictarray() ;
static  void  near  pre_cache() ;
static  void  near  init_psprivatedict(); //DJC
#endif /* LINT_ARGS */

/* @WIN; add prototype */
fix us_readidlecachefont(void);

#ifdef KANJI
extern struct dict_head_def FAR *init_encoding_directory() ;
#endif  /* KANJI */

int     ES_flag = PDL;  /* added for Emulation Switch Aug-08,91 YM */

/*
 * init_1pp(): calling interface from main()
 *             to initialize each dictionaries
 */
void
init_1pp()
{
    struct  object_def  FAR *l_systemdict ;
    struct  dict_head_def   FAR *l_dict ;

    init_userdict() ;            /* init userdict */
#ifdef  DBG_1pp
    printf("init_userdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_errordict() ;           /* init errordict */
#ifdef  DBG_1pp
    printf("init_errordict() OK !\n") ;
#endif  /* DBG_1pp */

    init_serverdict() ;          /* init serverdict */
#ifdef  DBG_1pp
    printf("init_serverdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_printerdict() ;         /* init printerdict */
#ifdef  DBG_1pp
    printf("init_printerdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_idletimedict() ;        /* init idletimedict */
#ifdef  DBG_1pp
    printf("init_idletimedict() OK !\n") ;
#endif  /* DBG_1pp */

    init_execdict() ;            /* init execdict */
#ifdef  DBG_1pp
    printf("init_execdict() OK !\n") ;
#endif  /* DBG_1pp */

    init_Derrordict() ;          /* init Derrordict */
#ifdef  DBG_1pp
    printf("init_Derrordict() OK !\n") ;
#endif  /* DBG_1pp */

    //DJC begin new init_psprivatedict
    init_psprivatedict() ;      /*  init psprivatedict */

#ifdef  DBG_1pp
    printf("init_psprivatedict() OK !\n") ;
#endif  /* DBG_1pp */

    //DJC end new init_psprivatedict

    init_release() ;              /* init release control data */
#ifdef  DBG_1pp
    printf("init_release() OK !\n") ;
#endif  /* DBG_1pp */

/*
 * optional functions for BS fonts in file INITBSF.C
 * to re-initialize the PSF font entries in /FontDirectory
 */
/*  init_psf_fonts() ; */          /* init FontDirectory */
#ifdef  DBG_1pp
    printf("init_psf_fonts() OK !\n") ;
#endif /* DBG_1pp */

    /*
     * re-set access of systemdict to be READONLY
     */
    get_dict_value("systemdict", "systemdict", &l_systemdict) ;
    l_dict = (struct dict_head_def FAR *) VALUE(l_systemdict) ;
    DACCESS_SET(l_dict, READONLY) ;

/*
 * optional functions for BS fonts in file INITBSF.C
 */
/*    init_psg_fonts() ;  */         /* init BS PSG fonts 03/28/90 kung */
#ifdef  DBG_1pp
    printf("init_psg_fonts() OK !\n") ;
    op_pstack() ;
#endif  /* DBG_1pp */

/*
 * build pre_cache data
 */
#ifdef PCH_S
    pre_cache() ;
#endif

#ifdef  DBG_1pp1
    printf("pre_cache() OK !\n") ;
#endif  /* DBG_1pp */

    st_idlefonts() ;
    op_counttomark() ;
    us_readidlecachefont() ;
    if (ANY_ERROR()) {
        op_cleartomark() ;
        CLEAR_ERROR() ;
    }
#ifdef DBG_1pp1
  printf("idle font setup OK !\n") ;
#endif

    return ;
}   /* init_1pp */

/*
 *  init_userdict()
 *     initialize userdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_userdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;
#ifdef  KANJI
    ufix32 max_length ;
    struct dict_head_def FAR *encod_dir ;
#endif  /* KANJI */

#ifdef  DBG_1pp1
    printf("init_userdict()...\n") ;
#endif  /* DBG_1pp1 */

    get_dict_value(SYSTEMDICT, USERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, MAXUSERDICTSZ) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

#ifdef  DBG_1pp1
    printf("for loop OK !\n") ;
#endif  /* DBG_1pp1 */

#ifdef  KANJI
    encod_dir = init_encoding_directory(&max_length) ;
    get_name(&key_obj, "EncodingDirectory",
                lstrlen("EncodingDirectory"), TRUE) ;   /* @WIN */
    TYPE_SET(&value_obj, DICTIONARYTYPE) ;
    VALUE(   &value_obj) = (ufix32)encod_dir ;
    LENGTH(  &value_obj) =  max_length ;
    put_dict(dict_obj, &key_obj, &value_obj) ;
#endif  /* KANJI */

#ifdef  DBG_1pp1
    printf("KANJI OK !\n") ;
#endif  /* DBG_1pp1 */

    /*
     * push userdict on dictstack
     */
    if (FRDICTCOUNT() < 1)
       ERROR(DICTSTACKOVERFLOW) ;
    else
       PUSH_DICT_OBJ(dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;
    ES_flag = PDL ;     /* Aug-08,91 YM */
#ifdef  DBG_1pp1
    printf("exit init_userdict()\n") ;
#endif  /* DBG_1pp1 */

    return ;
}   /* init_userdict */

/*
 *  init_errordict()
 *     initialize errordict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_errordict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(SYSTEMDICT, ERRORDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_errordict */


//DJC begin , new function init_psprivatedict
//
/*
 *  init_psprivatedict()
 *     initialize psprivatedict from the data in systemdict_table[]
 *     and save it in VM. This is used to initialize any postscript
 *     level objects required for PSTODIB that were not available
 *     in the original true image code. Currently we have only
 *     one new integer defined which tracks the current page type number
 *     so we can pass on the page size associated with the frame buffer
 *
 */
static  void  near
init_psprivatedict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, PSPRIVATEDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_errordict */



/*
 *  init_serverdict()
 *     initialize serverdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_serverdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, SERVERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 20) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN */
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_serverdict */

/*
 *  init_printerdict()
 *     initialize $printerdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_printerdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    struct object_def  FAR *l_proc ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;


    get_dict_value(USERDICT, PRINTERDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /* @WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;

        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * re_define "proc" to be a procedure (packedarray)
     */


    get_dict_value(PRINTERDICT, "proc", &l_proc) ;
    PUSH_ORIGLEVEL_OBJ(l_proc) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,1) ;

    op_array() ;
    op_astore() ;

    op_cvx() ;
    op_executeonly() ;
    put_dict_value(PRINTERDICT, "proc", GET_OPERAND(0)) ;
    POP(1) ;




    /*
     * re_initial $printerdict arrays
     */
    init_printerdictarray() ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_printerdict */

/*
 *  init_idletimedict()
 *     initialize $idleTimeDict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_idletimedict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, IDLETIMEDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;

    for ( ; j < (fix)(dict_count-1) ; j++) {            //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * re_initial $idleTimeDict arrays
     */
    init_idletimedictarray() ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_idletimedict */

/*
 *  init_execdict()
 *     initialize execdict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_execdict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(USERDICT, EXECDICT, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;

    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_execdict */

/*
 *  init_Derrordict()
 *     initialize $errordict from the data in systemdict_table[]
 *     and save it in VM
 */
static  void  near
init_Derrordict()
{
    struct object_def  key_obj, value_obj, FAR *dict_obj ;
    struct object_def  FAR *l_curvm ;
    byte  FAR *key_string ;
    fix    j ;
    fix    dict_size=0 ;

    get_dict_value(SYSTEMDICT, DERROR, &dict_obj) ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;
    dict_count++ ;
    create_dict(dict_obj, dict_size + 3) ;
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
        key_string = systemdict_table[j].key ;
        ATTRIBUTE_SET(&key_obj, LITERAL) ;
        LEVEL_SET(&key_obj, current_save_level) ;
        get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ; /*@WIN*/
        value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
        value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
        put_dict(dict_obj, &key_obj, &value_obj) ;
    } /* for */

    /* initialize "/$cur_vm" array */
    for ( j = 0 ; j < 3 ; j++ )
        PUSH_VALUE(NULLTYPE,UNLIMITED,LITERAL,0, 0) ;

    /* create an array and load the initial values */
    get_dict_value(DERROR, "$cur_vm", &l_curvm) ;
    create_array(l_curvm, j) ;
    astore_array(l_curvm) ;

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_Derrordict */

/*
 *  init_printerdictarray()
 *     initialize following arrays in $printerdict:
 *     /printerarray, /letter, /lettersmall, /a4, /a4small,
 *     /b5, /legal, /note, /defaultmatrix, /matrix.
 */
static  void  near
init_printerdictarray()
{
    ufix16  l_i, l_j ;
    byte    FAR *l_name ;
    struct  object_def  l_paper ;
    struct  object_def  FAR *l_array, FAR *l_matrix, FAR *l_defmtx, FAR *l_prarray ;
    extern fix    near  resolution ;

    /* initialize "/printerarray" */
    for ( l_i = 0 ; l_i < PAPER_N ; l_i++ ) {
        l_name = (byte FAR *) pr_paper[l_i] ;
        ATTRIBUTE_SET(&l_paper, LITERAL) ;
        get_name(&l_paper, l_name, lstrlen(l_name), TRUE) ; /*@WIN*/
        PUSH_ORIGLEVEL_OBJ(&l_paper) ;

        /* initialize array for this paper size */
        for ( l_j = 0 ; l_j < 6 ; l_j++ )
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_arrays[l_i][l_j]) ;
        /* create an array and load the initial values */
        get_dict_value(PRINTERDICT, l_name, &l_array) ;
        create_array(l_array, l_j) ;
        astore_array(l_array) ;
    }

    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "printerarray", &l_prarray) ;
    create_array(l_prarray, l_i) ;
    astore_array(l_prarray) ;

    /* initialize "/matrix" array */
    for ( l_j = 0 ; l_j < 6 ; l_j++ )
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_mtx[l_j]) ;
    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;
    create_array(l_matrix, l_j) ;
    astore_array(l_matrix) ;

    /* initialize "/defaultmatrix array */
    l_j = 0 ;
    for (l_i = 0 ; l_i < 2 ; l_i++ ) {
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
        op_div() ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,pr_defmtx[l_j++]) ;
    }

    /* create an array and load the initial values */
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;
    create_array(l_defmtx, l_j) ;
    astore_array(l_defmtx) ;

    return ;
}   /* init_printerdictarray */

/*
 *  init_idletimedictarray()
 *     initialize following arrays in $idleTimeDict:
 *     /stdfontname, /cachearray, /defaultarray.
 */
static  void  near
init_idletimedictarray()
{
    ufix16  l_i, l_j ;
    byte    FAR *l_name ;
    struct  object_def  l_fontname ;
    struct  object_def  FAR *l_stdfontname, FAR *l_cstring, FAR *l_defarray, FAR *l_carray ;

    /* initialize "cachestring" */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cstring) ;
    create_string(l_cstring, (ufix16) lstrlen(CACHESTRING) ) ;  /*@WIN*/
    lstrcpy( (byte FAR *) VALUE(l_cstring), (char FAR *)CACHESTRING ) ; /*@WIN*/

    /* initialize "/stdfontname" */
    //DJC for ( l_i = 0; l_i < STD_FONT_N; l_i++ ) {
    //DJC for ( l_i = 0; l_i < MAX_INTERNAL_FONTS; l_i++ ) {
    for ( l_i = 0; l_i < sizeof(id_stdfont) / sizeof(id_stdfont[1]); l_i++ ) {
        l_name = (byte FAR *) id_stdfont[l_i] ;
        ATTRIBUTE_SET(&l_fontname, LITERAL) ;
        get_name(&l_fontname, l_name, lstrlen(l_name), TRUE) ;  /*@WIN*/
        PUSH_ORIGLEVEL_OBJ(&l_fontname) ;
    }

    /* create a packed array and load the initial values */
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfontname) ;
    create_array(l_stdfontname, l_i) ;
    astore_array(l_stdfontname) ;

    ATTRIBUTE_SET(l_stdfontname, EXECUTABLE) ;
    ACCESS_SET(l_stdfontname, READONLY) ;

    /* initialize "cachearray" & "defaultarray" */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cstring) ;
    for ( l_i = 0; l_i < IDL_FONT_N; l_i++ ) {
        /* push font#, scales, rotate */
        for ( l_j = 0 ; l_j < 4 ; l_j++ )
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,id_cachearray[l_i][l_j]) ;
        /* push cachestring */
        PUSH_ORIGLEVEL_OBJ(l_cstring) ;
        VALUE(GET_OPERAND(0)) = (ULONG_PTR)( (byte huge *)VALUE(l_cstring) +
                                          id_cachearray[l_i][l_j++] ) ;
        LENGTH(GET_OPERAND(0)) = id_cachearray[l_i][l_j] ;
    }

    /* create an array and load the initial values */
    get_dict_value(IDLETIMEDICT, "defaultarray", &l_defarray) ;
    get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
    create_array(l_defarray, (l_i * l_j)) ;
    astore_array(l_defarray) ;
    ACCESS_SET(l_defarray, READONLY) ;
    COPY_OBJ(l_defarray, l_carray) ;

    return ;
}   /* init_idletimedictarray */

/*
 * define some constants & strings in systemdict, userdict
 * and statusdict for release control
 */
static  void  near
init_release()
{
    struct  object_def      FAR *l_startpage;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(InitVersionDict),
        InitVersionDict) ;     /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during InitVersionDict initialization") ;
    POP(1) ;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(InitMsgDict),
        InitMsgDict) ;          /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during InitMsgDict initialization") ;
    POP(1) ;

    PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(PSPrep),
        PSPrep) ;               /*@WIN*/
    if (interpreter(GET_OPERAND(0)))
        printf("Error during PSPrep initialization") ;
    POP(1) ;

    get_dict_value(USERDICT, "startpage", &l_startpage);

    // DJC change name of StartPage to avoid collision with Win API
    // VALUE(l_startpage) = (ufix32)StartPage;
    // LENGTH(l_startpage) = lstrlen(StartPage);   /*@WIN*/
    VALUE(l_startpage) = (ULONG_PTR)PSStartPage;
    LENGTH(l_startpage) = (ufix16)lstrlen(PSStartPage);   /*@WIN*/

    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
}   /* init_release */

/*
 * pre_cache():
 */
static  void  near
pre_cache()
{
    struct  object_def  l_save, l_tmpobj ;
    struct  object_def  FAR *l_stdfont, FAR *l_cachestr, FAR *l_defmtx ;
    ufix16  l_i, l_j, l_k ;

    /* initialize object pointers */
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cachestr) ;
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;

    /* create VM snapshot */
    op_save() ;
    COPY_OBJ(GET_OPERAND(0), &l_save) ;
    POP(1) ;

    /* set default matrix */
    PUSH_ORIGLEVEL_OBJ(l_defmtx) ;
    op_setmatrix() ;

    /* build pre-cache */
    op_gsave() ;
    l_j = 0 ;
    GEIio_write(GEIio_stdout, "\n", 1) ;
    for ( l_i = 0 ; l_i < PRE_CACHE_N ; l_i++ ) {
        op_grestore() ;
        op_gsave() ;

        /* set font */
        get_array(l_stdfont, pre_array[l_j++], &l_tmpobj) ;
        PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;

        GEIio_write(GEIio_stdout, "PreCache: ", 10) ;
        op_dup() ;
        one_equal_print() ;

        op_findfont() ;
        op_setfont() ;
        for (l_k=0 ; l_k<3 ; l_k++) {
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, pre_array[l_j++]) ;
        } /* for */

        GEIio_write(GEIio_stdout, ", Rotate= ", 10) ;
        op_dup() ;
        one_equal_print() ;

        op_rotate(1) ;

        GEIio_write(GEIio_stdout, ", Scale= ", 9) ;
        op_dup() ;
        one_equal_print() ;

        op_scale(2) ;

        GEIio_write(GEIio_stdout, ", Characters= ", 14) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, pre_array[l_j]) ;
        one_equal() ;
        op_flush() ;

        /* call op_stringwidth */
        getinterval_string(l_cachestr, 0, pre_array[l_j++], &l_tmpobj) ;
        PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
        op_stringwidth() ;
        POP(2) ;
    } /* for */

    GEIio_write(GEIio_stdout, "\n", 1) ;
    op_grestore() ;

#ifdef  DBG
    /* print out cachestatus */
    printf("\nCache Status = ") ;
    op_l_bracket() ;
    op_cachestatus() ;
    op_r_bracket() ;
    two_equal() ;
#endif  /* DBG */

    PUSH_ORIGLEVEL_OBJ(&l_save) ;
    op_restore() ;

#ifdef  DBG
    /* print out vmstatus */
    printf("\nVM Status = ") ;
    op_l_bracket() ;
    op_vmstatus() ;
    op_r_bracket() ;
    two_equal() ;
#endif  /* DBG */

#ifdef PCH_S
{
    bool        pack_cached_data();

    if (!pack_cached_data())
        printf("$$ PreCache ERROR!!!!!!\n");

    printf("TI pending!!!!!!\n");
    while(1);  /* forever */
}
#endif

    return ;
}   /* pre_cache */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\release.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              RELEASE.H
 *      Author:                 Chia-Chi Teng
 *      Date:                   12/21/89
 *      Owner:                  Microsoft Co.
 *      Description: just for release control use
 *
 * revision history:
 *      7/20/90; ccteng; delete PRODUCT, put it in InitVersionDict
 ************************************************************************
 */
/*
 * versiondict
 */
static byte FAR InitVersionDict[] = "\
statusdict begin\
/product(TrueImage)def\
/versiondict 7 dict dup begin\
/Core(51.2)def/r_Core 6.0 def\
/FileSys(0.0)def/r_FileSys 0 def\
/EFonts(0.0)def/r_EFonts 0 def\
/Hardware 3 dict dup begin/Processor(AM29000)def\
/FPU null def/Engine(TEC-6)def end readonly def\
 end readonly def end";

/*
 * messagedict
 */
static byte FAR InitMsgDict[] = "\
userdict begin/messagedict 40 dict dup begin\
/banner{(\nTrueImage\050r\051 Version )print =}def\
/copyrightnotice{(Copyright \050c\051 1989-92 Microsoft Corporation)=}def\
/reporterror{(%%[ Error: )print =print(; OffendingCommand: )print\
 =print( ]%%)=}def\
/flushingjob{(%%[ Flushing: rest of job \050to end-of-file\051 will be ignored ]%%)\
=}def\
/fontnotfound{exch =print( not found, using )print =}def\
/prompterror{(Error during prompt execution)=}def\
/exitingserver{(%%[ exitserver: permanent state may be changed ]%%)=}def\
/reportprintererror{(%%[ PrinterError: )print print ( ]%%\n)print flush}def\
/statusrequest{exch 3 -1 roll/; false def(%%[)print dup null eq{pop}\
{( job: )print =print/; true def}ifelse dup null eq{pop}\
{;{(;)print}if( status: )print =print/; true def} ifelse\
 dup null eq{pop}{;{(;)print}if( source: )print =print}ifelse( ]%%)=}def\
/JobBusy(busy)def\
/JobIdle(idle)def\
/JobInitializing(initializing)def\
/JobPrinting(printing)def\
/JobStartPage(printing start page)def\
/JobTestPage(printing test page)def\
/JobWaiting(waiting)def\
/CoverOpen(cover open)def\
/NoPaper(out of paper)def\
/NoPaperTray(no paper tray)def\
/NoResponse(controller not responding)def\
/PaperJam(paper jam)def\
/WarmUp(warming up)def\
/TonerOut(toner out)def\
/ManualFeedTimeout(manual feed timeout)def\
/EngineError(engine error)def\
/EnginePrintTest(engine print test)def\
/SourceAppleTalk(AppleTalk)def\
/SourceEtherTalk(EtherTalk)def\
/SourceSerial9(serial 9)def\
/SourceSerial25(serial 25)def\
 end def end";

/*
 * TrueImage start message
 */
static byte FAR StartMsg[] = "\
( Start )print statusdict begin =string printername end =print(....)=\
( >>>>---- TrueImage)print version print( ---- [)print\
 FontDirectory length =print( Fonts] ----)=";

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\relate.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */


// DJC added global include file
#include "psglobal.h"


#include        <string.h>
#include        "global.ext"
#include        "arith.h"
#include        <stdio.h>

#define         GE          1
#define         GT          2
#define         LE          3
#define         LT          4
#define         EQ          1
#define         NE          2

#define         AND         1
#define         OR          2
#define         XOR         3

/* static function declaration */
#ifdef LINT_ARGS
static fix near  lenstr_cmp(byte FAR *, byte FAR *, ufix16, ufix16) ;
static fix near  eq_ne(ufix16) ;
#else
static fix near  lenstr_cmp() ;
static fix near  eq_ne() ;
#endif /* LINT_ARGS */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if they are equal, 'false' if not.
 *  The definition of equality depends on the types of the objects being
 *  compared. Simple objects are equal if their types and values are the
 *  same. Strings are equal if their lengths and individual elements are
 *  equal. Other composite objects(arrays and dictionaries) are equal only
 *  if they share the same value ; separate values are considered unequal,
 *  even if all the components of those values are the same.
 *
 *  Some type conversions are performed by Eq_op, Integers and real can
 *  be compared freely: an integer and a real representing the same
 *  mathmatical value are considered equalby Eq_op. Strings and names
 *  can likewise be compared freely: a name defined by some sequence
 *  of character is equal to a string whose elements are the same sequence
 *  of characters.
 *
 *  The literal/executable and access attributes of objects are not
 *  considered in comparisons between objects.
 *
 * TITLE:       op_eq              Date:   00/00/87
 * CALL:        op_eq()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:        eq_ne()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_eq()
{
    eq_ne(EQ) ;

    return(0) ;
}   /* op_eq() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if they are equal, 'false' if not.
 *  What it means for objects to be equal is presented in the description
 *  of the Eq_op operator.
 *
 * TITLE:       op_ne               Date:   00/00/87
 * CALL:        op_ne ()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:        eq_ne()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_ne()
{
    eq_ne(NE) ;

    return(0) ;
}   /* op_ne() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is greater
 *  than or equal to the second, false otherwise. If both operands are
 *  numbers, Ge_op compares their mathematical values. If both operands
 *  are strings, Ge_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Ge_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_ge              Date:   00/00/87
 * CALL:        op_ge()            UpDate: 08/06/87
 * PARAMETERS:  par1,par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_ge()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll >= l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff >= l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code >= 0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_ge() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is greater
 *  than the second, false otherwise. If both operands are
 *  numbers, Gt_op compares their mathematical values. If both operands
 *  are strings, Gt_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Gt_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1,par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_gt()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll >  l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff >  l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code >  0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_gt() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is less
 *  than or equal to the second, false otherwise. If both operands are
 *  numbers, Le_op compares their mathematical values. If both operands
 *  are strings, Le_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Le_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1, par2 ; object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_le()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll <= l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff <= l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code <= 0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_le() */

/* *********************************************************************
 *
 *  This operator is used to pop two objects from the operand stack
 *  and push the boolean value 'true' if the first operand is less
 *  than the second, false otherwise. If both operands are
 *  numbers, Lt_op compares their mathematical values. If both operands
 *  are strings, Lt_op compares them element by element to determine
 *  whether the first string is lexically greater than or equal to the
 *  second. If the operands are of other types, Lt_op executes the
 *  TypeCheck error.
 *
 * TITLE:       op_gt              Date:   00/00/87
 * CALL:        op_gt()            UpDate: 08/06/87
 * PARAMETERS:  par1, par2 ;  object pointer (4-byte)
 *                        ; with number or string type only
 * INTERFACE:
 * CALL:        ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 **********************************************************************/
fix
op_lt()
{
    struct  object_def  FAR *par1, FAR *par2 ;
    union   four_byte   l_par1, l_par2 ;
    ufix32  l_bool ;
    fix     ret_code ;

/*
 *  Initialize
 */
    par1 = GET_OPERAND(1) ;
    par2 = GET_OPERAND(0) ;
    l_par1.ll = (fix32)VALUE(par1) ;
    l_par2.ll = (fix32)VALUE(par2) ;
    l_bool = FALSE ;
    if (IS_NUM_OBJ(par1) && IS_NUM_OBJ(par2)) {
       if (IS_INTEGER(par1) && IS_INTEGER(par2)) {
                if (l_par1.ll <  l_par2.ll)
                   l_bool = TRUE ;
       } else { /* one of them or both is real */
          if (IS_INTEGER(par1))
             l_par1.ff = (real32)l_par1.ll ;
          if (IS_INTEGER(par2))
             l_par2.ff = (real32)l_par2.ll ;
                if (l_par1.ff <  l_par2.ff)
                   l_bool = TRUE ;
       }
    } else {
    /*
     * both operand are string
     */
       if ((ACCESS(par1) & EXECUTEONLY) || (ACCESS(par2) & EXECUTEONLY)) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       ret_code = lenstr_cmp((byte FAR *)l_par1.address, (byte FAR *)l_par2.address,
                             LENGTH(par1), LENGTH(par2)) ;
             if (ret_code <  0)
                l_bool = TRUE ;
    }

    POP(1);
    opnstack[opnstktop-1].value=l_bool;
    TYPE_SET(&opnstack[opnstktop-1],BOOLEANTYPE);

    return(0) ;
}   /* op_lt() */

/* *********************************************************************
 *
 *  If the operands are booleans, And_op returns their logical
 *  conjunction. If the operands are integers, And_op returns the
 *  bitwise 'and' of their binary representations.
 *
 * TITLE:       op_and              Date:   08/25/87
 * CALL:        op_and()            UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_and()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) & VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_and() */

/* *********************************************************************
 *
 *  If the operand is a boolean, Not_op returns its logical
 *  conjunction. If the operand is an integer, Not_op returns the
 *  bitwise complement of its binary representation.
 *
 * TITLE:       op_not              Date:   08/25/87
 * CALL:        op_not()            UpDate:
 * PARAMETERS:  par        ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_not()
{
    struct  object_def  FAR *par ;

    par = GET_OPERAND(0) ;
/*
 *   operand is an integer numbers
 */
    if (IS_INTEGER(par))
       VALUE(par) = ~VALUE(par) ;       /* one's complement */
/*
 *   operand is boolean type
 */
    else if (VALUE(par) == TRUE)
       VALUE(par) = FALSE ;
    else
       VALUE(par) = TRUE ;

    return(0) ;
}   /* op_not() */

/* *********************************************************************
 *
 *  If the operands are booleans, Or_op returns their logical
 *  disjunction. If the operands are integers, Or_op returns the
 *  bitwise 'inclusive or' of their binary representation.
 *
 * TITLE:       op_or               Date:   08/25/87
 * CALL:        op_or()             UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_or()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) | VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_or() */

/* *********************************************************************
 *
 *  If the operands are booleans, Xor_op returns their logical
 *  'exclusive or'. If the operands are integers, Xor_op returns the
 *  bitwise 'exclusive or' of their binary representation.
 *
 * TITLE:       op_xor              Date:   08/25/87
 * CALL:        op_xor()            UpDate:
 * PARAMETERS:  par1, par2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; BOOLEANTYPE object for BOOLEAN (4-byte)
 *                       ; parameter
 *                       ; INTEGER object for INTEGER parameter (4-byte)
 **********************************************************************/
fix
op_xor()
{
    opnstack[opnstktop-2].value = VALUE(GET_OPERAND(1)) ^ VALUE(GET_OPERAND(0)) ;
    POP(1) ;

    return(0) ;
}   /* op_or() */

/* *********************************************************************
 *
 *  This operator is used to return a boolean object whose value is
 *  true on the operand stack.
 *
 * TITLE:       op_true             Date:   08/25/87
 * CALL:        op_true()           UpDate:
 * PARAMETERS:  none.
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; TRUE BOOLEANTYPE object  (4-byte)
 **********************************************************************/
fix
op_true()
{
    /* check free object # on operand stack */
    if (FRCOUNT() < 1) {
       ERROR(STACKOVERFLOW) ;
       return(0) ;
    }

    /* push 'bool' to operand stack */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;

    return(0) ;
}   /* op_true() */

/* *********************************************************************
 *
 *  This operator is used to return a boolean object whose value is
 *  false on the operand stack.
 *
 * TITLE:       op_false            Date:   08/25/87
 * CALL:        op_false()          UpDate:
 * PARAMETERS:  none.
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; TRUE BOOLEANTYPE object  (4-byte)
 **********************************************************************/
fix
op_false()
{
    /* check free object # on operand stack */
    if (FRCOUNT() < 1) {
       ERROR(STACKOVERFLOW) ;
       return(0) ;
    }

    /* push 'bool' to operand stack */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;

    return(0) ;
}   /* op_false() */

/* *********************************************************************
 *
 *  This operator is used to shift the binary representation of inum
 *  left by 'shift' bits and returns the result. Bits shifted out are
 *  lost ; bits shifted in are zero. If 'shift' is negative then a right
 *  shift by '-shift' bits is performed. Both inum  and shift must be
 *  integers.
 *
 * TITLE:       op_bitshift         Date:   08/25/87
 * CALL:        op_bitshift()       UpDate:
 * PARAMETERS:  int1, int2      ; pointer to INTEGERTYPE objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_val    ; pointer to INTEGERTYPE object ( 4-byte)
 **********************************************************************/
fix
op_bitshift()
{
    struct  object_def  FAR *inum ;
    union   four_byte   l_num2 ;

/*
 *  Initialize
 */
    inum = GET_OPERAND(1) ;
    l_num2.ll = (fix32)VALUE(GET_OPERAND(0)) ;
/*
 *   shift is not zero
 */
    if (l_num2.ll) {
    /*
     * shift is positive: shift left
     */
       if (l_num2.ll > 0)
          VALUE(inum) = VALUE(inum) << l_num2.ll ;
    /*
     * shift is negative: shift right
     */
       else
          VALUE(inum) = VALUE(inum) >> (-l_num2.ll) ;
    }
    POP(1) ;

    return(0) ;
}   /* op_bitshift() */

/* *********************************************************************
 *
 *  This routine is called by op_eq() and op_ne().
 *  If mode = EQ, compare equal
 *     mode = NE, comapre not equal
 *
 * TITLE:       eq_ne              Date:   00/00/87
 * CALL:        eq_ne()            UpDate: 08/06/87
 * PARAMETERS:  any1, any2 ; pointer to any type objects (4-byte)
 * INTERFACE:
 * CALLS :      ERROR()
 * RETURN:      l_bool   ; BOOLEANTYPE object with value l_bool  (4-byte)
 * **********************************************************************/
static fix near
eq_ne(mode)
ufix16  mode ;
{
    struct object_def  FAR *any1, FAR *any2 ;
    union  four_byte   l_num1, l_num2 ;
    ufix32  l_bool ;

    any1 = GET_OPERAND(1) ;
    any2 = GET_OPERAND(0) ;
    l_num1.ll = (fix32)VALUE(any1) ;
    l_num2.ll = (fix32)VALUE(any2) ;
    l_bool = FALSE ;

   /*
    *   TYPE not equal
    */
    if (TYPE(any1) != TYPE(any2)) {

       if (IS_NUM_OBJ(any1) && IS_NUM_OBJ(any2)) {
       /*
        *   one is real, the other is an integer
        */
          if (IS_INTEGER(any1))
             l_num1.ff = (real32)l_num1.ll ;
          else
             l_num2.ff = (real32)l_num2.ll ;

          if (F2L(l_num1.ff) == F2L(l_num2.ff))
             l_bool = TRUE ;

       } else {
       /*
        *   one is string, the other is a name
        */
          if ((TYPE(any1) == STRINGTYPE || TYPE(any1) == NAMETYPE) &&
              (TYPE(any2) == STRINGTYPE || TYPE(any2) == NAMETYPE)) {
             if ((TYPE(any1) == STRINGTYPE && (ACCESS(any1) & EXECUTEONLY)) ||
                 (TYPE(any2) == STRINGTYPE && (ACCESS(any2) & EXECUTEONLY))) {
                ERROR(INVALIDACCESS) ;
                return(0) ;
             }
            /*
             *  Convert string object to name object, then
             *  compare hash "id" of the two name objects
             */
             if (equal_key(any1, any2))
                l_bool = TRUE ;
             else
                CLEAR_ERROR() ;
          }
       }
    } else {    /* Type equal */
       if (VALUE(any1) != VALUE(any2)) {
       /*
        * VALUE is not equal
        */
          switch (TYPE(any1)) {
          case  NULLTYPE:
          case  MARKTYPE:
                l_bool = TRUE ;
                break ;

          case  STRINGTYPE:
                if ((ACCESS(any1) & EXECUTEONLY) || (ACCESS(any2) & EXECUTEONLY)) {
                   ERROR(INVALIDACCESS) ;
                   return(0) ;
                }
                if ( LENGTH(any1) == LENGTH(any2) ) {
                    if ( !lstrncmp(l_num1.address, l_num2.address, LENGTH(any1)) )
                       l_bool = TRUE ;
                }
          default:
                break ;
          } /* switch */
       } else {
       /*
        * VALUE are equal
        */
          switch (TYPE(any1)) {
          case  STRINGTYPE:
                if ((ACCESS(any1) & EXECUTEONLY) || (ACCESS(any2) & EXECUTEONLY)) {
                   ERROR(INVALIDACCESS) ;
                   return(0) ;
                }

          case  ARRAYTYPE:
          case  PACKEDARRAYTYPE:
                if (LENGTH(any1) == LENGTH(any2))
                   l_bool = TRUE ;
                break ;

          case  SAVETYPE:
          case  FONTIDTYPE:
                l_bool = FALSE ;
                break ;

          default:
                l_bool = TRUE ;
                break ;
          } /* switch */
       }
    } /* Type equal */

    POP(2) ;
    if (mode == NE)
       l_bool = !l_bool ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;

    return(0) ;
 }   /* eq_ne() */


/* *********************************************************************
 *
 *  String compare routine.
 *  This routine called by op_ge(), op_gt(), op_le(), op_lt().
 *  Give two string with their length, the two string may not terminated
 *  by  null character.
 *
 * TITLE:       lenstr_cmo          Date:   08/25/87
 * CALL:        lenstrcmp()         UpDate:
 * PARAMETERS:  str1, str2 : Pointer to input char string.
 *              len1, len2 : length of string1, string2.
 *
 * INTERFACE:
 * CALLS :      ERROR(),
 * RETURN:      integer  ;  Return (1) : if string1 > string2
 *                       ;  Return (0) : if string1 == string2
 *                       ;  Return (-1) : if string1 < string2
 **********************************************************************/
static fix near
lenstr_cmp(str1, str2, len1, len2)
byte  FAR *str1, FAR *str2 ;
ufix16 len1, len2 ;
{
    while (len1 && len2) {   /* len1 > 0 && len2 > 0 */
          if (*str1 > *str2)
             return(1) ;
          else if (*str1 < *str2)
             return(-1) ;
          len1-- ; len2-- ;
          str1++ ; str2++ ;
    }
    if (!len1 && !len2)
       return(0) ;
    else if (len1 > 0)
       return(1) ;
    else
       return(-1) ;
}   /* lenstr_cmp() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\startpg.h ===
/*
 * Copyright(c)1989,90 Microsoft Corporation
 */

// DJC DJC added ifdef status_page
#ifdef STATUS_PAGE


/* @WIN; no start page ------------ delete start here ------------

#ifndef UNIX
const
#endif
char FAR StartPage[]= "\
 printerdict/currentpagetype get/legal eq{20 15 translate 0.92 1.25 scale}if\
 printerdict/currentpagetype get/a4 eq{-10 0 translate 1 1.06 scale}if\
 printerdict/currentpagetype get/b5 eq{-10 -20 translate 0.91 0.95 scale}if\
/O{load def}bind def/C/curveto O\
/M/moveto O/L/lineto O/D/def O/U/dup O/P/put O/R/readonly O/A/ashow O\
/S/show O/X/exch O/F{findfont X scalefont setfont}D/J/setlinewidth O\
/N{setmiterlimit setlinejoin setlinecap J}D/G/gsave O/T/grestore O\
/Y/setgray O/H/closepath O/W/newpath O/K/stroke O/I/fill O/E/translate O\
/Q/scale O/B/rmoveto O/Z/rlineto O/-/sub O/V/stringwidth O/+{true charpath}D\
/s10{10 string}D/SS save D\
 -1 584 E 0.85 0.85 Q 12 dict begin/FontInfo 9 dict U begin end R D\
/FontName/MicroSoft D/Encoding 256 array U 77/M P R D/PaintType 0 D\
/FontType 1 D/StrokeWidth 0 D/FontMatrix[0.001 0 0 0.001 0 0]R D\
/FontBBox{-9 -26 5180 848}R D currentdict end\
 userdict/ND{noaccess def}executeonly put\
 userdict/NP{noaccess put}executeonly put\
 dup/Private 8 dict dup begin/BlueValues [-9 0 499 503 506 507 510 511]ND\
/MinFeature{16 16}ND/password 5839 def/StdHW[146]def/StdVW[238]def\
/StemSnapH[34 146 178 ]def/StemSnapV[180 238 ]def/Subrs 9 array\
 dup 0<15059cb865ff574d21893ec5987229>NP dup 1<15059cb860e7f1f12a>NP\
 dup 2<15059cb860e6224dc7>NP dup 3<15059cb8e0>NP dup 4<9b1bcad1065e416f>NP\
 dup 5<e865aff883ffef9700>NP dup 6<9f043839fb827d5cca>NP\
 dup 7<e86ccaf9c30086516e>NP dup 8<9f043adaf47355d0ca>NP ND end NP\
 dup/CharStrings 1 dict dup begin/M\
<926d7c4881b70c413da9227f14c524480efc3b817718c5530229a93c0a52d7f984af48\
5b5b86d4585dda98c29fb605f7feb8ced3f7d701650cabdb65a88067a9c7b9ee836c29\
4604785f5cee23d1554cb91c38f7875bde174099e8d6f9697e4806fc10c870ae83a143\
ffff57775e3005081e46fae5f3caca52766d4356dfbb5e87f46f71c2b030115b4c02ec\
1ee4d935983eded11ef76873c6e9f525465a4a99fcef8cb4e91cd2b83da2db3bfd0930\
e16ff26a742aa468a0b0bff2dda75c466bc45691108f9ad858ec56d2037b99df89f565\
8210675876872efd512f5a76dd241806bd8c24587ac85dd165265c96684f5b5936d081\
cd1d3c77e089b77311a6ba995a2cbd919b2816b377895b73bce5b37d4cb3176f35546e\
a05b4927e7b4351f997acdbce23f3a49c2b8815ae4de6833e0d09383e88c4f7dee8169\
7139ba88ca85fec07834dbc1c1763ed317458fd64b1489c8ed43ae00dcfd25e8d06dd3\
017267a7dfede3506f9d00469e08a195a6a8cea489d9f6eede474c65be1dab74f73125\
638af4b5e47298542696fe541d25772f8ad1adb47ebb41193c872bb3ca240195547218\
3cbe0cc54f8f97c575c7031921854fbe541dd2748e8085f2a5b013f9b05c0b01698aff\
39267a8ab6966c445e32643589208847c3d8961ab57630986c093ffa1ee248f9bdc96d\
aa419ae1b1befe4a20a7b70700f1de45c96d557fc3185ebae4ad627c25574afa8c578f\
6ba4da49251dedca776418d1fb9078ae3f29d0d670231b4faffc544c0854b3c29a2059\
24b28cfed6ac6b5216a23ef15953f0f23fa50bbb344d64df81103aaffb0578dfe905f9\
83949d16c498efef3dd3370db6e67b57bee297a832daee008b1c4e18fa05438603c2b3\
a40377be61a9afd88d223ba848843dadf0446a003666c6b365f7b36f48c3ff0bf4fb3b\
245393d22c455fdba95b5990b5d9d7c961dfa85fbeeb153c6cbc5c1a21d4ad3511089c\
1450bc2f1fd3ffcd55b7e8a86ce5a599f7a9fee0908d6f703a3f>ND end readonly put dup\
/FontName get exch definefont pop\
 -30 -200 E G 145 68 E 0.55 0.55 Q\
 G 120 30 E\
 45/MicroSoft F 114.7 475 M -5.6 0(M)A 328.9 505.2 M 327.5 491.7 L\
 T\
 G 367 73 E\
 -214 -43 E 54.772049/Times-Italic F 327.412 475 M -1.7 0(T)A\
 345.938 475 M -1.7 0(r)A 363.809 475 M -1.7 0(u)A 387.216 475 M -1.7 0(e)A\
 404.258 475 M -1.7 0(I)A 417.408 475 M -1.7 0(m)A 452.971 475 M -1.7 0(a)A\
 473.636 475 M -1.7 0(g)A 493.754 475 M -1.7 0(e)A 9/Symbol F 512.8 471.2 M\
 (\344)S\
 T\
 G 160 33 E\
 20.147827/Times-Italic F 328.818 453 M -1.5 0(P)A 337.525 453 M\
 -1.5 0(a)A 345.815 453 M -1.5 0(g)A 353.903 453 M -1.5 0(e D)A 377.277 453 M\
 -1.5 0(e)A 384.435 453 M -1.5 0(scri)A 408.720 453 M -1.5 0(p)A 417.413 453 M\
 -1.5 0(t)A 421.630 453 M -1.5 0(ion La)A 464.796 453 M -1.5 0(n)A\
 472.682 453 M -1.5 0(g)A 480.972 453 M -1.5 0(u)A 490.270 453 M -1.5 0(a)A\
 498.358 453 M -1.5 0(g)A 506.244 453 M -1.5 0(e)A\
 T\
 G 255 33 E\
 18/Times-Italic F\
 328.818 433 M -0.5 0(Version 1.11)A\
 T\
 T 196 250 E 0.7 U Q G 0.24 0.24 Q W 305.8 466.5 M\
 333.8 579 432.8 609.5 432.8 609.5 C 264 609.5 L\
 169 556.5 177.8 466.5 177.8 466.5 C 305.8 466.5 L H G 0 Y I T G\
 0.5 0 0 3.863693 N 0 Y K T W 264.5 589.5 M 247.5 579 237 565.5 237 565.5 C\
 235 565.5 273.1 565.5 273.1 565.5 C 236.1 528.5 231 486.5 231 486.5 C\
 229 486.5 261.3 486.5 261.3 486.5 C 275 543.8 309.3 565.5 309.3 565.5 C\
 334.8 565.5 L 350.8 583.3 361.8 589.5 361.8 589.5 C 264.5 589.5 L H G 1 Y I T\
 G 0.5 0 0 3.863693 N 0 Y K T W 321.7 746 M 293.7 633.5 194.7 603 194.7 603 C\
 363.5 603 L 458.5 656 449.7 746 449.7 746 C 321.7 746 L H G 1 Y I T G\
 6 0 0 3.863693 N 0 Y K T W 363 623 M 380 633.5 390.5 647 390.5 647 C\
 392.5 647 354.4 647 354.4 647 C 391.4 684 396.5 726 396.5 726 C\
 398.5 726 366.2 726 366.2 726 C 352.5 668.7 318.2 647 318.2 647 C\
 292.7 647 L 276.7 629.2 265.7 623 265.7 623 C 363 623 L H G 0 Y I T G\
 0.5 0 0 3.863693 N 0 Y K T T\
 SS restore\
 G 1 1.1 Q 880 /Times-Bold F 30 35 M 0.8 Y (T) S T\
 G 118 81 M 408 0 Z 0 488 Z -408 0 Z H G 1 Y I T 2.0 J K T\
 G 122 85 M 400 0 Z 0 480 Z -400 0 Z H 0.5 J K T\
 -54 45 E G\
 72 2.54 div U Q /Times-Roman findfont[0.6 0 0 0.51 0 0]makefont setfont\
 11.7 17.4 M FontDirectory length s10 cvs S( TrueType)S G 0.17 /Times-Roman F\
 0.1 0.25 B(TM)S T 15.4 17.4 M(Fonts)S\
 G 7 17.2 M 12.4 0 Z 0.04 J K T\
/yup 16.7 D(ITC Zapf Dingbats)/ZapfDingbats\
(ITC Zapf Chancery Medium Italic)/ZapfChancery-MediumItalic\
(ITC Bookman Light Italic)/Bookman-LightItalic\
(ITC Bookman Demi Italic)/Bookman-DemiItalic\
(ITC Bookman Demi)/Bookman-Demi(ITC Bookman Light)/Bookman-Light\
(ITC Avant Garde Gothic Book Oblique)/AvantGarde-BookOblique\
(ITC Avant Garde Gothic Demi Oblique)/AvantGarde-DemiOblique\
(ITC Avant Garde Gothic Demi)/AvantGarde-Demi\
(ITC Avant Garde Gothic Book)/AvantGarde-Book\
(Century Schoolbook Italic)/NewCenturySchlbk-Italic\
(Century Schoolbook Bold Italic)/NewCenturySchlbk-BoldItalic\
(Century Schoolbook Bold)/NewCenturySchlbk-Bold\
(Century Schoolbook Roman)/NewCenturySchlbk-Roman\
(Zapf Calligraphic Italic)/Palatino-Italic\
(Zapf Calligraphic Bold Italic)/Palatino-BoldItalic\
(Zapf Calligraphic Bold)/Palatino-Bold\
(Zapf Calligraphic Roman)/Palatino-Roman(Symbol)/Symbol\
(Times New Roman Italic)/Times-Italic\
(Times New Roman Bold Italic)/Times-BoldItalic\
(Times New Roman Bold)/Times-Bold(Times New Roman)/Times-Roman\
(Arial Narrow Oblique)/Helvetica-Narrow-Oblique\
(Arial Narrow Bold Oblique)/Helvetica-Narrow-BoldOblique\
(Arial Narrow Bold)/Helvetica-Narrow-Bold\
(Arial Narrow)/Helvetica-Narrow(Arial Oblique)/Helvetica-Oblique\
(Arial Bold Oblique)/Helvetica-BoldOblique(Arial Bold)/Helvetica-Bold\
(Arial)/Helvetica(Courier Oblique)/Courier-Oblique\
(Courier Bold Oblique)/Courier-BoldOblique(Courier Bold)/Courier-Bold\
(Courier)/Courier 35{U FontDirectory X known{U 0.4 X F 14.4 yup M\
(ABCDabcd1234!@#$)S U/Symbol eq X/ZapfDingbats eq or{0.4/Times-Roman F}if U V\
 pop 13.9 X - yup M S/yup yup 0.44 - D}{pop pop}ifelse}repeat\
 T G 158 35 E -90 rotate\
 8 /Times-Roman F\
(Microsoft is a registered trademark & TrueImage is a trademark of Microsoft\
 Corporation)U V 0 X - X 0 X - X M S T\
" ;
 * @WIN; no start page ------------ delete end here ------------
 */

#endif // DJC endif ifdef STATUS_PAGE

// DJC char FAR StartPage[]= "nop";    /*@WIN*/
// DJC changed name to avoid collision with StartPage() API
char FAR PSStartPage[] = { "nop" } ;



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\scanner.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * Revision History:
 */
/* #include "errno.h"   @WIN: Seems we use it for ERANGE definition only, so
 *                      just define it and don't include this header, since
 *                      the global variable "errno" also defined in this header
 */
#define ERANGE          34

#ifdef _AM29K
#include <stdlib.h>
#endif
#include "global.ext"
#include <stdio.h>

int errno ;

/*
**  temp. buffer definition
*/

#define MAXBUFSZ         256

struct buffer_def {
        byte   str[MAXBUFSZ] ;
        fix16  length ;
} ;

/*
**  heap definition
*/
#define  MAXHEAPBLKSZ   400

struct heap_def {
        struct heap_def FAR *next ;
        fix16  size ;
        fix16  pad ;
        byte   data[MAXHEAPBLKSZ] ;
} ;

#define  MAXPARENTDEP   224     /* max allowable parenthese depth in string */
#define  MAXBRACEDEP    48      /* max allowable brace depth in string */

/*
 *  Finite State Machine to identify Name, Integer, Radix, and Real token
 */
/* state encoding */
#define         S0      0       /* INIT */
#define         S1      1       /* SIGN */
#define         S2      2       /* DIGIT */
#define         S3      3       /* DOT */
#define         S4      4       /* NAME */
#define         S5      5       /* SIGN-DIGIT */
#define         S6      6       /* FRACTION */
#define         S7      7       /* EXPONENT */
#define         S8      8       /* EXPONENT-SIGN/DIGIT/SIGN-DIGIT */
#define         S9      9       /* DIGIT-# with valid base */
#define         S10     10      /* DIGIT-# with invalid base */
#define         S11     11      /* DIGIT-#-DIGIT with valid number */
#define         S12     12      /* DIGIT-#-DIGIT with invalid number */

/* input trig encoding */
#define         I0      0       /* + - */
#define         I1      1       /* 0 - 9 */
#define         I2      2       /* . */
#define         I3      3       /* E e */
#define         I4      4       /* # */
#define         I5      5       /* OTHER */
#define         I6      6       /* null char */

/* final state encoding */
#define         NULL_ITEM       100
#define         INTEGER_ITEM    101
#define         RADIX_ITEM      102
#define         REAL_ITEM       103
#define         NAME_ITEM       104
 /*mslin 1/25/91 begin OPT*/
#define         FRACT_ITEM      105
 /*mslin 1/25/91 end OPT*/

/*
 *  syntax rule:
 *
 *      INTEGER_ITEM <- [SIGN] [DIGIT]+
 *      FRACTION     <- [SIGN] [DIGIT]+ '.' [DIGIT]*
 *                    | [SIGN] '.' [DIGIT]+
 *      EXPONENTIAL  <- EXPONENT INTEGER
 *      EXPONENT     <- INTEGER 'E'
 *                    | INTEGER 'e'
 *                    | FRACTION 'E'
 *                    | FRACTION 'e'
 *      REAL_ITEM    <- FRACTION
 *                    | EXPONENTIAL
 *      RADIX_ITEM   <- base '#' number
 *      base         <- '2' - '36'
 *      number       <- '0' - '9' 'A' - 'Z' 'a' - 'z' (< base)
 *      NUMBER       <- INTEGER_ITEM
 *                    | REAL_ITEM
 *                    | RADIX_ITEM
 *      NAME_ITEM    <- ~ (NUMBER)
 */

#ifdef  _AM29K
const
#endif
static ubyte far  state_machine[][7] = {
 /* S0  */       { S1, S2,  S3, S4,  S4, S4,   NULL_ITEM },
 /* S1  */       { S4, S5,  S3, S4,  S4, S4,   NAME_ITEM },
 /* S2  */       { S4, S2,  S6, S7,  S9, S4,   INTEGER_ITEM },
 /* S3  */       { S4, S6,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S4  */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S5  */       { S4, S5,  S6, S7,  S4, S4,   INTEGER_ITEM },
 /*mslin 1/25/91 begin OPT*/
 /* S6        { S4, S6,  S4, S7,  S4, S4,   REAL_ITEM }, */
 /* S6  */       { S4, S6,  S4, S7,  S4, S4,   FRACT_ITEM },
 /*mslin 1/25/91 end OPT*/
 /* S7  */       { S8, S8,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S8  */       { S4, S8,  S4, S4,  S4, S4,   REAL_ITEM },
 /* S9  */       { S4, S11, S4, S11, S4, S11,  NAME_ITEM },
 /* S10 */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM },
 /* S11 */       { S4, S11, S4, S11, S4, S11,  RADIX_ITEM },
 /* S12 */       { S4, S4,  S4, S4,  S4, S4,   NAME_ITEM }
} ;

/*
 *  Macro definition
 */
#define         ISDELIMITOR(c)\
        (ISWHITESPACE(c) || ISSPECIALCH(c))

#define         EVAL_ALPHANUMER(c)\
        {\
          if (c >= '0' && c <= '9') c -= (ubyte)'0' ;\
          else if (c >= 'A' && c <= 'Z') c = c - (ubyte)'A' + (ubyte)10 ;\
          else if (c >= 'a' && c <= 'z') c = c - (ubyte)'a' + (ubyte)10 ;\
        }                                       // @WIN
#define          Crtl_C_Char     3

#define          S_MAX31            2147483647.0
#define          S_MAX31_PLUS_1     2147483648.0
#define          S_MAX32            4294967295.0

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\scanner.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
************************************************************************
*  File:        SCANNER.C
*  By:
*  Date:        Jan-05-88
*  Owner:
*
*  The scanner module provide a function to allow other module to get token
*  from file or character string.
*  The scanner read characters from the input stream and interprete them
*  until getting a complete token, oor an error occured.
*
*  The parsing is according to PostScript syntax rule.
*  Basically, this scanner is a finite state automate, and can be parsed
*  by table_driven technique.
*
*  History:
************************************************************************
*/
/*
*   Function:
*       get_token
*       get_ordstring
*       get_hexstring
*       get_packed_array
*       get_normal_array
*       get_name
*       get_integer
*       get_real
*       read_c_exec
*       hexval
*       read_c_norm
*       unread_char
*       str_eq_name
*       nstrcpy
*       putc_buffer
*       append_c_buffer
*       get_heap
*       strtol_d
*       init_scanner
*       name_to_id
*       free_name_entry
*/


// DJC added global include file
#include "psglobal.h"


#include        "scanner.h"
#include        "geiio.h"
#include        "geierr.h"
#include        "geitmr.h"              /* @GEI */

#ifdef LINT_ARGS
bool read_c_exec(byte FAR *, struct object_def FAR *) ;
bool read_c_norm(byte FAR *, struct object_def FAR *) ;
void unread_char(fix, struct object_def FAR *) ;

static bool near  get_ordstring(struct object_def FAR *,
       struct object_def FAR *, struct buffer_def FAR *) ;
static bool near  get_hexstring(struct object_def FAR *,
       struct object_def FAR *, struct buffer_def FAR *) ;
static bool near  get_packed_array(struct object_def FAR *, struct object_def FAR *) ;
static bool near  get_normal_array(struct object_def FAR *, struct object_def FAR *) ;
static bool near  get_integer(struct object_def FAR *, byte FAR *, fix, fix) ;
static bool near  get_real(struct object_def FAR *, byte FAR *) ;
static bool near  str_eq_name(byte FAR *, byte FAR *, fix) ;
static void near  nstrcpy(ubyte FAR *, ubyte FAR *, fix) ;
static bool near  putc_buffer(struct buffer_def FAR *, struct object_def FAR *) ;
static bool near  append_c_buffer(byte, struct buffer_def FAR *, struct object_def FAR *) ;
static byte FAR *  near  get_heap(void) ;
static fix32   near  strtol_d(byte FAR *, fix, fix) ;
static bool near get_fraction(struct object_def FAR *, byte FAR *);    /*@WIN*/
#else
bool read_c_exec() ;
bool read_c_norm() ;
void unread_char() ;

static bool near  get_ordstring() ;
static bool near  get_hexstring() ;
static bool near  get_packed_array() ;
static bool near  get_normal_array() ;
static bool near  get_integer() ;
static bool near  get_real() ;
static bool near  str_eq_name() ;
static void near  nstrcpy() ;
static bool near  putc_buffer() ;
static bool near  append_c_buffer() ;
static byte FAR *  near  get_heap() ;
static fix32   near  strtol_d() ;
static bool near get_fraction();    /*@WIN*/
#endif /* LINT_ARGS */

ubyte   ungeteexec[2] ;
bool16  abort_flag ;

extern ufix16   eseed, old_eseed ;
//DJC extern fix      bypass ;
extern fix32   bypass ;    //DJC fix from SC
extern xbool    itype ;
extern ybool    estate ;
/* @WIN; add prototype */
bool load_name_obj(struct object_def FAR *, struct object_def FAR * FAR *);
extern bool     read_fd(GEIFILE FAR *, byte FAR *) ;
fix hexval(byte);

extern GEItmr_t      wait_tmr;   /* jonesw */
extern fix16         waittimeout_set; /*jonesw*/
/*
**********************************************************************
*
*   This submodule read characters from the input stream, and interpret them
*   according to the PostScript syntax rule until it construct a complete
*   token or error occurs.
*
*
*   Name:       get_token
*   Called:
*   Calling:
*               read_file
*               unread_file
*               get_ordstring
*               get_hexstring
*               get_packed_array
*               get_normal_array
*               get_integer
*               get_name
*               get_real
*               name_to_id
*               alloc_vm
*               load_dict
*   Input:
*               struct object_def *: token : pointer to the token object
*               struct object_def *: inp   : pointer to input stream
*   Output:
*               return value : TRUE - OK, FALSE - fail
*               token : result token object
**********************************************************************
*/
bool
get_token(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    static bool8   begin_mark = 0 ;       /* >0 - procedure mark was parsed */
    //DJC byte  ch = 0 ;                        /* input char */
    ubyte  ch = 0 ;                        /* input char */ //DJC fix from SC
    GEIFILE FAR *l_file ;
    struct buffer_def  buffer ;

    /* ?? check file closed or not */
    if ( TYPE(inp) == FILETYPE ) {      /* ?? */
        l_file = (GEIFILE FAR *)VALUE(inp) ;
        if( (! GEIio_isopen(l_file)) ||
            ((ufix16)GEIio_opentag(l_file) != LENGTH(inp)) ) { //@WIN
            GEIio_clearerr(l_file) ;
            GEIclearerr() ;
            begin_mark = 0 ;
            TYPE_SET(token, EOFTYPE) ;
            return(TRUE) ;              /* EOF */
        }
    }

/* qqq, begin */
    /* RAM = 0
    LEVEL_SET(token, current_save_level);
    ROM_RAM_SET(token, RAM);             |* reset unused token fields *|
    */
    token->bitfield = 0;
    LEVEL_SET(token, current_save_level);
/* qqq, end */

    for ( ; ;) {
        if (!READ_CHAR(&ch, inp)) {
            if ( TYPE(inp) == FILETYPE ) {      /* ?? */
                GEIio_clearerr((GEIFILE FAR *)VALUE(inp)) ;
                GEIclearerr() ;
            }
            begin_mark = 0 ;
            TYPE_SET(token, EOFTYPE) ;
            return(TRUE) ;              /* EOF */
        }

        /*
         ** skip White_spaces (LF, CR, FF, SP, TAB, \0).
         */
        if( ISWHITESPACE(ch) )
            continue ;

        /*
        ** find the tokens (Comment, String, Procedure, Name, Number).
        */
        switch (ch) {

        /* skip Comment token */
        case '%' :
            /* ignore following characters until newline */
            if( estate == NON_EEXEC ) {
                if (TYPE(inp) == STRINGTYPE) {
                    while( (inp->length) && (! ISLINEDEL(*(byte FAR *)inp->value)) ) {
                        inp->length-- ;
                        inp->value++ ;
                    }
                    if( inp->length ) {
                        inp->length-- ;
                        inp->value++ ;
                    }
                } else {                /* type == FILETYPE */
                    GEIFILE FAR *l_file ;

                    l_file = (GEIFILE FAR *)VALUE(inp) ;
                    if((ufix16)GEIio_opentag(l_file) != LENGTH(inp) ) //@WIN
                        break ;

                    do {
                        if ( ! read_fd(l_file, &ch) )
                            break ;      /* EOF */
                    } while ( ! ISLINEDEL(ch) ) ;
                }
            } else {
                do {
                    if (! READ_CHAR(&ch, inp))
                        break ;          /* EOF */
                } while ( ! ISLINEDEL(ch) ) ;
                /* ?? CR-NL */
            }
            break ;

        /* get a String token */
        case '(' :      /* in normal string form */
        case '<' :      /* in hex digit string form */
        {
            //DJCbyte  huge *orig_vmptr ;            /*@WIN*/
            byte FAR *orig_vmptr ;            /*@WIN*/ //DJC fix from SC
            bool  tt ;

            buffer.length = 0 ;
            token->length = 0 ;
            token->value = NIL ;
#ifdef _AM29K
                  if (waittimeout_set==1)
                  {
                    waittimeout_set=0;
                    GEItmr_stop(wait_tmr.timer_id);
                  }
#endif  /* _AM29K */
            orig_vmptr = vmptr ;       /* @WIN save current VM */
            if (ch == '(')
                tt = get_ordstring(token, inp, &buffer) ;
            else
                tt = get_hexstring(token, inp, &buffer) ;

            if (tt) {
                if (buffer.length != 0)
                    if (!putc_buffer(&buffer, token)) {
                        //DJC vmptr = orig_vmptr ;       /* restore VM */
                        free_vm(orig_vmptr); //DJC fix from SC
                        goto error ;
                    }
                /* initialize the string token */
                TYPE_SET(token, STRINGTYPE) ;
                ATTRIBUTE_SET(token, LITERAL) ;
                ACCESS_SET(token, UNLIMITED) ;
                return(TRUE) ;
            } else {
                //DJC vmptr = orig_vmptr ;            /* restore VM */
                free_vm(orig_vmptr);     //DJC fix from SC
                goto error ;
            }
        }

        /* end-of-string mark */
        case ')' :      /* syntax error */
        case '>' :      /* syntax error */
            ERROR(SYNTAXERROR) ;
            goto error ;

        /* get a Procedure */
        case '{' :
            if ((begin_mark++) > MAXBRACEDEP) {
                ERROR(SYNTAXERROR) ;
                goto error ;
            }
            token->length = 0 ;
            token->value = NIL ;
            if (packed_flag) {
                if (!get_packed_array(token, inp))
                    goto error ;
                TYPE_SET(token, PACKEDARRAYTYPE) ;
                ACCESS_SET(token, READONLY) ;
            } else {
                if (!get_normal_array(token, inp))
                    goto error ;
                TYPE_SET(token, ARRAYTYPE) ;
                ACCESS_SET(token, UNLIMITED) ;
            }
            ATTRIBUTE_SET(token, EXECUTABLE) ;
            return(TRUE) ;

        /* end-of-procedure mark */
        case '}' :
            if (begin_mark) {
                begin_mark-- ;
                TYPE_SET(token, MARKTYPE) ;
                return(TRUE) ;
            } else {
                ERROR(SYNTAXERROR) ;
                goto error ;
            }

        /* begin-of-array mark */
        /* end-ofarray mark */
        case '[' :
        case ']' :
            buffer.str[0] = ch ;
            buffer.length = 1 ;
            ATTRIBUTE_SET(token, EXECUTABLE) ;
            if (get_name(token, buffer.str, 1, TRUE)) {
                return(TRUE) ;
            } else
                goto error ;

        /* get a literal name or immediate name */
        case '/' :
        {
            fix   ll, ml, attri ;

            ll = 0 ; ml = MAXBUFSZ - 1 ;
            attri = LITERAL ;
            if (!READ_CHAR(&ch, inp))
                buffer.str[ll] = 0 ;
            else {
                if (ch == '/') {
                    attri = IMMEDIATE ;
                    if (!READ_CHAR(&ch, inp)) {
                        buffer.str[ll] = 0 ;
                        goto xx ;
                    } else if (ISDELIMITOR(ch)) {
                        buffer.str[ll] = 0 ;
                        unread_char(ch, inp) ;
                        goto xx ;
                   } else
                        buffer.str[ll++] = ch ;
                } else if (ISDELIMITOR(ch)) {
                    buffer.str[ll] = 0 ;
                    unread_char(ch, inp) ;
                    goto xx ;
                } else
                    buffer.str[ll++] = ch ;
                while (1) {
                    if (!READ_CHAR(&ch, inp))
                        break ;
                    if (ISDELIMITOR(ch)) {
                        unread_char(ch, inp) ;
                        break ;
                    } else if (ll < ml)
                        buffer.str[ll++] = ch ;
                }   /* while */
            }   /* else */
         xx:
            ATTRIBUTE_SET(token, attri) ;
            if (get_name(token, buffer.str, ll, TRUE))
                return(TRUE) ;
            else
                goto error ;
        }

        /*
        ** get a Name, Decimal Integer, Radixal Integer, and Real token
        */

        default :
        {
            fix   ll, ml, i ;
            fix   radix, base, state, input ;
            fix   c1;                           // @WIN byte => fix
            byte  FAR *pp, FAR *ps ;

            ll = 0 ; ml = MAXBUFSZ - 1 ;
            do {
                if (ll < ml)
                    buffer.str[ll++] = ch ;
                if (!READ_CHAR(&ch, inp))
                    break ;
                if (ISDELIMITOR(ch)) {
                    unread_char(ch, inp) ;
                    break ;
                }
            } while (1) ;
            buffer.str[ll++] = 0 ;      /* null char */
            pp = ps = buffer.str ;
            radix = base = 0 ;
            state = S0 ;

            for (i = 0 ; i < ll ; i++) {

                switch ((c1 = *(pp+i))) {
                /* SIGN */
                case '+' :
                case '-' :
                    input = I0 ; break ;

                /* DOT */
                case '.' :
                    input = I2 ; break ;

                /* EXP */
                case 'E' :
                case 'e' :
                    if (state == S9 || state == S11) {
                        if (c1 == 'E') c1 = c1 - 'A' + 10 ;
                        else if (c1 == 'e') c1 = c1 - 'e' + 10 ;
                        if ((fix)c1 < base) state = S11 ;
                        else state = S12 ;
                        continue ;
                    } else {       /* other state */
                        input = I3 ; break ;
                    }

                /* RADIX */
                case '#' :
                    if (state == S2) {
                        if (radix <= 2 && radix > 0 &&
                                         base <= 36 && base >= 2) {
                            ps = &pp[i + 1] ;
                            state = S9 ;
                        } else state = S10 ;
                        continue ;
                    } else {          /* other state */
                        input = I4 ; break ;
                    }

                /* null char */
                case '\0':
                    input = I6 ; break ;

                /* OTHER */
                default :
                    if (c1 >= '0' && c1 <= '9') {
                        c1 -= '0' ;
                        if (state == S0 || state == S2) {
                            base = base * 10 + c1 ;
                            radix++ ; input = I1 ; break ;
                        } else if (state == S9 || state == S11) {
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I1 ; break ;
                        }
                    } else if (c1 >= 'A' && c1 <= 'Z') {
                        if (state == S9 || state == S11) {
                            c1 = c1 - 'A'+ 10 ;
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I5 ; break ;
                        }
                    } else if (c1 >= 'a' && c1 <= 'z') {
                        if (state == S9 || state == S11) {
                            c1 = c1 - 'a'+ 10 ;
                            if ((fix)c1 < base) state = S11 ;
                            else state = S12 ;
                            continue ;
                        } else {       /* other state */
                            input = I5 ; break ;
                        }
                    } else {          /* other char */
                        input = I5 ; break ;
                    }
                } /* switch */
                state = state_machine[state][input] ;   /* get next state */
/* qqq, begin */
            /*
            }   |* for *|
            */
                if( state == S4 ) {
                    P1_ATTRIBUTE_SET(token, P1_EXECUTABLE);
                    if (get_name(token, ps, ll - 1, TRUE))
                        return(TRUE);
                    else
                        goto error;
                }
            }   /* for */
/* qqq, end */

            if (state == NAME_ITEM) {
                ATTRIBUTE_SET(token, EXECUTABLE) ;
                if (get_name(token, ps, ll - 1, TRUE))
                    return(TRUE) ;
                else
                    goto error ;
            } else if (state == INTEGER_ITEM)
                return(get_integer(token, ps, 10, TRUE)) ;
/*mslin, 1/24/91 begin OPT*/
            else if (state == FRACT_ITEM)
                return(get_fraction(token, ps));
/*mslin, 1/24/91 end OPT*/
            else if (state == REAL_ITEM)
                return(get_real(token, ps)) ;
            else if (state == RADIX_ITEM) {
            /*
             * if it can't be integer, it is name object
             */
                if (!get_integer(token, ps, base, FALSE)) {
                    ATTRIBUTE_SET(token, EXECUTABLE) ;
                    if (get_name(token, pp, ll - 1, TRUE))
                        return(TRUE) ;
                    else
                        goto error ;
                } else  /* integer objecj */
                    return(TRUE) ;
            } else
                return(FALSE) ;
        }   /* default */
        }   /* switch */
    }   /* for */

 error:
    begin_mark = 0 ;          /* clear begin_marg */

    return(FALSE) ;
}   /* get_token */

/*
**********************************************************************
*   This submodule reads the input character string and constructs a
*   string object.
*
*   Name:       get_ordstring
*   Called:
*   Calling:
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*               struct buffer_def *: buffer: pointer to temp. buffer
*   Output:
*               return value: TRUE - OK, FALSE - VM full or EOF.
*               token: valid string object
*
**********************************************************************
*/
static bool near
get_ordstring(token, inp, buffer)
struct object_def FAR *token, FAR *inp ;
struct buffer_def FAR *buffer ;
{
    byte ch, code, l_c ;
    fix   parent_depth, digit_no ;

    parent_depth = 1 ;
   /*
    ** read characters of the string if EOF is not encountered
    */
    while (READ_CHAR(&ch, inp)) {

    begun:
        if (ch == '\\' && (TYPE(inp) == FILETYPE)) {
            /* special treatment for escape sequence */

            if (!READ_CHAR(&ch, inp)) goto error ;

            switch (ch) {
            case '\\':  ch = '\\' ; break ;
            case 'n' :  ch = '\n' ; break ;
            case 't' :  ch = '\t' ; break ;
            case 'r' :  ch = '\r' ; break ;
            case 'b' :  ch = '\b' ; break ;
            case 'f' :  ch = '\f' ; break ;
            case '(' :  ch = '(' ; break ;
            case ')' :  ch = ')' ; break ;
            /* erik chen 10-19-1990 */
            case '\r':  if(READ_CHAR(&ch, inp)) {
                            if( ch != '\n' )
                                unread_file(ch, inp) ;
                        }
                        else
                            goto error ;
                        continue ;
            case '\n':  continue ;
            default :
                /* special treatment for \ddd */
                if (ch >= '0' && ch < '8') {    /* is_oct_digit(ch) */
                    digit_no = 1 ;
                    code = ch - (byte)'0' ;     //@WIN
                    while (READ_CHAR(&ch, inp)) {
                        if (ch >= '0' && ch < '8' && digit_no++ < 3)
                            code = code * (byte)8 + ch - (byte)'0' ; //@WIN
                        else {
                            if (!append_c_buffer(code, buffer, token))
                                return(FALSE) ;
                            goto begun ;
                        }
                    } /* while */
                    goto error ;
                } /* if */
            } /* switch */
            if (!append_c_buffer(ch, buffer, token)) return(FALSE) ;
        } else if (ch == ')') {
            if (!(--parent_depth))
                return(TRUE) ;
            else if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        } else if (ch == '(') {
        /*
         * special treatment for the nested parenthese.
         */
            if ((parent_depth++) > MAXPARENTDEP) /* MAXPARENTDEP = 224 */
                goto error ;
            else if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        } else {         /* for other chars */
            if( ch == '\r' ) {
                ch = '\n' ;
                /* read char from general routine instead of from file @WIN */
                //DJC if( read_fd((GEIFILE FAR *)VALUE(inp), &l_c) ) {
                //DJC    if( l_c != '\n' )
                //DJC        unread_file(l_c, inp) ;
                if( READ_CHAR( &l_c, inp)) {
                   if (l_c != '\n' )
                     unread_char(l_c,inp);

                } else
                    return(FALSE) ;
            }

            if (!append_c_buffer(ch, buffer, token))
                return(FALSE) ;
        }
    } /* while */
 error:
    ERROR(SYNTAXERROR) ;

    return(FALSE) ;
}   /* get_ordstring */

/*
**********************************************************************
*   This submodule reads hex digits to construct a string object.
*
*   Name:       get_hexstring
*   Called:
*   Calling:
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*               struct buffer_def *: buffer: pointer to temp. buffer
*   Output :
*               return value: TRUE - OK, FALSE - VM full or EOF.
*               token: valid string object
**********************************************************************
*/
static near
get_hexstring(token, inp, buffer)
struct object_def FAR *token, FAR *inp ;
struct buffer_def FAR *buffer ;
{
    byte    ch ;
    byte    cl = 0;
    bool8   hex_pair = FALSE ;

   /*
    ** read characters of the string if EOF is not encountered !
    */
    while (READ_CHAR(&ch, inp)) {
        if (ISHEXDIGIT(ch)) {
            if (hex_pair) {
                ch = (byte)EVAL_HEXDIGIT(ch) + cl ;     //@WIN
                if (!append_c_buffer(ch, buffer, token))
                   return(FALSE) ;         /* VM full */
                hex_pair = FALSE ;
            } else {
                hex_pair = TRUE ;
                cl = (byte)(EVAL_HEXDIGIT(ch) << 4);    //@WIN
            }
        } else if (ISWHITESPACE(ch)) continue ;
        else if (ch == '>') {
            if (hex_pair) {
                if (!append_c_buffer(cl, buffer, token))
                    return(FALSE) ;         /* VM full */
            }
            return(TRUE) ;
        } else  /* other chars */
            break ;                        /* syntax error */
    } /* while */
    ERROR(SYNTAXERROR) ;

    return(FALSE) ;
}   /* get_hexstring */

/*
**********************************************************************
*   This submodule reads characters from the input stream and constructs
*   an packed array object.
*
*   Name:       get_packed_array
*   Called:
*   Calling:
*               get_token
*               alloc_vm
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*   Output:
*               return value: TRUE - OK, FALSE - VM full
*               token: packed array object
**********************************************************************
*/
static bool near
get_packed_array(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    struct heap_def  huge *cur_heap,  huge *first_heap ;
    struct object_def ttemp ;
/*  byte   huge *p,  huge *temptr,  huge *old_heap ; pj 4-18-1991 */
    byte   huge *p,  huge *old_heap ;
    ubyte  nobyte, packed_header ;
    fix16  l_size ;

    old_heap = vmheap ;
/*  cur_heap = first_heap = (struct heap_def huge *)get_heap() ; pj 4-30-1991 */
    cur_heap = (struct heap_def huge *)get_heap() ;
    if (cur_heap == (struct heap_def FAR *)NIL)
        return (FALSE);
    else
        first_heap = cur_heap ;

    /*
    ** get tokens and store them in heap temp. blocks first, if encounter
    ** end-of-mark '}', copy all objects in this specific array, from heap
    ** temp. blocks into VM
    */
    while (get_token(&ttemp, inp)) {

        if (TYPE(&ttemp) == EOFTYPE) { /* erik chen 5-1-1991 */
            ERROR(SYNTAXERROR) ;
            abort_flag = 1;
            return(FALSE);
        }

        if (TYPE(&ttemp) == MARKTYPE) {
            /*
            ** the end-of-array mark is encondered,
            ** copy the tokens in temporary buffers into VM
            */
            /* pj 4-18-1991 begin
            cur_heap = first_heap ; temptr = NIL ;
            while (cur_heap != NIL) {
                if ((p = (byte huge *)alloc_vm((ufix32)cur_heap->size)) != NIL) {
                    if (temptr == NIL) temptr = p ;
                    nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                    cur_heap = cur_heap->next ;
                } else {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                }
            } |* while *|
            if (VALUE(token) == NIL) token->value = (ufix32)temptr ; */
            l_size = 0;
            cur_heap = first_heap ;
            while (cur_heap != NIL) {
                l_size += cur_heap->size;
                cur_heap = cur_heap->next ;
            }
            if ((p = (byte huge *)alloc_vm((ufix32)l_size)) == NIL) {
                free_heap(old_heap) ;
                return(FALSE) ;
            }
            cur_heap = first_heap ;
            if (VALUE(token) == NIL) token->value = (ULONG_PTR)p ;
            while (cur_heap != NIL) {
                nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                p += cur_heap->size;
                cur_heap = cur_heap->next ;
            } /* while */
            /* pj 4-18-1991 end */
            free_heap(old_heap) ;
            return(TRUE) ;
        } else {
            token->length++ ;
            switch (TYPE(&ttemp)) {
            case NAMETYPE :
                nobyte = 2 ;
                if (ATTRIBUTE(&ttemp) == LITERAL)
                    packed_header = LNAMEPACKHDR ;
                else   /* EXECUTABLE */
                    packed_header = ENAMEPACKHDR ;
                break ;
            case OPERATORTYPE :
                nobyte = 2 ;
                packed_header = OPERATORPACKHDR ;
                break ;
            case INTEGERTYPE :
                if ((fix32)ttemp.value <= 18 && (fix32)ttemp.value >= -1) {
                    nobyte = 1 ;
                    packed_header = SINTEGERPACKHDR ;
                } else {
                    nobyte = 5 ;
                    packed_header = LINTEGERPACKHDR ;
                }
                break ;
            case REALTYPE :
                nobyte = 5 ;
                packed_header = REALPACKHDR ;
                break ;
            case FONTIDTYPE :
                nobyte = 5 ;
                packed_header = FONTIDPACKHDR ;
                break ;
            case NULLTYPE :
                nobyte = 5 ;
                packed_header = NULLPACKHDR ;
                break ;
            case MARKTYPE :
                nobyte = 5 ;
                packed_header = MARKPACKHDR ;
                break ;
            case BOOLEANTYPE :
                nobyte = 1 ;
                packed_header = BOOLEANPACKHDR ;
                break ;
            default :   /* Array, Packedarray, Dictionary, File, String, Save */
                nobyte = 9 ;
                packed_header = _9BYTESPACKHDR ;
            } /* switch */

            if ((MAXHEAPBLKSZ - cur_heap->size) < (fix)nobyte) { //@WIN
                if ((p = (byte huge *)get_heap()) == NIL) {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                } else
                    cur_heap = cur_heap->next = (struct heap_def huge *)p ;
            }

            if (nobyte == 2) {         /* Name/Operator object */
                ufix16  i ;
                ubyte   obj_type ;

                if (TYPE(&ttemp) == OPERATORTYPE) {
                    i = LENGTH(&ttemp) ;
                    obj_type = (ubyte)ROM_RAM(&ttemp) ;
                    obj_type <<= 3 ;
                } else {       /* NAMETYPE */
                    i = (ufix16)VALUE(&ttemp) ;
                    obj_type = 0 ;
                }
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) =
                             ((ubyte)(i >> 8)) | packed_header | obj_type ;
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) = (ubyte)i ;

            } else if (nobyte == 1) {  /* Integer/Boolean object */
                if (TYPE(&ttemp) == INTEGERTYPE)
                    ttemp.value++ ; /* -1 ~ 18 ==> 0 ~ 19 */
                *((ubyte FAR *)&cur_heap->data[cur_heap->size++]) =
                             ((ubyte)ttemp.value) | packed_header ;
            } else if (nobyte == 5) {  /* Integer/Real/Fontid/Null/Mark object */
                ubyte   huge *l_stemp, huge *l_dtemp ;

                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size++] ;
                *l_dtemp++ = packed_header ;
                l_stemp = (ubyte FAR *)&VALUE(&ttemp) ;
                COPY_PK_VALUE(l_stemp, l_dtemp, ufix32) ;
                cur_heap->size += sizeof(ufix32) ;
            } else {  /* Array/Packedarray/Dictionary/File/String/Save object */
                ubyte   huge *l_stemp, huge *l_dtemp ;

                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size++] ;
                *l_dtemp++ = packed_header ;
                l_stemp = (ubyte FAR *)&ttemp ;
                COPY_PK_VALUE(l_stemp, l_dtemp, struct object_def ) ;
                l_dtemp = (ubyte FAR *)&cur_heap->data[cur_heap->size] ;
                LEVEL_SET_PK_OBJ(l_dtemp, current_save_level) ;
                cur_heap->size += sizeof(struct object_def) ;
            }
        } /* else */
    } /* while */
    free_heap(old_heap) ;

    return(FALSE) ;
}   /* get_packed_array */

/*
**********************************************************************
*   This submodule reads characters from the input stream and constructs
*   an array object.
*
*   Name:       get_normal_array
*   Called:
*   Calling:
*               get_token
*               alloc_vm
*   Input:
*               struct object_def *: token: pointer to a token object
*               struct object_def *: inp: pointer to input token
*   Output:
*               return value: TRUE - OK, FALSE - VM full
*               token: array object
**********************************************************************
*/
static bool near
get_normal_array(token, inp)
struct object_def FAR *token, FAR *inp ;
{
    struct heap_def  huge *cur_heap,  huge *first_heap ;
    struct object_def ttemp ;
    byte   huge *p,  huge *temptr,  huge *old_heap ;

    old_heap = vmheap ;
/*  cur_heap = first_heap = (struct heap_def huge *)get_heap() ; pj 4-30-1991 */
    cur_heap = (struct heap_def huge *)get_heap() ;
    if (cur_heap == (struct heap_def FAR *)NIL)
        return (FALSE);
    else
        first_heap = cur_heap ;


    /*
    ** get tokens and store them in heap temp. blocks first, if encounter
    ** end-of-mark '}', copy all objects in this specific array, from heap
    ** temp. blocks into VM
    */
    while (get_token(&ttemp, inp)) {

        if (TYPE(&ttemp) == EOFTYPE) { /* erik chen 5-1-1991 */
            ERROR(SYNTAXERROR) ;
            abort_flag = 1;
            return(FALSE);
        }

        if (TYPE(&ttemp) == MARKTYPE) {
            /*
            ** the end-of-array mark is encondered,
            ** copy the tokens in temporary buffers into VM
            */
            cur_heap->next = NIL ;
            cur_heap = first_heap ; temptr = NIL ;
            while (cur_heap != NIL) {
                if ((p = (byte huge *)alloc_vm((ufix32)cur_heap->size)) != NIL) {
                    if (temptr == NIL) temptr = p ;
                    nstrcpy((ubyte FAR *)cur_heap->data, (ubyte FAR *)p, cur_heap->size) ;
                    cur_heap = cur_heap->next ;
                } else {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                }
            } /* while */
            if (VALUE(token) == NIL) token->value = (ULONG_PTR)temptr ;
            free_heap(old_heap) ;
            return(TRUE) ;
        } else {
            struct object_def  FAR *pp ;

            token->length++ ;
            if ((MAXHEAPBLKSZ - cur_heap->size) < sizeof(struct object_def)) {
                if ((p = (byte huge *)get_heap()) == NIL) {
                    free_heap(old_heap) ;
                    return(FALSE) ;
                } else
                    cur_heap->next = (struct heap_def huge *)p ;
                    cur_heap = (struct heap_def huge *)p ;
            }
            pp = (struct object_def FAR *)&cur_heap->data[cur_heap->size] ;
            COPY_OBJ(&ttemp, pp) ;
            LEVEL_SET(pp, current_save_level) ;
            cur_heap->size += sizeof (struct object_def) ;
        } /* else */
    } /* while */
    free_heap(old_heap) ;

    return(FALSE) ;
}   /* get_normal_array */

/*
**********************************************************************
*   This submodule construct a name object, or search the dict. and load
*   the associated value object
*
*   Name ;       get_name
*   Called:
*   Calling:
*               load_dict
*   Input:
*               struct object_def *: token: pointer to a token object
*               byte *: string: pointer to the name string
*               ufix16: len: length of the name string
*               bool8: isvm: TRUE - copy the name string into VM,
*                            FALSE - otherwise.
*
*   Output:
*               return value: TRUE - OK, FALSE -  VM full, name_table full,
*                             (no# of char) > MAXNAMESZ, or null associated
*                             value object
*               token: name object
**********************************************************************
*/
bool
get_name(token, string, len, isvm)
struct object_def FAR *token ;
byte   FAR *string ;
ufix    len ;
bool8   isvm ;
{
    struct object_def FAR *result ;
    fix16  hash_id ;

    if (len >= MAXNAMESZ) {
        ERROR(LIMITCHECK) ;
        return(FALSE) ;
    }

    /* convert the string of the name to the name ID */
    if (name_to_id(string, len, &hash_id, isvm)) {
        token->value = hash_id ;
        token->length = 0 ;
        TYPE_SET(token, NAMETYPE) ;
/* qqq, begin */
        /*
        ACCESS_SET(token, 0);
        if (ATTRIBUTE(token) == IMMEDIATE) {
            if (!load_dict(token, &result)) {
                if( (ANY_ERROR() == UNDEFINED) && (FRCOUNT() >= 1) ) {
        */
        P1_ACC_UNLIMITED_SET(token);
        if( P1_ATTRIBUTE(token) == P1_IMMEDIATE) {
            if( ! load_name_obj(token, &result) ) {
                if( (ANY_ERROR() == UNDEFINED) && (FR1SPACE()) ) {
/* qqq, end */
                    PUSH_OBJ(token) ;
                    return(FALSE) ;
                }
            }
            else
                COPY_OBJ(result, token) ;
        }
        return(TRUE) ;
    } else
        return(FALSE) ;
}   /* get_name */

/*
**********************************************************************
*   This submodule convert a string to an integer object, a real object
*   if it can't be represented in integer form
*
*   Name:       get_integer
*   Called:
*   Calling:
*               strtol_d
*               strtod
*   Input:
*               struct object_def *: token: pointer to token object
*               byte *: string: pointer to integer string
*               fix16: base: base of this integer number
*               fix16: isint: TRUE - invoked from normal integer,
*                             FALSE - invoked from radix integer
*   Output:
*               token: integer object
**********************************************************************
*/
static bool near
get_integer(token, string, base, isint)
struct object_def FAR *token ;
byte   FAR *string ;
fix    base, isint ;
{
    fix32   l ;

    errno = 0 ;
    l = strtol_d(string, base, isint) ;
    if (errno == ERANGE) {
        errno = 0 ;
        if (isint)
            return(get_real(token, string)) ;
        else
            return(FALSE) ;
    }
    TYPE_SET(token, INTEGERTYPE) ;
    ACCESS_SET(token, 0) ;
    ATTRIBUTE_SET(token, LITERAL) ;
    token->value = l ;
    token->length = 0 ;

    return(TRUE) ;
}   /* get_integer */

/*mslin, 1/24/91 begin OPT*/
/*
************************************************************************
*   This submodule convert a string to a real object
*
*   Name:       get_fraction
*   Called:
*   Calling:
*   Input:
*           1. token  : pointer to token object
*           2. string : pointer to real string
*
*   Output:
*           1. token  : real object
*   history: added by mslin, 1/25/91 for performance optimization
*************************************************************************/
real32  get_real_factor[10] = {(real32)1.0, (real32)10.0, (real32)100.0,
                (real32)1000.0, (real32)10000.0, (real32)100000.0,
                (real32)1000000.0, (real32)10000000.0, (real32)100000000.0,
                (real32)1.000000000};
static bool near get_fraction(token, string)
struct object_def FAR *token;
byte   FAR *string;
{
    union four_byte  result;
    ufix32      result_1;
    byte        sign = 0, c;
    fix         i,j;
    byte        FAR *str;   /* erik chen 5-20-1991 */

        result_1 = 0;
        if ((c = *string) == '+')
            string++;
        else if (c == '-') {
            str = string;       /* erik chen 5-20-1991 */
            string++; sign++;
        }

        for (i = 0; (c = *(string+i)) != '.'; i++) {
                result_1 = (result_1 << 3) +
                           result_1 + result_1 + EVAL_HEXDIGIT(c) ;
        }   /* for */

/*      if(i > 9)
                return(get_real(token, string)); erik chen 5-20-1991 */

        if(i > 9)
            if(sign)
                return(get_real(token, str));
            else
                return(get_real(token, string));

        for (j = i+1; c = *(string+j); j++) {
                result_1 = (result_1 << 3) +
                           result_1 + result_1 + EVAL_HEXDIGIT(c) ;
        }   /* for */

        i = j - i -1;
/*      if(j > 10)
                return(get_real(token,  string)); erik chen 5-20-1991 */
        if(j > 10)
            if(sign)
                return(get_real(token, str));
            else
                return(get_real(token,  string));

        if(sign)
                result.ff =  -(real32)result_1 / get_real_factor[i];
        else
                result.ff =  (real32)result_1 / get_real_factor[i];

    TYPE_SET(token, REALTYPE);
    P1_ACC_UNLIMITED_SET(token);             /* rrr */
    P1_ATT_LITERAL_SET(token);            /* rrr */
    token->value = result.ll;
    token->length = 0;
    return(TRUE);
}   /* get_fraction */
/*mslin, 1/24/91 end OPT*/
/*
**********************************************************************
*   This submodule convert a string to a real object
*
*   Name:       get_real
*   Called:
*   Calling:
*               strtod
*   Input:
*               struct object_def *: token: pointer to token object
*               byte *: string: pointer to real string
*   Output:
*               token: integer object
**********************************************************************
*/
static bool near
get_real(token, string)
struct object_def FAR *token ;
byte   FAR *string ;
{
    union four_byte  result ;
    real64 x;   //strtod();     @WIN; take it out, defined in global.ext

    byte   FAR *stopstr ;

    errno = 0 ;
    x = strtod(string, &stopstr) ;       /* convert to real number */
    if (errno == ERANGE) {
        ubyte  underflow, c ;
        fix    i ;

        errno = 0 ;
        for (i = underflow = 0 ; c = *(string+i) ; i++)
            if ((c == 'E' || c == 'e') && (*(string+i+1) == '-')) {
                underflow++ ; break ;
            }
        if (underflow)
            result.ff = (real32)0.0 ;         /* underflow */
        else
            result.ll = INFINITY ;         /* overflow */
    } else if (x == 0.0)
        result.ff = (real32)0.0 ;
    else if (x > 0.0) {
        if (x > EMAXP)
            result.ll = INFINITY ;
        else
            result.ff = (real32)x ;
    } else {
        if (x < EMINN)
            result.ll = INFINITY ;
        else
            result.ff = (real32)x ;
    }
    TYPE_SET(token, REALTYPE) ;
    ACCESS_SET(token, 0) ;
    ATTRIBUTE_SET(token, LITERAL) ;
    token->value = result.ll ;
    token->length = 0 ;

    return(TRUE) ;
}   /* get_real */

/*
**********************************************************************
*   This submodule reads a character from a file or a string object and
*   return the character to the caller.  If in EEXEC state, the character
*   will be decrypted.
*
*   Name:       read_c_exec
*   Called:
*   Calling:
*               read_file
*               read_c
*               hexval
*   Input:
*               byte *: c
*               struct object_def *: inp: object which is the source of the input stream
*               bool16: over: TRUE - throw away the last read char
*                             FALSE - keep the last read char
*   Output:
*               c: character has been readed
*               return value: TRUE - OK, FALSE - EOF or end_of_string.
**********************************************************************
*/
bool
read_c_exec(c, inp)
byte FAR *c ;
struct object_def FAR *inp ;
{
    static  byte ch[8] ;
    static  fix header, count ;
    ufix16  input ;
    byte    junk ;
    fix     i ;
    bool    tmp ;
    byte    output = 0 ;

    /*
    * eexec read char
    */
    if (itype == UNKNOWN) {
        for (i = 0 ; i < 8 ; i++)
            ch[i] = '\0' ;
        header = 0 ;
        while( (tmp=read_c_norm(&junk, inp)) ) {       /* skip white space */
            //DJCif( ! ISEEXECWSPACE(junk) ) {
            if( ! ISEEXECWSPACE((ubyte)junk) ) {
                ch[header++] = junk ;
                break ;
            }
        }

        /* ?? tmp == FALSE: timeout, eof, ^C...  */

        for (i = 1 ; (i < 8) && read_c_norm(&ch[header], inp) ; i++, header++) ;
        header = header - 1 ;
        count = 0 ;
        itype = HEX_DATA ;
        for (i = 0 ; i <= header ; i++) {       /* determine type of input data */
            if( hexval(ch[i]) == -1 ) {
                itype = FULL_BINARY ;
                break ;
            }
        }
    }

    /*
    * read a char
    */
    input = 0 ;
    junk = '\0' ;
    do {
        tmp = FALSE ;
        if (itype == FULL_BINARY) {
            if (count <= header) {
                tmp = TRUE ;
                input = ch[count++] ;
                input = 0x00ff & input ;
            } else if (header >= 7) {
#ifdef DJC
                tmp = read_c_norm((char FAR *)(&input) + 1, inp) ;
                input = 0x00ff & input ;
                ungeteexec[0] = (ubyte)input ;          //@WIN
#endif
                //DJC fix from history.log UPD038
                tmp = read_c_norm(ungeteexec, inp) ;
                input = 0x00ff & ungeteexec[0];
            }
        } else {
            if( count <= header ) {
                tmp = TRUE ;
                input = (ufix16)hexval(ch[count++]) ;
                input = (input << 4) + hexval(ch[count++]) ;
            } else if( header >= 7 ) {
                while( (tmp=read_c_norm(&junk, inp)) ) {
                    if( hexval(junk) == -1 )
                        continue ;
                    else
                        break ;
                }
                ungeteexec[1] = (ubyte)hexval(junk) ;   //@WIN
                input = ungeteexec[1] ;
                while( (tmp=read_c_norm(&junk, inp)) ) {
                    if( hexval(junk) == -1 )
                        continue ;
                    else
                        break ;
                }
                ungeteexec[0] = (ubyte)hexval(junk) ;   //@WIN
                input = (input << 4) + ungeteexec[0] ;
            }
        }
        if (tmp == TRUE) {
            /* decryption */
            output = (char)(input ^ (eseed >> 8)) ;
            old_eseed = eseed ;                          /* for unread */
            eseed = (input + eseed) * 0xce6d + 0x58bf ;
        }
    } while ( bypass-- > 0 ) ;

    /*
    * ending
    */
    *c = output ;
    return (tmp) ;
}   /* read_c_exec */

/*
**********************************************************************
*   This submodule converts a hex-character to its hex value, for
*   non-hex-character, return -1.
*
*   Name:       hexval
*   Called:
*   Calling:
*   Input:
*               byte: c: a character
*   Output:
*               return value : for hex-char 1 - 16, others -1
**********************************************************************
*/
fix hexval(c)
byte c ;
{
    if( ISHEXDIGIT(c) )
        return(EVAL_HEXDIGIT(c)) ;
    else
        return(-1) ;
}   /* hexval */

/*
**********************************************************************
*   This submodule reads a character from a file or a string object and return
*   the character to the caller.
*
*   Name:       read_c_norm
*   Called:
*   Calling:
*               read_file
*   Input:
*               byte *: c
*               struct object_def *: inp: object which is the source of the input stream
*               bool16: over: TRUE - throw away the last read char
*                             FALSE - keep the last read char
*   Output:
*               c: character has been readed
*               return value: TRUE - OK, FALSE - EOF or end_of_string.
**********************************************************************
*/
/*static bool near read_char(c, inp, over) */
bool
read_c_norm(c, inp)
byte   FAR *c ;
struct object_def FAR *inp ;
{
    if (TYPE(inp) == STRINGTYPE) {
        if (LENGTH(inp) == 0)
            return(FALSE) ;
        else {
            *c = *((byte FAR *)VALUE(inp)) ;
            inp->value++ ; inp->length-- ; /* update string value/length */
            return(TRUE) ;
        }
    } else {                           /* type == FILETYPE */
        if( read_fd((GEIFILE FAR *)VALUE(inp), c) ) {
            return(TRUE) ;
        } else {
            return(FALSE) ;
        }
    }
}   /* read_c_norm */

/*
**********************************************************************
*   restore the last read char into the specific input stream
*
*   Name:       unread_char
*   Called:
*   Calling
*               unread_file
*   Input:
*               struct object_def *: inp: object which is the source of the input stream
*   Output:
**********************************************************************
*/
void
unread_char(p_ch, inp)
fix     p_ch ;
struct object_def FAR *inp ;
{
    byte    c ;
#ifdef DJC // took this out to fix UPD042
    if( ISWHITESPACE(p_ch) )
        return ;
#endif
    if( ISWHITESPACE(p_ch) ) {
        if(p_ch == 0x0d) {
            if (READ_CHAR(&c, inp)) {
                if (c == 0x0a)
                   return;
                else
                   p_ch = c;
            } else
                return;
        } else
            return;
    }

    if (estate == EEXEC)
        eseed = old_eseed ;

    if (TYPE(inp) == STRINGTYPE) {
        if ((estate == EEXEC) && (itype == HEX_DATA)) {
            inp->length = inp->length + 2 ;
            inp->value = inp->value - 2 ;
        } else {
            inp->length++ ;
            inp->value-- ;
        }
    } else {
        if( estate == EEXEC ) {
            c = ungeteexec[0] ;
            if (c >= 0x00 && c <= 0x09) c += '0' ;
            if (c >= 0x0A && c <= 0x0F) c += 'A' - 10 ;
            unread_file(c, inp) ;
            if( itype == HEX_DATA ) {
                c = ungeteexec[1] ;
                if (c >= 0x00 && c <= 0x09) c += '0' ;
                if (c >= 0x0A && c <= 0x0F) c += 'A' - 10 ;
                unread_file(c, inp) ;
            }
        } else
            unread_file((byte)p_ch, inp) ;      /* @WIN; add cast */
    }
}   /* unread_char */

/*
**********************************************************************
*   compare string
*
*   Name:       str_eq_name
*   Called:
*   Calling:
*   Input:
*               byte *: p1:
*               byte *: p2:
*               fix16: len:
*   Output
*               return value: TRUE - if p1 equal to p2
*                             FALSE - otherwise
**********************************************************************
*/
static bool near
str_eq_name(p1, p2, len)
byte FAR *p1, FAR *p2 ;
fix len ;
{
    fix   i ;

    for (i = 0 ; i < len ; i++)
        if (p1[i] != p2[i]) return(FALSE) ;

    return(TRUE) ;
}   /* str_eq_name */

/*
**********************************************************************
*   copy number of len chars from p1 to p2
*
*   Name:       nstrcpy:
*   Called:
*   Calling:
*   Input:
*               byte *: p1
*               byte *: p2
*               fix16: len
*   Output:
**********************************************************************
*/
static void near
nstrcpy(p1, p2, len)
ubyte  FAR *p1, FAR *p2 ;
fix    len ;
{
    fix   i ;

    for (i = 0 ; i < len ; i++)
        *(p2+i) = *(p1+i) ;
}   /* nstrcpy */

/*
**********************************************************************
*   put temp. buffer into VM, and re_initial temp. buffer.
*
*   Name:       putc_buffer
*   Called:
*   Calling:
*   Input:
*               struct object_def *: buffer
*               struct object_def *: token
*   Output:
*               return value : TRUE - OK, FALSE - VM full.
**********************************************************************
*/
static bool near
putc_buffer(buffer, token)
struct buffer_def FAR *buffer ;
struct object_def FAR *token ;
{
    byte  huge *p ;

    if ((p = (byte huge *)alloc_vm((ufix32)buffer->length)) == NIL)
        return(FALSE) ;                  /* VM error */
    if (VALUE(token) == NIL)
        token->value = (ULONG_PTR)p ;        /* initial value */
    nstrcpy((ubyte FAR *)buffer->str, (ubyte FAR *)p, buffer->length) ;
    token->length += buffer->length ;   /* update length */
    buffer->length = 0 ;

    return(TRUE) ;
}   /* putc_buffer */

/*
**********************************************************************
*   put a char into temp. buffer, if buffer exceeds MAXBUFSZ, put
*   this temp. buffer into VM.
*
*   Name:       append_c_buffer
*   Called:
*   Calling:
*   Input:
*               byte: ch
*               struct object_def *: buffer
*               struct object_def *: token
*   Output:
*               return value: TRUE - OK, FALSE - VM full.
**********************************************************************
*/
static bool near
append_c_buffer(ch, buffer, token)
byte  ch ;
struct buffer_def FAR *buffer ;
struct object_def FAR *token ;
{
    if ((LENGTH(token) + (ufix16)buffer->length) >= (ufix16)MAXSTRCAPSZ)
        return(TRUE) ;
    buffer->str[buffer->length ++] = ch ;
    if (buffer->length == MAXBUFSZ)
        return(putc_buffer(buffer,token)) ;
    else
        return(TRUE) ;
}   /* append_c_buffer */

/*
**********************************************************************
*   allocate a heap block from heap, if overlap with VM, return
*   NIL pointer.
*
*   Name:       get_heap
*   Called:
*   Calling:
**********************************************************************
*/
static byte FAR * near
get_heap()
{
    struct heap_def  FAR *p1 ;

    if ( (p1 = (struct heap_def FAR *)
               alloc_heap((ufix32)sizeof(struct heap_def))) != NIL ) {
        p1->size = 0 ;
        p1->next = NIL ;
    }

    return((byte FAR *)p1) ;
}   /* get_heap */

/*
**********************************************************************
*   convert string to long decimal integer equivalent of number in given base
*
*   Name:       strtol_d
*   Called:
*   Calling:
*   Input:
*               byte *: string
**********************************************************************
*/
static fix32 near strtol_d(string, base, isint)
byte  FAR *string;
fix   base, isint;
{
    fix32   result_l = 0;               /* www */
    real64  result = 0.0;
    ufix32  result_tmp;
    byte    c, sign = 0;
    fix     i;

    if (isint) {   /* normal decimal */
        if ((c = *string) == '+')
            string++;
        else if (c == '-') {
            string++; sign++;
        }
/* www, begin */
        /*
        for (i = 0; c = *(string+i); i++) {
            result = result * 10 + EVAL_HEXDIGIT(c) ;
            if (result > S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
            }
        }   |* for *|
        if (sign)
            |* 4.19.90 kevina: replaced next line with the one following *|
            |* return((ufix32)-result); *|
            return(-(ufix32)result);
        else {
            if (result == S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
            }
            return((ufix32)result);
        }
        */
        if(lstrlen(string) <= 9) {      /* @WIN */
           /* mslin, 1/24/91 OPT
            * within 9 digits interger
            */
           for (i = 0; c = *(string+i); i++) {
                result_l = (result_l << 3) +
                           result_l + result_l + EVAL_HEXDIGIT(c) ;
           }   /* for */
           if (sign)
               /* 4.19.90 kevina: replaced next line with the one following */
               /* return((ufix32)-result); */
                return(-(fix32)result_l);

           return((fix32)result_l);
        } else {
           /* mslin, 1/24/91 OPT
            * possible interger of 10 digit or overflow
            */
           for (i = 0; c = *(string+i); i++) {
              result = result * 10 + EVAL_HEXDIGIT(c) ;
              if (result >= S_MAX31_PLUS_1) {
                errno = ERANGE;
                return(FALSE);
              }
           }   /* for */
           if (sign)
              /* 4.19.90 kevina: replaced next line with the one following */
              /* return((ufix32)-result); */
               return(-(fix32)result);

           return((fix32)result);
        }
/* www, end */
    } else {       /* radix integer */
        for (i = 0; c = *(string+i); i++) {
            EVAL_ALPHANUMER(c);
            result = result * base + c;
            if (result > S_MAX32) {
                errno = ERANGE;
                return(FALSE);
            }
        }   /* for */
        if (result >= S_MAX31_PLUS_1) {
            result_tmp = (ufix32)(result - S_MAX31_PLUS_1);
            return(result_tmp | 0x80000000);
        } else
            return((ufix32)result);
    }
}   /* strtol_d */

/*
**********************************************************************
*   initialize the name table
*
*   Name:       init_scanner
*   Called:
*   Calling:
**********************************************************************
*/
void
init_scanner()
{
    fix  i ;
    static struct ntb_def  null_entry ;

    name_table = (struct ntb_def FAR * FAR *)fardata((ufix32)(sizeof(struct ntb_def FAR *)
                  * MAXHASHSZ)) ;
    for (i = 1 ; i < MAXHASHSZ ; i++)
        name_table[i] = NIL ;     /* null name entry */

    null_entry.dict_found = 0 ;
    null_entry.dstkchg = 0 ;
    null_entry.save_level = 0 ;
    null_entry.colli_link = 0 ;
    null_entry.dict_ptr = 0 ;
    null_entry.name_len = 0 ;
    null_entry.text = 0 ;
    name_table[0] = &null_entry ;

    hash_used = HASHPRIME ;

    return ;
}   /* init_scanner */

/*
**********************************************************************
*   This submodule converts a name string to an unique hash id.
*
*   Name:       name_to_id
*   Called:
*               name_token
*               op_cvn
*   Calling:
*   Input:
*               byte *: str: pointer to the name string
*               ufix16: len: length of the name string
*               fix16 *: hash_id
*               bool8: isvm
*   Output:
*               hash_id : return hash code, if it can be searched in
*                         the name_table.
*               return value : TRUE - OK, FALSE - VM full, nmae_table
*                              full, or null name string.
**********************************************************************
*/
bool
name_to_id(str, len, hash_id, isvm)
byte   FAR *str ;
ufix    len ;
fix16   FAR *hash_id ;
bool8   isvm ;
{
//  fix16  i, hcode ;   @WIN; i & hcode changed to unsigned
    ufix16  i, hcode ;
    byte   FAR *p ;
    struct ntb_def FAR *hptr, FAR *dptr ;
    fix16  l_save_hcode;           /* qqq */

    if (len == 0) {
        *hash_id = 0 ;
        return(TRUE) ;
    }

    /*
    ** compute the hash code for the name string
    */
    for (i = 0, hcode = 0 ; i < len ; i++) {
#ifdef DJC
        if(*(str+i) <0) printf("name_to_id %d < 0\n", *(str+i)); //@WIN; debug
#else
        if(*(str+i) <0) {
          printf("name_to_id %d < 0\n", *(str+i)); //@WIN; debug
        }
#endif
        hcode = 13 * hcode + (unsigned)*(str+i) ;       // @WIN; add unsigned
        hcode %= HASHPRIME ;
    }
    l_save_hcode = hcode;               /* qqq */

    /*
    ** search the name_table, process the collision problem.
    */
    for ( ; ;) {
        /* used entry */
        if ((hptr = name_table[hcode]) != NIL) {
            /*
            ** this hash code has been defined with a name
            */
            if (hptr->name_len == len && str_eq_name(hptr->text, str, len))
                break ; /* OK, the name is old one */

            /* collision, put it into the collision area */
            else if ((i = hptr->colli_link) && (i < hash_used)) {
                hcode = i ; continue ;
            } else {
                if (hash_used == MAXHASHSZ) {   /* name_table full */
                    ERROR(LIMITCHECK) ;
                    return(FALSE) ;
                }
                hptr->colli_link = hash_used ;
                hcode = hash_used ;
            }
        } /* if */

        if (isvm) {
            /* empty entry */
            if ((p = alloc_vm((ufix32)len)) == NIL) {
                if (hcode >= HASHPRIME)
                    hptr->colli_link = 0 ;
                return(FALSE) ;                       /* VM full */
            } else
                nstrcpy((ubyte FAR *)str, (ubyte FAR *)p, len) ;
        } else
            p = str ;

        /* allocate VM space for name entry */
        if ((dptr = (struct ntb_def FAR *)
            alloc_vm((ufix32)sizeof(struct ntb_def))) == NIL) {
            if (hcode >= HASHPRIME)
                hptr->colli_link = 0 ;
            return(FALSE) ;                          /* VM full */
        } else {
            /* construct name_table entry, return hassh id */
            dptr->dict_found = 0 ;
            dptr->dstkchg = 0 ;
            dptr->save_level = current_save_level ;
            dptr->colli_link = 0 ;
#ifndef _WIN64
            dptr->dict_ptr = (struct dict_content_def FAR *)((ufix32)hcode) ;
#endif
            dptr->name_len = (ufix16)len ;
            dptr->text = p ;
            name_table[hcode] = dptr ;
/* qqq, begin */
            if( ! cache_name_id.over )
                vm_cache_index(l_save_hcode);
/* qqq, end */
            if (hcode >= HASHPRIME)
                hash_used++ ;
            break ;
        }
    } /* for */
    *hash_id = hcode ;

    return(TRUE) ;
}   /* name_to_id */

/*
**********************************************************************
*   free a name entry in the name table
*   Protect multiple link to same collision name entry
*
*   Name:       free_name_entry
*   Called:
*   Calling:
*   Input:
*               fix16: slevel
*               fix16: free_idx
**********************************************************************
 */
fix
free_name_entry(slevel, free_idx)
fix    slevel, free_idx ;
{
    struct ntb_def FAR *p ;

    if ((p = name_table[free_idx]) != NIL) {
        if (p->colli_link) {
            if (free_name_entry(slevel, p->colli_link))
                p->colli_link = 0 ;
        }
        if (p->save_level >= (ufix16)slevel) {          //@WIN
            name_table[free_idx] = NIL ;
            if (free_idx >= HASHPRIME)
                hash_used-- ;
            return(++free_idx) ;
        } else
            return(0) ;
    } else
        return(1) ;
}   /* free_name_entry */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\start.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * ***********************************************************************
 *  Change history :
 *    04-07-92   SCC   Create ps_call() and ps_interactive() from ps_main(),
 *                     for ps_main() just does init, others for batch and
 *                     interactive mode calls respectively.
 *                     Global allocate for opnstack, dictstack & execstack
 * ***********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include  <string.h>
// DJC moved to above global.def to avoid prototype prob with ic_init()
#include  "ic_cfg.h"            /* @WIN */
#include  "global.def"
#include  "arith.h"
#include  "user.h"
#include  <stdio.h>

#include  "geiio.h"             /* @WIN; for ps_interactive */

extern  ufix16   Word_Status87 ;
extern  byte near  _fpsigadr ;    /* +0  -  offset of fpsignal routine */
                                 /* +2  -  segment of fpsignal routine */

static  byte  huge * near vm_head ;

#ifdef LINT_ARGS
static   void near  init(void) ;
static   void near  init_floating(void) ;
static   void near  init_systemdict(void) ;
static   void near  init_statusdict(void) ;
extern   void       reinit_fontcache(void) ;
#else
static   void near  init() ;
static   void near  init_floating() ;
static   void near  init_systemdict() ;
static   void near  init_statusdict() ;
extern   void       reinit_fontcache() ;
#endif  /* LINT_ARGS */

/* @WIN; add prototype */
fix set_sysmem(struct  ps_config  FAR  *);
void init_asyncio(void);

fix
ps_main(configptr)
struct  ps_config  FAR *configptr ;     /*@WIN*/
{
    fix status ;

    if ((status = ic_init(configptr)) != 0)
        return(status) ;

    //ic_startup() ;            @WIN; don't do start page; Tmp only?????

//  while(1) {                  @WIN; do init only; move to ps_call()
//      ic_startjob() ;
//      init_operand() ;
//      init_status() ;
//  }
    return(0);
}   /* ps_main() */

#ifndef DUMBO
// DJC fix ps_call (buf)
// DJC char FAR * buf;
fix ps_call(void)
#else
fix ps_call ()
#endif
{
//      extern char FAR * WinBuffer;
//      WinBuffer = buf;        /* set for gesfs.c */

#ifndef DUMBO
// DJC         extern PSTR (FAR *lpWinRead)(void);

// DJC        lpWinRead = (PSTR (FAR *)(void)) buf;        /* set for gesfs.c */
#endif

        ic_startjob() ;
        init_operand() ;
        init_status() ;
        return 0;
}

fix ps_interactive(buf)
char FAR * buf;
{
        static struct  object_def  FAR *Winl_stdin = 0L;
        GEIFILE FAR *l_file = 0 ;
// DJC  extern PSTR (FAR *lpWinRead)(void);
        extern fix se_enterserver(void);
        extern fix se_protectserver(void);

        return(1);   // DJC .. not supported yet

// DJC lpWinRead = (PSTR (FAR *)(void)) buf;        /* set for gesfs.c */

        // by scchen; to set up save level 0 & 1 ???? to check with PJ
        if (current_save_level < 2) {
            /* create save snapshut */
            op_nulldevice() ;
            se_enterserver() ;
            se_protectserver() ;
            printf("current_save_level from 0 => %d\n", current_save_level);
        }

//      if (!Winl_stdin) {
            get_dict_value(SERVERDICT, "stdin", &Winl_stdin) ;

            l_file = GEIio_stdin ;
            TYPE_SET(Winl_stdin, FILETYPE) ;
            ACCESS_SET(Winl_stdin, READONLY) ;
            ATTRIBUTE_SET(Winl_stdin, EXECUTABLE) ;
            LEVEL_SET(Winl_stdin, current_save_level) ;
            LENGTH(Winl_stdin) = (ufix16)GEIio_opentag(l_file) ;
            VALUE(Winl_stdin) = (ULONG_PTR)l_file ;
//      }

        interpreter(Winl_stdin) ;
        return 0;
}

fix
ic_init(configptr)
struct  ps_config  FAR *configptr ;     /*@WIN*/
{
    fix status ;

    if ((status = set_sysmem(configptr)) != 0)
        return(status) ;

    /* Global allocate for opnstack, dictstack & execstack; @WIN */
    opnstack = (struct object_def far *)         /* take from global.def */
                fardata((ufix32)(MAXOPNSTKSZ * sizeof(struct object_def)));
    dictstack = (struct object_def far *)        /* take from global.def */
                fardata((ufix32)(MAXDICTSTKSZ * sizeof(struct object_def)));
    execstack = (struct object_def far *)        /* take from global.def */
                fardata((ufix32)(MAXEXECSTKSZ * sizeof(struct object_def)));

    setup_env() ;
    init() ;
    init_1pp() ;

    return(0) ;
}   /* ic_init() */


/*
**  System Initialization  Module
**
** Function Description
**
** This module initializes the system data structures of PostScript interpreter
** and create the system dict at the initialization time.
*/
static void near
init()
{
    init_asyncio() ;                 /* init async I/O */
#ifdef  DBG
    printf("init_asyncio() OK !\n") ;
#endif  /* DBG */

    init_floating() ;           /* init floating processor */
#ifdef  DBG
    printf("init_floating() OK !\n") ;
#endif  /* DBG */

    init_scanner() ;             /* init scanner */
#ifdef  DBG
    printf("init_scanner() OK !\n") ;
#endif  /* DBG */

    init_interpreter() ;         /* init interpreter */
#ifdef  DBG
    printf("init_interpreter() OK !\n") ;
#endif  /* DBG */

    init_operand() ;             /* init operand mechanism */
#ifdef  DBG
    printf("init_operand() OK !\n") ;
#endif  /* DBG */

    init_dict() ;                /* init dict mechanism */
#ifdef  DBG
    printf("init_dict() OK !\n") ;
#endif  /* DBG */

    init_vm() ;                  /* init vm mechanism */
#ifdef  DBG
    printf("init_vm() OK !\n") ;
#endif  /* DBG */

    init_file() ;                /* init file system */
#ifdef  DBG
    printf("init_file() OK !\n") ;
#endif  /* DBG */

    vm_head = vmptr ;
    init_systemdict() ;          /* init SystemDict */
#ifdef  DBG
    printf("init_systemdict() OK !\n") ;
#endif  /* DBG */

    init_graphics() ;            /* init graphics machinery */
#ifdef  DBG
    printf("init_graphics() OK !\n") ;
#endif  /* DBG */

    init_font() ;                /* init font machinery */


#ifdef  DBG
    printf("init_font() OK !\n") ;
#endif  /* DBG */

    init_misc() ;
#ifdef  DBG
    printf("init_misc() OK !\n") ;
#endif  /* DBG */

    init_statusdict() ;          /* init StatusDict 10-28-1987 */



#ifdef  DBG
    printf("init_statusdict() OK !\n") ;
#endif  /* DBG */

    init_status() ;              /* init StatusDict 10-28-1987: Su */
#ifdef  DBG
    printf("init_status() OK !\n") ;
#endif  /* DBG */

    init_timer() ;               /* init timer */
#ifdef  DBG
    printf("init_timer() OK !\n") ;
#endif  /* DBG */

    return ;
}   /* init() */

static void near
init_floating()
{
    union   four_byte   inf4 ;

    /* get INFINITY's real type value */
    inf4.ll = INFINITY ;
    infinity_f = inf4.ff ;

    _control87(CW_PDL, 0xffff) ;
    _clear87() ;

    return ;
}   /* init_floating() */

/*
 * **************************************
 *      - init_systemdict()
 *      - init_statusdict()
 * **************************************
 */
static void near
init_systemdict()
{
    struct object_def  key_obj, value_obj, dict_obj ;
    byte  FAR *key_string ;             /*@WIN*/
    fix    i ;
    fix    dict_size=0 ;

    dict_count = MAXOPERSZ;                 /* qqq */

    i = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte *)NULL) ;
    dict_count++ ;
    create_dict(&dict_obj, MAXSYSDICTSZ) ; /* or dict_size */
    for ( ; i < (fix)(dict_count-1) ; i++) {    //@WIN
         key_string = systemdict_table[i].key ;
         ATTRIBUTE_SET(&key_obj, LITERAL) ;
         LEVEL_SET(&key_obj, current_save_level) ;
         get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ;/* @WIN */
         value_obj.bitfield = systemdict_table[i].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)i ;
         value_obj.value = (ULONG_PTR)systemdict_table[i].value ;
         put_dict(&dict_obj, &key_obj, &value_obj) ;
     } /* for */
     /*
      * re_initial systemdict entry and push systemdict on
      * dict stack
      */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "systemdict", lstrlen("systemdict"), FALSE) ;/* @WIN */
     put_dict(&dict_obj, &key_obj, &dict_obj) ;
     if (FRDICTCOUNT() < 1) {
        ERROR(DICTSTACKOVERFLOW) ;
        return ;
     } else
        PUSH_DICT_OBJ(&dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;


    return ;
 }  /* init_systemdict() */

 static void near
 init_statusdict()
 {
    struct object_def  key_obj, value_obj, dict_obj ;
    struct object_def  FAR *sysdict_obj ;       /*@WIN*/
    byte  FAR *key_string ;                     /*@WIN*/
    fix    j ;
    fix    dict_size=0 ;

    j = dict_count ;
    do {
        dict_count++ ;
        dict_size++ ;
    } while ( systemdict_table[dict_count].key != (byte FAR *)NULL) ;/*@WIN*/
    dict_count++ ;
    create_dict(&dict_obj, MAXSTATDICTSZ) ;      /* or dict_size */
    for ( ; j < (fix)(dict_count-1) ; j++) {    //@WIN
         key_string = systemdict_table[j].key ;
         ATTRIBUTE_SET(&key_obj, LITERAL) ;
         LEVEL_SET(&key_obj, current_save_level) ;
         get_name(&key_obj, key_string, lstrlen(key_string), TRUE) ;/* @WIN */
         value_obj.bitfield = systemdict_table[j].bitfield ;
        if (TYPE(&value_obj) != OPERATORTYPE)
            value_obj.length = 0 ;
        else
            value_obj.length = (ufix16)j ;
         value_obj.value = (ULONG_PTR)systemdict_table[j].value ;
         put_dict(&dict_obj, &key_obj, &value_obj) ;
     } /* for */
     /*
      * re_initial systemdict entry
      */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "systemdict", lstrlen("systemdict"), FALSE) ;/* @WIN */
     load_dict(&key_obj, &sysdict_obj) ;        /* get the system_dict */
     ATTRIBUTE_SET(&key_obj, LITERAL) ;
     LEVEL_SET(&key_obj, current_save_level) ;
     get_name(&key_obj, "statusdict", lstrlen("statusdict"), FALSE) ;/* @WIN */
     put_dict(sysdict_obj, &key_obj, &dict_obj) ;
    /*
     * change the global_dictstkchg to indicate some dictionaries
     * in the dictionary stack have been changed
     */
    change_dict_stack() ;

    return ;
 }  /* init_statusdict() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\setvm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 *      3/2/91; scchen; increase 8K for CMB by decrease CCB 8K
 *      5/8/91; scchen; adjust page size of legal small
 *    04-07-92   SCC   Move in fardata() from blib.c, and modify for global
 *                     allocate from Windows
 */



// DJC added global include file
#include "psglobal.h"


#include               <math.h>
#include               <string.h>

#include               "global.ext"
#include               "graphics.h"
#include               "graphics.ext"
#include               "fillproc.h"
#include               "fillproc.def"
#include               "stdio.h"

#include               "ic_cfg.h"
#ifdef  DBG
#define DEBUG_SHOW(format, data)        (printf(format, data)) ;
#else
#define DEBUG_SHOW(format, data)
#endif

#define STATUS_OK      0
#define MAX_ISPS       (16)             /* maximum number of ISP */
#define SYSM_OFFSET    (0x0L)
#define VM_OFFSET      (SYSM_OFFSET)
#define VM_SIZEOF      (1024 * 230L)     /* 256 -> 230 */
#define FB_OFFSET      (VM_OFFSET + VM_SIZEOF)

extern ULONG_PTR                           fardata_ptr ;
extern struct precache_hdr_s * near     precache_hdr ;
ULONG_PTR highmem;

#ifndef _AM29K
#define FB_SIZEOF      (1024 * 1024L)  /* grayscale, 8-1-90, Jack Liaw */
#define FD_SIZEOF      (1024 * 324L)
//#define CCB_SIZEOF     (1024 * 96L)   @WIN; change to 64K for temp???
#define CCB_SIZEOF     (1024 * 64L)
#define GCB_SIZEOF     (1024 * 64L)

#define CRC_SIZEOF     (1024 *   2L)
#define ISP_SIZEOF     ( 512 *   1L)
#define HTP_SIZEOF     (1024 *   2L)
#define HTC_SIZEOF     (1024 *  16L)
#define HTB_SIZEOF     (1024 *  36L)
#define CMB_SIZEOF     (1024 *  16L)

#define FC_OFFSET      (1024 *  64L)
#define FONTDICT_BASE   (0x00180000L)
#else   /* _AM29K */
extern  fix16  near  pr_arrays[][6] ;
#define LEGAL_ENT      6  /* refer to init1pp.h */
#define WID_ENT        2
#define HI_ENT         3
#define MINUS_WID      52
#define MINUS_HI       229

#define FB_SIZEOF      (1024 * 1024L)             /* _AM29K */
#define LG_FB_SIZEOF   (4081 * 304L)              /* FB for Legal paper */
#define CCB_SIZEOF     (1024 * 128L)
#define GCB_SIZEOF     (1024 *  64L)
#define MAX_CCB_SIZEOF (1024 * 256L)
#ifdef  FORMAT_13_3
#define FD_SIZEOF      (1024 * 236L)
#elif FORMAT_16_16
#define FD_SIZEOF      (1024 * 290L)              /* 236 -> 290 for HSIC */
#elif FORMAT_28_4
#define FD_SIZEOF      (1024 * 290L)              /* 236 -> 290 for HSIC */
#endif

#define CRC_SIZEOF     (1024 *   2L)
#define ISP_SIZEOF     ( 512 *   1L)
#define HTP_SIZEOF     (1024 *   2L)
#define HTC_SIZEOF     (1024 *   8L)              /* 16 -> 8 */
#define HTB_SIZEOF     (1024 *  36L)
#define CMB_SIZEOF     (1024 *  24L)              /* 16 -> 24 */

#define FC_OFFSET      (1024 *  64L)
#endif  /* _AM29K */

// DJC ifdefed out all this windows stuff cause we
// include the windows.h header file which has it in it.
#ifdef IN_WINDOWS  //DJC

/* @WIN; Windows header */
#define API                 far pascal
typedef int                 BOOL;
typedef unsigned short      WORD;
typedef unsigned long       DWORD;
//typedef WORD                HANDLE;           defined in "windowsx.h"
typedef char far            *LPSTR;
HANDLE API GlobalAlloc(WORD, DWORD);
DWORD  API GlobalCompact(DWORD);
HANDLE API GlobalFree(HANDLE);
LPSTR  API GlobalLock(HANDLE);
BOOL   API GlobalUnlock(HANDLE);
DWORD  API GlobalHandle(WORD);
/* Global Memory Flags */
#define GMEM_FIXED          0x0000
#define GMEM_MOVEABLE       0x0002
#define GMEM_NOCOMPACT      0x0010
#define GMEM_NODISCARD      0x0020
#define GMEM_ZEROINIT       0x0040
#define GMEM_MODIFY         0x0080
#define GMEM_DISCARDABLE    0x0100
#define GMEM_NOT_BANKED     0x1000
#define GMEM_SHARE          0x2000
#define GMEM_DDESHARE       0x2000
#define GMEM_NOTIFY         0x4000
#define GMEM_LOWER          GMEM_NOT_BANKED

#endif // DJC end of IN_WINDOWS ifdef



fix set_sysmem(configptr)   /* _AM29K */
struct  ps_config  FAR  *configptr;     /*@WIN*/
{
    ULONG_PTR  sysmembase ;
    ufix32  sysmemsize, left,more, more_vm, frame_size ;

    sysmembase = (ULONG_PTR)configptr->PsMemoryPtr ;
    sysmemsize = configptr->PsMemorySize ;
    highmem = sysmembase + sysmemsize ;

    DEBUG_SHOW("sysmembase:   %8.8lx\n", sysmembase)
    DEBUG_SHOW("sysmemsize:   %8.8lx\n", sysmemsize)
    DEBUG_SHOW("highmem :     %8.8lx\n", highmem )

    FARDATA_HEAD = sysmembase ;
    FARDATA_END  = sysmembase + FD_SIZEOF ;
    DEBUG_SHOW("FARDATA_HEAD: %8.8lx\n", FARDATA_HEAD)
    DEBUG_SHOW("FARDATA_END:  %8.8lx\n", FARDATA_END)
    fardata_ptr = FARDATA_HEAD ;
    DEBUG_SHOW("fardata_ptr:  %8.8lx\n", fardata_ptr)

    CRC_BASE = FARDATA_END; CRC_SIZE = CRC_SIZEOF ;
    DEBUG_SHOW("CRC_BASE:     %8.8lx\n", CRC_BASE)
    DEBUG_SHOW("CRC_SIZE:     %8.8lx\n", CRC_SIZE)

    ISP_BASE = CRC_BASE + CRC_SIZEOF; ISP_SIZE = ISP_SIZEOF ;
    DEBUG_SHOW("ISP_BASE:     %8.8lx\n", ISP_BASE)
    DEBUG_SHOW("ISP_SIZE:     %8.8lx\n", ISP_SIZE)

    HTP_BASE = ISP_BASE + ISP_SIZEOF * MAX_ISPS; HTP_SIZE = HTP_SIZEOF ;
    DEBUG_SHOW("HTP_BASE:     %8.8lx\n", HTP_BASE)
    DEBUG_SHOW("HTP_SIZE:     %8.8lx\n", HTP_SIZE)

    HTC_BASE = HTP_BASE + HTP_SIZEOF; HTC_SIZE = HTC_SIZEOF ;
    DEBUG_SHOW("HTC_BASE:     %8.8lx\n", HTC_BASE)
    DEBUG_SHOW("HTC_SIZE:     %8.8lx\n", HTC_SIZE)

    HTB_BASE = HTC_BASE + HTC_SIZEOF; HTB_SIZE = HTB_SIZEOF ;
    DEBUG_SHOW("HTB_BASE:     %8.8lx\n", HTB_BASE)
    DEBUG_SHOW("HTB_SIZE:     %8.8lx\n", HTB_SIZE)

    CMB_BASE = HTB_BASE + HTB_SIZEOF; CMB_SIZE = CMB_SIZEOF ;
    DEBUG_SHOW("CMB_BASE:     %8.8lx\n", CMB_BASE)
    DEBUG_SHOW("CMB_SIZE:     %8.8lx\n", CMB_SIZE)

    GWB_BASE = CMB_BASE; GWB_SIZE = CMB_SIZE ;   /* The same as CMB */
    DEBUG_SHOW("GWB_BASE:     %8.8lx\n", GWB_BASE)
    DEBUG_SHOW("GWB_SIZE:     %8.8lx\n", GWB_SIZE)

/* _AM29K : above allocations are fixed although h/w RAM size is changed */

    //DJC CCB_BASE = CMB_BASE + CMB_SIZEOF ;
    //DJC fix from history.log UPD025 (may need more fixing based on history notes
    CCB_BASE = CMB_BASE + CMB_SIZEOF + 3072;
    DEBUG_SHOW("Hardware Dependent Allocation From %8.8lx\n",CCB_BASE)

    left= (ufix32)(highmem-CCB_BASE) ;    /* memory left for CCB, GCB and FB */
    DEBUG_SHOW("so far memory left : %8.8lx\n",left)

#ifdef _AM29K
    if (left< (CCB_SIZEOF + GCB_SIZEOF + VM_SIZEOF + LG_FB_SIZEOF) ) { /* not enough for Legal */
        more = 0 ;
        more_vm = (left-FB_SIZEOF-CCB_SIZEOF-GCB_SIZEOF-VM_SIZEOF) ;
        frame_size=FB_SIZEOF ;

        /* change printable area for Legal paper */
        pr_arrays[LEGAL_ENT][WID_ENT] -= MINUS_WID ;
        pr_arrays[LEGAL_ENT][HI_ENT]  -= MINUS_HI ;
        /* 2/26/91 ccteng, temporary setting, might need to be modified */
        /* marketing is satisfied with the result right now */
        pr_arrays[LEGAL_ENT][0] = 120;  /* adjust to center; 5/8/91 scchen */
        /*pr_arrays[LEGAL_ENT][1] = 0 ;    adjust to center; 5/8/91 scchen */
        pr_arrays[LEGAL_ENT][4] = 267 ;
        pr_arrays[LEGAL_ENT][5] = 174 ;
    }
    else {  /* frame buffer = legal */
        more= (left-LG_FB_SIZEOF-CCB_SIZEOF-GCB_SIZEOF-VM_SIZEOF) >> 1 ;
        if ( (more+CCB_SIZEOF) > MAX_CCB_SIZEOF) {
            more_vm = ((more+CCB_SIZEOF) - MAX_CCB_SIZEOF) << 1 ;
            more = MAX_CCB_SIZEOF - CCB_SIZEOF ;
        }
        frame_size=LG_FB_SIZEOF ;
    }
#else  /* _AM29K */
    more_vm=0 ;
    more=0 ;
    frame_size=FB_SIZEOF ;
#endif /* _AM29K */

    DEBUG_SHOW("frame buffer reserved : %8.8lx\n", frame_size)
    DEBUG_SHOW("more momory for GCB and CCB : %8.8lx\n", more)

    CCB_SIZE = CCB_SIZEOF + more ;
    DEBUG_SHOW("CCB_BASE:     %8.8lx\n", CCB_BASE)
    DEBUG_SHOW("CCB_SIZE:     %8.8lx\n", CCB_SIZE)

    GCB_BASE = CCB_BASE + CCB_SIZE; GCB_SIZE = GCB_SIZEOF + more ;
    DEBUG_SHOW("GCB_BASE:     %8.8lx\n", GCB_BASE)
    DEBUG_SHOW("GCB_SIZE:     %8.8lx\n", GCB_SIZE)

    VMBASE  = GCB_BASE + GCB_SIZE ;
    MAXVMSZ = VM_SIZEOF + more_vm ;
    DEBUG_SHOW("VMBASE:       %8.8lx\n", VMBASE)
    DEBUG_SHOW("MAXVMSZ:      %8.8lx\n", MAXVMSZ)

    FONTBASE = VMBASE + FC_OFFSET ;
    DEBUG_SHOW("FONTBASE:     %8.8lx\n", FONTBASE)

#ifndef DUMBO
    FBX_BASE = VMBASE + MAXVMSZ ;
    DEBUG_SHOW("FBX_BASE:     %8.8lx\n", FBX_BASE)
#endif

    // return(STATUS_OK) ;  @WIN: ignore above memory assignment, just
    //                            use global allocate as follows.

/* Allocate memory for TrueImage @WIN ------------------------------- BEGIN */
    {
      HANDLE hCRC, hISP, hHTP, hHTC, hHTB, hCMB, hGWB, hCCB, hGCB, hVM;
      WORD wFlag = GMEM_FIXED|GMEM_ZEROINIT;

      /* allocate all except Fardata, fontbase, and Frame buffer */
      if (!(hCRC = GlobalAlloc (wFlag, CRC_SIZE))) goto FatalError;
      if (!(CRC_BASE = (ULONG_PTR)GlobalLock(hCRC))) goto FatalError;
      DEBUG_SHOW("CRC_BASE:     %8.8lx\n", CRC_BASE)
      DEBUG_SHOW("CRC_SIZE:     %8.8lx\n", CRC_SIZE)
      if (!(hISP = GlobalAlloc (wFlag, ISP_SIZE * MAX_ISPS))) goto FatalError;
                                          // alloc MAX_ISPS seeds @WIN
      if (!(ISP_BASE = (ULONG_PTR)GlobalLock(hISP))) goto FatalError;
      DEBUG_SHOW("ISP_BASE:     %8.8lx\n", ISP_BASE)
      DEBUG_SHOW("ISP_SIZE:     %8.8lx\n", ISP_SIZE * MAX_ISPS)
      if (!(hHTP = GlobalAlloc (wFlag, HTP_SIZE))) goto FatalError;
      if (!(HTP_BASE = (ULONG_PTR)GlobalLock(hHTP))) goto FatalError;
      DEBUG_SHOW("HTP_BASE:     %8.8lx\n", HTP_BASE)
      DEBUG_SHOW("HTP_SIZE:     %8.8lx\n", HTP_SIZE)
      if (!(hHTC = GlobalAlloc (wFlag, HTC_SIZE))) goto FatalError;
      if (!(HTC_BASE = (ULONG_PTR)GlobalLock(hHTC))) goto FatalError;
      DEBUG_SHOW("HTC_BASE:     %8.8lx\n", HTC_BASE)
      DEBUG_SHOW("HTC_SIZE:     %8.8lx\n", HTC_SIZE)
      if (!(hHTB = GlobalAlloc (wFlag, HTB_SIZE))) goto FatalError;
      if (!(HTB_BASE = (ULONG_PTR)GlobalLock(hHTB))) goto FatalError;
      DEBUG_SHOW("HTB_BASE:     %8.8lx\n", HTB_BASE)
      DEBUG_SHOW("HTB_SIZE:     %8.8lx\n", HTB_SIZE)
      if (!(hCMB = GlobalAlloc (wFlag, CMB_SIZE))) goto FatalError;
      if (!(CMB_BASE = (ULONG_PTR)GlobalLock(hCMB))) goto FatalError;
      DEBUG_SHOW("CMB_BASE:     %8.8lx\n", CMB_BASE)
      DEBUG_SHOW("CMB_SIZE:     %8.8lx\n", CMB_SIZE)
      if (!(hGWB = GlobalAlloc (wFlag, GWB_SIZE))) goto FatalError;
      if (!(GWB_BASE = (ULONG_PTR)GlobalLock(hGWB))) goto FatalError;
      DEBUG_SHOW("GWB_BASE:     %8.8lx\n", GWB_BASE)
      DEBUG_SHOW("GWB_SIZE:     %8.8lx\n", GWB_SIZE)
      if (!(hCCB = GlobalAlloc (wFlag, CCB_SIZE))) goto FatalError;
      if (!(CCB_BASE = (ULONG_PTR)GlobalLock(hCCB))) goto FatalError;
      DEBUG_SHOW("CCB_BASE:     %8.8lx\n", CCB_BASE)
      DEBUG_SHOW("CCB_SIZE:     %8.8lx\n", CCB_SIZE)
      if (!(hGCB = GlobalAlloc (wFlag, GCB_SIZE))) goto FatalError;
      if (!(GCB_BASE = (ULONG_PTR)GlobalLock(hGCB))) goto FatalError;
      DEBUG_SHOW("GCB_BASE:     %8.8lx\n", GCB_BASE)
      DEBUG_SHOW("GCB_SIZE:     %8.8lx\n", GCB_SIZE)

      //DJC MAXVMSZ = (DWORD)256 * (DWORD)1024;          // set it as 256K 04-20-92
      //DJC increase size of VM for MAC job problem
      MAXVMSZ = (DWORD)1000 * (DWORD)1024;          // set it as 256K 04-20-92

      //DJCif (!(hVM = GlobalAlloc (wFlag, MAXVMSZ))) goto FatalError;
      //DJC test if we can take out zeroinit
      if (!(hVM = GlobalAlloc (GMEM_FIXED, MAXVMSZ))) goto FatalError;
      if (!(VMBASE = (ULONG_PTR)GlobalLock(hVM))) goto FatalError;
      DEBUG_SHOW("VMBASE:       %8.8lx\n", VMBASE)
      DEBUG_SHOW("MAXVMSZ:      %8.8lx\n", MAXVMSZ)

      return(STATUS_OK) ;
FatalError:
      printf("\n\07 Fatal error, fail to allocate memory\n");

		PsReportInternalError( PSERR_ABORT | PSERR_ERROR,
		  							  PSERR_LOG_MEMORY_ALLOCATION_FAILURE,
                             0,
                             NULL );
      return(FALSE);
    }
}


byte FAR *
fardata(size)
ufix32  size ;
{
    HANDLE hMemory;
    char FAR *Memory;
    WORD wFlag = GMEM_FIXED|GMEM_ZEROINIT;

    if (size > (DWORD)64 * (DWORD)1024)
        printf("\nWarning to allocate %8.8lx bytes(>64K) in fardata\n", size);

    if (!(hMemory = GlobalAlloc (wFlag, size))) goto FatalError;
    if (!(Memory = GlobalLock(hMemory))) goto FatalError;
    return(Memory);

FatalError:
    printf("\n\07 Fail to allocate %8.8lx bytes in fardata\n", size);
    return(NULL);

}   /* fardata() */
/* Allocate memory for TrueImage @WIN -------------------------------  END  */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\server.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              SERVER.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *
 * revision history:
 *      7/23/90 ; ccteng ; 1)move idleproc from execstdin to startjob
 *                       2)change execstdin to run passed object and
 *                         change startjob to pass stdin to it
 *                       3)modify se_internaldict and rename to flushexec
 *                       4)rename ex_idleproc to ex_idleproc1, and add
 *                         ex_idleproc to be real execdict operator
 *      08-08-91 : ymkung : add emulation switch at END-OF-JOB ref: @EMUS
 *      12-05-91   ymkung   fix manualfeed bug ref : @MAN
 ************************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include        "global.ext"
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"
#include        "language.h"
#include        "file.h"
#include        "user.h"
#include        "geieng.h"
#include        "geisig.h"
#include        "geipm.h"
#include        "geitmr.h"
#include        "gescfg.h"

#ifdef LINT_ARGS
static  bool  near  ex_idleproc1(ufix16) ;
static  bool  near  ba_firstsave(void) ;
static  bool  near  ba_firstrestore(void) ;
static  bool  near  flushexec(bool) ;
#else
static  bool  near  ex_idleproc1() ;
static  bool  near  ba_firstsave() ;
static  bool  near  ba_firstrestore() ;
static  bool  near  flushexec() ;
#endif /* LINT_ARGS */

static  bool  near  id_flag = FALSE ;
struct  object_def  FAR   *exec_depth ;
struct  object_def  FAR   *run_batch ;
static  bool  near  send_ctlD = FALSE ;

#ifdef  _AM29K
extern   GEItmr_t   jobtime_tmr ;
ufix8               jobtimeout_set ;
ufix8               sccbatch_set ;
#endif  /* _AM29K */

bool16  doquit_flag ;
extern  bool16  chint_flag ;
bool16  chint_flag = FALSE ;
bool16  abort_flag ;

/* @WIN; add prototype */
fix op_clearinterrupt(void);
fix op_disableinterrupt(void);
fix op_enableinterrupt(void);
fix se_initjob(void);
fix se_enterserver(void);
fix se_protectserver(void);
fix us_useidlecache(fix);

extern  GESiocfg_t FAR *     ctty ;

/* @WIN; add prototype */
extern  int             GEIeng_checkcomplete(void); /* @EMUS 08-08-91 YM */
extern  void            DsbIntA(void);          /* @EMUS disable interrupt */
extern  void            switch2pcl(void);       /* @EMUS go to PCL */
extern  int             ES_flag ;               /* @EMUS 08-08-91 YM */
extern  void            GEPmanual_feed(void);   /* @MAN 12-05-91 YM */
extern  unsigned int    manualfeed_com;         /* @MAN 12-05-91 YM */
extern  unsigned int    papersize_tmp;          /* @MAN 12-05-91 YM */
extern  int             papersize_nvr;          /* @MAN 12-05-91 YM */

/************************************
 *  DICT: serverdict
 *  NAME: settimeouts
 *  FUNCTION: use as an internal function only
 *            to set time-outs
 *            jobtimeout manualfeedtimeout waittimeout settimeouts -
 *  INTERFACE: ex_idleproc1, do_execjob, se_initjob
 ************************************/
fix
se_settimeouts()
{
    struct  object_def  FAR *l_waittimeout, FAR *l_mftimeout ;

#ifdef DBG_1pp
    printf("se_settimeouts()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(STATUSDICT, "waittimeout", &l_waittimeout) ;
    get_dict_value(STATUSDICT, "manualfeedtimeout", &l_mftimeout) ;

    /* set time-outs */
    COPY_OBJ(GET_OPERAND(0), l_waittimeout) ;
    COPY_OBJ(GET_OPERAND(1), l_mftimeout) ;
    POP(2) ;
    st_setjobtimeout() ;

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: do_execjob
 *  FUNCTION: call interpreter to execute object
 *  INTERFACE: ic_startjob and ic_startup
 ************************************/
fix
do_execjob(object, save_level, handleerror)
struct object_def object ;
fix save_level ;
bool handleerror ;
{
    struct object_def l_timeout ;
    struct object_def FAR *l_tmpobj, FAR *l_errorname, FAR *l_newerror ;
    fix l_status, l_i ;

#ifdef DBG_1pp
    printf("do_execjob()...\n") ;
#endif

    if (save_level) {
        /* create save snapshut */
        op_nulldevice() ;
        se_enterserver() ;
/*      op_nulldevice() ; erik chen */
#ifdef  _AM29K
    {
        ufix  tray ;
        ubyte pagetype ;
        struct object_def   FAR *l_job ;

        tray = GEIeng_paper() ;
        switch (tray) {
           case PaperTray_LETTER:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)8 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_LEGAL:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)24 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_A4:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)2 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;

           case PaperTray_B5:
               get_dict_value(STATUSDICT, "printerstatus", &l_job) ;
               VALUE(l_job) = (ufix32)18 ;
               put_dict_value1(STATUSDICT, "printerstatus", l_job) ;
               break ;
        }
        GEIpm_read(PMIDofPAGETYPE,&pagetype,sizeof(unsigned char)) ;
        if (pagetype == 1)
            us_note() ;
        else
        {
            tray = GEIeng_paper() ;
            switch (tray) {
                case PaperTray_LETTER:
                    us_letter() ;
                    break ;

                case PaperTray_LEGAL:
                    us_legal() ;
                    break ;

                case PaperTray_A4:
                    us_a4() ;
                    break ;

                case PaperTray_B5:
                    us_b5() ;
                    break ;
            }
        }
    }
#else
    {
      int iTray;

      // DJC us_letter() ;

      // DJC , add code to set up the default tray based on whatever the
      //       default for the printer is set up to.
      //
      iTray = PsReturnDefaultTItray();

      switch ( iTray) {

         case PSTODIB_LETTER:
           us_letter();
           break;

         case PSTODIB_LETTERSMALL:
           us_lettersmall();
           break;

         case PSTODIB_A4:
           us_a4();
           break;

         case PSTODIB_A4SMALL:
           us_a4small();
           break;

         case PSTODIB_B5:
           us_b5();
           break;

         case PSTODIB_NOTE:
           us_note();
           break;

         case PSTODIB_LEGAL:
           us_legal();
           break;

         default:
           us_letter();
           break;

      }




    }
#endif
        /*
         * for a normal job (save_level==2), call protectserver
         * to record a pointer of execstack for exitserver
         */
        if (save_level ==2)
            se_protectserver() ;
    }

    /*
    st_defaulttimeouts() ;
    se_settimeouts() ;
    */
    // UPD054
    //op_clearinterrupt() ;
    op_enableinterrupt();


    /* call interpreter to execute the object */
    ATTRIBUTE_SET(&object, EXECUTABLE) ;
    st_defaulttimeouts() ;
    se_settimeouts() ;
    l_status = interpreter(&object) ;
    /* check if "stop" encountered */
    op_clearinterrupt() ;
    op_disableinterrupt() ;
    op_clear() ;
    us_cleardictstack() ;
    if (l_status) {
        /* pop out "op_stop" from execstack */
        POP_EXEC(1) ;

/*      if (handleerror) { erik chen 3-16-1991 */
// DJC         if (handleerror && !chint_flag) {
        if (handleerror) {

                        /* initialize object pointers */
            get_dict_value(DERROR, "runbatch", &run_batch) ;
            get_dict_value(DERROR, "newerror", &l_newerror) ;
            get_dict_value(DERROR, "errorname", &l_errorname) ;
            get_name1(&l_timeout, "timeout", 7, TRUE) ;

            /* handle errer */
            if (VALUE(l_newerror)) {
                get_dict_value(SYSTEMDICT, "handleerror", &l_tmpobj) ;
                interpreter(l_tmpobj) ;
            }
        }
        //UPD054, call this code anyway
        //
        /* flush file */
        PUSH_ORIGLEVEL_OBJ(&object) ;
        op_status() ;
        POP(1) ;
        GEIio_ioctl(GEIio_stdin, _FIONREAD, (int FAR *)&l_i); /*@WIN*/
        if( (VALUE_OP(-1) && VALUE(run_batch)) &&
            !((VALUE(l_errorname) == VALUE(&l_timeout)) && ! l_i) ) {



            //DJC here we need to call PSTODIB to let it knowthe
            //DJC current job is being flushed
            //
            PsFlushingCalled(); //DJC



            get_dict_value(MESSAGEDICT, "flushingjob", &l_tmpobj) ;
            interpreter(l_tmpobj) ;
            if (!abort_flag) { /* erik chen 5-8-1991 */
                op_flush() ;
                PUSH_ORIGLEVEL_OBJ(&object) ;
                op_flushfile() ;
            }
        }
        //UPD 054 } /* if */
    } /* if */

#ifdef DBG_1pp
    printf("save_level=%d, use_fg=%d\n", save_level, use_fg) ;
#endif
    /*
     * use_fg==0, exiting server or end of a exitservered job at savelevel 0
     * use_fg==1, job end at savelevel 2 or 1
     * use_fg==2, exiting server at savelevel 2
     */
    op_clear() ;
    us_cleardictstack() ;
    if (save_level)
        switch (use_fg) {
            case 1:
                ba_firstrestore() ;
                use_fg = 0 ;
                break ;

            case 2:
                ba_firstrestore() ;
                break ;

            default: break ;
        }

#ifdef SCSI /* moved here from begining of enterserver */
    /* write cache information from RAM to SCSI at every end of job */
    st_flushcache() ;
    op_sync() ;
#endif

    return(l_status) ;
}

/************************************
 *  DICT: internal
 *  NAME: enterserver
 *  FUNCTION:
 *  INTERFACE: do_execjob
 ************************************/
fix
se_enterserver()
{
#ifdef  DBG_1pp
        printf("se_enterserver()...\n") ;
#endif  /* DBG_1pp */

    /* clear operand stack and dictionary stack */
    op_clear() ;
    us_cleardictstack() ;

    switch( use_fg ) {
        case 0:
            ba_firstsave() ;
            use_fg = 1 ;
            break ;

        case 1:
            /* ba_firstrestore() ; */
            ba_firstsave() ;
            use_fg = 0 ;
            break ;

        case 2:
            /* ba_firstrestore() ; */
            use_fg = 0 ;
            break ;

        default:
            break ;
    }

    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: exitserver
 *  FUNCTION:
 *  INTERFACE: interpreter
 ************************************/
fix
se_exitserver()
{
    struct  object_def  FAR *l_tmpobj ;
    fix l_pass ;

#ifdef DBG_1pp
    printf("se_exitserver()...\n") ;
#endif

    if ( COUNT() < 1 ) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if ( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    st_checkpassword() ;
    l_pass = (fix)VALUE_OP(0) ;         //@WIN
    POP(1) ;
    if (l_pass) {
        op_disableinterrupt() ;
        op_clear() ;
        us_cleardictstack() ;

        /* print exitserver message defined in messagedict */
        get_dict_value(MESSAGEDICT, "exitingserver", &l_tmpobj) ;
        interpreter(l_tmpobj) ;
        op_flush() ;

        if ( use_fg == 1 )
            use_fg = 2 ;
        else
            use_fg = 0 ;

        VALUE(exec_depth) = 0 ;
        VALUE(run_batch) = FALSE ;

        /* call flushexec to flush execstack to saved pointer */
        flushexec(TRUE) ;
    }

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: protectserver
 *  FUNCTION:
 *  INTERFACE: do_execjob
 ************************************/
fix
se_protectserver()
{
    struct object_def   FAR *l_serverdict ;

#ifdef  DBG_1pp
        printf("se_protectserver()...\n") ;
#endif  /* DBG_1pp */

    /* check use_fg */
    if ( use_fg == 1 ) {
        /* 7/21/90 ccteng */
        get_dict_value(USERDICT, SERVERDICT, &l_serverdict) ;
        PUSH_ORIGLEVEL_OBJ(l_serverdict) ;
        op_readonly() ;
        POP(1) ;
        op_save() ;
        POP(1) ;
    } else
        use_fg = 0 ;

    /* call flushexec to record a pointer */
    flushexec(FALSE) ;

    return(0) ;
}   /* se_protectserver */

/************************************
 *  DICT: internal
 *  NAME: ic_startjob
 *  FUNCTION:
 *  INTERFACE: ic_main or JobMgrMain
 ************************************/
fix
ic_startjob()
{
    struct  object_def  FAR *l_stdin, FAR *l_stdout, FAR *l_defmtx ;
    fix     ret ;
    char    FAR *pp ;
    struct  object_def   l_job ;
    struct  object_def   FAR *l_job1 ;

    GEIFILE FAR *l_file = 0 ;
    fix l_arg ;

#ifdef DBG_1pp
    printf("ic_startjob()...\n") ;
#endif

    /* initialize object pointers */
    send_ctlD = FALSE ;
    get_dict_value(SERVERDICT, "stdin", &l_stdin) ;
    get_dict_value(SERVERDICT, "stdout", &l_stdout) ;
    get_dict_value(DERROR, "runbatch", &run_batch) ;
    get_dict_value(EXECDICT, "execdepth", &exec_depth) ;
    get_dict_value(PRINTERDICT, "defaultmtx", &l_defmtx) ;

    while ( 1 ) {
        /*
         * job cycle:
         * 1. initialization
         * 2. build idle time cache
         * 3. check channel configuration
         * 4. ioctl()
         * 5. do_execjob()
         * 6. end of job stuff
         */
        SET_NULL_OBJ(&l_job) ;
        put_dict_value1(STATUSDICT, "jobname", &l_job) ;

        pp = GEIio_source() ;
        if(!lstrcmp(pp ,"%SERIAL25%")) lstrncpy(job_source, "serial 25\0", 11) ;/* @WIN */
        else if(!lstrcmp(pp, "%SERIAL9%")) lstrncpy(job_source, "serial 9\0", 10);/* @WIN */
        else lstrncpy(job_source, "AppleTalk\0", 11);
        get_dict_value(STATUSDICT, "jobsource", &l_job1) ;
        lstrncpy((byte FAR *)VALUE(l_job1), job_source, strlen(job_source));

        lstrncpy(job_state, "idle\0", 6);
        TI_state_flag = 0 ;
        change_status() ;

        /* job initialization */
        se_initjob() ;

/* @WIN delete idletime processing */
#ifdef XXX
/*
        st_defaulttimeouts();
        POP(2);
        st_setjobtimeout();
 */
/*      op_nulldevice() ; */
        PUSH_ORIGLEVEL_OBJ(l_defmtx) ;
        op_setmatrix() ;

        us_useidlecache(0);
        while( ! GEIio_selectstdios() )
            us_useidlecache(1);
        us_useidlecache(2);
#endif


        SET_NULL_OBJ(&l_job) ;
        put_dict_value1(STATUSDICT, "jobname", &l_job) ;

        pp = GEIio_source() ;
        if(!lstrcmp(pp ,"%SERIAL25%")) lstrncpy(job_source, "serial 25\0", 11) ;/* @WIN */
        else if(!lstrcmp(pp, "%SERIAL9%")) lstrncpy(job_source, "serial 9\0", 10);/* @WIN */
        else lstrncpy(job_source, "AppleTalk\0", 11);
        get_dict_value(STATUSDICT, "jobsource", &l_job1) ;
        lstrncpy((byte FAR *)VALUE(l_job1), job_source, strlen(job_source));

        /* open stdin */
 /*     fs_info.attr = F_READ ;
        fs_info.fnameptr = special_file_table[F_STDIN].name ;
        fs_info.fnamelen = strlen(special_file_table[F_STDIN].name) ;
        open_file(l_stdin) ;
        ACCESS_SET(l_stdin, READONLY) ;
        ATTRIBUTE_SET(l_stdin, EXECUTABLE) ; erik chen 4-15-1991 */
        l_file = GEIio_stdin ;
        TYPE_SET(l_stdin, FILETYPE) ;
        ACCESS_SET(l_stdin, READONLY) ;
        ATTRIBUTE_SET(l_stdin, EXECUTABLE) ;
        LEVEL_SET(l_stdin, current_save_level) ;
        LENGTH(l_stdin) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(l_stdin) = (ULONG_PTR)l_file ;

        /* open stdout */
/*      fs_info.attr = F_WRITE ;
        fs_info.fnameptr = special_file_table[F_STDOUT].name ;
        fs_info.fnamelen = strlen(special_file_table[F_STDOUT].name) ;
        open_file(l_stdout) ;
        ATTRIBUTE_SET(l_stdout, LITERAL) ; erik chen 4-15-1991 */
        l_file = GEIio_stdout ;
        TYPE_SET(l_stdout, FILETYPE) ;
        ACCESS_SET(l_stdout, UNLIMITED) ;
        ATTRIBUTE_SET(l_stdout, LITERAL) ;
        LEVEL_SET(l_stdout, current_save_level) ;
        LENGTH(l_stdout) = (ufix16)GEIio_opentag(l_file) ;
        VALUE(l_stdout) = (ULONG_PTR)l_file ;
        l_arg = _O_NDELAY ;
        GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg); /*@WIN*/

        //UPD054
        //op_enableinterrupt() ;

        abort_flag = 0 ;      /* erik chen 5-8-1991 */
        ret = do_execjob(*l_stdin, 2, TRUE) ;
        chint_flag = FALSE ;
#ifdef  _AM29K
        if (jobtimeout_set==1) {
            jobtimeout_set=0;
            GEItmr_stop(jobtime_tmr.timer_id);
        }
#endif

        /* Handle ^d */
        if (VALUE(run_batch) && send_ctlD) {

            /* echo EOF, print a 0x04 to %stdout */
            op_flush();
            GEIio_ioctl(GEIio_stdout, _ECHOEOF, (int FAR *)0) ; /*@WIN*/
            GEIio_ioctl(GEIio_stdout, _FIONRESET, (int FAR *)0) ; /*@WIN*/
            if (manualfeed_com) {               /* @MAN 12-05-91 YM */
                manualfeed_com = 0;             /* reset flag */
                GEPmanual_feed();               /* clear front panel */
                papersize_nvr = papersize_tmp;  /* restore paper size */
            }
            if (ES_flag == PCL) {               /* @EMUS 08-08-91 YM */
                while(GEIeng_checkcomplete()) ; /* wait printing finished */
                DsbIntA();
                switch2pcl();                   /* go to PCL */
            }
        }

        /* 7/24/90 ccteng
         * this might not be needed for our job control
         */
        if ( ANY_ERROR() ) {
            PUSH_ORIGLEVEL_OBJ(l_stdin) ;
            op_resetfile() ;
            PUSH_ORIGLEVEL_OBJ(l_stdout) ;
            op_resetfile() ;
            VALUE(run_batch) = TRUE ;
        } /* if */

        /* close files */
        if ( VALUE(run_batch) ) {
/*          GEIio_setsavelevel((GEIFILE FAR *)VALUE(l_stdin), 0) ;
            GEIio_close((GEIFILE FAR *)VALUE(l_stdin)) ;
            GEIio_setsavelevel((GEIFILE FAR *)VALUE(l_stdout), 0) ;
            GEIio_close((GEIFILE FAR *)VALUE(l_stdout)) ; erik chen 4-15-1991 */
            GEIio_forceopenstdios(_FORCESTDIN) ;
            GEIio_forceopenstdios(_FORCESTDOUT) ;
        } /* if */

#ifdef  _AM29K
        if (sccbatch_set == 1) {
            sccbatch_set=0;
            GEIsig_raise(GEISIGSCC, 1);         /* Raise SCC changed */
        }
#endif

        /* Just do once for TrueImage.DLL, Temp solution; @WIN */

        // DJC DJC
        op_flush();

        break;

    } /* while */
    return 0;           //@WIN
}

/************************************
 *  DICT: serverdict
 *  NAME: initjob
 *  FUNCTION:
 *  INTERFACE: ic_startjob
 ************************************/
fix
se_initjob()
{
    ufix16  l_i ;

#ifdef DBG_1pp
    printf("se_initjob()...\n") ;
#endif

    op_disableinterrupt() ;

    /* set timeouts */
    for (l_i = 0 ; l_i < 3 ; l_i++)
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, 0) ;
    se_settimeouts() ;

    op_clear() ;
    us_cleardictstack() ;

    /* activate idleproc */
    ex_idleproc1(1) ;

    /* init values */
    send_ctlD = TRUE ;
    VALUE(exec_depth) = 0 ;
    VALUE(run_batch) = TRUE ;

    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: interactive
 *  FUNCTION:
 *  INTERFACE: us_executive
 ************************************/
fix
se_interactive()
{
    struct  object_def  FAR *l_stmtfile, FAR *l_opfile ;
    struct  object_def  FAR *l_handleerror, FAR *l_newerror ;
    fix l_arg;

#ifdef DBG_1pp
    printf("se_interactive()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(EXECDICT, "stmtfile", &l_stmtfile) ;
    get_dict_value(SYSTEMDICT, "handleerror", &l_handleerror) ;
    get_dict_value(DERROR, "newerror", &l_newerror) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
    st_setjobtimeout() ;

    l_arg = _O_SYNC ;
    GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg) ;  /*@WIN*/

    while ( 1 ) {
        /* reset quit flag & prompt */
        doquit_flag = FALSE ;
        VALUE(l_newerror) = FALSE ;
        us_prompt() ;

        ex_idleproc1(0) ;

        /* open statementedit file */
        fs_info.attr = F_READ ;
        fs_info.fnameptr = special_file_table[SPECIAL_STAT].name ;
        fs_info.fnamelen = lstrlen(special_file_table[SPECIAL_STAT].name) ;

        lstrncpy(job_state, "waiting; \0", 11) ;
        TI_state_flag = 0 ;
        change_status() ;

        if ( ! open_file(l_stmtfile) ) {
#ifdef DBG_1pp
    printf("fail open stmtfile = error %d\n", ANY_ERROR()) ;
#endif
            /* open fail */
            if ( ANY_ERROR() != UNDEFINEDFILENAME ) {
                /* error */
                get_dict_value(SYSTEMDICT, "file", &l_opfile) ;
                error_handler(l_opfile) ;
                interpreter(l_handleerror) ;
            } else
                /* ^D at begin of file */
                CLEAR_ERROR() ;
            break ;
        } else {
            lstrncpy(job_state, "busy; \0", 8) ;
            TI_state_flag = 1 ;
            change_status() ;

            /* file open successfully */
            ACCESS_SET(l_stmtfile, READONLY) ;
            ATTRIBUTE_SET(l_stmtfile, EXECUTABLE) ;
            LEVEL_SET(l_stmtfile, current_save_level) ;
            /* call interpreter */
            if ( interpreter(l_stmtfile) ) {
#ifdef DBG_1pp
    printf("stopped (stmtfile)...\n") ;
#endif
                /* pop out "op_stop" from execstack */
                POP_EXEC(1) ;
                /* "stop" met during execution */
                interpreter(l_handleerror) ;
                close_file(l_stmtfile) ;
            } /* if */
        } /* if-else */

        if ( id_flag ) {
            flushexec(TRUE) ;
            return(0) ;
        } /* if */

        if (doquit_flag)
            break ;
    } /* while */

    l_arg = _O_NDELAY ;
    GEIio_ioctl(GEIio_stdout, _F_SETFL, (int FAR *)&l_arg) ;   /*@WIN*/

    return(0) ;
}

/************************************
 *  DICT: internal
 *  NAME: ex_idleproc1
 *  FUNCTION: use as an internal function only
 *            to set time-outs
 *  INTERFACE: se_interactive, do_execjob
 *  INPUT:  1. activate
 *          0. settimeouts if active
 ************************************/
static bool near
ex_idleproc1(p_mode)
ufix16 p_mode ;
{
    static  bool    idle_flag ;

    /* check p_mode */
    if ( p_mode ) {
#ifdef DBG_1pp
    printf("ex_idleproc1(1)...\n") ;
#endif
        /* activate idleproc */
        idle_flag = FALSE ;
    } else {
        /* check if idleproc is active */
        if ( !idle_flag ) {
            /* set time-outs */
            if ( FRCOUNT() < 3 ) {
                ERROR(STACKOVERFLOW) ;
                return(FALSE) ;
            }
#ifdef DBG_1pp
    printf("ex_idleproc1(0)...\n") ;
#endif
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            st_defaulttimeouts() ;
            POP(1) ;
            op_exch() ;
            POP(1) ;
            PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            se_settimeouts() ;

            /* inactivate it after using it */
            idle_flag = TRUE ;
        } /* if */
    } /* if-else */

    return(TRUE) ;
}

/*
 * execdict: idleproc
 * call by PS executive procedure
 * testing only
 * 7/23/90 ccteng
 */
fix
ex_idleproc()
{
    ex_idleproc1(0) ;

    return(0) ;
}

/************************************
 *  DICT: internal...
 *  NAME: firstsave
 *  FUNCTION: use as an internal function only
 *  INTERFACE: se_enterserver
 ************************************/
static  bool  near
ba_firstsave()
{
#ifdef DBG_1pp
    printf("ba_firstsave()...\n") ;
#endif

    //DJC UPD047
    if ( current_save_level >= MAXSAVESZ) {
        ba_firstrestore();
    }

    op_save() ;
    COPY_OBJ(GET_OPERAND(0), &sv1) ;
    POP(1) ;

#ifdef SCSI
    /* protect system area */
    PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, FALSE) ;
    op_setsysmode() ;
#endif

    return(TRUE) ;
}

/************************************
 *  DICT: internal...
 *  NAME: firstrestore
 *  FUNCTION: use as an internal function only
 *  INTERFACE: se_enterserver
 ************************************/
static  bool  near
ba_firstrestore()
{
#ifdef DBG_1pp
    printf("ba_firstrestore()...\n") ;
#endif

    PUSH_ORIGLEVEL_OBJ(&sv1) ;
    op_restore() ;

#ifdef SCSI
    /* open system area */
    PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, TRUE) ;
    op_setsysmode() ;
#endif

    return(TRUE) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: setrealdevice
 *  FUNCTION: dummy, for LaserPrep
 *  INTERFACE: interpreter
 ************************************/
fix
se_setrealdevice()
{
    return(0) ;
}

/************************************
 *  DICT: serverdict
 *  NAME: execjob
 *  FUNCTION: dummy, for LaserPrep
 *  INTERFACE: interpreter
 ************************************/
fix
se_execjob()
{
    return(0) ;
}

/*
 *  This operator name is not matching its usage.
 *  used to record and restore the execution stack status.
 *  flushexec(bool)
 *  bool == FALSE, save current execution stack status
 *  bool == TRUE, flush the execution stack to the saved pointer
 *  Added by ccteng, 2/28/90 for new 1PP modules
 */
static bool near
flushexec(l_exec)
bool l_exec ;
{
    static ufix16  l_execsave = 0xFFFF ;
    struct object_def FAR *temp_obj ;

    if (!l_exec) {
       l_execsave = execstktop ;
       id_flag = FALSE ;
    } else
       if (l_execsave != 0xFFFF) {
           id_flag = TRUE ;
           while ( execstktop > l_execsave ) {
/* qqq, begin */
                /*
                temp_obj = &execstack[execstktop-1];   |* get next object *|
                if ((TYPE(temp_obj) == OPERATORTYPE) && (ROM_RAM(temp_obj) == ROM)) {
                */
                temp_obj = GET_EXECTOP_OPERAND() ;
                if( (P1_ROM_RAM(temp_obj) == P1_ROM) &&
                    (TYPE(temp_obj) == OPERATORTYPE) ) {
/* qqq, end */
                  if (LENGTH(temp_obj) == AT_EXEC) {
                     if ( execstktop == l_execsave )
                         id_flag = FALSE ;
                     return(TRUE) ;                /* normal @exec */
                  }
               }
               POP_EXEC(1) ;
           } /* while */
           id_flag = FALSE ;
       }

    return(TRUE) ;
}   /* flushexec() */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\status.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * **********************************************************************
 *      File name:              STATUS.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * **********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    <string.h>
#include    "status.h"
#include    "user.h"
#include    "geieng.h"
#include    "geicfg.h"
#include    "geipm.h"
#include    "geitmr.h"
#include    "geisig.h"
#include    "geierr.h"

extern ufix32 far printer_status() ;
extern ufix32     save_printer_status ;
extern struct     object_def  FAR   *run_batch;
GEItmr_t          jobtime_tmr;
fix16             timeout_flag=0;
extern ufix8      jobtimeout_set;
int               jobtimeout_task();

static    unsigned long     job_time_out=  0L ;
static    unsigned long     wait_time_out=  30L ;
static    unsigned long     manual_time_out=  60L ;

extern  byte    job_name[], job_state[], job_source[] ;
extern  byte    TI_state_flag ;

extern  int     ES_flag ;       /* Added for emulation switch Aug-08,91 YM */
/*
 * ********************************************************************
 * TITLE:       st_setpassword              Date:   10/23/87
 * CALL:        st_setpassword()            UpDate: 06/20/90
 * INTERFACE:   interpreter:
 * CALLS:
 * ********************************************************************
 */
fix
st_setpassword()
{
    bool    l_bool ;
    byte FAR *l_char ;  /*@WIN*/
    ufix32  l_password ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    if (COUNT() < 2) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE)||(TYPE_OP(1) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_char = (byte FAR *)&l_password ;  /*@WIN*/
        GEIpm_read(PMIDofPASSWORD,l_char,sizeof(unsigned long)) ;
        if (l_password == (ufix32)VALUE_OP(1)) {
            l_password = (ufix32)VALUE_OP(0) ;
            GEIpm_write(PMIDofPASSWORD,l_char,sizeof(unsigned long)) ;
            l_bool = TRUE ;
        }
        else
            l_bool = FALSE ;
        POP(2) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* st_setpassword() */

/*
 * *******************************************************************
 * TITLE:       st_checkpassword                Date:   10/23/87
 * CALL:        st_checkpassword()              UpDate: 06/20/90
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_checkpassword()
{
    bool    l_bool ;
    ufix32  l_password ;

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else {
        GEIpm_read(PMIDofPASSWORD,(char FAR *)&l_password,      /*@WIN*/
            sizeof(unsigned long)) ;
        if (l_password == (ufix32)VALUE_OP(0))
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;
    }

    return(0) ;
}   /* st_checkpassword() */

/*
 * *******************************************************************
 * TITLE:       st_setdefaulttimeouts       Date:   10/23/87
 * CALL:        st_setdefaulttimeouts()     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_setdefaulttimeouts()
{
    toutcfg_t  time_temp ;


    if( (TYPE_OP(0) != INTEGERTYPE) || (TYPE_OP(1) != INTEGERTYPE) ||
            (TYPE_OP(2) != INTEGERTYPE) )
        ERROR(TYPECHECK) ;
    else if(COUNT() < 3)
        ERROR(STACKUNDERFLOW) ;
    //DJC put back else if (current_save_level)
    //DJC put back    ERROR(INVALIDACCESS) ;
    else if (((VALUE_OP(0)>0 && VALUE_OP(0)<15) || VALUE_OP(0)>2147483) ||
            (VALUE_OP(1)>2147483) || ((VALUE_OP(2)>0 && VALUE_OP(2)<15)
            || VALUE_OP(2)>2147483))
        ERROR(RANGECHECK) ;
    else {
        time_temp.jobtout = (unsigned long)VALUE_OP(2) ;
        time_temp.manualtout = (unsigned long)VALUE_OP(1) ;
        time_temp.waittout = (unsigned long)VALUE_OP(0) ;
        GEIpm_write(PMIDofTIMEOUTS,(char FAR *)&time_temp,sizeof(toutcfg_t)) ;
        POP(3);                    /*@WIN FAR*/
    }

    return(0) ;
}   /* st_setdefaulttimeouts() */

/*
 * *******************************************************************
 * TITLE:       st_defaulttimeouts          Date:   10/23/87
 * CALL:        st_defaulttimeouts()        UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 *********************************************************************
 */
fix
st_defaulttimeouts()
{
    toutcfg_t  time_temp ;

    if(FRCOUNT() < 3)
        ERROR(STACKOVERFLOW) ;
    else {
/*      GEIpm_read(PMIDofTIMEOUTS,(char *)&time_temp,sizeof(toutcfg_t)) ; */
        GEIpm_read(PMIDofTIMEOUTS, (char FAR *)&time_temp, 3*sizeof(long)); /*@WIN*/
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.jobtout) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.manualtout) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, time_temp.waittout) ;
    }

    return(0) ;
}   /* st_defaulttimeouts() */

#ifdef _AM29K
/************************************
* jobtimeout handler routine
************************************/
int jobtimeout_task()
{
  jobtimeout_set=0;
  GEItmr_stop(jobtime_tmr.timer_id);
  ERROR(TIMEOUT);
  GESseterror(ETIME);
  timeout_flag =1; /* jonesw */
  return(1);
}
#endif
/*
 * *******************************************************************
 * TITLE:       st_setjobtimeout            Date:   10/23/87
 * CALL:        st_setjobtimeout()          UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_setjobtimeout()
{
    if(COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if(TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if(VALUE_OP(0) & MIN31)
        ERROR(RANGECHECK) ;
    else {
        job_time_out = (unsigned long) VALUE_OP(0) ;
        POP(1) ;
#ifdef  _AM29K
          if (VALUE(run_batch))
          {
           if (job_time_out >  0)
           {
            if (jobtimeout_set != 1)
            {
             if (job_time_out > 2147483)
                jobtime_tmr.interval=2147483*1000;
             else
                jobtime_tmr.interval=job_time_out*1000;
             jobtime_tmr.handler=jobtimeout_task;
             jobtimeout_set=1;
             GEItmr_start(&jobtime_tmr);
            }
           }
           else
           {
            if (jobtimeout_set == 1)
            {
               jobtimeout_set=0;
               GEItmr_stop(jobtime_tmr.timer_id);
            }
           }
         }
         else
         {
           if (jobtimeout_set==1) {
               jobtimeout_set=0;
               GEItmr_stop(jobtime_tmr.timer_id);
           }
         }
#endif
    }

    return(0) ;
}   /* st_setjobtimeout() */

/*
 * *******************************************************************
 * TITLE:       st_jobtimeout               Date:   10/23/87
 * CALL:        st_jobtimeout()             UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:
 * *******************************************************************
 */
fix
st_jobtimeout()
{
    if(FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, job_time_out) ;
    }

    return(0) ;
}   /* st_jobtimeout() */

/*
 * *******************************************************************
 * TITLE:       st_setmargins                   Date:   02/23/87
 * CALL:        st_setmargins()                 UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setmargins()
{
    engcfg_t    margin ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if(COUNT() < 2) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if( (TYPE_OP(0) != INTEGERTYPE) || (TYPE_OP(1) != INTEGERTYPE) )
        ERROR(TYPECHECK) ;

    else if( ((fix32)VALUE_OP(0) > MAX15) ||
            ((fix32)VALUE_OP(1) > MAX15) ||
            ((fix32)VALUE_OP(0) < MIN15) ||
            ((fix32)VALUE_OP(1) < MIN15) )
        ERROR(RANGECHECK) ;
    else {                              /*@WIN FAR*/
        GEIpm_read(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        margin.topmargin = (unsigned long)VALUE_OP(1) ;
        margin.leftmargin = (unsigned long)VALUE_OP(0) ;
        GEIpm_write(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        POP(2) ;                       /*@WIN FAR*/
    }

    return(0) ;
}   /* st_setmargins */

/*
 * *******************************************************************
 * TITLE:       st_margins                      Date:   02/23/87
 * CALL:        st_margins()                    UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_margins()
{
    engcfg_t    margin ;

    if(FRCOUNT() < 2) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    else {                              /*@WIN FAR*/
        GEIpm_read(PMIDofPAGEPARAMS, (char FAR *)&margin,sizeof(engcfg_t)) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, margin.topmargin) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, margin.leftmargin) ;
    }

    return(0) ;
}   /* st_margins */

/*
 * *******************************************************************
 * TITLE:       st_setprintername               Date:   02/23/87
 * CALL:        st_setprintername()             UpDate: Feb/16/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setprintername()
{
    ufix16   l_len ;
    byte     *s_nme ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }
    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != STRINGTYPE)
        ERROR(TYPECHECK) ;
    else if (LENGTH_OP(0) > 31)
        ERROR(LIMITCHECK) ;
    else if (ACCESS_OP(0) >= EXECUTEONLY)
        ERROR(INVALIDACCESS) ;
    else if (current_save_level)
        ERROR(INVALIDACCESS) ;
    else {
        l_len = LENGTH_OP(0) ;
        s_nme = (byte *)VALUE_OP(0) ;
        s_nme[l_len] = '\0' ;
        GEIpm_write(PMIDofPRNAME,s_nme,_MAXPRNAMESIZE) ;
        POP(1) ;
    }

    return(0) ;
}   /* st_setprintername() */

/*
 * *******************************************************************
 * TITLE:       st_printername                  Date:   02/23/87
 * CALL:        st_printername()                UpDate: Feb/16/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_printername()
{
    ufix16  l_len=0 ;
    byte *prtnme ;

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != STRINGTYPE)
        ERROR(TYPECHECK) ;
    else if (ACCESS_OP(0) !=  UNLIMITED)
        ERROR(INVALIDACCESS) ;
    else {
        prtnme = (byte *)VALUE_OP(0) ;
        GEIpm_read(PMIDofPRNAME,prtnme,_MAXPRNAMESIZE) ;
        while (prtnme[l_len] != '\0')
            l_len++ ;
        if (l_len > LENGTH_OP(0))
            ERROR(RANGECHECK) ;
        else
            LENGTH_OP(0) = l_len ;
    }

    return(0) ;
}   /* st_printername() */

/*
 * *******************************************************************
 * TITLE:       st_setdostartpage               Date:   02/23/87
 * CALL:        st_setdostartpage()             UpDate: 06/20/90
 * INTERFACE:
 * CALLS:
 * *******************************************************************
 */
fix
st_setdostartpage()
{
    ubyte   l_byte ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != BOOLEANTYPE)
        ERROR(TYPECHECK) ;
    else {
        if (VALUE_OP(0))
            l_byte  = 1    ;
        else
            l_byte  = 0    ;
        GEIpm_write(PMIDofDOSTARTPAGE,&l_byte,sizeof(unsigned char)) ;
        POP(1) ;
        GEIsig_raise(GEISIGSTART, 1) ;       /* Raise STARTPAGE changed */
    }

    return(0) ;
}   /* st_setdostartpage() */

/*
 *********************************************************************
 * TITLE:       st_dostartpage                  Date:   02/23/87
 * CALL:        st_dostartpage()                UpDate: 06/20/90
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_dostartpage()
{
    ubyte   l_byte = 0;

    if (FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
        GEIpm_read(PMIDofDOSTARTPAGE,&l_byte,sizeof(unsigned char)) ;
        if (l_byte) {
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        } else {
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
        }
    }

    return(0) ;
}   /* st_dostartpage() */

/*
 *********************************************************************
 * TITLE:       st_setpagetype                  Date:   02/23/87
 * CALL:        st_setpagetype()                UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_setpagetype()
{
//  engcfg_t    page_temp ;     @WIN
    ubyte       l_data ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1)
        ERROR(STACKUNDERFLOW) ;
    else if (TYPE_OP(0) != INTEGERTYPE)
        ERROR(TYPECHECK) ;
    else if (VALUE_OP(0) > 0x7F)
        ERROR(RANGECHECK) ;
    else {
        l_data = (byte)VALUE_OP(0) ;
/* 3/19/91, JS
        GEIpm_read(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
        page_temp.pagetype  =l_data ;
        GEIpm_write(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
 */
        GEIpm_write(PMIDofPAGETYPE,&l_data,sizeof(unsigned char)) ;
        POP(1) ;
    }

    return(0) ;
}   /* st_setpagetype() */

/*
 *********************************************************************
 * TITLE:       st_pagetype                     Date:   02/23/87
 * CALL:        st_pagetype()                   UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:
 *********************************************************************
 */
fix
st_pagetype()
{
//  engcfg_t     page_temp ;    @WIN
    ubyte        l_byte ;

    if (FRCOUNT() < 1)
        ERROR(STACKOVERFLOW) ;
    else {
/* 3/19/91, JS
        GEIpm_read(PMIDofPAGEPARAMS, (char *)&page_temp,sizeof(engcfg_t)) ;
        l_byte =   page_temp.pagetype ;
 */
        GEIpm_read(PMIDofPAGETYPE,&l_byte,sizeof(unsigned char)) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)l_byte) ;
    }

    return(0) ;
}   /* st_pagetype() */

/*
 *********************************************************************
 * TITLE:       st_pagecount                    Date:   Jul/15/88
 * CALL:        st_pagecount()                  UpDate: Jul/15/88
 * INTERFACE:   interpreter
 * CALLS:
 *********************************************************************
 */
fix
st_pagecount()
{
    ufix32  t_pagecount[32],max ;
    int     i ;

    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
    } else {                            /*@WIN FAR*/
        GEIpm_read(PMIDofPAGECOUNT,(char FAR *)&t_pagecount[0],_MAXPAGECOUNT) ;
        max=t_pagecount[0] ;
        for (i=1 ;i<_MAXPAGECOUNT ;i++) {
            if (max < t_pagecount[i])
                max=t_pagecount[i] ;
            else
                break ;
        }
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, (ufix32)max) ;
    }

    return(0) ;
}   /* st_pagecount() */

/*
 *********************************************************************
 * TITLE:       init_status                     Date:   10/23/87
 * CALL:        init_status()                   UpDate: 06/20/88
 * INTERFACE:   start
 * CALLS:
 *********************************************************************
 */
void
init_status()
{
    /* Initialize EEROM if the first time */
    ST_inter_password = FALSE ;
}   /* init_status() */

/*
*********************************************************************
* TITLE:       printer_error                   Date:   Dec/20/88
* CALL:        printer_error(p_status)         UpDate: Dec/20/88
* INTERFACE:
*********************************************************************
*/
void
printer_error(p_status)
ufix32     p_status ;
{
//  byte    l_buf[60] ;         @WIN
    struct object_def   FAR *l_valueobj, FAR *l_tmpobj ;
    ufix16 l_len ;

    if(p_status == save_printer_status)
        return ;
    save_printer_status = p_status ;

/* 11-06-90, JS
    if(p_status & 0x80000000) {
        get_dict_value(MESSAGEDICT, EngineError, &l_valueobj) ;
    } else if(p_status & 0x10000000) {
        get_dict_value(MESSAGEDICT, EnginePrintTest, &l_valueobj) ;
    } else if(p_status & 0x00800000) {
        get_dict_value(MESSAGEDICT, CoverOpen, &l_valueobj) ;
    } else if(p_status & 0x04000000) {
        get_dict_value(MESSAGEDICT, ManualFeedTimeout, &l_valueobj) ;
    } else if(p_status & 0x01000000) {
        get_dict_value(MESSAGEDICT, TonerOut, &l_valueobj) ;
    } else if(p_status & 0x00400000) {
        get_dict_value(MESSAGEDICT, NoPaper, &l_valueobj) ;
    } else if(p_status & 0x00200000) {
        get_dict_value(MESSAGEDICT, PaperJam, &l_valueobj) ;
    }
 JS */

    switch(p_status)
    {
    case EngErrPaperOut :
         get_dict_value(MESSAGEDICT, NoPaper, &l_valueobj) ;
         break ;
    case EngErrPaperJam :
         get_dict_value(MESSAGEDICT, PaperJam, &l_valueobj) ;
         break ;
    case EngErrWarmUp :
         get_dict_value(MESSAGEDICT, WarmUp, &l_valueobj) ;
         break ;
    case EngErrCoverOpen :
         get_dict_value(MESSAGEDICT, CoverOpen, &l_valueobj) ;
         break ;
    case EngErrTonerLow :
         get_dict_value(MESSAGEDICT, TonerOut, &l_valueobj) ;
         break ;
    case EngErrHardwareErr :
         get_dict_value(MESSAGEDICT, EngineError, &l_valueobj) ;
         break ;
    default:
         return;
    }

    /* print message to screen */
    PUSH_OBJ(l_valueobj) ;
    get_dict_value(MESSAGEDICT, "reportprintererror", &l_tmpobj) ;
    interpreter(l_tmpobj) ;
    /* change jobstate */
    l_len = LENGTH(l_valueobj) ;
    lstrncpy(job_state, "PrinterError: \0", 15);        /*@WIN*/
    strncat(job_state, (byte *)VALUE(l_valueobj), l_len) ;
    job_state[l_len +14] = ';' ;
    job_state[l_len + 15] = ' ' ;
    job_state[l_len + 16] = '\0' ;
    TI_state_flag = 0;
    change_status() ;
    return ;
}  /* printer_error */

fix
st_softwareiomode()
{
    unsigned char   l_swiomode ;
                                /*@WIN FAR*/
    GEIpm_read(PMIDofSWIOMODE,(char FAR *)&l_swiomode,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_swiomode) ;

    return(0) ;
}   /* st_softwareiomode */

fix
st_setsoftwareiomode()
{
    unsigned char   l_swiomode ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_swiomode = (unsigned char)VALUE_OP(0) ;
//      if ((l_swiomode >=0) && (l_swiomode <= 5)) {
        if (l_swiomode <= 5) {          //@WIN; l_swiomode always >=0
/* Aug-08,91 YM
            GEIpm_write(PMIDofSWIOMODE,(char *)&l_swiomode,sizeof(char)) ;
*/
            if(l_swiomode == 5) ES_flag = PCL;
        } else
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_setsoftwareiomode */

fix
st_hardwareiomode()
{
    unsigned char   l_hwiomode='\0' ;
                                /*@WIN FAR*/
    GEIpm_read(PMIDofHWIOMODE,(char FAR *)&l_hwiomode,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_hwiomode) ;

    return(0) ;
}   /* st_hardwareiomode */

fix
st_sethardwareiomode()
{
    unsigned char   l_hwiomode ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_hwiomode = (unsigned char)VALUE_OP(0) ;
//      if ((l_hwiomode >=0) && (l_hwiomode <= 2)) {
        if (l_hwiomode <= 2) {    // @WIN; l_hwiomode always >=0
            GEIpm_write(PMIDofHWIOMODE,(char FAR *)&l_hwiomode,sizeof(char)) ;
        } else                          /*@WIN FAR*/
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_sethardwareiomode */

fix
st_dosysstart()
{
    unsigned char   l_dosysstart ;

    GEIpm_read(PMIDofSTSSTART,(char FAR *)&l_dosysstart,sizeof(char)) ;
    PUSH_VALUE(INTEGERTYPE,0,LITERAL,0,l_dosysstart) ;

    return(0) ;
}   /* st_dosysstart */

fix
st_setdosysstart()
{
    unsigned char   l_dosysstart ;

    if (current_save_level) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }

    if ((TYPE_OP(0) != INTEGERTYPE))
        ERROR(TYPECHECK) ;
    else {
        l_dosysstart = (unsigned char)VALUE_OP(0) ;
//      if ((l_dosysstart >=0) && (l_dosysstart <= 1)) {
        if (l_dosysstart <= 1) {      //@WIN; l_dosysstart always >=0
            GEIpm_write(PMIDofSTSSTART,(char FAR *)&l_dosysstart,sizeof(char)) ;
        } else                          /*@WIN FAR*/
            ERROR(RANGECHECK) ;
    }
    POP(1) ;

    return(0) ;
}   /* st_setdosysstart */

/*
 *********************************************************************
 * TITLE:       updatepc                        Date:   Jul/15/88
 * CALL:        updatepc()                      UpDate: 06/20/90
 * INTERFACE:   print_page
 * CALLS:
 *********************************************************************
 */
void
updatepc(p_pageno)
ufix32  p_pageno;
{
}   /* updatepc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\timer1.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 *  File: TIMER1.C
 *
 *     init_timer()
 *     close_timer()
 *     curtime()            <get current time>
 *     modetimer()          <set timer>
 *     gettimeout()         <get current timeout>
 *     settimer()           <set current time>
 *     manual()             <set/reset manual>
 *     check_timeout()      <get timeout status>
 */


// DJC added global include file
#include "psglobal.h"


#include "global.ext"
#include "geitmr.h"

/* timeout-time and absolute-time */
static ufix32 abs_timer = 0L ;        /* set absolute time              */
static ufix32 job_timer = 0L ;        /* set current job timeout        */
static ufix32 wait_timer = 0L ;       /* set current wait timeout       */
static ufix32 manual_timer = 0L ;     /* set current manualfeed timeout */

static ufix16 m_mode = 0 ;            /* manualfeed mode                */
static ufix16 t_mode = 0 ;            /* timeout setting mode           */

/* default timeout value */
static ufix32 d_job_timer = 0L ;      /* set default job timeout        */
static ufix32 d_wait_timer = 0L ;     /* set default wait timeout       */
static ufix32 d_manual_timer = 0L ;   /* set default manualfeed timeout */

/*
 * ---------------------------------------------------------------------
 */
void
init_timer()
{
    GEItmr_reset_msclock() ;

    return ;
}   /* init_timer */

/*
 * ----------------------------------------------------------------------
 */
void
close_timer()
{
    return ;
}   /* close_timer */

/*
 * ---------------------------------------------------------------------
 * set default timeout value: modetimer()
 * timer_mode:
 * +--------+-+-+-+-+    S: start timer
 * |        |S|M|W|J|    M: Manualfeed timeout
 * +--------+-+-+-+-+    W: Wait timeout
 *                       J: Job timeout
 * ---------------------------------------------------------------------
 */
void
modetimer(timer_array, timer_mode)
ufix32   FAR *timer_array ;
fix16    timer_mode ;
{
#ifdef DBG_timer
    printf("modetimer() timer_mode = %x\n", timer_mode) ;
#endif

    if (!(timer_mode & 0x000f))
       return ;

    /* get abs_timer */
    abs_timer = GEItmr_read_msclock() ;

    if (timer_mode & 0x0001) {  /* test job timeout */
       if (timer_array[0] != 0L) {
#ifdef DBG_timer
    printf("timer_array[0] = %d\n", timer_array[0]) ;
#endif
          d_job_timer = timer_array[0] ;
          if (timer_mode & 0x0008) {
             job_timer = abs_timer + d_job_timer ;
             t_mode |= 0x0001 ;
          }
       } else {
          d_job_timer = 0L ;
          t_mode &= 0xfe ;
       }
    }

    if (timer_mode & 0x0002) {  /* test wait timeout */
       if (timer_array[1] != 0L) {
#ifdef DBG_timer
    printf("timer_array[1] = %d\n", timer_array[1]) ;
#endif
          d_wait_timer = timer_array[1] ;
          if (timer_mode & 0x0008) {
             wait_timer = abs_timer + d_wait_timer ;
             t_mode |= 0x0002 ;
          }
       } else {
          d_wait_timer = 0L ;
          t_mode &= 0xfd ;
       }
    }

    if (timer_mode & 0x0004) {  /* test manualfeed timeout */
       if (timer_array[2] != 0L) {
#ifdef DBG_timer
    printf("timer_array[2] = %d\n", timer_array[2]) ;
#endif
          d_manual_timer = timer_array[2] ;
          if (timer_mode & 0x0008) {
             manual_timer = abs_timer + d_manual_timer ;
             t_mode |= 0x0004 ;
          }
       } else {
          d_manual_timer = 0L ;
          t_mode &= 0xfb ;
       }
    }
#ifdef DBG_timer
    printf("exit modetimer()\n") ;
#endif

    return ;
}   /* modetimer */

/*
 * ----------------------------------------------------------------
 * get the no# of seconds remaining before timeout: gettimeout()
 * timer_mode:
 * +----------+-+-+-+    M: Manualfeed timeout
 * |          |M|W|J|    W: Wait timeout
 * +----------+-+-+-+    J: Job timeout
 *
 * ---------------------------------------------------------------
 *
 */
void
gettimeout(timer_array, timer_mode)
ufix32   FAR *timer_array ;
fix16    timer_mode ;
{
#ifdef DBG_timer
    printf("gettimeout()\n") ;
#endif
    if (!(timer_mode & 0x0007))
       return ;

    /* get abs_timer */
    abs_timer = GEItmr_read_msclock() ;

    if (timer_mode & 0x0001) {
       if (!d_job_timer)
          timer_array[0] = 0L ;
       else
          timer_array[0] = job_timer - abs_timer ;
    }

    if (timer_mode & 0x0002) {
       if (!d_wait_timer)
          timer_array[1] = 0L ;
       else
          timer_array[1] = wait_timer - abs_timer ;
    }

    if (timer_mode & 0x0004) {
       if (!d_manual_timer)
          timer_array[2] = 0L ;
       else
          timer_array[2] = manual_timer - abs_timer ;
    }

    return ;
}   /* gettimeout() */

/*
 * ------------------------------------------------------
 */
void
settimer(time_value)
 ufix32   time_value ;
{
    GEItmr_reset_msclock() ;
}   /* settimer */

/*
 * -------------------------------------------------------
 */
ufix32
curtime()
{
    return( GEItmr_read_msclock() ) ;
}   /* curtime */

/*
 * ------------------------------------------------------------------
 */
void
manual(manual_flag)
bool16 manual_flag ;
{
#ifdef DBG_timer
    printf("manual()\n") ;
#endif
    m_mode = manual_flag ;

    return ;
}   /* manual */

/*
 * ----------------------------------------------------------------
 */
fix16
check_timeout()
{
    fix16    tt_flag ;

#ifdef DBG_timer
    printf("check_timeout()\n") ;
#endif

    tt_flag = 0 ;
    abs_timer = 0 ;

    /* Someone must do a ctc_set_timer and ctc_time_left for this
        stuff to really work.  I just hardcoded abs_timer
        to 0 until this is done.  */
    if (!t_mode)
       return(0) ;
    if (t_mode & 0x0001) {  /* job timeout */
       if (job_timer >= abs_timer) {
          tt_flag |= 0x01 ;
          t_mode  &= 0xfe ;
       }
    }

    if (t_mode & 0x0002) {  /* wait timeout */
       if (wait_timer >= abs_timer) {
          tt_flag |= 0x02 ;
          t_mode  &= 0xfd ;
       }
    }

    if (t_mode & 0x0004) {  /* manualfeed timeout */
       if (m_mode) { /* manualfeed mode */
          if (manual_timer >= abs_timer) {
             tt_flag |= 0x04 ;
             t_mode  &= 0xfb ;
          }
       }
    }

    return(tt_flag) ;
}   /* check_timeout */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\status.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              STATUS.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#include    "global.ext"
#include    "language.h"

#define     PASSWORD_STR    "ChRiStMaS^GrApHiC"

struct chan_params {
        byte channel ;
        ufix16 baud ;
        ufix16 parity ;
} ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\vm.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * *********************************************************************
 *      File name:              VM.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * 7/25/90 ; ccteng ; change op_restore to camment check_key_object call
 ************************************************************************
 */

// DJC added global include file
#include "psglobal.h"


#ifndef WDALN                   /* always set it @WIN */
#define WDALN
#endif

#include    "vm.h"


//DJC UPD045
bool g_extallocfail=FALSE;

/*
 *********************************************************************
 * This submodule implement the operator save.
 * Its operand and result objects on the operand stack are :
 *     -save- save
 * It creates a snapshot of the currunt state of the virtual memory and
 * returns a save object representing that snapshot.
 *
 * TITLE:       op_save                         Date:   00/00/87
 * CALL:        op_save()                       UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       alloc_vm:
 *              gsave_process:
 * *******************************************************************
 */
fix
op_save()
{
    byte   huge *l_ptr ;        /*@WIN 04-20-92*/

    /*
    ** The number of save level should be less than the maximum save level.
    ** There should be a free element in the operand stack.
    */
    if( current_save_level >= MAXSAVESZ ) {
        ERROR(LIMITCHECK) ;
        return(0) ;
    }

    if( FRCOUNT() < 1 )
        ERROR(STACKOVERFLOW) ;
    else{
        /*
        ** allocate virtual memory for the save object
        ** set initial values of the save object
        */
        /*  call gsave to save the graphics state ; */
        if( gsave_process(TRUE) ) {
            l_ptr = alloc_vm( (ufix32)sizeof(struct block_def) ) ;
            if( (ULONG_PTR)l_ptr != NIL ) {
/* qqq, begin */
#ifdef  DBG
                printf("save: cnt:%d, ctlvl:%d\n", cache_name_id.count,
                 current_save_level) ;
#endif
                if( cache_name_id.over ) {
                    cache_name_id.save_level = current_save_level ;
                    cache_name_id.count = 0 ;
                    cache_name_id.over = FALSE ;
                 }
/* qqq, end */
                saveary[current_save_level].fst_blk =   /*@WIN 04-20-92*/
                                            (struct block_def huge *)l_ptr ;
                saveary[current_save_level].curr_blk =  /*@WIN 04-20-92*/
                                            (struct block_def huge *)l_ptr ;
                saveary[current_save_level].offset = 0 ;
                saveary[current_save_level].packing = packed_flag ;
                saveary[current_save_level].curr_blk->previous = NIL ;

                /* push the save object onto the operand stack. */
                current_save_level++ ;
                PUSH_VALUE(SAVETYPE, 0, LITERAL, 0, (ufix32)current_save_level) ;
            } else
                ERROR(LIMITCHECK) ;     /* VMerror */
        }
    }

    return(0) ;
}   /* op_save */

/*
 *********************************************************************
 * This submodule implement the operator restore.
 * Its operand and result objects on the operand stack are :
 *     save -restore-
 * It resets the virtual memory to the state represented by the supplied
 * save object.
 *
 * TITLE:       op_restore                      Date:   00/00/87
 * CALL:        op_restore()                    UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       vm_close_file:
 *              check_key_object:
 *              update_dict_list:
 *              free_name_entry:
 *              op_grestoreall:
 *********************************************************************
 */
fix
op_restore()
{
    fix     l_i, l_j ;
    fix16   l_slevel ;
    ufix    l_type ;
    struct  cell_def   huge  *l_cellptr ;
    struct  block_def  huge  *l_blkptr ;
    struct  object_def       FAR *l_stkptr ;             /* qqq */
    struct  save_def         FAR *l_stemp = 0 ;

#ifdef  DBG
    printf("0:<value:%ld><current:%d>\n", VALUE_OP(0), current_save_level ) ;
    printf("OPERAND<top:%d>\n", opnstktop) ;
    printf("EXECUTION<type:%d>\n", l_type) ;
    printf("DICTIONARY<top:%d>\n", dictstktop) ;
#endif

    if(VALUE_OP(0) > current_save_level ) {
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }
    if(!current_save_level) {   /* current_save_level == 0 */
        ERROR(RANGECHECK) ;
        return(0) ;
    }

    l_slevel = (fix16)VALUE_OP(0) ;

    /*
    ** the save levels of composite objects on the execution,
    ** the operand and dictionary stacks should be less than the save level.
    */
    /*
    **  OPERAND STACK
    */
/* qqq, begin */
    /*
    for(l_i=0 ; l_i < (opnstktop-1) ; l_i++) {   |* top already checked *|
        l_type = (ufix)TYPE(&opnstack[l_i]) ;
    */
    for(l_i=0, l_stkptr=opnstack ; l_i < (fix)(opnstktop-1) ; l_i++, l_stkptr++) { //@WIN
        l_type = (ufix)TYPE(l_stkptr) ;
/* qqq, end */
        switch(l_type) {
            case SAVETYPE:
            case STRINGTYPE:
            case ARRAYTYPE:
            case PACKEDARRAYTYPE:
            case DICTIONARYTYPE:
            case FILETYPE:
            case NAMETYPE:
/* qqq, begin */
                /*
                if (LEVEL(&opnstack[l_i]) >= l_slevel)
                */
// DJC signed/unsigned mismatch warning
// DJC          if( LEVEL(l_stkptr) >= (ufix)l_slevel )         //@WIN
                if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel )         //@WIN
/* qqq, end */
                    break ;
            default:
                continue ;

        }   /* switch */
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }

    /*
    **  EXECUTION STACK
    */
/* qqq, begin */
    /*
    for (l_i = 0 ; l_i < execstktop ; l_i++) {
        l_type = (ufix)TYPE(&execstack[l_i]) ;
    */
    for(l_i=0, l_stkptr=execstack ; l_i < (fix)execstktop ; l_i++, l_stkptr++) { //@WIN
        l_type = (ufix)TYPE(l_stkptr) ;
/* qqq, end */
        switch (l_type) {
        /*
        case STRINGTYPE:
        */
        case ARRAYTYPE:
        case PACKEDARRAYTYPE:
        case DICTIONARYTYPE:
        case SAVETYPE:
        case NAMETYPE:
/* qqq, begin */
            /*
            if (LEVEL(&execstack[l_i]) >= l_slevel)
            */
// DJC signed/unsigned mismatch warning
// DJC      if( LEVEL(l_stkptr) >= (ufix)l_slevel )     //@WIN
            if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel )     //@WIN
/* qqq, end */
            break ;
        default:
             continue ;
        }   /* switch */
        ERROR(INVALIDRESTORE) ;
        return(0) ;
    }

    /*
    **  DICTIONARY STACK
    */
/* qqq, begin */
    /*
    for (l_i=0 ; l_i < dictstktop ; l_i++) {
        if(LEVEL(&dictstack[l_i]) >= l_slevel) {
    */
    for (l_i=0, l_stkptr=dictstack ; l_i < (fix)dictstktop ; l_i++, l_stkptr++) { //@WIN
// DJC signed/unsigned mismatch warning
// DJC  if( LEVEL(l_stkptr) >= (ufix)l_slevel ) {       //@WIN
        if( (ufix)(LEVEL(l_stkptr)) >= (ufix)l_slevel ) {       //@WIN
/* qqq, end */
            ERROR(INVALIDRESTORE) ;
            return(0) ;
        }
    }
    /*
    **  close file
    */
    vm_close_file(l_slevel) ;  /* current_save_level */

    /*
    ** RELEASE DIFF LINK
    */
/* qqq, begin */
    /*
    update_dict_list(l_slevel) ;
    */
#ifdef  DBG
    printf("cnt:%d, clvl:%d, slvl:%d\n", cache_name_id.count,
            cache_name_id.save_level, l_slevel-1) ;
#endif
    if( (cache_name_id.save_level <= (ufix16)(l_slevel-1)) &&     //@WIN
        (! cache_name_id.over) ) {
        for(l_j=0 ; l_j < cache_name_id.count ; l_j++) {
            update_dict_list(l_slevel, cache_name_id.id[l_j], 0) ;
        }
    } else {
        update_dict_list(l_slevel, 0, 1) ;
    }
    cache_name_id.save_level = l_slevel - 1 ;
    cache_name_id.count = 0 ;
    cache_name_id.over = FALSE ;
/* qqq, end */

    for(l_j = current_save_level - 1 ; l_j >= l_slevel - 1 ; l_j--) {
        l_stemp = &saveary[l_j] ;
        /*  restore the graphics state ; */
        grestoreall_process(TRUE) ;

        /*
        ** sequentially restore save objects until the specified save object.
        */

        l_blkptr = l_stemp->curr_blk ;

        /*
        **  PROCESS THE LAST BLOCK
        **
        **  process each cell
        */
        l_i = l_stemp->offset - 1 ;
        while(l_i >= 0) {
            l_cellptr = &(l_blkptr->block[l_i]) ;
            COPY_OBJ( &(l_cellptr->saveobj), l_cellptr->address ) ;
         /* 7/25/90 ccteng, change from PJ
          * check_key_object(l_cellptr->address) ;
          */
            l_i-- ;
        }

        /*
        **  MORE THAN ONE BLOCK
        **
        **  process each block
        */
        if(l_blkptr->previous != NIL) {
            do {
                l_blkptr = l_blkptr->previous ;     /* to previous block */
                l_i = VM_MAXCELL - 1 ;
                /* process each cell */
                while(l_i >= 0) {
                    l_cellptr = &(l_blkptr->block[l_i]) ;
                    COPY_OBJ( &(l_cellptr->saveobj), l_cellptr->address ) ;
                 /* 7/25/90 ccteng, change from PJ
                  * check_key_object(l_cellptr->address) ;
                  */
                    l_i-- ;
                }
            } while(l_blkptr->previous != NIL) ;
        }
        current_save_level-- ;                  /* update save level */
    }   /* for */

    packed_flag = l_stemp->packing ;             /* restore packed flag */
    //DJC vmptr = (byte huge *)l_stemp->fst_blk ;    /* update free VM pointer */

    //DJC, fix from history.log UPD013
    free_vm((char FAR *) l_stemp->fst_blk);
    POP(1) ;

    return(0) ;
}   /* op_restore */

/*
 * *******************************************************************
 * This submodule implements the operator vmstatus.
 * Its operand and result objects on the operand stack are :
 *     -vmstatus- level used maximum
 * It returns three integer objects, level, used, and
 * maximum object, on the operand stack.
 *
 * TITLE:       op_vmstatus                     Date:   00/00/87
 * CALL:        op_vmstatus()                   UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_vmstatus()
{
    ufix32  l_temp ;

    /*
    (* check operand *)
    if( FRCOUNT() < 3 )
        ERROR(STACKOVERFLOW) ;
    else {
        (*
        ** push the level, used, maximum objects onto the operand stack.
        *)
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)current_save_level) ;
        DIFF_OF_ADDRESS(l_temp, ufix32, vmptr, (byte huge *)VMBASE) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, l_temp) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)MAXVMSZ) ;
    }
    */
    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        goto l_vms ;
    } else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, (ufix32)current_save_level) ;
    }

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
        goto l_vms ;
    } else {
        DIFF_OF_ADDRESS(l_temp, ufix32, vmptr, (byte huge *)VMBASE) ;
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0, l_temp) ;
    }

    if( FRCOUNT() < 1 ) {
        ERROR(STACKOVERFLOW) ;
    } else {
        PUSH_VALUE(INTEGERTYPE, 0, LITERAL,0,
            (ufix32)(vmheap - (byte huge *)VMBASE)) ;
    }

l_vms:
    return(0) ;
}   /* op_vmstatus */

/*
 * *******************************************************************
 * This submodule save the given object in the current save object.
 *
 * TITLE:       save_obj                        Date:   00/00/87
 * CALL:        save_obj()                      UpDate: Jul/12/88
 * INTERFACE:
 * CALLS:       alloc_vm:
 * *******************************************************************
 */
bool
save_obj(p_obj)
struct  object_def  FAR *p_obj ;
{
    byte   huge *l_ptr ;        /*@WIN 04-20-92*/
    struct  cell_def    huge *l_cellptr ;
    struct  save_def    FAR *l_stemp ;
    struct  block_def   FAR *l_previous ;

    if( current_save_level == 0 ) return(TRUE) ;
    l_stemp = &saveary[current_save_level-1] ;

    /*
    ** if the current block is full, allocate a new block.
    */
    if( l_stemp->offset >= VM_MAXCELL ) {
        //DJC fix for UPD045
        l_ptr = (byte huge *)extalloc_vm( (ufix32)sizeof(struct block_def) ) ;
        if( (ULONG_PTR)l_ptr == NIL ) return(FALSE) ;
        l_previous = l_stemp->curr_blk ;
        l_stemp->curr_blk = (struct block_def huge *)l_ptr ; /*@WIN04-20-92*/
        l_stemp->curr_blk->previous = l_previous ;
        l_stemp->offset = 0 ;
    }
    /*
    ** save the address and the content of the object, and update the pointer.
    */
    l_cellptr = &(l_stemp->curr_blk->block[l_stemp->offset]);
    l_cellptr->address = p_obj ;               /* save object's address */
    COPY_OBJ(p_obj, &(l_cellptr->saveobj)) ;   /* save object's contain */
    l_stemp->offset++ ;

    return(TRUE) ;
}   /* save_obj */

/*
 * *******************************************************************
 * This submodule allocates a block of virtual memory from VM.
 *
 * TITLE:       alloc_vm                        Date:   00/00/87
 * CALL:        alloc_vm                        UpDate: Jul/12/88
 * INTERFACE:
 * *******************************************************************
 */
byte  HUGE *                    /*@WIN*/
alloc_vm(p_size)
 ufix32  p_size ;
{
 byte    huge *l_begin ;        /*@WIN*/
// ufix32  p1 ;                   @WIN
// fix32   l_diff ;               @WIN
 ufix32 offset;

#ifdef XXX                      /* @WIN */
#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    if (l_diff <= (fix32)p_size) {
       ERROR(VMERROR) ;
       return((byte FAR *)NIL) ;
    } else {

#ifdef SOADR
       /* For Intel Seg/Off CPU Only. If p_size >= 64KB,  */
       /* the offset must be aligned in 8-bytes boundary. */
       l_off = (ufix)vmptr & 0x0F ;
       if ((p_size + l_off) >= 0x010000) {
          if (l_off & 0x07) {
             if (l_off & 0x08) {                  /* 8 < x < F */
                vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF0) ;
                vmptr = (byte huge *)((ufix32)vmptr + 0x10000) ;
             } else {                            /* 0 < x < 8 */
                vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF8) ;
                vmptr += 8 ;
             }
          }
       }
#endif /* SOADR */

       l_begin = vmptr ;
       vmptr += p_size ;               /* update free VM pointer */
       ADJUST_SEGMENT(vmptr, p1) ;
       vmptr = (byte huge *)p1 ;
       return(l_begin) ;
    }
#endif
#ifdef DJC
    offset = ((ufix32)vmptr) & 0x0000FFFFL;
    if (((p_size + offset) & 0x0000FFFFL) < offset) { /* cross 64K boundary */
        vmptr += p_size;
        l_begin = (byte huge *) (((ufix32)vmptr) & 0xFFFF0000L); //@WIN
        vmptr = l_begin + p_size;
        return(l_begin) ;
    } else {
#endif

// DJC add WORD align stuff
        p_size = WORD_ALIGN(p_size) ;


        l_begin = vmptr;
        vmptr += p_size;   /* update free VM pointer */
        return(l_begin) ;
#ifdef DJC
    }
#endif

} /* alloc_vm */

/*
 * *******************************************************************
 * This submodule deallocates a block of virtual memory to VM.
 *
 * TITLE:       free_vm                         Date:   00/00/87
 * CALL:        free_vm()                       UpDate: Jul/12/88
 * INTERFACE:
 * *******************************************************************
 */
void
free_vm(p_pointer)
byte   huge *p_pointer ;        /*@WIN 04-20-92*/
{
    vmptr = (byte huge *)p_pointer ;
} /* free_vm */

/*
 * *******************************************************************
 * TITLE:       init_vm             Date:   08/01/87
 * CALL:        init_vm()           UpDate: Jul/12/88
 * INTERFACE:   start:
 * *******************************************************************
 */
void
init_vm()
{
 ULONG_PTR  p1 ;

    /* far data */
    saveary = (struct save_def far *)           /* @WIN; take out near */
              fardata( (ufix32)MAXSAVESZ * sizeof(struct save_def ) ) ;

    ADJUST_SEGMENT(VMBASE, p1) ;
    vmptr = (byte huge *)p1 ;
    ADJUST_SEGMENT((ULONG_PTR)(vmptr + MAXVMSZ), p1) ;
    vmheap = (byte huge *)p1 ;

    current_save_level = 0 ;
/* qqq, begin */
    cache_name_id.save_level = 0 ;
    cache_name_id.count = 0 ;
    cache_name_id.over = FALSE ;
/* qqq, end */
} /* init_vm */

/*
 * *******************************************************************
 * maintain the associated dict_list, while restoring vm
 * before doing this function, make sure these name entries, created by
 * this save level, had been released.
 *
 * TITLE:       update_dict_list                Date:   00/00/87
 * CALL:        update_dict_list()              UpDate: Jul/12/88
 * INTERFACE:   op_restore:
 * CALLS:       free_name_entry:
 * *******************************************************************
 */
static void near
/* qqq, begin */
/*
update_dict_list(p_level)
fix16  p_level ;                             |* restore level *|
*/
update_dict_list(p_level, p_index, p_mode)
fix    p_level ;                             /* restore level */
fix    p_index ;
fix    p_mode ;
/* qqq, end */
{
    struct dict_content_def  FAR *l_curptr, FAR *l_lastptr ;
    fix    l_i ;

/* qqq, begin */
    /*
    for (l_i = 0 ; l_i < MAXHASHSZ ; l_i++) {
    */
    fix    l_limit ;

    if( p_mode == 1 ) {
        l_i = 0 ;
        l_limit = MAXHASHSZ ;
    } else {
        l_i = p_index ;
        l_limit = p_index + 1 ;
    }
    for ( ; l_i < l_limit ; l_i++) {
/* qqq, end */
    /*
     * skip if it is a null name entry or a nil dict_list
     */
         /* change structure of name_table */
        if (name_table[l_i] == NIL)
           continue ;

        if( free_name_entry(p_level, l_i) )
            continue ;

        if ((ULONG_PTR)name_table[l_i]->dict_ptr >= SPECIAL_KEY_VALUE) {
            /*
             * deleting free_name_entry
             * search for each dict_list, and maintain its chain ptr
             */
            l_lastptr = NIL ;
            l_curptr = name_table[l_i]->dict_ptr ;
            while ((ULONG_PTR)l_curptr >= SPECIAL_KEY_VALUE) {
// DJC signed/unsigned mismatch warning
// DJC          if (LEVEL(&l_curptr->k_obj) >= (ufix16)p_level) { //@WIN
                if ((ufix16)(LEVEL(&l_curptr->k_obj)) >= (ufix16)p_level) { //@WIN
                    if ((ULONG_PTR)l_lastptr < SPECIAL_KEY_VALUE) {   /* 1st element */
                        name_table[l_i]->dict_ptr =
                                (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
                        /* name list changed */
                        name_table[l_i]->dict_found = FALSE ;
                    } else  {
                        VALUE(&l_lastptr->k_obj) = VALUE(&l_curptr->k_obj) ;
                        l_curptr = (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
                        continue ;
                    }

#ifdef DBG
            printf("free from name LIST(%d):<", l_i) ;
            GEIio_write(GEIio_stdout, name_table[l_i]->text, name_table[l_i]->name_len) ;
            printf(">(%lx)\n", VALUE(&l_curptr->k_obj)) ;

#endif /* DBG */
                } else
                    l_lastptr = l_curptr ;

                l_curptr = (struct dict_content_def FAR *)VALUE(&l_curptr->k_obj) ;
            } /* while */
        } /* else */
    } /* for */
}   /* update_dict_list */

/*
 * *********************************************************************
 * This submodule allocates a block of virtual memory from bottom of VM.
 *
 * TITLE:       alloc_heap                      Date:   03/29/89, by J. Lin
 * CALL:        alloc_heap                      UpDate:
 * INTERFACE:
 * *******************************************************************
 */
byte  FAR *
alloc_heap(p_size)
 ufix32  p_size ;
{
 ULONG_PTR  p1 ;
// fix32   l_diff ;
 ufix32   l_diff ;      //@WIN

#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    l_diff -= 256 ;     /* pj 4-30-1991 */
    if (l_diff <= p_size) {
       ERROR(VMERROR) ;
       return((byte FAR *)NIL) ;
    } else {
       vmheap -= p_size ;  /* @WIN update free VM_heap pointer */
       ADJUST_SEGMENT((ULONG_PTR)vmheap, p1) ;
       vmheap = (byte huge *)p1 ;
       return((byte huge *)p1) ;        /* 04-20-92 @WIN */
    }
} /* alloc_heap() */

/*
 * *******************************************************************
 * This submodule free a block of virtual memory to VM.
 *
 * TITLE:       free_heap                       Date:   03/29/89, by J. Lin
 * CALL:        free_heap()                     UpDate:
 * INTERFACE:
 * *******************************************************************
 */
void
free_heap(p_pointer)
 byte   huge *p_pointer ;       /*@WIN 04-20-92*/
{
    vmheap = (byte huge *)p_pointer ;
} /* free_heap() */

/*
 * *******************************************************************
 * This submodule allocates a block of virtual memory from VM.
 *
 * TITLE:       extalloc_vm
 * CALL:        extalloc_vm
 * INTERFACE:
 * *******************************************************************
 */
byte  FAR  *
extalloc_vm(p_size)
 ufix32  p_size ;
{
 fix32   l_diff ;

#ifdef WDALN
    p_size = WORD_ALIGN(p_size) ;
#endif /* WDALN */

    DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

    /* error if reaches maximum of the virtual memory */
    //DJC UPD045
    if (!g_extallocfail) {
      l_diff -= 512 ;
    }

    if (l_diff <= (fix32)p_size) {
       ERROR(VMERROR) ;
       //DJC UPD045
       g_extallocfail = TRUE;
       return((byte huge *)NIL) ;
    } else {
       return(alloc_vm(p_size)) ;
    }
} /* extalloc_vm */
/* qqq, begin */
/*
************************************************************************
*   Name:       vm_cache_index
************************************************************************
*/
void
vm_cache_index(p_index)
fix     p_index ;
{
#ifdef  DBG
    printf("idx:%d, cnt:%d\n", p_index, cache_name_id.count) ;
#endif
    if( cache_name_id.count ==  MAX_VM_CACHE_NAME ) {
        cache_name_id.over = TRUE ;
        return ;
    }
   if( (cache_name_id.count != 0) &&
       (p_index == cache_name_id.id[cache_name_id.count-1]) )
        return ;
    cache_name_id.id[cache_name_id.count] = (fix16)p_index ;
    cache_name_id.count++ ;
}   /* vm_cache_index */
/* qqq, end */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\user.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              USER.H
 *      Author:                 CC Teng
 *      Date:                   11/21/89
 *      Owner:                  Microsoft Co.
 *      Description: this file was built for new 1pp code
 *
 * revision history:
 *
 ************************************************************************
 */
#define                 SYSTEMDICT              "systemdict"
#define                 USERDICT                "userdict"
#define                 STATUSDICT              "statusdict"
#define                 ERRORDICT               "errordict"
#define                 SERVERDICT              "serverdict"
#define                 DERROR                  "$error"
#define                 PRINTERDICT             "printerdict"
#define                 IDLETIMEDICT            "$idleTimeDict"
#define                 FONTDIRECTORY           "FontDirectory"
#define                 EXECDICT                "execdict"
#define                 MESSAGEDICT             "messagedict"
//DJC
#define                 PSPRIVATEDICT           "psprivatedict" //DJC new

#define                 JobBusy                 "JobBusy"
#define                 JobIdle                 "JobIdle"
#define                 JobInitializing         "JobInitializing"
#define                 JobPrinting             "JobPrinting"
#define                 JobStartPage            "JobStartPage"
#define                 JobTestPage             "JobTestPage"
#define                 JobWaiting              "JobWaiting"
#define                 SourceAppleTalk         "SourceAppleTalk"
#define                 SourceEtherTalk         "SourceEtherTalk"
#define                 SourceSerial9           "SourceSerial9"
#define                 SourceSerial25          "SourceSerial25"
#define                 CoverOpen               "CoverOpen"
#define                 NoPaper                 "NoPaper"
#define                 NoPaperTray             "NoPaperTray"
#define                 NoResponse              "NoResponse"
#define                 PaperJam                "PaperJam"
#define                 WarmUp                  "WarmUp"
#define                 TonerOut                "TonerOut"
#define                 ManualFeedTimeout       "ManualFeedTimeout"
#define                 EngineError             "EngineError"
#define                 EnginePrintTest         "EnginePrintTest"

/*
 *  data for setscreen
 */
#define                 FREQUENCY               60
#define                 ANGLE                   45

/*
 *  Added for emulation switch  Aug-08,91 YM
 */
#define                 PDL                     0
#define                 PCL                     5

/*
 *  macros
 */
#define     SET_NULL_OBJ(obj)\
            {\
                TYPE_SET(obj, NULLTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = 0 ;\
            }

#define     SET_TRUE_OBJ(obj)\
            {\
                TYPE_SET(obj, BOOLEANTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = TRUE ;\
            }

#define     SET_FALSE_OBJ(obj)\
            {\
                TYPE_SET(obj, BOOLEANTYPE) ;\
                ACCESS_SET(obj, UNLIMITED) ;\
                ATTRIBUTE_SET(obj, LITERAL) ;\
                ROM_RAM_SET(obj, RAM) ;\
                LEVEL_SET(obj, current_save_level) ;\
                (obj)->length = 0 ;\
                (obj)->value = FALSE ;\
            }

extern  bool16  doquit_flag ;
extern  bool16  startup_flag ;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\string.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * **********************************************************************
 *      File name:              STRING.C
 *      Author:                 Ping-Jang Su
 *      Date:                   05-Jan-88
 *
 * revision history:
 * Jan-30-89 PJ: . op_string: check vmptr for iLaser version
 *                            if across segment
 * Dec-06-88 PJ: . putinterval_string():
 *                 delete statement:
 *                 LENGTH(p_d_string) = l_length ;
 * May-03-88 PJ: save level & PUSH_OBJ
 * **********************************************************************
 */


// DJC added global include file
#include "psglobal.h"


#include    "global.ext"
#include    "language.h"

/*
 *********************************************************************
 * This operator is used to creates a string of length num, each of
 * whose elements is initialized with the integer 0, and pushes this
 * string on the operand stack. The num operand must be a non-negative
 * integer not greater than the maximum allowable string length.
 *
 * TITLE:       op_string                       Date:   08/01/87
 * CALL:        op_string()                     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * CALLS:       create_string:
 *********************************************************************
 */
fix
op_string()
{
    struct  object_def  l_save ;

    if( ((fix32)VALUE_OP(0) < 0) ||
        ((ufix32)VALUE_OP(0) > MAXSTRCAPSZ) )
        ERROR(RANGECHECK) ;
    /*
    **  this operand must be a non-negative integer and not greater
    **  than the maximum allowable string length
    */
    else {
#ifdef SOADR
        {
         ufix    l_off ;
         fix32   l_diff ;

         /* For Intel Seg/Off CPU Only. */
         l_off = (ufix)vmptr & 0x0F ;
         if( (VALUE_OP(0) + l_off) >= 0x010000 ) {
             DIFF_OF_ADDRESS(l_diff, fix32, vmheap, vmptr) ;

             /* error if reaches maximum of the virtual memory */
             if (l_diff <= 0x10) {   /* one seg */
                 ERROR(VMERROR) ;
                 return(0) ;
             } else {
                 vmptr = (byte huge *)((ufix32)vmptr & 0xFFFFFFF0) ;
                 vmptr = (byte huge *)((ufix32)vmptr + 0x10000) ;
             }
         }
        }
#endif
        if( create_string(&l_save, (ufix16)VALUE_OP(0)) )
            COPY_OBJ( &l_save, GET_OPERAND(0) ) ;
    }

    return(0) ;
}   /* op_string */

/*
 * *******************************************************************
 * This operator is used to determine whether the string 'seek' matches
 * the initial substring of 'string'. If so, Anchorsearch_op splits
 * 'string' into two segments: 'match', the portion of 'string' that
 * matches 'seek', and 'post', the remainder of 'string' ; it then pushes
 * the string object 'post' and 'match' and the boolean true. If not,
 * it pushes the original 'string' and the boolean false.
 *
 * TITLE:       op_anchorsearch                 Date:   08/01/87
 * CALL:        op_anchorsearch()               UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_anchorsearch()
{
    ufix16  l_len1, l_len2, l_index ;
    byte    FAR *l_string, FAR *l_seek ;

    /*
     *  check access right
     */
    if( (ACCESS_OP(1) >= EXECUTEONLY) ||
        (ACCESS_OP(0) >= EXECUTEONLY) ) {
        ERROR(INVALIDACCESS) ;
        return(0) ;
    }

    l_len1 = LENGTH_OP(1) ;
    l_len2 = LENGTH_OP(0) ;
    l_string = (byte FAR *)VALUE_OP(1) ;
    l_seek = (byte FAR *)VALUE_OP(0) ;

    /*
     *  seek matches the initial substring of string ?
     */
    for(l_index = 0 ; (l_index < l_len1) && (l_index < l_len2) ; l_index++)
        if( l_string[l_index] != l_seek[l_index] )  break ;

    /*
     *  match
     */
    if( l_index == l_len2 ) {
        if( FRCOUNT() < 1 ) {
            POP(2) ;
            ERROR(STACKOVERFLOW) ;
        } else {
            /*
             *  split string into two segments:
             *  match: the portion of string that matches seek
             *  post:  the remainder of string
             *
             *  push 'postobj', 'matchobj', 'bool' to operand stack
             */
            VALUE_OP(0) = VALUE_OP(1) ;
            VALUE_OP(1) = VALUE_OP(0) + l_len2 ;
            LENGTH_OP(1) = l_len1 - l_len2 ;
            LENGTH_OP(0) = l_len2 ;
            LEVEL_OP_SET(0, LEVEL_OP(1)) ;
            ACCESS_OP_SET(0, ACCESS_OP(1)) ;
            ATTRIBUTE_OP_SET(0, ATTRIBUTE_OP(1)) ;
            PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
        }
    } else {
        /*
         *  not match
         *
         *  push 'bool' to operand stack
         */
        POP(1) ;
        PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;
    }

    return(0) ;
}   /* op_anchorsearch */

/*
 * *******************************************************************
 * This operator is used to look for the first occurrence of the string
 * 'seek' within 'string' and return results of theis search on the
 * operand stack. The topmost result is a boolean that indicates whether
 * the search succeeded or not.
 *
 * If Search_op finds a subsequence of 'string' whose elements are equal
 * to the elements of 'seek', it splits string into three segments:
 * preobj, matchobj, and postobj. It then pushes the string objects
 * postobj, matchobj, preobj on the operand stack, followed by the
 * boolean true. All three of these strings are substrings sharing
 * intervals of the value of the original string.
 *
 * If Search_op does not find a match, it pushes the original string and
 * the boolean false.
 *
 * TITLE:       op_serach                       Date:   08/01/87
 * CALL:        op_search()                     UpDate: Jul/12/88
 * INTERFACE:   interpreter:
 * *******************************************************************
 */
fix
op_search()
{
    ufix     l_access, l_attribute ;
    byte     FAR *l_string, FAR *l_seek ;
    ufix16   l_len1, l_len2, l_index, l_i1, l_i2, l_temp ;
    ufix16   l_post_length ;
    ULONG_PTR   l_match_position;
    ULONG_PTR   l_pre_position, l_post_position ;

    /*
     *  check access right
     */
    if ((ACCESS_OP(1) >= EXECUTEONLY) || (ACCESS_OP(0) >= EXECUTEONLY)) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    l_len1 = LENGTH_OP(1) ;
    l_access = ACCESS_OP(1) ;
    l_attribute = ATTRIBUTE_OP(1) ;

    l_len2 = LENGTH_OP(0) ;
    l_string = (byte FAR *)VALUE_OP(1) ;
    l_seek = (byte FAR *)VALUE_OP(0) ;

    /*
     *  look for the occurrence of the string [seek] within [string]
     */
    if (l_len1) {
        for (l_index = 0 ; l_index < l_len1 ; l_index++) {
            l_i1 = l_index ;
            for (l_i2 = 0 ; (l_i1 < l_len1) && (l_i2 < l_len2) ; l_i1++, l_i2++)
                if (l_string[l_i1] != l_seek[l_i2])
                    break ;

            if (l_i2 == l_len2) {
                if (FRCOUNT() < 2) {
                    ERROR(STACKOVERFLOW) ;
                } else {
                    l_pre_position = VALUE_OP(1) ;
                    l_temp = l_index + l_len2 ;
                    l_post_position = VALUE_OP(1) + l_temp ;
                    if (l_temp == l_len1)
                        l_post_length = 0 ;
                    else
                        l_post_length = l_len1 - l_temp ;
                    l_match_position = VALUE_OP(1) + l_index ;

                    /*
                     *  push 'postobj', 'matchobj', 'preobj', 'bool' to operand
                     *  stack.
                     */
                    LENGTH_OP(1) = l_post_length ;
                    VALUE_OP(1) = l_post_position ;

                    LENGTH_OP(0) = l_len2 ;
                    VALUE_OP(0) = l_match_position ;
                    LEVEL_OP_SET(0, LEVEL_OP(1)) ;
                    ACCESS_OP_SET(0, l_access) ;
                    ATTRIBUTE_OP_SET(0, l_attribute) ;

                    PUSH_VALUE(STRINGTYPE, l_access, l_attribute, l_index, l_pre_position) ;
                    LEVEL_OP_SET(0, LEVEL_OP(2)) ;

                    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, TRUE) ;
                } /* else */
                return(0) ;
            } /* if (l_i2 == l_len2) */
        } /* for */
    }

    /*
     *  not match,
     *  push 'bool' to operand stack
     */
    POP(1) ;
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, FALSE) ;

    return(0) ;
}   /* op_search() */

/*
 * *******************************************************************
 * TITLE:       getinterval_string              Date:   08/01/87
 * CALL:        getinterval_string()            UpDate: Jul/12/88
 * INTERFACE:   op_getinterval:
 * *******************************************************************
 */
bool
getinterval_string(p_string, p_index, p_count, p_retobj)
struct  object_def  FAR *p_string, FAR *p_retobj ;
ufix16  p_index, p_count ;
{
    byte   huge *l_temp ;

    /*
    **  index must be a valid index in the original array and
    **  count to be a non-negative integer, and index+count is not
    **  greater than the length of the original string
    */
    if( ((ufix32)p_count + p_index) > LENGTH(p_string) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_temp = (byte huge *)VALUE(p_string)  + p_index ;
    /*
    **  MAKE A NEW OBJECT
    */
    COPY_OBJ(p_string, p_retobj) ;
    VALUE(p_retobj) = (ULONG_PTR) l_temp ;
    LENGTH(p_retobj) = p_count ;
    LEVEL_SET(p_retobj, LEVEL(p_string)) ;

    return(TRUE) ;
}  /* getinterval_string */

/*
 * *******************************************************************
 * TITLE:       putinterval_string              Date:   08/01/87
 * CALL:        putinterval_string()            UpDate: Jul/12/88
 * INTERFACE:   op_putinterval:
 * *******************************************************************
 */
bool
putinterval_string(p_d_string, p_index, p_s_string)
struct  object_def  FAR *p_s_string, FAR *p_d_string ;
ufix16  p_index ;
{
    ufix16  l_i, l_length ;
    byte    huge *l_sptr, huge *l_dptr ;


    l_length = LENGTH(p_s_string) ;
    /*
    **  index to be a valid index in string, index plus the length
    **  of string2 is not greater than the length of array1
    */
    /* ?? if overflow */
    if( ((ufix32)p_index + l_length) > LENGTH(p_d_string) ) {
        ERROR(RANGECHECK) ;
        return(FALSE) ;
    }

    l_dptr = (byte huge *)VALUE(p_d_string) + p_index ;
    l_sptr = (byte huge *)VALUE(p_s_string) ;

    /* SOURCE STRING ==> DESTINATION STRING */
    if ((l_sptr + l_length) < l_dptr) {
        for(l_i = 0 ; l_i < l_length ; l_i++)
            *l_dptr++ = *l_sptr++  ;
    } else {
        l_sptr += l_length - 1 ;
        l_dptr += l_length - 1 ;
        for(l_i = l_length ; l_i > 0 ; l_i--)
            *l_dptr-- = *l_sptr-- ;
    }

    return(TRUE) ;
}   /* putinterval_string */

/*
 * *******************************************************************
 * TITLE:       forall_string                   Date:   08/01/87
 * CALL:        forall_string()                 UpDate: Jul/12/88
 * INTERFACE:   op_forall:
 * *******************************************************************
 */
bool
forall_string(p_string, p_proc)
struct  object_def  FAR *p_string, FAR *p_proc ;
{
    if( FREXECOUNT() < 3 ) {
        ERROR(EXECSTACKOVERFLOW) ;
        return(FALSE) ;
    }

    PUSH_EXEC_OBJ(p_proc) ;
    PUSH_EXEC_OBJ(p_string) ;
    PUSH_EXEC_OP(AT_STRINGFORALL) ;

    return(TRUE) ;
}   /* forall_string */

/*
 * ******************************************************************
 * TITLE:       create_string                   Date:   08/01/87
 * CALL:        create_string(obj, size)        UpDate: Jul/12/88
 * INTERFACE:   op_string:
 * CALLS:       alloc_vm:
 * ******************************************************************
 */
bool
create_string(p_obj, p_size)
struct  object_def  FAR *p_obj ;
ufix16   p_size ;
{
    byte   FAR *l_string, huge *l_temp ;
    ufix16  l_i ;

    if( p_size != 0 ) {                     /* ?? less than 64K - 16B */
        l_string = extalloc_vm((ufix32)p_size) ;
        if( l_string != NIL ) {
            l_temp = l_string ;
            /* initialize: null string */
            for(l_i=0 ; l_i < p_size ; l_i++, l_temp++)
                *l_temp = 0 ;
// FDB - changed *l_temp = NULL as NULL must be a pointer for MIPS build
        } else
            return(FALSE) ;
    } else
        l_string = NULL_OBJ ;

    /*
    **  call by op_array
    */
    TYPE_SET(p_obj, STRINGTYPE) ;
    ACCESS_SET(p_obj, UNLIMITED) ;
    ATTRIBUTE_SET(p_obj, LITERAL) ;
    ROM_RAM_SET(p_obj, RAM) ;
    LEVEL_SET(p_obj, current_save_level) ;
    LENGTH(p_obj) = p_size ;
    VALUE(p_obj) = (ULONG_PTR)l_string ;

    return(TRUE) ;
}   /* create_string */

/*
 * ******************************************************************
 * TITLE:       get_string                  Date:   08/01/87
 * CALL:        get_string()                UpDate: Jul/12/88
 * INTERFACE:   op_get:
 * Fix-Bug: 8-22-1988, by J. Lin, mask l_string value by 0x000000FF
 * *******************************************************************
 */
bool
get_string(p_strobj, p_index, p_intobj)
struct  object_def  FAR *p_strobj, FAR *p_intobj ;
ufix16  p_index ;
{
    byte    huge *l_string ;

    if( ACCESS(p_strobj) >= EXECUTEONLY ) {
        ERROR(INVALIDACCESS) ;
        return(FALSE) ;
    }

    /*  the index is greater than the length of array or string*/
    if (p_index >= LENGTH(p_strobj)) {
       ERROR(RANGECHECK) ;
       return(FALSE) ;
    }

    l_string = (byte huge *)VALUE(p_strobj) ;

    LEVEL_SET(p_intobj, current_save_level) ;
    TYPE_SET(p_intobj, INTEGERTYPE) ;
    ATTRIBUTE_SET(p_intobj, LITERAL) ;
    VALUE(p_intobj) = ((ufix32)*(l_string + p_index) & 0x000000FF) ;

    return(TRUE) ;
}   /* get_string() */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\user.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              USER.C
 *      Author:                 Chia-Chi Teng
 *      Date:                   11/20/89
 *      Owner:                  Microsoft Co.
 *      Description: this file contains all the userdict operators.
 *
 * revision history:
 * 07-10-90 ; ccteng ; change startpage to a string in userdict
 * 7/23/90 ; ccteng ; 1)move StartPage initialization to init_release
 *                    in init1pp.c along with "startpage.h"
 * 7/25/90 ; ccteng ; 1)move dosysstart before dostartpage
 *                  2)rename se_execstdin to do_execjob
 *                  3)change us_start to be a null function
 *                  4)add a new function ic_startup from us_start
 *                  5)remove se_startjob call from ic_startup
 * 08-08-90 ; Jack Liaw ; update for grayscale
 * 8/30/90 ; ccteng ; change change_status() for messagedict
 * 8/31/90 ; ccteng ; 1)include file.h, stdio.h
 * 11/20/90 ; scchen ; pr_setuppage(): update for "note" page type
 * 11/30/90  PJ & Danny   Fix Bug to let idle fonts works(ref. IDL:)
 ************************************************************************
 */



// DJC added global include file
#include "psglobal.h"


#include        <stdio.h>
#include        <string.h>
#include        "global.ext"
#include        "geiio.h"
#include        "geiioctl.h"
#include        "geierr.h"
#include        "geipm.h"
#include        "language.h"
#include        "user.h"
#include        "release.h"
#include        "file.h"
#include        "geieng.h"
#include        "graphics.h"
extern struct gs_hdr far * near GSptr ;

/* @WIN; add prototype */
fix pr_setuppage(void);
fix se_interactive(void);
fix op_clearinterrupt(void);
fix op_disableinterrupt(void);

bool16  doquit_flag ;
bool16  startup_flag ;

/************************************
 *  DICT: userdict
 *  NAME: cleardictstack
 *  FUNCTION:
 ************************************/
fix
us_cleardictstack()
{
    ufix16 l_dictcount ;

#ifdef DBG_1pp
    printf("cleardictstack...\n") ;
#endif
    /*
     *  pop the all dictioanries except userdict and systemdict
     *  off the dictstack
     */
    if( dictstktop > 2 ) {
        /*
         *  change the confirm number to indicate some dictionaries
         *  in the dictionary stack have been changed
         */
        l_dictcount = dictstktop-2 ;
        POP_DICT(l_dictcount) ;
        change_dict_stack() ;
    }

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: letter
 *  FUNCTION:
 ************************************/
fix
us_letter()
{
#ifdef DBG_1pp
    printf("us_letter()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 0 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: lettersmall
 *  FUNCTION:
 ************************************/
fix
us_lettersmall()
{
#ifdef DBG_1pp
    printf("us_lettersmall()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 1 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 1) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: a4
 *  FUNCTION:
 ************************************/
fix
us_a4()
{
#ifdef DBG_1pp
    printf("us_a4()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 2 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 2) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: a4small
 *  FUNCTION:
 ************************************/
fix
us_a4small()
{
#ifdef DBG_1pp
    printf("us_a4small()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 3 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 3) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: b5
 *  FUNCTION:
 ************************************/
fix
us_b5()
{
#ifdef DBG_1pp
    printf("us_b5()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 4 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 4) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: note
 *  FUNCTION:
 ************************************/
fix
us_note()
{
#ifdef DBG_1pp
    printf("us_note()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push 5 and call setuppage() */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 5) ;
    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: legal
 *  FUNCTION:
 ************************************/
fix
us_legal()
{
#ifdef DBG_1pp
    printf("us_legal()...\n") ;
#endif
    if (FRCOUNT() < 1) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* check paper size */
    st_largelegal() ;
    if ( VALUE_OP(0) ) {
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 6) ;
    } else {
        POP(1) ;
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 7) ;
    } /* if-else */

    pr_setuppage() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: prompt
 *  FUNCTION:
 ************************************/
fix
us_prompt()
{
    struct  object_def  FAR *l_execdepth ;
    ufix16  l_i ;

    /* get execdepth in execdict */
    if ( !get_dict_value(USERDICT, "execdepth", &l_execdepth) ) {
        get_dict_value(EXECDICT, "execdepth", &l_execdepth) ;
    }
    l_i = (ufix16) VALUE(l_execdepth) ;
    GEIio_write(GEIio_stdout, "PS", 2) ;
    while ( l_i-- )
        GEIio_write(GEIio_stdout, ">", 1) ;

    op_flush() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: quit
 *  FUNCTION:
 ************************************/
fix
us_quit()
{
    struct  object_def  FAR *l_stopobj ;

#ifdef DBG_1pp
    printf("us_quit()...\n") ;
#endif

    doquit_flag = TRUE ;

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: readidlecachefont
 *  FUNCTION:
 ************************************/
fix
us_readidlecachefont()
{
    struct  object_def  FAR *l_caryidx, FAR *l_defarray, FAR *l_carray ;
    struct  object_def  FAR *l_cachestr, FAR *l_stdfont, FAR *l_citem ;
    ufix16  l_i, l_j ;

#ifdef DBG_1pp
    printf("us_readidlecachefont()...\n") ;
#endif

    /* initialize object pointers */
    get_dict_value(IDLETIMEDICT, "carrayindex", &l_caryidx) ;
    get_dict_value(IDLETIMEDICT, "defaultarray", &l_defarray) ;
    get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
    get_dict_value(IDLETIMEDICT, "cachestring", &l_cachestr) ;
    get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
    get_dict_value(IDLETIMEDICT, "citem", &l_citem) ;

    /* push idle fonts on the operand stack */
    /*
     * 12/15/89 ccteng modify FONT_OP4.C st_setidlefonts
     * to call this function
     * use the integers already on operand stack, no need for
     * calling st_idlefonts & op_counttomark
     */
    if ( VALUE_OP(0) < 5 ) {
        COPY_OBJ(l_defarray, l_carray) ;
    }
    else {
        VALUE(l_caryidx) = VALUE_OP(0) ;
        l_i = (ufix16) VALUE_OP(0) % 5 ;
        if ( l_i ) {
            VALUE(l_caryidx) -= l_i ;
            POP(l_i + 1) ;
        } else
            POP(1) ;
        /* create a new cache array for new idle font data */
        if ( !create_array(l_carray, (ufix16) VALUE(l_caryidx) ) ) {
            ERROR(VMERROR) ;
            return(0) ;
        }
        l_i = (ufix16) VALUE(l_caryidx) / 5 ;
        while ( l_i-- ) {
            /* put cache string */
            if ( VALUE_OP(0) > LENGTH(l_cachestr) )
                getinterval_string(l_cachestr, 0, 0, l_citem) ;
            else
                getinterval_string(l_cachestr, 0, (ufix16)VALUE_OP(0), l_citem) ;
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), l_citem) ;
            POP(1) ;
            /* put rotate */
            VALUE_OP(0) *= 5 ;
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
            POP(1) ;
            /* put scales */
            for ( l_j = 0 ; l_j < 2 ; l_j++ ) {
                PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 10) ;
                op_div() ;
                put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
                POP(1) ;
            }
            /* put font# */
            if ( VALUE_OP(0) >= LENGTH(l_stdfont) ) {
                POP(1) ;
                PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;
            }
            put_array(l_carray, (ufix16)(--VALUE(l_caryidx)), GET_OPERAND(0)) ;
            POP(1) ;
        } /* while */
    } /* if */
    op_cleartomark() ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: useidlecache
 *  FUNCTION:
 ************************************/
fix
us_useidlecache(p_flag)
fix     p_flag;
{
    static struct  object_def
            FAR *l_caryidx, FAR *l_cstridx, FAR *l_cstring, FAR *l_carray,
            FAR *l_citem, FAR *l_stdfont, FAR *l_fontdir, l_fontname;
    struct  object_def  l_char, FAR *l_fontdict;
    ufix16  l_i ;

#ifdef DBG_1pp
    printf("us_useidlecache()...\n") ;
#endif

    if (p_flag == 0) {
        /* initialize carrayindex, cstringindex, cstring */
        get_dict_value(IDLETIMEDICT, "carrayindex", &l_caryidx) ;
        VALUE(l_caryidx) = 0 ;
        get_dict_value(IDLETIMEDICT, "cstringindex", &l_cstridx) ;
        VALUE(l_cstridx) = 1 ;
        get_dict_value(IDLETIMEDICT, "cstring", &l_cstring) ;
        create_string(l_cstring, 0) ;

        /* initialize object pointers */
        get_dict_value(IDLETIMEDICT, "cachearray", &l_carray) ;
        get_dict_value(IDLETIMEDICT, "citem", &l_citem) ;
        get_dict_value(IDLETIMEDICT, "stdfontname", &l_stdfont) ;
        get_dict_value(SYSTEMDICT, FONTDIRECTORY, &l_fontdir) ;
#ifdef DBG_1pp
        printf("cachearray = \n") ;
        PUSH_OBJ(l_carray) ;
        two_equal() ;
#endif
        op_gsave();
        return(0);
    }

    /* if cstringindex >= LENGTH(cstring) */
    if ( VALUE(l_cstridx) >= LENGTH(l_cstring) ) {
        /* check carrayindex */
        if ( VALUE(l_caryidx) >= LENGTH(l_carray) )
            VALUE(l_caryidx) = 0 ;
        get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
        get_array(l_stdfont, (ufix16) VALUE(l_citem), &l_fontname) ;
#ifdef DBG_1pp
    printf("fontname = ") ;
    PUSH_OBJ(&l_fontname) ;
    two_equal() ;
#endif
        /* get font */
        if ( ( LENGTH(l_carray) != 0 ) &&
             ( get_dict(l_fontdir, &l_fontname, &l_fontdict) ) ) {
            /* font exist */
            op_grestore() ;
            op_gsave() ;
            /* set font */
            PUSH_ORIGLEVEL_OBJ(l_fontdict) ;
            op_setfont() ;
            /* set rotate and scales */
            for ( l_i = 0 ; l_i < 3 ; l_i++ ) {
                get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
                PUSH_ORIGLEVEL_OBJ(l_citem) ;
            }
#ifdef DBG_1pp
    printf("rotate, scale...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
            op_rotate(1) ;
            op_scale(2) ;
            /* set cache string */
            get_array(l_carray, (ufix16)(VALUE(l_caryidx)++), l_citem) ;
            COPY_OBJ(l_citem, l_cstring) ;
#ifdef DBG_1pp
    printf("cachestring = ") ;
    PUSH_OBJ(l_cstring) ;
    two_equal() ;
#endif
            VALUE(l_cstridx) = 0 ;
        } else
            /* font not exist */
            VALUE(l_caryidx) += 4 ;
    } else {
        /* build font cache */
        getinterval_string(l_cstring, (ufix16)(VALUE(l_cstridx)++), 1, &l_char) ;
        PUSH_ORIGLEVEL_OBJ(&l_char) ;
        op_stringwidth() ;
        POP(2) ;
    } /* if */

    if (p_flag == 2)
        op_grestore();

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: executive
 *  FUNCTION:
 ************************************/
fix
us_executive()
{
    struct  object_def  FAR *l_execdepth, FAR *l_runbatch, FAR *l_version ;
    struct  object_def  FAR *l_stopobj ;

#ifdef DBG_1pp
    printf("us_executive()...\n") ;
#endif
    /* initialize object pointers */
    get_dict_value(EXECDICT, "execdepth", &l_execdepth) ;
    get_dict_value(DERROR, "runbatch", &l_runbatch) ;
    get_dict_value(SYSTEMDICT, "version", &l_version) ;

    /* increase execdepth by 1 */
    op_clearinterrupt() ;
/*  op_disableinterrupt() ; */
    VALUE(l_execdepth) += 1 ;
    if (interpreter(l_version))
        printf("Error during version\n") ;
    get_dict_value(MESSAGEDICT, "banner", &l_version) ;
    if (interpreter(l_version))
        printf("Error during banner\n") ;
    get_dict_value(MESSAGEDICT, "copyrightnotice", &l_version) ;
    if (interpreter(l_version))
        printf("Error during copyrightnotice\n") ;

    /* call se_interactive */
    se_interactive() ;

    /* decrease execdepth by 1 */
    VALUE(l_execdepth) -= 1 ;
    doquit_flag = FALSE ;
    VALUE(l_runbatch) = FALSE ;

    /* execute stop */
    get_dict_value(SYSTEMDICT, "stop", &l_stopobj) ;
    PUSH_EXEC_OBJ(l_stopobj) ;

    return(0) ;
}

/************************************
 *  DICT: userdict
 *  NAME: start
 *  FUNCTION:
 ************************************/
fix
us_start()
{
    /*
     * always return invalidaccess error when user trying to use it
     * but still keep this object for compatibility reason
     */
    ERROR(INVALIDACCESS) ;
    return(0) ;
}

/*
 * new function for new job control scheme
 */
fix
ic_startup()
{
    extern  fix   near  resolution ;
    struct  object_def  l_tmpobj, FAR *l_paper ;
    fix l_dostart ;

#ifdef DBG_1pp1
    printf("start()...\n") ;
#endif

    startup_flag = FALSE;

    /* check start_flag */
    if ( !start_flag ) {
        op_disableinterrupt() ;
        PUSH_VALUE(BOOLEANTYPE,UNLIMITED,LITERAL,0, FALSE) ;
        op_daytime() ;

        /* set resolution */
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, resolution) ;
        st_setresolution() ;
        op_clear() ;

        /* print start message to system stderr */
        PUSH_VALUE(STRINGTYPE,0,EXECUTABLE,lstrlen(StartMsg),
             StartMsg) ;        /* @WIN */
        COPY_OBJ(GET_OPERAND(0), &l_tmpobj) ;
        POP(1) ;
        if (interpreter(&l_tmpobj))
            printf("Error during start message\n") ;
        op_flush() ;

#ifdef SCSI /* ??? should this go before startpage ??? */
        /* open system area */
        PUSH_VALUE(BOOLEANTYPE, UNLIMITED, LITERAL, 0, TRUE) ;
        op_setsysmode() ;

        /* run (Sys/Start) file if flag is set */
        st_dosysstart() ;
        l_dostart = VALUE_OP(0) ;
        POP(1) ;
        if ( l_dostart ) {
            /* check status of file (Sys/Start) */
            create_string(&l_tmpobj, 9) ;
            lstrcpy( VALUE(&l_tmpobj), (char FAR *)"Sys/Start") ; /* @WIN */
            PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
            op_status() ;
            if ( VALUE_OP(0) ) {
                /* run (Sys/Start) */
                POP(4) ;
                PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
                op_run() ;
            } /* if */
            POP(1) ;
        } /* if */
#endif
        /*
         * run startpage string in savelevel 1 without errorhandling
         */
        st_dostartpage() ;
        l_dostart = (fix)VALUE_OP(0) ;          //@WIN
        POP(1) ;
        start_flag = TRUE ;
        if (l_dostart) {
            lstrncpy(job_state, "start page\0", 12);    /*@WIN*/
            job_source[0] = '\0' ;
            TI_state_flag = 0;
            change_status();
            op_disableinterrupt() ;

            /* print start page */
            get_dict_value(SERVERDICT, "startpage", &l_paper) ;
            do_execjob(*l_paper, 1, FALSE) ;
        }
    } /* if */

    startup_flag = TRUE ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: defaultscrn
 *  FUNCTION:
 ************************************/
fix
pr_defaultscrn()
{
    struct  object_def  FAR *l_defspotfunc;
    union   four_byte   tmp;            /* @WIN */

#ifdef DBG_1pp
    printf("defaultscrn()...\n") ;
#endif
    if(FRCOUNT() < 12) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* push frequency, angle, proc and call op_setscreen, 8-8-90, Jack Liaw */
/*  PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, GSptr->halftone_screen.freq) ;
 *  PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, GSptr->halftone_screen.angle) ;
 *                                              @WIN; 1/22/92; scchen
 */
    tmp.ff = GSptr->halftone_screen.freq;
    PUSH_VALUE(REALTYPE,UNLIMITED,LITERAL,0, tmp.ll);
    tmp.ff = GSptr->halftone_screen.angle;
    PUSH_VALUE(REALTYPE,UNLIMITED,LITERAL,0, tmp.ll);

    get_dict_value(PRINTERDICT, "defspotfunc", &l_defspotfunc) ;
    PUSH_ORIGLEVEL_OBJ(l_defspotfunc) ;

    /* 60 45 {...} setscreen */
    op_setscreen() ;

    /* {} settransfer */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0, 0) ;

    /* BEGIN 03/20/90 D.S. Tseng */
    /* Replace this statement for 68000
     * op_packedarray() ;
     */
    op_array() ;
    op_astore() ;

    op_cvx() ;
    /* call settransfer */
    op_settransfer() ;

    /* initgraphics & erasepage */
    op_initgraphics() ;
    op_erasepage() ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: getframeargs
 *  FUNCTION:
 ************************************/
fix
pr_getframeargs()
{
    struct  object_def  l_tmpobj ;
    struct  object_def  FAR *l_prarray, FAR *l_matrix, FAR *l_height, FAR *l_width ;
    extern  fix   near  resolution ;

#ifdef DBG_1pp
    printf("getframeargs()...\n") ;
#endif
    if (FRCOUNT() < 2) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if ((TYPE(GET_OPERAND(0)) != PACKEDARRAYTYPE)
        && (TYPE(GET_OPERAND(0)) != ARRAYTYPE)) {
        ERROR(TYPECHECK) ;
        return(0) ;
    }

    l_prarray = GET_OPERAND(0) ;
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;

    /* set width */
    get_dict_value(PRINTERDICT, "width", &l_width) ;
    get_array(l_prarray, 2, l_width) ;

    /* set height */
    get_dict_value(PRINTERDICT, "height", &l_height) ;
    get_array(l_prarray, 3, l_height) ;

    /* set xoffset */
    get_array(l_prarray, 4, &l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
    op_neg() ;
    put_array(l_matrix, 4, GET_OPERAND(0)) ;
    POP(1) ;

    /* set yoffset */
    get_array(l_prarray, 5, &l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(&l_tmpobj) ;
    PUSH_ORIGLEVEL_OBJ(l_height) ;
#ifdef DBG_1pp1
    printf("yoffset, height...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    op_add() ;
    put_array(l_matrix, 5, GET_OPERAND(0)) ;
    POP(1) ;

    /* set dpi/72 */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,72) ;
    op_div() ;
    put_array(l_matrix, 0, GET_OPERAND(0)) ;
    POP(1) ;

    /* set -dpi/72 */
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,resolution) ;
    PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,(ufix32) -72) ;
    op_div() ;
    put_array(l_matrix, 3, GET_OPERAND(0)) ;
    POP(1) ;

    /* pop printer parameter array */
    POP(1) ;
    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: proc
 *  FUNCTION:
 ************************************/
fix
pr_proc()
{
    struct  object_def  l_topm, l_leftm ;
    struct  object_def  FAR *l_prarray, FAR *l_page ;
    struct  object_def  FAR *l_mfeed, FAR *l_prdict, FAR *l_copies ;

#ifdef DBG_1pp
    printf("pr_proc()...\n") ;
#endif
    if (FRCOUNT() < 4) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }

    /* set jobstate to "printing" */
    lstrncpy(job_state, "printing; \0", 12);    /*@WIN*/
    TI_state_flag = 0;
    change_status();

    /* get printing parameter array */
    get_dict_value(USERDICT, PRINTERDICT, &l_prdict) ;
    get_dict_value(PRINTERDICT, "currentpagetype", &l_page) ;
    get_dict(l_prdict, l_page, &l_prarray) ;

    /* set top margin = topmargin + prarray[0] */
    st_margins() ;
    op_exch() ;
    get_array(l_prarray, 0, &l_topm) ;
    PUSH_ORIGLEVEL_OBJ(&l_topm) ;
    op_add() ;
#ifdef DBG_1pp
    printf("top margin = ") ;
    op_dup() ;
    one_equal() ;
#endif
    op_exch() ;

    /* set left margin = round( (leftmargin + prarray[1]) / 16 ) * 2 */
    get_array(l_prarray, 1, &l_leftm) ;
    PUSH_ORIGLEVEL_OBJ(&l_leftm) ;
    op_add() ;

 /* 2/5/90 ccteng, for LW38.0 compatible only, not needed for LW47.0
  *
  * PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,16) ;
  * op_div() ;
  * op_round() ;
  * PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,2) ;
  * op_mul() ;
  * op_cvi() ;
  */

#ifdef DBG_1pp
    printf("left margin = ") ;
    op_dup() ;
    one_equal() ;
#endif

    /* get manualfeedtimout */
    get_dict_value(STATUSDICT, "manualfeed", &l_mfeed) ;
    if (VALUE(l_mfeed)) {
        struct  object_def  FAR *l_mfeedtimeout ;
        get_dict_value(STATUSDICT, "manualfeedtimeout", &l_mfeedtimeout) ;
        PUSH_ORIGLEVEL_OBJ(l_mfeedtimeout) ;
    } else
        PUSH_VALUE(INTEGERTYPE,UNLIMITED,LITERAL,0,0) ;

    /* #copies */
/*  get_dict_value(USERDICT, "#copies", &l_copies) ; erik chen 4-16-1991 */
    ATTRIBUTE_SET(&l_topm, LITERAL) ;
    LEVEL_SET(&l_topm, current_save_level) ;
    get_name(&l_topm, "#copies", lstrlen("#copies"), FALSE) ;  /* @WIN */
    load_dict(&l_topm, &l_copies) ;
    PUSH_ORIGLEVEL_OBJ(l_copies) ;

#ifdef DBG_1pp
    printf("frametoprinter...\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    /* top left manualfeedtimeout copies frametoprinter */
    st_frametoprinter() ;

    return(0) ;
}

/************************************
 *  DICT: $printerdict
 *  NAME: setuppage
 *  FUNCTION:
 ************************************/
fix
pr_setuppage()
{
    struct  object_def  FAR *l_prarray, FAR *l_matrix, FAR *l_height, FAR *l_width ;

    struct  object_def  FAR *l_pspagetype;  //DJC new
    struct  object_def  l_newpagetype;      //DJC new

    struct  object_def  l_page, FAR *l_array, FAR *l_proc, FAR *l_prdict ;
    ufix tray ;
//  byte default_page ;         @WIN
    ufix page_type = 0 ;

#ifdef DBG_1pp
    printf("setuppage()...\n") ;
#endif
    if (FRCOUNT() < 4) {
        ERROR(STACKOVERFLOW) ;
        return(0) ;
    }
    if (COUNT() < 1) {
        ERROR(STACKUNDERFLOW) ;
        return(0) ;
    }
    if (TYPE(GET_OPERAND(0)) != INTEGERTYPE) {
        ERROR(TYPECHECK) ;
        return(0) ;
    }

    /* for "note", to get paper tray and according to default page type
     * to dicide the real page type ; scchen 11/20/90
     */
    if (VALUE_OP(0) == 5) {         /* if paper_size is "note" */
#ifdef  _AM29K
        tray = GEIeng_paper() ;     /* get current tray */
#else
        tray = PaperTray_LETTER ;   /* get current tray */
#endif
/* 3/19/91, JS
        default_page = FALSE ;
        default_page = default_page & 0x07F ;         |* clear 1 bit *|
 */
        POP(1) ;

        switch (tray) {
          case PaperTray_LETTER:
            page_type = 1 ;          /* lettersmall */
            break ;
          case PaperTray_LEGAL:
            page_type = 6 ;          /* legal */
            break ;
          case PaperTray_A4:
            page_type = 3 ;          /* a4small */
            break ;
          case PaperTray_B5:
            page_type = 4 ;          /* b5 */
            break ;
        }
        PUSH_VALUE(INTEGERTYPE, UNLIMITED, LITERAL, 0, page_type) ;
    }


    //DJC begin save page type in psprivatedict
    //
    get_dict_value(PSPRIVATEDICT,"psprivatepagetype", &l_pspagetype);
    COPY_OBJ( l_pspagetype, &l_newpagetype);

    VALUE(&l_newpagetype) = (ufix32) VALUE_OP(0);

    put_dict_value1(PSPRIVATEDICT,"psprivatepagetype", &l_newpagetype);

    //DJC end




    /* get & define pagetype */
    get_dict_value(PRINTERDICT, "printerarray", &l_prarray) ;
    get_array(l_prarray, (ufix16) VALUE_OP(0), &l_page) ;
    put_dict_value1(PRINTERDICT, "currentpagetype", &l_page) ;
    POP(1) ;

    /* get printing parameter array */
    get_dict_value(USERDICT, PRINTERDICT, &l_prdict) ;
    get_dict(l_prdict, &l_page, &l_array) ;
    PUSH_ORIGLEVEL_OBJ(l_array) ;

    /* call getframeargs */
    pr_getframeargs() ;
#ifdef DBG_1pp
    printf("pr_getframeargs()...\n") ;
    op_pstack() ;
#endif

    /* matrix width height {proc} framedevice */
    get_dict_value(PRINTERDICT, "mtx", &l_matrix) ;
    PUSH_ORIGLEVEL_OBJ(l_matrix) ;
    get_dict_value(PRINTERDICT, "width", &l_width) ;


    PUSH_ORIGLEVEL_OBJ(l_width) ;



    get_dict_value(PRINTERDICT, "height", &l_height) ;



    PUSH_ORIGLEVEL_OBJ(l_height) ;
    get_dict_value(PRINTERDICT, "proc", &l_proc) ;
    PUSH_ORIGLEVEL_OBJ(l_proc) ;
#ifdef DBG_1pp
    printf("framedevice....\n") ;
    op_pstack() ;
    printf("end pstack...\n") ;
#endif
    op_framedevice() ;

    /* call defaultscrn */
    pr_defaultscrn() ;

    return(0) ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\typeconv.c ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 * revision history:
 *      7/25/90 ; ccteng ; change op_noaccess and op_readonly to save
 *                       dictionary's access
 */


// DJC added global include file
#include "psglobal.h"


#include        <math.h>
#include        <string.h>
#include        "global.ext"
#include        <stdio.h>

#define         STRMAXLEN       33
#define         DEFAULTRADIX    10
#define         SIGNIFIC_DIGIT   6

#define         MAX31PATTERN    0x4F000000
#define         SIGNPATTERN     0x80000000
#define         VALUEPATTERN    0x7FFFFFFF

static byte far * far type_ary[] = {
                  "eoftype",
                  "arraytype",
                  "booleantype",
                  "dicttype",
                  "filetype",
                  "fonttype",
                  "integertype",
                  "marktype",
                  "nametype",
                  "nulltype",
                  "operatortype",
                  "realtype",
                  "savetype",
                  "stringtype",
                  "packedarraytype"
} ;

/* @WIN; add prototype */
bool save_obj(struct  object_def  FAR *);



/*
 * *******************************************************************
 * This operator is used to return a name object that identifies the
 * type of the object 'any'. The result is one of the following names:
 *
 *      arraytype       nametype
 *      booleantype     nulltype
 *      dicttype        operatortype
 *      filetype        realtype
 *      fonttype        savetype
 *      integertype     stringtype
 *      marktype        packedarraytype
 *
 *
 * TITLE:       op_type            Date:   00/00/87
 * CALL:        op_type()          UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      type name  ; pointer to any type object (4-byte)
 * ******************************************************************
 */
fix
op_type()
{
    struct  object_def  FAR *any, name_obj = {0, 0, 0};
    ufix                l_type ;
    byte                FAR *str ;

/*
 *   get operand's type and convert this string to an hash code
 *   in order to find it's id
 */
    any = GET_OPERAND(0) ;
    l_type = TYPE(any) ;
    str = type_ary[l_type] ;
    ATTRIBUTE_SET(&name_obj, EXECUTABLE) ;
    LEVEL_SET(&name_obj, current_save_level) ;
    get_name(&name_obj, str, lstrlen(str), TRUE ) ;     /* @WIN */

    POP(1) ;
/*
 *   Create a NAMETYPE object on top of operand stack
 *   to indicate the input object's type
 */
     ATTRIBUTE_SET(&name_obj, EXECUTABLE) ;
     PUSH_OBJ(&name_obj) ;

    return(0) ;
}   /* end op_type */

/*
 * *******************************************************************
 * This operator is used to make the object on the top of the operand
 * stack have the literal attribute.
 *
 * TITLE:       op_cvlit           Date:   00/00/87
 * CALL:        op_cvlit()         UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      any object with attribute changed to "LITERAL"
 *              ; pointer to any type object (4-byte)
 * *******************************************************************
 */
fix
op_cvlit()
{
    struct  object_def  FAR *any ;

/*
 *   set attribute to  LITERAL
 */
    any = GET_OPERAND(0) ;
    ATTRIBUTE_SET(any, LITERAL) ;

    return(0) ;
}   /* end op_cvlit */

/*
 * *******************************************************************
 * This operator is used to make the object on the top of the operand
 * stack have the executable attribute.
 *
 * TITLE:       op_cvx             Date:   00/00/87
 * CALL:        op_cvx()           UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      any object with attribute changed to "EXECUTABLE"
 *              ; pointer to any type object (4-byte)
 * *******************************************************************
 */
fix
op_cvx()
{
    struct  object_def  FAR *any ;

/*
 *   set attribute to EXECUTABLE
 */
    any = GET_OPERAND(0) ;
    ATTRIBUTE_SET(any, EXECUTABLE) ;

    return(0) ;
}   /* end op_cvx */

/*
 * *******************************************************************
 * This operator is used to test whether the operand has the
 * executable or literal attribute, returning true if it is executable
 * or false if it is literal
 *
 * TITLE:       op_xcheck          Date:   00/00/87
 * CALL:        op_xcheck()        UpDate: 08/06/87
 * PARAMETERS:  any        ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object .
 * *******************************************************************
 */
fix
op_xcheck()
{
    struct  object_def  FAR *any ;
    ufix32  l_bool ;

    any = GET_OPERAND(0) ;
/*
 *   check attribute, not including DICT object, follows LW V.38
 */
    l_bool = FALSE ;
    if (ATTRIBUTE(any) == EXECUTABLE)
        l_bool = TRUE ;
    else
        l_bool = FALSE ;

    POP(1) ;

/*
 *   Create a BOOLEANTYPE object on operand stack to indicate
 *   whether the input operand has the executable attribute
 */
    PUSH_VALUE(BOOLEANTYPE, 0, LITERAL, 0, l_bool) ;

    return(0) ;
}   /* end op_xcheck */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file or string object to executeonly. Access can only be reduced
 * by this means, never increased. When an object is executeonly, its
 * value cannot be read or modified explicitly by other operators.
 * but it can still be executed by the interpreter.
 *
 * Executeonly_op affects the access attribute only of the object that
 * it returns ; if there exist other objects that share the same value,
 * their access attribute are unaffected.
 *
 * TITLE:       op_executeonly     Date:   00/00/87
 * CALL:        op_executeonly()   UpDate: 08/06/87
 * PARAMETERS:  a_f_s      ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_f_s object with access changed to EXECUTEONLY
 * *******************************************************************
 */
fix
op_executeonly()
{
    struct  object_def  FAR *a_f_s ;

    a_f_s = GET_OPERAND(0) ;

/*
 *  Set access to EXECUTEONLY for ARRAYTYPE, FILETYPE, STRINGTYPE object.
 */
    switch( TYPE(a_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_f_s) == UNLIMITED ) {
            ERROR(INVALIDACCESS) ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_f_s) == NOACCESS )
            ERROR( INVALIDACCESS ) ;
        else
            ACCESS_SET(a_f_s, EXECUTEONLY) ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_executeonly */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file, dictionary or string object to none. The value of noaccess
 * object cannot be executed or accessed directly by other operators.
 *
 * For an array, file or string, Noaccess_op affects the access
 * attribute only of the object that it returns ; if there exist other
 * objects that share the same value, their access attributes are
 * unaffected. However, in the case of a dictionary, Noaccess_op affects
 * the value of the object, so all dictionary object shareing the same
 * dictionary are affected.
 *
 * TITLE:       op_noaccess        Date:   00/00/87
 * CALL:        op_noccess()       UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_d_f_s object with access changed to NOACCESS
 * *******************************************************************
 */
fix
op_noaccess()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Set access to NOACCESS for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE object
 */
    switch( TYPE(a_d_f_s) )  {
    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case FILETYPE :
    case STRINGTYPE :
        ACCESS_SET(a_d_f_s, NOACCESS) ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        /* 7/25/90 ccteng, change from PJ */
        if (l_dict->level != current_save_level)
            if (save_obj((struct object_def FAR *)l_dict)) {
                DACCESS_SET(l_dict, NOACCESS) ;
                l_dict->level = current_save_level ;
            }
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_noaccess */

/*
 * *******************************************************************
 * This operator is used to reduce the access attribute of an array,
 * file, dictionary or string object to read-only. Access can only
 * be reduced by this means, never increased. When an object is
 * read-only, its value cannot be modified by other operators, but it
 * can still be read by operators or executed by the interprepter.
 *
 * For an array, file or string, Readonly_op affects the access
 * attribute only of the object that it returns ; if there exist other
 * objects that share the same value, their access attributes are
 * unaffected. However, in the case of a dictionary, Readonly_op affects
 * the value of the object, so all dictionary object shareing the same
 * dictionary are affected.
 *
 * TITLE:       op_readonly        Date:   00/00/87
 * CALL:        op_readonly()      UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      a_d_f_s    ; POINTER TO object with access changed
 *                         ; to READONLY .
 * *******************************************************************
 */
fix
op_readonly()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Set access to READONLY for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE object
 */
    switch( TYPE(a_d_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_d_f_s) == UNLIMITED ) {
            ERROR(INVALIDACCESS) ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == EXECUTEONLY || ACCESS(a_d_f_s) == NOACCESS ) {
            ERROR( INVALIDACCESS ) ;
            return(0) ;
        }
        else
            ACCESS_SET(a_d_f_s, READONLY) ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == EXECUTEONLY || DACCESS(l_dict) == NOACCESS )
            ERROR(INVALIDACCESS) ;
        else
            /* 7/25/90 ccteng, change from PJ */
            if (l_dict->level != current_save_level)
                if (save_obj((struct object_def FAR *)l_dict)) {
                    DACCESS_SET(l_dict, READONLY) ;
                    l_dict->level = current_save_level ;
                }
        break ;

    default :
        ERROR( TYPECHECK ) ;
        break ;
    } /* switch */

    return(0) ;
}   /* end op_readonly */

/*
 * *******************************************************************
 * This operator is used to test whether the operand's access permits
 * its value to be read explicitly by other operators. Rcheck_op returns
 * true if the operand's access is unlimited or read-only, false otherwise.
 *
 * TITLE:       op_rcheck          Date:   00/00/87
 * CALL:        op_rcheck()        UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object to indicate whether the a_d_f_s object's
 *              access permits its value to be read explicitly by other
 *              operators.
 * *******************************************************************
 */
fix
op_rcheck()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;
    ufix32              l_bool ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Check the access right for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE oject
 */
    switch( TYPE(a_d_f_s) ) {
    case FILETYPE :             /* ?? RW */
        if( ACCESS(a_d_f_s) == UNLIMITED ) {
            l_bool = FALSE ;
            break ;
        }

    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == UNLIMITED || ACCESS(a_d_f_s) == READONLY )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == UNLIMITED || DACCESS(l_dict) == READONLY )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        return(0) ;
    } /* switch */

    POP(1) ;

/*
 *  Create a BOOLEANTYPE object to indicate whether the operand's access
 *  permits its value to be read explicitly by other operators.
 */
    PUSH_VALUE( BOOLEANTYPE, 0, LITERAL, 0, l_bool ) ;

    return(0) ;
}   /* end op_rcheck() */

/*
 * ******************************************************************
 * This operator is used to test whether the operand's access permits
 * its value to be written explicitly by other operators. Wcheck_op returns
 * true if the operand's access is unlimited, false otherwise.
 *
 * TITLE:       op_wcheck          Date:   00/00/87
 * CALL:        op_wcheck()        UpDate: 08/06/87
 * PARAMETERS:  a_d_f_s    ; pointer to any type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      BOOLEAN object to indicate whether the a_d_f_s object's
 *              access permits its value to be read explicitly by other
 *              operators.
 * *******************************************************************
 */
fix
op_wcheck()
{
    struct  object_def  FAR *a_d_f_s ;
    struct  dict_head_def   FAR *l_dict ;
    ufix32              l_bool ;

    a_d_f_s = GET_OPERAND(0) ;
/*
 *  Check the access right for ARRAYTYPE, FILETYPE, STRINGTYPE,
 *  DICTIONARYTYPE oject
 */
    switch( TYPE(a_d_f_s) ) {
    case PACKEDARRAYTYPE :
    case ARRAYTYPE :
    case FILETYPE :
    case STRINGTYPE :
        if( ACCESS(a_d_f_s) == UNLIMITED )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    case DICTIONARYTYPE :
        l_dict = (struct dict_head_def FAR *)(VALUE(a_d_f_s)) ;
        if( DACCESS(l_dict) == UNLIMITED )
            l_bool = TRUE ;
        else
            l_bool = FALSE ;
        break ;

    default :
        ERROR( TYPECHECK ) ;
        return(0) ;
    } /* switch */
    POP(1) ;

/*
 *  Create a BOOLEANTYPE object to indicate whether the operand's access
 *  permits its value to be written explicitly by other operators.
 */
    PUSH_VALUE( BOOLEANTYPE, 0, LITERAL, 0, l_bool ) ;

    return(0) ;
}   /* end op_wcheck() */

/*
 * *******************************************************************
 * This operator is used to take an integer, real, or string object
 * from the stack an produces an integer result. If the operand is
 * an integer, Cvi_op simply returns it. If the operand is a real, it
 * truncates any fraction part and converts it to an integer. If the
 * operand is string, it interprets the characters of the string as
 * a number according to the PostScript syntax rule ; if that number
 * is a real, Cvi_op converts it to an integer.
 *
 * Cvi_op executes a RangeCheck error if a real is too large to convert
 * to an integer.
 *
 * TITLE:       op_cvi             Date:   08/06/87
 * CALL:        op_cvi()           UpDate: 06/29/88
 * PARAMETERS:  num_str    ; pointer to number/sting type object (4-byte)
 * INTERFACE:
 * CALL:
 *
 * RETURN:      integer type object on operand stack if no error.
 * *******************************************************************
 */
bool    minus_sign(real_string_obj)
 struct  object_def  FAR *real_string_obj ;
{
    ubyte     FAR *ch ;

    ch = (ubyte FAR *)VALUE(real_string_obj) ;
    while(*ch == ' ')
       ch++ ;
    if(*ch == '-')
       return(TRUE) ;
    else
       return(FALSE) ;
}   /* minus_sign */

fix
op_cvi()
{
    struct  object_def  FAR *num_str, l_token, l_save ;
    union   four_byte   lf_num ;
    ULONG_PTR  li_int ;
    ufix32  lt_num ;

    num_str = GET_OPERAND(0) ;
    if (TYPE(num_str) == STRINGTYPE) {
       /*
        *  Process string type object
        */
       if (ACCESS(num_str) != UNLIMITED && ACCESS(num_str) != READONLY) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }

       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       if (!get_token(&l_token, &l_save))
          return(0) ;
       else {
          switch (TYPE(&l_token)) {
          case INTEGERTYPE:
               li_int = VALUE(&l_token) ;
               break ;

          case REALTYPE:
               lf_num.ll = (fix32)(VALUE(&l_token)) ;
               if (lf_num.ll == INFINITY){
                    ERROR(RANGECHECK) ;
                    return(0) ;
               } else {
                  lt_num = lf_num.ll & VALUEPATTERN ;
                  if (lf_num.ll & SIGNPATTERN) { /* < 0 */
                     if (lt_num > MAX31PATTERN) {
                        ERROR(RANGECHECK) ;
                        return(0) ;
                     } else
                        li_int = (ULONG_PTR)lf_num.ff ;
                  } else {      /* >= 0 */
                     if (lt_num >= MAX31PATTERN) {
                        ERROR(RANGECHECK) ;
                        return(0) ;
                     } else
                        li_int = (ULONG_PTR)lf_num.ff ;
                  }
               }
               break ;

    default :
        ERROR( TYPECHECK ) ;
               return(0) ;
         } /* switch */
       }
    } else if (TYPE(num_str) == REALTYPE) {
       /*
        *  Process real object
        */
       lf_num.ll = (fix32)VALUE(num_str) ;
       lt_num = lf_num.ll & VALUEPATTERN ;
       if (lt_num >= MAX31PATTERN) {
          ERROR(RANGECHECK) ;
          return(0) ;
       } else {
          if (lf_num.ll & SIGNPATTERN)   /* < 0 */
             li_int = (ULONG_PTR)lf_num.ff ;
          else          /* >= 0 */
             li_int = (ULONG_PTR)lf_num.ff ;
       }
    } else      /* Integer type operand */
       li_int = VALUE(num_str) ;

    POP(1) ;
    PUSH_VALUE(INTEGERTYPE, 0, LITERAL, 0, li_int) ;

    return(0) ;
}   /* op_cvi() */

/*
 * *******************************************************************
 * This operator is used to convert the string operand to a name
 * object that is lexically the same string. The name object is
 * executable if the string was.
 *
 * TITLE:       op_cvn             Date:   00/00/87
 * CALL:        op_cvn()           UpDate: 08/06/87
 * PARAMETERS:  string    ; pointer to string type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      name type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvn()
{
    struct  object_def  FAR *string, l_name ;

    string = GET_OPERAND(0) ;
/*
 *  Access right check
 */
    if (ACCESS(string) != UNLIMITED && ACCESS(string) != READONLY) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    if( LENGTH(string) >= MAXNAMESZ ) {
        ERROR(RANGECHECK) ;
        return(0) ;
    }

/*
 *  String to name object convert, designed by SPJ.
 */
    if (sobj_to_nobj(string, &l_name)) {
       POP(1) ;
       PUSH_OBJ(&l_name) ;
    }

    return(0) ;
}   /* end op_cvn() */

/*
 * *******************************************************************
 * This operator is used to take an integer, real, or string object
 * from the stack an produces a real result. If the operand is
 * a real, Cvr_op simply returns it. If the operand is an integer, it
 * Cvr_op converts it to a real. If the operand is string, it interprets
 * the characters of the string as a number according to the PostScript
 * syntax rule ; if that number is an integer, Cvr_op converts it to an
 * real.
 *
 * TITLE:       op_cvr             Date:   08/06/87
 * CALL:        op_cvr()           UpDate: 06/29/88
 * PARAMETERS:  num_str   ; pointer to string type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      real type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvr()
{
    struct  object_def  FAR *num_str, l_token, l_save ;
    union   four_byte   lf_real ;

    num_str = GET_OPERAND(0) ;
    if (TYPE(num_str) == STRINGTYPE) {
    /*
     *  Process string type object
     */
       if (ACCESS(num_str) != UNLIMITED && ACCESS(num_str) != READONLY) {
          ERROR(INVALIDACCESS) ;
          return(0) ;
       }
       COPY_OBJ(GET_OPERAND(0), &l_save) ;
       if (!get_token(&l_token, &l_save))
          return(0) ;
       else {
          switch (TYPE(&l_token)) {
          case INTEGERTYPE:
               lf_real.ff = (real32)((fix32)VALUE(&l_token)) ;
               break ;

          case REALTYPE:
               lf_real.ll = (fix32)VALUE(&l_token) ;
               break ;

    default :
        ERROR( TYPECHECK ) ;
               return(0) ;
          } /* switch */
       }
    }
    else if (TYPE(num_str) == INTEGERTYPE)
       lf_real.ff = (real32)((fix32)VALUE(num_str)) ;
    else
       lf_real.ll = (fix32)VALUE(num_str) ;       /* real type */

    POP(1) ;
    PUSH_VALUE(REALTYPE, 0 , LITERAL, 0, lf_real.ll) ;

    return(0) ;
}   /* op_cvr() */

/*
 * *******************************************************************
 * This operator is used to produces a text representation of the
 * number num in the specified radix, stores the text into the supplied
 * string, and returns a string object designating the substring
 * actually used. If the string is too small to hold the result of the
 * conversion, Cvrs_op executes the error RangeCheck.
 *
 * If num is a real, Cvrs_op first converts it to an integer. radix
 * is expected to be a positive decimal integer in the range 2 to 36.
 * Digits greater than 9 in the resulting string are represented by
 * the letters 'A' through 'Z'.
 *
 * TITLE:       op_cvrs             Date:   08/06/87
 * CALL:        op_cvrs()           UpDate: 06/29/88
 * PARAMETERS:  num_str   ; pointer to string type object (4-byte)
 *
 *
 * INTERFACE:
 * CALL:
 * RETURN:      string type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvrs()
{
    struct  object_def  FAR *num, FAR *string ;
    union   four_byte   lf_num ;
    byte    l_strhold[STRMAXLEN] ;
    fix32   li_int ;
    ufix16  length, radix, l_idx ;
    ufix32  lt_num ;

    num = GET_OPERAND(2) ;
    radix = (ufix16)VALUE(GET_OPERAND(1)) ;
    string = GET_OPERAND(0) ;

    if (ACCESS(string) != UNLIMITED) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    if (radix < 2 || radix > 36) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }

    /*
     *  Process real object
     */
    if (TYPE(num) == REALTYPE) {
       lf_num.ll = (fix32)VALUE(num) ;

       if (radix == 10) {
          if (lf_num.ll == INFINITY)
             lstrcpy(l_strhold, (char FAR *)"Infinity.0") ;     /* @WIN */
          else
             gcvt(lf_num.ff, SIGNIFIC_DIGIT, (byte FAR *)l_strhold) ;
          length = (ufix16)lstrlen(l_strhold) ;         /* @WIN */
          goto  cvrs_exit ;

       } else { /* radix != 10 */
          if (lf_num.ll == INFINITY)
             li_int = MAX31 ;
          else {
             lt_num = lf_num.ll & VALUEPATTERN ;
             if (lf_num.ll & SIGNPATTERN) {      /* < 0 */
                if (lt_num > MAX31PATTERN)
                   li_int = MIN31 ;
                else
                   li_int = (fix32)lf_num.ff ;
             } else {
                if (lt_num >= MAX31PATTERN)
                   li_int = MAX31 ;
                else
                   li_int = (fix32)lf_num.ff ;
             }
          }
       }
    } else      /* integer object */
       li_int = (fix32)VALUE(num) ;

    /*
     *  Convert long integer to string with radix
     */
    ltoa(li_int, (char FAR *)l_strhold, radix) ;        /*@WIN*/
    length = (ufix16)lstrlen(l_strhold) ;               /* @WIN */
    /* convert to capital letter */
    for (l_idx = 0 ; l_idx < length ; l_idx++)
        if (l_strhold[l_idx] >= 97)  /* a - z */
           l_strhold[l_idx] -= 32 ;   /* A - Z */

 cvrs_exit:

    if (length > LENGTH(string)) {
       ERROR(RANGECHECK) ;
       return(0) ;
    }
    lstrncpy((char FAR *)(VALUE(string)), l_strhold, length) ;  /*@WIN*/

    POP(3) ;
    PUSH_VALUE(STRINGTYPE, UNLIMITED, LITERAL, length, VALUE(string)) ;
    LEVEL_SET(GET_OPERAND(0), LEVEL(string)) ;

    return(0) ;
}   /* op_cvrs() */

/*
 * *******************************************************************
 * This operator is used to produces a text representation of an arbitrary
 * object any, stores the text into the supplied string, and returns a
 * string object designating the substring actually used. If the string
 * is too small to hold the result of the conversion, Cvs_op executes
 * the error RangeCheck.
 *
 * If any is a number,  cvs produces a string respresentation of that
 * number. If any is a boolean, cvs produces either the string 'true'
 * or the string 'false'. If any is a string, cvs copies its contents
 * into string. If any is a name or an operator, cvs produces the text
 * of the associated name into string, otherwise cvs procedures the text
 * '--nostringval--'.
 *
 * TITLE:       op_cvs             Date:   08/06/87
 * CALL:        op_cvs()           UpDate: 06/29/88
 * PARAMETERS:  num_str    ; pointer to number/sting type object (4-byte)
 * INTERFACE:
 * CALL:
 * RETURN:      integer type object on operand stack if no error.
 * *******************************************************************
 */
fix
op_cvs()
{
    struct  object_def  FAR *string, FAR *any ;
    byte    l_strhold[STRMAXLEN] ;
    bool8   copy_flag ;
    ufix16  length, id ;
    union   four_byte  lf_num ;
    byte    FAR *text = 0;

    copy_flag = 1 ;  /* clear, if TYPE(any) = STRING, NAME, OPERATOR, default */
    any = GET_OPERAND(1) ;
    string = GET_OPERAND(0) ;
    if (ACCESS(string) != UNLIMITED) {
       ERROR(INVALIDACCESS) ;
       return(0) ;
    }

    switch (TYPE(any)) {
    case STRINGTYPE:
         if (ACCESS(any) != UNLIMITED && ACCESS(any) != READONLY) {
            ERROR(INVALIDACCESS) ;
            return(0) ;
         }
         length = LENGTH(any) ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         copy_flag = 0 ;
         lstrncpy((byte FAR *)(VALUE(string)), (byte FAR *)(VALUE(any)), length) ; /*@WIN*/
         break ;

    case REALTYPE:
         lf_num.ll = (fix32)VALUE(any) ;
         if (lf_num.ll == INFINITY )
            lstrcpy(l_strhold, (char FAR *)"Infinity.0") ;      /* @WIN */
         else
            gcvt(lf_num.ff, SIGNIFIC_DIGIT, (byte FAR *)l_strhold) ;
         length = (ufix16)lstrlen(l_strhold) ;          /* @WIN */
         break ;

    case INTEGERTYPE:
         ltoa((fix32)VALUE(any), (char FAR *)l_strhold, (int)DEFAULTRADIX);/*@WIN*/
         length = (ufix16)lstrlen(l_strhold) ;          /* @WIN */
         break ;

    case BOOLEANTYPE:
         if (VALUE(any) == 0) {
            length = 5 ;
            lstrncpy(l_strhold, "false", length) ;      /*@WIN*/
         } else {
            length = 4 ;
            lstrncpy(l_strhold, "true", length) ;       /*@WIN*/
         }
         break ;

    case NAMETYPE:
         id = (ufix16)VALUE(any) ;
         length = name_table[id]->name_len ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((byte FAR *)VALUE(string), name_table[id]->text, length) ;/*@WIN*/
         copy_flag = 0 ;
         break ;

    case OPERATORTYPE:
         id = (ufix16)LENGTH(any) ;
/* qqq, begin */
         /*
         switch (ROM_RAM(any)) {
         case RAM:
              text = systemdict_table[id].key ;
              break ;

         case ROM:
              text = oper_table[id].name ;
              break ;
         }   |* switch *|
         */
        text = systemdict_table[id].key ;
/* qqq, end */

         length = (ufix16)lstrlen(text) ;               /* @WIN */
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((char FAR *)VALUE(string), text, length) ;    /*@WIN*/
         copy_flag = 0 ;
         break ;

    default:
         length = 15 ;
         if (length > LENGTH(string)) {
            ERROR(RANGECHECK) ;
            return(0) ;
         }
         lstrncpy((char FAR *)VALUE(string), "--nostringval--", length) ;/*@WIN*/
         copy_flag = 0 ;
    } /* switch */

    if (copy_flag) {
       if (length > LENGTH(string)) {
          ERROR(RANGECHECK) ;
          return(0) ;
       } else
          lstrncpy((char FAR *)VALUE(string), l_strhold, length) ; /*@WIN*/
    }

    POP(2) ;
    PUSH_VALUE(STRINGTYPE, UNLIMITED, LITERAL, length, VALUE(string)) ;
    LEVEL_SET(GET_OPERAND(0), LEVEL(string)) ;

    return(0) ;
} /* op_cvs() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\win2ti.h ===
int far InitTrueImage(HDC hDC);
void far ExitTrueImage(void);
void TrueImage(HDC hDC, LPSTR buf, LPRECT PageRect, LPRECT EPSRect,int fBatch);
void BitbltFrameBuffer(HDC hDC, LPRECT DisplayRect, LPRECT EPSRect);

extern BOOL bGDIRender;


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\lang\vm.h ===
/*
 * Copyright (c) 1989,90 Microsoft Corporation
 */
/*
 ************************************************************************
 *      File name:              VM.H
 *      Author:                 Ping-Jang Su
 *      Date:                   11-Jan-88
 *
 * revision history:
 ************************************************************************
 */
#include    "global.ext"
#include    "language.h"

#define     VM_MAXCELL      16

struct cell_def {
    struct  object_def huge *address ;          /*@WIN 04-20-92*/
    struct  object_def saveobj ;
} ;

struct block_def {
    struct cell_def  block[VM_MAXCELL] ;
    struct block_def huge *previous ;           /*@WIN 04-20-92*/
} ;

struct save_def {
    struct  block_def   huge *fst_blk ;         /*@WIN 04-20-92*/
    struct  block_def   huge *curr_blk ;        /*@WIN 04-20-92*/
    ubyte   offset ;
    ubyte   packing ; /* changed the word packed to packing since packed
                         is a reserved C type. */
} ;

static  struct  save_def    far * saveary ;     /* @WIN; take out near */

#ifdef LINT_ARGS
static void near    update_dict_list(fix, fix, fix);      /* qqq */
#else
static void near    update_dict_list();
#endif /* LINT_ARGS */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\trueim.h ===
/* copied from global.ext, graphics.h, graphics.ext, and fillproc.h, since
   to work these files with windows.h will let C6.0 compile for a long time and
   need lots of memory
 */

/* from global.ext */
typedef int                   fix;
typedef unsigned int          ufix;
typedef short int             fix16;
typedef unsigned short int    ufix16;
typedef long                  fix32,
                              long32;
typedef unsigned long int     ufix32;
typedef float                 real32;
typedef char                  fix7,       /* 8-bits data type */
                              fix8,
                              byte;
typedef unsigned char         ufix8,      /* 8-bits unsigned data type */
                              bool8,
                              ubyte;

struct object_def {
    ufix16  bitfield ;               /* recording the object header */
    ufix16  length ;                 /* have diff meaning for diff object */
    ufix32  value ;                  /* recording the object content */
} ;

#define     TYPE_ON             0x000F                  /* from constant.h */
#define     LITERAL             0                       /* from constant.h */
#define     ATTRIBUTE_BIT       4                       /* from constant.h */
#define     ATTRIBUTE_ON        0x0003                  /* from constant.h */
#define     ATTRIBUTE_OFF       0xFFCF                  /* from constant.h */
#define     TYPE(obj)\
            ((obj)->bitfield & TYPE_ON)
#define     GET_OPERAND(n)\
            (opnstkptr - (n+1))
#define     POP(n)\
            {\
                opnstkptr -= n;\
                opnstktop -= n;\
            }
#define     ATTRIBUTE_SET(obj, var)\
            ((obj)->bitfield =\
             ((obj)->bitfield & ATTRIBUTE_OFF) | (((var) & ATTRIBUTE_ON) << ATTRIBUTE_BIT))
extern struct object_def far *opnstkptr;
extern  ufix16  near opnstktop ;


/* from graphics.h */
#define     MAXDASHSZ     11     /* from constant.h */
#define MAXDASH MAXDASHSZ
/*-----------------*
 | type definition |
 *-----------------*/
typedef fix16   sfix_t;
typedef fix32   lfix_t;
typedef fix16   PH_IDX;         /* index to path header, in path_table */
typedef fix16   SP_IDX;         /* index to subpath header, in node_table */
typedef fix16   VX_IDX;         /* index to vertex, in node_table */
typedef fix16   ET_IDX;         /* index to edge_table */
typedef fix16   CP_IDX;         /* index to clip_trpzd, in node_table */
typedef ufix32  gmaddr;         /* graphics memory address */
// DJC change to ufix16 typedef fix16   SCANLINE;       /* scanline structure */
typedef ufix16   SCANLINE;       /* scanline structure */

typedef fix16   HORZLINE;       /* scanline structure */
typedef fix16   PIXELIST;

struct coord {          /* floating point coordinate structure */
        real32  x;
        real32  y;
};

struct coord_i {
        sfix_t  x;
        sfix_t  y;
};

struct rectangle_i {    /* rectangle in integer coordinates */
        sfix_t  ux;
        sfix_t  uy;
        sfix_t  lx;
        sfix_t  ly;
};


/*-------------------------------*
 | Graphics State Data Structure |
 *-------------------------------*/

struct clr_hdr {                /* color structure */
        fix16   adj_gray;       /* index to gray table */
        real32  gray;           /* gray value */
        real32  hsb[3];         /* hue, sat, brt */
        fix16   inherit;        /* TRUE: inherit form previous */
};

struct gray_hdr {               /* adjust gray structure */
        fix16   val[256];
};

struct cp_hdr {                 /* Clipping trapezoid structure */
        CP_IDX  head;           /* index to edge table, to the head and tail */
        CP_IDX  tail;           /* of clipping trapezoids                    */
        sfix_t  bb_ux;          /* bounind box of clipping path:             */
        sfix_t  bb_uy;          /*      (ux, uy), (lx, ly)                   */
        sfix_t  bb_lx;          /*                                           */
        sfix_t  bb_ly;
        fix16   single_rect;    /* TRUE: single rectangle clipping region */
        fix16   inherit;        /* TRUE: inherit from previous gsave level */
};

struct scrn_hdr {               /* Halftone screen structure */
        fix16   chg_flag;       /* indicate repeat pattern need to update */
        real32  freq;
        real32  angle;
        fix16   no_whites;
        struct  object_def proc;
        fix16   spotindex;
                /* @@@ gstate manipulator should update fields above  */
        fix16   majorfact;
        fix16   minorfact;
        fix16   size_fact;
        fix16   cell_fact;
        fix16   scalefact;
        fix16   patt_size;
        fix16   cell_size;
        fix16   no_pixels;
                                /* the following fields inserted for
                                 * strange spots of binary pattern
                                 */
        fix16   ht_binary;
        fix16   bg_pixels;
        real32  back_gray;
        fix16   fg_pixels;
        real32  fore_gray;
};

struct dsh_hdr {                        /* dash pattern structure */
        fix16   pat_size;               /* no# of pattern element */
        real32  pattern[MAXDASH];       /* MAXDASH = 11 */
        struct  object_def pattern_obj;
        real32  offset;
                                        /* adjusted dash pattern @EHS_STK */
        fix16   dpat_index;
        real32  dpat_offset;
        fix16   dpat_on;
};

struct dev_hdr {                /* device related structure */
        real32  default_ctm[6];
        struct  rectangle_i default_clip;
        struct  object_def  device_proc;
        fix16   width;
        fix16   height;
        byte    chg_flg;        /* indicate device header needs to update */
        byte    nuldev_flg;     /* null device */
};

struct gs_hdr {                                 /* Graphics State structure */
        fix16   save_flag;                      /* set by save operator */
        real32  ctm[6];                         /* current transform matrix */
        struct  clr_hdr color;                  /* color */
        struct  coord   position;               /* current point */
        fix16   path;                           /* current path */
        struct  cp_hdr  clip_path;              /* clipping path */
        struct  object_def  font;               /* current typeface */
#ifdef KANJI
        struct  object_def  rootfont;           /* current rootfont */
#endif
        real32  line_width;                     /* line width */
        fix16   line_cap;                       /* line cap */
        fix16   line_join;                      /* line join */
        struct  scrn_hdr    halftone_screen;    /* halftone screen */
        struct  object_def transfer;            /* gray transfer function */
        real32  flatness;                       /* flatness */
        real32  miter_limit;                    /* miter limit */
        struct  dsh_hdr dash_pattern;           /* dash pattern */
        struct  dev_hdr device;                 /* device dependent */
                                                /* Jack Liaw 7-26-90 */
        bool8   graymode;                       /* FALSE:mono; TRUE:gray */
        bool8   interpolation;                  /* FALSE/TRUE */
};


struct tpzd {                           /* clip_tpzd --> tpzd, @SCAN_EHS */
    sfix_t  topy;          /* y coordinate of upper horiz. line */
    sfix_t  topxl;         /* left x_coordinate */
    sfix_t  topxr;         /* right x_coordinate */
    sfix_t  btmy;          /* y coordinate of bottom horiz. line */
    sfix_t  btmxl;         /* left x_coordinate */
    sfix_t  btmxr;         /* right x_coordinate */
};

struct tpzd_info {
        union {
                struct {
                        fix  box_x;     /* x-coordinate of upper-left corner */
                        fix  box_y;     /* y-coordinate of upper-left corner */
                } coord;
                gmaddr  bitmap;         /* address of character bitmap */
        } orig;
        fix  box_w;          /* width of the bounding box */
        fix  box_h;          /* height of the bounding box */
};
#define BMAP   orig.bitmap
#define BOX_X  orig.coord.box_x
#define BOX_Y  orig.coord.box_y


#define     REALTYPE            11              /* constant.h */
#define     F2L(ff)     (*((long32 far *)(&ff)))
#define     L2F(ll)     (*((real32 far *)(&ll)))
#define     VALUE(obj)\
            ((obj)->value)
#define     IS_REAL(a)      (TYPE(a)  == REALTYPE ? TRUE : FALSE)
#define     GET_OBJ_VALUE(f, obj)\
            {\
                    if (IS_REAL(obj))\
                            f = L2F(VALUE(obj));\
                    else\
                            f = (real32)((fix32)VALUE(obj));\
            }

/* from fillproc.h */
struct  bitmap
{
    gmaddr              bm_addr;        /* base address of bitmap       */
    fix                 bm_cols;        /* #(cols) of bitmap in pixels  */
    fix                 bm_rows;        /* #(rows) of bitmap in pixels  */
    fix                 bm_bpp;         /* #(planes) of bitmap */
};

/* from graphics.ext */
extern struct gs_hdr far *      GSptr;   /* pointer to current graphics state*/
extern struct bitmap near   FBX_Bmap;   /* from fillproc.ext */
extern unsigned long int far FBX_BASE;       /* from fillproc.ext */

/* from scaling.c for image */
struct OUTBUFFINFO
{
    fix16   repeat_y;       /* number of repeat in row */
    fix16  far *newdivc;    /* array of number of repeat in col for a pixel */
    ubyte  far *valptr0;    /* pointer to data */
    fix16   clipcol;        /* input col size */
    fix16   clipnewc;       /* output col size */
    fix16   clipx;          /* start data after clipping */
    ufix16  htsize;         /* halftone repeat pattern size */
    ufix16  httotal;        /* halftone size */
    ufix16  fbwidth;        /* frame buffer width in word */
    ufix16  fbheight;       /* height of the image @WIN_IM */
    ufix16  start_shift;    /* start position in a word */
    ubyte  far *htbound;    /* halftone pattern boundary in col */
    ubyte  far *htmin;      /* halftone pattern upper boundary in row */
    ubyte  far *htmax;      /* halftone pattern lower boundary in row */
    ubyte  far *htptr0;     /* halftone pattern pointer corresponding to data */
    ubyte  far *htmax0;     /* halftone pattern lower boundary in row for landscape*/
    ubyte  far *htmin0;     /* halftone pattern upper boundary in row for landscape*/
    ufix16 far *outbuff0;   /* starting word of a line in frame buffer */
    fix16   yout;           /* current line count of frame buffer */
    fix16   xout;           /* current col count of frame buffer */
    ubyte   gray[256];           /* convert gray_table for settransfer */
    ubyte   gray0;          /* gray value for 0 */
    ubyte   gray1;          /* gray value for 1 */
    ubyte   grayval;        /* current gray value */
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\winenv.c ===
/*
 * Copyright (c) 1992 Microsoft Corporation
 *
 * This file contains misc functions of porting Trueimage to Windows environment
 */

// DJC include global header file
#include "psglobal.h"


//#include    <math.h>
#include    <stdio.h>
#include    "global.ext"
#include    "geiio.h"
#include    "geitmr.h"
#include    "geisig.h"
#include    "geiioctl.h"
#include    "geipm.h"
#include    "gescfg.h"
#include    "geicfg.h"
#include    "graphics.h"
#include    "graphics.ext"
#include    "fillproc.h"
#include    "fillproc.ext"
#include    "fntjmp.h"

/*--------------------------+
 | pseudo routines for GEI  |
 +--------------------------*/
int             ES_flag;
unsigned int    manualfeed_com;
unsigned int    papersize_tmp;
int             papersize_nvr;
ufix32          save_printer_status;

void            DsbIntA(){}
void            switch2pcl(){}
void            GEPmanual_feed(){}
void            GEP_restart(){}

//DJC add the GEItmr routines required
//

/* GEItmr.c */
void           GEStmr_init(void) {}
int            GEItmr_start(GEItmr_t FAR *tmr) {return TRUE;}
int            GEItmr_reset(int tmrid ) {return TRUE;}
int            GEItmr_stop(int tmrid ) {return TRUE;}
void           GEItmr_reset_msclock() {}
unsigned long  GEItmr_read_msclock()
{
    DWORD   WINAPI GetTickCount(void);       // windows millisecond ticks

    return(GetTickCount());
}

/* GEIsig.c */
void           GESsig_init(void) {}
sighandler_t   GEIsig_signal(int sigid, sighandler_t sighandler)
                            {return(GEISIG_IGN);}
void           GEIsig_raise(int sigid, int sigcode)
{
    extern short int_flag;

         if (sigid == GEISIGINT)
        int_flag = 1;
    return;
}




/* GEIpm.c */
#define     _MAXSCCBATCH         10
#define     _MAXSCCINTER         10

//static unsigned char prname[]   = "\023MicroSoft TrueImage0.234567890.23"; @WIN
static unsigned char prname[]   = "\023MicroSoft TrueImage";
static unsigned char sccbatch[] = "\031\045\200\000\000\011\045\200\000\000";
static unsigned char sccinter[] = "\031\045\200\000\000\011\045\200\000\000";

void           GESpm_init(void) {}
int /* bool */ GEIpm_read(unsigned pmid, char FAR *pmvals, unsigned pmsize)
{
    switch (pmid) {
    case PMIDofPASSWORD:
         *(unsigned long FAR *)pmvals = 0;
         break;

    case PMIDofPAGECOUNT:
         *(unsigned long FAR *)pmvals = 0;
         break;

    case PMIDofPAGEPARAMS:
         ( (engcfg_t FAR *)pmvals )->timeout    = 0;
         ( (engcfg_t FAR *)pmvals )->leftmargin = 0;
         ( (engcfg_t FAR *)pmvals )->topmargin  = 0;
         ( (engcfg_t FAR *)pmvals )->pagetype   = 0;
         break;

    case PMIDofPAGETYPE:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSERIAL25:
    case PMIDofSERIAL9:
         ( (serialcfg_t FAR *)pmvals )->timeout     = 0;
         ( (serialcfg_t FAR *)pmvals )->baudrate    = _B9600;
         ( (serialcfg_t FAR *)pmvals )->flowcontrol = _FXONXOFF;
         ( (serialcfg_t FAR *)pmvals )->parity      =  _PNONE;
         ( (serialcfg_t FAR *)pmvals )->stopbits    = 1;
         ( (serialcfg_t FAR *)pmvals )->databits    = 8;
         break;

    case PMIDofPARALLEL:
         ( (parallelcfg_t FAR *)pmvals )->timeout   = 0;
         break;

    case PMIDofPRNAME:
         lmemcpy( pmvals, prname, sizeof(prname));
                        break;

    case PMIDofTIMEOUTS:
         ( (toutcfg_t FAR *)pmvals )->jobtout    =      0;
         ( (toutcfg_t FAR *)pmvals )->manualtout =      0;
         ( (toutcfg_t FAR *)pmvals )->waittout   =      0;     /* 0; @WIN */
         break;

    case PMIDofEESCRATCHARRY:
         break;

    case PMIDofIDLETIMEFONT:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSTSSTART:
         *( (unsigned char FAR *)pmvals ) = 0;
         break;

    case PMIDofSCCBATCH:
         lmemcpy(pmvals, sccbatch, _MAXSCCBATCH);
         break;

    case PMIDofSCCINTER:
         lmemcpy(pmvals, sccinter, _MAXSCCINTER);
         break;

    case PMIDofDPLYLISTSIZE:
    case PMIDofFONTCACHESZE:
    case PMIDofATALKSIZE:
    case PMIDofDOSTARTPAGE:
    case PMIDofHWIOMODE:
    case PMIDofSWIOMODE:
    case PMIDofPAGESTCKORDER:
    case PMIDofATALK:
    case PMIDofRESERVE:
         break;
         }
    return(TRUE);
}

int /* bool */ GEIpm_write(unsigned pmid, char FAR *pmvals, unsigned pmsize)
{
    return(TRUE);
}

int /* bool */ GEIpm_ioparams_read(char FAR *channelname, GEIioparams_t FAR *
                                   ioparams, int isBatch)
{
    ioparams->protocol = _SERIAL;
    ioparams->s.baudrate = _B9600;
    ioparams->s.parity = _PNONE;
    ioparams->s.stopbits = 1;
    ioparams->s.databits = 8;
    ioparams->s.flowcontrol = _FXONXOFF;
    return(TRUE);
}

int /* bool */ GEIpm_ioparams_write(char FAR *channelname, GEIioparams_t FAR *
                                   ioparams, int isBatch)
{
    return(TRUE);
}









// DJC remove definition of HWND, cause it is in windows.h
// typedef UINT                    HWND;
// DJC note this function is not used in PSTODIB
int GEIeng_printpage(ncopies, eraseornot)
int ncopies; int eraseornot;
{
#ifndef DUMBO
    extern HWND        hwndMain;
    void WinShowpage(HWND);
//DJC     WinShowpage(hwndMain);
   //DJC extern void PsPageReady(int, int);

   //DJC PsPageReady(ncopies, eraseornot);
#endif
    return 0;
}

fix GEIeng_checkcomplete() { return(0);}        /* always return ready @WIN */

#ifdef  DUMBO
// @DLL, added by JS, 4/30/92
void far GDIBitmap(box_x, box_y, box_w, box_h, nHalftone, nProc, lpParam)
fix   box_x, box_y, box_w, box_h;
ufix16 nHalftone;
fix   nProc;
LPSTR lpParam;
{}

void far GDIPolyline(int x0, int y0, int x1, int y1) {}
void far GDIPolygon(info, tpzd)
struct tpzd_info FAR *info;
struct tpzd FAR *tpzd;
{}

fix printf(char *va_alist) {}
#endif

/* +------------------------------+
   |   Sumpplementary C Library   |
   +------------------------------+
     lstrncmp lstrncpy lstrcat
     lmemcmp lmemcpy lmemset
     FixMul FixDiv
 */

int         FAR PASCAL lstrncmp( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                if (dest[i] != src[i]) return(-1);
        }
        return(0);
}

LPSTR       FAR PASCAL lstrncpy( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = src[i];
                if (!src[i]) break;
        }
        return(dest);
}

/* already provided by Win3.1 SDK Lib
LPSTR       FAR PASCAL lstrcat( LPSTR dest, LPSTR src)
{
        LPSTR p, q, r;

        for (p= dest; *p; p++);
        q = p; r = src;
        while(*r) *q++ = *r++;
        *q = 0;
        return(p);
}
*/

int         FAR PASCAL lmemcmp(LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                if (dest[i] != src[i]) return(-1);
        }
        return(0);
}

LPSTR       FAR PASCAL lmemcpy( LPSTR dest, LPSTR src, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = src[i];
        }
        return(dest);
}

LPSTR       FAR PASCAL lmemset( LPSTR dest, int c, int count)
{
        int i;

        for (i=0; i<count; i++) {
                dest[i] = (char)c;
        }
        return(dest);
}

#ifdef DJC
// dummy setjmp and longjmp
int setjmp(jmp_buf jmpbuf) {return(0);}
void longjmp(jmp_buf jmpbuf , int i) {
        printf("Warning -- longjmp\n");
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\wintt.c ===
// DJC includ global header file
#include "psglobal.h"


#include <windows.h>


#include "winenv.h"
#include "trueim.h"
//DJC ti.h is in DTI and should not be used
//include "ti.h"
#include "wintt.h"

/* @PROFILE */
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <io.h>
#include "..\font\fontdefs.h"   //DJC added
#include "..\..\..\psqfont\psqfont.h"

double strtod(char FAR *str, char FAR * FAR *endptr);

char szDebugBuffer[80];

//int FAR cdecl printf(LPSTR,...);
// DJC printf should be defined in stdio.h int printf(char *,...);

RECT CharRect= {300, 100, 400, 200};

static     int            nFontID;
static     int            nCharCode;
static     HFONT          hFont;
static     FONT FAR       *font;
static     HDC hdc;

/* from "fontdefs.h" */
#ifdef DJC
typedef struct
             {   long       font_type;
                 char       FAR *data_addr; /*@WIN*/
                 char       FAR *name;      /*@WIN*/
                 char       FAR *FileName;  /*@PROFILE; @WIN*/
                 float      FAR *matrix;    /*@WIN*/
                 unsigned long   uniqueid;
                 float     italic_ang;
                 short      orig_font_idx;
             }   font_data;
/* @PROFILE --- Begin */
typedef struct
             {   int        num_entries;
                 font_data  FAR *fonts; /*@WIN*/
             }   font_tbl;
#endif

//DJC font_data FontDefs[35];

font_data FontDefs[MAX_INTERNAL_FONTS];
font_tbl built_in_font_tbl= { 0, FontDefs};
static char szProfile[] = "tumbo.ini";
static char szControlApp[] = "control";
static char szTIFontApp[] = "TIFont";
static char szSubstituteApp[] = "SubstituteFont";

#define KEY_SIZE 1024

#define        NULL_MATRIX                 (float FAR *)NULL
float MATRIX_O12[] =  {(float)0.001,   (float)0.0,  (float)0.000212577,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_O105[] = {(float)0.001,   (float)0.0,  (float)0.000185339,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_N0[] =   {(float)0.00082, (float)0.0,  (float)0.0,
                        (float)0.001,   (float)0.0,  (float)0.0};
float MATRIX_N10[] =  {(float)0.00082, (float)0.0,  (float)0.000176327,
                        (float)0.001,   (float)0.0,  (float)0.0};

// DJC #define ACT_FONT_SIZE 4
// DJC increase to 35
//#define ACT_FONT_SIZE 35

#define FONTDATASIZE  65536L    /* temp testing */
#define BUFSIZE 128

typedef struct {
     GLOBALHANDLE hGMem;
     struct object_def FAR *objFont;
} ACTIVEFONT;
//DJC ACTIVEFONT ActiveFont[ACT_FONT_SIZE];

/* @PROFILE ---  End  */

/* from "in_sfnt.h", for TTBitmapSize() */
struct  CharOut {
        float   awx;
        float   awy;
        float   lsx;
        float   lsy;
        unsigned long byteWidth;
        unsigned short bitWidth;
        short    scan;
        short    yMin;
        short    yMax;
};

#ifdef DJC  // not used

#define FONTLOCK() \
     hdc = GetDC (hwndMain); \
     font = (FONT FAR *) GlobalLock (enumer2.hGMem) + nFontID; \
     hFont = SelectObject (hdc, CreateFontIndirect (&font->lf))

#define FONTUNLOCK() \
     GlobalUnlock (enumer2.hGMem); \
     DeleteObject (SelectObject (hdc, hFont)); \
     ReleaseDC (hwndMain, hdc)

// #define     F2L(ff)     (*((long FAR *)(&ff)))       defined in win2ti.h
#define POINT2FLOAT(p) ( (float)p.value + (unsigned)p.fract / (float)65536.0)

extern HWND        hwndMain;
extern ENUMER  enumer1, enumer2;
extern FARPROC lpfnEnumAllFaces, lpfnEnumAllFonts;
GLYPHMETRICS   gm;
MAT2 mat2;

#endif // DJC


static OFSTRUCT OfStruct;     /* information from OpenFile() */

void TTQuadBezier(LPPOINTFX p0, LPPOINTFX p1, LPPOINTFX p2);
void cr_translate(float FAR *tx, float FAR *ty);      // from "ry_font.c"
static int LargestCtm(float FAR *ctm, float FAR *lsize);
void    moveto(long, long);
void    lineto(long, long);
void    curveto(long, long, long, long, long, long);
int     op_newpath(void);
int     op_closepath(void);
static void TTMoveto(LPPOINTFX lpPointfx);
static void TTLineto(LPPOINTFX lpPointfx);
static void TTNewpath(void);
static void TTClosepath(void);

#ifdef DJC
// not used

int FAR PASCAL EnumAllFaces (LPLOGFONT lf, LPNEWTEXTMETRIC ntm,
                             short nFontType, ENUMER FAR *enumer)
{
     LPSTR lpFaces;

     if (NULL == GlobalReAlloc (enumer->hGMem,
                         (DWORD) LF_FACESIZE * (1 + enumer->nCount),
                         GMEM_MOVEABLE))
          return 0;

     // @SC; ignore non-TT font
     if(!(nFontType & TRUETYPE_FONTTYPE)) {
        return 1;
     }

     lpFaces = GlobalLock (enumer->hGMem);
     lstrcpy (lpFaces + enumer->nCount * LF_FACESIZE, lf->lfFaceName);
     GlobalUnlock (enumer->hGMem);
     enumer->nCount ++;
     return 1;
}

int FAR PASCAL EnumAllFonts (LPLOGFONT lf, LPNEWTEXTMETRIC ntm,
                             short nFontType, ENUMER FAR *enumer)
{
     FONT FAR *font;
     static int nFirstWinTT=0;


     if (NULL == GlobalReAlloc (enumer->hGMem,
                         (DWORD) sizeof (FONT) * (1 + enumer->nCount),
                         GMEM_MOVEABLE))
          return 0;

     // @SC; ignore non-TT font
     if(!(nFontType & TRUETYPE_FONTTYPE)) {
        return 1;
     }

     font = (FONT FAR *) GlobalLock (enumer->hGMem) + enumer->nCount;
     font->nFontType = nFontType;
     font->lf = *lf;
     font->ntm = *ntm;

     GlobalUnlock (enumer->hGMem);
     enumer->nCount ++;
     return 1;
}

void CheckFontData ()
{
     int x=10, y=50;
     int j;

     HGLOBAL hglb;
     DWORD dwSize;
     void FAR* lpvBuffer;
     union {
          DWORD FAR * dw;
          int FAR * sw;
          char FAR * ch;
     } lp;
     DWORD dwVersion, dwCheckSum, dwOffset, dwLength;
     int nNumTables, nSearchRange, nEntrySelector, nRangeShift;
     char chTag0, chTag1, chTag2, chTag3;

     FONTLOCK();

     /* get TT font data */
     if ((dwSize = GetFontData (hdc, NULL, 0L, NULL, 0L))==0 ||
         dwSize == 0xffffffffL) {
         printf("GetFontData() error: size <= 0\n");
         goto NoTTFontData;
     }
     hglb = GlobalAlloc (GPTR, dwSize);
     lpvBuffer = GlobalLock (hglb);
     if ((GetFontData (hdc, NULL, 0L, lpvBuffer, dwSize))== -1) {
         printf("GetFontData() error: fail to get data\n");
         GlobalUnlock (hglb);
         GlobalFree (hglb);
         goto NoTTFontData;
     }

     SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT));

     /* analysis the Offset table & Table Directory */
     lp.dw = (DWORD FAR *)lpvBuffer;
     dwVersion = LWORDSWAP(*lp.dw); lp.dw ++;
     nNumTables = SWORDSWAP(*lp.sw); lp.sw ++;
     nSearchRange = SWORDSWAP(*lp.sw); lp.sw ++;
     nEntrySelector = SWORDSWAP(*lp.sw); lp.sw ++;
     nRangeShift = SWORDSWAP(*lp.sw); lp.sw ++;
     for (j=0; j<nNumTables; j++) {
         chTag0 = *lp.ch++;
         chTag1 = *lp.ch++;
         chTag2 = *lp.ch++;
         chTag3 = *lp.ch++;
         dwCheckSum = LWORDSWAP(*lp.dw); lp.dw ++;
         dwOffset = LWORDSWAP(*lp.dw); lp.dw ++;
         dwLength = LWORDSWAP(*lp.dw); lp.dw ++;
         wsprintf(szDebugBuffer,"Table %c%c%c%c ---   Offset: %lx, Length: %lx",
              chTag0, chTag1, chTag2, chTag3, dwOffset, dwLength);
         TextOut (hdc, 10, y, szDebugBuffer, lstrlen(szDebugBuffer));
         y += 20;
     }
     wsprintf(szDebugBuffer,"Total length: %lx", dwSize);
     TextOut (hdc, 20, y, szDebugBuffer, lstrlen(szDebugBuffer));

     GlobalUnlock (hglb);
     GlobalFree (hglb);

NoTTFontData:

     FONTUNLOCK();
     return;
}
#endif // DJC


void TTLoadFont (int nFont) {
     nFontID = nFont;
}

void TTLoadChar (int nChar) {
     nCharCode = nChar;
}


#ifdef DJC // not used

int TTAveCharWidth (void)
{
     int nWidth;
     HGLOBAL hglb;
     LPABC lpabc;

     FONTLOCK();

     //  /* refer to rc_GetAdvanceWidth():
     //   *     Metrs->awx = (int)(key->nonScaledAW*PDLCharUnit/EMunits+0.5);
     //   * to get a non-linear scaling advance width
     //   */
     //  nWidth = (int)((float)(font->ntm.ntmAvgWidth) * 1000.0 /
     //                       font->ntm.ntmSizeEM + 0.5);

     // using non-linear advance width
     hglb = GlobalAlloc (GPTR, (DWORD) sizeof (ABC));
     lpabc = (LPABC)GlobalLock (hglb);

     if (!GetCharABCWidths (hdc, nCharCode, nCharCode, lpabc)) {
         printf("GetCharABCWidths() error\n");
     }

     nWidth = lpabc->abcA + lpabc->abcB + lpabc->abcC;
     GlobalUnlock (hglb);
     GlobalFree (hglb);

     FONTUNLOCK();
     return nWidth;
}

float TTTransform (float FAR *ctm)
{
        long int  ma, mb, mc, md;
        float   largest_ctm;
        float   pts;
        #define FLOAT2FIXED(x)  ((long int)(x * (1L << 16)))

        /* Find Largest of the ctm */
        LargestCtm(ctm, &largest_ctm);

        ma = FLOAT2FIXED(     ctm[0] / largest_ctm);
        mb = FLOAT2FIXED(-1.0*ctm[1] / largest_ctm); /* Element b & d must be mirrored */
        mc = FLOAT2FIXED(     ctm[2] / largest_ctm);
        md = FLOAT2FIXED(-1.0*ctm[3] / largest_ctm);
          mat2.eM11.fract = (int)((DWORD)ma &0x0ffffL);
          mat2.eM11.value = (int)((DWORD)ma >>16);
          mat2.eM12.fract = (int)((DWORD)mb &0x0ffffL);
          mat2.eM12.value = (int)((DWORD)mb >>16);
          mat2.eM21.fract = (int)((DWORD)mc &0x0ffffL);
          mat2.eM21.value = (int)((DWORD)mc >>16);
          mat2.eM22.fract = (int)((DWORD)md &0x0ffffL);
          mat2.eM22.value = (int)((DWORD)md >>16);
        FONTLOCK();

//      pts = ((largest_ctm * PDLCharUnit * 72.0) / (float)sfdt.dpi);
        pts = (largest_ctm * 1000 * (float)72.0) /
                            (float)GetDeviceCaps (hdc, LOGPIXELSX);
        pts = pts * (float)1.536;  // tuning point size; we don't know why the point
                           // size is smaller than expected, so just scale
                           // up.  @WIN for temp solution
        font->lf.lfHeight = (int)pts;
        font->lf.lfWidth = 0;           // force TT to chose acording to height
        FONTUNLOCK();
        return largest_ctm;
}


void TTBitmapSize (struct CharOut FAR *CharOut)
{
     FONTLOCK();

     GetGlyphOutline (hdc, nCharCode, GGO_BITMAP,
                           (LPGLYPHMETRICS) &gm,
                           0, NULL, (LPMAT2) &mat2);

        CharOut->awx       = gm.gmCellIncX;
        CharOut->awy       = gm.gmCellIncY;
        CharOut->lsx       = gm.gmptGlyphOrigin.x;
        CharOut->lsy       = gm.gmptGlyphOrigin.y;
        CharOut->byteWidth = ((gm.gmBlackBoxX+31) & 0xffe0) >>3; // bytes in DWORD boundary
        CharOut->bitWidth = gm.gmBlackBoxX;
        CharOut->yMin      = gm.gmptGlyphOrigin.y-gm.gmBlackBoxY;
        CharOut->yMax      = gm.gmptGlyphOrigin.y;
        CharOut->scan      = gm.gmBlackBoxY;
     FONTUNLOCK();

}


unsigned long ShowGlyph (unsigned int fuFormat, char FAR *lpBitmap)
{
     DWORD dwSize;
     HGLOBAL hglb;
     void FAR* lpvBuffer;
     int i, x=10, y=50;

     POINT ptStart = {10, 10};
     unsigned long dwWidthHeight;
#ifdef DBG
     float nCol, nInc;
     HPEN hOldPen;
     HPEN hRedPen;
     HPEN hDotPen;
#endif

     FONTLOCK();

          // DJC MoveTo (hdc, ptStart.x, ptStart.y);
          MoveToEx (hdc, ptStart.x, ptStart.y, NULL);

          dwSize = GetGlyphOutline (hdc, nCharCode, fuFormat,
                           (LPGLYPHMETRICS) &gm,
                           0, NULL, (LPMAT2) &mat2);

          hglb = GlobalAlloc (GPTR, dwSize);
          lpvBuffer = GlobalLock (hglb);
          if (GetGlyphOutline (hdc, nCharCode, fuFormat,
                           (LPGLYPHMETRICS) &gm,
                           dwSize, lpvBuffer, (LPMAT2) &mat2) == -1) {
              printf("GetGlyphOutline() error\n");
              goto OutlineError;
          }

          if (fuFormat == GGO_BITMAP) {
              UINT uWidth, uHeight;
#ifdef DBG
              DWORD FAR * lpdwBits;
              HBITMAP hBitmap;
              HBITMAP hOldBitmap;
              HDC hdcBitmap;
#endif
              uWidth = ((gm.gmBlackBoxX+31) & 0xffe0) >>3; // bytes in DWORD boundary
              uHeight = gm.gmBlackBoxY;

              // copy bitmap
              lmemcpy (lpBitmap, lpvBuffer, (int) dwSize);
              dwWidthHeight = ((DWORD)uWidth <<19) | (DWORD)uHeight;
                                /* uWidth in bits */

#ifdef DBG
              if ((DWORD)(uWidth * uHeight) != dwSize)
                  printf("byte count wrong in GetGlyphOutline() for bitmap\n");

              // display bitmap
              /* create bitmap */
              hBitmap = CreateBitmap(uWidth*8, uHeight, 1, 1,
                               (LPSTR)lpvBuffer);
              if (!hBitmap) {
                  printf("fail to create bitmap\n");
                  goto OutlineError;
              }
              hdcBitmap = CreateCompatibleDC(hdc);
              hOldBitmap = SelectObject(hdcBitmap, hBitmap);

              /* Bitblt bitmap to Windows DC */
              SetStretchBltMode(hdc, BLACKONWHITE);

              i = gm.gmptGlyphOrigin.x *
                  (CharRect.right-CharRect.left) / (gm.gmCellIncX);

              StretchBlt(hdc, CharRect.left + i, CharRect.top,
                      CharRect.right - CharRect.left,
                      CharRect.bottom - CharRect.top,
                      hdcBitmap, 0, 0,
                      gm.gmCellIncX, uHeight,
                      (DWORD)0x00330008);    // Boolean 33, NOTSRCCOPY

              SelectObject(hdcBitmap, hOldBitmap);
              DeleteDC(hdcBitmap);
              DeleteObject(hBitmap);

              /* display grid */
              hDotPen = CreatePen(2, 2, RGB(0, 0, 0));
              hRedPen = CreatePen(0, 1, RGB(255, 0, 0));   // solid pen
              hOldPen = SelectObject(hdc, hRedPen);

              nInc = ((float)(CharRect.right-CharRect.left))/(gm.gmCellIncX);
              if(nInc<1) nInc = 1;
              for (nCol= CharRect.left; nCol <=CharRect.right+1; nCol+=nInc) {
                   // DJC MoveTo(hdc, (int)nCol, CharRect.top);
                   MoveToEx(hdc, (int)nCol, CharRect.top, NULL);
                   LineTo(hdc, (int)nCol, CharRect.bottom);
              }
              nInc = ((float)(CharRect.bottom-CharRect.top))/(uHeight);
              if(nInc<1) nInc = 1;
              for (nCol= CharRect.top; nCol <CharRect.bottom; nCol+=nInc) {
                   // DJC MoveTo(hdc, CharRect.left, (int)nCol);
                   MoveToEx(hdc, CharRect.left, (int)nCol, NULL);
                   LineTo(hdc, CharRect.right, (int)nCol);
              }

              // draw Char box
              SelectObject(hdc, hDotPen);
              // DJC MoveTo(hdc, CharRect.left, CharRect.top);
              MoveToEx(hdc, CharRect.left, CharRect.top, NULL);
              LineTo(hdc, CharRect.right, CharRect.top);
              LineTo(hdc, CharRect.right, CharRect.bottom);
              LineTo(hdc, CharRect.left, CharRect.bottom);
              LineTo(hdc, CharRect.left, CharRect.top);

              /* restore old pen */
              SelectObject(hdc, hOldPen);
              DeleteObject(hRedPen);
              DeleteObject(hDotPen);
#endif

          } else {      // GGO_NATIVE
              TTPOLYGONHEADER FAR * lpHeader;
              TTPOLYCURVE FAR * lpCurve;
              POINTFX FAR * lpPoint, FAR * cp;
              DWORD dwEnd;

              SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT));

              lpHeader = (TTPOLYGONHEADER FAR *)lpvBuffer;

              TTNewpath();

              while ((DWORD)lpHeader < ((DWORD)lpvBuffer + dwSize)) {

                  dwEnd = (DWORD)lpHeader + lpHeader->cb;

                  TTMoveto (&lpHeader->pfxStart);
                  cp = &lpHeader->pfxStart;

                  lpCurve = (TTPOLYCURVE FAR *)((TTPOLYGONHEADER FAR *)lpHeader+1);

                  while ((DWORD)lpCurve < dwEnd) {

                      lpPoint = (POINTFX FAR *)&lpCurve->apfx[0];
                      if (lpCurve->wType == TT_PRIM_QSPLINE) {
                          POINTFX OnPoint;
                          POINTFX FAR * mp, FAR * end;
                          long lx, ly;

                          end = lpPoint + (lpCurve->cpfx -1);
                          mp = lpPoint++;
                          while (lpPoint < end) {

                              lx = (((long)mp->x.value << 16) +
                                   mp->x.fract +
                                   ((long)lpPoint->x.value << 16) +
                                   lpPoint->x.fract) >>1;
                              ly = (((long)mp->y.value << 16) +
                                   mp->y.fract +
                                   ((long)lpPoint->y.value << 16) +
                                   lpPoint->y.fract) >>1;
                              OnPoint.x.value = (int)(lx >> 16);
                              OnPoint.x.fract = (int)(lx & 0xffffL);
                              OnPoint.y.value = (int)(ly >> 16);
                              OnPoint.y.fract = (int)(ly & 0xffffL);

                              TTQuadBezier(cp, mp, (POINTFX FAR *)&OnPoint);
                              cp = (POINTFX FAR *)&OnPoint;
                              mp = lpPoint++;
                          }
                          TTQuadBezier(cp, mp, lpPoint);
                          cp = lpPoint++;

                      } else {
                          for (i=0; (unsigned)i<lpCurve->cpfx; i++, lpPoint++) {
                              TTLineto (lpPoint);
                              cp = lpPoint;
                          }
                      }

                      lpCurve = (TTPOLYCURVE FAR *)lpPoint;
                  }

                  lpHeader = (TTPOLYGONHEADER FAR *)lpCurve;

                  TTClosepath();
              }
          }
OutlineError:
          GlobalUnlock (hglb);
          GlobalFree (hglb);
          FONTUNLOCK();
          return dwWidthHeight;
}

void ShowABCWidths(UINT uFirstChar, UINT uLastChar)
{
     HGLOBAL hglb;
     LPABC lpabc;
     unsigned int i;

     FONTLOCK();

     hglb = GlobalAlloc (GPTR,
                         (DWORD) sizeof (ABC) * (uLastChar - uFirstChar +1));
     lpabc = (LPABC)GlobalLock (hglb);

     if (!GetCharABCWidths (hdc, uFirstChar, uLastChar, lpabc)) {
         printf("GetCharABCWidths() error\n");
     }

     for (i=uFirstChar; i<=uLastChar; i++) {
         LPABC lp = lpabc + (i - uFirstChar);
     }

     GlobalUnlock (hglb);
     GlobalFree (hglb);
     FONTUNLOCK();
}

void TTCharPath()
{
    ShowGlyph (GGO_NATIVE, (char FAR *)NULL);
}

#define KK              ((float)1.0/(float)3.0)
void TTQuadBezier(LPPOINTFX p0, LPPOINTFX p1, LPPOINTFX p2)
{
    float xx, yy, x0, x1, x2, y0, y1, y2;

    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]

    x0 = xx + POINT2FLOAT (p0->x);
    y0 = yy - POINT2FLOAT (p0->y);
    x1 = xx + POINT2FLOAT (p1->x);
    y1 = yy - POINT2FLOAT (p1->y);
    x2 = xx + POINT2FLOAT (p2->x);
    y2 = yy - POINT2FLOAT (p2->y);
    x1 *= 2;
    y1 *= 2;

//  printf("%f %f    %f %f    %f %f curveto\n",
//          (x0+x1)*KK, (y0+y1)*KK, (x2+x1)*KK, (y2+y1)*KK, x2, y2);
//  curveto((x0+x1)*KK, (y0+y1)*KK, (x2+x1)*KK, (y2+y1)*KK, x2, y2);
    x0 = (x0+x1) * KK;
    y0 = (y0+y1) * KK;
    x1 = (x1+x2) * KK;
    y1 = (y1+y2) * KK;
    curveto(F2L(x0), F2L(y0), F2L(x1), F2L(y1), F2L(x2), F2L(y2));
}


static void TTMoveto(LPPOINTFX lpPointfx)
{
    float xx, yy;
    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]
    xx += POINT2FLOAT (lpPointfx->x);
    yy -= POINT2FLOAT (lpPointfx->y);
//  printf("(%f, %f) moveto\n", xx, yy);
    moveto(F2L(xx), F2L(yy));
}

static void TTLineto(LPPOINTFX lpPointfx)
{
    float xx, yy;
    cr_translate((float FAR *)&xx, (float FAR *)&yy); // get GSptr->ctm[4],[5]
    xx += POINT2FLOAT (lpPointfx->x);
    yy -= POINT2FLOAT (lpPointfx->y);
//  printf("(%f, %f) moveto\n", xx, yy);
    lineto(F2L(xx), F2L(yy));
}

static void TTNewpath()
{
//  printf("newpath\n");
    op_newpath();
}
static void TTClosepath()
{
//  printf("closepath\n");
    op_closepath();
}

#endif // DJC


/* --------------------------------------------------------------------
 * Routine: LargestCtm(ctm, lsize)
 *
 * Find Largest value of the given ctm to
 * find the largest element in the matrix.
 * This routine return the largest
 * of scale and yscale as well as the scale factors them selves.
 *
 * --------------------------------------------------------------------*/
static int LargestCtm(float FAR *ctm, float FAR *lsize)
{
    float    a, b, c, d;
    #define IS_ZERO(f) ((unsigned long)  (!((*((long FAR *)(&f))) & 0x7fffffffL)))

    a = (ctm[0] >= (float)0.0) ? ctm[0] : - ctm[0];
    b = (ctm[1] >= (float)0.0) ? ctm[1] : - ctm[1];
    c = (ctm[2] >= (float)0.0) ? ctm[2] : - ctm[2];
    d = (ctm[3] >= (float)0.0) ? ctm[3] : - ctm[3];

    if (b > a)    a = b;
    if (d > c)    c = d;

    if (c > a)    a = c;

    if (IS_ZERO(a))    *lsize = (float)1.0;
    else               *lsize = a;

    return(0);
} /* LargestCtm() */

int TTOpenFile(char FAR *szName)
{
    return (OpenFile(szName, (LPOFSTRUCT) &OfStruct, OF_READ));
}

#ifdef DJC  // this is the original code that read the fonts out of tumbo.ini
/* @PROFILE --- Begin */
void SetupFontDefs()
{
     static char lpAllKeys[KEY_SIZE], *lpKey;
     static char lpBuffer[KEY_SIZE], *lpValue;

     int bWinFont, bTIFont;
     int nTIFont=0;
     font_data FAR *lpFont;
     char * lpFilename, *lpMatrix, *lpAngle, *lpStop;
     //DJC
     char szFullProfile[255];


     PsFormFullPathToCfgDir( szFullProfile, szProfile);  // DJC added



     bWinFont = bUsingWinFont();
     //DJC bTIFont = GetPrivateProfileInt (szControlApp, "Tifont", 0, szProfile);
     bTIFont = GetPrivateProfileInt (szControlApp, "Tifont", 0, szFullProfile);

     lpKey = lpAllKeys;
     lpValue = lpBuffer;
     if(bTIFont) {
         //DJC GetPrivateProfileString (szTIFontApp, NULL, "", lpKey, KEY_SIZE,
         //DJC                         szProfile);
         GetPrivateProfileString (szTIFontApp, NULL, "", lpKey, KEY_SIZE,
                                  szFullProfile);

         while (*lpKey) {
             lpFont = &(built_in_font_tbl.fonts[nTIFont]);
             lpFont->name = lpKey;
             //DJC GetPrivateProfileString (szTIFontApp, lpKey, "", lpValue, 80,
             //DJC                     szProfile);
             GetPrivateProfileString (szTIFontApp, lpKey, "", lpValue, 80,
                                  szFullProfile);

             lpFilename = strtok (lpValue, ", ");
             lpValue += strlen(lpFilename) + 1;

#ifdef DJC
             lpMatrix = strtok (lpValue, ", ");
             lpValue += strlen(lpMatrix) + 1;
#else
             lpMatrix = strtok(lpValue,", ");
             if ( lpMatrix != NULL ) {
                lpValue += strlen(lpMatrix) + 1;
             }
#endif
             lpFont->FileName = lpFilename;
             // DJC if (*lpMatrix) {
             if (lpMatrix) {
                 lpAngle = strtok (lpValue, ", ");
                 lpValue += strlen(lpAngle) + 1;

                 switch (*lpMatrix) {
                     case 'O':          // Oblique 12
                     case 'o':          // Oblique 12
                         lpFont->matrix = MATRIX_O12;
                         break;
                     case 'P':          // Oblique 10.5
                     case 'p':          // Oblique 10.5
                         lpFont->matrix = MATRIX_O105;
                         break;
                     case 'M':          // Narrow 0
                     case 'm':          // Narrow 0
                         lpFont->matrix = MATRIX_N0;
                         break;
                     case 'N':          // Narrow 10
                     case 'n':          // Narrow 10
                         lpFont->matrix = MATRIX_N10;
                         break;
                     default:
                         lpFont->matrix = NULL_MATRIX;
                 }
                 lpFont->italic_ang = (float) strtod ((char FAR *)lpAngle,
                         (char FAR * FAR *)&lpStop);
             } else {
                 lpFont->matrix = NULL_MATRIX;
                 lpFont->italic_ang = (float)0.0;
             }

             lpFont->uniqueid = nTIFont+TIFONT_UID;// avoid uniqueid being zero
             lpFont->font_type = (long)42;
             lpFont->orig_font_idx = -1;        // tmp solution

             nTIFont ++;
             lpKey += strlen (lpKey) + 1 ;
         }
     }
     built_in_font_tbl.num_entries = nTIFont;

     // setup all win31 TT fonts
     if(bWinFont) {
#ifdef DJC // not used

#ifdef ALLOCATE_ALL_WINTT
        int i;
        for (i=0; i<enumer2.nCount && built_in_font_tbl.num_entries<35; i++) {
            FONT FAR *font;
            font_data FAR *lpFontDef;
            char *lp;

            font = (FONT FAR *) GlobalLock (enumer2.hGMem) + i;
            lpFontDef = &(built_in_font_tbl.fonts[nTIFont+i]);

            lstrcpy(lpKey, font->lf.lfFaceName);
            for (lp=lpKey; *lp; lp++) {
                if(*lp == ' ') *lp = '-';
            }
            if (font->ntm.ntmFlags & NTM_BOLD) strcat(lpKey, "Bold");
            if (font->ntm.ntmFlags & NTM_ITALIC) strcat(lpKey, "Italic");

            lpFontDef->font_type = (long)42;
            lpFontDef->data_addr = (char FAR *)NULL;
            lpFontDef->name = (char FAR *)lpKey;
            lpFontDef->FileName = (char FAR *)NULL;
            lpFontDef->matrix = NULL_MATRIX;
            lpFontDef->uniqueid = WINFONT_UID + i;
            lpFontDef->italic_ang = (float)0.0;
            lpFontDef->orig_font_idx = -1;

            lpKey += strlen(lpKey) + 1;
            built_in_font_tbl.num_entries++;

            GlobalUnlock (enumer2.hGMem);
        }
#endif
         int nFontDef, uid;
         int nBold, nItalic;
         FONT FAR *font;
         font_data FAR *lpFontDef;
         char * lpAttr;

         //DJC GetPrivateProfileString (szSubstituteApp, NULL, "", lpKey, KEY_SIZE,
         //DJC                         szProfile);
         GetPrivateProfileString (szSubstituteApp, NULL, "", lpKey, KEY_SIZE,
                                  szFullProfile);

         for(; *lpKey; lpKey += strlen(lpKey)+1) {
             /* search existing fonts in FontDefs[] */
             for (nFontDef=0; nFontDef<built_in_font_tbl.num_entries;
                  nFontDef++) {
                if(!lstrcmp(built_in_font_tbl.fonts[nFontDef].name,
                            (char FAR*)lpKey)) {
                    break;      // found
                }
             }
//           if (nFontDef >= built_in_font_tbl.num_entries) continue;   // not found; ignore it

             /* get value from profile */
             //DJC GetPrivateProfileString (szSubstituteApp, lpKey, "", lpValue, 80,
             //DJC                       szProfile);

             GetPrivateProfileString (szSubstituteApp, lpKey, "", lpValue, 80,
                                  szFullProfile);

             lpFilename = strtok (lpValue, ",");
             lpValue += strlen(lpFilename) + 1;
             nBold = nItalic = 0;
             do {
                 lpAttr = strtok (lpValue, ",");
                 lpValue += strlen(lpAttr) + 1;
                 if(*lpAttr == 'B' || *lpAttr == 'b') nBold = NTM_BOLD;
                 if(*lpAttr == 'I' || *lpAttr == 'i') nItalic = NTM_ITALIC;
             } while (strlen(lpAttr));

             /* search for existing fonts in win31 */
             font = (FONT FAR *) GlobalLock (enumer2.hGMem);
             for (uid=0; uid<enumer2.nCount; uid++, font++) {
                if(!lstrcmp(font->lf.lfFaceName, (char FAR*)lpFilename)) {
                    if (nBold ^ (font->ntm.ntmFlags & NTM_BOLD)) continue;
                    if (nItalic ^ (font->ntm.ntmFlags & NTM_ITALIC)) continue;
                    break;      /* found */
                }
             }
             if (uid >= enumer2.nCount) continue;   // not found; ignore it

             lpFontDef = &(built_in_font_tbl.fonts[nFontDef]);
             lpFontDef->font_type = (long)42;
             lpFontDef->data_addr = (char FAR *)NULL;
             lpFontDef->name = (char FAR *)lpKey;
             lpFontDef->FileName = (char FAR *)NULL;
             lpFontDef->matrix = NULL_MATRIX;
             lpFontDef->uniqueid = WINFONT_UID + uid;
             lpFontDef->italic_ang = (float)0.0;
             lpFontDef->orig_font_idx = -1;

             if (nFontDef >= built_in_font_tbl.num_entries) {
                 // add a new font name in fontdefs[]
                 built_in_font_tbl.num_entries++;
             }
         }
#endif // DJC
       ; // DJC

     }   /* if(bWinFont) */
}
#endif


LPTSTR PsStringAllocAndCopy( LPTSTR lptStr )
{
    LPTSTR lpRet=NULL;
    if (lptStr) {
      lpRet = (LPTSTR) LocalAlloc( LPTR, (lstrlen(lptStr) + 1) * sizeof(TCHAR));
	  if (lpRet != NULL)
      {
      	lstrcpy( lpRet, lptStr);
      }
    }
    return(lpRet);
}

//
// DJC , SetupFontDefs is completeley re-written to take advantage of
//       the Font query API implemented in psqfont
//
void SetupFontDefs()
{
     static char lpAllKeys[KEY_SIZE], *lpKey;
     static char lpBuffer[KEY_SIZE], *lpValue;
     TCHAR szFontName[512];
     TCHAR szFontFilePath[MAX_PATH];

     DWORD dwFontNameLen;
     DWORD dwFontFilePathLen;


     BOOL bRetVal;

     int bWinFont, bTIFont;
     int nTIFont=0;
     font_data FAR *lpFont;
     char * lpFilename, *lpMatrix, *lpAngle, *lpStop;
     PS_QUERY_FONT_HANDLE psQuery;
     int iNumFonts;
     DWORD dwFontsAvail;
     DWORD i;


     if( PsBeginFontQuery( &psQuery ) != PS_QFONT_SUCCESS ) {

			PsReportInternalError( PSERR_ERROR | PSERR_ABORT,
         		                 PSERR_FONT_QUERY_PROBLEM,
                                0,
                                (LPBYTE) NULL );

     } 


     // The begin worked so lets query the fonts were gonna load

     // Now enumerate through all keys


       PsGetNumFontsAvailable( psQuery, &dwFontsAvail );

	   if ( dwFontsAvail == 0 ) {

			PsReportInternalError( PSERR_ERROR | PSERR_ABORT,
         		                   PSERR_FONT_QUERY_PROBLEM,
                                   0,
                                   (LPBYTE) NULL );
	   }

       for ( i=0; i<dwFontsAvail;i++ ) {


         dwFontNameLen = sizeof(szFontName);
         dwFontFilePathLen = sizeof( szFontFilePath);


         if (PsGetFontInfo( psQuery,
                            i,
                            szFontName,
                            &dwFontNameLen,
                            szFontFilePath,
                            &dwFontFilePathLen ) == PS_QFONT_SUCCESS ) {


             lpFont = &(built_in_font_tbl.fonts[nTIFont]);
             lpFont->name = PsStringAllocAndCopy( szFontName );


             lpFont->FileName = PsStringAllocAndCopy( szFontFilePath );
             lpFont->matrix = NULL_MATRIX;
             lpFont->italic_ang = (float)0.0;

             lpFont->uniqueid = nTIFont+TIFONT_UID;// avoid uniqueid being zero
             lpFont->font_type = (long)42;
             lpFont->orig_font_idx = -1;        // tmp solution
             lpFont->data_addr = (char FAR *) NULL;

             nTIFont ++;

             // Dont go over...
             if (nTIFont > MAX_INTERNAL_FONTS) {  //DJC

                PsReportInternalError( 0,
                                       PSERR_EXCEEDED_INTERNAL_FONT_LIMIT,
                                       0,
                                       (LPBYTE)NULL );

                break;  // DJC
             }
         }
       }

       // Were done with the query so get rid of the handle.
       PsEndFontQuery( psQuery );

     built_in_font_tbl.num_entries = nTIFont;

}




int bUsingWinFont()
{
//DJC   return GetPrivateProfileInt (szControlApp, "Winfont", 0, szProfile);
   // //DJC this version always uses fonts built in NOT windows FONTS
   return(FALSE);
}

#ifdef DJC  // Old code recode to use file mapping

char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot)
{
    static  char buf[BUFSIZE];
    int  hFd;            /* file handle */
    char FAR *lpGMem;
    font_data FAR *lpFont;
    static int nSlot=0;
    int i;
    DWORD dwLength;
    char szTemp[255];  //DJC

    /* special processing for win font */
    if (built_in_font_tbl.fonts[nFontDef].uniqueid >= WINFONT_UID) {
        static GLOBALHANDLE hGMem=NULL;

        if (!hGMem) {   /* just do once */
            //DJC if ((hFd = TTOpenFile((char FAR *)"cr.s"))<0) {
            PsFormFullPathToCfgDir( szTemp, "cr.s");

            if ((hFd = TTOpenFile(szTemp))<0) {
                printf("Fatal error: font file %s not found\n",
                                 //DJC "cr.s");
                                 szTemp);


                return (char FAR *)NULL;
            }
            /* Global allocate space */
            hGMem = GlobalAlloc (GPTR, (DWORD)FONTDATASIZE);
            lpGMem = GlobalLock (hGMem);
            // this global alloc should be freed after exit Trueimage ??? TBD

            /* Read in font data */
//          dp = lpGMem;
//          while(1) {
//              if ((ret = read (hFd, buf, BUFSIZE)) <= 0) break;
//              sp = buf;
//              while (ret-->0) *dp++ = *sp++;
//          }
            if ((dwLength = _llseek(hFd, 0L, 2)) >= 65534L) {
                _lclose (hFd);
                printf("Fatal error: font file %s too large\n",
                                 "cr.s");
                return (char FAR *)NULL;
            }
#ifdef DJC
            _llseek(hFd, 0L, 0);
            _lread(hFd, lpGMem, (WORD) dwLength);
#else
            {
                // DJC unused UINT uiAct;
                if ( _llseek(hFd, 0L, 0 ) == -1 ) {
                   printf("\nThe seek failed");
                }
                if (_lread(hFd,lpGMem, (UINT) dwLength) != dwLength) {
                   printf("\nThe font read failed");
                }
            }
#endif
            _lclose (hFd);
        } else {
            lpGMem = GlobalLock (hGMem);
        }
        return lpGMem;
    }

    /* Find a free slot */
    i = nSlot;
    while (ActiveFont[i].hGMem) {
        i = i< (ACT_FONT_SIZE-1) ? i+1 : 0;
        if (i == nSlot) {       // need to kick out this slot
            FreeFontData (i);
            break;
        }
    }
    *lpnSlot = nSlot = i;

    /* Open font file */
    lpFont = &(built_in_font_tbl.fonts[nFontDef]);
    //DJC if ((hFd = TTOpenFile(lpFont->FileName))<0) {
    //PsFormFullPathToCfgDir( szTemp, lpFont->FileName);

    //if ((hFd = TTOpenFile(szTemp))<0) {
    if ((hFd = TTOpenFile(lpFont->FileName)) < 0 ) {
        printf("Fatal error: font file %s not found\n",
                         lpFont->name);
                         //szTemp);
        return (char FAR *)NULL;
    }
#ifdef DJC
    /* Global allocate space */
    ActiveFont[nSlot].hGMem = GlobalAlloc (GPTR, (DWORD)FONTDATASIZE);
    lpGMem = GlobalLock (ActiveFont[nSlot].hGMem);
#endif
    /* Read in font data */
//  dp = lpGMem;
//  while(1) {
//      if ((ret = read (hFd, buf, BUFSIZE)) <= 0) break;
//      sp = buf;
//      while (ret-->0) *dp++ = *sp++;
//  }
#ifdef DJC
    if ((dwLength = _llseek(hFd, 0L, 2)) >= 65534L) {
	_lclose (hFd);
        printf("Fatal error: font file %s too large\n",
			 "cr.s");
        return (char FAR *)NULL;
    }
#else
    // in 32 bit world there is no segment limit. So first allocate
    // space for the fonts
    dwLength = _llseek( hFd, 0L, 2);

    ActiveFont[nSlot].hGMem = GlobalAlloc (GPTR, (DWORD)dwLength + 2);
    lpGMem = GlobalLock (ActiveFont[nSlot].hGMem);

#endif

#ifdef DJC
    _llseek(hFd, 0L, 0);
    _lread(hFd, lpGMem, (WORD) dwLength);
#else
    {
        // DJC unused UINT uiAct;
        if ( _llseek(hFd, 0L, 0 ) == -1 ) {
           printf("\nThe seek failed");
        }
        if (_lread(hFd,lpGMem, (UINT) dwLength) != dwLength) {
           printf("\nThe font read failed");
        }
    }

#endif

    _lclose (hFd);
    nSlot = nSlot< (ACT_FONT_SIZE-1) ? nSlot+1 : 0;     // next slot try
    return lpGMem;
}
#endif



void PsFormMappingNameFromFontName( LPTSTR lpMapName, LPTSTR lpFontName)
{
   // Very simple logic. Replace all spaces with nothing and tack
   // on a _PSTODIB on the end
   while (*lpFontName) {
      if (*lpFontName != ' ') {
         *lpMapName++ = *lpFontName;
      }
      lpFontName++;
   }
   *lpMapName = '\000';
   lstrcat( lpMapName, "_PSTODIB");
}



// DJC new ReadFontData code which implements file mapping
char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot)
{
    static  char buf[BUFSIZE];
    int  hFd;            /* file handle */
    char FAR *lpGMem= (char FAR *) NULL;
    font_data FAR *lpFont;
    static int nSlot=0;
    int i;
    DWORD dwLength;
    char szTemp[255];  //DJC

    /* special processing for win font */
    if (built_in_font_tbl.fonts[nFontDef].uniqueid >= WINFONT_UID) {
        printf("Fatal error, WINFONTS are not supported??");
        return( (char FAR *) NULL);
    }

    /* Find a free slot */

#ifdef DJC
    i = nSlot;
    while (ActiveFont[i].hGMem) {
        i = i< (ACT_FONT_SIZE-1) ? i+1 : 0;
        if (i == nSlot) {       // need to kick out this slot
            FreeFontData (i);
            break;
        }
    }
#else


    i = nFontDef;
#endif
    *lpnSlot = nSlot = i;

    /* Open font file */
    lpFont = &(built_in_font_tbl.fonts[nFontDef]);



    //DJC new code to implement file mapping instead of allocing memory
    //DJC and reading in.

    // 1st thing form

    {

        TCHAR szFontMapName[512];
        HANDLE hFile;
        HANDLE hMap;
        HANDLE hMapMutex;
        font_data FAR *lpFontEnum;
        int i;


        // Scan through the fonts we have defined as built in, look
        // for a font that had the same file name in which case we may
        // already have a mapping open, and dont need a new one
        // This is caused when we return both Arial and Helvetica to
        // the caller where only one data file services BOTH fonts
        //
#ifdef DJC
        for (i = 0, lpFontEnum=&(built_in_font_tbl.fonts[0]);
             i < built_in_font_tbl.num_entries;
             i++, lpFontEnum++ ) {

           if ((lstrcmpi( lpFont->FileName, lpFontEnum->FileName)  == 0 ) &&
               (lpFontEnum->data_addr != (char FAR *) NULL )) {

              // We have found a match, and the address of the match is
              // not 0 which means we have already set up a mapping for
              // this item, so lets save some memory and reuse it!!
              //
              lpGMem = lpFontEnum->data_addr;
              break;
           }
        }
#endif

        if (lpGMem == (char FAR *) NULL ) {


           // We have not already mapped this file so go ahead and set it up
           //
           PsFormMappingNameFromFontName( szFontMapName, lpFont->name);

           hMapMutex = CreateMutex( NULL, FALSE, "PSTODIB_FONT_MAP");

           WaitForSingleObject( hMapMutex, INFINITE);

           // Now go and try to open the mapping object
           hMap = OpenFileMapping( FILE_MAP_READ,FALSE, szFontMapName);


           // if the mapping failed then we need to create it
           if ( hMap == (HANDLE) NULL) {
              hFile = CreateFile( lpFont->FileName,
                                  GENERIC_READ,
                                  FILE_SHARE_READ,
                                  NULL,
                                  OPEN_EXISTING,
                                  0,
                                  NULL);

              if (hFile != (HANDLE)INVALID_HANDLE_VALUE) {
                 hMap = CreateFileMapping( hFile,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           szFontMapName);

              }

           }
           // At this point we have a handle to the mapping object
           // all that is left to do is convert it to a pointer

           lpGMem = (char FAR *) MapViewOfFile( hMap, FILE_MAP_READ, 0,0,0);
        }
        // Release and close the mutex
        ReleaseMutex( hMapMutex );
        CloseHandle( hMapMutex);



    }
    //DJC nSlot = nSlot< (ACT_FONT_SIZE-1) ? nSlot+1 : 0;     // next slot try
    return lpGMem;
}

void SetFontDataAttr(int nSlot, struct object_def FAR *font_dict)
{
    //DJC ActiveFont[nSlot].objFont = font_dict;
    //DJC get rid of this since SC used this in his font caching mechanism
    //    and we dont need it!

    //DJC FontDefs[nSlot].objFont = font_dict;  //DJC added
}
// DJC original version
#ifdef DJC
void FreeFontData (int nSlot)
{
     GLOBALHANDLE hGMem = ActiveFont[nSlot].hGMem;

     GlobalUnlock (hGMem);
     GlobalFree (hGMem);
     ActiveFont[nSlot].hGMem = NULL;

     /* Clear data addr of correspoding font dict */
     VALUE(ActiveFont[nSlot].objFont) = (unsigned long)NULL;
}
#endif

//DJC took out the stuff to free the memory because we now use
//    memory mapped files which dont actually consume any memory!
void FreeFontData (int nSlot)
{
     //DJC get rid of this stuff because SC used in his font caching
     //DJC mechanism and we dont need it


     //DJC ActiveFont[nSlot].hGMem = NULL;

     /* Clear data addr of correspoding font dict */
     //DJC VALUE(ActiveFont[nSlot].objFont) = (unsigned long)NULL;

     //DJC VALUE(FontDefs[nSlot].objFont) = (unsigned long)NULL; // DJC added
}




/* @PROFILE ---  End  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\wintt.h ===
// Short & long word swapping @WINFLOW
#define bSwap TRUE
#define SWORDSWAP(sw) \
        (   sw = bSwap ? (sw << 8) | (sw >> 8) : sw     )
#define LWORDSWAP(lw) \
        (   lw = bSwap ? (lw << 24) | (lw >> 24) | \
                 ((lw >> 8) & 0x0000ff00) | ((lw << 8) & 0x00ff0000) : lw )

#define TIFONT_UID   100
#define WINFONT_UID 1024

typedef struct {
     GLOBALHANDLE hGMem;
     short        nCount;
} ENUMER;

typedef struct {
     short        nFontType;
     LOGFONT      lf;
     NEWTEXTMETRIC   ntm;
} FONT;

int  FAR PASCAL EnumAllFaces (LPLOGFONT, LPNEWTEXTMETRIC, short, ENUMER FAR *);
int  FAR PASCAL EnumAllFonts (LPLOGFONT, LPNEWTEXTMETRIC, short, ENUMER FAR *);
void CheckFontData (void);
unsigned long ShowGlyph (unsigned int fuFormat,
     char FAR *lpBitmap);
void ShowABCWidths(UINT uFirstChar, UINT uLastChar);
void ShowOTM (void);
void ShowKerning(void);
void TTLoadFont (int nFont);
void TTLoadChar (int nChar);
int TTAveCharWidth (void);
float TTTransform (float FAR *ctm);
void TTBitmapSize (struct CharOut FAR *CharOut);
void TTCharPath(void);
int TTOpenFile(char FAR *szName);
void SetupFontDefs(void);
int bUsingWinFont(void);
char FAR * ReadFontData (int nFontDef, int FAR *lpnSlot);
void FreeFontData (int nSlot);
void SetFontDataAttr(int nFontDef, struct object_def FAR *font_dict);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\pstodib\ti\src\win\winenv.h ===
// DJC ... elminate these in the NT model
#if 0

#ifndef FAR
#ifdef W32
#define     FAR
#define     far
#define     HUGE
#define     huge
#else
#define     FAR far
#define     HUGE huge
#endif
#endif


#ifndef NEAR
#ifdef W32
#define NEAR
#define near
#else
#define NEAR                _near
#endif
#endif



#ifndef PASCAL
#ifdef W32
#define PASCAL
#define pascal
#else
#define PASCAL              pascal
#endif
#endif



#endif // DJC endif for eliminating type defines


/* string manipulation library; copied from "windows.h"; @WIN */
int         FAR PASCAL lstrncmp( LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lstrncpy( LPSTR dest, LPSTR src, int count);
int         FAR PASCAL lmemcmp(LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lmemcpy( LPSTR dest, LPSTR src, int count);
LPSTR       FAR PASCAL lmemset( LPSTR dest, int c, int count);




#ifndef HUGE
#ifdef W32
#define     HUGE
#define     huge
#else
#define     HUGE huge
#endif
#endif





#define WINENV


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\macps.h ===
//
// Copyright(c) Microsoft Corp., 1991, 1993
//
//
//	Macps.h -	Defines, type definitions, and function prototypes for the
//				MacPrint service of Windows NT Advanced Server
//
//  History:
//  Created for LAN Manager 2.1		Jameel Hyder @ Microsoft
//  modified for Windows NT			Frank Byrum @ Microsoft
//  Cleaned up						Jameel Hyder @ Microsoft
//

#include <winsock2.h>
#include <atalkwsh.h>

#ifndef _MACPS
#define _MACPS

#include <winspool.h>
#include <prtdefs.h>

// default string if string table not available - no need to localize

#define STATUS_MSG_ACTIVE		"Spooling to print server \"%s\" ..."
#define CLIENTNAME				"MAC_Client"


#define GENERIC_BUFFER_SIZE		1024
#define STACKSIZE				8192
#define PRINT_SHARE_CHECK_DEF	60000L
#define PS_EOF					4
#define FONTNAMELEN				49
#define FONTVERSIONLEN			7
#define FONTENCODINGLEN			9

// these strings are not localized - they are used for NBP browsing
#define LW_TYPE					"LaserWriter"
#define	DEF_ZONE				"*"
#define	NULL_STR				""
#define MACPRINT_NAME			L"MacPrint"
#define TOKLEN					255
#define PPDLEN					49
#define PSLEN					259
#define PENDLEN					PSLEN+1				// This needs to be 4*N

// ProcSet states
#define PROCSETMISSING			0
#define PROCSETPRESENT			1
#define PROCSETALMOSTPRESENT	2

// Registry Parameters - registry key names are not localized
#define HKEY_MACPRINT			L"SYSTEM\\CurrentControlSet\\Services\\MacPrint"
#define HKEY_PARAMETERS			L"Parameters"
#define HVAL_SHARECHECKINTERVAL	L"ShareCheckInterval"
#define HVAL_LOGFILE			L"LogFilePath"
#define HVAL_DUMPFILE			L"DumpFilePath"


#define MACSPOOL_MAX_EVENTS             2
#define MACSPOOL_EVENT_SERVICE_STOP     0
#define MACSPOOL_EVENT_PNP              1

typedef SOCKET * PSOCKET;

//	A FONT_RECORD structure will contain the information describing a font.
//	A list of these stuctures will be associated with each shared PostScript
//	printer.

typedef struct
{
	char		name[FONTNAMELEN+1];
	char		encoding[FONTENCODINGLEN+1];
	char		version[FONTVERSIONLEN+1];
} FONT_RECORD, *PFR;



//  A DICT_RECORD structure contains information describing a PostScript
//  dictionary.  It is used to determine what version of the Macintosh
//  LaserWriter driver was used to submit a job, as this structure is
//  filled in from information provided by ADSC comments in the print job.

#define DICTNAMELEN		17
#define DICTVERSIONLEN	7
#define DICTREVISIONLEN 7

typedef struct dict_record
{
	char		name[DICTNAMELEN+1];
	char		version[DICTVERSIONLEN+1];
	char		revision[DICTREVISIONLEN+1];
} DICT_RECORD, *PDR;

// A BUF_READ structure exists for each print job. All data that is read from
// a client is read here. PendingBuffer field is used to copy partial lines
// from previous I/O.  A pointer to this structure can be found in the job
// record

#define PAP_QUANTUM_SIZE		512
#define PAP_DEFAULT_QUANTUM		8
#define PAP_DEFAULT_BUFFER		(PAP_DEFAULT_QUANTUM*PAP_QUANTUM_SIZE)

typedef	struct
{
	BYTE	PendingBuffer[PENDLEN];		// Keep commands that span buffers here.
	BYTE	Buffer[PAP_DEFAULT_BUFFER]; // buffer for data Xfers
} BUF_READ, *PBR;


// A JOB_RECORD structure will exist for each job to be service by the
// queue service routine.  All job specific data can be found through
// this structure
typedef struct job_record
{
	struct queue_record	* job_pQr;	// owning print queue structure
	struct job_record  * NextJob;	// next job for this printer
	DWORD		dwFlags;			// Flags, what else ?
	HANDLE		hPrinter;			// NT Printer Handle for this job
	DWORD		dwJobId;			// NT Print Manager Job ID.
	SOCKET		sJob;				// socket for this job
	HDC			hicFontFamily;		// used for querying PostScript fonts
	HDC			hicFontFace;		// used for querying PostScript fonts
	DWORD		dwFlowQuantum;		// negotiated flow quantum
	DWORD		XferLen;			// Number of bytes in DataBuffer
	PBYTE		DataBuffer;			// Data buffer for xfer's
	PBR			bufPool;			// pool of two buffers
	DWORD		bufIndx;			// index into Buffer Pool
	int			cbRead;				// Bytes read in last read
	DWORD		PendingLen;			// Length of partial command stored in PendingBuffer
	USHORT		psJobState;			// Current state of the PostScript job.
	USHORT		JSState;			// Current PostScript Data Stream state.
	USHORT		SavedJSState;		// Saved PostScript Data Stream state.
	USHORT		InProgress;			// Flags for query state
    DWORD       EOFRecvdAt;         // Time when we recvd EOF from client
	BOOL		InBinaryOp;			// We are accepting Binary information.
	BOOL		FirstWrite;			// Set to True initially. Set to False after header is written
	BOOL		EOFRecvd;			// True, if EOF received, False otherwise
#if DBG
	DWORD		PapEventCount;		// Count of events
#endif
	BYTE		buffer[2*sizeof(BUF_READ)];
									// read data buffer
	WCHAR		pszUser[TOKLEN + 1];// username from DSC comment
	BYTE		JSKeyWord[TOKLEN+1];// Keyword being scanned for.
} JOB_RECORD, *PJR;


// once we get EOF, if we don't hear from the client for 60 seconds, assume done! (oti hack!)
#define OTI_EOF_LIMIT   60000
#define EXECUTE_OTI_HACK(_StartTime)    ( ((GetTickCount() - (_StartTime)) > OTI_EOF_LIMIT) ? \
                                            TRUE : FALSE )

//
// Job Record Defines
//

// dwFlags
#define JOB_FLAG_NULL				0x00000000
#define JOB_FLAG_TITLESET			0x00000001
#define JOB_FLAG_OWNERSET			0x00000002

// psJobState
#define psNullJob			0	// Not in a PostScript Job Structure (S0)
#define psQueryJob			1	// In a Query Job (S1)
#define psExitServerJob 	2	// In an Exit Server Job (S2)
#define psStandardJob		3	// In a Standard Job (S3)


// JSState
#define JSStrip				0	// Write nothing, scan for Structuring Comment
#define JSStripEOL			1	// Write nothing, scan for end of line, then restore state
#define JSStripKW			2	// Write nothing, scan for JSKeyword, then restore state
#define JSStripTok			3	// Write nothing, scan for next token, then restore state
#define JSWrite				4	// Write everything, scan for Structuring Comment
#define JSWriteEOL			5	// Write everything, scan for end of line, then restore state
#define JSWriteKW			6	// Write everything, scan for JSKeyword, then restore state
#define JSWriteTok			7	// Write everything, scan for next token, then restore state


// InProgress
#define NOTHING				0	// A scan is not currently in progress
#define QUERYDEFAULT		1	// Currently scanning for the default response to a query

#define RESOLUTIONBUFFLEN	9	// room for "xxxxxdpi"
#define COLORDEVICEBUFFLEN  6	// room for "False"

// A QUEUE_RECORD structure exists for each shared Windows NT local printer
// defined by the Windows NT Print Manager.  All relevant data specific to
// a Windows NT Printer is accessed through this data structure.  This
// structure also serves as the head of the list of jobs to service that
// are being spooled to this printer.
typedef struct	queue_record
{
	struct queue_record * pNext;		// Next queue in the list
	BOOL		bFound;					// TRUE if found in EnumPrinters list
	BOOL		SupportsBinary;			// True, if printer supports binary mode
	LPWSTR		pPrinterName;			// Print Manager printer name
	LPSTR		pMacPrinterName;		// Macintosh ANSI printer name
	LPWSTR		pDriverName;			// NT Printer driver
	LPWSTR		pPortName;				// NT Port name
	LPWSTR		pDataType;				// datatype used for jobs
	LPSTR		IdleStatus;				// "status: idle"
	LPSTR		SpoolingStatus;			// "status: Spooling to ......"
	PJR			PendingJobs;			// Pointer to the list of pending jobs.
	BOOL		ExitThread;				// Flag to Exit thread.
	HANDLE		hThread;				// handle to queue service thread
	PFR			fonts;					// array of fonts on this printer (PostScript only)
	DWORD		MaxFontIndex;			// max # fonts in fonts array
	SOCKET		sListener;				// listener socket for this printer
	DWORD		JobCount;				// Number of Jobs Outstanding.
	DWORD		FreeVM;					// Virtual memory available on printer
	CHAR		LanguageVersion[PPDLEN+1];// PPD LangaugeVersion, default: English
	CHAR		Product[PPDLEN+1];		// PPD Product name
	CHAR		Version[PPDLEN+1];		// PPD PostScript Version, Null = Unknown
	CHAR		Revision[PPDLEN+1];		// PPD Revision
	CHAR		DeviceNickName[PPDLEN+1];// Human readable device name
	CHAR		pszColorDevice[COLORDEVICEBUFFLEN];
	CHAR		pszResolution[RESOLUTIONBUFFLEN];
	CHAR		pszLanguageLevel[PPDLEN+1];
} QUEUE_RECORD, *PQR;


// pDataType
#define MACPS_DATATYPE_RAW		L"RAW"
#define MACPS_DATATYPE_PS2DIB	L"PSCRIPT1"

typedef struct _failed_cache
{
    struct _failed_cache    *Next;
    WCHAR                   PrinterName[1];
} FAIL_CACHE, *PFAIL_CACHE;

// Action codes for CheckFailCache
#define PSP_ADD                     1
#define PSP_DELETE                  2

// Return codes from CheckFailCache
#define PSP_OPERATION_SUCCESSFUL    0
#define PSP_OPERATION_FAILED        12
#define PSP_ALREADY_THERE           10
#define PSP_NOT_FOUND               11


BOOLEAN
PostPnpWatchEvent(
    VOID
);

BOOLEAN
HandlePnPEvent(
    VOID
);

// Function Prototypes for macpsq.c
void	ReportWin32Error (DWORD dwError);
void	QueueServiceThread(PQR pqr);
DWORD	HandleNewJob(PQR pqr);
DWORD	HandleRead(PJR pjr);
DWORD	CreateNewJob(PQR pqr);
void	RemoveJob(PJR pjr);
void	HandleNextPAPEvent(PQR pqr);
void	MoveJobAtEnd(PQR pqr, PJR pjr);
DWORD	CreateListenerSocket(PQR pqr);


// Function Prototypes for psp.c
BOOLEAN	SetDefaultPPDInfo(PQR pqr);
BOOLEAN	SetDefaultFonts(PQR pqr);
BOOLEAN	GetPPDInfo (PQR pqr);
int		LineLength(PBYTE pBuf, int cbBuf);
DWORD	WriteToSpool(PJR pjr, PBYTE pchbuf, int cchlen);
DWORD	MoveToPending(PJR pjr, PBYTE pchbuf, int cchlen);

DWORD	TellClient (PJR, BOOL, PBYTE, int);
DWORD	PSParse(PJR, PBYTE, int);

#define	PopJSState(Job)				Job->JSState = Job->SavedJSState
#define	PushJSState(Job, NewState)	\
		{	\
			Job->SavedJSState = Job->JSState; \
			Job->JSState = NewState;		  \
		}

// Function prototype for pspquery.c
DWORD	HandleEndFontListQuery(PJR);
DWORD	HandleEndQuery (PJR, PBYTE);
DWORD	FinishDefaultQuery (PJR, PBYTE);
void	FindDictVer(PDR DictQuery);
DWORD	HandleBQComment(PJR, PBYTE);
DWORD	HandleBeginProcSetQuery(PJR, PSZ);
DWORD	HandleBeginFontQuery(PJR, PSZ);
DWORD	HandleEndPrinterQuery(PJR);
void	HandleBeginXQuery(PJR, PSZ);
void	EnumeratePostScriptFonts(PJR pjr);
DWORD   CheckFailedCache(LPWSTR pPrinterName, DWORD dwAction);

int CALLBACK FamilyEnumCallback(
		LPENUMLOGFONT lpelf,
		LPNEWTEXTMETRIC pntm,
		int iFontType,
		LPARAM lParam);
int CALLBACK FontEnumCallback(
		LPENUMLOGFONT lpelf,
		LPNEWTEXTMETRIC pntm,
		int iFontType,
		LPARAM lParam);

//
// global data
//

extern	HANDLE			mutexQueueList;
extern	HANDLE			hevStopRequested;
#if DBG
extern	HANDLE			hDumpFile;
#endif
extern	HANDLE			hEventLog;
extern	SERVICE_STATUS	MacPrintStatus;

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\macps.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	Author: Frank D. Byrum
//		adapted from MacPrint for LAN Manager Services for Macintosh
//		which was adapted from the 3Com product
//
////////////////////////////////////////////////////////////////////////////////

/*
	File Name: MacPS.C

	General Description:

	This is the main module for the WNTSFM (Grimace) Print Service.
	The main routine is registered with the NT Service Controller by the
	Grimace Service Process, and is invoked when a SERVICE_START
	request is received for MacPrint.

	The routine immediately registers a service control handler
	to field service control requests from the NT Service
	Controller.  It then retreives configuration information
	from the registry and starts a thread for each configured
	print queue to manage the print jobs for the queue.

	Spooling is done by making each shared NT print queue appear
	as a LaserWriter on the AppleTalk network.  Each queue is
	shared by using AppleTalk PAP to register the queue on
	the AppleTalk network.  Once the queue name is published, a
	read driven loop is entered to support any connections/requests
	from AppleTalk clients.

	The flow of the Print Service threads is as follows:


	main ()
		NT Service Control dispatch thread for MacPrint.

	MacPrintMain()
		Registers a service control handler routine with
		the NT Service Controller.	If there is an error
		registering the handler, MacPrintMain logs a
		critical error message and returns.	This indicates
		to the NT Service Controller that MacPrint has
		stopped.

		Initializes per queue data structures based on
		information from the NT Registry.  For any queue
		that data structures cannot be initialized, a
		warning message is logged, and the control thread
		for that queue is not started.

		Spawns a thread for each queue that handles print
		jobs for that queue

		Enters a loop on a flag that is changed when a
		service stop request is received. This loop traverses
		the list of queues to see if they are still shared
		by NT and enumerates the list of shared queues to
		see if any new queues need to be published on
		the AppleTalk network.

	Each service thread:

		Each service thread supports a single print queue
		on the AppleTalk network.

		It publishes the NBP name of the printer on the
		AppleTalk network to allow Macintosh clients to
		see the print queue from the Chooser.

		It posts an ATalkPAPGetNextJob request to service
		a print request.  This allows Macintosh clients to
		connect to the print queue.

		It enters a service loop and remains there until
		the service is stopped, or that particular queue
		is 'unshared' by the NT Print Manager.	This service
		loop handles all states of a print job (OPEN, READ,
		WRITE, CLOSE), and transfers data for the print job
		to the NT Print Manager.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <winsvc.h>
#include <winspool.h>

#include <macps.h>
#include <macpsmsg.h>
#include <debug.h>

#define PRINTER_ENUM_BUFFER_SIZE	1024
#define	MACPRINT_WAIT_HINT			25*60000	// 25 minutes

BOOL	fLocalSystem;

SERVICE_STATUS			MacPrintStatus;
/*  MacPrintStatus is the global service status structure.  It is
	read by multiple threads and written ONLY by the service control
	handler (it is initialized by MacPrintMain before the service
	control handler is started)		*/

SERVICE_STATUS_HANDLE	hMacPrintService;
/*  hMacPrintService is the handle to the MacPrint service used in
	calls to SetServiceStatus to change the state of the MacPrint
	service.  It is initialized when the service control handler is
	created by MacPrintMain(), and is used only by MacPrintHandler()  */

#if DBG
HANDLE	hDumpFile = INVALID_HANDLE_VALUE;
#endif
HANDLE	hLogFile = INVALID_HANDLE_VALUE;

HANDLE	hEventLog = NULL;
ULONG	ShareCheckInterval;	// number of miliseconds between polls of the NT Print Manager
							// to update our queue list
HANDLE	mutexQueueList;		// provide mutual exclusion to the linked list of active queues
							// need to change to be a critical section
HANDLE  mutexFlCache;      // mutual exclusion for the failCache queue
HANDLE	hevStopRequested;	// event that is signalled when a stop request is received from
							// the service controller. The main thread that dispatches queue
							// threads waits on this event (with a timeout) to signal all
							// queue threads to die.
HANDLE  hevPnpWatch = NULL;
SOCKET  sPnPSocket = INVALID_SOCKET;
BOOLEAN fNetworkUp = FALSE;

PQR	 pqrHead = NULL;
PFAIL_CACHE FlCacheHead = NULL;

//
// Function Prototypes for MacPS.c
//
VOID	MacPrintMain(DWORD dwNumServicesArgs, LPTSTR * lpServiceArgs);
VOID	UpdateQueueInfo(PQR * ppqrHead);
VOID	MacPrintHandler(IN DWORD dwControl);
BOOLEAN	PScriptQInit(PQR pqr, LPPRINTER_INFO_2 pPrinter);
PQR		FindPrinter(LPPRINTER_INFO_2 pSearch, PQR pqrHead);
void	ReadRegistryParameters(void);
#define	IsRemote(pPrinter)	(((pPrinter)->Attributes & PRINTER_ATTRIBUTE_NETWORK) ? TRUE : FALSE)

/*  main()

	Purpose:
	This is the service control dispatcher thread.	It connects
	to the NT Service Controller and provides the mechanism to
	start the MacPrint service.

	Entry:
	Standard C arguments that are ignored

	Exit:
	Exits on service stop with return of 0
*/

__cdecl
main(
	int		argc,
	char **	argv
)
{

	SERVICE_TABLE_ENTRY		 ServiceTable[2];

	/* initialize the service table for MacPrint */
	ServiceTable[0].lpServiceName = MACPRINT_NAME;
	ServiceTable[0].lpServiceProc = &MacPrintMain;
	ServiceTable[1].lpServiceName = NULL;
	ServiceTable[1].lpServiceProc = NULL;

	StartServiceCtrlDispatcher(ServiceTable);

	return(0);
}


/*  MacPrintMain()

	Purpose:

	This is the 'service main function' described in the NT
	Service Control model, and it is invoked by the Service
	Control Dispatcher for the MacPrint service.  It initializes
	data structures for the MacPrint service, registers a service
	control handler, and dispatches threads to support print
	queues shared on the AppleTalk network.

	Entry:

	dwNumServiceArgs: undefined
	lpServiceArgs: undefined

	The main function implements the standard service main function
	interface, but uses no arguments.  The standard arguments are
	ignored.

	Exit:

	The routine returns no argument.  It terminates when the MacPrint
	service stops.
*/

#define ALLOCATED_QUEUE_MUTEX		0x00000001
#define ALLOCATED_SERVICE_STARTED	0x00000002
#define ALLOCATED_STOP_EVENT		0x00000004

VOID
MacPrintMain(
	DWORD		dwNumServicesArgs,
	LPTSTR *	lpServiceArgs
)
{
	DWORD	fAllocated = 0;
	PQR		pqr = NULL;
	DWORD	dwError;
	WSADATA WsaData;
	DWORD	cbSizeNeeded;
	HANDLE	hProcessToken = INVALID_HANDLE_VALUE;
	SID		LocalSystemSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID };
	BYTE 	TokenUserBuffer[100];
    PFAIL_CACHE pFlCache, nextFlCache;
    BOOLEAN fWatchingPnP = FALSE;
    HANDLE  EventsArray[MACSPOOL_MAX_EVENTS];
    DWORD   dwNumEventsToWatch=0;
    DWORD   dwWaitTime;
    DWORD   index;

	TOKEN_USER * pTokenUser  = (TOKEN_USER *)TokenUserBuffer;

	do
	{
		//
		// prepare the event log.  If it doesn't register, there is nothing
		// we can do anyway.  All calls to ReportEvent will be with a NULL
		// handle and will probably fail.
		//
		hEventLog = RegisterEventSource(NULL, MACPRINT_EVENT_SOURCE);

		//
		// Initialize global data
		//
		ReadRegistryParameters();

		if ((hevStopRequested = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: unable to create stop request event, error = %d\n", dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}
		else
		{
			fAllocated |= ALLOCATED_STOP_EVENT;
		}

		if ((hevPnpWatch = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: unable to create PnP event, error = %d\n", dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		if ((mutexQueueList = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: Unable to create queue mutex object, error = %d\n",
					dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}
		else
		{
			fAllocated |= ALLOCATED_QUEUE_MUTEX;
		}

		if ((mutexFlCache = CreateMutex(NULL, FALSE, NULL)) == NULL)
		{
			dwError = GetLastError();
			DBGPRINT(("ERROR: Unable to create FailCache mutex object, error = %d\n",
					dwError));

			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_RESOURCES,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		DBGPRINT(("\nMacPrint starting\n"));

		//
		// initialize Windows Sockets
		//
		if (WSAStartup(0x0101, &WsaData) == SOCKET_ERROR)
		{
			dwError = GetLastError();
			DBGPRINT(("WSAStartup fails with %d\n", dwError));
			break;
		}

		//
		//	register service control handler
		//
		MacPrintStatus.dwServiceType = SERVICE_WIN32;
		MacPrintStatus.dwCurrentState = SERVICE_START_PENDING;
		MacPrintStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
		MacPrintStatus.dwWin32ExitCode = NO_ERROR;
		MacPrintStatus.dwServiceSpecificExitCode = NO_ERROR;
		MacPrintStatus.dwCheckPoint = 1;
		MacPrintStatus.dwWaitHint = MACPRINT_WAIT_HINT;

		hMacPrintService = RegisterServiceCtrlHandler(MACPRINT_NAME,&MacPrintHandler);

		if (hMacPrintService == (SERVICE_STATUS_HANDLE) 0)
		{

			dwError = GetLastError();
			DBGPRINT(("ERROR: failed to register service control handler, error=%d\n",dwError));
			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_CONTROLLER_ERROR,
						NULL,
						0,
						sizeof(DWORD),
						NULL,
						&dwError);
			break;
		}

		//
		// Determine if we are running in LocalSystem context
		//
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		{
			dwError = GetLastError();

			DBGPRINT(("MacPrintMain: OpenProcessToken returns %d\n", dwError));

			if (dwError == ERROR_ACCESS_DENIED)
				 fLocalSystem = FALSE;
			else break;
		}

		if (!GetTokenInformation(hProcessToken,
								 TokenUser,
								 pTokenUser,
								 sizeof(TokenUserBuffer),
								 &cbSizeNeeded))
		{
			dwError = GetLastError();

			DBGPRINT(("MacPrintMain:GetTokenInformation returns%d\n",dwError));

			if (dwError == ERROR_INSUFFICIENT_BUFFER)
				 fLocalSystem = FALSE;
			else break;
		}
		else
		{
			fLocalSystem = EqualSid(pTokenUser->User.Sid, &LocalSystemSid);
		}

		DBGPRINT(("MacPrintMain:fLocalSystem %d\n", fLocalSystem));

		// Create a security object. This is really just a security descriptor
		// is self-relative form. This procedure will allocate memory for this
		// security descriptor and copy all in the information passed in. This

		DBGPRINT(("MacPrintMain: registered service control handler\n"));

		//
		// show service started
		//

		MacPrintStatus.dwCurrentState = SERVICE_RUNNING;
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to change state.  err = %d\n", GetLastError()));
			break;
		}

		DBGPRINT(("changed to SERVICE_RUNNING\n"));
		fAllocated |= ALLOCATED_SERVICE_STARTED;
#if 0
		ReportEvent(hEventLog,
					EVENTLOG_INFORMATION_TYPE,
					EVENT_CATEGORY_ADMIN,
					EVENT_SERVICE_STARTED,
					NULL,
					0,
					0,
					NULL,
					NULL);
#endif

        EventsArray[MACSPOOL_EVENT_SERVICE_STOP] = hevStopRequested;
        EventsArray[MACSPOOL_EVENT_PNP] = hevPnpWatch;

		// poll print manager for install/removal of printer objects
		while (MacPrintStatus.dwCurrentState == SERVICE_RUNNING)
		{
            if (!fNetworkUp)
            {
                dwNumEventsToWatch = 1;

                fWatchingPnP = PostPnpWatchEvent();

                if (fWatchingPnP)
                {
                    dwNumEventsToWatch = 2;
                }
            }

            //
            // If network is available, publish all printers
            //
            if (fNetworkUp)
            {
			    UpdateQueueInfo(&pqrHead);
                dwWaitTime = ShareCheckInterval;
            }

            // looks like network is still not available: try after 10 seconds
            else
            {
                dwWaitTime = 10000;
            }

            //
            // "sleep" for the specified event.  During that time, watch for
            // PnP event or the service stopping
            //
            index = WaitForMultipleObjectsEx(dwNumEventsToWatch,
                                             EventsArray,
                                             FALSE,
                                             dwWaitTime,
                                             FALSE);

            if (index == MACSPOOL_EVENT_PNP)
            {
                HandlePnPEvent();
            }

		}
	} while (FALSE);

	//
	//	wait for all worker threads to die
	//

	if (fAllocated & ALLOCATED_QUEUE_MUTEX)
	{
		while (pqrHead != NULL)
		{
			MacPrintStatus.dwCheckPoint++;
			SetServiceStatus(hMacPrintService, &MacPrintStatus);
			Sleep(100);
		}
		CloseHandle(mutexQueueList);
	}


    // if there were any entries in the failed cache, free them now
    for ( pFlCache=FlCacheHead; pFlCache != NULL; pFlCache = nextFlCache )
    {
        nextFlCache = pFlCache->Next;
        LocalFree( pFlCache );
    }

    if (mutexFlCache != NULL)
    {
        CloseHandle(mutexFlCache);
    }

    if (sPnPSocket != INVALID_SOCKET)
    {
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
    }

    if (hevPnpWatch)
    {
		CloseHandle(hevPnpWatch);
    }

	//
	// disconnect from Windows Sockets
	//

	WSACleanup();

	//
	//	change service state to stopped
	//

	MacPrintStatus.dwCurrentState = SERVICE_STOPPED;

	if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
	{
		DBGPRINT(("ERROR: unable to change status to SERVICE_STOPPED.%d\n",
		GetLastError()));
	}
	else
	{
		DBGPRINT(("changed state to SERVICE_STOPPED\n"));
#if 0
		ReportEvent(hEventLog,
					EVENTLOG_INFORMATION_TYPE,
					EVENT_CATEGORY_ADMIN,
					EVENT_SERVICE_STOPPED,
					NULL,
					0,
					0,
					NULL,
					NULL);
#endif
	}

	if (hProcessToken != INVALID_HANDLE_VALUE)
		CloseHandle(hProcessToken);


	if (fAllocated & ALLOCATED_STOP_EVENT)
	{
		CloseHandle(hevStopRequested);
	}

	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLogFile);
	}

#if DBG
	if (hDumpFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hDumpFile);
	}
#endif
}


BOOLEAN
PostPnpWatchEvent(
    VOID
)
{

    SOCKADDR_AT address;
    DWORD       dwResult;
    DWORD       dwByteCount;



    //
    // we must always start with a "fresh" socket!
    //
    if (sPnPSocket != INVALID_SOCKET)
    {
        DBGPRINT(("SFMPRINT: sPnPSocket wasn't closed!! Closing now\n"));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
    }

    sPnPSocket = socket(AF_APPLETALK, SOCK_RDM, ATPROTO_PAP);
    if (sPnPSocket == INVALID_SOCKET)
    {
        DBGPRINT(("PostPnpWatchEvent: socket failed %d\n",GetLastError()));
        return(FALSE);
    }

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    if (bind(sPnPSocket, (PSOCKADDR) &address, sizeof(address)) == SOCKET_ERROR)
    {
        DBGPRINT(("PostPnpWatchEvent: bind failed %d\n",GetLastError()));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
        return(FALSE);
    }

    if (WSAEventSelect(sPnPSocket,
                       hevPnpWatch,
                       (FD_READ | FD_ADDRESS_LIST_CHANGE)) == SOCKET_ERROR)
    {
        DBGPRINT(("PostPnpWatchEvent: WSAEventSelect failed %d\n",GetLastError()));
        closesocket(sPnPSocket);
        sPnPSocket = INVALID_SOCKET;
        return(FALSE);
    }

    dwResult = WSAIoctl(sPnPSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL,
                        0,
                        NULL,
                        0,
                        &dwByteCount,
                        NULL,
                        NULL);

    if (dwResult == SOCKET_ERROR)
    {
        dwResult = GetLastError();

        if (dwResult != WSAEWOULDBLOCK)
        {
            DBGPRINT(("PostPnpWatchEvent: WSAIoctl failed %d\n",dwResult));
            closesocket(sPnPSocket);
            sPnPSocket = INVALID_SOCKET;
            return(FALSE);
        }
    }

    fNetworkUp = TRUE;

    return(TRUE);
}


BOOLEAN
HandlePnPEvent(
    VOID
)
{

    DWORD               dwErr;
    WSANETWORKEVENTS    NetworkEvents;


    dwErr = WSAEnumNetworkEvents(sPnPSocket, hevPnpWatch, &NetworkEvents);

    if (dwErr != NO_ERROR)
    {
        DBGPRINT(("HandlePnPEvent: WSAEnumNetworkEvents failed %d\n",dwErr));
        return(fNetworkUp);
    }

    if (NetworkEvents.lNetworkEvents & FD_ADDRESS_LIST_CHANGE)
    {
        dwErr = NetworkEvents.iErrorCode[FD_ADDRESS_LIST_CHANGE_BIT];

        if (dwErr != NO_ERROR)
        {
            DBGPRINT(("HandlePnPEvent: iErrorCode is %d\n",dwErr));
            return(fNetworkUp);
        }
    }

    if (fNetworkUp)
    {
        SetEvent(hevStopRequested);

        // sleep till all the threads quit
	    while (pqrHead != NULL)
	    {
			Sleep(500);
		}

        ResetEvent(hevStopRequested);

        fNetworkUp = FALSE;
    }

    return(fNetworkUp);

}





////////////////////////////////////////////////////////////////////////////////
// 	ReadRegistryParameters()
//
//  DESCRIPTION:  This routine reads all configuration parameters from
//		the registry and modifies global variables to make those parameters
//		available to the rest of the service.  They include:
//
//			ShareCheckInterval
//			hLogFile
//			hDumpFile
////////////////////////////////////////////////////////////////////////////////
void
ReadRegistryParameters(
	void
)
{
	HKEY	hkeyMacPrintRoot = INVALID_HANDLE_VALUE;
	HKEY	hkeyParameters = INVALID_HANDLE_VALUE;
	LONG	Status;
	DWORD	cbShareCheckInterval = sizeof(DWORD);
	LPWSTR	pszLogPath = NULL;
	DWORD	cbLogPath = 0;
	LPWSTR	pszDumpPath = NULL;
	DWORD	cbDumpPath = 0;
	DWORD	dwValueType;
	DWORD	dwError;

	//
	// resource allocation 'loop'
	//

	do
	{
		//
		// initialize to defaults
		//

		ShareCheckInterval = PRINT_SHARE_CHECK_DEF;
#if DBG
#ifndef _WIN64
		hLogFile = (HANDLE)STD_OUTPUT_HANDLE;
#endif
		hDumpFile = INVALID_HANDLE_VALUE;
#endif

		//
		// Open the service control key
		//

		if ((Status = RegOpenKeyEx(
				HKEY_LOCAL_MACHINE,
				HKEY_MACPRINT,
				0,
				KEY_READ,
				&hkeyMacPrintRoot)) != ERROR_SUCCESS)
			{

			dwError = GetLastError();
			if (dwError == ERROR_ACCESS_DENIED)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ACCESS_DENIED,
							NULL,
							0,
							0,
							NULL,
							NULL);

			}
			else
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ERROR,
							NULL,
							0,
							sizeof(DWORD),
							NULL,
							&dwError);
			}

			hkeyMacPrintRoot = INVALID_HANDLE_VALUE;
			break;
		}

		//
		// Open the parameters key
		//

		if ((Status = RegOpenKeyEx(
				hkeyMacPrintRoot,
				HKEY_PARAMETERS,
				0,
				KEY_READ,
				&hkeyParameters)) != ERROR_SUCCESS)
			{

			dwError = GetLastError();

			if (dwError == ERROR_ACCESS_DENIED)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_REGISTRY_ACCESS_DENIED,
							NULL,
							0,
							0,
							NULL,
							NULL);
			}

			hkeyParameters = INVALID_HANDLE_VALUE;
			break;
		}

		//
		// get the share check interval
		//

		RegQueryValueEx(
				hkeyParameters,
				HVAL_SHARECHECKINTERVAL,
				NULL,
				&dwValueType,
				(LPBYTE) &ShareCheckInterval,
				&cbShareCheckInterval);

#if DBG
		//
		// get the log file path
		//

		RegQueryValueEx(hkeyParameters,
				HVAL_LOGFILE,
				NULL,
				&dwValueType,
				(LPBYTE) pszLogPath,
				&cbLogPath);
		if (cbLogPath > 0)
		{
			// cbLogPath is really a count of characters
			pszLogPath = (LPWSTR)LocalAlloc(LPTR, (cbLogPath + 1) * sizeof(WCHAR));
			if (pszLogPath == NULL)
			{
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				break;
			}
		}


		if ((Status = RegQueryValueEx(hkeyParameters,
									HVAL_LOGFILE,
									NULL,
									&dwValueType,
									(LPBYTE) pszLogPath,
									&cbLogPath)) == ERROR_SUCCESS)
		{
			//
			// open the log file
			//

			hLogFile = CreateFile(pszLogPath,
								GENERIC_WRITE,
								FILE_SHARE_READ,
								NULL,
								CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
								NULL);

			if (hLogFile == INVALID_HANDLE_VALUE)
			{
				dwError = GetLastError();
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_CREATE_FILE_ERROR,
							NULL,
							1,
							sizeof(DWORD),
							&pszLogPath,
							&dwError);
			}
			else
			{
				ReportEvent(hEventLog,
							EVENTLOG_INFORMATION_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_CREATE_LOG_FILE,
							NULL,
							1,
							0,
							&pszLogPath,
							NULL);
			}

		}
		else
		{
			hLogFile = INVALID_HANDLE_VALUE;
		}


		DBGPRINT(("MACPRINT LOG FLE OPENED\n\n"));

		//
		// get the dump file path
		//

		RegQueryValueEx(hkeyParameters,
						HVAL_DUMPFILE,
						NULL,
						&dwValueType,
						(LPBYTE) pszDumpPath,
						&cbDumpPath);

		if (cbDumpPath > 0)
		{
			// cbDumpPath is really a count of characters
			pszDumpPath = (LPWSTR)LocalAlloc(LPTR, (cbDumpPath + 1) * sizeof(WCHAR));
			if (pszDumpPath == NULL)
			{
				DBGPRINT(("ERROR: cannot allocate buffer for dump file path\n"));
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				break;
			}
		}

		if ((Status = RegQueryValueEx(hkeyParameters,
									HVAL_DUMPFILE,
									NULL,
									&dwValueType,
									(LPBYTE) pszDumpPath,
									&cbDumpPath)) != ERROR_SUCCESS)
		{
			DBGPRINT(("ERROR: no dump path, rc = 0x%lx\n", Status));
		}
		else
		{
			//
			// open the dump file
			//

			hDumpFile = CreateFile(pszDumpPath,
									GENERIC_WRITE,
									FILE_SHARE_READ,
									NULL,
									CREATE_ALWAYS,
									FILE_ATTRIBUTE_NORMAL,
									NULL);
		}
#endif
	} while (FALSE);

	//
	// resource cleanup
	//

	if (hkeyParameters != INVALID_HANDLE_VALUE)
	{
		RegCloseKey(hkeyParameters);
	}

	if (hkeyMacPrintRoot != INVALID_HANDLE_VALUE)
	{
		RegCloseKey(hkeyMacPrintRoot);
	}

#if DBG
	if (pszLogPath != NULL)
	{
		LocalFree (pszLogPath);
	}

	if (pszDumpPath != NULL)
	{
		LocalFree (pszDumpPath);
	}
#endif
}


////////////////////////////////////////////////////////////////////////////////
// 	FindPrinter() - locate a printer in our list of printers
//
//  DESCRIPTION:
//
//		Given an NT printer information structure and a pointer to the head of
//		a list of our printer structures, this routine will return a pointer
//		to our printer structure that corresponds to the printer described by
//		the NT printer information structure.  If no such printer is found in
//		our list, this routine returns NULL.
//
////////////////////////////////////////////////////////////////////////////////
PQR
FindPrinter(
	LPPRINTER_INFO_2	pSearch,
	PQR 				pqrHead
)
{
	PQR status = NULL;
	PQR pqrCurrent;

	for (pqrCurrent = pqrHead; pqrCurrent != NULL; pqrCurrent = pqrCurrent->pNext)
	{
		if (_wcsicmp(pSearch->pPrinterName, pqrCurrent->pPrinterName) == 0)
		{
			return (pqrCurrent);
		}
	}
	return (NULL);
}


////////////////////////////////////////////////////////////////////////////////
//
//	UpdateQueueInfo() - get new list of printers from NT
//
//	DESCRIPTION:
//		This routine is called periodically to see if any new NT Printer Objects
//		have been created or if any old ones have been destroyed since the last
//		time this routine was called.  For each new printer object discovered,
//		a thread is started to manage that printer object.  For each printer object
//		destroyed, the thread corresponding to that printer object is signalled
//		to quit.
//
//		This routine takes a pointer to the head of a list of printers and
//		makes certain that the list corresponds to the set of currently
//		defined NT Printer Objects.
//
////////////////////////////////////////////////////////////////////////////////
#define ALLOCATED_RELEASE_MUTEX	 0x00000001
#define ALLOCATED_ENUM_BUFFER	0x00000002

VOID
UpdateQueueInfo(
	PQR *	ppqrHead
)
{
	DWORD		fAllocated = 0;
	PQR			pqrCurrent;
	PQR			pqrTemp;
	DWORD		i;
	DWORD		dwThreadId;
	DWORD		cbNeeded = 0;
	DWORD		cPrinters = 0;
	LPBYTE		pPrinters = NULL;
	LPPRINTER_INFO_2	pinfo2Printer;
	HANDLE		ahWaitList[MAXIMUM_WAIT_OBJECTS];
	DWORD		dwReturn;
	DWORD		dwError;
	BOOLEAN		boolEnumOK = TRUE;

	// DBGPRINT(("Entering UpdateQueueInfo\n"));

	do
	{
		//
		//	take the QueueList mutex
		//

		if (WaitForSingleObject(mutexQueueList, INFINITE) == 0)
		{
			fAllocated |= ALLOCATED_RELEASE_MUTEX;
			// DBGPRINT(("UpdateQueueInfo takes mutexQueueList\n"));
		}
		else
		{
			//
			// fatal error - log a message and stop the service
			//

			DBGPRINT(("ERROR: problem waiting for queue list mutex, error = %d\n",  GetLastError()));
			dwReturn = 0;
			break;
		}

		//
		//	Mark all the queues NOT FOUND
		//

		for (pqrCurrent = *ppqrHead;
			 pqrCurrent != NULL;
			 pqrCurrent = pqrCurrent->pNext)
		{
			pqrCurrent->bFound = FALSE;
		}

		// DBGPRINT(("queues marked not found\n"));

		//
		//	Enumerate the local printers
		//

		cPrinters = 0;
		if ((pPrinters = (LPBYTE)LocalAlloc(LPTR, PRINTER_ENUM_BUFFER_SIZE)) != NULL)
		{
			fAllocated |= ALLOCATED_ENUM_BUFFER;
		}
		else
		{
			//
			// out of resources - let service continue running
			//

			DBGPRINT(("ERROR: unable to allocated buffer for printer enum.  error = %d\n", GetLastError()));
			ReportEvent(hEventLog,
						EVENTLOG_ERROR_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SERVICE_OUT_OF_MEMORY,
						NULL,
						0,
						0,
						NULL,
						NULL);
			dwReturn = 1;
			break;
		}

		dwReturn = 0;
		cbNeeded = PRINTER_ENUM_BUFFER_SIZE;

		while (!EnumPrinters(PRINTER_ENUM_SHARED | PRINTER_ENUM_LOCAL,
							NULL,
							2,
							pPrinters,
							cbNeeded,
							&cbNeeded,
							&cPrinters))
		{
			//
			// enum failed - allocate more data if we need it, or fail
			//

			if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
			{
				//
				// the NT spooler is probably dead - stop the service
				//
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SPOOLER_NOT_RESPONDING,
							NULL,
							0,
							sizeof(DWORD),
							NULL,
							&dwError);

				DBGPRINT (("ERROR:  Unable to enumerate printers, error = %d\n",dwError));
				boolEnumOK = FALSE;
				dwReturn = 0;
				break;
			}

			//
			// allocate a larger buffer
			//

			LocalFree(pPrinters);
			cPrinters = 0;
			if ((pPrinters = (LPBYTE)LocalAlloc(LPTR, cbNeeded)) == NULL)
			{
				//
				// out of resources, see if service will continue to run
				//

				fAllocated &= ~ALLOCATED_ENUM_BUFFER;
				dwError = GetLastError();
				DBGPRINT(("ERROR: unable to reallocate printer enum buffer, error = %d\n",dwError));
				ReportEvent(hEventLog,
							EVENTLOG_ERROR_TYPE,
							EVENT_CATEGORY_INTERNAL,
							EVENT_SERVICE_OUT_OF_MEMORY,
							NULL,
							0,
							0,
							NULL,
							NULL);
				boolEnumOK = FALSE;
				dwReturn = 1;
				break;
			}
		}

		if (!boolEnumOK)
		{
			break;
		}

		// DBGPRINT(("%d printers enumerated\n", cPrinters));

		//
		//	For each LOCAL_PRINTER, attempt to find it in the
		//	queue list and change its status to FOUND.	If it
		//	can't be found in the list that add it and start
		//	a service thread for it
		//
		dwReturn = 1;
		for (i = 0, pinfo2Printer = (LPPRINTER_INFO_2)pPrinters;
			 i < cPrinters;
			 i++, pinfo2Printer++)
		{
			//
			// do not count pending_deletion printers as found
			//

            if (MacPrintStatus.dwCurrentState != SERVICE_RUNNING)
            {
                DBGPRINT(("Service stopping: quitting UpdateQueueInfo\n"));
                break;
            }

			if (pinfo2Printer->Status & PRINTER_STATUS_PENDING_DELETION)
				continue;

			pqrCurrent = FindPrinter(pinfo2Printer,*ppqrHead);

			if ((pqrCurrent != NULL) &&
				(_wcsicmp(pqrCurrent->pDriverName, pinfo2Printer->pDriverName) == 0))
			{
				//
				// printer already going, mark it found
				//

				pqrCurrent->bFound = TRUE;
			}
			else
			{
				//
				// start a new thread, but first make sure we are still running
				//

				DBGPRINT(("Discovered new printer, starting thread\n"));

				//
				// allocate a new queue record
				//

				if ((pqrCurrent = (PQR)LocalAlloc(LPTR, sizeof(QUEUE_RECORD))) == NULL)
				{
					//
					// out of memory, but can still enumerate printers, so don't stop
					// the service, just quit
					//

					DBGPRINT(("ERROR: cannont allocate queue record, error = %d\n", GetLastError()));
					ReportEvent(hEventLog,
								EVENTLOG_ERROR_TYPE,
								EVENT_CATEGORY_INTERNAL,
								EVENT_SERVICE_OUT_OF_MEMORY,
								NULL,
								0,
								0,
								NULL,
								NULL);
					dwReturn = 1;
					break;
				}

				//
				// initialize it
				//
				if (!PScriptQInit(pqrCurrent, pinfo2Printer))
				{
					LocalFree (pqrCurrent);
					continue;
				}

				//
				// add it to the head of the list
				//

				pqrCurrent->pNext = *ppqrHead;
				*ppqrHead = pqrCurrent;

				//
				// start a service thread for the queue
				//

				if ((pqrCurrent->hThread = CreateThread(NULL,
														STACKSIZE,
														(LPTHREAD_START_ROUTINE)QueueServiceThread,
														(LPVOID)pqrCurrent,
														0,
														&dwThreadId)) == 0)
				{
					DBGPRINT(("ERROR: unable to start thread routine for %ws\n", pqrCurrent->pPrinterName));
					dwError = GetLastError();
					ReportEvent(hEventLog,
								EVENTLOG_ERROR_TYPE,
								EVENT_CATEGORY_INTERNAL,
								EVENT_SERVICE_OUT_OF_RESOURCES,
								NULL,
								0,
								sizeof(DWORD),
								NULL,
								&dwError);

					*ppqrHead = pqrCurrent->pNext;
					// BUG BUG - memory leak (pqrCurrent->pszXXXX) if can't start threads.
					LocalFree(pqrCurrent);
				} // end of CreateThread()
			} //end of discovering a new printer
		} // loop walking list of printers

		//
		//	Walk the list of queues for NOT_FOUND ones and signal
		//	the service thread for that queue to terminate.  Each
		//	thread will remove itself from the queue list and free
		//	its own queue entry.
		//

		// DBGPRINT(("removing lost printers\n"));
		pqrCurrent = *ppqrHead;
		i = 0;
		while (pqrCurrent != NULL)
		{
			//
			// get the address of the next queue record and signal this
			// queue record to terminate if necessary.  Must save the
			// address before requesting termination as once ExitThread
			// is set to TRUE, the data structure is no longer accessible
			// (the queue thread could free it)
			//
			pqrTemp = pqrCurrent->pNext;
			if (!pqrCurrent->bFound)
			{
                // terminate the thread
				DBGPRINT(("signalling %ws to terminate\n", pqrCurrent->pPrinterName));
				ahWaitList[i++] = pqrCurrent->hThread;
				pqrCurrent->ExitThread = TRUE;
			}

			pqrCurrent = pqrTemp;

			if (i==MAXIMUM_WAIT_OBJECTS)
			{
				//
				//	release the queue mutex so that threads can remove
				//	themselves from the queue list.  The list beyond
				//	pqrCurrent should not be modified, so it's ok to
				//	continue from there when we're done
				//

				ReleaseMutex(mutexQueueList);
				WaitForMultipleObjects(i, ahWaitList, TRUE, INFINITE);

				// take the mutex again and continue
				WaitForSingleObject(mutexQueueList, INFINITE);
				i = 0;
			}
		} // end of walking the queue list for not found printers

		//
		// wait for all remaining worker threads to die
		//

		ReleaseMutex(mutexQueueList);
		fAllocated &= ~ALLOCATED_RELEASE_MUTEX;
		if (i > 0)
		{
			DBGPRINT(("waiting for terminated queues to die\n"));
			WaitForMultipleObjects(i, ahWaitList, TRUE, INFINITE);
		}
		dwReturn = 1;
	} while (FALSE);

	//
	// resource cleanup
	//

	if (fAllocated & ALLOCATED_RELEASE_MUTEX)
	{
		// DBGPRINT(("UpdateQueueInfo releases mutexQueueList\n"));
		ReleaseMutex(mutexQueueList);
	}

	if (fAllocated & ALLOCATED_ENUM_BUFFER)
	{
		LocalFree(pPrinters);
	}

	if (dwReturn == 0)
	{
		//
		// unrecoverable error - stop the service
		//

		MacPrintStatus.dwCurrentState = SERVICE_STOP_PENDING;
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("UpdateQueueInfo: FAIL - unable to change state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("UpdateQueueInfo: changed to SERVICE_STOP_PENDING\n"));
		}
		SetEvent(hevStopRequested);
	}
}



////////////////////////////////////////////////////////////////////////////////
//
//	MacPrintHandler() - handles service control requests
//
//	DESCRIPTION:
//		This routine receives and processes service requests from the NT
//		Service Controller.  Supported requests include:
//
//			SERVICE_CONTROL_STOP
//			SERVICE_CONTROL_INTERROGATE
//
//		dwControl is the service control request.
////////////////////////////////////////////////////////////////////////////////
VOID
MacPrintHandler (
	IN DWORD dwControl
)
{

	switch (dwControl)
	{
	  case SERVICE_CONTROL_STOP:
 		DBGPRINT(("MacPrintHandler: received SERVICE_CONTROL_STOP\n"));
		MacPrintStatus.dwCurrentState = SERVICE_STOP_PENDING;
		MacPrintStatus.dwCheckPoint = 1;
		MacPrintStatus.dwWaitHint = MACPRINT_WAIT_HINT;

		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to change state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("changed to SERVICE_STOP_PENDING\n"));
		}

		SetEvent(hevStopRequested);
		break;

	  case SERVICE_CONTROL_INTERROGATE:
		DBGPRINT(("MacPrintHandler: received SERVICE_CONTROL_INTERROGATE\n"));
		if (!SetServiceStatus(hMacPrintService, &MacPrintStatus))
		{
			DBGPRINT(("MacPrintHandler: FAIL - unable to report state.  err = %ld\n", GetLastError()));
		}
		else
		{
			DBGPRINT(("returned status on interrogate\n"));
		}

		break;
	}
}


////////////////////////////////////////////////////////////////////////////////
//
//	PScriptQInit() - Initialize a Queue Record
//
//	DESCRIPTION:
//		This routine initializes a queue record with the PostScript
//		capabilities of an NT Printer Object as well as allocates
//		the events and system resources necessary to control the
//		queue.
//
////////////////////////////////////////////////////////////////////////////////

BOOLEAN
PScriptQInit(
	PQR					pqr,
	LPPRINTER_INFO_2	pPrinter
)
{
	BOOLEAN			status = TRUE;
	PDRIVER_INFO_2	padiThisPrinter = NULL;
	DWORD			cbDriverInfoBuffer;
	HANDLE			hPrinter = NULL;
	DWORD			cbDataFileName;
	DWORD			rc;

	//
	// resource allocation 'loop'
	//
	do
	{
		pqr->bFound = TRUE;
		pqr->hThread = NULL;
		pqr->JobCount = 0;			// No jobs yet.
		pqr->PendingJobs = NULL;	// Set pending jobs to none.
		pqr->ExitThread = FALSE;	// Set thread control.
		pqr->sListener = INVALID_SOCKET;
		pqr->fonts	  = NULL;
		pqr->MaxFontIndex = 0;
        pqr->pPrinterName = NULL;
        pqr->pMacPrinterName = NULL;
        pqr->pDriverName = NULL;
        pqr->IdleStatus = NULL;
        pqr->SpoolingStatus = NULL;

		//
		// convert printer name to Mac ANSI
		//
#ifdef DBCS
		pqr->pMacPrinterName = (LPSTR)LocalAlloc(LPTR, (wcslen(pPrinter->pPrinterName) + 1) * sizeof(WCHAR));
#else
		pqr->pMacPrinterName = (LPSTR)LocalAlloc(LPTR, wcslen(pPrinter->pPrinterName) + 1);
#endif
		if (pqr->pMacPrinterName == NULL)
		{
			DBGPRINT(("out of memory for pMacPrinterName\n"));
			status = FALSE;
			break;
		}
		CharToOem(pPrinter->pPrinterName, pqr->pMacPrinterName);

		pqr->pPrinterName = (LPWSTR)LocalAlloc(LPTR,
											   (wcslen(pPrinter->pPrinterName) + 1) * sizeof(WCHAR));

		if (pqr->pPrinterName == NULL)
		{
			DBGPRINT(("out of memory for pPrinterName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pPrinterName, pPrinter->pPrinterName);

		pqr->pDriverName = (LPWSTR)LocalAlloc(LPTR,
											  (wcslen(pPrinter->pDriverName) + 1) * sizeof(WCHAR));

		if (pqr->pDriverName == NULL)
		{
			DBGPRINT(("out of memory for pDriverName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pDriverName, pPrinter->pDriverName);

		pqr->pPortName = (LPWSTR)LocalAlloc(LPTR,
											(wcslen(pPrinter->pPortName) + 1) * sizeof(WCHAR));

		if (pqr->pPortName == NULL)
		{
			DBGPRINT(("out of memory for pPortName\n"));
			status = FALSE;
			break;
		}
		wcscpy (pqr->pPortName, pPrinter->pPortName);

		//
		// determine the datatype to use
		//

		if (!OpenPrinter(pqr->pPrinterName, &hPrinter, NULL))
		{
			status = FALSE;
			DBGPRINT(("ERROR: OpenPrinter() fails with %d\n", GetLastError()));
			break;
		}

		//
		// start with a guess as to size of driver info buffer
		//

		cbDriverInfoBuffer = 2*sizeof(DRIVER_INFO_2);
		padiThisPrinter = (PDRIVER_INFO_2)LocalAlloc(LPTR, cbDriverInfoBuffer);
        if (padiThisPrinter == NULL)
        {
            status = FALSE;
			DBGPRINT(("ERROR: LocalAlloc() failed for padiThisPrinter\n"));
            break;
        }

		if (!GetPrinterDriver(hPrinter,
							  NULL,
							  2,
							  (LPBYTE)padiThisPrinter,
							  cbDriverInfoBuffer,
							  &cbDriverInfoBuffer))
		{
			rc = GetLastError();
			DBGPRINT(("WARNING: first GetPrinterDriver call fails with %d\n", rc));
			LocalFree(padiThisPrinter);
                        padiThisPrinter = NULL;

			if (rc != ERROR_INSUFFICIENT_BUFFER)
			{
				status = FALSE;
				break;
			}

			//
			// failed with buffer size error.  Reallocate and retry
			//
			padiThisPrinter = (PDRIVER_INFO_2)LocalAlloc(LPTR, cbDriverInfoBuffer);

			if (padiThisPrinter == NULL)
			{
				status = FALSE;
				DBGPRINT(("out of memory for second padiThisPrinter\n"));
				break;
			}

			if (!GetPrinterDriver(hPrinter,
								  NULL,
								  2,
								  (LPBYTE)padiThisPrinter,
								  cbDriverInfoBuffer,
								  &cbDriverInfoBuffer))
			{
				DBGPRINT(("ERROR: final GetPrinterDriverA call fails with %d\n", GetLastError()));
				status = FALSE;
				break;
			}
		}
		//
		// driver takes postscript if the datafile is a .PPD file
		// otherwise, we'll send it ps2dib
		//
		pqr->pDataType = NULL;

		SetDefaultPPDInfo(pqr);

		if (padiThisPrinter->pDataFile != NULL)
		{
			if ((cbDataFileName = wcslen(padiThisPrinter->pDataFile)) > 3)
			{
				if (_wcsicmp(padiThisPrinter->pDataFile + cbDataFileName - 3, L"PPD") == 0)
				{
					if (IsRemote(pPrinter) && fLocalSystem)
					{
						DBGPRINT(("%ws is remote\n", pPrinter->pPrinterName));
						status = FALSE;
						break;
					}

					//
					// we are postscript
					//
					pqr->pDataType = (LPWSTR)LocalAlloc(LPTR,
														(wcslen(MACPS_DATATYPE_RAW) + 1) * sizeof(WCHAR));

					if (pqr->pDataType == NULL)
					{
						DBGPRINT(("out of memory for pDataType\n"));
						status = FALSE;
						break;
					}

					wcscpy (pqr->pDataType, MACPS_DATATYPE_RAW);
					DBGPRINT(("postscript printer, using RAW\n"));

					if (!GetPPDInfo(pqr))
					{
						DBGPRINT(("ERROR: unable to get PPD info for %ws\n", pqr->pPrinterName));
						status = FALSE;
						break;
					}
				} // ends in PPD
			} // filename longer than 3
		} // filename exists

		if (pqr->pDataType == NULL)
		{
			if (IsRemote(pPrinter))
			{
				DBGPRINT(("%ws is remote\n", pPrinter->pPrinterName));
				status = FALSE;
				break;
			}

			//
			// we are not postscript
			//
			pqr->pDataType = (LPWSTR)LocalAlloc(LPTR,
												(wcslen(MACPS_DATATYPE_PS2DIB) + 1) * sizeof(WCHAR));

			if (pqr->pDataType == NULL)
			{
				DBGPRINT(("out of memory for PSTODIB pDataType\n"));
				status = FALSE;
				break;
			}

			wcscpy (pqr->pDataType, MACPS_DATATYPE_PS2DIB);
			DBGPRINT(("non postscript printer, using PS2DIB\n"));

			if (!SetDefaultFonts(pqr))
			{
				DBGPRINT(("ERROR: cannot set to laserwriter PPD info for %ws\n",
						pqr->pPrinterName));
				status = FALSE;
				break;
			}
		}

	}  while (FALSE);

	//
	// resource cleanup
	//

	if (!status)
	{
		if (pqr->pPrinterName != NULL)
		{
			LocalFree(pqr->pPrinterName);
		}
		if (pqr->pMacPrinterName != NULL)
		{
			LocalFree(pqr->pMacPrinterName);
		}
		if (pqr->pDriverName != NULL)
		{
			LocalFree(pqr->pDriverName);
		}
		if (pqr->pPortName != NULL)
		{
			LocalFree(pqr->pPortName);
		}

		if (pqr->pDataType != NULL)
		{
			LocalFree(pqr->pDataType);
		}

		if (pqr->fonts != NULL)
		{
			LocalFree(pqr->fonts);
		}
	}

	if (hPrinter != NULL)
	{
		ClosePrinter(hPrinter);
	}

	if (padiThisPrinter != NULL)
	{
		LocalFree(padiThisPrinter);
	}

	return (status);
}




DWORD
CreateListenerSocket(
	PQR			pqr
)
{
	DWORD		rc = NO_ERROR;
	SOCKADDR_AT address;
	WSH_REGISTER_NAME	reqRegister;
	DWORD		cbWritten;
	ULONG		fNonBlocking;
	LPWSTR		pszuStatus = NULL;
	LPWSTR		apszArgs[1] = {NULL};
	DWORD		cbMessage;

	DBGPRINT(("enter CreateListenerSocker()\n"));

	//
	// resource allocation 'loop'
	//

	do
	{
		//
		// create a socket
		//

		pqr->sListener = socket(AF_APPLETALK, SOCK_RDM, ATPROTO_PAP);
		if (pqr->sListener == INVALID_SOCKET)
		{
			rc = GetLastError();
			DBGPRINT(("socket() fails with %d\n", rc));
			break;
		}

		//
		// bind the socket
		//

		address.sat_family = AF_APPLETALK;
		address.sat_net = 0;
		address.sat_node = 0;
		address.sat_socket = 0;

		if (bind(pqr->sListener, (PSOCKADDR) &address, sizeof(address)) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("bind() fails with %d\n", rc));
			break;
		}

		//
		// post a listen on the socket
		//

		if (listen(pqr->sListener, 5) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("listen() fails with %d\n", rc));
			break;
		}

		//
		// set the PAP Server Status
		//

		if ((apszArgs[0] = LocalAlloc(LPTR, sizeof(WCHAR) * (strlen(pqr->pMacPrinterName) + 1))) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(args) fails with %d\n", rc));
			break;
		}

		OemToChar(pqr->pMacPrinterName, apszArgs[0]);

		if ((cbMessage = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_HMODULE |
											FORMAT_MESSAGE_ARGUMENT_ARRAY,
										NULL,
										STRING_SPOOLER_ACTIVE,
										LANG_NEUTRAL,
										(LPWSTR)&pszuStatus,
										128,
										(va_list *)apszArgs)) == 0)
		{

			rc = GetLastError();
			DBGPRINT(("FormatMessage() fails with %d\n", rc));
			break;
		}

        if (pszuStatus == NULL)
        {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            DBGPRINT(("FormatMessage could not allocate memory for pszuStatus \n"));
            break;
        }

		//
		// remove trailing ret/lf
		//
		pszuStatus[cbMessage - 2] = 0;

/* MSKK NaotoN modified for MBCS system 11/13/93 */
// change JAPAN -> DBCS 96/08/13 v-hidekk
#ifdef DBCS
		if ((pqr->SpoolingStatus = LocalAlloc(LPTR, cbMessage * sizeof(USHORT))) == NULL)
#else
		if ((pqr->SpoolingStatus = LocalAlloc(LPTR, cbMessage)) == NULL)
#endif
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(SpoolingStatus) fails with %d\n", rc));
			break;
		}

		CharToOem(pszuStatus, pqr->SpoolingStatus);

		if ((cbMessage = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
											FORMAT_MESSAGE_FROM_HMODULE |
											FORMAT_MESSAGE_ARGUMENT_ARRAY,
										NULL,
										STRING_SPOOLER_IDLE,
										LANG_NEUTRAL,
										(LPWSTR)&pszuStatus,
										128,
										(va_list *)apszArgs)) == 0)
		{

			rc = GetLastError();
			DBGPRINT(("FormatMessage() fails with %d\n", rc));
			break;
		}

		//
		// remove trailing ret/lf
		//
		pszuStatus[cbMessage - 2] = 0;
#ifdef DBCS
		if ((pqr->IdleStatus = LocalAlloc(LPTR, cbMessage * sizeof(WCHAR))) == NULL)
#else
		if ((pqr->IdleStatus = LocalAlloc(LPTR, cbMessage)) == NULL)
#endif
		{
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(IdleStatus) fails with %d\n", rc));
			break;
		}

		CharToOem(pszuStatus, pqr->IdleStatus);

		DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
		if ((setsockopt(pqr->sListener,
						SOL_APPLETALK,
						SO_PAP_SET_SERVER_STATUS,
						pqr->IdleStatus,
						strlen(pqr->IdleStatus))) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("setsockopt(status) fails with %d\n", rc));
			break;
		}

		//
		// register a name on the socket
		//
		reqRegister.ZoneNameLen = sizeof(DEF_ZONE) - 1;
		reqRegister.TypeNameLen = sizeof(LW_TYPE) - 1;
		reqRegister.ObjectNameLen = (CHAR) strlen(pqr->pMacPrinterName);

		// Silently truncate the name if it exceeds the max. allowed
		if ((reqRegister.ObjectNameLen&0x000000ff) > MAX_ENTITY)
			reqRegister.ObjectNameLen = MAX_ENTITY;

		memcpy (reqRegister.ZoneName, DEF_ZONE, sizeof(DEF_ZONE) - 1);
		memcpy (reqRegister.TypeName, LW_TYPE, sizeof(LW_TYPE) - 1);
		memcpy (reqRegister.ObjectName, pqr->pMacPrinterName, reqRegister.ObjectNameLen&0x000000ff);

		cbWritten = sizeof(reqRegister);
		if (setsockopt(pqr->sListener,
					   SOL_APPLETALK,
					   SO_REGISTER_NAME,
					   (char *) &reqRegister,
					   cbWritten) == SOCKET_ERROR)
		{
			rc = GetLastError();

            if (CheckFailedCache(pqr->pPrinterName, PSP_ADD) != PSP_ALREADY_THERE)
            {
                DWORD   dwEvent;

                dwEvent = (rc == WSAEADDRINUSE)? EVENT_NAME_DUPNAME_EXISTS :
                                                EVENT_NAME_REGISTRATION_FAILED;

			    ReportEvent(hEventLog,
			           		EVENTLOG_ERROR_TYPE,
				        	EVENT_CATEGORY_INTERNAL,
					        dwEvent,
					        NULL,
					        1,
					        0,
					        &apszArgs[0],
					        NULL);
            }
			DBGPRINT(("setsockopt(SO_REGISTER_NAME) fails with %d\n", rc));
			break;
		}

		//
		// make the socket non-blocking
		//
		fNonBlocking = 1;
		if (ioctlsocket(pqr->sListener, FIONBIO, &fNonBlocking) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("ioctlsocket(FIONBIO) fails with %d\n", rc));
			break;
		}

	} while (FALSE);

	//
	// resource cleanup
	//

	if (apszArgs[0] != NULL)
	{
		LocalFree (apszArgs[0]);
	}

	if (pszuStatus != NULL)
	{
		LocalFree (pszuStatus);
	}

    //
    // if this printer had failed previous initialization attempts, it will be in our
    // failed cache: remove it here.
    //
    if ((rc == NO_ERROR))
    {
        CheckFailedCache(pqr->pPrinterName, PSP_DELETE);
    }
    else
    {
	    // close the listener
	    DBGPRINT(("%ws: closing listener socket, error = %d\n", pqr->pPrinterName,rc));
        if (pqr->sListener != INVALID_SOCKET)
        {
	        closesocket(pqr->sListener);
            pqr->sListener = INVALID_SOCKET;
        }
    }

	return rc;
}

////////////////////////////////////////////////////////////////////////////////
//
//	CheckFailedCache(): find an entry, and add/delete the entry depending on dwAction
//
//	DESCRIPTION:
//		This routine caches all names of all printers that fail to initialize.  The current use
//      of such a cache is to avoid logging too many entries in event log for the same printer
//      which fails over and over.
//      In reality, we don't expect more than 1 (usually 0) entries in this cache!
////////////////////////////////////////////////////////////////////////////////

DWORD
CheckFailedCache(LPWSTR pPrinterName, DWORD dwAction)
{

    PFAIL_CACHE pFlCache, prevFlCache;
    BOOLEAN     bFound=FALSE;
    DWORD       dwRetCode;
    DWORD       dwSize;


    WaitForSingleObject(mutexFlCache, INFINITE);

    for ( pFlCache=prevFlCache=FlCacheHead; pFlCache != NULL; pFlCache = pFlCache->Next )
    {
        if (_wcsicmp(pFlCache->PrinterName, pPrinterName) == 0)
        {
            bFound = TRUE;
            break;
        }
        prevFlCache = pFlCache;
    }

    switch( dwAction )
    {
        case PSP_ADD:

            if (bFound)
            {
                ReleaseMutex(mutexFlCache);
                return(PSP_ALREADY_THERE);
            }

            dwSize = sizeof(FAIL_CACHE) + (wcslen(pPrinterName)+1)*sizeof(WCHAR);

            pFlCache = (PFAIL_CACHE)LocalAlloc(LPTR, dwSize);
            if (pFlCache == NULL)
            {
			    DBGPRINT(("CheckFailedCache: LocalAlloc failed!\n"));

                ReleaseMutex(mutexFlCache);
                // nothing evil should happen if we fail here, other than may be multiple
                // event log entries (which is what we are fixing now!)

                return(PSP_OPERATION_FAILED);
            }

            wcscpy (pFlCache->PrinterName, pPrinterName);

            pFlCache->Next = FlCacheHead;

            FlCacheHead = pFlCache;

            dwRetCode = PSP_OPERATION_SUCCESSFUL;

            break;

        case PSP_DELETE:

            if (!bFound)
            {
                ReleaseMutex(mutexFlCache);
                return(PSP_NOT_FOUND);
            }

            if (pFlCache == FlCacheHead)
            {
                FlCacheHead = pFlCache->Next;
            }
            else
            {
                prevFlCache->Next = pFlCache->Next;
            }

            LocalFree(pFlCache);

            dwRetCode = PSP_OPERATION_SUCCESSFUL;

            break;
    }

    ReleaseMutex(mutexFlCache);

    return( dwRetCode );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\macpsq.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	macpsq.c - Macintosh Print Service queue service routines
//
//	Author: Frank D. Byrum
//		adapted from MacPrint from LAN Manager Services for Macintosh
//
//	DESCRIPTION:
//		This module provides the routines to manage an NT Printer Object
//		on an AppleTalk network.  A QueueServiceThread is started for
//		each NT Printer Object that is to be shared on the AppleTalk
//		network.  This thread publishes an NBP name for the printer,
//		listens for connection requests from Macintosh clients, and
//		handles the communication between the Macintosh and the NT
//		Print Spooler.
//
////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <winsvc.h>
#include <macps.h>
#include <macpsmsg.h>
#include <debug.h>

extern HANDLE DbgSpoolFile;
extern	PQR	 pqrHead;

////////////////////////////////////////////////////////////////////////////////
//
//	QueueServiceThread() - Thread routine to service an NT Printer Object
//
//	DESCRIPTION:
//		This routine fields all AppleTalk PAP requests and service all
//		events associtated with each job.
//
//		pqr ===> points to the Print Queue record for the printer to
//		be serviced.
//
//		On exit from this routine, the queue is shut down and all resources
//		associated with the queue are freed.
//
////////////////////////////////////////////////////////////////////////////////
void
QueueServiceThread(
	PQR		pqr
)
{
	PQR 	*	ppQr;
	PJR			pjr;


	DBGPRINT(("Enter QueueServiceThread for %ws\n", pqr->pPrinterName));
	if (CreateListenerSocket(pqr) != NO_ERROR)
	{
    	DBGPRINT(("ERROR: failed to create session listener.\n"));
        pqr->ExitThread = TRUE;
	}
    else
    {
	    ReportEvent(hEventLog,
		    		EVENTLOG_INFORMATION_TYPE,
			    	EVENT_CATEGORY_ADMIN,
				    EVENT_PRINTER_REGISTERED,
				    NULL,
				    1,
				    0,
				    &(pqr->pPrinterName),
				    NULL);
    }

	//	service jobs until told to exit
	while (!pqr->ExitThread)
	{
		//
		// service PAP events.	HandleNextPAPEvent will wait for up to 2
		// seconds for a read or open to occur on this queue.  If one
		// happens, pjr is the job record the event happened on.  If
		// pjr is NULL, then no event was found.
		//
		HandleNextPAPEvent(pqr);

		//
		// check for service stop
		//
		if (WaitForSingleObject(hevStopRequested, 0) == WAIT_OBJECT_0)
		{
			DBGPRINT(("%ws thread gets service stop request\n", pqr->pPrinterName));
			pqr->ExitThread = TRUE;
			break;
		}
	} // end while !ExitThread

	DBGPRINT(("%ws received signal to die\n", pqr->pPrinterName));

	// Remove all outstanding pending jobs
	DBGPRINT(("%ws removing pending jobs\n", pqr->pPrinterName));

	while ((pjr = pqr->PendingJobs) != NULL)
    {
		RemoveJob(pjr);
    }


	// close the listener
	DBGPRINT(("%ws closing listener socket\n", pqr->pPrinterName));
    if (pqr->sListener != INVALID_SOCKET)
    {
	    closesocket(pqr->sListener);

	    // report printer removed
	    DBGPRINT(("%ws reporting printer removed\n", pqr->pPrinterName));
	    ReportEvent(hEventLog,
		    		EVENTLOG_INFORMATION_TYPE,
				    EVENT_CATEGORY_ADMIN,
				    EVENT_PRINTER_DEREGISTERED,
				    NULL,
				    1,
				    0,
				    &(pqr->pPrinterName),
				    NULL);
    }


	// remove ourselves from the queue list
	DBGPRINT(("queue thread waiting for the queue list mutex\n"));
	WaitForSingleObject(mutexQueueList, INFINITE);
	DBGPRINT(("queue thread removing self from queue\n"));

	for (ppQr = &pqrHead; ; ppQr = &(*ppQr)->pNext)
	{
		if (*ppQr == pqr)
		{
			*ppQr = pqr->pNext;
			break;
		}
	}

	DBGPRINT(("queue thread releasing list mutex\n"));
	ReleaseMutex(mutexQueueList);


	// close the handle to the thread that was opened on create
	CloseHandle(pqr->hThread);


	DBGPRINT(("closed thread for %ws\n", pqr->pPrinterName));


    //	all of this memory allocated in PScriptQInit()
	DBGPRINT(("%ws freeing memory\n", pqr->pPrinterName));

	if (pqr->pPrinterName != NULL)
    {
	    LocalFree(pqr->pPrinterName);
    }

	if (pqr->pMacPrinterName != NULL)
    {
	    LocalFree(pqr->pMacPrinterName);
    }

	if (pqr->pDriverName != NULL)
    {
	    LocalFree(pqr->pDriverName);
    }

	if (pqr->IdleStatus != NULL)
    {
	    LocalFree(pqr->IdleStatus);
    }

	if (pqr->SpoolingStatus != NULL)
    {
	    LocalFree(pqr->SpoolingStatus);
    }

	if (pqr->pPortName != NULL)
	{
		LocalFree(pqr->pPortName);
	}

	if (pqr->pDataType != NULL)
	{
		LocalFree(pqr->pDataType);
	}

	if (pqr->fonts != NULL)
	{
		LocalFree(pqr->fonts);
	}

	LocalFree(pqr);

	DBGPRINT(("leaving QueueServiceThread\n"));
}



////////////////////////////////////////////////////////////////////////////////
//
//	HandleNewJob() - Handle the open of a print job from a Macintosh
//
//	DESCRIPTION:
//		This routine does the necessary processing to handle the open
//		of a PAP connection from a Macintosh.
//
//		If this routine is unable to complete the processesing necessary
//		to open a job, the job is cancelled, the job data structures are
//		cleaned up.
//
////////////////////////////////////////////////////////////////////////////////
DWORD
HandleNewJob(
	PQR		pqr
)
{
	PJR			        pjr = NULL;
	DOC_INFO_1	        diJobInfo;
	PRINTER_DEFAULTS	pdDefaults;
	DWORD		        dwError = NO_ERROR;
	BOOL		        boolOK = TRUE;
	DWORD		        rc = NO_ERROR;
    PJOB_INFO_2         pji2GetJob=NULL;
    DWORD               dwNeeded;
	int			        fNonBlocking;

	DBGPRINT(("enter HandleNewJob()\n"));

	do
	{
		// allocate a job structure
		if ((rc = CreateNewJob(pqr)) != NO_ERROR)
		{
			DBGPRINT(("FAIL - cannot create a new job structure\n"));
			break;
		}

		pjr = pqr->PendingJobs;

		// accept the connection
		if ((pjr->sJob = accept(pqr->sListener, NULL, NULL)) == INVALID_SOCKET)
		{
			rc = GetLastError();
			DBGPRINT(("accept() fails with %d\n", rc));
			break;
		}

		// make the socket non-blocking
		fNonBlocking = 1;
		if (ioctlsocket(pjr->sJob, FIONBIO, &fNonBlocking) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("ioctlsocket(FIONBIO) fails with %d\n", rc));
			break;
		}

		// initialize an NT print job
		pdDefaults.pDatatype = pqr->pDataType;
		pdDefaults.pDevMode = NULL;
		pdDefaults.DesiredAccess = PRINTER_ACCESS_USE;

		if (!OpenPrinter(pqr->pPrinterName, &pjr->hPrinter, &pdDefaults))
		{
			rc = GetLastError();
			DBGPRINT(("OpenPrinter() fails with %d\n"));
			pjr->hPrinter = INVALID_HANDLE_VALUE;
			break;
		}

		diJobInfo.pDocName = NULL;
		diJobInfo.pOutputFile = NULL;
		diJobInfo.pDatatype = pqr->pDataType;

		pjr->dwJobId = StartDocPrinter(pjr->hPrinter, 1, (LPBYTE) &diJobInfo);
		if (pjr->dwJobId == 0)
		{
			rc = GetLastError();
			DBGPRINT(("StartDocPrinter() fails with %d\n", rc));
			break;
		}

#if DBG_SPOOL_LOCALLY
    if (DbgSpoolFile == INVALID_HANDLE_VALUE)
    {
        DbgSpoolFile = CreateFile( L"e:\\tmp\\injob.ps",
                            GENERIC_READ|GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_TEMPORARY,
                            NULL );
    }
#endif


        //
        // set pParameters field of the jobinfo to a unique string that our
        // monitor can identify, so that it can know if the job came from a Mac.
        //

        dwNeeded = 1024;
        while (1)
        {
            pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );
            if (pji2GetJob == NULL)
            {
			    DBGPRINT(("HandleNewJob: alloc for %d bytes failed\n", dwNeeded));
			    rc = ERROR_INSUFFICIENT_BUFFER;
			    break;
            }

            rc = 0;
            if (!GetJob( pjr->hPrinter, pjr->dwJobId, 2,
                         (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ))
            {
                rc = GetLastError();
            }

            if ( rc == ERROR_INSUFFICIENT_BUFFER )
            {
                LocalFree(pji2GetJob);
            }
            else
            {
                break;
            }
        }

        if (rc != 0)
        {
		    DBGPRINT(("HandleNewJob: GetJob failed, rc=%d\n", rc));
			break;
        }

        pji2GetJob->pParameters = LFILTERCONTROL;
        pji2GetJob->Position = JOB_POSITION_UNSPECIFIED;

        SetJob( pjr->hPrinter,pjr->dwJobId, 2, (LPBYTE)pji2GetJob, 0 );

        LocalFree(pji2GetJob);

		pjr->FirstWrite = TRUE;

		// prime for a read
		if (setsockopt(pjr->sJob,
					   SOL_APPLETALK,
					   SO_PAP_PRIME_READ,
					   pjr->bufPool[pjr->bufIndx].Buffer,
					   PAP_DEFAULT_BUFFER) == SOCKET_ERROR)
		{
			DBGPRINT(("setsockopt(SO_PAP_PRIME_READ) fails with %d\n", GetLastError()));
			rc = GetLastError();
			break;
		}
	} while (FALSE);

	if ((rc != NO_ERROR) && (NULL != pjr))
	{
		RemoveJob(pjr);
	}

	return rc;
}




////////////////////////////////////////////////////////////////////////////////
//
//	HandleRead() - Handle a read event from a Macintosh print job
//
//	DESCRIPTION:
//		This routine does the necessary processing to handle a read
//		on a PAP connection from a Macintosh.
//
////////////////////////////////////////////////////////////////////////////////
DWORD
HandleRead(
	PJR		pjr
)
{
	DWORD			rc = NO_ERROR;
	DWORD			dwParseError = NO_ERROR;
	PQR 			pqr = pjr->job_pQr;
    WSABUF          wsaBuf;
	int				iRecvFlags = 0;
    DWORD           dwBytesRead;
    BOOL            fRemoveJob = FALSE;
#if	DBG
	int				CheckPoint = 0;
#endif

	DBGPRINT(("enter HandleRead()\n"));

	do
	{
		// get the data.  recv() will return the negative count of
		// bytes read if EOM is not set.  SOCKET_ERROR is -1.

        wsaBuf.len = pjr->dwFlowQuantum * PAP_QUANTUM_SIZE;
        wsaBuf.buf = pjr->bufPool[pjr->bufIndx].Buffer;

		if (WSARecv(pjr->sJob,
			  	    &wsaBuf,
			  	    1,
                    &pjr->cbRead,
			  	    &iRecvFlags,
                    NULL,
                    NULL) == SOCKET_ERROR)
		{
			DBGPRINT(("CheckPoint = %d\n", CheckPoint = 1));
			rc = GetLastError();
			DBGPRINT(("recv() fails with %d, removing job\n", rc));
			if (rc == WSAEDISCON)
				rc = NO_ERROR;
			RemoveJob(pjr);
			break;
		}

		// if this is flagged EOM, echo the EOM and ignore any error
		// (disconnect will show when we try to prime for a read)

		pjr->EOFRecvd = FALSE;
		if (iRecvFlags != MSG_PARTIAL)
		{
			rc = TellClient(pjr, TRUE, NULL, 0);
			pjr->EOFRecvd = TRUE;
            pjr->EOFRecvdAt = GetTickCount();
		}

		DBGPRINT(("%ws: Read (%d%s)\n", pqr->pPrinterName,
				pjr->cbRead, pjr->EOFRecvd ? ", EOF" : ""));

		// deal with the pending buffer if there is one
		pjr->DataBuffer = pjr->bufPool[pjr->bufIndx].Buffer;
		pjr->XferLen = pjr->cbRead;
		if (pjr->PendingLen)
		{
			DBGPRINT(("USING PENDING BUFFER\n"));
			pjr->DataBuffer -= pjr->PendingLen;
			pjr->XferLen += pjr->PendingLen;
			pjr->PendingLen = 0;
		}

		// setup buffers for next read
		pjr->bufIndx ^= 1;

		// prime for the next read if we haven't disconnected
		if (rc == NO_ERROR)
		{
			DBGPRINT(("priming for another read\n"));
			if (setsockopt(pjr->sJob,
							SOL_APPLETALK,
							SO_PAP_PRIME_READ,
							pjr->bufPool[pjr->bufIndx].Buffer,
							PAP_DEFAULT_BUFFER) == SOCKET_ERROR)
			{
				rc = GetLastError();
				DBGPRINT(("setsockopt() fails with %d\n", rc));

				//
				// this call could fail if the client has disconnected.  Therefore,
				// we parse the data we have received first, then return this
				// error code.
				//
			}
		}

		// parse this data.
		switch (dwParseError = PSParse(pjr, pjr->DataBuffer, pjr->XferLen))
		{
			case NO_ERROR:
				break;

			case ERROR_NOT_SUPPORTED:
				//
				// job from a downlevel client
				//
				DBGPRINT(("aborting a downlevel driver job\n"));
				ReportEvent(hEventLog,
							EVENTLOG_WARNING_TYPE,
							EVENT_CATEGORY_ADMIN,
							EVENT_DOWNLEVEL_DRIVER,
							NULL,
							0,
							0,
							NULL,
							NULL);
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 2));
                fRemoveJob = TRUE;
				break;

			case ERROR_INVALID_PARAMETER:
				//
				// PostScript DSC error.
				//
				DBGPRINT(("ERROR on PSParse().  Aborting job\n"));
				ReportEvent(hEventLog,
							EVENTLOG_WARNING_TYPE,
							EVENT_CATEGORY_USAGE,
							EVENT_DSC_SYNTAX_ERROR,
							NULL,
							1,
							0,
							(LPCWSTR *)(&pjr->pszUser),
							NULL);
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 3));
                fRemoveJob = TRUE;
				break;

			case WSAEINVAL:
				//
				// TellClient got a disconnect
				//
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 4));
				DBGPRINT(("PSParse returns WSAEINVAL, RemoveJob for disconnect\n"));
                fRemoveJob = TRUE;
				break;

			default:
				//
				// some other error - report unknown error
				// and remove job
				//
				DBGPRINT(("CheckPoint = %d\n", CheckPoint = 5));
				DBGPRINT(("PSParse returns error %d\n", dwParseError));
				ReportWin32Error(dwParseError);
                fRemoveJob = TRUE;
		}

		// rc is the return code for TellClient.  If it is an error, we
		// have a disconnect and need to return it.  If it's not, psparse
		// could have gotten a disconnect and we need to return that
		if (rc != NO_ERROR || (fRemoveJob == TRUE))
		{
			DBGPRINT(("HandleRead: rc = %d, fRemoveJob = %d, so removejob\n",rc,fRemoveJob));
			RemoveJob(pjr);
			rc = NO_ERROR;
		}
	} while (FALSE);

	return rc;
}



////////////////////////////////////////////////////////////////////////////////
//
//	CreateNewJob() - Initialize a job data structure
//
//	DESCRIPTION:
//		This routine allocates, initializes and links a job data structure to the
//		job chain for a queue.
//
//		if this fails (due to lack of memory), the returned value is NULL.
//		Otherwise, it is a pointer to a job structure.
//
////////////////////////////////////////////////////////////////////////////////
DWORD CreateNewJob(PQR pqr)
{

	PJR			pjr = NULL;
	DWORD		rc = NO_ERROR;

	DBGPRINT(("enter CreateNewJob(%ws)\n", pqr->pPrinterName));

	do
	{
		// allocate a job structure
		if ((pjr = (PJR)LocalAlloc(LPTR, sizeof(JOB_RECORD))) == NULL)
		{
			//
			// log an error and return
			//
			rc = GetLastError();
			DBGPRINT(("LocalAlloc(pjr) fails with %d\n", rc));
			break;
		}

		// initialize job structure
		pjr->job_pQr = pqr;
		pjr->NextJob = NULL;
		pjr->dwFlags = JOB_FLAG_NULL;
		pjr->hPrinter = INVALID_HANDLE_VALUE;
		pjr->dwJobId = 0;
		pjr->sJob = INVALID_SOCKET;
		pjr->hicFontFamily = INVALID_HANDLE_VALUE;
		pjr->hicFontFace = INVALID_HANDLE_VALUE;
		pjr->dwFlowQuantum = 8;
		pjr->XferLen = 0;
		pjr->DataBuffer = NULL;
		pjr->bufPool = (PBR)(pjr->buffer);
		pjr->bufIndx = 0;
		pjr->cbRead = 0;
		pjr->PendingLen = 0;
		pjr->psJobState = psStandardJob;
		pjr->JSState = JSWrite;
		pjr->SavedJSState = JSWrite;
		pjr->InProgress = NOTHING;
		pjr->InBinaryOp = 0;
#if DBG
		pjr->PapEventCount = 1;
#endif
		pjr->JSKeyWord[0] = 0;

		// get an information context for font family query
		if ((pjr->hicFontFamily = CreateIC(pqr->pDriverName,
											pqr->pPrinterName,
											pqr->pPortName,
											NULL)) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("CreateIC(hicFontFamily) fails with %d\n", rc));
			break;
		}

		// get an information context for font face query
		if ((pjr->hicFontFace = CreateIC(pqr->pDriverName,
										pqr->pPrinterName,
										pqr->pPortName,
										NULL)) == NULL)
		{
			rc = GetLastError();
			DBGPRINT(("CreateIC(hicFontFace) fails with %d\n", rc));
			break;
		}

		// if this is first job, bump thread priority and change our status
		if (pqr->PendingJobs == NULL)
		{
			DBGPRINT(("first job on queue, bumping thread priority\n"));
			SetThreadPriority(pqr->hThread, THREAD_PRIORITY_ABOVE_NORMAL);

			// Change our status from idle to spooling
			DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
			if ((setsockopt(pqr->sListener,
							SOL_APPLETALK,
							SO_PAP_SET_SERVER_STATUS,
							pqr->SpoolingStatus,
							strlen(pqr->SpoolingStatus))) == SOCKET_ERROR)
			{
				rc = GetLastError();
				DBGPRINT(("setsockopt(status) fails with %d\n", rc));
				break;
			}
		}

		// Add the new job to the list of pending jobs for this print queue.
		pjr->NextJob = pqr->PendingJobs;
		pqr->PendingJobs = pjr;
	} while (FALSE);

	if (rc != NO_ERROR)
	{
		if (pjr != NULL)
		{
			if ((pjr->hicFontFamily != NULL) && (pjr->hicFontFamily != INVALID_HANDLE_VALUE))
			{
				DeleteDC(pjr->hicFontFamily);
			}

			if ((pjr->hicFontFace != NULL) && (pjr->hicFontFace != INVALID_HANDLE_VALUE))
			{
				DeleteDC(pjr->hicFontFace);
			}

			LocalFree(pjr);
		}
	}

	return rc;
}




////////////////////////////////////////////////////////////////////////////////
//
//	RemoveJob() - Close a job and clean up the job list
//
//	DESCRIPTION:
//		This routine examines the state of a job and cleans up appropriately.
//		It then unlinks the job structure from the job list and frees it.
//
////////////////////////////////////////////////////////////////////////////////
void
RemoveJob(
	PJR		pjr
)
{
	PJR *	ppjob;
	char	psEOF = '\04';
	DWORD	cbWritten;
	PQR		pqr = pjr->job_pQr;

	DBGPRINT(("enter RemoveJob(%ws)\n", pqr->pPrinterName));

	// find the job in the pending list
	ppjob = &pqr->PendingJobs;
	while (*ppjob != NULL && *ppjob != pjr)
		ppjob = &(*ppjob)->NextJob;

	// remove it from the list
	*ppjob = pjr->NextJob;

	// clean up the socket
	if (pjr->sJob != INVALID_SOCKET)
	{
		DBGPRINT(("closing socket\n"));
		closesocket(pjr->sJob);
	}

	// clean up information contexts
	if (pjr->hicFontFamily != NULL)
	{
		DeleteDC(pjr->hicFontFamily);
	}

	if (pjr->hicFontFace != NULL)
	{
		DeleteDC(pjr->hicFontFace);
	}

	// end the NT print job and close the printer
	if (pjr->hPrinter != INVALID_HANDLE_VALUE)
	{
		if (pqr->ExitThread)
		{
			// we are aborting, so delete the job
			if (!SetJob(pjr->hPrinter, pjr->dwJobId, 0, NULL, JOB_CONTROL_CANCEL))
			{
				DBGPRINT(("ERROR: unable to cancel print job on service stop, rc=%d\n", GetLastError()));
			}
		}

		// Do not write anything if we have not written anything yet !!!
		if (!pjr->FirstWrite && !wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			WritePrinter(pjr->hPrinter,
						 &psEOF,
						 1,
						 &cbWritten);
		}

		EndDocPrinter(pjr->hPrinter);

#if DBG_SPOOL_LOCALLY
        CloseHandle(DbgSpoolFile);
        DbgSpoolFile = INVALID_HANDLE_VALUE;
#endif

		ClosePrinter(pjr->hPrinter);
	}

	// if all the jobs in this queue handled, drop back to normal priority
	if (pqr->PendingJobs == NULL)
	{
		DBGPRINT(("last job removed, dropping thread priority\n"));
		SetThreadPriority(pqr->hThread, THREAD_PRIORITY_NORMAL);

		// change the status from spooling to idle
		DBGPRINT(("setting status to %s\n", pqr->IdleStatus));
		setsockopt(pqr->sListener,
				   SOL_APPLETALK,
				   SO_PAP_SET_SERVER_STATUS,
				   pqr->IdleStatus,
				   strlen(pqr->IdleStatus));
	}

	// free the job structure
	LocalFree(pjr);
}



////////////////////////////////////////////////////////////////////////////////
//
//	HandleNextPAPEvent() - Wait for a PAP event
//
//	DESCRIPTION:
//		This routine waits for a service stop request or an Open or Read to
//		complete on an outstanding job.  In the event of an Open or Read
//		event, the routine finds the job that the event completed for and
//		returns a pointer to that job.
//
//		In the case of a service stop event, the return value is NULL
//
//	NOTES:
//
//		Finding the job that corresponds to the event is tricky.  In the
//		case of the open event it is simple as only one job ever has an
//		open pending.  However, for reads, most jobs will have reads
//		pending simultaneously.
//
//		To find a job with a completed read, we depend on three things.
//		First, all reads are done so that they will trigger a single
//		NT Event.  When this event is signalled, we start looking for
//		completed reads.  Second, when a read completes it changes a
//		status code that is stored on a per job basis, so it's possible
//		to walk a list to find reads that have completed.  Third, we
//		need to be careful about when we reset the event.  The race
//		condition to avoid is between walking the list and reseting
//		the event.  If there are reads outstanding, a read at the beginning
//		of the list could complete before we finish walking the list.
//		To avoid this, we only reset the event when no reads are outstanding
//
////////////////////////////////////////////////////////////////////////////////
void
HandleNextPAPEvent(
	PQR		pqr
)
{
	DWORD	rc = NO_ERROR;
	DWORD	dwIndex;
	PJR		pjr, pjrNext, pjrOrgFirst;
	fd_set	readfds;
	fd_set	exceptfds;
	struct	timeval	timeout;
	int		cEvents;

	do
	{
        //
        // check to see if any OTI-jobs need to be timed out
        // this is a hack to work-around the Apple's OTI bug where the Mac client fails to
        // send the ConnectionClose to us after it has sent EOF (because it crashes!).  To
        // avoid the job staying in our spooler forever, we force the connection closed if
        // we haven't heard from the mac for 60 seconds after it sends an EOF
        //
        pjr = pqr->PendingJobs;
        while(pjr != NULL)
    	{
		    pjrNext = pjr->NextJob;

            if (pjr->EOFRecvd && EXECUTE_OTI_HACK(pjr->EOFRecvdAt))
            {
				DBGPRINT(("%ws must be OTI user ! closing the connection on behalf of client!\n",pjr->pszUser));
		    	RemoveJob(pjr);
            }

		    pjr = pjrNext;
    	}

		// setup socket list with all pending jobs and listener socket
		FD_ZERO(&readfds);
		FD_ZERO(&exceptfds);
		FD_SET(pqr->sListener, &readfds);

		for (dwIndex = 1, pjr = pqr->PendingJobs;
			 (dwIndex < FD_SETSIZE) && (pjr != NULL);
			 dwIndex++, pjr = pjr->NextJob)
		{
			FD_SET(pjr->sJob, &readfds);
			FD_SET(pjr->sJob, &exceptfds);
		}

		// wait for up to 2 seconds for a set of sockets to be ready
		timeout.tv_sec = 2;
		timeout.tv_usec = 0;


		if ((cEvents = select(0, &readfds, NULL, &exceptfds, &timeout)) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("select() fails with %d: CLOSING DOWN QUEUE\n", rc));
			pqr->ExitThread = TRUE;
			break;
		}

		if (cEvents == 0)
		{
            // timeout, done
			break;
		}

		// handle a new connection if there is one
		if (FD_ISSET(pqr->sListener, &readfds))
		{
			if ((rc = HandleNewJob(pqr)) != NO_ERROR)
			{
				DBGPRINT(("ERROR - could not open new job - CLOSING DOWN QUEUE\n"));
				pqr->ExitThread = TRUE;
				break;
			}
		}

		pjr = pqr->PendingJobs;
        pjrOrgFirst = NULL;

        // since every pjr that succeeds on select goes to the tail of the list, make
        // sure we have a way of getting out of this loop!  pjrOrgFirst is the way
        while(pjr != NULL && pjr != pjrOrgFirst)
		{
			pjrNext = pjr->NextJob;

			if (FD_ISSET(pjr->sJob, &exceptfds))
			{
				DBGPRINT(("job for user %ws ends\n", pjr->pszUser));
				RemoveJob(pjr);
			}

			else if (FD_ISSET(pjr->sJob, &readfds))
			{
                // mark the first pjr that's going to be moved to the tail
                if (pjrOrgFirst == NULL)
                {
                    pjrOrgFirst = pjr;
                }

				// Move this job to the end of the queue
				MoveJobAtEnd(pqr, pjr);

				// HandleRead() will remove pjr if a disconnect happens
				HandleRead(pjr);
			}

		    pjr = pjrNext;
		}

		rc = NO_ERROR;
	} while (FALSE);

	if (rc != NO_ERROR)
	{
		ReportWin32Error(rc);
	}
}




/*
** MoveJobAtEnd - Move this job to end of queue.
**
** This is to ensure TRUE round robin scheduling of jobs within a queue.
** Since we always start at head of queue at GetNextPAPEvent, we need to
** do this for any job which got service. The way we achieve this is as
** follows: Ji will be pushed to the end of the queue.
**
** Before the change:
**
** Q -> J1 -> J2 -> ... -> Ji -> Jj -> ... -> Jn -> NULL
**
** After the change:
**
** Q -> J1 -> J2 -> ... -> Jj -> ... -> Jn -> Ji -> NULL
**
** Note that in the boundary conditions of n = 1 OR i = n, it is a NOP i.e.
** its unlinked and linked back - BIG DEAL !!
*/
void
MoveJobAtEnd(PQR pqr, PJR pjr)
{
	PJR *	ppjob = &pqr->PendingJobs;
	BOOL	found = FALSE;

	for (ppjob = &pqr->PendingJobs;
		 *ppjob != NULL;
		 ppjob = &(*ppjob)->NextJob)
	{
		if (*ppjob == pjr)
		{
			/* Unlink it from its current position */
			*ppjob = pjr->NextJob;
			break;
		}
	}

	for (NOTHING;
		 *ppjob != NULL;
		 ppjob = &(*ppjob)->NextJob)
	{
		NOTHING;
	}

	/* Link job at tail */
	*ppjob = pjr;

        // and terminate the tail
        pjr->NextJob = NULL;
}


void
ReportWin32Error (
	DWORD	dwError
)
{
	LPWSTR  pszError = NULL;
	DWORD   rc = NO_ERROR;

	DBGPRINT(("enter ReportWin32Error(%d)\n", dwError));

	do
	{
		if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
							FORMAT_MESSAGE_IGNORE_INSERTS |
							FORMAT_MESSAGE_FROM_SYSTEM,
						  NULL,
						  dwError,
						  0,
						  (LPWSTR)(&pszError),
						  128,
						  NULL) == 0)
		{
			// Report unknown error
			ReportEvent(
				hEventLog,
				EVENTLOG_WARNING_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_MESSAGE_NOT_FOUND,
				NULL,
				0,
				sizeof(DWORD),
				NULL,
				&dwError);

		}
		else
		{
			// report known error
			ReportEvent(hEventLog,
						EVENTLOG_WARNING_TYPE,
						EVENT_CATEGORY_INTERNAL,
						EVENT_SYSTEM_ERROR,
						NULL,
						1,
						0,
						&pszError,
						NULL);
		}
	} while (FALSE);

	if (NULL != pszError)
	{
		LocalFree(pszError);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\pskey.h ===
/*
 *			Copyright(c) Microsoft Corp., 1991
 */

/*
** File Name:
**	
**	PSKEY.H - PostScript Parser Keywords and other strings
**
** Description:
**
*/

#define STDJOBID			"%!PS-Adobe-2.0"
#define QUERYJOBID			"Query"
#define EXITJOBID			"ExitServer"
#define COMMENTHDR			"%%"
#define BEGINBINARY			"%%BeginBinary"				// Start of binary Image
#define ENDBINARY			"%%EndBinary"				// End of Binary Image
#define BEXITSERVER			"%%BeginExitServer"     
#define BEGINFILE			"%%BeginFile"				// Used by PageMaker
#define BPROCSET			"%%BeginProcSet"        
#define BOUNDINGBOX			"%%BoundingBox"				// Used by PageMaker
#define CREATIONDATE		"%%CreationDate"        
#define CREATOR				"%%Creator"             
#define DOCUMENTFONTS		"%%DocumentFonts"			// Used by PageMaker
#define DOCPRINTERREQ		"%%DocumentPrinterRequired" // Used by PageMaker
#define DOCNEEDEDFONTS		"%%DocumentNeededFonts"	 	// Used by PageMaker
#define DOCSUPPLIEDFNT		"%%DocumentSuppliedFonts"	// Used by PageMaker
#define ENDDOCUMENT			"%%EndDocument"				// Used by PageMaker
#define EEXITSERVER			"%%EndExitServer"
#define EPROCSET			"%%EndProcSet"
#define EOFCOMMENT			"%%EOF"
#define FORCOMMENT			"%%For"
#define INCLUDEPROCSET		"%%IncludeProcSet"
#define LOGIN				"%%Login"
#define LOGINCONT			"%%LoginContinue"
#define PAGECOMMENT			"%%Page"
#define PAGESCOMMENT		"%%Pages"
#define TITLECOMMENT		"%%Title"
#define TRAILER				"%%Trailer"
#define QCOMMENT			"%%?"
#define BQCOMMENT			"%%?Begin"
#define EQCOMMENT			"%%?End"
#define BQUERY				"%%?BeginQuery"
#define BBUNGAQUERY			"%%?BeginBungaQuery"		// Non-Conforming Query used by AppleShare Spooler
#define BFEATUREQUERY		"%%?BeginFeatureQuery"
#define BFILEQUERY			"%%?BeginFileQuery"
#define BFONTLISTQUERY		"%%?BeginFontListQuery"
#define BFONTQUERY			"%%?BeginFontQuery"
#define BPASSTHRUQUERY		"%%?BeginPassThroughQuery"
#define BPRINTERQUERY		"%%?BeginPrinterQuery"
#define BPROCSETQUERY		"%%?BeginProcSetQuery"
#define	BSPOOLERQUERY		"%%?BeginSpoolerQuery"
#define BUAMETHODQUERY		"%%?BeginUAMethodsQuery"
#define BVMSTATUS			"%%?BeginVMStatus"			// Non-Conforming Query used by PageMaker
#define BVMSTATUSQUERY		"%%?BeginVMStatusQuery"
#define EBUNGAQUERY			"%%?EndBungaQuery"			// Non-Conforming Query used by AppleShare Spooler
#define EFEATUREQUERY		"%%?EndFeatureQuery"
#define EFILEQUERY			"%%?EndFileQuery"
#define EFONTLISTQ			"%%?EndFontListQuery"
#define EFONTQUERY			"%%?EndFontQuery"
#define EPRINTERQUERY		"%%?EndPrinterQuery"
#define EPROCSETQUERY		"%%?EndProcSetQuery"
#define EPASSTHROUGHQ		"%%?EndPassThroughQuery"
#define EQUERY				"%%?EndQuery"
#define	ESPOOLERQUERY		"%%?EndSpoolerQuery"
#define EUAMETHODQUERY		"%%?EndUAMethodQuery"
#define EVMSTATUS			"%%?EndVMStatus"			// Non-Conforming Query used by PageMaker
#define EVMSTATUSQUERY		"%%?EndVMStatusQuery"
#define RUASPOOLER			"rUaSpooler"
#define ALDUS_QUERY_RESP	"printer"

#define FQLANGUAGELEVEL		"*LanguageLevel"
#define FQPSVERSION			"*PSVersion"
#define FQTOTALVM			"ADORamSize"
#define FQBINARYOK			"ADOIsBinaryOK?"
#define FQPRODUCT			"*Product"
#define FQPRODUCT1			"Product"
#define FQRESOLUTION		"*?Resolution"
#define FQCOLORDEVICE		"*ColorDevice"
#define FQFREEVM			"*FreeVM"
#define FQSPOOLER			"spooler"

// Client Responses
#define LOGINRESPONSE					"LoginOK"
#define EFONTLISTQRESP					"*\n"
#define FONTNOTFOUND					"0\x0a"
#define FONTFOUND						"1\x0a"
#define NULLRESPONSE					"\n"
#define PROCSETMISSINGRESPONSE			"0\r"
#define PROCSETPRESENTRESPONSE			"1\n"
#define PROCSETALMOSTPRESENTRESPONSE	"2\n"
#define DEFAULTPRODUCTRESPONSE			"LaserWriter Plus"
#define DEFAULTPSVERSION				"38.0"
#define DEFAULTPSREVISION				"2"
#define DEFAULTRESPONSE					 "Unknown"
#define UNKNOWNPRINTER					"Apple LaserWriter Plus v38.0"
#define COLORDEVICEDEFAULT				"False"
#define RESOLUTIONDEFAULT				"300dpi"
#define VMDEFAULT						136002
#define DEFAULTLANGUAGELEVEL			"1"

// PPD File Keywords
// See PostScript Printer Description Files Specification Version 3.0
// Some don't have a colon after them on purpose.

#define ppdDEFAULTFILE				"APPLE380.PPD"	// default ppd file name

#define ppdLANGUAGEVERSION			"*LanguageVersion:"
#define ppdLANGUAGELEVEL			"*LanguageLevel:"
#define ppdFORMATVERSION			"*FormatVersion:"
#define ppdFILEVERSION				"*FileVersion:"
#define ppdPSVERSION				"*PSVersion:"
#define ppdPRODUCT					"*Product:"
#define ppdNICKNAME					"*NickName:"
#define ppdINCLUDE					"*Include:"
#define ppdDEFAULTRESOLUTION		"*DefaultResolution:"
#define ppdSETRESOLUTION			"*SetResolution:"
#define ppdQRESOLUTION				"*?Resolution:"
#define ppdCOLORDEVICE				"*ColorDevice:"
#define ppdPATCHFILE				"*PatchFile:"
#define ppdTHROUGHPUT				"*ThroughPut:"
#define ppdFREEVM					"*FreeVM:"
#define ppdRESET					"*Reset:"
#define ppdPASSWORD					"*Password:"
#define ppdPROTOCOL					"*Protocols:"
#define ppdEXITSERVER				"*ExitServer:"
#define ppdFILESYSTEM				"*FileSystem:"
#define ppdQFILESYSTEM				"*?FileSystem:"
#define ppdDEVICEADJUSTMATRIX		"*DeviceAdjustMatrix:"
#define ppdSCREENFREQ				"*ScreenFreq:"
#define ppdSCREENANGLE				"*ScreenAngle:"
#define ppdDEFAULTSCREENPROC		"*DefaultScreenProc:"
#define ppdDEFAULTRANSFER			"*DefaultTransfer:"
#define ppdTRANSFER					"*Transfer:"
#define ppdDEFAULTPAGESIZE			"*DefaultPageSize:"
#define ppdPAGESIZE					"*PageSize:"
#define ppdQPAGESIZE				"*?PageSize:"
#define ppdDEFAULTPAGEREGION		"*DefaultPageRegion:"
#define ppdPAGEREGION				"*PageRegion:"
#define ppdDEFAULTPAPERTRAY			"*DefaultPaperTray:"
#define ppdPAPERTRAY				"*PaperTray:"
#define ppdQPAPERTRAY				"*?PaperTray:"
#define ppdDEFAULTIMAGEABLEAREA		"*DefaultImageableArea:"
#define ppdIMAGEABLEAREA			"*ImageableArea:"
#define ppdQIMAGEABLEAREA			"*?ImageableArea:"
#define ppdDEFAULTPAPERDIMENSION	"*DefaultPaperDimension:"
#define ppdPAPERDIMENSION			"*PaperDimension:"
#define ppdVARIABLEPAPERSIZE		"*VariablePaperSize:"
#define ppdDEFAULTINPUTSLOT			"*DefaultInputSlot:"
#define ppdINPUTSLOT				"*InputSlot:"
#define ppdQINPUTSLOT				"*?InputSlot:"
#define ppdDEFAULTMANUALFEED		"*DefaultManualFeed:"
#define ppdMANUALFEED				"*ManualFeed:"
#define ppdQMANUALFEED				"*?ManualFeed:"
#define ppdDEFAULTOUTPUTBIN			"*DefaultOutputBin:"	
#define ppdOUTPUTBIN				"*OutPutBin:"
#define ppdQOUTPUTBIN				"*?OutPutBin:"
#define ppdDEFAULTOUTPUTORDER		"*DefaultOutputOrder:"
#define ppdOUTPUTORDER				"*OutputOrder:"
#define ppdQOUTPUTORDER				"*?OutputOrder:"
#define ppdDEFAULTCOLLATOR			"*DefaultCollator:"
#define ppdCOLLATOR					"*Collator:"
#define ppdQCOLLATOR				"*?Collator:"
#define ppdDEFAULTDUPLEX			"*DefaultDuplex:"
#define ppdDUPLEX					"*Duplex:"
#define ppdQDUPLEX					"*?Duplex:"
#define ppdFONT						"*Font"
#define ppdDEFAULTFONT				"*DefaultFont:"
#define ppdQFONTLIST				"*?FontList:"
#define ppdQFONTQUERY				"*?FontQuery:"
#define ppdPRINTERERROR				"*PrinterError:"
#define ppdSTATUS					"*Status:"
#define ppdSOURCE					"*Source:"
#define ppdMESSAGE					"*Message:"
#define ppdDEFAULTCOLORSEP			"*DefaultColorSep:"
#define ppdCOLORSEPSCREENFREQ		"*ColorSepScreenFreq"
#define ppdCOLORSEPSCREENANGLE		"*ColorSepScreenAngle"
#define ppdCOLORSEPSCREENPROC		"*ColorSepScreenProc"
#define ppdCOLORSEPTRANSFER			"*ColorSepTransfer"
#define ppdCUSTOMCMYK				"*CustomCMYK"
#define ppdINKNAME					"*InkName"
#define ppdEND						"*End"

#define mdBPROCSET					"%%BeginProcSet: \"(AppleDict md)\" "
#define mdAPPLEDICTNAME				"AppleDict md"
#define APPLEDICTNAME				"AppleDict"
#define	PROTOCOL_BCP				"BCP"
#define MDNAME						"md"
#define SYSTEM7_CHOOSERPACK			"71"		// Rev of system 7.0 lwprep.
#define	CHOOSER_6X					"70"
#define	CHOOSER_52					"68"

// options for LanguageVersion are
#define ENGLISH						"English"
#define RUSSIAN						"Russian"
#define FRENCH						"French"
#define SPANISH						"Spanish"
#define GERMAN						"German"
#define CHINESE						"Chinese"
#define ITALIAN						"Italian"
#define JAPANESE					"Japanese"

// Options for Paper Form Factor
#define LETTER						"Letter"
#define LETTERSMALL					"LetterSmall"
#define TABLOID						"Tabloid"
#define LEDGER						"Ledger"
#define LEGAL						"Legal"
#define STATEMENT					"Statement"
#define A3							"A3"
#define A4							"A4"
#define A4SMALL						"A4Small"
#define A5							"A5"
#define B4							"B4"
#define B5							"B5"
#define ENVELOPE					"Envelope"
#define FOLIO						"Folio"
#define QUARTO						"Quarto"
#define TENBY14						"10x14"

// Options for PaperTray and Bins
#define ppdLARGECAPACITY			"LargeCapacity"
#define ppdLARGEFORMAT				"LargeFormat"
#define ppdLOWER					"Lower"
#define ppdMIDDLE					"Middle"
#define ppdUPPER					"Upper"
#define ppdONLYONE					"OnlyOne"
#define ppdANYSMALLFORMAT			"AnySmallFormat"
#define ppdANYLARGEFORMAT			"AnyLargeFormat"
#define ppdNORMAL					"Normal"
#define ppdREVERSE					"Reverse"

// Options for Font
#define ppdSTANDARD					"Standard"
#define ppdSPECIAL					"Special"
#define ppdISOLATIN1				"ISOLatin1"
#define ppdERROR					"Error"

// Options for Halftones
#define ppdNULL						"Null"
#define ppdNORMALIZED				"Normalized"
#define ppdDOT						"Dot"
#define ppdLINE						"Line"
#define ppdELLIPSE					"Ellipse"
#define ppdCROSS					"Cross"
#define ppdMEZZO					"Mezzo"

// The LaserWriter Plus set of fonts, and encodings

#define DEFAULTFONTS 35

#define FONT00						"AvantGarde-Book"
#define FONT01						"AvantGarde-BookOblique"
#define FONT02						"AvantGarde-Demi"
#define FONT03						"AvantGarde-DemiOblique"
#define FONT04						"Bookman-Demi"
#define FONT05						"Bookman-DemiItalic"
#define FONT06						"Bookman-Light"
#define FONT07						"Bookman-LightItalic"
#define FONT08						"Courier"
#define FONT09						"Courier-Bold"
#define FONT10						"Courier-BoldOblique"
#define FONT11						"Courier-Oblique"
#define FONT12						"Helvetica"
#define FONT13						"Helvetica-Bold"
#define FONT14						"Helvetica-BoldOblique"
#define FONT15						"Helvetica-Narrow"
#define FONT16						"Helvetica-Narrow-Bold"
#define FONT17						"Helvetica-Narrow-BoldOblique"
#define FONT18						"Helvetica-Narrow-Oblique"
#define FONT19						"Helvetica-Oblique"
#define FONT20						"NewCenturySchlbk-Bold"
#define FONT21						"NewCenturySchlbk-BoldItalic"
#define FONT22						"NewCenturySchlbk-Italic"
#define FONT23						"NewCenturySchlbk-Roman"
#define FONT24						"Palatino-Bold"
#define FONT25						"Palatino-BoldItalic"
#define FONT26						"Palatino-Italic"
#define FONT27						"Palatino-Roman"
#define FONT28						"Symbol"
#define FONT29						"Times-Bold"
#define FONT30						"Times-BoldItalic"
#define FONT31						"Times-Italic"
#define FONT32						"Times-Roman"
#define FONT33						"ZapfChancery-MediumItalic"
#define FONT34						"ZapfDingbats"
	
#define ENCODING00					ppdSTANDARD
#define ENCODING01					ppdSTANDARD
#define ENCODING02					ppdSTANDARD
#define ENCODING03					ppdSTANDARD
#define ENCODING04					ppdSTANDARD
#define ENCODING05					ppdSTANDARD
#define ENCODING06					ppdSTANDARD
#define ENCODING07					ppdSTANDARD
#define ENCODING08					ppdSTANDARD
#define ENCODING09					ppdSTANDARD
#define ENCODING10					ppdSTANDARD
#define ENCODING11					ppdSTANDARD
#define ENCODING12					ppdSTANDARD
#define ENCODING13					ppdSTANDARD
#define ENCODING14					ppdSTANDARD
#define ENCODING15					ppdSTANDARD
#define ENCODING16					ppdSTANDARD
#define ENCODING17					ppdSTANDARD
#define ENCODING18					ppdSTANDARD
#define ENCODING19					ppdSTANDARD
#define ENCODING20					ppdSTANDARD
#define ENCODING21					ppdSTANDARD
#define ENCODING22					ppdSTANDARD
#define ENCODING23					ppdSTANDARD
#define ENCODING24					ppdSTANDARD
#define ENCODING25					ppdSTANDARD
#define ENCODING26					ppdSTANDARD
#define ENCODING27					ppdSTANDARD
#define ENCODING28					ppdSPECIAL
#define ENCODING29					ppdSTANDARD
#define ENCODING30					ppdSTANDARD
#define ENCODING31					ppdSTANDARD
#define ENCODING32					ppdSTANDARD
#define ENCODING33					ppdSTANDARD
#define ENCODING34					ppdSPECIAL

// Define some magic characters
#define	LINEFEED			0x0A
#define	CR					0x0D
#define	SPACE				0x20
#define	BANG				0x22
#define	PERCENT				0x25
#define	ASTERISK			0x2A
#define	COLON				0x3A


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\psp.c ===
////////////////////////////////////////////////////////////////////////////////
//
//	MacPrint - Windows NT Print Server for Macintosh Clients
//		Copyright (c) Microsoft Corp., 1991, 1992, 1993
//
//	psp.c - Macintosh Print Service Postscript Parsing Routines
//
//	Author: Frank D. Byrum
//		adapted from MacPrint from LAN Manager Services for Macintosh
//
//	DESCRIPTION:
//		This module provides the routines to parse the Adobe DSC 2.0
//		comments in a PostScript stream.
//
////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <windows.h>
#include <macpsmsg.h>
#include <macps.h>
#include <pskey.h>
#include <debug.h>

// function prototypes
DWORD	HandleTitle(PJR pjr);
DWORD	HandleBeginExitServer(PJR pjr);
DWORD	HandleCreationDate(PJR pjr);
DWORD	HandleCreator(PJR pjr);
DWORD	HandleEndExitServer(PJR pjr);
DWORD	HandleEOF(PJR pjr);
DWORD	HandleFor(PJR pjr);
DWORD	HandleLogin(PJR pjr);
DWORD	HandleBeginProcSet(PJR pjr);
DWORD	HandleEndProcSet(PJR pjr);
DWORD	HandleIncludeProcSet(PJR pjr);
DWORD	HandleComment(PJR, PBYTE);
DWORD	HandleBeginBinary(PJR pjr);
DWORD	HandleEndBinary(PJR pjr);
DWORD	HandlePages(PJR pjr);
void	HandleJobComment (PJR, PBYTE);
PFR		ReAllocateFontList (PFR pfrOld, DWORD cOldFonts, DWORD cNewFonts);

#if DBG_SPOOL_LOCALLY
HANDLE DbgSpoolFile = INVALID_HANDLE_VALUE;
#endif

char *	deffonts[DEFAULTFONTS] =
{
	FONT00,	FONT01,	FONT02,	FONT03,	FONT04,	FONT05,	FONT06,	FONT07,
	FONT08,	FONT09,	FONT10,	FONT11,	FONT12,	FONT13,	FONT14,	FONT15,
	FONT16,	FONT17,	FONT18,	FONT19,	FONT20,	FONT21,	FONT22,	FONT23,
	FONT24,	FONT25,	FONT26,	FONT27,	FONT28,	FONT29,	FONT30,	FONT31,
	FONT32,	FONT33,	FONT34
};

////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultPPDInfo() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the default parameters of our
//		printer to LaserWriter Plus characteristics.  This is used
//		in the event there is no PPD file associated with the given
//		NT Printer Object (as in the case of non Postscript printers)
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SetDefaultPPDInfo(
	PQR		pqr
)
{
	DWORD	i;

	//
	// initialize Postscript keywords
	//
	strcpy(pqr->LanguageVersion, ENGLISH);
	strcpy(pqr->Product, DEFAULTPRODUCTRESPONSE);
	strcpy(pqr->Version, DEFAULTPSVERSION);
	strcpy(pqr->Revision, DEFAULTPSREVISION);
	strcpy(pqr->DeviceNickName, UNKNOWNPRINTER);
	strcpy(pqr->pszColorDevice, COLORDEVICEDEFAULT);
	strcpy(pqr->pszResolution, RESOLUTIONDEFAULT);
	strcpy(pqr->pszLanguageLevel, DEFAULTLANGUAGELEVEL);
	pqr->FreeVM = VMDEFAULT;
	pqr->SupportsBinary = FALSE;

	pqr->fonts = NULL;

	return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
//	SetDefaultFonts() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the default parameters of our
//		printer to LaserWriter Plus characteristics.  This is used
//		in the event there is no PPD file associated with the given
//		NT Printer Object (as in the case of non Postscript printers)
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
SetDefaultFonts(
	PQR		pqr
)
{
	DWORD	i;


	if (pqr->fonts != NULL)
        {
	    DBGPRINT(("ERROR: pqr->fonts is nonnull!\n"));
        }

	pqr->fonts = (PFR)LocalAlloc(LPTR, DEFAULTFONTS * sizeof (FONT_RECORD));
	if (pqr->fonts == NULL)
	{
		DBGPRINT(("ERROR: unable to allocate font data\n"));
		ReportEvent(
				hEventLog,
				EVENTLOG_ERROR_TYPE,
				EVENT_CATEGORY_INTERNAL,
				EVENT_SERVICE_OUT_OF_MEMORY,
				NULL, 0, 0, NULL, NULL);
		return (FALSE);
	}

	//
	// copy font names
	//

	for (i = 0; i < DEFAULTFONTS; i++)
	{
		strcpy(pqr->fonts[i].name, deffonts[i]);
	}
	pqr->MaxFontIndex = DEFAULTFONTS-1;

	return (TRUE);
}

////////////////////////////////////////////////////////////////////////////////
//
//	GetPPDInfo() - Initialize to LaserWriter Plus configuration
//
//	DESCRIPTION:
//		This routine is used to set the parameters of our
//		printer to the characteristics specified in the PPD
//		file for the printer.
//
//		returns true if queue structure initialized OK.
//
////////////////////////////////////////////////////////////////////////////////
BOOLEAN
GetPPDInfo(
	PQR		pqr
)
{
	FILE *  		ppdfile = NULL;
	char *			result = NULL;
	char *			token = NULL;
	char			line[PSLEN];
	PFR				fontPtr=NULL;
	USHORT  		MaxFonts = 100;
	USHORT  		fontindex = 0;
	LPDRIVER_INFO_2	pdiThis = NULL;
	DWORD			cbpdiThis = sizeof(DRIVER_INFO_2) + 256;
	LPSTR			pszPPDFile = NULL;
	BOOLEAN 		ReturnStatus = TRUE;
	HANDLE  		hPrinter = INVALID_HANDLE_VALUE;
	int				toklen;

	do
	{
		// get the path of the ppdfile
		if (!OpenPrinter(pqr->pPrinterName, &hPrinter, NULL))
		{
			hPrinter = INVALID_HANDLE_VALUE;
			DBGPRINT(("ERROR: unable to get printer handle, error=%d\n", GetLastError()));
			ReturnStatus = FALSE;
			break;
		}

		pdiThis = (LPDRIVER_INFO_2) LocalAlloc(LPTR, cbpdiThis);
		if (pdiThis == NULL)
		{
			DBGPRINT(("ERROR: unable to allocate new driverinfo buffer\n"));
			ReturnStatus = FALSE;
			break;
		}
		if (!GetPrinterDriver(hPrinter,
							  NULL,
							  2,
							  (LPBYTE) pdiThis,
							  cbpdiThis,
							  &cbpdiThis))
		{
			if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			{
				DBGPRINT(("ERROR: unable to get printer driver info\n"));
				ReturnStatus = FALSE;
				break;
			}

			LocalFree(pdiThis);
			pdiThis = (LPDRIVER_INFO_2) LocalAlloc(LPTR, cbpdiThis);
			if (pdiThis == NULL)
			{
				DBGPRINT(("ERROR: unable to allocte new driverinfo buffer\n"));
				ReturnStatus = FALSE;
				break;
			}

			if (!GetPrinterDriver(hPrinter,
								  NULL,
								  2,
								  (LPBYTE) pdiThis,
								  cbpdiThis,
								  &cbpdiThis))
			{
				DBGPRINT(("ERROR: unable to get printer driver info\n"));
				ReturnStatus = FALSE;
				break;
			}
		}
#ifdef DBCS
		pszPPDFile = (LPSTR)LocalAlloc(LPTR, (wcslen(pdiThis->pDataFile)+1) * sizeof(WCHAR));
#else
		pszPPDFile = (LPSTR)LocalAlloc(LPTR, wcslen(pdiThis->pDataFile)+1);
#endif
		DBGPRINT(("pDataFile name length = %d\n", wcslen(pdiThis->pDataFile)));
		if (pszPPDFile == NULL)
		{
			DBGPRINT(("out of memory for pszPPDFile\n"));
			ReturnStatus = FALSE;
			break;
		}
		CharToOem(pdiThis->pDataFile, pszPPDFile);
		DBGPRINT(("pDataFile = %ws, pszPPDFile = %s\n", pdiThis->pDataFile, pszPPDFile));

		if ((ppdfile = fopen(pszPPDFile, "rt")) == NULL)
		{
			DBGPRINT(("File open error %s", pszPPDFile));
			ReturnStatus = FALSE;
			break;
		}

		/*
		 * Allocate a buffer for fonts. We don't know yet what size we need.
		 * We make a guess and increase the size as we go. The incremental
		 * size is 10 fonts. We start off with 100. We shrink the segment size
		 * to the final size.
		 */
		fontPtr = (PFR) LocalAlloc (LPTR, sizeof(FONT_RECORD)*MaxFonts);
		if (fontPtr == NULL)
		{
			DBGPRINT(("ERROR: cannot allocate font list buffer, error=%d\n", GetLastError()));
			ReturnStatus = FALSE;
			break;
		}

		pqr->SupportsBinary = FALSE;	// Default
		while (result = fgets(line, PSLEN, ppdfile))
		{
			if (line[0] != ASTERISK || (token= strtok(line, " \011")) == NULL)
				continue;

			// PPD Font Entry?
			if (!_stricmp(line, ppdFONT))
			{
				/* This should be the fontname */
				if ((token= strtok(NULL, " \011:")) != NULL)
				{
					if (strlen(token) <= FONTNAMELEN)
					{
						strcpy(fontPtr[fontindex].name, token);
						DBGPRINT(("Font: %s\n", token));
						fontindex++;
						if (fontindex >= MaxFonts)
						{
							fontPtr = ReAllocateFontList (fontPtr, MaxFonts, MaxFonts + 10);
							if (fontPtr == NULL)
							{
								DBGPRINT(("ERROR: unable to grow font buffer, error=%d\n", GetLastError()));
								ReturnStatus = FALSE;
								break;
							}
							MaxFonts += 10;
						}
					}
					else DBGPRINT(("Fontname > PPDLEN ???\n"));
				}
			}
			else if (!_stricmp(token, ppdPSVERSION))
			{
				// PPD Postscript Version Entry?
				/* Get the PostScript version */
				token= strtok(NULL, "\011()\""); /* This should be the version */
				if (token != NULL)
				{
	                toklen = strlen(token);
					/* Get the PostScript revision */
					if ((toklen <= PPDLEN) && (toklen > 0))
					{
						strcpy(pqr->Version, token);
						DBGPRINT(("Version: %s\n", pqr->Version));
					}
					else
					{
						strcpy(pqr->Version, "1.0");	// Default
						DBGPRINT(("Version > PPDLEN ???\n"));
					}
	
					token= strtok(NULL, "()\""); /* This should be the revision */
					if (token != NULL)
					{
						while ((*token != '\0') && (*token == ' '))
							token ++;
						toklen = strlen(token);
						if ((toklen <= PPDLEN) && (toklen > 0))
						{
							strcpy(pqr->Revision, token);
							DBGPRINT(("Revision: %s\n", pqr->Revision));
						}
						else
						{
							strcpy(pqr->Revision, "1.0");	// Some bogus token
							DBGPRINT(("Revision > PPDLEN ???\n"));
						}
					}
					else
					{
						strcpy(pqr->Version, "1.0");	// Defaults
						strcpy(pqr->Revision, "1.0");
					}
				}
			}
			else if (!_stricmp(token, ppdNICKNAME))
			{
				// PPD NickName?
				/* Get the NICKNAME */
				token= strtok(NULL, "\011()\""); /* This should be the nickname */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->DeviceNickName, token);
					DBGPRINT(("DeviceNickName: %s\n", pqr->DeviceNickName));
				}
				else DBGPRINT(("DeviceNickName > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdLANGUAGEVERSION))
			{
				// PPD Postscript Language Version?
				/* Get the LANGUAGEVERSION */
				token= strtok(NULL, " \011:"); /* This should be the language */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->LanguageVersion, token);
					DBGPRINT(("LanguageVersion: %s\n", pqr->LanguageVersion));
				}
				else DBGPRINT(("LanguageVersion > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdPRODUCT))
			{
				// PPD Product ?
				/* Get the PRODUCT */
				token = strtok(NULL, "\011()\""); /* This should be the product */
				if ((token != NULL) && (strlen(token) <= PPDLEN))
				{
					strcpy(pqr->Product, token);
					DBGPRINT(("Product: %s\n", pqr->Product));
				}
				else DBGPRINT(("Product > PPDLEN ???\n"));
			}
			else if (!_stricmp(token, ppdFREEVM))
			{
				token= strtok(NULL, "\011()\""); /* This should be the product */
				if (token != NULL)
					sscanf(token, "%ld", &pqr->FreeVM);
				DBGPRINT(("Free VM: %ld\n", pqr->FreeVM));
			}
			else if (!_stricmp(token, ppdCOLORDEVICE))
			{
				// this should be a string indicating color support or not
				// in the form of <True> or <False> (brackets not included)
				token = strtok(NULL, " \011:\x0d\x0a");
				if ((token != NULL) && (strlen(token) < COLORDEVICEBUFFLEN))
				{
					strcpy (pqr->pszColorDevice, token);
				}
				else
				{
					strcpy (pqr->pszColorDevice, COLORDEVICEDEFAULT);
				}
				DBGPRINT(("Color device: %s\n", pqr->pszColorDevice));
			}
			else if (!_stricmp(token, ppdDEFAULTRESOLUTION))
			{
				// this should be a string indicating the default
				// resolution of the printer in the form <xxxxdpi>
				// where xxxx is a number
				token = strtok(NULL, " \011:\x0d\x0a");
				if ((token != NULL) && (strlen(token) < RESOLUTIONBUFFLEN))
				{
					strcpy (pqr->pszResolution, token);
				}
				else
				{
					strcpy (pqr->pszResolution, RESOLUTIONDEFAULT);
				}
				DBGPRINT(("Resolution: %s\n", pqr->pszResolution));
			}
			else if (!_stricmp(token, ppdLANGUAGELEVEL))
			{
				// this should be the PostScript level ("1" or "2")
				// implemented in this printer
				token = strtok(NULL, " \011\"");
				if ((token != NULL) && (PPDLEN >= strlen(token)))
				{
					strcpy (pqr->pszLanguageLevel, token);
				}
				else
				{
					strcpy (pqr->pszLanguageLevel, DEFAULTLANGUAGELEVEL);
				}
				DBGPRINT(("Language Level: %s\n", pqr->pszLanguageLevel));
			}
			else if (!_stricmp(line, ppdPROTOCOL))
			{
				/* Get the string following and see if it is BCP or TBCP ? */
				if ((token= strtok(NULL, " \011:")) != NULL)
				{
					if (strstr(token, PROTOCOL_BCP) != NULL)
					{
						pqr->SupportsBinary = TRUE;
					}
				}
			}
		}

		if (!ReturnStatus)
		{
			pqr->fonts = NULL;
			pqr->MaxFontIndex = 0;
		}
		else
		{
			pqr->fonts = fontPtr;
			pqr->MaxFontIndex = fontindex-1;
		}
	} while (FALSE);

	if (pszPPDFile != NULL)
	{
		LocalFree(pszPPDFile);
	}

	if (ppdfile != NULL)
	{
		fclose(ppdfile);
	}

	if (hPrinter != INVALID_HANDLE_VALUE)
	{
		ClosePrinter(hPrinter);
	}

	if (pdiThis != NULL)
	{
		LocalFree(pdiThis);
	}

	if (!ReturnStatus)
	{
		if (fontPtr != NULL)
		{
			LocalFree(fontPtr);
		}
	}

	return (ReturnStatus);
}




PFR
ReAllocateFontList(
	PFR		pfrOld,
	DWORD	cOldFonts,
	DWORD	cNewFonts
)
{
	PFR pfrNew = NULL;

	DBGPRINT(("enter ReAllocateFontList()\n"));

	do
	{
		// allocate new font record
		pfrNew = LocalAlloc(LPTR, cNewFonts * sizeof(FONT_RECORD));
		if (pfrNew == NULL)
		{
			DBGPRINT(("LocalAlloc fails with %d\n", GetLastError()));
			break;
		}

		//
		// copy old font record
		//
		CopyMemory(pfrNew, pfrOld, cOldFonts * sizeof(FONT_RECORD));
	} while (FALSE);

	LocalFree(pfrOld);

	return pfrNew;
}


/*
**
** WriteToSpool()
**
**	Purpose: Determines if job stream is currently being written to
**		the spooler, then writes it to the file if it is being written.
**
**	Returns: fwrite return codes.
**
*/
DWORD
WriteToSpool(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	BOOL	SpoolIt=FALSE;
	DWORD	cbWritten;
	DWORD	dwError = NO_ERROR;


	if ((cchlen !=0) && (pchbuf != NULL) &&
		((pjr->psJobState==psExitServerJob) || (pjr->psJobState==psStandardJob)))
	{
		/* determine the data stream mode to know whether to write */
		switch (pjr->JSState)
		{
			case JSStripEOL:
			case JSStripKW:
			case JSStripTok:
				DBGPRINT(("POP - strip\n"));
				PopJSState(pjr);
				break;

			case JSWriteEOL:
			case JSWriteKW:
			case JSWriteTok:
				DBGPRINT(("POP - write\n"));
				PopJSState(pjr);
			case JSWrite:
				SpoolIt=TRUE;
				break;
		}

		// Do we write this Data to the Output Stream ?
		if (SpoolIt)
		{
			// retry on disk full conditions.
			LONG	RetryCount = 0;

			do
			{
	            dwError = NO_ERROR;
				do
				{
					if (pjr->FirstWrite)
					{
// don't need that filter string anymore
#if 0
						//
						// place comment in job to signal AppleTalk monitor not to filter control characters
						//
						if (!WritePrinter(pjr->hPrinter, FILTERCONTROL, SIZE_FC, &cbWritten))
						{
							dwError = GetLastError();
							DBGPRINT(("WritePrinter() failed with %d\n", dwError));
							RetryCount++;
							break;
						}
#endif
						pjr->FirstWrite = FALSE;
					}

#if DBG_SPOOL_LOCALLY
                    if (DbgSpoolFile != INVALID_HANDLE_VALUE)
                    {
                        WriteFile( DbgSpoolFile, pchbuf, cchlen, &cbWritten, NULL );
                    }
#endif

					if (!WritePrinter(pjr->hPrinter, pchbuf, cchlen, &cbWritten))
					{
						dwError = GetLastError();
						DBGPRINT(("ERROR: cannot write to printer, error = %x\n", dwError));
						RetryCount++;
						break;
					}
				} while (FALSE);

				if (dwError == NO_ERROR)
					break;

				if ((dwError == ERROR_HANDLE_DISK_FULL) || (dwError == ERROR_DISK_FULL))
				{
					Sleep(180*1000);	// 3 minutes. Its okay to block since we cannot
										// service any other jobs either since the disk
										// has no space anyway
				}
			} while (RetryCount <= 10);
		}
	}
	return dwError;
}


/*
** MoveToPending()
**
**	Purpose: Moves the buffer pointed at into the pending buffer.
**
**	Returns: DosWrite error codes.
**
*/
DWORD
MoveToPending(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	DBGPRINT(("Enter MoveToPending\n"));
	if ((cchlen > PSLEN) || (*pchbuf != '%'))
	{
		/*
		 * input line is not a comment and is conforming PostScript line,
		 * so give it to WriteToSpool
		 */
		DBGPRINT(("not a DSC comment, so sending to spooler\n"));
		return (WriteToSpool (pjr, pchbuf, cchlen));
	}

	pjr->PendingLen= cchlen;
	memcpy(&pjr->bufPool[pjr->bufIndx].PendingBuffer[PENDLEN-cchlen], pchbuf, cchlen);
	return (NO_ERROR);
}


/*
** TellClient ()
**
**	Purpose: Sends a message back to the client
**
**	Returns: Any of the PAPWrite return codes.
**
*/
DWORD
TellClient(
	PJR		pjr,
	BOOL	fEof,
	PBYTE	BuffPtr,
	int		cchlen
)
{
	DWORD			rc = NO_ERROR;
	fd_set			writefds;
	struct timeval  timeout;
	int				sendflag;
	int			 	wsErr;

	DBGPRINT(("enter TellClient()\n"));

	do
	{
		FD_ZERO(&writefds);
		FD_SET(pjr->sJob, &writefds);

		//
		// wait up to 30 seconds to be able to write
		//

		if (fEof)
		{
			sendflag = 0;
		}
		else
		{
			sendflag = MSG_PARTIAL;
		}

		timeout.tv_sec = 30;
		timeout.tv_usec = 0;

		DBGPRINT(("waiting for writeability\n"));

		wsErr = select(0, NULL, &writefds, NULL, &timeout);

		if (wsErr == 0)
		{
			DBGPRINT(("response to client times out\n"));
			rc = ERROR_SEM_TIMEOUT;
			break;
		}

		if (wsErr != 1)
		{
			rc = GetLastError();
			DBGPRINT(("select(writefds) fails with %d\n"));
			break;
		}

		if (send(pjr->sJob, BuffPtr, cchlen, sendflag) == SOCKET_ERROR)
		{
			rc = GetLastError();
			DBGPRINT(("send() fails with %d\n", rc));
			break;
		}
	} while (FALSE);

	return rc;
}


/*
**
** HandleBeginBinary()
**
**	Purpose: Handles BeginBinary Comment Events.
**
*/
DWORD
HandleBeginBinary(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginBinary\n"));

	/* Process the BeginBinary Comment */
	pjr->InBinaryOp = TRUE;
	return NO_ERROR;
}


/*
**
** HandleEndBinary()
**
**	Purpose: Handles BeginBinary Comment Events.
**
*/
DWORD
HandleEndBinary(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndBinary\n"));

	// Process the EndBinary Comment
	pjr->InBinaryOp = FALSE;
	return NO_ERROR;
}


/*
**
** HandleBeginExitServer()
**
**	Purpose: Handles BeginExitServer Comment Events.
**
*/
DWORD
HandleBeginExitServer(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginExitServer\n"));
	switch (pjr->psJobState)
	{
		case psQueryJob:
		case psExitServerJob:
			PushJSState(pjr, JSStrip);
			break;

		case psStandardJob:
			PushJSState(pjr, JSStripEOL);
			break;
	}
	return NO_ERROR;
}


/*
**
** HandleCreationDate()
**
**	Purpose: Handles CreationDate Comment Events.
**
**	Returns: Number of lines that should be skipped before scanning
**		for another event starts again.
**
*/
DWORD
HandleCreationDate(
	PJR		pjr
)
{
	return NO_ERROR;
}


/*
**
** HandleCreator() -
**
**	Purpose: Handles Creator Comment Events.
**
*/
DWORD
HandleCreator(
	PJR		pjr
)
{
	return NO_ERROR;
}



/*
**
** HandleEndExitServer()-
**
**	Purpose: Handles EndExitServer Comment Events.
**
*/
DWORD
HandleEndExitServer(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndExitServer\n"));

	if (pjr->psJobState == psStandardJob)
		PushJSState (pjr, JSStripEOL);

	return NO_ERROR;
}

/*
** HandleEOF()
**
** Purpose: Handles EOF Comment Events.
**
*/
DWORD
HandleEOF(
	PJR		pjr
)
{

	DBGPRINT(("Enter HandleEOF\n"));

	if (pjr->psJobState == psQueryJob || pjr->psJobState == psExitServerJob)
	{
		pjr->psJobState = psStandardJob;
	}
	// pjr->JSState = JSStripKW;

	return NO_ERROR;
}


/*
**
** HandleFor()
**
**	Purpose: Handles For Comment Events.
**
*/
DWORD
HandleFor(
	PJR		pjr
)
{

	LPSTR		token;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandleFor\n"));

	//
	// only look for name in main part of print job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("not in standard job, skipping username\n"));
		return NO_ERROR;
	}

	//
	// make sure we haven't already set the title
	//

	if (pjr->dwFlags & JOB_FLAG_OWNERSET)
	{
		DBGPRINT(("owner already set, skipping username\n"));
		return NO_ERROR;
	}

	//
	// mark the job as having an owner
	//
	pjr->dwFlags |= JOB_FLAG_OWNERSET;

	//
	//	look for the client name in the comment and
	//	default if not found
	//
	if (((token = strtok(NULL, NULL_STR)) == NULL) ||
		(strchr(token, '*') != NULL))
	{
		token = CLIENTNAME;
	}

	//
	// get the current job info
	//
	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// need more buffer?  If so, try again with a larger one
		//

		if (cbNeeded > GENERIC_BUFFER_SIZE)
		{
			DBGPRINT(("GetJob needs larger buffer.  Retrying\n"));
			pji1Job = (PJOB_INFO_1)LocalAlloc(LPTR, cbNeeded);
			if (pji1Job == NULL)
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: out of memory in HandleFor\n"));
				return Status;
			}

			if (!GetJob(pjr->hPrinter,
						pjr->dwJobId,
						1,
						(LPBYTE)pji1Job,
						cbNeeded,
						&cbNeeded))
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: second GetJob fails in HandleFor with %d\n",
					Status));
				return Status;
			}
		}
		else
		{
			Status = GetLastError();
			DBGPRINT(("GetJob fails with %d\n", Status));
			return Status	;
		}
	}

	//
	// change the username
	//
	OemToChar(token, pjr->pszUser);
	pji1Job->pUserName = pjr->pszUser;
	DBGPRINT(("Setting user name to %ws\n", pjr->pszUser));

	//
	// set new job information (do not change job position)
	//
	pji1Job->Position = 0;

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{
		Status = GetLastError();
		DBGPRINT(("WARNING: tried to change user name and failed setjob with %d\n", Status));
	}

	return Status;
}


/*
**
** HandleLogin()
**
**	Purpose: Handles Login Comment Events.
**
**	Returns: PAPWrite errors.
**
*/
DWORD
HandleLogin(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleLogin\n"));
	PushJSState(pjr,JSStripEOL);
	return (TellClient(pjr, TRUE, LOGINRESPONSE, sizeof(LOGINRESPONSE)-1));
}


/*
**
** HandleTitle()
**
**	Purpose: Handles Title Comment Events.
**
*/
DWORD
HandleTitle(
	PJR		pjr
)
{
	LPSTR		token;
	LPWSTR		pszTitle;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	PJOB_INFO_1	pji1JobAlloc=NULL;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandleTitle\n"));

	//
	// only get title if we are in main part of job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("skipping this title, not main job\n"));
		return NO_ERROR	;
	}

	//
	// make sure title not already set
	//
	if (JOB_FLAG_TITLESET & pjr->dwFlags)
	{
		DBGPRINT(("title already set.  Skipping this title\n"));
		return NO_ERROR;
	}

	//
	// marke the title as set
	//

	pjr->dwFlags |= JOB_FLAG_TITLESET;

	//
	// get the current job data
	//

	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// need more buffer?  If so, try again with a larger one
		//

		if (cbNeeded > GENERIC_BUFFER_SIZE)
		{
			DBGPRINT(("GetJob needs larger buffer.  Retrying\n"));
			pji1JobAlloc = (PJOB_INFO_1)LocalAlloc(LPTR, cbNeeded);
			if (pji1JobAlloc == NULL)
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: out of memory\n"));
				return Status;
			}

            pji1Job = pji1JobAlloc;

			if (!GetJob(pjr->hPrinter,
						pjr->dwJobId,
						1,
						(LPBYTE)pji1Job,
						cbNeeded,
						&cbNeeded))
			{
				Status = GetLastError();
				DBGPRINT(("ERROR: second GetJob fails with %d\n", Status));
                LocalFree(pji1JobAlloc);
				return Status;
			}
		}
		else
		{
			Status = GetLastError();
			DBGPRINT(("GetJob fails with %d\n", Status));
			return Status;
		}
	}

	//
	// get the title
	//
	if ((token = strtok(NULL, NULL_STR)) == NULL)
	{
		// Clear flag. No title.
		pjr->dwFlags &= ~JOB_FLAG_TITLESET;
		return NO_ERROR	;
	}

	pszTitle = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (strlen(token)+1));
	if (pszTitle == NULL)
	{
		Status = GetLastError();
		DBGPRINT(("out of memory for pszTitle\n"));
		return Status;
	}

	OemToChar(token, pszTitle);

	//
	// change the title
	//
	pji1Job->Position = 0;
	pji1Job->pDocument = pszTitle;
	DBGPRINT(("changing title to %ws\n", pszTitle));

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{

		Status = GetLastError();
		DBGPRINT(("WARNING: tried to change title and failed setjob with %d\n", Status));
	}

    if (pji1JobAlloc)
    {
        LocalFree(pji1JobAlloc);
    }

	LocalFree(pszTitle);
	return Status;
}


/*
**
** HandleBeginProcSet()
**
**	Purpose: Handles Begining of a ProcSet Upload
**
*/
DWORD
HandleBeginProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleBeginProcSet\n"));
	return NO_ERROR;
}



/*
** HandleEndProcSet()
**
**	Purpose: Handles End of a procset inclusion.
**
*/
DWORD
HandleEndProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleEndProcSet\n"));
	return NO_ERROR;
}


/*
** HandleIncludeProcSet()
**
** Purpose: Handles end of a procset inclusion.
**
** Entry:
**	Pointer to Job Structure
**
** Exit:
**
**	0 if no error, otherwise error code.
*/
DWORD
HandleIncludeProcSet(
	PJR		pjr
)
{
	DBGPRINT(("Enter HandleIncludeProcSet\n"));

	return NO_ERROR;
}





///////////////////////////////////////////////////////////////////////////////
//
// HandlePages()
//
//  This comment includes the total number of pages in the job and is
//  used to set the jobinfo structure for the job with the total number
//  of pages
//
///////////////////////////////////////////////////////////////////////////////
DWORD
HandlePages(
	PJR		pjr
)
{
	LPSTR		token;
	DWORD		cPages = 0;
	BYTE		pbBuffer[GENERIC_BUFFER_SIZE];
	PJOB_INFO_1	pji1Job;
	DWORD		cbNeeded;
	DWORD		Status = NO_ERROR;

	DBGPRINT(("Enter HandlePages\n"));

	//
	// only get pages if we are in main part of job
	//
	if (pjr->psJobState != psStandardJob)
	{
		DBGPRINT(("skipping this comment, not main job\n"));
		return NO_ERROR	;
	}

	//
	// get the current job data
	//

	pji1Job = (PJOB_INFO_1)pbBuffer;
	if (!GetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				pbBuffer,
				GENERIC_BUFFER_SIZE,
				&cbNeeded))
	{
		//
		// GetJob failed, and buffer passed in is larger than the largest
		// possible buffer for a job_info_1, so abort this ADSC comment
		//

		Status = GetLastError();
		DBGPRINT(("GetJob() fails with %d\n", Status));
		return Status;
	}

	//
	// get the number of pages.  The comment is of the form %%Pages xx nn
	// where xx is the number of pages to display
	//

	token = strtok(NULL, " ");
	if (token == NULL)
		return(NO_ERROR);
	
	cPages = atoi(token);

	//
	// change the number of pages
	//

	pji1Job->Position = 0;
	pji1Job->TotalPages = cPages;
	DBGPRINT(("changing page count to %d\n", cPages));

	if (!SetJob(pjr->hPrinter,
				pjr->dwJobId,
				1,
				(LPBYTE)pji1Job,
				0))
	{
		Status = GetLastError();
		DBGPRINT(("SetJob fails with %d\n",Status));
	}

	return Status;
}


struct commtable
{
	PSZ	commentstr;
	DWORD	(near *pfnHandle)(PJR);
} commtable [] =
{
	{ FORCOMMENT,		HandleFor				},
	{ TITLECOMMENT,		HandleTitle				},
	{ BEXITSERVER,		HandleBeginExitServer	},
	{ EEXITSERVER,		HandleEndExitServer		},
	{ BPROCSET,			HandleBeginProcSet		},
	{ EPROCSET,			HandleEndProcSet		},
	{ INCLUDEPROCSET,	HandleIncludeProcSet	},
	{ CREATIONDATE,		HandleCreationDate		},
	{ CREATOR,			HandleCreator			},
	{ EOFCOMMENT,		HandleEOF				},
	{ LOGIN,			HandleLogin				},
	{ LOGINCONT,		HandleLogin				},
	{ BEGINBINARY,		HandleBeginBinary		},
	{ ENDBINARY,		HandleEndBinary			},
	{ PAGESCOMMENT,		HandlePages				},
	{ NULL,				NULL					}
};

/*
** HandleComment()
**
**	Purpose: Handles Comment Events.
**
*/
DWORD
HandleComment(
	PJR		pjr,
	PBYTE	ps
)
{
	PSZ	token;
	struct commtable *pct;
	DWORD  status = NO_ERROR;

	DBGPRINT(("Enter HandleComment\n"));

	if ((token = strtok(ps," :")) != NULL)
	{
		DBGPRINT(("Comment: %s\n", token));
		for (pct = commtable; pct->pfnHandle; pct++)
		{
			if (!_stricmp(token, pct->commentstr))
			{
				status = pct->pfnHandle(pjr);
				break;
			}
		}
	}

	// No action on this keyword !!!
	return status;
}


/*
** HandleJobComment()
**
**	Purpose: This parses PostScript Job Comments
*/
void
HandleJobComment(
	PJR		pjr,
	PBYTE	ps
)
{
	char *token;

	DBGPRINT(("Enter HandleJobComment\n"));

	token= strtok(ps, " ");

	//
	// it's a job statement
	//

	if ((token = strtok(NULL, " ")) != NULL)
	{
		/* standard job identification */
		if (!strcmp(token, QUERYJOBID))
		{
			pjr->psJobState = psQueryJob;
			pjr->JSState = JSStrip;
			DBGPRINT(("This is a standard job\n"));
			return;
		}

		if (!strcmp(token, EXITJOBID))
		{
			pjr->psJobState = psExitServerJob;
			pjr->JSState = JSStrip;
			DBGPRINT(("This is an exitjob\n"));
			return;
		}
	}

	//
	// Job identification not recognized, but some PostScript hackers
	// put the program name in this comment, so we treat this as a standard
	// job
	//

	DBGPRINT(("This is an unknown jobtype - processing as standard job\n"));
	pjr->psJobState = psStandardJob;
	pjr->JSState = JSWrite;
}



/*  LineLength -
 *	Returns the number of bytes, including CR/LF to the next
 *	CR/LF in the buffer.  If no CR/LF found, returns -1
 */
int
LineLength(PBYTE pBuf, int cbBuf)
{

	int	 intLength = 0;

	while (intLength < cbBuf)
	{
		//
		// we are looking for a CR
		//
		if (pBuf[intLength] != '\x0d')
		{
			intLength++;
			continue;
		}

		//
		// we've found a CR.  If it's followed by a LF, return that
		// length too, otherwise, just return what we've found
		//
		if ((intLength + 1) < cbBuf)
		{
			if (pBuf[intLength + 1] == '\x0a')
			{
				return intLength + 2;
			}
		}

		return intLength + 1;
	}

	return (-1);
}



/*
**
** PSParse()
**
**	Purpose: This does the actual parsing of the PostScript Data Stream.
**		This routine is always called pointing to the data stream at
**		the beginning of a the Data Stream, or the beginning of a line.
**
**	Returns: PAPWrite error codes.
**
*/
DWORD
PSParse(
	PJR		pjr,
	PBYTE	pchbuf,
	int		cchlen
)
{
	int	cbskip;
	char	ps[PENDLEN];
	DWORD	err = NO_ERROR;

	DBGPRINT(("ENTER: PSParse()\n"));

	while (cchlen > 0)
	{
		if ((cbskip = LineLength(pchbuf, cchlen)) == -1)
			return (MoveToPending(pjr, pchbuf, cchlen));

		/* Determine what the event is */
		if ((cbskip < PSLEN) && (pchbuf[0] == '%'))
		{
			/* copy a comment into the ps string */
			memcpy(ps, pchbuf, cbskip);
			ps[cbskip-1] = 0;		// OverWrite the CR/LF

			if (ps[1] == '%')
			{
				 /* Its a Query Comment */
				if (ps[2] == '?'&& !pjr->InBinaryOp)
				{
					if (ps[3] == 'B')
					{
						/* Process the Begin Query Comment */
						if ((err = HandleBQComment(pjr, ps)) != NO_ERROR)
						{
							DBGPRINT(("PSParse: HandleBQComment %ld\n", err));
							return(err);
						}
					}
					else if (ps[3] == 'E')
					{
						if (pjr->InProgress ==  QUERYDEFAULT)
						{
							if ((err = FinishDefaultQuery(pjr, ps)) != NO_ERROR)
							{
								DBGPRINT(("PSParse: FinishDefaultQuery %ld\n", err));
								return(err);
							}
						}
					}
				}
				else
				{
					/* Process the Comment */
					if ((err = HandleComment(pjr, ps)) != NO_ERROR)
					{
						DBGPRINT(("PSParse: HandleComment %ld\n", err));
						return(err);
					}
				}
			}
			else if (ps[1] == '!'&& !pjr->InBinaryOp)
			{
				/* Process Job ID Comment */
				HandleJobComment(pjr, ps);
			}
		}

		/* Write the lines to the spoolfile? */
		if ((err = WriteToSpool (pjr, pchbuf, cbskip)) != NO_ERROR)
			return (err);

		pchbuf += cbskip;
		cchlen  -= cbskip;
	}
	return NO_ERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\macprint\spooler\pspquery.c ===
/*
**		Copyright(c) Microsoft Corp., 1991
*

/*
** File Name:
**
**	PSPQUERY.C - PostScript Parser Handlers for Query Comments
**
** General Description:
**
**	These are the routines that parse and interprete the PostScript data
**	stream. This interpreter looks for PostScript Document Structuring
**	Comments, which are the spooler commands that are imbedded in the
**	PostScript job stream. This particular file has the code that handles
**	the postscript query commands
*/

#include <stdio.h>
#include <string.h>
#include <search.h>

#include <windows.h>
#include <macps.h>
#include <psqfont.h>
#include <debug.h>
#include <pskey.h>

DWORD	HandleFeatureLanguage(PJR pjr);
DWORD	HandleFeatureVersion(PJR pjr);
DWORD	HandleFeatureBinary(PJR pjr);
DWORD	HandleFeatureProduct(PJR pjr);
DWORD	HandleFeatureResolution(PJR pjr);
DWORD	HandleFeatureColor(PJR pjr);
DWORD	HandleFeatureVM(PJR pjr);
DWORD	HandleFeatureSpooler(PJR pjr);
DWORD	HandleBeginFeatureQuery(PJR pjr, PSZ pszQuery);
DWORD	HandleEndFeatureQuery(PJR pjr, PSZ pszDefaultResponse);
BOOL	IsFontAvailable(PQR pqr, LPSTR pszFontName);
int		__cdecl compare(const void * arg1, const void * arg2);
LONG	GetFontListResponse(PQR pqr, LPSTR pFontBuffer, DWORD cbFontBuffer, LPDWORD pcbNeeded);


/*
** HandleEndFontListQuery()
**
**	Purpose: Handles the EndFontListQuery Comment
**
**	Returns: Error Codes from PAPWrite Call
**
*/

#define DEFAULT_FONTBUF_SIZE		2048

DWORD
HandleEndFontListQuery(
	PJR		pjr
)
{
	PQR		pqr = pjr->job_pQr;
	LPSTR	pFontBuffer = NULL;
	LPSTR	pFontWalker = NULL;
	DWORD	cbFontBuffer = 0;
	DWORD	dwStatus = NO_ERROR;
	DWORD	cbNeeded;

	DBGPRINT(("Enter HandleEndFontListQuery\n"));

	do
	{
		//
		// allocate a typical font buffer
		//

		if ((pFontBuffer = (LPSTR)LocalAlloc(LPTR, DEFAULT_FONTBUF_SIZE)) == NULL)
		{
			dwStatus = GetLastError();
			DBGPRINT(("ERROR: unable to allocate font buffer\n"));
			break;
		}
		cbFontBuffer = DEFAULT_FONTBUF_SIZE;

		//
		// get the fontlist response
		//
		if ((dwStatus = GetFontListResponse(pqr, pFontBuffer, cbFontBuffer, &cbNeeded)) != ERROR_SUCCESS)
		{
			//
			// if buffer too small, reallocate and try again
			//

			if (dwStatus == ERROR_MORE_DATA)
			{
				LocalFree(pFontBuffer);
				if ((pFontBuffer = (LPSTR)LocalAlloc(LPTR, cbNeeded)) == NULL)
				{
					dwStatus = GetLastError();
					DBGPRINT(("ERROR: unable to reallocate font buffer\n"));
					break;
				}
				cbFontBuffer = cbNeeded;

				if ((dwStatus = GetFontListResponse(pqr, pFontBuffer, cbFontBuffer, &cbNeeded)) != ERROR_SUCCESS)
				{
					DBGPRINT(("ERROR: unable to get font list response\n"));
					break;
				}
			}
		}

		//
		// send response to client (in single font name per write)
		// NOTE: While the Apple LaserWriter driver gets fonts from
		// the printer in 512 byte packets that are packed with multiple
		// font names, the PageMaker driver expects fonts to come in
		// a single font per write scheme. So we lose the work that builds
		// a font response like the Mac LaserWriter driver by sending
		// the fonts as PageMaker expects them (which works for both
		// drivers)
		//

		DBGPRINT(("writing fontlist:\n%s", pFontBuffer));
		pFontWalker = pFontBuffer;

		cbFontBuffer = 0;

		while (*pFontWalker != '*')
		{
			cbFontBuffer = strlen(pFontWalker);
			if ((dwStatus = TellClient(pjr, FALSE, pFontWalker, cbFontBuffer)) != NO_ERROR)
			{

				//
				// error sending data to client
				//

				DBGPRINT(("ERROR: unable to send font to client\n"));
				break;
			}
			pFontWalker += (cbFontBuffer + 1);
		}

		//
		// do not fail if a send of a font fails. If we can get the
		// termination font out, the Mac will just download any fonts
		// it needs and the job will print - albeit slowly.
		//

		if ((dwStatus = TellClient(pjr, pjr->EOFRecvd, pFontWalker, strlen(pFontWalker))) != NO_ERROR)
		{
			 DBGPRINT(("ERROR: unable to send terminating font to client\n"));
			 break;
		}
	} while (FALSE);

	if (pFontBuffer != NULL)
	{
		LocalFree (pFontBuffer);
	}

	return dwStatus;
}


//////////////////////////////////////////////////////////////////////////////
//
// GetFontListResponse - formats a fontlist buffer to send to a Mac
//
// Based on the queue type (Postscript or non), a fontlist is generated
// and placed in the supplied buffer. The font list is an ordered list
// of fonts separated by '\n\0' with a terminating font of '*\n\0'.
//
// if the buffer is too small, this routine returns ERROR_MORE_DATA.
// if for some other reason the list cannot be generated, the return
// value is ERROR_INVALID_PARAMETER.
// if the function successfully returns a font list, the return value
// is ERROR_SUCCESS.
//
//////////////////////////////////////////////////////////////////////////////
LONG
GetFontListResponse(
	PQR		pqr,
	LPSTR	pFontBuffer,
	DWORD	cbFontBuffer,
	LPDWORD	pcbNeeded
)
{
	LONG	lReturn = ERROR_SUCCESS;
	HANDLE	hFontQuery = INVALID_HANDLE_VALUE;
	DWORD	cFonts;
	DWORD	dwIndex;
	BOOL	boolPSQueue;
	LPSTR	*apszFontNames = NULL;
	LPSTR	pTempBuffer = NULL;
	DWORD	cbTempBuffer = cbFontBuffer;
	DWORD	cbFontFileName;
	LPSTR	pFont;
	DWORD	cbFont;
	DWORD	rc;

	DBGPRINT(("enter GetFontListResponse(cbBuffer:%d, cbNeeded:%d\n", cbFontBuffer, *pcbNeeded));

	do
	{
		//
		// what kind of queue are we
		//
		if (wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			//
			// we are PSTODIB
			//
			boolPSQueue = FALSE;
		}
		else
		{
			//
			// we are Postscript
			//
			boolPSQueue = TRUE;
		}

		//
		// allocate an array of fontname pointers.
		//

		if (boolPSQueue)
		{
			cFonts = pqr->MaxFontIndex + 1;
			DBGPRINT(("cFonts=%d\n", cFonts));
			apszFontNames = (LPSTR*)LocalAlloc(LPTR, cFonts * sizeof(LPSTR));
		}
		else
		{
			//
			// for PSTODIB we will need a temp buffer for the fonts as well
			//
			if ((pTempBuffer = (LPSTR)LocalAlloc(LPTR, cbFontBuffer)) == NULL)
			{
				lReturn = ERROR_INVALID_PARAMETER;
				DBGPRINT(("ERROR: unable to allocate temp font buffer\n"));
				break;
			}

			if ((rc = PsBeginFontQuery(&hFontQuery)) != PS_QFONT_SUCCESS)
			{
				DBGPRINT(("ERROR: PsBeginFontQuery returns %d\n", rc));
				lReturn = ERROR_INVALID_PARAMETER;
				break;
			}

			if ((rc = PsGetNumFontsAvailable(hFontQuery,
											 &cFonts)) != PS_QFONT_SUCCESS)
			{
				DBGPRINT(("ERROR: PsGetNumFontsAvailable returns %d\n", rc));
				lReturn = ERROR_INVALID_PARAMETER;
				break;
			}
			apszFontNames = (LPSTR*)LocalAlloc(LPTR, cFonts * sizeof(LPSTR));
		}

		if (apszFontNames == NULL)
		{
			DBGPRINT(("ERROR: cannot allocate font list array\n"));
			lReturn = ERROR_INVALID_PARAMETER;
			break;
		}

		//
		// fill the array of fontname pointers
		//

		*pcbNeeded = 3;
		pFont = pTempBuffer;
		for (dwIndex = 0; dwIndex < cFonts; dwIndex++)
		{
			if (boolPSQueue)
			{
				apszFontNames[dwIndex] = pqr->fonts[dwIndex].name;
				*pcbNeeded += (strlen(pqr->fonts[dwIndex].name)+2);
				DBGPRINT(("adding font:%s, cbNeeded:%d, index:%d\n", pqr->fonts[dwIndex].name, *pcbNeeded, dwIndex));
			}
			else
			{
				//
				// pstodib - add the font to the temp buffer
				// and set the pointer
				//
				cbFont = cbTempBuffer = cbFontBuffer;
				if ((rc = PsGetFontInfo(hFontQuery,
										dwIndex,
										pFont,
										&cbFont,
										NULL,
										&cbFontFileName)) != PS_QFONT_SUCCESS)
				{
					//
					// if we are out of memory, continue enumeration
					// to get size needed, but set return to ERROR_MORE_DATA
					//
					if (rc == PS_QFONT_ERROR_FONTNAMEBUFF_TOSMALL)
					{
						DBGPRINT(("user buffer too small for font query\n"));
						lReturn = ERROR_MORE_DATA;
						pFont = pTempBuffer;
						cbFont = cbTempBuffer = cbFontBuffer;
						if ((rc = PsGetFontInfo(hFontQuery,
												dwIndex,
												pFont,
												&cbFont,
												NULL,
												&cbFontFileName)) != PS_QFONT_SUCCESS)
						{
							//
							// we be hosed. Fail.
							//
							lReturn = ERROR_INVALID_PARAMETER;
							DBGPRINT(("ERROR: cannot continue PSTODIB font enumeration\n"));
							break;
						}
						else
						{
							*pcbNeeded += cbFont + 2;
						}
					}
				}
				else
				{
					*pcbNeeded += cbFont + 2;
				}
				apszFontNames[dwIndex] = pFont;
				cbTempBuffer -= cbFont;
				pFont += cbFont;
				cbFont = cbTempBuffer;
			}

		}

		if (*pcbNeeded > cbFontBuffer)
		{
			lReturn = ERROR_MORE_DATA;
			break;
		}

		//
		// build the fontlistresponse
		//

		cbFontBuffer = 0;
		for (dwIndex = 0; dwIndex < cFonts; dwIndex++)
		{
			cbFont = sprintf(pFontBuffer, "%s\n", apszFontNames[dwIndex]) + 1;
			pFontBuffer += cbFont;
			cbFontBuffer += cbFont;
		}

		memcpy (pFontBuffer, "*\n", 3);
	} while (FALSE);

	if (apszFontNames != NULL)
	{
		LocalFree(apszFontNames);
	}

	if (pTempBuffer != NULL)
	{
		LocalFree(pTempBuffer);
	}

	if (hFontQuery != INVALID_HANDLE_VALUE)
	{
		PsEndFontQuery(hFontQuery);
	}

	return (lReturn);
}


int __cdecl
compare(const void* arg1, const void* arg2)
{
	return _stricmp(* (char **)arg1, * (char **)arg2);
}


//
//		For Postscript printers, the font enumeration technique is complex.
//		EnumFontFamilies expects the programmer to specify a callback function
//		that will be called either once for every font family, or once for
//		every font face in a family. To get all fonts available, I use
//		EnumFontFamilies twice. The first enumeration, I call EnumFontFamilies
//		with a null value for the family name. This causes the callback
//		function to be called once for each family name installed. This
//		callback function then does an enumeration on that family name to
//		get the specific face names in the family. This second layer of
//		enumeration specifies yet another callback function that returns
//		the font name to the Macintosh client.
//
void
EnumeratePostScriptFonts(
	PJR		pjr
)
{
	PQR		pqr = pjr->job_pQr;

	DBGPRINT(("ENTER EnumeratePostScriptFonts\n"));

	if (pjr->hicFontFamily != NULL)
	{
		//
		// enumerate the font families
		//
		EnumFontFamilies(pjr->hicFontFamily,
						NULL,
						(FONTENUMPROC)FamilyEnumCallback,
						(LPARAM)pjr);
	}
}


int CALLBACK
FamilyEnumCallback(
	LPENUMLOGFONT	lpelf,
	LPNEWTEXTMETRIC	pntm,
	int				iFontType,
	LPARAM			lParam
)
{
	PQR		pqr = ((PJR)lParam)->job_pQr;
	PJR		pjr = (PJR)lParam;

	DBGPRINT(("Enter FamilyEnumCallback for family %ws\n", lpelf->elfFullName));

	//
	// enumerate the fonts in this family
	//

	if (iFontType & DEVICE_FONTTYPE)
	{
		DBGPRINT(("enumerating face names\n"));
		EnumFontFamilies(pjr->hicFontFace,
						lpelf->elfFullName,
						(FONTENUMPROC)FontEnumCallback,
						lParam);
	}
	else
	{
		DBGPRINT(("this family is not a DEVICE_FONTTYPE\n"));
	}

	return 1;
}


int CALLBACK
FontEnumCallback(
	LPENUMLOGFONT	lpelf,
	LPNEWTEXTMETRIC	pntm,
	int				iFontType,
	LPARAM			lParam
)
{
	DWORD		PAPStatus;
	PJR			pjr = (PJR)lParam;
	BYTE		pszFontName[255];

	DBGPRINT(("Enter FontEnumCallback\n"));

	//
	// return this font name to the client
	//

	if (iFontType & DEVICE_FONTTYPE)
	{
		CharToOem(lpelf->elfFullName, pszFontName);
		if (PAPStatus = TellClient(pjr,
								   FALSE,
								   pszFontName,
								   strlen(pszFontName)))
		{
			DBGPRINT(("ERROR: TellClient returns %d\n", PAPStatus));
		}
	}
	else
	{
		DBGPRINT(("%ws is not a DEVICE_FONTTYPE\n", lpelf->elfFullName));
	}

	return 1;
}




/*
** HandleEndQuery()
**
**	Purpose: PageMaker will send a query that goes like this:
**
**		%%BeginQuery
**		...
**		%%EndQuery (spooler)
**
**		In order to allow pagemaker to print TIFF formated images
**		properly, we should respond to this query with "printer".
**
**	Returns: Error Codes from PAPWrite Call
**
*/
DWORD
HandleEndQuery(
	PJR		pjr,
	PBYTE	ps
)
{
	char	*token;
	CHAR	pszResponse[PSLEN+1];

	DBGPRINT(("Enter HandleEndQuery\n"));
	token = strtok(NULL,"\n");

	if (token == NULL)
	{
		return NO_ERROR;
	}

	/* strip off any leading blanks in the default */
	token += strspn(token, " ");

	//
	// respond with the default
	//

	sprintf(pszResponse, "%s\x0a", token);
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}


/***************************************************************************
** FinishDefaultQuery()
**
**	Purpose: Scans for the PostScript command specified in psKeyWord. It
**		then will respond with the default response specified on that
**		line. It will set the InProgress field in the JOB_RECORD to
**		an InProgress value if the default is not found in this buffer.
**
**	Returns: Error Codes from PAPWrite Call
**
***************************************************************************/
DWORD
FinishDefaultQuery(
	PJR		pjr,
	PBYTE	ps
)
{
	char *	token;
	char	buf[PSLEN+1];

	DBGPRINT(("FinishDefaultQuery: %s\n", ps));

	if (NULL == (token = strtok (ps," :")))
	{
		return (NO_ERROR);
	}

	pjr->InProgress= NOTHING;

	/* First We Should Handle the cases that do not use the default response */

	if (!_stricmp(token, EFEATUREQUERY))
		return (HandleEndFeatureQuery(pjr, strtok (NULL," \n")));

 	if (!_stricmp(token, EFONTLISTQ))
		return( HandleEndFontListQuery (pjr));

	if (!_stricmp(token, EQUERY))
 		return( HandleEndQuery (pjr, ps));

	if (!_stricmp(token, EPRINTERQUERY))
		return( HandleEndPrinterQuery(pjr));

	if (!_stricmp(token, EVMSTATUS))
	{
		sprintf(buf, "%ld", pjr->job_pQr->FreeVM);
		return (TellClient(pjr, pjr->EOFRecvd, buf , strlen(buf)));
	}

	if ((token = strtok(NULL,"\n")) == NULL)
	{
		return (NO_ERROR);
	}

	/* strip off any leading blanks in the default. Append a LF */
	token += strspn(token, " ");
	sprintf(buf, "%s\x0a", token);
	return (TellClient(pjr, pjr->EOFRecvd, buf, strlen(buf)));
}


DWORD
HandleEndFeatureQuery(
	PJR		pjr,
	PSZ		pszDefaultResponse)
{

	DWORD			rc = NO_ERROR;
	CHAR			pszResponse[PSLEN];

	DBGPRINT(("enter HandleEndFeatureQuery\n"));

	do
	{
		//
		// return the default response if there is one
		//
		if (NULL != pszDefaultResponse)
		{
			sprintf(pszResponse, "%s\x0a", pszDefaultResponse);
			DBGPRINT(("responding with default response from query: %s\n", pszResponse));
			rc = TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse));
			break;
		}

		DBGPRINT(("responding with Unknown\n"));
		rc = TellClient(pjr, pjr->EOFRecvd, DEFAULTRESPONSE, strlen(DEFAULTRESPONSE));

	} while (FALSE);

	return rc;
}



/*
** Routine:
**	ParseDict
**
**	Purpse:
**
**	This routine will take a given QueryProcSet, BeginProcSet, or
**	IncludeProcSet comment and determine what dictionary is being
**	referenced.
**
** Entry:
**
**	Address of a record to fill in with the Dictionary information.
**
** Exit:
**
**	Filed in structure
**
*/
void
FindDictVer(
	PDR		pdr
)
{
	char	*token;

	pdr->name[0] = 0;
	pdr->version[0] = 0;
	pdr->revision[0] = 0;

	DBGPRINT(("Enter FindDictVer\n"));

	/* lets look for a line like this: "(appledict md)" 67 0 */
	token = strtok(NULL,"() \""); /* this should be appledict */

	if (token !=NULL)
	{
		/*/
		** If the token is "Appledict", then we need to parse again to get
		** the real dict name.
		*/
		if (!_stricmp(token, APPLEDICTNAME))
		token = strtok(NULL,"() \""); /* this sholud be md, or some other dict name */

		if (token != NULL)
		{
			strcpy(pdr->name, token);
			token = strtok(NULL," \"");

			if (token != NULL)
			{
				strcpy(pdr->version,token);
				token = strtok(NULL," \"");

				if (token != NULL)
				strcpy(pdr->revision,token);
			}
		}
	}
	DBGPRINT(("FindDictVer: %s:%s:%s\n", pdr->name,
			pdr->version, pdr->revision));
} // End of FindDictVer



struct commtable
{
	PSZ	commentstr;
	DWORD	(*pfnHandle)(PJR, PSZ);
	PSZ	parmstr;
} qrytable [] =
{
	{ BPROCSETQUERY,	HandleBeginProcSetQuery,	NULL },
	{ BFONTQUERY,		HandleBeginFontQuery,		NULL },
	{ NULL,			NULL,				NULL }
};


/*
**
** HandleBQCommentEvent()
**
**	Purpose: Handles Begin Query Comment Events.
**
**	Returns: Error Codes
*/
DWORD
HandleBQComment(
	PJR		pjr,
	PBYTE	ps
)
{
	PSZ		token;
	PSZ		qrytoken;
	PSZ		endquery	= EQCOMMENT;
	DWORD	status = NO_ERROR;
	struct commtable *pct;

	DBGPRINT(("Enter HandleBQComment\n"));

	//
	// Parse the keyword
	//
	if ((token= strtok(ps," :")) != NULL)
	{
		DBGPRINT(("query: %s\n", token));

		// found the keyword, call the correct handler
		for (pct = qrytable; pct->pfnHandle != NULL; pct++)
		{
			if (!strcmp(token, pct->commentstr))
			{
				status = pct->pfnHandle(pjr,
										pct->parmstr == NULL ? ps : pct->parmstr);
				if (status == (DWORD)-1)	// Special error code, handle it the default way
				{
					status = NO_ERROR;
					break;
				}
				return (status);
			}
		}

		// special case the BeginFeatureQuery comment as the item
		// being queried comes as the next token
		if (!strcmp(token, BFEATUREQUERY))
		{
			status = HandleBeginFeatureQuery(pjr, strtok(NULL," \n\x09"));
			return (status);
		}

		// special case the BeginQuery comment for the same reasons
		// as BeginFeatureQuery
		if (!strcmp(token, BQUERY))
		{
			qrytoken = strtok(NULL, " \n\x09");
			if (NULL != qrytoken)
			{
				status = HandleBeginFeatureQuery(pjr, qrytoken);
				return (status);
			}
		}

		// keyword not recognized, parse as unknown comment. Token is
		// of form %%?BeginXXXXQuery. Change this to the form %%?EndXXXXQuery
		// and pass it to HandleBeginXQuery.
		token += sizeof(BQCOMMENT) - sizeof(EQCOMMENT);
		strncpy(token, EQCOMMENT, sizeof(EQCOMMENT)-1);
		HandleBeginXQuery(pjr, token);
	}

	return (status);
}




struct featurecommtable
{
	PSZ	commentstr;
	DWORD	(*pfnHandle)(PJR);
} featureqrytable [] =
{
	{ FQLANGUAGELEVEL,	HandleFeatureLanguage },
	{ FQPSVERSION,		HandleFeatureVersion },
	{ FQBINARYOK,		HandleFeatureBinary },
	{ FQPRODUCT,		HandleFeatureProduct },
	{ FQPRODUCT1,		HandleFeatureProduct },
	{ FQRESOLUTION,		HandleFeatureResolution },
	{ FQCOLORDEVICE,	HandleFeatureColor },
	{ FQFREEVM,			HandleFeatureVM },
	{ FQTOTALVM,		HandleFeatureVM },
	{ FQSPOOLER,		HandleFeatureSpooler },
	{ NULL,				NULL }
};

DWORD
HandleBeginFeatureQuery(
	PJR		pjr,
	PSZ 	pszQuery
)
{
	DWORD	i, rc = NO_ERROR;
	struct	featurecommtable *pct;

	DBGPRINT(("enter HandleBeginFeatureQuery:%s\n", pszQuery));

	do
	{
		//
		// if we have no query keyword, break;
		//

		if (NULL == pszQuery)
		{
			DBGPRINT(("NULL feature\n"));
			break;
		}

		// Strip out any trailing CR/LF before comparing
		for (i = strlen(pszQuery) - 1; ; i--)
		{
			if ((pszQuery[i] != CR) && (pszQuery[i] != LINEFEED))
				break;
			pszQuery[i] = 0;
		}
		//
		// walk the list of known feature queries and call the appropriate
		// feature query handler
		//

		for (pct = featureqrytable; pct->pfnHandle != NULL; pct++)
		{
			if (!strcmp(pszQuery, pct->commentstr))
			{
				rc = pct->pfnHandle(pjr);
				break;
			}
		}

		if (NULL == pct->pfnHandle)
		{
			DBGPRINT(("WARNING: feature query not found\n"));
			pjr->InProgress = QUERYDEFAULT;
		}

	} while (FALSE);

	return rc;
}





DWORD
HandleFeatureLanguage(
	PJR		pjr
)
{
	CHAR	pszResponse[PSLEN];
	//
	// this routine should respond with the PostScript language level
	// supported by the printer. The response is in the form "<level>"
	// where <level> is PostScript language level - either a 1 or a 2 at
	// the time of this writing.
	//

	DBGPRINT(("enter HandleFeatureLanguage\n"));

	sprintf(pszResponse, "\"%s\"\x0a", pjr->job_pQr->pszLanguageLevel);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureVersion(
	PJR		pjr
)
{
	CHAR		pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureVersion\n"));

	sprintf(pszResponse, "\"(%s) %s\"\x0a", pjr->job_pQr->Version, pjr->job_pQr->Revision);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureBinary(
	PJR		pjr
)
{
	DBGPRINT(("enter HandleFeatureBinary\n"));

	return (TellClient(pjr,
					   pjr->EOFRecvd,
					   pjr->job_pQr->SupportsBinary ? "True\x0a" : "False\x0a",
					   pjr->job_pQr->SupportsBinary ? 5: 6));
}

DWORD
HandleFeatureProduct(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureProduct\n"));

	sprintf(pszResponse, "\"(%s)\"\x0a", pjr->job_pQr->Product);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));

}


DWORD
HandleFeatureResolution(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureResolution\n"));

	sprintf(pszResponse, "%s\x0a", pjr->job_pQr->pszResolution);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}


DWORD
HandleFeatureColor (PJR pjr)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureColor\n"));

	sprintf(pszResponse, "%s\x0a", pjr->job_pQr->pszColorDevice);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureVM(
	PJR 	pjr
)
{
	CHAR	pszResponse[PSLEN];

	DBGPRINT(("enter HandleFeatureVM\n"));

	sprintf(pszResponse, "\"%d\"\x0a", pjr->job_pQr->FreeVM);
	DBGPRINT(("responding with:%s\n", pszResponse));
	return (TellClient(pjr, pjr->EOFRecvd, pszResponse, strlen(pszResponse)));
}

DWORD
HandleFeatureSpooler(
	PJR 	pjr
)
{
	DBGPRINT(("enter HandleFeatureSpooler\n"));
	return (TellClient(pjr, pjr->EOFRecvd, "1 \x0a", 3));
}


/*
** HandleBeginProcSetQuery()
**
**	Purpose: Handles BeginProcSetQuery Comment Events.
**
**	Returns: Number of lines that should be skipped before scanning
**		for another event starts again.
*/
DWORD
HandleBeginProcSetQuery(
	PJR		pjr,
	PSZ		dummy
)
{
	DICT_RECORD QDict;
	PQR			pqr = pjr->job_pQr;
	DWORD		rc;

	DBGPRINT(("Enter HandleBeginProcSetQuery\n"));

	//
	// the dictionary the job is looking for determines what
	// client version the job originated from.
	//
	FindDictVer(&QDict);

	//
	// if we are a 5.2 client, then reset this to be a PSTODIB job
	//
	if ((_stricmp(QDict.name, MDNAME) == 0) &&
		(_stricmp(QDict.version, CHOOSER_52) == 0))
	{
		DBGPRINT(("a 5.2 client - we do not support him\n"));
		rc = ERROR_NOT_SUPPORTED;
	}
	else
	{
		// we don't cache any other dictionaries, so tell client we
		// don't have it
		rc = TellClient(pjr,
						pjr->EOFRecvd,
						PROCSETMISSINGRESPONSE,
						strlen(PROCSETMISSINGRESPONSE));
	}

	return rc;
}


/*
**
** HandleBeginFontQuery()
**
**	Purpose: Handles BeginFontQuery Comment Events.
**
**	Returns: PAPWrite Error Codes
**
*/
DWORD
HandleBeginFontQuery(
	PJR		pjr,
	PSZ		ps
)
{
	PQR		pqr = pjr->job_pQr;
	CHAR	response[PSLEN + 3];
	LPSTR	pszResponseFont = response;
	DWORD	cbResponseUsed = 0;
	LPSTR	requestedFont = NULL;
	DWORD	len= 0;
	DWORD	rc = NO_ERROR;

	DBGPRINT(("Enter HandleBeginFontQuery\n"));

	do
	{
		// parse out the fontname list
		requestedFont= strtok(NULL,"\n");

		if (NULL == requestedFont)
		{
			rc = (DWORD)-1;	// Special error code to indicate we want default handling
			break;
		}

		len = strlen(requestedFont);

		DBGPRINT(("requesting font list:%s. Length: %d\n", requestedFont, len));

		// Mac will request status on a list of fonts separated by spaces.
		// for each font we respond with /fontname:yes or /fontname:no and
		// bundle this response into one write
		requestedFont = strtok(requestedFont, " ");
		while (requestedFont != NULL)
		{
			DBGPRINT(("looking for font:%s\n", requestedFont));

			// enough space for response?
			if (PSLEN < (cbResponseUsed + strlen(requestedFont) + sizeof(":yes ")))
			{
				DBGPRINT(("out of space for response\n"));
				break;
			}

			if (IsFontAvailable(pqr, requestedFont))
			{
				sprintf(pszResponseFont, "/%s:Yes\x0a", requestedFont);
			}
			else
			{
				sprintf(pszResponseFont, "/%s:No\x0a", requestedFont);
			}

			cbResponseUsed += strlen(pszResponseFont);
			pszResponseFont += strlen(pszResponseFont);
			requestedFont = strtok(NULL, " ");
		}
	} while (FALSE);

	strcpy (pszResponseFont, "*\x0a");

	if (NO_ERROR == rc)
	{
		DBGPRINT(("responding with:%s", response));
		rc = TellClient(pjr, pjr->EOFRecvd, response, strlen(response));
	}

	return rc;
}




BOOL
IsFontAvailable(
	PQR		pqr,
	LPSTR	pszFontName
)
{
	BOOL			rc = FALSE;
	DWORD			i;
	PFR			 	fontPtr;
	HANDLE		 	hFontQuery = INVALID_HANDLE_VALUE;
	DWORD			cFonts;
	DWORD			dummy;
	CHAR			pszFont[PPDLEN + 1];
	DWORD			cbFont = 0;
	DWORD			err;

	DBGPRINT(("enter IsFontAvailable\n"));

	do
	{
		//
		// fonts for Postscript queues different than for PSTODIB queues
		//

		if (!wcscmp(pqr->pDataType, MACPS_DATATYPE_RAW))
		{
			//
			// do a PostScript queue font search
			//

			DBGPRINT(("starting font search on PostScript queue\n"));

			for (i = 0, fontPtr = pqr->fonts; i <= pqr->MaxFontIndex; i++, fontPtr++)
			{
				if (!_stricmp(pszFontName, fontPtr->name))
				{
					DBGPRINT(("found the font\n"));
					rc = TRUE;
					break;
				}
			}
		}
		else
		{
			//
			// do a PSTODIB font search
			//
			DBGPRINT(("starting font search on PSTODIB queue\n"));

			if (PS_QFONT_SUCCESS != (PsBeginFontQuery(&hFontQuery)))
			{
				DBGPRINT(("PsBeginFontQuery fails\n"));
				hFontQuery = INVALID_HANDLE_VALUE;
				break;
			}

			if (PS_QFONT_SUCCESS != (PsGetNumFontsAvailable(hFontQuery, &cFonts)))
			{
				DBGPRINT(("psGetNumFontsAvailable fails\n"));
				break;
			}

			for (i = 0; i < cFonts; i++)
			{
				cbFont = PPDLEN + 1;
				dummy = 0;
				err = PsGetFontInfo(hFontQuery, i, pszFont, &cbFont, NULL, &dummy);
				if (PS_QFONT_SUCCESS != err)
				{
					DBGPRINT(("PsGetFontInfo fails with %d\n", err));
					break;
				}

				if (0 == _stricmp(pszFontName, pszFont))
				{
					DBGPRINT(("found the font\n"));
					rc = TRUE;
					break;
				}
			}
		}
	} while (FALSE);

	if (INVALID_HANDLE_VALUE != hFontQuery)
	{
		PsEndFontQuery(hFontQuery);
	}

	return rc;
}


/*
**
** HandleEndPrinterQuery()
**
**	Purpose: Handles EndPrinterQuery Comment Events.
**
*/
DWORD
HandleEndPrinterQuery(
	PJR		pjr
)
{
	char	reply[PSLEN+1];
	PQR		QPtr = pjr->job_pQr;

	DBGPRINT(("Enter HandleEndPrinterQuery\n"));

	/* respond with revision number, version and product */
	sprintf(reply, "%s\n(%s)\n(%s)\n", QPtr->Revision, QPtr->Version, QPtr->Product);

	/* respond to the client */
	return (TellClient(pjr, pjr->EOFRecvd, reply, strlen(reply)));
}


/*
** HandleBeginXQuery()
**
**	Purpose: Handles BeginQuery Comment Events.
*/
void
HandleBeginXQuery(
	PJR		pjr,
	PSZ		string
)
{
	DBGPRINT(("BeginQuery: %s\n", string));
	strcpy(pjr->JSKeyWord, string);
	pjr->InProgress=QUERYDEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\h\helpnums.h ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    HelpNums.h

    Help context manifests for the MPR dialogs

    FILE HISTORY:
	JohnL	23-Jan-1992	Created
        Yi-HsinS25-Aug-1992     Base off HC_UI_MPR_BASE

*/

#ifndef _HELPNUMS_H_
#define _HELPNUMS_H_

#include <uihelp.h>

//
// Help Contexts for various dialogs
//

#define HC_RECONNECTDIALOG_ERROR     (HC_UI_MPR_BASE+8) // Do you wish to continue

// 
// Help Contexts for MsgPopups
//
#define HC_CONNECT_ERROR             (HC_UI_MPR_BASE+105) // IERR_ProfileLoadError

//
// Context-sensitive help constants
//
#define IDH_PASSWORD                 1000

#endif //_HELPNUMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\h\mprconn.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    MPRConn.h

    This file contains the MPR Connection dialog manifests

    FILE HISTORY:
        Johnl   09-Jan-1992     Commented
        CongpaY Nov-4-1992      Add more defines.
        dsheldon 20-Mar-1998    Chopped out map net drives wizard stuff - now in
                                private\shell\ext\netplwiz.
*/

#ifndef _MPRCONN_H_
#define _MPRCONN_H_

#include <windows.h>        // basic windows functionality
#include <uimsg.h>


/* Message IDSs
 */
#define IDS_WN_EXTENDED_ERROR                   (IDS_UI_MPR_BASE+1)
#define IERR_ProfileLoadError                   (IDS_UI_MPR_BASE+3)
#define IERR_TEXT1                              (IDS_UI_MPR_BASE+4)
#define IERR_TEXT2                              (IDS_UI_MPR_BASE+5)
#define IERR_TEXT3                              (IDS_UI_MPR_BASE+6)
#define IERR_CANNOT_SET_EXPANDLOGONDOMAIN       (IDS_UI_MPR_BASE+7)
#define IERR_INVALID_PATH                       (IDS_UI_MPR_BASE+8)

#define IDS_BROWSE_DRIVE_CAPTION                (IDS_UI_MPR_BASE+51)
#define IDS_BROWSE_PRINTER_CAPTION              (IDS_UI_MPR_BASE+52)
#define IDS_SERVERS_LISTBOX_DRIVE               (IDS_UI_MPR_BASE+59)
#define IDS_SERVERS_LISTBOX_PRINTER             (IDS_UI_MPR_BASE+60)

#define IDS_DEVICELESS_CONNECTION_NAME          (IDS_UI_MPR_BASE+61)
#define IDS_OPENFILES_WITH_NAME_WARNING         (IDS_UI_MPR_BASE+64)

#define IDS_MPRHELPFILENAME                     (IDS_UI_MPR_BASE+67)
#define IDS_NO_PASSWORD                         (IDS_UI_MPR_BASE+69)
#define IDS_GETTING_INFO                        (IDS_UI_MPR_BASE+70)
#define IDS_PASSWORD                            (IDS_UI_MPR_BASE+71)
#define IDS_ACCOUNT_DISABLED                    (IDS_UI_MPR_BASE+72)


/* Dialog IDDs
 */
#define IDD_NET_BROWSE_DIALOG        7004

#define IDD_RESOURCE                 7010
#define IDD_PASSWORD                 7011
#define IDD_USERNAME                 7012
#define IDD_PASSWORD_TEXT            7013


#define IDD_RECONNECT_DLG            7015
#define IDD_TEXT                     7016

#define IDD_ERROR_DLG                7020
#define IDD_CHKCANCELCONNECTION      7021
#define IDD_ERRORWITHCANCEL_DLG      7022
#define IDD_TEXT1                    7023
#define IDD_TEXT2                    7024
#define IDD_TEXT3                    7025
#define IDD_CHKHIDEERRORS            7026

#define IDC_MPR_BASE                 4096

/* Control IDCs
 */
#define IDC_NETPATH_CONTROL             (IDC_MPR_BASE+4 )
#define IDC_CHECKBOX_EXPANDLOGONDOMAIN  (IDC_MPR_BASE+6 )
#define IDC_SLT_SHOW_LB_TITLE           (IDC_MPR_BASE+9 )
#define IDC_BUTTON_SEARCH               (IDC_MPR_BASE+10)

#define IDC_NET_SHOW                    (IDC_MPR_BASE+20)
#define IDC_COL_SHOWLB_INDENT           (IDC_MPR_BASE+21)
#define IDC_COL_SHOWLB_BITMAP           (IDC_MPR_BASE+22)
#define IDC_COL_SHOWLB_RESNAME          (IDC_MPR_BASE+23)
#define IDC_COL_SHOWLB_COMMENT          (IDC_MPR_BASE+24)
#define IDC_SLE_GETINFO_TEXT            (IDC_MPR_BASE+25)

/* Icons
 */

/* The following manifests define the BITMAP names used by the browse
 * dialogs.
 * They are meant to be used with the DISPLAY_MAP class (they have a green
 * border for that represents the transparent color).
 */
#define BMID_PRINTER                 7001
#define BMID_PRINTER_UNAVAIL         7002
#define BMID_SHARE                   7003
#define BMID_SHARE_UNAVAIL           7004
#define BMID_NOSUCH                  7005

#define BMID_BROWSE_GEN              7010
#define BMID_BROWSE_GENEX            7011
#define BMID_BROWSE_GENNOX           7012
#define BMID_BROWSE_PROV             7025
#define BMID_BROWSE_PROVEX           7026
#define BMID_BROWSE_SHR              7013
#define BMID_BROWSE_SHREX            7014
#define BMID_BROWSE_SHRNOX           7015
#define BMID_BROWSE_SRV              7016
#define BMID_BROWSE_SRVEX            7017
#define BMID_BROWSE_SRVNOX           7018
#define BMID_BROWSE_DOM              7019
#define BMID_BROWSE_DOMEX            7020
#define BMID_BROWSE_DOMNOX           7021
#define BMID_BROWSE_PRINT            7022
#define BMID_BROWSE_PRINTEX          7023
#define BMID_BROWSE_PRINTNOX         7027
#define BMID_BROWSE_FILE             7028
#define BMID_BROWSE_FILEEX           7029
#define BMID_BROWSE_FILENOX          7030
#define BMID_BROWSE_GROUP            7031
#define BMID_BROWSE_GROUPEX          7032
#define BMID_BROWSE_GROUPNOX         7033
#define BMID_BROWSE_TREE             7034
#define BMID_BROWSE_TREEEX           7035
#define BMID_BROWSE_TREENOX          7036


#endif //_MPRCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\mprui\mpr\dlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dlg.cxx
        It contains the WNetConnectionDialog source.

    FILE HISTORY:
        kevinl     31-Dec-91       Created
        terryk     03-Jan-92       capitalize the manifest
        Johnl      10-Jan-1992     Cleaned up
        BruceFo    23-May-1995     Add WNetConnectionDialog1 support

*/

#define INCL_NETCONS
#define INCL_NETCONFIG
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <dbgstr.hxx>

#include <mprconn.h>
#include <mprmisc.hxx>
#include <mprbrows.hxx>
#include <shellapi.h>
#include <shlapip.h>

extern "C"
{
    #include <uigenhlp.h>
}
#include <wfext.h>

#include <fmx.hxx>

#define THIS_DLL_NAME   SZ("mprui.dll")


APIERR
InitBrowsing(
    VOID
    );

/*******************************************************************

    NAME:       InitBrowsing

    SYNOPSIS:   Internal API for initializing browsing

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      The MprBrowseDialog and MprConnectionDialog has
                a second worker thread. In order to prevent
                the dll from unloading itself while the worker
                thread is still active, we need to do a loadlibrary
                on the current dll.

    HISTORY:
        YiHsins         21-Mar-1993     Created

********************************************************************/

APIERR InitBrowsing( VOID )
{
    static BOOL fLoadedCurrentDll = FALSE;
    if ( !fLoadedCurrentDll )
    {
        HANDLE handle = ::LoadLibraryEx( THIS_DLL_NAME,
                                         NULL,
                                         LOAD_WITH_ALTERED_SEARCH_PATH );
        if ( handle == NULL )
            return ::GetLastError();
        fLoadedCurrentDll = TRUE;
    }

    return NERR_Success;
}

/*******************************************************************

    NAME:       MPRUI_WNetDisconnectDialog

    SYNOPSIS:   Private API for the file manager disconnect dialog

    ENTRY:      hwnd - Parent window handle suitable for hosting a dialog
                dwType - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpHelpFile - helpfile to use on Help Button
                nHelpContext - to pass to WinHelp on Help button


    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   22-Jan-1992     Commented, fixed
        beng    31-Mar-1992     Unicode mumble

********************************************************************/

DWORD
MPRUI_WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    )
{
    AUTO_CURSOR cursHourGlass ;
    DEVICE_TYPE devType ;
    switch ( dwType )
    {
    case RESOURCETYPE_DISK:
        devType = DEV_TYPE_DISK ;
        break ;

    // Allow Disk only
    case RESOURCETYPE_PRINT:
    default:
        return WN_BAD_VALUE ;
    }

    //
    // Call into netplwiz for the real dialog
    //

    return SHDisconnectNetDrives(hwnd);
}


/*******************************************************************

    NAME:       WNetBrowsePrinterDialog

    SYNOPSIS:

    ENTRY:      hwnd     - Parent window handle suitable for hosting a dialog
                lpszName - place to store the name chosen
                nNameLength - number of characters in the buffer lpszName
                lpszHelpFile    - helpfile to use on Help Button
                nHelpContext    - to pass to WinHelp on Help button
                pfuncValidation - callback function to validate the name chosen
                                  by the user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS   12-Nov-1992     Created

********************************************************************/

DWORD WNetBrowsePrinterDialog( HWND   hwnd,
                               WCHAR *lpszName,
                               DWORD  nNameLength,
                               WCHAR *lpszHelpFile,
                               DWORD  nHelpContext,
                               PFUNC_VALIDATION_CALLBACK pfuncValidation )
{
    return WNetBrowseDialog( hwnd,
                             RESOURCETYPE_PRINT,
                             lpszName,
                             nNameLength,
                             lpszHelpFile,
                             nHelpContext,
                             pfuncValidation );
}

/*******************************************************************

    NAME:       WNetBrowseDialog

    SYNOPSIS:

    ENTRY:      hwnd     - Parent window handle suitable for hosting a dialog
                dwType   - one of RESOURCETYPE_DISK or RESOURCETYPE_PRINT
                lpszName - place to store the name chosen
                nNameLength - number of characters in the buffer lpszName
                lpszHelpFile    - helpfile to use on Help Button
                nHelpContext    - to pass to WinHelp on Help button
                pfuncValidation - callback function to validate the name chosen
                                  by the user

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS   12-Nov-1992     Created

********************************************************************/

DWORD WNetBrowseDialog( HWND   hwnd,
                        DWORD  dwType,
                        WCHAR *lpszName,
                        DWORD  nNameLength,
                        WCHAR *lpszHelpFile,
                        DWORD  nHelpContext,
                        PFUNC_VALIDATION_CALLBACK pfuncValidation )
{
    if ( lpszName == NULL || lpszHelpFile == NULL  || nNameLength <= 0 )
        return WN_BAD_VALUE;

    *lpszName = 0;
    *(lpszName + (nNameLength - 1)) = 0;

    AUTO_CURSOR cursHourGlass ;
    DEVICE_TYPE devType ;
    switch ( dwType )
    {
    case RESOURCETYPE_DISK:
        devType = DEV_TYPE_DISK;
        break ;

    case RESOURCETYPE_PRINT:
        devType = DEV_TYPE_PRINT;
        break;

    default:
        return WN_BAD_VALUE ;
    }


    NLS_STR nlsName;
    APIERR err = nlsName.QueryError();
    if ( err != NERR_Success )
        return err;

    err = InitBrowsing();
    if ( err != NERR_Success )
        return err;

    MPR_BROWSE_DIALOG * pbrowsedlg = new MPR_BROWSE_DIALOG( hwnd,
                                                            devType,
                                                            lpszHelpFile,
                                                            nHelpContext,
                                                            &nlsName,
           