HS->pErrInfo->NamErr.extendedData;
        pErrInfo->NamErr.problem = pTHS->pErrInfo->NamErr.problem;
        // Note: Not deep copied, no need.
        pErrInfo->NamErr.pMatched = pTHS->pErrInfo->NamErr.pMatched;
        break;

    case referralError:
        pErrInfo->RefErr.dsid = pTHS->pErrInfo->RefErr.dsid;
        pErrInfo->RefErr.extendedErr = pTHS->pErrInfo->RefErr.extendedErr;
        pErrInfo->RefErr.extendedData = pTHS->pErrInfo->RefErr.extendedData;

        pContRef = &pTHS->pErrInfo->RefErr.Refer;
        pContRefDest = &pErrInfo->RefErr.Refer;
        while(pContRef){
            
            // First copy all the elements.
            // Note: Not deep copied, no need.
            pContRefDest->pTarget = pContRef->pTarget;
                // Indented for clarity, copy OpState
                pContRefDest->OpState.nameRes = pContRef->OpState.nameRes;
                pContRefDest->OpState.unusedPad = pContRef->OpState.unusedPad;
                pContRefDest->OpState.nextRDN = pContRef->OpState.nextRDN;
            pContRefDest->aliasRDN = pContRef->aliasRDN;
            pContRefDest->RDNsInternal = pContRef->RDNsInternal;
            pContRefDest->refType = pContRef->refType;
            pContRefDest->count = pContRef->count;

            for(i = 0, pDAL = pContRef->pDAL;
                (i < pContRef->count) && pDAL;
                i++, pDAL = pDAL->pNextAddress){

                pDALTemp = pDALDest;
                pDALDest = THAllocEx(pTHS, sizeof(DSA_ADDRESS_LIST_DRS_WIRE_V1));
                if(i == 0){
                    // Must put the first one in the ContRef.
                    pContRefDest->pDAL = pDALDest;
                } else {
                    // Must use pDALTemp to build pDAL's in order.
                    pDALTemp->pNextAddress = pDALDest;
                }

                // Note: Not deep copied, no need.  Also note that
                // we didn't pack the original DSA_ADDRESS || UNICODE_STRING
                // in the data structure and left as a pointer for eash of 
                // creating a marshleable structure.
                pDALDest->pAddress = &pDAL->Address;

            }
            Assert(i == pContRef->count);
            // We DO _NOT_ want to copy this very complicated structure
            // if we can help it.  I don't think we need this for our
            // purposes today, so I'll pass the buck.  Further, I don't 
            // think this we will ever have a filter from a referral
            // for trying to add an object to the Partitions container.
            //   So we'll set it to NULL and Assert it is NULL.
            Assert(pContRef->pNewFilter == NULL);
            // There is no pNewFilter attribute, but might be added in the
            // next version of the error state packing function.
            // pContRefDest->pNewFilter = NULL;
            pContRefDest->bNewChoice = pContRef->bNewChoice;
            // Who cares if bNewChoise is TRUE we'll copy this anyway.
            pContRefDest->choice = pContRef->choice;

            // Second if there's a next guy, allocate room for him, and continue.
            if(pContRef->pNextContRef){
                pContRefDest->pNextContRef = THAllocEx(pTHS, sizeof(CONTREF_DRS_WIRE_V1));
            } else {
                pContRefDest->pNextContRef = NULL;
            }
            pContRef = pContRef->pNextContRef;
        }
        break;

    case securityError:
        pErrInfo->SecErr.dsid = pTHS->pErrInfo->SecErr.dsid;
        pErrInfo->SecErr.extendedErr = pTHS->pErrInfo->SecErr.extendedErr;
        pErrInfo->SecErr.extendedData = pTHS->pErrInfo->SecErr.extendedData;
        pErrInfo->SecErr.problem = pTHS->pErrInfo->SecErr.problem;
        break;

    case serviceError:
        pErrInfo->SvcErr.dsid = pTHS->pErrInfo->SvcErr.dsid;
        pErrInfo->SvcErr.extendedErr = pTHS->pErrInfo->SvcErr.extendedErr;
        pErrInfo->SvcErr.extendedData = pTHS->pErrInfo->SvcErr.extendedData;
        pErrInfo->SvcErr.problem = pTHS->pErrInfo->SvcErr.problem;
        break;

    case updError:
        pErrInfo->UpdErr.dsid = pTHS->pErrInfo->UpdErr.dsid;
        pErrInfo->UpdErr.extendedErr = pTHS->pErrInfo->UpdErr.extendedErr;
        pErrInfo->UpdErr.extendedData = pTHS->pErrInfo->UpdErr.extendedData;
        pErrInfo->UpdErr.problem = pTHS->pErrInfo->UpdErr.problem;
        break;

    case systemError:     
        pErrInfo->SysErr.dsid = pTHS->pErrInfo->SysErr.dsid;
        pErrInfo->SysErr.extendedErr = pTHS->pErrInfo->SysErr.extendedErr;
        pErrInfo->SysErr.extendedData = pTHS->pErrInfo->SysErr.extendedData;
        pErrInfo->SysErr.problem = pTHS->pErrInfo->SysErr.problem;
        break;

    default:
        Assert(!"New error type someone update draXlateThDirErrToWireDirErr() & draXlateWireDirErrToThDirErr routines");
        DRA_EXCEPT (ERROR_DS_CODE_INCONSISTENCY, 0);
    }

    return;
}

void
draXlateWireDirErrToThDirErr(
              IN     DWORD                 errCode,
              IN     DIRERR_DRS_WIRE_V1 *  pErrInfo,
    OPTIONAL  IN     DWORD                 dwOptErr,
              IN OUT THSTATE *             pTHS
    )
/*++

Routine Description:

    This is a helper function to draDecodeDraErrorDataAndSetThError(),
    to decode and fill in the pErrInfo potion of the thread state error
    only.

    Changes to this function should be accompained by changes to her
    sister fuctnion draXlateThDirErrToWireDirErr()

    BUGBUG: pNewFilter in the AtrErr is the only thing not transfered,
    if someone ever needs this functionality I suggest they add it.  It
    would complete the robustness of this routine

Arguments:

    errCode [IN] - The errCode (serviceError, attributeError,
        etc) from the wire error info. Set by the remote server.
    pErrInfo [IN] - The thread error state from the wire error
        info.  Set by the remote server.  
    dwOptErr [IN] - (Optional) This allows the caller to specify
        a more useful user error in the extendedError of the 
        operation.  In this case the existing extendedError is 
        moved to the extendedData field and the original
        extendedData field is lost.  If this param is 0, then
        the thread state error is propogated perfectly.
    pTHS - This is really the out parameter, because we store the
        thread error state in pTHS->pErrInfo.

Return Value:

    None

--*/
{
    PROBLEMLIST *                    pAttrProbListDest;
    PROBLEMLIST_DRS_WIRE_V1 *        pAttrProbList;
    CONTREF *                        pContRefDest;
    CONTREF_DRS_WIRE_V1 *            pContRef;
    DSA_ADDRESS_LIST *               pDALDest = NULL;
    DSA_ADDRESS_LIST *               pDALTemp = NULL;
    DSA_ADDRESS_LIST_DRS_WIRE_V1 *   pDAL;
    
    ULONG    i;

    Assert(pTHS);
    Assert(errCode);
    Assert(pErrInfo);
    Assert(pTHS->pErrInfo);

    switch(errCode){
    case attributeError:
        // Note: Not deep copied, no need.
        pTHS->pErrInfo->AtrErr.pObject = pErrInfo->AtrErr.pObject;
        pTHS->pErrInfo->AtrErr.count = pErrInfo->AtrErr.count;
        
        Assert(pErrInfo->AtrErr.count != 0);
        pAttrProbList = &pErrInfo->AtrErr.FirstProblem;
        pAttrProbListDest = &pTHS->pErrInfo->AtrErr.FirstProblem;
        // Copy the list of problems
        for(i = 0; i < pErrInfo->AtrErr.count; i++){

            if (pAttrProbList == NULL || pAttrProbListDest == NULL) {
                // Something went tragically wrong, because the count doesn't match the 
                // number of pNextProblem's
                Assert(!"Has this packet been messed with?");
                // This error path still has potential to leak memory, despite this THFree.
                THFreeEx(pTHS, pTHS->pErrInfo); 
                SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                            ERROR_DS_CODE_INCONSISTENCY);
            }

            // First copy over all the individual elements.
            pAttrProbListDest->intprob.dsid = pAttrProbList->intprob.dsid;
            if (dwOptErr) {
                pAttrProbListDest->intprob.extendedErr = dwOptErr;
                pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedErr;
            } else {                                              
                pAttrProbListDest->intprob.extendedErr = pAttrProbList->intprob.extendedErr;
                pAttrProbListDest->intprob.extendedData = pAttrProbList->intprob.extendedData;
            }
            pAttrProbListDest->intprob.problem = pAttrProbList->intprob.problem;
            pAttrProbListDest->intprob.type = pAttrProbList->intprob.type;
            pAttrProbListDest->intprob.valReturned = pAttrProbList->intprob.valReturned;
            if(pAttrProbList->intprob.valReturned){
                pAttrProbListDest->intprob.Val.valLen = pAttrProbList->intprob.Val.valLen;
                // Note: Not deep copied, no need.
                pAttrProbListDest->intprob.Val.pVal = pAttrProbList->intprob.Val.pVal;
            }

            // Second continue to the next problem if there is one.
            if(pAttrProbList->pNextProblem){
                // There is a next problem.
                Assert(i < (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = (PROBLEMLIST *) THAllocEx(pTHS, sizeof(PROBLEMLIST));
                pAttrProbListDest = pAttrProbListDest->pNextProblem;
            } else {
                // No more problems, NULL terminate linked list.
                Assert(i == (pErrInfo->AtrErr.count-1));
                pAttrProbListDest->pNextProblem = NULL;
            }
        }
        break;

    case nameError:
        pTHS->pErrInfo->NamErr.dsid = pErrInfo->NamErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->NamErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->NamErr.extendedData = pErrInfo->NamErr.extendedErr;
        } else {
            pTHS->pErrInfo->NamErr.extendedErr = pErrInfo->NamErr.extendedErr;
            pTHS->pErrInfo->NamErr.extendedData = pErrInfo->NamErr.extendedData;
        }
        pTHS->pErrInfo->NamErr.problem = pErrInfo->NamErr.problem;
        // Note: Not deep copied, no need.
        pTHS->pErrInfo->NamErr.pMatched = pErrInfo->NamErr.pMatched;
        break;

    case referralError:
        pTHS->pErrInfo->RefErr.dsid = pErrInfo->RefErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->RefErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->RefErr.extendedData = pErrInfo->RefErr.extendedErr;
        } else {
            pTHS->pErrInfo->RefErr.extendedErr = pErrInfo->RefErr.extendedErr;
            pTHS->pErrInfo->RefErr.extendedData = pErrInfo->RefErr.extendedData;
        }

        pContRef = &pErrInfo->RefErr.Refer;
        pContRefDest = &pTHS->pErrInfo->RefErr.Refer;
        while(pContRef){

            // First copy all the elements.
            // Note: Not deep copied, no need.
            pContRefDest->pTarget = pContRef->pTarget;
                // indented for clarity, copy OpState
                pContRefDest->OpState.nameRes = pContRef->OpState.nameRes;
                pContRefDest->OpState.unusedPad = pContRef->OpState.unusedPad;
                pContRefDest->OpState.nextRDN = pContRef->OpState.nextRDN;
            pContRefDest->aliasRDN = pContRef->aliasRDN;
            pContRefDest->RDNsInternal = pContRef->RDNsInternal;
            pContRefDest->refType = pContRef->refType;
            pContRefDest->count = pContRef->count;

            for(i = 0, pDAL = pContRef->pDAL;
                (i < pContRef->count) && pDAL;
                i++, pDAL = pDAL->pNextAddress){

                pDALTemp = pDALDest;
                pDALDest = (DSA_ADDRESS_LIST *) THAllocEx(pTHS, 
                                     sizeof(DSA_ADDRESS_LIST));
                if(i == 0){
                    // Must be the first one in the ContRef.
                    pContRefDest->pDAL = pDALDest;
                } else {
                    // Must use pDALTemp to build the pDAL's in order.
                    pDALTemp->pNextAddress = pDALDest;
                }

                // Copy the Address UNICODE_STRING structure.
                pDALDest->Address.Buffer = (WCHAR *) THAllocEx(pTHS, pDAL->pAddress->Length + sizeof(UNICODE_NULL));
                pDALDest->Address.Length = pDAL->pAddress->Length;
                pDALDest->Address.MaximumLength = pDAL->pAddress->MaximumLength;
                memcpy(pDALDest->Address.Buffer, 
                       pDAL->pAddress->Buffer,
                       pDAL->pAddress->Length);
                       
            } // End of For each DSA_ADDRESS structure.

            Assert(i == pContRef->count);
            // We DO _NOT_ want to copy this very complicated structure
            // if we can help it.  I don't think we need this for our
            // purposes today, so I'll pass the buck.  Further, I don't 
            // think this we will ever have a filter from a referral
            // for trying to add an object to the Partitions container.
            //   So we'll set it to NULL.  It wasn't even packed up
            //   on the other side in draXlateThDirErrToWireDirErr().
            pContRefDest->pNewFilter = NULL;
            pContRefDest->bNewChoice = pContRef->bNewChoice;
            // who cares if bNewChoice is TRUE we'll copy this anyway.
            pContRefDest->choice = pContRef->choice;

            // Second if there's a next guy, allocate room for him, and continue.
            if(pContRef->pNextContRef){
                pContRefDest->pNextContRef = (CONTREF *) THAllocEx(pTHS, sizeof(CONTREF));
            } else {
                pContRefDest->pNextContRef = NULL;
            }
            pContRef = pContRef->pNextContRef;
        } // Wnd while We still have Referral structures to copy.

        break;

    case securityError:
        pTHS->pErrInfo->SecErr.dsid = pErrInfo->SecErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SecErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SecErr.extendedData = pErrInfo->SecErr.extendedErr;
        } else {
            pTHS->pErrInfo->SecErr.extendedErr = pErrInfo->SecErr.extendedErr;
            pTHS->pErrInfo->SecErr.extendedData = pErrInfo->SecErr.extendedData;
        }
        pTHS->pErrInfo->SecErr.problem = pErrInfo->SecErr.problem;
        break;

    case serviceError:
        pTHS->pErrInfo->SvcErr.dsid = pErrInfo->SvcErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SvcErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SvcErr.extendedData = pErrInfo->SvcErr.extendedErr;
        } else {
            pTHS->pErrInfo->SvcErr.extendedErr = pErrInfo->SvcErr.extendedErr;
            pTHS->pErrInfo->SvcErr.extendedData = pErrInfo->SvcErr.extendedData;
        }
        pTHS->pErrInfo->SvcErr.problem = pErrInfo->SvcErr.problem;
        break;

    case updError:
        pTHS->pErrInfo->UpdErr.dsid = pErrInfo->UpdErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->UpdErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->UpdErr.extendedData = pErrInfo->UpdErr.extendedErr;
        } else {
            pTHS->pErrInfo->UpdErr.extendedErr = pErrInfo->UpdErr.extendedErr;
            pTHS->pErrInfo->UpdErr.extendedData = pErrInfo->UpdErr.extendedData;
        }
        pTHS->pErrInfo->UpdErr.problem = pErrInfo->UpdErr.problem;
        break;

    case systemError:
        pTHS->pErrInfo->SysErr.dsid = pErrInfo->SysErr.dsid;
        if (dwOptErr) {
            pTHS->pErrInfo->SysErr.extendedErr = dwOptErr;
            pTHS->pErrInfo->SysErr.extendedData = pErrInfo->SysErr.extendedErr;
        } else {
            pTHS->pErrInfo->SysErr.extendedErr = pErrInfo->SysErr.extendedErr;
            pTHS->pErrInfo->SysErr.extendedData = pErrInfo->SysErr.extendedData;
        }
        pTHS->pErrInfo->SysErr.problem = pErrInfo->SysErr.problem;
        break;

    default:
        Assert(!"New error type someone update draXlateThDirErrToWireDirErr() & draXlateWireDirErrToThDirErr()\n");
    }

}



////////////////////////////////////////////////////////////////////////////////
//
//  ERROR ENCODE / DECODE FUNCTIONS (PUBLIC FUNCTIONS)
//


void
draEncodeError(
    OPTIONAL IN  THSTATE *                  pTHS,      // For Dir* error info
    OPTIONAL IN  DWORD                      ulRepErr,  // DRS error
             OUT DWORD *                    pdwErrVer,
             OUT DRS_ERROR_DATA **          ppErrData  // Out Message
    )
/*++

Routine Description:

    This is the public function for packing up the thread error and
    replication error state set by whatever operation just proceeded.
    Anyone who wants to send the thread error state across the wire,
    can use this function for that purpose.  The function will set
    success error data if there is no error.  This error data is 
    intended to be used by it's sister function, 
    draDecodeDraErrorDataAndSetThError().

    NOTE: about the contract between the Encode/Decode functions.
    // This sets the success/error state of the AddEntry reply message
    // This data _MUST_ in V1 include:
    //    *pdwErrVer = 1;
    //    pErrData = allocated memory if pTHS is non-NULL
    //    pErrData->V1.dwRepError = <error || 0>;
    //    pErrData->V1.errCode = <thread prob (1-7) || 0>;
    //    pErrData->V1.pErrInfo = if(pErrData->V1.errCode != 0) allocated memory
    // If we couldn't allocate even enough memory for pErrData or the
    //   thread state (pTHS) was NULL, then *pErrData will be NULL
    // If we couldn't allocate the thread state error, or the thread
    //   state error was inconsistent, then we put an error in dwRepError,
    //   set pErrData->V1.errCode to 0, and pErrData->V1.pErrInfo to NULL.

Arguments:

    pTHS [IN] - This is used both for allocating memory, and for 
        grabbing the thread error state (pTHS->errCode & pTHS->pErrInfo).
        This may be NULL, in the case where we haven't even been able
        to init a thread state.
    ulRepErr [IN] - This is the optional replication operation error,
        such as Version of RPC call/message not supported, no memory,
        invalid parameter.
    pdwErrVer [OUT] - The version of the error data to set.  Note that
        whatever version you set, you need to make sure that the client
        side draDecodeDraErrorDataAndSetThError() will be able to under-
        stand it.  This is usually done with DRS_EXT_ bits.
    ppErrData [OUT] - The pointer to put the allocated memory for the
        error data in.  If we can't allocate the memory, because pTHS
        is NULL or there is no memory, then *ppErrData must equal NULL,
        to indicate a serious error to the sister function.

Return Value:

    None

--*/
{
    DRS_ERROR_DATA *                    pErrData = NULL;
    ULONG                               dwException, ulErrorCode, dsid;
    PVOID                               dwEA;

    Assert(pdwErrVer);
    Assert(ppErrData);

    // This function should be called for only version 1 of the error
    // data.
    *pdwErrVer = 1;
    *ppErrData = NULL;

    if(pTHS){ 

        __try {

            // Allocate space for the error data.
            pErrData = THAllocEx(pTHS, sizeof(DRS_ERROR_DATA_V1));

            // Set the output param.
            *ppErrData = pErrData;

            // We've got room to pack up the error state.
            // Set Replication Error/Success value.
            pErrData->V1.dwRepError = ulRepErr;
            // Set Thread State Error/Success value.
            pErrData->V1.errCode = pTHS->errCode;
            if (pTHS->errCode) {

                //
                // Set this only on a thread state error being present.
                //

                if ( pTHS->pErrInfo == NULL ) {
                    // Just want to be safe in case I don't understand the code for setting
                    // the error state info in src\mderror.c,
                    Assert(!"Any time pTHS->errCode is set, pTHS->pErrInfo shouldn't be NULL.");
                    DRA_EXCEPT (ERROR_DS_CODE_INCONSISTENCY, 0);
                } 

                // Looks like valid thread error state, allocate wire thread error info.
                pErrData->V1.pErrInfo = (DIRERR_DRS_WIRE_V1 *) THAllocEx(pTHS, sizeof(DIRERR_DRS_WIRE_V1));

                // Finally translate the thread error state to the wire version.
                draXlateThDirErrToWireDirErr(pTHS, pErrData->V1.errCode, pErrData->V1.pErrInfo);

            } // If pTHS->errCode set.

        } __except (GetExceptionData(GetExceptionInformation(), &dwException,
                       &dwEA, &ulErrorCode, &dsid)) {

              // Probably (should) fail with out of memory or code inconsistency.
              Assert(ulErrorCode == ERROR_NOT_ENOUGH_MEMORY ||
                     ulErrorCode == ERROR_DS_CODE_INCONSISTENCY);
              if(pErrData){
                  // Can't be sure about the thread state error, so kill
                  // the return(wire) thread error and return a dwRepError.
                  pErrData->V1.errCode = 0;
                  if(pErrData->V1.pErrInfo) { 
                      THFreeEx(pTHS, pErrData->V1.pErrInfo);
                  }
                  pErrData->V1.pErrInfo = NULL;
                  pErrData->V1.dwRepError = ulErrorCode;

              } // else no pErrData allocated, bail with *ppErrData = NULL,
                // indicate fatal error.

        } // End __except() there was a fatal error setting the error state 
       
    } // else no pTHS to allocate memory with, leave *ppErrData NULL to 
      // indicate fatal error.

    // Finally validate that this is valid.
    DPRINT1(1, "Returning error reply version = %ul\n", *pdwErrVer);
    Assert(*pdwErrVer == 1);

#if DBG
    if(pErrData){
         Assert(pErrData->V1.errCode == 0 || pErrData->V1.pErrInfo);
    }
#endif

}

void
draDecodeDraErrorDataAndSetThError(
              IN     DWORD                 dwVer,
              IN     DRS_ERROR_DATA *      pErrData,
    OPTIONAL  IN     DWORD                 dwOptionalError,
              IN OUT THSTATE *             pTHS
    )
/*++

Routine Description:

    This is the public function for unpacking the remote error
    state set by our sister function (draEncodeError()), and
    setting the thread error state for this thread.  
        
Arguments:

    dwVer [IN] - The version of the DRA/DRS error data being
        provided.  Currently only support for version 1 exists.
    pErrData [IN] - The actualy DRA/DRS error data being provided.
        This error state data consists of 3 things:
            dwRepError - The error set by the replication/DRA/DRS
                API on the remote side of the RPC call.  This is
                often if something went wrong such that we didn't
                even get to the part where we actually set the
                thread error state.
            errCode - This is the remote servers pTHS->errCode for
                the operation that we asked the server to perform.
            pErrInfo - This is a _WIRE_ version of the pTHS->pErrInfo
                thread error info for the operation that we asked
                the server to perform.
    dwOptErr [IN] - (Optional) This allows the caller to specify
        a more useful user error in the extendedError of the 
        operation.  In this case the existing extendedError is 
        moved to the extendedData field and the original
        extendedData field is lost.  If this param is 0, then
        the thread state error is propogated perfectly.
    pTHS [IN/OUT] - This is how we get at the error state that gets
        setup.

Return Value:

    None, 
    
    NOTE: though there is no return value, if there was some error
    info in the error data, then a thread state error will be set
    in pTHS.

--*/
{
    Assert(pTHS->errCode == 0);
    Assert(pErrData);
    
    if (dwVer != 1) {
        
        // Just in case, someone in the next version of WinXP messes up.
        Assert(dwVer == 1);
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_CODE_INCONSISTENCY);
        return;

    }
    if (pErrData == NULL) {

        // This means the the DRS_AddEntry call failed on the server because
        // the DC was shutting down or out of memory.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                    ERROR_DS_SERVER_DOWN);
        return;

    }

    // Set the thread state error depening on how we got the error.
    if(pErrData->V1.errCode){

        if(pErrData->V1.pErrInfo == NULL){
            Assert(!"Should never happen, RPC would've thrown an error, or remote side should've set a dwRepError.");
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED,
                        ERROR_DS_CODE_INCONSISTENCY);
            return;
        }
        // Got an error from the remote thread state error, crack it out
        // of the reply data and set the error.
        pTHS->errCode = pErrData->V1.errCode;
        pTHS->pErrInfo = (DIRERR *) THAllocEx(pTHS, sizeof(DIRERR));
        draXlateWireDirErrToThDirErr(pErrData->V1.errCode,
                                     pErrData->V1.pErrInfo,
                                     dwOptionalError,
                                     pTHS);

    } else if (pErrData->V1.dwRepError) {

        // Got a repl error from the remote repl API side, set an 
        // intelligent error.
        SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, 
                    pErrData->V1.dwRepError);

    } // else the operation was successful, don't set the thread state error.
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drainst.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drainst.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>			// schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>			// MD global definition header
#include <mdlocal.h>			// MD local definition header
#include <dsatools.h>			// needed for output allocation
#include <dsconfig.h>

// Logging headers.
#include "dsevent.h"			/* header Audit\Alert logging */
#include "mdcodes.h"			/* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"		/* Defines for selected classes and atts*/
#include "msrpc.h"
#include <errno.h>
#include "direrr.h"        /* header for error codes */
#include "dstaskq.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAINST:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drsdra.h"
#include "drancrep.h"
#include "usn.h"


#include <fileno.h>
#define  FILENO FILENO_DRAINST

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

BOOL IsDSA(DBPOS *pDB){

   ULONG            len;
   SYNTAX_OBJECT_ID Class;
   SYNTAX_OBJECT_ID *pClass=&Class;
   ULONG            NthValIndex=0;

   DPRINT(1,"IsDSA entered\n");


   while(!DBGetAttVal(pDB,++NthValIndex, ATT_OBJECT_CLASS,
                      DBGETATTVAL_fCONSTANT, sizeof(Class),
                      &len, (UCHAR **)&pClass)){

       if (CLASS_NTDS_DSA == Class){

           DPRINT(4,"DSA Object\n");
           return TRUE;
       }
   }/*while*/

   DPRINT(4,"Not a DSA Object\n");
   return FALSE;

}/*IsDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Validate that this is an internal master DSA object. */

int ValidInternalMasterDSA(THSTATE *pTHS, DSNAME *pDSA){

   DWORD err;
   DBPOS *pDB = NULL;
   SYNTAX_INTEGER iType;
   BOOL  Deleted;

   DBOpen2(TRUE, &pDB);
   if (NULL == pDB) {
       return DB_ERR_DATABASE_ERROR;
   }
   __try {

        // make sure the object exists
        if (FindAliveDSName(pDB, pDSA)) {

            DPRINT(4,"***Couldn't locate the DSA object\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_FIND_DSA_OBJ,
                     NULL,
                     NULL,
                     NULL);
            __leave;
        }

        /* Validate that the instance type is an internal_master.  */
        
        if (err = DBGetSingleValue(pDB, ATT_INSTANCE_TYPE,  &iType, sizeof(iType),
                                   NULL)) {
        
            DPRINT(4,"***Instance type  not found ERROR\n");
            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_CANT_RETRIEVE_INSTANCE,
                     szInsertDN(pDSA),
                     szInsertUL(err),
                     szInsertHex(DSID(FILENO, __LINE__)));
            pTHStls->errCode = 1;
            SetSvcError(SV_PROBLEM_DIR_ERROR,
                        DIRERR_CANT_RETRIEVE_INSTANCE);

            __leave;
        }
        else if (iType != INT_MASTER){
        
            SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                        DIRERR_DSA_MUST_BE_INT_MASTER);
            pTHStls->errCode = 1;
            __leave;
        
        }

        if (!IsDSA(pDB)){
        
            DPRINT(4,"***Object Class  not DSA\n");
            pTHStls->errCode = 1;
            SetUpdError(UP_PROBLEM_OBJ_CLASS_VIOLATION,
                      DIRERR_CLASS_NOT_DSA);
            __leave;
        }

    }
    __finally
    {
        DBClose(pDB, !AbnormalTermination());
    }


    return pTHStls->errCode;

}/*Valid InternalMasterDSA*/

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/

/* Change the DNs in all master NC's in the Anchor to reflect new DIT.
*/


int  UpdateMasterNCs(THSTATE *pTHS, DSNAME *pNewDSA)
{


   NAMING_CONTEXT_LIST       *pNCL;
   SYNTAX_DISTNAME_STRING   *pNewDSAAnchor;
   DWORD rtn = 0;
   BOOL fCommit = FALSE;

   DPRINT(1,"UpdateMasterNCs entered\n");


   /* Build new DSA name-address attribute */

   pNewDSAAnchor = malloc(DERIVE_NAME_DATA_SIZE(pNewDSA,
                                                DATAPTR(gAnchor.pDSA)));
   if(!pNewDSAAnchor) {
       SetSysErrorEx(ENOMEM, ERROR_OUTOFMEMORY,
                     DERIVE_NAME_DATA_SIZE(pNewDSA,
                                           DATAPTR(gAnchor.pDSA)));
       return ENOMEM;
   }

   BUILD_NAME_DATA(pNewDSAAnchor, pNewDSA, DATAPTR(gAnchor.pDSA));

   if (DBReplaceHiddenDSA(NAMEPTR(pNewDSAAnchor))) {

      DPRINT(4,"Hidden record not replaced...update failed\n");
      free(pNewDSAAnchor);
      LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
  	    DS_EVENT_SEV_MINIMAL,
  	    DIRLOG_CANT_REPLACE_HIDDEN_REC,
  	    NULL,
	    NULL,
  	    NULL);

      return SetSvcError(SV_PROBLEM_DIR_ERROR,
			 DIRERR_CANT_REPLACE_HIDDEN_REC);
   }
   free(pNewDSAAnchor);


   /* All updates are O.K. so rename the DSA in global memory */
   free(gAnchor.pDSA);
   free(gAnchor.pDSADN);
   free(gAnchor.pDomainDN);

   /* All the updates are so re-load the DSA information */
   if (rtn = InitDSAInfo()){

       LogUnhandledError(rtn);
   
       DPRINT(2,"Failed to locate and load DSA knowledge\n");
       return rtn;
   }
    
   return rtn;

}/*UpdateMasterNCs*/

int LocalRenameDSA(THSTATE *pTHS, DSNAME *pNewDSA)
		   
{
    int err = 0;
   
    /* The order of these validations are important */

    if ( (err=ValidInternalMasterDSA(pTHS, pNewDSA))
     ||  (err=UpdateMasterNCs(pTHS, pNewDSA))
     ||  (err=BuildRefCache(FALSE)) ) {
    
      DPRINT1(4," DSA Rename failed (%u)\n", err);

    }

    if (!err)
        err = pTHS->errCode;

   return (err);  /*in case we have an attribute error*/

}/* LocalRenameDSA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dramail.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dramail.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to support asynchronous (e.g., mail) replication.

NOTE #1: Variable-length headers
The MAIL_REP_MSG structure has the ability to have the data start at a
variable point from start of the message.  This is called a variable-
length header. This is indicated by the cbDataOffset field in the message.
W2K never set this field, and always expects a fixed header. Post-W2K fill
in this field, can send either a fixed or variable message, and can receive a
fixed or variable message.
Since MAIL_REP_MSG is a fixed size structure, care must be taken when
accessing a variable length header.  The rules are that when constructing
a native message, you can fill in the whole structure and access the 'data'
field as the start of the data. When receiving a message from the wire, or
when contructing a message with a non-native header size, you must NOT
access the data field, but must instead use the cbDataOffset to calculate
where the data should go.

NOTE #2: W2K compatibility and variable length headers
  We send an indication that we can handle variable headers.
  When we get the response,
  W2K will send the fixed header, and post-W2K will send
  an extended header.
  We detect whether the sender can support variable length headers.

NOTE #3: Linked Value Replication Protocol Upgrade
Upgrade to LVR mode can occur two ways.
1. Through receipt of a reply with LVR values
2. Through replication of the upgraded forest version in the Config NC.

Upgrade to LVR on receipt of reply containing values. LVR mode is orthogonal to
message version by design. One can only detect an LVR source when the source
returns LVR data. Note that this detection is one way, on receipt of reply.
A mail partitioned site must receive a Whistler reply, and one with actual values
in order to detect LVR.

Once in LVR mode we reject all W2K version messages.

Compatibility matrix:
W2k and Whistler LVR combinations: not allowed
Dest     Source   RequestAction            ReplyAction
non-lvr  non-lvr  stays non-lvr            stays non-lvr
non-lvr  lvr      treat as lvr             upgrade if values returned
lvr      non-lvr  treat as non-lvr         accept legacy mode update
lvr      lvr      treat as lvr             treat as lvr

DETAILS:

CREATED:

REVISION HISTORY:

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include <heurist.h>
#include "mci.h"
#include "mdi.h"
#include "permit.h"
#include "dsconfig.h"
#include "dsaapi.h"
#include "dsutil.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAMAIL:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "draasync.h"
#include "dramail.h"
#include "usn.h"
#include "drauptod.h"
#include "drasch.h"
#include "drameta.h"
#include "draaudit.h"

#include <ismapi.h>
#include <align.h>

#include "xpress.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMAIL

// The service name used to send and receive messages between DSAs via ISM.
#define DRA_ISM_SERVICE_NAME L"NTDS Replication"

// Tests show that the smallest message we ever send appears to be about 700 bytes.
// It's probably not worth compressing such a small message, so we set the limit at
// 1024 bytes. This value was chosen mostly arbitrarily.
#define MIN_COMPRESS_SIZE 0x400

// The uncompressed message size is stored in the unsigned MAIL_REP_MSG structure
// and is therefore subject to tampering. To prevent attacks which cause the DS to
// commit excessive amounts of memory, we impose a maximum size of 50 megabytes on
// the uncompressed data.
#define MAX_UNCOMPRESSED_DATA_SIZE (50 * 1024 * 1024)

// The maximum value for gulDraCompressionLevel
#define MAX_COMPRESSION_LEVEL 9

// The level at which we compress the data (0=faster, ..., 9=more compression).
// The default value is 9 and the value can be changed with a registry key
ULONG gulDraCompressionLevel;

// The compression algorithm which the user requests that we used. We validate that
// it is one of the known types. For types that are common to downlevel servers, we
// use that type exclusively. For types that are not common, we negotiate to the
// desired type if possible.
ULONG gulDraCompressionAlg;

// This is the approximate maximum number of entries and bytes that we request
// in each mail update message.
ULONG gcMaxAsyncInterSiteObjects = 0;
ULONG gcMaxAsyncInterSiteBytes = 0;

// Delay between checks to see if the ISM service has been started.
#define MAIL_START_RETRY_PAUSE_MSECS    (5*60*1000)

// Delay time if we get an error while attempting to get the next inbound
// intersite message.
#define MAIL_RCVERR_RETRY_PAUSE_MINS    (30)
#define MAIL_RCVERR_RETRY_PAUSE_MSECS   (MAIL_RCVERR_RETRY_PAUSE_MINS*60*1000)

// If we try to apply changes and we get a sync failure, this is how
// long we wait before trying
#define SYNC_FAIL_RETRY_PAUSE_MSECS    5000

// This is the number of times we retry a sync failure before giving up.
#define SYNC_FAILURE_RETRY_COUNT 10

// The MSZIP and XPRESS compression libraries work on data blocks with a certain maximum
// size (see MSZIP_MAX_BLOCK and XPRESS_MAX_BLOCK). When encoding a blob, we split it
// up into blocks and compress each one separately. The compressed blobs are actually a
// sequence of MAIL_COMPRESS_BLOCKs, each of which contains the size and data of a
// compressed block.
typedef struct _MAIL_COMPRESS_BLOCK {
    ULONG cbUncompressedSize;
    ULONG cbCompressedSize;
    BYTE  data[];
} MAIL_COMPRESS_BLOCK;

// This is the maximum size of a block that we pass to the MSZIP library.
#define MSZIP_MAX_BLOCK (32*1024)


// Mail running is indicated by the gfDRAMAilRunning flag being TRUE.
BOOL gfDRAMailRunning = FALSE;

char grgbBogusBuffer[BOGUS_BUFFER_SIZE];

// Maximum number of milliseconds we have to wait for the mail send before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxTicksMailSendMsg = 0;

// Sleep for the given number of milliseconds or until shutdown is initiated,
// whichever comes first.
#define DRA_SLEEP(x)                            \
    WaitForSingleObject(hServDoneEvent, (x));   \
    if (eServiceShutdown) {                     \
        DRA_EXCEPT_NOLOG(DRAERR_Shutdown, 0);   \
    }

#define DWORDMIN(a,b) ((a<b) ? (a) : (b))

// printf templates for subject strings
#define MAX_INT64_D_SZ_LEN (25)
#define MAX_INT_X_SZ_LEN   (12)

#define REQUEST_TEMPLATE L"Get changes request for NC %ws from USNs <%I64d/OU, %I64d/PU> with flags 0x%x"
#define REQUEST_TEMPLATE_LEN (ARRAY_SIZE(REQUEST_TEMPLATE))
//This is how much space is needed for arguments when expanded (not inc nc)
#define REQUEST_VARIABLE_CHARS (MAX_INT64_D_SZ_LEN*2 + MAX_INT_X_SZ_LEN)

#define REPLY_TEMPLATE L"Get changes reply for NC %ws from USNs <%I64d/OU, %I64d/PU> to USNs <%I64d/OU, %I64d/PU>"
#define REPLY_TEMPLATE_LEN (ARRAY_SIZE(REPLY_TEMPLATE))
#define REPLY_VARIABLE_CHARS (MAX_INT64_D_SZ_LEN*4)

// Prototypes
void
ProcessReqUpdate(
    IN  THSTATE *       pTHS,
    IN  DRA_CERT_HANDLE hSenderCert,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed,
    IN  PDSNAME         pDestNtdsDsaDN
    );

void
ProcessUpdReplica(
    IN  THSTATE *       pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed,
    IN  PDSNAME         pSourceNtdsDsaDN
    );

BOOL
draCompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppCmprsMailRepMsg,
    OUT DRS_COMP_ALG_TYPE *pCompressionAlg
    );

void
draUncompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppUncompressedMailRepMsg
    );

ULONG
SendMailMsg(
    IN      THSTATE *       pTHS,
    IN      LPWSTR          pszTransportDN,
    IN      MTX_ADDR *      pmtxDestDSA,
    IN      LPWSTR          pszSubject,
    IN      DRA_CERT_HANDLE hReceiverCert,      OPTIONAL
    IN      DRA_KEY_SIZE    eKeySize,
    IN OUT  MAIL_REP_MSG *  pMailRepMsg,
    IN OUT  ULONG *         pcbMsgSize
    )
/*++

Routine Description:

    Send message to remote DSA via ISM.  Compresses message before transmission
    if appropriate.

    This routine can send messages with variable length headers.  Routines that it
    calls, draCompress, draSign and draEncrypt, also understand variable length
    headers.

Arguments:

    pszTransportDN (IN) - Transport by which to send message.

    pmtxDestDSA (IN) - Transport-specific address of remote DSA.

    pszSubject (IN) - Subject string describing the message

    hReceiverCert (IN) - A handle to the receiver's certificate.  If non-NULL,
        the sent message will be signed and encrypted.  If NULL, the sent
        message will be signed only.

    eKeySize (IN) - Key size to use when encrypting

    pMailRepMsg (IN/OUT) - The pickled message to send.  Updated with
        compression and protocol versions.

    pcbMsgSize (IN/OUT) - The message size.  Reset if the sent message is
        compressed.

Return Values:

    DRAERR_*

--*/
{
    BOOL            fProcessed = FALSE;
    MAIL_REP_MSG *  pProcessedMailRepMsg;
    ISM_MSG         IsmMsg;
    LPWSTR          pszTransportAddress = NULL;
    DWORD           cch;
    DWORD           winErr;
    DRS_COMP_ALG_TYPE CompAlg = DRS_COMP_ALG_NONE;

    // Set the request version
    pMailRepMsg->ProtocolVersionCaller = CURRENT_PROTOCOL_VERSION;

    // This message has not been compressed yet
    pMailRepMsg->CompressionVersionCaller = DRS_COMP_ALG_NONE;

    // Compress the message.
    if( draCompressMessage(pTHS, pMailRepMsg, &pProcessedMailRepMsg, &CompAlg) ) {

        // Compression succeeded; work with the compressed message now
        fProcessed = TRUE;
        pMailRepMsg = pProcessedMailRepMsg;

        // Confirm that an acceptable algorithm was chosen
        Assert(   CompAlg==DRS_COMP_ALG_NONE
               || CompAlg==DRS_COMP_ALG_MSZIP
               || CompAlg==DRS_COMP_ALG_XPRESS );
        pMailRepMsg->CompressionVersionCaller = CompAlg;
    }

    if (NULL == hReceiverCert) {
        // Sign the message, but don't encrypt.
        Assert( DRA_KEY_SIZE_UNKNOWN==eKeySize );
        draSignMessage(pTHS, pMailRepMsg, &pProcessedMailRepMsg);
    }
    else {
        // Sign and encrypt the message.
        Assert( DRA_KEY_SIZE_UNKNOWN!=eKeySize );
        draEncryptAndSignMessage(pTHS, pMailRepMsg, hReceiverCert, eKeySize,
                                 &pProcessedMailRepMsg);
    }

    if (fProcessed) {
        // We've processed the message once already; free the intermediate
        // version.  (As a corollary to this, we never free the original message
        // passed to us by the caller.)
        THFreeEx(pTHS, pMailRepMsg);
    }

    // Use the signed message as the one we will send.
    fProcessed = TRUE;
    pMailRepMsg = pProcessedMailRepMsg;
    *pcbMsgSize = MAIL_REP_MSG_SIZE(pMailRepMsg);

    // Send message.
    IsmMsg.pbData = (BYTE *) pMailRepMsg;
    IsmMsg.cbData = *pcbMsgSize;
    IsmMsg.pszSubject = pszSubject;

    pszTransportAddress = THAllocEx(pTHS, pmtxDestDSA->mtx_namelen * sizeof(WCHAR));
    cch = MultiByteToWideChar(CP_UTF8,
                              0,
                              pmtxDestDSA->mtx_name,
                              pmtxDestDSA->mtx_namelen,
                              pszTransportAddress,
                              pmtxDestDSA->mtx_namelen);
    Assert(0 != cch);

    winErr = I_ISMSend(&IsmMsg,
                       DRA_ISM_SERVICE_NAME,
                       pszTransportDN,
                       pszTransportAddress);

    if (NO_ERROR != winErr) {
        DPRINT3(0, "Unable to send %ws message to %ls, error %d.\n",
                pszSubject, pszTransportAddress, winErr);
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_EXTENSIVE,
                  DIRLOG_DRA_MAIL_ISM_SEND_FAILURE,
                  szInsertWin32Msg( winErr ),
                  szInsertWC( pszTransportAddress ),
                  szInsertWC( pszTransportDN ),
                  szInsertWC( pszSubject ),
                  szInsertWin32ErrCode( winErr ),
                  NULL, NULL, NULL );
    }

    if (fProcessed) {
        THFreeEx(pTHS, pProcessedMailRepMsg);
    }

    if(pszTransportAddress != NULL) THFreeEx(pTHS, pszTransportAddress);

    return winErr;
}

ULONG
SendReqUpdateMsg(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pTransportDN,
    IN  MTX_ADDR *                  pmtxSrcDSA,
    IN  UUID *                      puuidSrcInvocId,
    IN  UUID *                      puuidSrcDsaObj,
    IN  MTX_ADDR *                  pmtxLocalDSA,
    IN  DWORD                       dwInMsgVersion,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq
    )
/*++

Routine Description:

    Send a GetNCChanges() request message.

Arguments:

    pTransportDN (IN) - Transport by which to send the message.

    pmtxSrcDSA (IN) - Transport-specific address of remote DSA.

    puuidSrcInvocId (IN) - Invocation ID of source DSA.

    puuidSrcDsaObj (IN) - objectGuid of source DSA's ntdsDsa object.

    pmtxLocalDSA (IN) - Transport-specific address of local DSA (to use as
        a return address).

    pMsgReq (IN) - The request.

Return Values:

    DRAERR_*

--*/
{
    char *                  pbPickledMsg;
    ULONG                   cbPickdSize;
    DWORD                   cbDataOffset;
    DWORD                   cbExtOffset;
    MAIL_REP_MSG *          pMailRepMsg = NULL;
    DWORD                   ret = DRAERR_Success;
    handle_t                hEncoding;
    RPC_STATUS              status;
    ULONG                   ulEncodedSize;
    ULONG                   ulMsgSize = 0;
    DWORD                   ret2, len;
    LPWSTR                  pszSubject = NULL;
    DWORD                   cTickStart = GetTickCount();
    DWORD                   cTickDiff;
    DRS_MSG_GETCHGREQ       OutboundReq;
    BOOL                    fExtendedDataAllowed = (4 != dwInMsgVersion);
    DRS_EXTENSIONS_INT *    pextLocal = gAnchor.pLocalDRSExtensions;
    BOOL                    fCommit;

    Assert(pTransportDN && pmtxSrcDSA && pNativeReq);
    Assert(!fNullUuid(&pTransportDN->Guid));
    Assert(OWN_DRA_LOCK());
    Assert(pTHS->fSyncSet && (SYNC_WRITE == pTHS->transType));

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier.
    ret = DRAEnsureMailRunning();
    if (ret) {
        goto LogAndLeave;
    }

    // Abort if outbound replication is disabled and this is not a forced sync.
    if (gAnchor.fDisableInboundRepl && !(pNativeReq->ulFlags & DRS_SYNC_FORCED)) {
        DRA_EXCEPT(DRAERR_SinkDisabled, 0);
    }

    if (fExtendedDataAllowed) {
        // Other DSA is > Win2k.
        cbExtOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        cbDataOffset = ROUND_UP_COUNT(cbExtOffset + DrsExtSize(pextLocal),
                                      MAIL_REP_MSG_DATA_ALIGN);
    } else {
        // Other DSA is Win2k.
        cbExtOffset = 0;
        cbDataOffset = MAIL_REP_MSG_W2K_HEADER_SIZE;
    }
    
    Assert(COUNT_IS_ALIGNED(cbExtOffset, MAIL_REP_MSG_EXT_ALIGN));
    Assert(COUNT_IS_ALIGNED(cbDataOffset, MAIL_REP_MSG_DATA_ALIGN));
    
    __try {
        draXlateNativeRequestToOutboundRequest(pTHS,
                                               pNativeReq,
                                               pmtxLocalDSA,
                                               &pTransportDN->Guid,
                                               dwInMsgVersion,
                                               &OutboundReq);

        // Encode the request, leaving room at the beginning of the buffer to
        // hold our MAIL_REP_MSG header and DRS_EXTENSIONS (if needed).
        ret = draEncodeRequest(pTHS,
                               dwInMsgVersion,
                               &OutboundReq,
                               cbDataOffset,
                               (BYTE **) &pMailRepMsg,
                               &ulMsgSize);
        if (ret) {
            // Event already logged
            __leave;
        }

        pMailRepMsg->cbDataSize = ulMsgSize - cbDataOffset;
        pMailRepMsg->cbDataOffset = cbDataOffset;
        pMailRepMsg->dwMsgType = MRM_REQUPDATE;
        pMailRepMsg->dwMsgVersion = dwInMsgVersion;

        if (fExtendedDataAllowed) {
            // Record the DRS extensions we support.
            
            // Consumed by Whistler Beta 1 and Beta 2 DCs.
            pMailRepMsg->dwExtFlags = gAnchor.pLocalDRSExtensions->dwFlags;

            // Consumed by > Whistler Beta 2 DCs.
            pMailRepMsg->cbExtOffset = cbExtOffset;
            memcpy((BYTE *)pMailRepMsg + pMailRepMsg->cbExtOffset,
                   pextLocal,
                   DrsExtSize(pextLocal));
        }

        len = (DWORD)(REQUEST_TEMPLATE_LEN +
            wcslen( pNativeReq->pNC->StringName ) +
            REQUEST_VARIABLE_CHARS);
        pszSubject = (LPWSTR) THAllocEx(pTHS, len * sizeof( WCHAR ) );
        swprintf( pszSubject, REQUEST_TEMPLATE,
                  pNativeReq->pNC->StringName,
                  pNativeReq->usnvecFrom.usnHighObjUpdate,
                  pNativeReq->usnvecFrom.usnHighPropUpdate,
                  pNativeReq->ulFlags );

        // Note: pextRemote may be NULL here, or may be non-NULL. As a
        // result, sometimes requests may use Xpress compression, and sometimes
        // they may not.
        ret = SendMailMsg(pTHS, pTransportDN->StringName, pmtxSrcDSA,
                          pszSubject, NULL, DRA_KEY_SIZE_UNKNOWN,
                          pMailRepMsg, &ulMsgSize);

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        ;
    }

 LogAndLeave:
    
    if (DRAERR_Success != ret) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_DRA_IDREQUEST_FAILED,
                  szInsertDN(pNativeReq->pNC),
                  szInsertMTX(pmtxSrcDSA),
                  szInsertWin32Msg( ret ),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL );
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_MAIL_REQ_UPD_SENT,
                 szInsertUL(ulMsgSize),
                 szInsertDN(pNativeReq->pNC),
                 szInsertMTX(pmtxSrcDSA));
    }

    if (pMailRepMsg) {
        THFreeEx(pTHS, pMailRepMsg);
    }

    // Need a separate transaction here so that update to reps-from will commit
    // independent of error
    EndDraTransaction( !ret );

    BeginDraTransaction( SYNC_WRITE );
    fCommit = FALSE;
    __try {
        // Update Reps-From value to indicate we have sent our request (or attempted
        // to do so, anyway).
        ret2 = UpdateRepsFromRef(pTHS,
                                 DRS_UPDATE_RESULT,
                                 pNativeReq->pNC,
                                 DRS_FIND_DSA_BY_UUID,
                                 URFR_MUST_ALREADY_EXIST,
                                 puuidSrcDsaObj,
                                 puuidSrcInvocId,
                                 &pNativeReq->usnvecFrom,
                                 &pTransportDN->Guid,
                                 pmtxSrcDSA,
                                 pNativeReq->ulFlags,
                                 NULL,
                                 ret ? ret : ERROR_DS_DRA_REPL_PENDING,
                                 NULL);
        Assert(!ret2);
        fCommit = !ret2;
    } __finally {
        EndDraTransaction( fCommit );
    }

    // Came in with a writeable transaction, must leave with one...
    BeginDraTransaction(SYNC_WRITE);

    if(pszSubject != NULL) THFreeEx(pTHS, pszSubject);

    cTickDiff = GetTickCount() - cTickStart;
    if (cTickDiff > gcMaxTicksMailSendMsg) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_MAIL_SEND_CONTENTION,
                 szInsertUL((cTickDiff/1000) / 60),
                 szInsertUL((cTickDiff/1000) % 60),
                 NULL);
    }

    return ret;
}


ULONG
SendUpdReplicaMsg(
    IN  THSTATE *                     pTHS,
    IN  DSNAME *                      pTransportDN,
    IN  MTX_ADDR *                    pmtxDstDSA,
    IN  DRA_CERT_HANDLE               hRecipientCert,
    IN  DWORD                         dwOutMsgVersion,
    IN  BOOL                          fExtendedDataAllowed,
    IN  DRS_MSG_GETCHGREPLY_NATIVE *  pNativeReply
    )
/*++

Routine Description:

    Send reply to DSA that sent us a GetNCChanges() request.

Arguments:

    pTransportDN (IN) - Transport by which to send the message.

    pmtxDstDSA (IN) - Transport-specific address of remote DSA.

    hRecipientCert (IN) - Handle to recipient's cert, to be used for encryption.

    dwOutMsgVersion (IN) - Desired version for reply message

    fExtendedDataAllowed (IN) - Whether the sender supports variable headers

    pmsgUpdReplica (IN) - The reply.

Return Values:

    DRAERR_*

--*/
{
    char *                  pPickdUpdReplicaMsg;
    ULONG                   cbPickdSize;
    DWORD                   cbDataOffset;
    DWORD                   cbExtOffset;
    MAIL_REP_MSG *          pMailRepMsg = NULL;
    BOOL                    ret = FALSE;
    handle_t                hEncoding;
    RPC_STATUS              status;
    ULONG                   ulEncodedSize;
    ULONG                   ulMsgSize = 0, len;
    LPWSTR                  pszSubject = NULL;
    DRS_MSG_GETCHGREPLY     OutboundReply;
    DRS_EXTENSIONS_INT *    pextLocal = gAnchor.pLocalDRSExtensions;
    DRA_KEY_SIZE            eKeySize;

    Assert(pTransportDN && pmtxDstDSA && pNativeReply);
    Assert(0 == ((ULONG_PTR) pmtxDstDSA) % sizeof(DWORD));
    Assert(NULL != pTHS->pextRemote);

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier.

    ret = DRAEnsureMailRunning();
    if (ret) {
        goto LogAndLeave;
    }

    if (fExtendedDataAllowed) {
        // Other DSA is > Win2k.
        cbExtOffset = MAIL_REP_MSG_CURRENT_HEADER_SIZE;
        cbDataOffset = ROUND_UP_COUNT(cbExtOffset + DrsExtSize(pextLocal),
                                      MAIL_REP_MSG_DATA_ALIGN);
    } else {
        // Other DSA is Win2k.
        cbExtOffset = 0;
        cbDataOffset = MAIL_REP_MSG_W2K_HEADER_SIZE;
    }
    
    Assert(COUNT_IS_ALIGNED(cbExtOffset, MAIL_REP_MSG_EXT_ALIGN));
    Assert(COUNT_IS_ALIGNED(cbDataOffset, MAIL_REP_MSG_DATA_ALIGN));

    __try {
        draXlateNativeReplyToOutboundReply(pTHS,
                                           pNativeReply,
                                           0,  // xlate flags
                                           pTHS->pextRemote,
                                           &dwOutMsgVersion,
                                           &OutboundReply);

        // Encode the reply, leaving room at the beginning of the buffer to
        // hold our MAIL_REP_MSG header and at the end to hold our
        // DRS_EXTENSIONS (if needed).
        ret = draEncodeReply(pTHS,
                             dwOutMsgVersion,
                             &OutboundReply,
                             cbDataOffset,
                             (BYTE **) &pMailRepMsg,
                             &ulMsgSize);
        if (ret) {
            // Event already logged
            __leave;
        }

        pMailRepMsg->cbDataSize = ulMsgSize - cbDataOffset;
        pMailRepMsg->cbDataOffset = cbDataOffset;
        pMailRepMsg->dwMsgType = MRM_UPDATEREPLICA;
        pMailRepMsg->dwMsgVersion = dwOutMsgVersion;

        if (fExtendedDataAllowed) {
            // Record the DRS extensions we support.
            
            // Consumed by Whistler Beta 1 and Beta 2 DCs.
            pMailRepMsg->dwExtFlags = gAnchor.pLocalDRSExtensions->dwFlags;

            // Consumed by > Whistler Beta 2 DCs.
            pMailRepMsg->cbExtOffset = cbExtOffset;
            memcpy((BYTE *)pMailRepMsg + pMailRepMsg->cbExtOffset,
                   pextLocal,
                   DrsExtSize(pextLocal));
        }

        // Choose reply key size
        // W2K SP2 and beyond have high-encryption pack and can handle 128 bit keys
        // Since there is no easy way to detect SP2, we switch on W2K message version.
        // Note that make our decision based on something inside the signed request.
        if (dwOutMsgVersion >= 6) {
            eKeySize = DRA_KEY_SIZE_128; // > W2K reply
        } else {
            eKeySize = DRA_KEY_SIZE_56;  // W2K reply
        }

        len = (ULONG)(REPLY_TEMPLATE_LEN +
            wcslen(pNativeReply->pNC->StringName) +
            REPLY_VARIABLE_CHARS);
        pszSubject = THAllocEx(pTHS, len * sizeof( WCHAR ) );
    
        swprintf(pszSubject,
                 REPLY_TEMPLATE,
                 pNativeReply->pNC->StringName,
                 pNativeReply->usnvecFrom.usnHighObjUpdate,
                 pNativeReply->usnvecFrom.usnHighPropUpdate,
                 pNativeReply->usnvecTo.usnHighObjUpdate,
                 pNativeReply->usnvecTo.usnHighPropUpdate);

        Assert( NULL!=hRecipientCert );
        ret = SendMailMsg(pTHS, pTransportDN->StringName, pmtxDstDSA,
                          pszSubject, hRecipientCert, eKeySize,
                          pMailRepMsg, &ulMsgSize );

    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        ;
    }

 LogAndLeave:

    if (DRAERR_Success != ret) {
        // There is no other way for the source to record that it could not send
        // the reply.  We are going to drop the reply on the floor at this point.
        // If we did not log this, the user would no way to know what the problem
        // is.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_IDUPDATE_FAILED,
                  szInsertDN(pNativeReply->pNC),
                  szInsertMTX(pmtxDstDSA),
                  szInsertWin32Msg( ret ),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL );
    } else {
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_MAIL_UPD_REP_SENT,
                 szInsertUL(ulMsgSize),
                 szInsertDN(pNativeReply->pNC),
                 szInsertMTX(pmtxDstDSA));
    }

    if (pMailRepMsg) {
        THFreeEx(pTHS, pMailRepMsg);
    }
    if(pszSubject != NULL) THFreeEx(pTHS, pszSubject);

    return ret;
}


void
draXlateInboundMailRepMsg(
    IN  THSTATE *           pTHS,
    IN  BYTE *              pbInboundMsg,
    IN  DWORD               cbInboundMsgSize,
    OUT BOOL *              pfExtendedDataAllowed,
    OUT MAIL_REP_MSG *      pNativeMsgHeader,
    OUT BYTE **             ppbData
    )
{
    // DRS extensions supported by Win2k.
    static DWORD dwWin2kExtFlags
        = (1 << DRS_EXT_BASE)
          | (1 << DRS_EXT_ASYNCREPL)
          | (1 << DRS_EXT_REMOVEAPI)
          | (1 << DRS_EXT_MOVEREQ_V2)
          | (1 << DRS_EXT_GETCHG_COMPRESS)
          | (1 << DRS_EXT_DCINFO_V1)
          // | (1 << DRS_EXT_STRONG_ENCRYPTION) // not supported over mail!
          | (1 << DRS_EXT_ADDENTRY_V2)
          | (1 << DRS_EXT_KCC_EXECUTE)
          | (1 << DRS_EXT_DCINFO_V2)
          | (1 << DRS_EXT_DCINFO_VFFFFFFFF)
          | (1 << DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD)
          | (1 << DRS_EXT_CRYPTO_BIND)
          | (1 << DRS_EXT_GET_REPL_INFO)
          | (1 << DRS_EXT_TRANSITIVE_MEMBERSHIP)
          | (1 << DRS_EXT_ADD_SID_HISTORY)
          | (1 << DRS_EXT_POST_BETA3)
          | (1 << DRS_EXT_RESTORE_USN_OPTIMIZATION)
          | (1 << DRS_EXT_GETCHGREQ_V5);
    
    MAIL_REP_MSG *      pInboundMsg = (MAIL_REP_MSG *) pbInboundMsg;
    DWORD               cbInboundHeader;
    BYTE *              pbData;
    DRS_EXTENSIONS *    pextRemote;
    DWORD               dwMsgVersion;
    DRS_EXTENSIONS_INT  extRemoteFlagsOnly;
    DWORD               cbExtOffset;

    // Validation: Check that the message is large enough to contain the basic header
    // (i.e. up to and including dwMsgVersion)
    if (cbInboundMsgSize < MAIL_REP_MSG_W2K_HEADER_SIZE) {
        // Header is too small -- invalid.
        DRA_EXCEPT(ERROR_BAD_LENGTH, cbInboundMsgSize);
    }
    
    if (pInboundMsg->ProtocolVersionCaller != CURRENT_PROTOCOL_VERSION) {
        // Message is incompatible with our protocol -- invalid.
        LogAndAlertEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_INCOMPAT_MAIL_MSG_P,
                         NULL,
                         NULL,
                         NULL);

        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, pInboundMsg->ProtocolVersionCaller);
    }

    if (0 == pInboundMsg->cbDataOffset) {
        // Sent by Win2k DC.
        *pfExtendedDataAllowed = FALSE;
        cbInboundHeader = MAIL_REP_MSG_W2K_HEADER_SIZE;
        pbData = (BYTE *) pInboundMsg + MAIL_REP_MSG_W2K_HEADER_SIZE;
        pextRemote = NULL;
        dwMsgVersion = (pInboundMsg->dwMsgType & MRM_REQUPDATE) ? 4 : 1;
    } else {
        // Sent by >= Whistler DC.

        // Validation: Before MAIL_REP_MSG_HEADER_SIZE can examine cbExtOffset,
        // we must check that the message is big enough to contain it.
        if( pInboundMsg->cbDataOffset > cbInboundMsgSize ) {
            DRA_EXCEPT(ERROR_BAD_LENGTH, pInboundMsg->cbDataOffset);
        }

        // Validation: Check that cbExtOffset is consistent with the message size
        // If the message does not store cbExtOffset then the local variable cbExtOffset
        // will be 0.
        cbExtOffset = MAIL_REP_MSG_DRS_EXT_OFFSET(pInboundMsg);
        if( cbExtOffset>cbInboundMsgSize ) {
            DRA_EXCEPT(ERROR_BAD_LENGTH, cbExtOffset);
        }
        
        *pfExtendedDataAllowed = TRUE;

        // Validation: cbInboundHeader is checked below
        cbInboundHeader = MAIL_REP_MSG_HEADER_SIZE(pInboundMsg);
        pbData = MAIL_REP_MSG_DATA(pInboundMsg);
        pextRemote = MAIL_REP_MSG_DRS_EXT(pInboundMsg);
        dwMsgVersion = pInboundMsg->dwMsgVersion;
    }

    if (   cbInboundHeader < MAIL_REP_MSG_W2K_HEADER_SIZE
        || cbInboundHeader > cbInboundMsgSize )
    {
        // Header length is invalid
        DRA_EXCEPT(ERROR_BAD_LENGTH, cbInboundMsgSize);
    }

    // Validation:
    //  - Claim that pbData is not NULL and points somewhere inside the pInboundMsg buffer
    //    (possibly right at the end of the buffer)
    //  - Claim that pextRemote is either NULL or points somewhere inside the pInboundMsg
    //    buffer (possibly right at the end of the buffer)
    //  - Claim that cbInboundHeader is less than the size of the pInboundMsg buffer
    //  - Note that cbInboundHeader, pbData and pextRemote may be unaligned. Alignment of
    //    pbData and pextRemote is checked below.

    // Validation: Message data is required.
    if ((NULL == pbData)

        // Validation: Message data must be 8-byte aligned relative to start of buffer.
        // Note that due to ISM_MSG buffer alignment, pInboundMsg is *not*
        // 8-byte aligned -- it's 4-byte aligned.
        || !COUNT_IS_ALIGNED(pbData - (BYTE *) pInboundMsg, MAIL_REP_MSG_DATA_ALIGN)

        // Validation: Start of message data must occur at or after the end of the header
        || (pbData < (BYTE *) pInboundMsg + cbInboundHeader)

        // Validation: End of message data must coincide with the end of the inbound message.
        || ((BYTE *) pInboundMsg + cbInboundMsgSize != pbData + pInboundMsg->cbDataSize)

        // Validation: Message data must not be empty
        || (0 == pInboundMsg->cbDataSize)

        // Validation: Message data size must not be larger than input buffer
        || (pInboundMsg->cbDataSize > cbInboundMsgSize ) )
    {
        // Message data is invalid.
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, 0);
    }

    *ppbData = pbData;

    // Validation: DRS_EXTENSIONS are optional.
    if ((NULL != pextRemote)

        // Validation: DRS_EXTENSIONS must be 8-byte aligned relative to start of buffer.
        // Note that due to ISM_MSG buffer alignment, pInboundMsg is *not*
        // 8-byte aligned -- it's 4-byte aligned.
        && (!COUNT_IS_ALIGNED((BYTE *) pextRemote - (BYTE *) pInboundMsg, MAIL_REP_MSG_EXT_ALIGN)

            // Validation: Start of DRS_EXTENSIONS must occur at or after the end of the header
            || ((BYTE *) pextRemote < (BYTE *) pInboundMsg + cbInboundHeader)

            // Validation: Start of DRS_EXTENSIONS must precede message data
            || ((BYTE*) pbData < (BYTE*) pextRemote)

            // Validation: pextRemote must have enough space for the cb field
            || (pbData-(BYTE*)pextRemote < offsetof(DRS_EXTENSIONS,cb)+sizeof(DWORD))

            // Validation: size of pextRemote array must fit inside pInboundMsg
            || (DrsExtSize(pextRemote) > cbInboundMsgSize )

            // Validation: size of pextRemote array must be >=4
            || (DrsExtSize(pextRemote) < 4 )

            // Validation: End of DRS_EXTENSIONS must precede message data
            || (pbData < (BYTE *) pextRemote + DrsExtSize(pextRemote))))
    {
        // DRS_EXTENSIONS structure is invalid.
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, 0);
    }

    // Validation: Check that cbUncompressedDataSize is not excessively large
    if( pInboundMsg->cbUncompressedDataSize >= MAX_UNCOMPRESSED_DATA_SIZE ) {
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, pInboundMsg->cbUncompressedDataSize);
    }
    
    // Validation: Check that cbUnsignedDataSize is consistent with cbDataSize
    if( pInboundMsg->cbUnsignedDataSize >= pInboundMsg->cbDataSize ) {
        DRA_EXCEPT(ERROR_INVALID_PARAMETER, pInboundMsg->cbUnsignedDataSize);
    }
    
    // Copy the header and convert it into the current native structure.
    memcpy(pNativeMsgHeader,
           pInboundMsg,
           min(cbInboundHeader, MAIL_REP_MSG_CURRENT_HEADER_SIZE));
    if (cbInboundHeader < MAIL_REP_MSG_CURRENT_HEADER_SIZE) {
        memset((BYTE *) pNativeMsgHeader + cbInboundHeader,
               0,
               MAIL_REP_MSG_CURRENT_HEADER_SIZE - cbInboundHeader);
    }

    // VALIDATION WARNING: CompressionVersionCaller cannot be trusted here
    // VALIDATION WARNING: dwMsgType cannot be trusted here
    // VALIDATION WARNING: dwMsgVersion cannot be trusted here
    pNativeMsgHeader->dwMsgVersion = dwMsgVersion;

    // DRS_EXTENSIONS and message data are not present in the translated
    // message.
    pNativeMsgHeader->cbExtOffset = 0;
    pNativeMsgHeader->cbDataOffset = 0;

    // Record DRS_EXTENSIONS on the thread state.
    if (NULL == pextRemote) {
        if (0 == pNativeMsgHeader->dwExtFlags) {
            // Sent from Win2k DC.
            extRemoteFlagsOnly.dwFlags = dwWin2kExtFlags;
        } else {
            // Win2k < DC version <= Whistler Beta 2.
            extRemoteFlagsOnly.dwFlags = pNativeMsgHeader->dwExtFlags;
        }

        extRemoteFlagsOnly.cb = sizeof(extRemoteFlagsOnly.dwFlags);
        
        pextRemote = (DRS_EXTENSIONS *) &extRemoteFlagsOnly;
    } else {
        // Sent from > Whistler Beta 2 DC.
        Assert(pNativeMsgHeader->dwExtFlags
               == ((DRS_EXTENSIONS_INT *)pextRemote)->dwFlags);        
    }

    // Flags are not signed and cannot be trusted
    // Mask out security sensitive flags
    ((DRS_EXTENSIONS_INT *)pextRemote)->dwFlags &= ~(1 << DRS_EXT_LINKED_VALUE_REPLICATION);

    DraSetRemoteDsaExtensionsOnThreadState(pTHS, pextRemote);
}


void
ProcessMailMsg(
    IN  ISM_MSG *   pIsmMsg
    )
/*++

Routine Description:

    Dispatch a message received via ISM.

Arguments:

    pIsmMsg (IN) - The received message.

Return Values:

    None.

--*/
{
    THSTATE *       pTHS;
    MAIL_REP_MSG    NativeMsgHeader;
    MAIL_REP_MSG *  pNativeMsg;
    BOOL            fProcessed = FALSE;
    DRA_CERT_HANDLE hSenderCert = NULL;
    BOOL            fEncrypted, fExtendedDataAllowed;
    DWORD           cb;
    PCHAR           pbData;
    PDSNAME         pRemoteNtdsDsaDN=NULL;

    // Set up thread state
    InitDraThread(&pTHS);

    __try {

        // Validation: draXlateInboundMailRepMsg does its best to verify all fields
        // in the MAIL_REP_MSG header. See the comments in that function to understand
        // what is and what is not validated. In particular, note that dwMsgType,
        // dwMsgVersion and CompressionVersionCaller are not validated.
       
        draXlateInboundMailRepMsg(pTHS,
                                  pIsmMsg->pbData,
                                  pIsmMsg->cbData,
                                  &fExtendedDataAllowed,
                                  &NativeMsgHeader,
                                  &pbData);

        if (!(NativeMsgHeader.dwMsgType & MRM_MSG_SIGNED)) {
            // We don't accept unsigned messages.
            // Send constructed bad message? Forgery?
            DRA_EXCEPT(ERROR_BAD_IMPERSONATION_LEVEL, 0);
        }

        fEncrypted = (NativeMsgHeader.dwMsgType & MRM_MSG_SEALED);

        // Validation: Tampering of the MRM_MSG_SEALED bit will be detected by
        // the following two verification functions.
        if (fEncrypted) {
            // Decrypt and verify message signature.
            pRemoteNtdsDsaDN = draDecryptAndVerifyMessageSignature(
                pTHS,
                &NativeMsgHeader,
                pbData,
                &pNativeMsg,
                &hSenderCert);
        } else {
            // Verify message signature.
            pRemoteNtdsDsaDN = draVerifyMessageSignature(
                pTHS,
                &NativeMsgHeader,
                pbData,
                &pNativeMsg,
                &hSenderCert);
            // Validation: MSDN claims that messages encrypted with
            // CryptSignAndEncryptMessage are signed first then encrypted.
            // This should mean that draVerifyMessageSignature fails on
            // encrypted messages.
        }

        // pNtdsDsaDN contains the DN of the NTDS Settings object of the machine
        // that signed this message.
        Assert( NULL!=pRemoteNtdsDsaDN );

        // Validation: Tampering of CompressionVersionCaller will be detected by
        // draUncompressMessage, unless CompressionVersionCaller was changed to
        // DRS_COMP_ALG_NONE.
        if (pNativeMsg->dwMsgType & MRM_MSG_COMPRESSED) {
            // Uncompress message.
            MAIL_REP_MSG * pUncompressedNativeMsg;

            draUncompressMessage(pTHS, pNativeMsg, &pUncompressedNativeMsg);
            THFreeEx(pTHS, pNativeMsg);
            pNativeMsg = pUncompressedNativeMsg;
        }

        // Check for LVR mode is done on receipt of reply

        // Validation:
        // If any of:
        //  - the MRM_MSG_COMPRESSED bit was tampered with 
        //  - CompressionVersionCaller was tampered with and changed to DRS_COMP_ALG_NONE
        //  - dwMsgVersion was tampered with
        // then ProcessReqUpdate and ProcessUpdReplica will fail in draDecodeRequest
        // or draDecodeReply respectively.
        
        // Act on type of message.
        switch (pNativeMsg->dwMsgType) {
        case MRM_REQUPDATE:

            ProcessReqUpdate(pTHS,
                             hSenderCert,
                             pNativeMsg,
                             fExtendedDataAllowed,
                             pRemoteNtdsDsaDN);
            break;

        case MRM_UPDATEREPLICA:
            if (!fEncrypted) {
                // Yikes -- updates can contain sensitive data (like passwords)!
                // These messages MUST be encrypted.
                // Sender constructed bad message?
                DPRINT(0, "Received unencrypted \"update replica\" message!\n");
                DRA_EXCEPT(ERROR_BAD_IMPERSONATION_LEVEL, 0);
            }

            ProcessUpdReplica(pTHS,
                              pNativeMsg,
                              fExtendedDataAllowed,
                              pRemoteNtdsDsaDN);
            break;

        default:
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_MAIL_BADMSGTYPE,
                     szInsertUL(pNativeMsg->dwMsgType),
                     NULL,
                     NULL );
            DPRINT1(0, "Ignoring unknown message type %u.\n",
                    pNativeMsg->dwMsgType);
        }

        // Don't bother to free pRemoteNtdsDsaDN since the thread state is
        // about to be destroyed.
        
    }
    __finally {
        if (NULL != hSenderCert) {
            draFreeCertHandle(hSenderCert);
        }

        DraReturn(pTHS, 0);
        free_thread_state();
    }
}


void
CheckReqSource(
    IN  THSTATE *       pTHS,
    IN  DBPOS *         pDB,
    IN  DSNAME *        pReqUpdateMsgNC,
    IN  MTX_ADDR *      pmtxFromDN,
    IN  BOOL            fWritableReq
    )
/*++

Routine Description:

    Verify the remote DSA is authorized to make GetNCChanges() requests for
    this NC.

Arguments:

    pReqUpdateMsgNC (IN) - The NC to be replicated.

    pmtxFromDN (IN) - The transport-specific addres of the remote DSA.
    
    fWritable (IN) - The type of request, true if writable, false if read-only

Return Values:

    None.  Generates exception if access is denied.

--*/
{
    ULONG len;
    DSNAME * pNC = NULL;
    DB_ERR dbErr = 0;

    Assert(0 == ((ULONG_PTR) pmtxFromDN) % sizeof(DWORD));

    // Find object.
    if (DBFindDSName(pDB, pReqUpdateMsgNC)) {
        // Couldn't find the replica NC, discard request
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_REQUPD_BADNC,
                 szInsertDN(pReqUpdateMsgNC),
                 szInsertMTX(pmtxFromDN),
                 NULL);

        DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, 0);
    }

    // if it's a request for a writable copy of a domain parition deny the req

    if (fWritableReq) { 

        if (pReqUpdateMsgNC->NameLen==0) {
            if (0== (dbErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR **) &pNC))) {
                // can't verify access rights - deny
                // should be a severe error since we found the object above.  
                LogUnhandledError(dbErr);
                DRA_EXCEPT(ERROR_DS_DATABASE_ERROR, dbErr);
            }
        } else {
            pNC = pReqUpdateMsgNC;
        }       
        
        if (IsDomainNC(pNC)) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                DS_EVENT_SEV_BASIC,
                DIRLOG_DRA_MAIL_REQUPD_WRT_NOT_ALLOWED,
                szInsertDN(pNC),
                szInsertMTX(pmtxFromDN),
                NULL);

            DRA_EXCEPT(ERROR_DS_DRA_ACCESS_DENIED, 0);
        }

        if (pNC && (pNC!=pReqUpdateMsgNC)) {
            // got it from DBGetAttVal
            THFreeEx(pTHS, pNC);
        }
    }

}

void
ProcessReqUpdate(
    IN  THSTATE *       pTHS,
    IN  DRA_CERT_HANDLE hSenderCert,
    IN  MAIL_REP_MSG   *pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed,
    IN  PDSNAME         pDestNtdsDsaDN
    )
/*++

Routine Description:

    Service a GetNCChanges() request received via ISM.

Arguments:

    pTHS (IN) - Ye old thread state.

    hSenderCert (IN) - Handle to sender's certificate.

    pMailRepMsg (IN) - Mail message

    fExtendedDataAllowed (IN) - Whether the sender supports variable headers

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    DRS_MSG_GETCHGREQ           InboundRequest;
    DRS_MSG_GETCHGREQ_NATIVE *  pNativeRequest = &InboundRequest.V8;
    DRS_MSG_GETCHGREPLY_NATIVE  NativeReply;
    DSNAME *                    pTransportDN;
    DWORD                       cb;
    DBPOS *                     pDB;
    DWORD                       ret = 0;
    DWORD                       dwOutMsgVersion;
    MTX_ADDR *                  pmtxReturnAddress;
    UUID                        uuidTransportObj;
    RPC_STATUS                  rpcStatus;
    
    ret = draDecodeRequest(pTHS,
                           pMailRepMsg->dwMsgVersion,
                           MAIL_REP_MSG_DATA(pMailRepMsg),
                           pMailRepMsg->cbDataSize,
                           &InboundRequest);
    if (ret) {
        DRA_EXCEPT(ret, 0);
    }

    draXlateInboundRequestToNativeRequest(pTHS,
                                          pMailRepMsg->dwMsgVersion,
                                          &InboundRequest,
                                          pTHS->pextRemote,
                                          pNativeRequest,
                                          &dwOutMsgVersion,
                                          &pmtxReturnAddress,
                                          &uuidTransportObj);

    if(   0!=UuidCompare(&pNativeRequest->uuidDsaObjDest, &pDestNtdsDsaDN->Guid, &rpcStatus)
       || RPC_S_OK!=rpcStatus )
    {
        Assert( !"Error: DSA from cert does not match DSA from request structure" );
        DRA_EXCEPT(DRAERR_AccessDenied, 0);
    }

    BeginDraTransaction(SYNC_READ_ONLY);
    pDB = pTHS->pDB;

    __try {
        // Abort if outbound replication is disabled and this is not a forced
        // sync.
        if (gAnchor.fDisableOutboundRepl
            && !(pNativeRequest->ulFlags & DRS_SYNC_FORCED)) {
            DRA_EXCEPT(DRAERR_SourceDisabled, 0);
        }

        // Check that we are authorized to replicate out to caller (excepts if un-auth)
        CheckReqSource(pTHS, pDB, pNativeRequest->pNC, pmtxReturnAddress, !!(pNativeRequest->ulFlags & DRS_WRIT_REP));

        // Get DN of the transport object.
        pTransportDN = THAllocEx(pTHS, DSNameSizeFromLen(0));
        pTransportDN->structLen = DSNameSizeFromLen(0);
        pTransportDN->Guid = uuidTransportObj;

        if (DBFindDSName(pDB, pTransportDN)
            || DBIsObjDeleted(pDB)
            || DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME,
                           DBGETATTVAL_fREALLOC,
                           pTransportDN->structLen, &cb,
                           (BYTE **) &pTransportDN)) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_MAIL_INTERSITE_TRANSPORT_MISSING,
                     szInsertUUID(&uuidTransportObj),
                     NULL,
                     NULL);

            DRA_EXCEPT(DRAERR_InvalidParameter, 0);
        }
    } __finally {
        EndDraTransaction (!AbnormalTermination());
    }

    // If the destination is not expecting notify, make sure we don't have any
    // TODO: Move this routine into common GetNcChanges processing so that
    // RPC links with notification disabled can take advantage of this.
    // Perhaps have the corresponding code (draserv.c:682) key off of
    // DRS_NEVER_NOTIFY too, and move code into common path as well?
    if (pNativeRequest->ulFlags & DRS_NEVER_NOTIFY) {
        DWORD ret;
        DSNAME DN;
        LPWSTR pszDsaAddr;

        memset(&DN, 0, sizeof(DN));
        DN.Guid = pNativeRequest->uuidDsaObjDest;
        DN.structLen = DSNameSizeFromLen(0);

        pszDsaAddr = DSaddrFromName(pTHS, &DN);

        ret = DirReplicaReferenceUpdate(
            pNativeRequest->pNC,
            pszDsaAddr,
            &pNativeRequest->uuidDsaObjDest,
            (pNativeRequest->ulFlags & DRS_WRIT_REP) |
                DRS_DEL_REF | DRS_ASYNC_OP | DRS_GETCHG_CHECK
            );
        if (ret) {
            DPRINT2( 0, "Failed to remove reps-to for nc %ws, error %d\n",
                     pNativeRequest->pNC->StringName, ret );
            LogUnhandledError(ret);
            // keep going
        }
    }

    // No FSMO operations over mail
    Assert( pNativeRequest->ulExtendedOp == 0 );

    // Get the changes
    __try {
        ret = DRA_GetNCChanges(pTHS,
                               NULL,  // No filter
                               0,     // No dwDirSyncControlFlags
                               pNativeRequest,
                               &NativeReply);
    } __except (GetDraException((GetExceptionInformation()), &ret)) {
        // Stop any exceptions here so we can log an event
        NativeReply.dwDRSError = ret;
    }

    // The code should have updated this value in all cases
    Assert( ret == NativeReply.dwDRSError );

    // If we are shutting down, get out now.
    if (eServiceShutdown) {
        DRA_EXCEPT_NOLOG(DRAERR_Shutdown, 0);
    }

    // Add schemaInfo to prefix table. ProcessMailMsg has already checked
    // that protocol versions match between source and destination, so other
    // side will strip it
    if (!ret) {
        if (ret = AddSchInfoToPrefixTable(pTHS, &NativeReply.PrefixTableSrc)) {
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_MAIL_ADD_SCHEMA_INFO_FAILED,
                      szInsertDN(pNativeRequest->pNC),
                      szInsertMTX(pmtxReturnAddress),
                      szInsertWin32Msg( ret ),
                      szInsertWin32ErrCode( ret ),
                      NULL, NULL, NULL, NULL );
            // Return error to the destination
            NativeReply.dwDRSError = ret;
        }
    }

    // Handle request errors
    if (ret) {
        DraLogGetChangesFailure( pNativeRequest->pNC,
                                 TransportAddrFromMtxAddrEx(pmtxReturnAddress),
                                 ret,
                                 0 );

        // If destination is not Whistler Beta 2 w/V6, do not send a reply
        if (!(IS_DRS_EXT_SUPPORTED(pTHS->pextRemote, DRS_EXT_GETCHGREPLY_V6))) {
            DRA_EXCEPT(ret, 0);
        }

        Assert( dwOutMsgVersion >= 6 );

        DPRINT1( 1, "Mail: Sending Whistler error reply with error %d\n", ret );

        // sanity check minimal error reply
        // NativeReply.usnvecFrom could be zero
        Assert( NativeReply.pNC );
        Assert( memcmp( &NativeReply.uuidDsaObjSrc,
                        &gAnchor.pDSADN->Guid,
                        sizeof( GUID )) == 0 );
        Assert( memcmp( &NativeReply.uuidInvocIdSrc,
                        &pTHS->InvocationID,
                        sizeof( GUID)) == 0 );
        Assert( NativeReply.dwDRSError );
        // Be paranoid that packet error field is set
        if (!NativeReply.dwDRSError) {
            DRA_EXCEPT(ret, 0);
        }
    }

    // Got changes, send em. (DRA_GetNcChanges excepts on error)
    // Any failure is logged by called routine.
    ret = SendUpdReplicaMsg(pTHS,
                            pTransportDN,
                            pmtxReturnAddress,
                            hSenderCert,
                            dwOutMsgVersion,
                            fExtendedDataAllowed,
                            &NativeReply );
    if (ret) {
        DRA_EXCEPT(ret, 0);
    }
}


void
CheckUpdateMailSource(
    IN  THSTATE *       pTHS,
    IN  DBPOS *         pDB,
    IN  PDSNAME         pSourceNtdsDsaDN,
    IN  DRS_MSG_GETCHGREPLY_NATIVE *pNativeReply,
    OUT REPLICA_LINK ** ppRepLink
    )
/*++

Routine Description:

    Verify that we replicate this NC from the source DSA.

Arguments:

    pUpdReplicaMsgNC (IN) - The NC being replicated.

    puuidDsaObjSrc (IN) - The objectGuid of the sources DSA's ntdsDsa object.

    ppRepLink (OUT) - On retunr, holds a pointer to the corresponding repsFrom
        value.

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    ULONG len;
    DSNAME * pNC = NULL;
    DB_ERR dbErr = DB_success;
    BOOL fIsWritableNC;
    DSNAME *pUpdReplicaMsgNC = pNativeReply->pNC;
    UUID *puuidDsaObjSrc = &pNativeReply->uuidDsaObjSrc;
    UPTODATE_VECTOR *pUpToDateVecDest = NULL;
    SYNTAX_INTEGER it;
    DWORD dwRet;

    // Find NC object. If it's not there, give up
    dwRet = FindNC(pDB, pUpdReplicaMsgNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it);
    if (dwRet) {
        // Can't find NC, discard request
        DPRINT1( 0, "Discarding message because we no longer hold NC %ws\n",
                 pUpdReplicaMsgNC->StringName );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_UPDREP_BADNC,
                 szInsertDN(pUpdReplicaMsgNC),
                 szInsertUUID(puuidDsaObjSrc),
                 NULL);

        DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, dwRet);
    }

    // Security check:  Should we accept updates from this source?
    //   Current Security Check is simply to deny any updates to 
    //   writable Domain NC's, and accept anything else.
    if (pUpdReplicaMsgNC->NameLen==0) {
        if (0== (dbErr = DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME, 0, 0, &len, (UCHAR **) &pNC))) {
            // can't verify access rights - deny
            // should be a severe error since we found the object above.  
            LogUnhandledError(dbErr);
            DRA_EXCEPT(ERROR_DS_DATABASE_ERROR, dbErr);
        }
    } else {
        pNC = pUpdReplicaMsgNC;
    }

    ASSERT( NULL!=pNC );
    fIsWritableNC = IsMasterForNC(pDB, gAnchor.pDSADN, pNC);

    if (fIsWritableNC && IsDomainNC(pNC)) {
        LogEvent(DS_EVENT_CAT_REPLICATION,
            DS_EVENT_SEV_BASIC,
            DIRLOG_DRA_MAIL_WRT_DOMAIN_NOT_ALLOWED,
            szInsertDN(pNC),
            szInsertUUID(puuidDsaObjSrc),
            NULL);

        DRA_EXCEPT(ERROR_DS_DRA_ACCESS_DENIED, 0);
    }

    if (pNC && (pNC!=pUpdReplicaMsgNC)) {
        // got it from DBGetAttVal
        THFreeEx(pTHS, pNC);
    }

    // Validate source.

    // Position ourselves on the NC head again in order to read repsFrom.
    // If NC is gone, give up
    dwRet = FindNC(pDB, pUpdReplicaMsgNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it);
    if (dwRet) {
        // Can't find NC, discard request
        DPRINT1( 0, "Discarding message because we no longer hold NC %ws\n",
                 pUpdReplicaMsgNC->StringName );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_UPDREP_BADNC,
                 szInsertDN(pUpdReplicaMsgNC),
                 szInsertUUID(puuidDsaObjSrc),
                 NULL);

        DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, dwRet);
    }

    // try and find the name of the DRA that sent us this message in the
    // repsfrom attribute.
    FindDSAinRepAtt(pDB, ATT_REPS_FROM, DRS_FIND_DSA_BY_UUID,
            puuidDsaObjSrc, NULL, NULL, ppRepLink, &len);

    if ( (!*ppRepLink) || (!((*ppRepLink)->V1.ulReplicaFlags & DRS_MAIL_REP)) )
    {
        CHAR szUuid[40];
        // Couldn't find source DRA as someone we replicate from.
        DPRINT1( 0, "Discarding message because we no longer replicate from source %s\n",
                 DsUuidToStructuredString( puuidDsaObjSrc, szUuid ) );
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_BASIC,
                 DIRLOG_DRA_MAIL_UPDREP_BADSRC,
                 szInsertDN(pUpdReplicaMsgNC),
                 szInsertUUID(puuidDsaObjSrc),
                 NULL);
        DRA_EXCEPT (ERROR_DS_DRA_NO_REPLICA, 0);
    }

    // Verify that source is not too old

    // Read UTDVEC
    UpToDateVec_Read(pDB, it, 0, 0, &pUpToDateVecDest);

    if (!draCheckReplicationLifetime( pTHS,
                                      pUpToDateVecDest,
                                      &(pNativeReply->uuidInvocIdSrc),
                                      puuidDsaObjSrc,
                                      pSourceNtdsDsaDN->StringName)) {
        DRA_EXCEPT( ERROR_DS_REPL_LIFETIME_EXCEEDED, 0 );
    }

    if (NULL != pUpToDateVecDest) {
        THFreeEx(pTHS, pUpToDateVecDest);
    }

}


void
draSendMailRequest(
    IN THSTATE                      *pTHS,
    IN DSNAME                       *pNC,
    IN ULONG                        ulOptions,
    IN REPLICA_LINK                 *pRepLink,
    IN UPTODATE_VECTOR *            pUpToDateVecDest,
    IN PARTIAL_ATTR_VECTOR*         pPartialAttrSet,
    IN PARTIAL_ATTR_VECTOR*         pPartialAttrSetEx
    )

/*++

Routine Description:

Send a mail-based request for replication.

Arguments:

    pTHS - thread state
    pNC - naming context
    ulOptions - Additional options, if any
    pRepLink - replica link structure
    pUpToDateVecDest - local UTD vector for this NC
    pPartialAttrSet - the PAS stored on the NC head (GC/RO repl only)
    pPartialAttrSetEx - any additional attributes (PAS cycles only)

Return Value:

    None.
    Exceptions are raised for all errors.

--*/

{
    DRS_MSG_GETCHGREQ_NATIVE    msgReq;
    DSNAME *                    pTransportDN;
    DWORD                       cb;
    ATTRTYP                     attAddress;
    MTX_ADDR *                  pmtxOurAddress;
    DWORD                       dwInMsgVersion;
    DSNAME                      dsTarget;
    DWORD                       dwTargetBehavior;
    DWORD                       ulErr;

    // assert: ensure we have PAS data for PAS cycles
    Assert(!(pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ||
           pPartialAttrSet && pPartialAttrSetEx);

    // Get DN of the transport object.
    pTransportDN = THAllocEx(pTHS, DSNameSizeFromLen(0));
    pTransportDN->structLen = DSNameSizeFromLen(0);
    pTransportDN->Guid = pRepLink->V1.uuidTransportObj;

    if (DBFindDSName(pTHS->pDB, pTransportDN)
        || DBIsObjDeleted(pTHS->pDB)
        || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                       DBGETATTVAL_fREALLOC,
                       pTransportDN->structLen, &cb,
                       (BYTE **) &pTransportDN)) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_MAIL_INTERSITE_TRANSPORT_MISSING,
                     szInsertDN(pTransportDN),
                     NULL,
                     NULL);

        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    // What attribute of our server object holds our transport-
    // specific address for this transport?
    GetExpectedRepAtt(pTHS->pDB,
                      ATT_TRANSPORT_ADDRESS_ATTRIBUTE,
                      &attAddress,
                      sizeof(attAddress));

    // Get our transport-specific address.
    pmtxOurAddress = draGetTransportAddress(pTHS->pDB,
                                            gAnchor.pDSADN,
                                            attAddress);

    // Build our request message.
    draConstructGetChgReq(pTHS,
                          pNC,
                          pRepLink,
                          pUpToDateVecDest,
                          pPartialAttrSet,
                          pPartialAttrSetEx,
                          ulOptions,
                          &msgReq);

    //
    // Determine which version to send to the source.
    //

    // default: W2K compatible
    dwInMsgVersion = 4;

    if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
        // up version if forest is homogenious at whistler level
        dwInMsgVersion = 7; // whistler compatible
    }
    else {
        // Get target behavior version
        ZeroMemory(&dsTarget, sizeof(DSNAME));
        dsTarget.structLen = DSNameSizeFromLen(0);
        dsTarget.Guid = pRepLink->V1.uuidDsaObj;
        dwTargetBehavior = 0;

        ulErr = GetBehaviorVersion(pTHS->pDB, &dsTarget, &dwTargetBehavior);
        if ( ERROR_SUCCESS == ulErr &&
             dwTargetBehavior >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
            // up version since target dsa speaks our language.
            dwInMsgVersion = 7; // whistler compatible
        }
    }


    // And off it goes...
    ulErr = SendReqUpdateMsg(pTHS,
                             pTransportDN,
                             RL_POTHERDRA(pRepLink),
                             &pRepLink->V1.uuidInvocId,
                             &pRepLink->V1.uuidDsaObj,
                             pmtxOurAddress,
                             dwInMsgVersion,
                             &msgReq);
    if (ulErr) {
        // Let manual sync caller know there was an error.
        DRA_EXCEPT(ulErr, 0);
    }

    THFreeEx(pTHS, pmtxOurAddress);

    if (NULL != pUpToDateVecDest) {
        THFreeEx(pTHS, pUpToDateVecDest);
    }

    THFreeEx(pTHS, pTransportDN);
} /* draSendMailRequest */


void
sendNextMailRequestHelp(
    IN THSTATE *pTHS,
    IN DSNAME *pNC,
    IN UUID *puuidDsaObjSrc,
    IN BOOL fExtendedDataAllowed
    )

/*++

Routine Description:

    Helper routine for ProcessUpdReplica

    This point divides two separate phases: the reply processing phase above,
    and the request issuing phase below.  Note that the input parameters for the
    request, the USN from vector, the rep flags, and the UTD vector, are all
    re-read at this point.  They are not passed down through variables.  This
    makes the phase below stateless; it also means that any state going forward
    has to be written to the reps-from above in order to take effect.

    Send the next mail request

Arguments:

    pTHS - thread state
    pNC - DSNAME of naming context
    puuidDsaObjSrc - uuid of src dsa

Return Value:

    None

--*/

{
    BOOL                    fHasRepsFromValues;
    DWORD                   cb;
    DWORD                   dwRet;
    REPLICA_LINK *          pRepLink;
    UPTODATE_VECTOR *       pUpToDateVecDest = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    SYNTAX_INTEGER          it;

    BeginDraTransaction(SYNC_WRITE);
    Assert(OWN_DRA_LOCK());    // We better own it

    __try {
        dwRet = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it);
        if (dwRet) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, dwRet);
        }

        if (FindDSAinRepAtt(pTHS->pDB,
                            ATT_REPS_FROM,
                            DRS_FIND_DSA_BY_UUID,
                            puuidDsaObjSrc,
                            NULL,
                            &fHasRepsFromValues,
                            &pRepLink,
                            &cb)) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Make sure we still have a mail-based link
        if (!(pRepLink->V1.ulReplicaFlags & DRS_MAIL_REP)) {
            CHAR szUuid[40];
            // Couldn't find source DRA as someone we replicate from.
            DPRINT1( 0, "Discarding message because we no longer replicate from source %s over mail\n",
                     DsUuidToStructuredString( puuidDsaObjSrc, szUuid ) );
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_BASIC,
                     DIRLOG_DRA_MAIL_UPDREP_BADSRC,
                     szInsertDN(pNC),
                     szInsertUUID(puuidDsaObjSrc),
                     NULL);
            DRA_EXCEPT (ERROR_DS_DRA_NO_REPLICA, 0);
        }

        UpToDateVec_Read(pTHS->pDB,
                         it,
                         UTODVEC_fUpdateLocalCursor,
                         DBGetHighestCommittedUSN(),
                         &pUpToDateVecDest);

        if (!(pRepLink->V1.ulReplicaFlags & DRS_WRIT_REP)){

            //
            // GC ReadOnly Replication
            //  - Partial-Attribute-Set setup:
            //      - For GC replication, ship over PAS from NC head
            //      - for PAS cycles, get also extended attrs from replink
            //

            GC_GetPartialAttrSets(
                pTHS,
                pNC,
                pRepLink,
                &pPartialAttrSet,
                &pPartialAttrSetEx);

                if (pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) {

                    //
                    // PAS cycle:
                    //  - ensure we have the extended set
                    //  - notify admin
                    //

                    Assert(pPartialAttrSet);
                    Assert(pPartialAttrSetEx);
                    // Log so the admin knows what's going on.
                    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GC_PAS_CYCLE,
                             szInsertWC(pNC->StringName),
                             szInsertMTX(RL_POTHERDRA(pRepLink)),
                             NULL
                             );
                }
        }


        Assert(OWN_DRA_LOCK());    // We better own it

        draSendMailRequest(
            pTHS,
            pNC,
            0,
            pRepLink,
            pUpToDateVecDest,
            pPartialAttrSet,
            pPartialAttrSetEx );
    }
    __finally {
        EndDraTransaction(!AbnormalTermination());
        Assert(OWN_DRA_LOCK());    // We better own it
    }

} /* sendNextMailRequestHelp */


DWORD
applyReplyPacket(
    IN THSTATE *pTHS,
    IN LPWSTR pszSourceServer,
    IN DRS_MSG_GETCHGREPLY_NATIVE *pUpdReplicaMsg,
    IN OUT ULONG *pulRepFlags,
    OUT PBYTE schemaInfo,
    OUT USN_VECTOR *pusnvecSyncPoint,
    OUT DWORD *pdwNCModified
    )

/*++

Routine Description:

    Apply one reply packet

Arguments:

    pTHS - thread state
    pszSourceServer - name of source server
    pUpdReplicaMsg - the reply message
    pulRepFlags - replication flags, may be updated
    schemaInfo - schema info, may be updated
    pusnvecSyncPoint - position, may be updated
    pdwNCModified - modified flag, may be updated

Return Value:

    DWORD - 

--*/

{
    ULONG ret = ERROR_SUCCESS;
    ULONG ulSyncFailure = 0;
    DRA_REPL_SESSION_STATISTICS replStats = {0};

    // Set the count of remaining entries to update.
    ISET(pcRemRepUpd, pUpdReplicaMsg->cNumObjects);

    // Strip out the schema info from the prefix table.
    // It is there, since current versions send it and
    // ProcessMailMsg checks that the version no.s are
    // compatible before doing anything

    StripSchInfoFromPrefixTable(&pUpdReplicaMsg->PrefixTableSrc, schemaInfo);

    __try {
	
	Assert(!fNullUuid(&(pUpdReplicaMsg->uuidDsaObjSrc)));

	DRA_AUDITLOG_REPLICASYNC_MAIL_BEGIN(pTHS, 
					    pszSourceServer, //pszDSA,
					    &(pUpdReplicaMsg->uuidDsaObjSrc), //invocationid, 
					    pUpdReplicaMsg->pNC, //pNC,
					    0); //ulOptions
	
	ret = UpdateNC(pTHS,
		       pUpdReplicaMsg->pNC,
		       pUpdReplicaMsg,
		       pszSourceServer,
		       &ulSyncFailure,
		       (*pulRepFlags) | DRS_GET_ANC,
		       pdwNCModified,
		       &replStats.ObjectsCreated,
		       &replStats.ValuesCreated,
		       schemaInfo,
		       0 /* no special flags */);
    }
    __except(GetDraException((GetExceptionInformation()), &ret)) {
    }
    
    DRA_AUDITLOG_REPLICASYNC_MAIL_END(pTHS, 
				      pszSourceServer, //pszDSA,
				      &(pUpdReplicaMsg->uuidDsaObjSrc), //invocationid, 
				      pUpdReplicaMsg->pNC, //pNC,
				      0,
				      &(pUpdReplicaMsg->usnvecTo),
				      ret);	
    
    Assert(OWN_DRA_LOCK());    // We better own it
    
    // If we had no sync failure...
    if ( (!ret) && (!ulSyncFailure) ) {

        replStats.ObjectsReceived = pUpdReplicaMsg->cNumObjects;
        replStats.ValuesReceived = pUpdReplicaMsg->cNumValues;
        replStats.SourceNCSizeObjects = pUpdReplicaMsg->cNumNcSizeObjects;
        replStats.SourceNCSizeValues = pUpdReplicaMsg->cNumNcSizeValues;

        // Report progress on any kind of "full sync"
        if (pUpdReplicaMsg->usnvecFrom.usnHighPropUpdate == 0) {
            // ISSUE wlees Aug 29, 2000. This reporting interface loses
            // information because we don't preserve the statistics across a
            // series of calls. The totals across a session (series of exchanges)
            // are not kept. Also, if updateNC creates some objects and then
            // returns an error, those objects are never counted.
            draReportSyncProgress(
                pTHS,
                pUpdReplicaMsg->pNC,
                pszSourceServer,
                pUpdReplicaMsg->fMoreData,
                &replStats );
        }

        // Leave "full sync packet" mode on successful packet
        (*pulRepFlags) &= ~DRS_FULL_SYNC_PACKET;

        // we are synced to the usn we received in the mail msg.
        (*pusnvecSyncPoint) = pUpdReplicaMsg->usnvecTo;

    } else if (ret == DRAERR_NotEnoughAttrs) {
        // Not enough properties sent to create an object
        
        Assert((!((*pulRepFlags) & DRS_FULL_SYNC_PACKET)) &&
               (!((*pulRepFlags) & DRS_FULL_SYNC_NOW)) &&
               (!((*pulRepFlags) & DRS_FULL_SYNC_IN_PROGRESS)) );

        // Re-request all properties
        (*pulRepFlags) |= DRS_FULL_SYNC_PACKET;
    }

    // Incorporate warning status
    return ret ? ret : ulSyncFailure;
} /* applyOneReply */


BOOL
applyMailUpdateHelp(
    IN THSTATE *pTHS,
    IN ULONG ulRepFlags,
    IN LPWSTR pszSourceServer,
    IN REPLICA_LINK *pRepLink,
    IN DRS_MSG_GETCHGREPLY_NATIVE *pUpdReplicaMsg
    )

/*++

Routine Description:

    Description

Arguments:

    pTHS - thread state
    ulRepFlags - replication flags
    pszSourceServer - name of source server
    pRepLink - The replica link for this source
    pUpdReplicaMsg - The native reply

Return Value:

    BOOL - Whether another request should be sent

--*/

{
    ULONG                   ret = 0;
    ULONG                   ret2;
    ULONG                   ulResult;
    USN_VECTOR              usnvecSyncPoint;
    DWORD                   dwNCModified = MODIFIED_NOTHING;
    BOOL                    fSendNextRequest = FALSE;
    BYTE                    schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    BOOL                    fSchInfoChanged = FALSE;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    SYNTAX_INTEGER          it;

    // note how up to sync we are to start off with
    usnvecSyncPoint = pUpdReplicaMsg->usnvecFrom;

    if (!pUpdReplicaMsg->dwDRSError) {
        ulResult = applyReplyPacket(
            pTHS,
            pszSourceServer,
            pUpdReplicaMsg,
            &ulRepFlags,
            schemaInfo,
            &usnvecSyncPoint,
            &dwNCModified
            );
    } else {
        ulResult = pUpdReplicaMsg->dwDRSError;
        DPRINT3( 1, "Source %ls partition %ls returned mail-based sync reply with extended error %d\n",
                 pszSourceServer, pUpdReplicaMsg->pNC->StringName, ulResult );
    }

    // Update repsFrom.
    BeginDraTransaction(SYNC_WRITE);

    __try {
        // Note that the old RepsFrom might have disappeared -- this
        // is expected when we get our first packet for a read-only
        // NC, as at the outset we have a placeholder NC that is
        // destroyed and replaced with the real NC head in the first
        // packet.

        ret2 = UpdateRepsFromRef(pTHS,
                                 DRS_UPDATE_ALL,  // Modify whole repsfrom
                                 pUpdReplicaMsg->pNC,
                                 DRS_FIND_DSA_BY_UUID,
                                 URFR_NEED_NOT_ALREADY_EXIST,
                                 &pUpdReplicaMsg->uuidDsaObjSrc,
                                 &pUpdReplicaMsg->uuidInvocIdSrc,
                                 &usnvecSyncPoint,
                                 &pRepLink->V1.uuidTransportObj,
                                 RL_POTHERDRA(pRepLink),
                                 ulRepFlags,
                                 &pRepLink->V1.rtSchedule,
                                 ulResult,
                                 NULL);

        if ((0 == ulResult) && (0 == ret2)
            && !pUpdReplicaMsg->fMoreData) {
            // we're now up-to-date with respect to the source DSA, so
            // we're also now transitively up-to-date with respect to
            // other DSAs to at least the same point as the source DSA

            ret = FindNC(pTHS->pDB,
                         pUpdReplicaMsg->pNC,
                         FIND_MASTER_NC | FIND_REPLICA_NC,
                         &it);
            if (ret) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, ret);
            }

            if (it & IT_NC_COMING) {
                // The initial inbound replication of this NC is now
                // complete.
                ret = ChangeInstanceType(pTHS,
                                         pUpdReplicaMsg->pNC,
                                         it & ~IT_NC_COMING,
                                         DSID(FILENO,__LINE__));
                if (ret) {
                    DRA_EXCEPT(ret, 0);
                }
            }

            if ( ulRepFlags & DRS_SYNC_PAS ) {
                //
                // We've had completed a successful PAS cycle.
                // At this point we can only claim to be as up to date as our source.
                // Action:
                //  - Overwrite our UTD w/ the source's UTD.
                //  - complete PAS replication:
                //      - reset other links USN vectors
                //      - reset this source's flags
                //
                //
                UpToDateVec_Replace(
                    pTHS->pDB,
                    &pUpdReplicaMsg->uuidInvocIdSrc,
                    &pUpdReplicaMsg->usnvecTo,
                    pUpdReplicaMsg->pUpToDateVecSrc);

                // assert: must have PAS data for PAS cycles
                GC_GetPartialAttrSets(
                    pTHS,
                    pUpdReplicaMsg->pNC,
                    pRepLink,
                    &pPartialAttrSet,
                    &pPartialAttrSetEx);
                Assert(pPartialAttrSet && pPartialAttrSetEx);

                // do the rest: USN water marks & update repsFrom
                (void)GC_CompletePASReplication(
                    pTHS,
                    pUpdReplicaMsg->pNC,
                    &pRepLink->V1.uuidDsaObj,
                    pPartialAttrSet,
                    pPartialAttrSetEx);
                ulRepFlags &= ~DRS_SYNC_PAS;
            }
            else {

                // pUpToDateVecSrc may be null here for legitimate reasons
                Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(pUpdReplicaMsg->pUpToDateVecSrc));
#if DBG
                {
                    USN usn;
                    // puptodvecRemote should already contain an entry for the source DSA.
                    Assert(
                        (!pUpdReplicaMsg->pUpToDateVecSrc) ||
                        ( UpToDateVec_GetCursorUSN(
                            pUpdReplicaMsg->pUpToDateVecSrc,
                            &pUpdReplicaMsg->uuidInvocIdSrc,
                            &usn) &&
                          (usn >= pUpdReplicaMsg->usnvecTo.usnHighPropUpdate) ) );
                }
#endif
                // improve our up-to-date vector for this NC
                if (pUpdReplicaMsg->pUpToDateVecSrc) {
                    UpToDateVec_Improve(pTHS->pDB, pUpdReplicaMsg->pUpToDateVecSrc);
                }
            }

            ulRepFlags &= ~DRS_FULL_SYNC_IN_PROGRESS;

            // Notify replicas
            DBNotifyReplicasCurrDbObj(pTHS->pDB, FALSE /*!urgnt*/);
        }
    }
    __finally {
        EndDraTransaction(!(ret2 || AbnormalTermination()));
        Assert(OWN_DRA_LOCK());    // We better own it
    }

    // Determine if we request another packet
    // On error, we want to be careful not to re-request a packet that is
    // going to fail again.  Better to wait for next period.
    // Note that we do not retry on error since we want to avoid
    // an infinite retry loop.
    fSendNextRequest = ( (0 == ulResult) && (pUpdReplicaMsg->fMoreData) );

    // If the sync was successful and we have no more data to sync,
    // write the schema info in case of schema NC sync
    if (DsaIsRunning() && NameMatched(gAnchor.pDMD,pUpdReplicaMsg->pNC)) {
        if (!ulResult && !fSendNextRequest) {
            // Update the schema-info value only if the replication
            // is successful, and there is nothign more to sync

            fSchInfoChanged = FALSE;
            WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged);
        }

        // if any "real" schema changes happened, up the global
        // to keep track of schema changes since boot, so that
        // later schema replications can check if thy have an updated
        // schema cache. Do this even if the whole NC replication
        // failed, since this indicates at least one object has
        // been changed.

        if (MODIFIED_NCTREE_INTERIOR == dwNCModified) {
            IncrementSchChangeCount(pTHS);
        }

        // force a cache update if anything cached changed
        if ( (MODIFIED_NCTREE_INTERIOR == dwNCModified) || fSchInfoChanged) {

            if (!SCSignalSchemaUpdateImmediate()) {
                // couldn't signal a schema update
                // Event will be logged in the exception handler
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }
        }
    }

    return fSendNextRequest;

} /* applyMailUpdateHelp */

void
ProcessUpdReplica(
    IN  THSTATE *       pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    IN  BOOL            fExtendedDataAllowed,
    IN  PDSNAME         pSourceNtdsDsaDN
    )
/*++

Routine Description:

    Service a GetNCChanges() reply received via ISM.

Similar to the synchronous code, there are three ways that "full sync" may be
indicated in this code:
1. usnvecfrom was set to scratch.  UTD is valid. When a replica is added, this
   is the kind of full sync that happens the first time.  See the call to
   ReplicaSync in ReplicaAdd().
2. FULL_SYNC_NOW specified to ReplicaAdd. In draConstructGetChg, we set the
usn vec from to scratch, and the UTD to NULL.  In Replica Add, if FULL_SYNC_NOW
was specified, FULL_SYNC_IN_PROGRESS was written to the Reps-From. See case 3.
3. After we have received a packet, and we are constructing another request,
we check whether FULL_SYNC_IN_PROGRESS was saved in the reps-from flags. If so,
we leave the usn as is, and we set the UTD to NULL.

Arguments:

    pTHS (IN) - Ye old thread state.

    pMailRepMsg (IN) - Mail message

    fExtendedDataAllowed (IN) - Whether source allows variable headers

Return Values:

    None.  Generates DRA exception on failure.

--*/
{
    DRS_MSG_GETCHGREPLY             InboundReply;
    DRS_MSG_GETCHGREPLY_NATIVE *    pNativeReply = &InboundReply.V6;
    REPLICA_LINK *                  pRepLink;
    ULONG                           ret = 0;
    ULONG                           ulRepFlags;
    BOOL                            fSendNextRequest = FALSE;
    DSTIME                          timeStarted;
    LPWSTR                          pszSourceServer = NULL;
    RPC_STATUS                      rpcStatus;

    // Get the DRA mutex before we check that we replicate this NC.
    GetDRASyncLock ();
    Assert(OWN_DRA_LOCK());    // We better own it
    timeStarted = GetSecondsSince1601();

    __try {
        BeginDraTransaction(SYNC_READ_ONLY);

        __try {
            // Decode according to proper version
            ret = draDecodeReply(pTHS,
                                 pMailRepMsg->dwMsgVersion,
                                 MAIL_REP_MSG_DATA(pMailRepMsg),
                                 pMailRepMsg->cbDataSize,
                                 &InboundReply);
            if (ret) {
                // Event already logged
                DRA_EXCEPT(ret, 0);
            }

            // Note that a Whistler source may send us a normal full reply
            // or a simple error reply.  An error reply has only the minimum
            // fields filled in. 

            draXlateInboundReplyToNativeReply(pTHS,
                                              pMailRepMsg->dwMsgVersion,
                                              &InboundReply,
                                              0,
                                              pNativeReply );

            if(   0!=UuidCompare(&pNativeReply->uuidDsaObjSrc, &pSourceNtdsDsaDN->Guid, &rpcStatus)
               || RPC_S_OK!=rpcStatus )
            {
                Assert( !"Error: DSA from cert does not match DSA from reply structure" );
                DRA_EXCEPT(DRAERR_AccessDenied, 0);
            }

            // Abort if inbound replication is disabled.
            // Note that there is no accomodation for the DRS_SYNC_FORCED flag
            // (which is used solely as a test hook for RPC-based replication).
            if (gAnchor.fDisableInboundRepl) {
                DRA_EXCEPT(DRAERR_SinkDisabled, 0);
            } 

            // check we should/would recieve updates from this source.
            CheckUpdateMailSource(pTHS,
                                  pTHS->pDB,
                                  pSourceNtdsDsaDN,
                                  pNativeReply,
                                  &pRepLink); 

            pszSourceServer = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepLink));

            VALIDATE_REPLICA_LINK_VERSION(pRepLink);

            // Save replica flags
            ulRepFlags = pRepLink->V1.ulReplicaFlags;
        }
        __finally {
            EndDraTransaction (!AbnormalTermination());
            Assert(OWN_DRA_LOCK());    // We better own it
        }

        // Check compatibility of source

        if (0 != memcmp(&pNativeReply->usnvecFrom,
                        &gusnvecFromScratch,
                        sizeof(gusnvecFromScratch))) {
            // Not the first packet of changes.
            if (0 != memcmp(&pNativeReply->usnvecFrom,
                            &pRepLink->V1.usnvec,
                            sizeof(pRepLink->V1.usnvec))) {
                // Out of sequence message, discard.
                DPRINT1(0, "Discarding out-of-sequence message from %ws.\n",
                        pszSourceServer );
                DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
            }
        }

        // Increment active threads to avoid sudden termination
        InterlockedIncrement((ULONG *)&ulcActiveReplicationThreads);

        __try {
            // Apply Updates phase
            fSendNextRequest = applyMailUpdateHelp(
                pTHS,
                ulRepFlags,
                pszSourceServer,
                pRepLink,
                pNativeReply );

            // Send next message phase

            Assert(OWN_DRA_LOCK());    // We better own it
            if (fSendNextRequest && !eServiceShutdown) {
                // Send request for next batch of changes.

                sendNextMailRequestHelp( pTHS,
                                         pNativeReply->pNC,
                                         &pNativeReply->uuidDsaObjSrc,
                                         fExtendedDataAllowed );

            } // if next request...
        }
        __finally {
            // No more remaining entries.
            ISET (pcRemRepUpd, 0);

            // Thread can be terminated now.
            InterlockedDecrement((ULONG *) &ulcActiveReplicationThreads);
            Assert(OWN_DRA_LOCK());    // We better own it
        }
    }
    __finally {
        DWORD cMinsDiff = (DWORD) ((GetSecondsSince1601() - timeStarted) / 60);

        FreeDRASyncLock();

        if ( (cMinsDiff > gcMaxMinsSlowReplWarning) &&
            IsDraOpWaiting() &&
            pNativeReply->pNC) {
            CHAR szUuid[40];

            DPRINT4( 0, "Perf warning: Mail update nc %ws, source %s, status %d took %d mins.\n",
                     pNativeReply->pNC->StringName,
                     DsUuidToStructuredString( &(pNativeReply->uuidDsaObjSrc), szUuid ),
                     ret, cMinsDiff );
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DRA_REPLICATION_FINISHED,
                      szInsertUL(cMinsDiff),
                      szInsertSz("Mail Synchronization Update"),
                      szInsertHex(0), // Options
                      szInsertUL(ret),
                      szInsertDN(pNativeReply->pNC),
                      szInsertUUID(&(pNativeReply->uuidDsaObjSrc)),
                      NULL,
                      NULL);
        }
    }
}

void
CheckForMail(void)
/*++

Routine Description:

    Receives and dispatches inbound intersite messages.  Terminates on shutdown
    or when ISM service is not running.

Arguments:

    None.

Return Values:

    None.

--*/
{
    MAIL_REP_MSG *  pMailRepMsg;
    ULONG           cbMsgSize;
    ULONG           ulRet;
    LPWSTR          pszTransportDN;
    ISM_MSG *       pIsmMsg;

    // Ensure mail running. Normally is at this point, but may
    // have failed earlier. If running, or starts, check for messages.

    __try {

        if (DRAEnsureMailRunning() == DRAERR_Success) {

            // While we have mail messages, remove them from the queue.
            while (!eServiceShutdown) {
                ulRet = I_ISMReceive(DRA_ISM_SERVICE_NAME, INFINITE, &pIsmMsg);

                if (eServiceShutdown) {
                    // DS is shutting down; clear out.
                    break;
                }
                else if (NO_ERROR == ulRet) {
                    Assert(NULL != pIsmMsg);

                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_EXTENSIVE,
                             DIRLOG_DRA_MAIL_RECEIVED,
                             szInsertUL( pIsmMsg->cbData ),
                             szInsertWC( pIsmMsg->pszSubject ),
                             NULL );

                    __try {
                        ProcessMailMsg(pIsmMsg);
                    }
                    __finally {
                        // Free memory allocated by I_ISMReceive().
                        I_ISMFree(pIsmMsg);
                    }
                }
                else if ( (RPC_S_SERVER_UNAVAILABLE == ulRet) ||
                          (ERROR_SHUTDOWN_IN_PROGRESS == ulRet) ) {
                    // ISM service has been stopped?
                    // Wait and then exit, calling thread will retry.
                    DPRINT(0, "ISM service stopped.\n");
                    gfDRAMailRunning = FALSE;
                    DRA_SLEEP(MAIL_START_RETRY_PAUSE_MSECS);
                    break;
                }
                else {
                    // Error retrieving message.
                    DPRINT1(0, "Error %d retrieving mail message.\n", ulRet);
                    LogEvent8(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_EXTENSIVE,
                              DIRLOG_DRA_MAIL_ISM_RECEIVE_RETRY,
                              szInsertWin32Msg( ulRet ),
                              szInsertUL( MAIL_RCVERR_RETRY_PAUSE_MINS ),
                              szInsertWin32ErrCode( ulRet ),
                              NULL, NULL, NULL, NULL, NULL );
                    DRA_SLEEP(MAIL_RCVERR_RETRY_PAUSE_MSECS);
                }
            }
        } else {
            // Ok, mail is not running for some reason, wait and then exit,
            // calling thread will retry
            DRA_SLEEP(MAIL_START_RETRY_PAUSE_MSECS);
        }
    } __except (GetDraException((GetExceptionInformation()), &ulRet)) {
        // Handle error. Any error conditions are logged earlier.
        ;
    }
}


ULONG __stdcall
MailReceiveThread(
    IN  void *  pvIgnored
    )
/*++

Routine Description:

    Thread to retrieve and process inbound intersite messages.  Terminates on
    shutdown.

Arguments:

    pvIgnored (IN) - Ignored.

Return Values:

    None.

--*/
{
    while (!eServiceShutdown) {
        CheckForMail();
    }

    return 0;
}


ULONG
DRAEnsureMailRunning()
/*++

Routine Description:

    Determines whether the ISM service is running.

Arguments:

    None.

Return Values:

    DRAERR_Success - Running.

    DRAERR_MailProblem - Not running.

--*/
{
    SERVICE_STATUS  ServiceStatus;
    SC_HANDLE       hSCM = NULL;
    SC_HANDLE       hService = NULL;

    if (gfDRAMailRunning) {
        return DRAERR_Success;
    }

    // Is the ISM service running?
    __try {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (NULL == hSCM) {
            DPRINT1(1, "Unable to OpenSCManager(), error %d.\n", GetLastError());
            __leave;
        }

        hService = OpenService(hSCM, "ismserv", SERVICE_QUERY_STATUS);
        if (NULL == hService) {
            DPRINT1(1, "Unable to OpenService(), error %d.\n", GetLastError());
            __leave;
        }

        if (!QueryServiceStatus(hService, &ServiceStatus)) {
            DPRINT1(1, "Unable to QueryServiceStatus(), error %d.\n", GetLastError());
            __leave;
        }

        if (SERVICE_RUNNING == ServiceStatus.dwCurrentState) {
            DPRINT(0, "ISMSERV is running.\n");
            gfDRAMailRunning = TRUE;
        }
    }
    __finally {
        if (hService != NULL) {
            CloseServiceHandle(hService);
        }

        if (hSCM != NULL) {
            CloseServiceHandle(hSCM);
        }
    }

    return gfDRAMailRunning ? DRAERR_Success : DRAERR_MailProblem;
}


DRS_COMP_ALG_TYPE
GetCompressionAlg( VOID )
/*++

Routine Description:

   Returns the compression algorithm as requested by the user

Arguments:

    None.

Return Values:

    A valid value for DRS_COMP_ALG_TYPE
    
--*/
{
    switch ((DRS_COMP_ALG_TYPE)gulDraCompressionAlg) {
    case DRS_COMP_ALG_NONE:
    case DRS_COMP_ALG_MSZIP:
    case DRS_COMP_ALG_XPRESS:
        return (DRS_COMP_ALG_TYPE)gulDraCompressionAlg;
        break;
    default:
        // Map illegal values to the default
        return DRS_COMP_ALG_XPRESS;
    }
}

ULONG
GetCompressionLevel( VOID )
/*++

Routine Description:

    Returns the level at which the blobs of data should be compressed. This value can
    be set with the registry key defined by DRA_REPL_COMPRESSION_LEVEL.

Arguments:

    None.

Return Values:

    A value between 0 and MAX_COMPRESSION_LEVEL.
    
--*/
{
    return DWORDMIN( gulDraCompressionLevel, MAX_COMPRESSION_LEVEL );
}


/*
 * Simple wrappers around THAlloc for use by the Xpress compression functions below.
 */
void * XPRESS_CALL xpressAlloc(void* context, int size) {
    return THAlloc(size);
}

void XPRESS_CALL xpressFree(void* context, void* address) {
    THFree(address);
}


ULONG
draUncompressBlobXpress(
    OUT BYTE *      pOutputBuffer,
    IN  ULONG       cbOutputBuffer,
    IN  BYTE *      pInputBuffer,
    IN  ULONG       cbInputBuffer
    )
/*++

Routine Description:

    Uncompress a buffer of blocks that was generated by draCompressBlobXpress().

    Blob Diagram:

    Block 0: <Uncomp. Len>   <Comp. Len>   <............ Data ............>
    Block 1: <Uncomp. Len>   <Comp. Len>   <............ Data ............>
    Block 2: <Uncomp. Len>   <Comp. Len>   <............ Data ............>

    Each block starts on a DWORD-aligned boundary and contains an uncompressed
    length, a compressed length, and a block of data. If the compressed length
    equals the uncompressed length, the data is not compressed. If the compressed
    length is less than the uncompressed length, the block is compressed. This means
    that a compressed blob may contain a mix of compressed and uncompressed
    blocks.
    
    The starting offset of each block is determined by finding the end of the
    data in the previous block and then rounding up to the nearest DWORD-aligned
    offset.

    Each block is stored as a MAIL_COMPRESS_BLOCK, just as a convenient way of
    stuffing the lengths into the byte stream. The MAIL_COMPRESS_BLOCK structure
    is never marshalled. Thus, their endianness is not properly adjusted to network
    endianness. This function will break if it is ever ported to big-endian machines.
 
Arguments:

    pOutputBuffer (OUT) - The output buffer for the uncompressed data.

    cbOutputBuffer (IN) - The size of the output buffer.

    pInputBuffer (IN)   - The input buffer which contains data blocks.

    cbInputBuffer (IN)  - The size of the input buffer.

Return Values:

    0 - Uncompression failed. The contents of pOutputBuffer are invalid and
        should be discarded.

   >0 - The size of the (successfully) uncompressed data.

--*/
{
    XpressDecodeStream      xpressStream;
    MAIL_COMPRESS_BLOCK    *pInputBlockHdr;
    BYTE                   *pOutputBlock;

    DWORD   cbInputProcessed;   /* Count of bytes from the input buffer that have been processed */
    DWORD   cbInputBlock;       /* The size of the current input block */

    DWORD   cbOutputBlock;      /* The uncompressed size of the current block */
    DWORD   cbOutputSize;       /* Amount of used space in the output buffer */
    int     result;             /* Return value of xpressDecode */

    DPRINT1(2,"XPRESS: Uncompress Start. Compressed blob size=%d\n",cbInputBuffer);
    Assert( NULL!=pOutputBuffer && NULL!=pInputBuffer );

    /* Neither the input or output buffers have been touched yet. */
    cbInputProcessed = cbOutputSize = 0;

    /* Create the 'stream', which is a context for doing the uncompression */
    xpressStream = XpressDecodeCreate( NULL, xpressAlloc );
    if( !xpressStream ) {
        return 0;
    }
    
    while( cbInputProcessed<cbInputBuffer ) {
        
        /* Figure out where the next input block header will start (it must
         * be on a DWORD-aligned boundary. Check that we don't step out of
         * the input buffer. */
        cbInputProcessed = ROUND_UP_COUNT(cbInputProcessed, sizeof(DWORD));
        if( cbInputProcessed+sizeof(MAIL_COMPRESS_BLOCK) > cbInputBuffer ) {
            Assert( !"XPRESS: Stepped out of input buffer" );
            return 0;
        }
        pInputBlockHdr = (MAIL_COMPRESS_BLOCK*) &pInputBuffer[ cbInputProcessed ];
        cbInputProcessed += sizeof(MAIL_COMPRESS_BLOCK);
        cbInputBlock = pInputBlockHdr->cbCompressedSize;
        if( cbInputProcessed+cbInputBlock > cbInputBuffer ) {
            Assert( !"XPRESS: Stepped out of input buffer" );
            return 0;
        }

        /* Get a pointer to the current position in the output buffer and
         * check that we will not overflow the output buffer */
        pOutputBlock = &pOutputBuffer[ cbOutputSize ];
        cbOutputBlock = pInputBlockHdr->cbUncompressedSize;
        Assert( cbOutputBlock>=cbInputBlock );
        if( cbOutputSize+cbOutputBlock > cbOutputBuffer ) {
            Assert( !"XPRESS: Overflowed the output buffer" );
            return 0;
        }

        /* If the compressed size and uncompressed size of the input block are
         * the same, the data is not compressed. */
        if( cbInputBlock==cbOutputBlock ) {
            /* Input block is not compressed. Copy it to the output buffer as is. */
            memcpy( pOutputBlock, pInputBlockHdr->data, cbInputBlock );
        } else {
            /* Decode the current input block into the output buffer. */
            result = XpressDecode( xpressStream, pOutputBlock, cbOutputBlock,
                cbOutputBlock, pInputBlockHdr->data, cbInputBlock );
            if( result!=cbOutputBlock ) {
                Assert( !"XPRESS: XpressDecode failed" );
                return 0;
            }
        }

        cbInputProcessed += cbInputBlock;
        cbOutputSize += cbOutputBlock;
    }

    XpressDecodeClose( xpressStream, NULL, xpressFree );

    DPRINT2(2,"XPRESS: Uncompress End. Compressed blob size=%d, "
              "Uncompressed blob size=%d\n",cbInputBuffer,cbOutputSize);
    return cbOutputSize;
}


ULONG
draCompressBlobXpress(
    OUT BYTE *  pOutputBuffer,
    IN  ULONG   cbOutputBuffer,
    IN  BYTE *  pInputBuffer,
    IN  ULONG   cbInputBuffer
    )
/*++

Routine Description:

    Compress the data in pInputBuffer using the Xpress compression library.

    Divide the data in the pInputBuffer buffer into blocks.
    For each block
        Add a block-header header to the pOutputBuffer buffer
        Compress the block.
        If the compressed succeeded
            Add the compressed block to the pOutputBuffer buffer
        Else
            Add the uncompressed block to the pOutputBuffer buffer
    End For

    If the resulting compressed blob is larger than the uncompressed blob, the
    compressed blob is discarded and an uncompressed message is sent instead.

    For a description of the compressed blob, see draUncompressBlobXpress().

Arguments:

    pOutputBuffer (OUT) - The output buffer for output data blocks.

    cbOutputBuffer (IN) - The size of the output buffer.

    pInputBuffer (IN)   - The original, uncompressed input buffer.

    cbInputBuffer (IN)  - The size of the original, uncompressed data.

Return Values:

    0 - Either a catastrophic compression failure occurred, or the
        data didn't fit into the pOutputBuffer buffer. The contents
        of the pOutputBuffer are not valid and should be discarded.

   >0 - The size of the successfully compressed data, which is now
        stored in pOutputBuffer.

--*/
{
    XpressEncodeStream      xpressStream;
    MAIL_COMPRESS_BLOCK    *pOutputBlockHdr;
    BYTE*                   pInputBlock;

    DWORD   cbInputBlockMax;    /* The maximum size of a block of input data */
    DWORD   cbInputProcessed;   /* Count of bytes from the input buffer that have been processed */
    DWORD   cbInputBlock;       /* The size of the current input block */

    DWORD   cbOutputBlockMax;   /* The maximum available size for the current output block */
    DWORD   cbOutputSize;       /* Amount of used space in the output buffer */
    DWORD   cbCompBlock;        /* The size of the current compressed block */

    DPRINT1(2,"XPRESS: Compress Start. Uncompressed blob size=%d\n",cbInputBuffer);
    Assert( NULL!=pOutputBuffer && NULL!=pInputBuffer );

    /* This is the maximum input block size that Xpress can handle */
    cbInputBlockMax = XPRESS_MAX_BLOCK;

    /* Neither the input or output buffers have been touched yet. */
    cbInputProcessed = cbOutputSize = 0;

    /* Create the 'stream', which is a context for doing the compression */
    xpressStream = XpressEncodeCreate( cbInputBlockMax, NULL, xpressAlloc, GetCompressionLevel() );
    if( !xpressStream ) {
        return 0;
    }

    while( cbInputProcessed<cbInputBuffer ) {

        /* Get a pointer to the current position in the input buffer and determine
         * the size of the current input block. */
        pInputBlock = &pInputBuffer[ cbInputProcessed ];
        cbInputBlock = DWORDMIN( cbInputBlockMax, cbInputBuffer-cbInputProcessed );

        /* Figure out where the next output block header will start (it must
         * be on a DWORD-aligned boundary). */
        cbOutputSize = ROUND_UP_COUNT(cbOutputSize, sizeof(DWORD));
        pOutputBlockHdr = (MAIL_COMPRESS_BLOCK*) &pOutputBuffer[ cbOutputSize ];

        /* Check that we have not exceeded the bounds of the buffer. */
        cbOutputSize += sizeof(MAIL_COMPRESS_BLOCK);
        if( cbOutputSize>cbOutputBuffer ) {
            return 0;
        }
        
        /* Determine the maximum space available for the the output block. */
        cbOutputBlockMax = cbOutputBuffer-cbOutputSize;

        /* Ensure buffers are DWORD-aligned */
        Assert( POINTER_IS_ALIGNED(pInputBlock,sizeof(DWORD)) );
        Assert( POINTER_IS_ALIGNED(pOutputBlockHdr->data,sizeof(DWORD)) );

        /* Encode a block of the input data into the output buffer. */
        cbCompBlock = XpressEncode( xpressStream, pOutputBlockHdr->data, cbOutputBlockMax,
            pInputBlock, cbInputBlock, NULL, NULL, 0 );
        if( !cbCompBlock ) {
            Assert( !"XPRESS: XpressEncode failed" );
            return 0;
        }

        if( cbCompBlock>=cbInputBlock ) {
            /* The size of the compressed block is no smaller than the size of
             * the uncompressed block (i.e. data was not compressed at all). We
             * copy the original, uncompressed data to the output buffer instead. */

            /* Check that we will not overflow the output buffer */
            if( cbInputBlock>cbOutputBlockMax ) {
                return 0;
            }
            memcpy( pOutputBlockHdr->data, pInputBlock, cbInputBlock );
            cbCompBlock = cbInputBlock;
        }
        cbInputProcessed += cbInputBlock;
        cbOutputSize += cbCompBlock;

        /* Update the fields in the output block header. */
        pOutputBlockHdr->cbUncompressedSize = cbInputBlock;
        pOutputBlockHdr->cbCompressedSize = cbCompBlock;
    }

    XpressEncodeClose( xpressStream, NULL, xpressFree );
    
    if( cbOutputSize < cbInputBuffer ) {
        /* Data successfully compressed and is smaller than input buffer */
        #ifdef DBG
        {
            ULONG result;
            BYTE* scratch;

            /* Decompress and check the data into a scratch buffer to check our code.
             * Decompression is about 4 times faster than compression so this shouldn't
             * be a big performance hit. */
            scratch = THAlloc(cbInputBuffer);
            if( scratch ) {
                result = draUncompressBlobXpress(scratch,cbInputBuffer,pOutputBuffer,cbOutputSize);
                Assert( result==cbInputBuffer );
                Assert( 0==memcmp(scratch,pInputBuffer,cbInputBuffer) );
                THFree(scratch);
            } else {
                // Not enough memory to uncompress and check. Oh well.
            }
        }
        #endif

        DPRINT2(2,"XPRESS: Compress End. Uncompressed blob size=%d, "
                  "Compressed blob size=%d\n",cbInputBuffer,cbOutputSize);
        return cbOutputSize;
    }

    /* Failure. The output data was bigger than the input data. */
    DPRINT1(0,"XPRESS: Failed to compress blob. Uncompressed blob size=%d\n",
            cbInputBuffer);
    return 0;
}

/*
 * Simple wrappers around THAlloc for use by Chunky[De]Compression below
 */

void * __cdecl zipAlloc(ULONG cb) {
    return THAlloc(cb);
}

void __cdecl zipFree(VOID *buff) {
    THFree(buff);
}

ULONG
draCompressBlobMszip(
    OUT BYTE *  pCompBuff,
    IN  ULONG   CompSize,
    IN  BYTE *  pUncompBuff,
    IN  ULONG   UncompSize
    )
/*++

Routine Description:

    Compress using mszip style compression.

    BUGBUG: Contains embedded ULONGS in the Data byte array.  Byte
    flipping will be a problem in other-endian machines.

Arguments:

    pCompBuff (OUT) - Buffer to hold compressed data.

    CompSize (IN) - Size of buffer to hold compressed data.

    pUncompBuff (IN) - Uncompressed data.

    UncompSize (IN) - Size of uncompressed data.

Return Values:

    0 - Buffer not compressed (compression failure or compressed buffer
        was bigger than original buffer).

    > 0 - Size of (successfully) compressed data.

--*/
{
    MCI_CONTEXT_HANDLE    mciHandle;
    MAIL_COMPRESS_BLOCK * pCompressedData;  // better data type for pCompBuff

    ULONG cbCompressed = 0; /* how much of pCompBuff used?             */
    ULONG cbInChunk;        /* how much to compress at a time.         */
    ULONG cbOutChunk;       /* how much it was compressed to.          */
    UINT  cbInChunkMax;     /* how big a chunk can we give?            */
    UINT  cbOutChunkMax;    /* how big a chunk can we get?             */
    ULONG OriginalSize = UncompSize;

    cbInChunkMax = MSZIP_MAX_BLOCK;

    if(MCICreateCompression(&cbInChunkMax,
                            zipAlloc,
                            zipFree,
                            &cbOutChunkMax,
                            &mciHandle)) {
        /* couldn't create a compression context.  bag it and go home */
        return 0;
    }

    /* pad the size of the max out chunk to be on a ULONG boundary, since
     * we will be padding the data stream below.
     */
    cbOutChunkMax = ROUND_UP_COUNT(cbOutChunkMax, sizeof(ULONG));

    pCompressedData = (MAIL_COMPRESS_BLOCK *) pCompBuff;

    while(UncompSize) {

        cbInChunk = min(UncompSize, cbInChunkMax);

        if((cbOutChunkMax +sizeof(MAIL_COMPRESS_BLOCK)) >  /* Max to write. */
           (CompSize - cbCompressed)) {                    /* Space left    */
            /* Space is tight.  While it is still technically possible that
             * compression could end up with smaller data, we are close
             * enough to filling our buffer that we MIGHT overfill it
             * during this chunk.  So, bag it and go home.
             */
            MCIDestroyCompression(mciHandle);
            return 0;
        }

        pCompressedData->cbUncompressedSize = cbInChunk;

        if(MCICompress(mciHandle,
                       pUncompBuff,
                       cbInChunk,
                       pCompressedData->data,
                       cbOutChunkMax,
                       &cbOutChunk)) {
            /* Something went wrong */
            MCIDestroyCompression(mciHandle);
            return 0;
        }


        pCompressedData->cbCompressedSize = cbOutChunk;


        /* Pad size to ULONG boundary, possibly making cbInChunk ==
         * cbOutChunk.  Oh well. We still have space to write it.
         */

        cbOutChunk = ROUND_UP_COUNT(cbOutChunk, sizeof(ULONG));

        cbCompressed += cbOutChunk + sizeof(MAIL_COMPRESS_BLOCK);
        pCompressedData =
            (MAIL_COMPRESS_BLOCK *) &pCompressedData->data[cbOutChunk];

        pUncompBuff = &pUncompBuff[cbInChunk];
        UncompSize -= cbInChunk;
    }

    MCIDestroyCompression(mciHandle);
    return ((cbCompressed < OriginalSize)? cbCompressed : 0);
}


ULONG
draUncompressBlobMszip(
    IN  THSTATE *   pTHS,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    )
/*++

Routine Description:

    Uncompress data previously compressed by draCompressBlobMszip().

Arguments:

    pUncompBuff (OUT) - Buffer to hold uncompressed data.

    cbUncomp (IN) - Size of buffer to hold uncompressed data.

    pCompBuff (IN) - Compressed data.

    cbCompBuff (IN) - Size of compressed data.

Return Values:

    0 - Uncompress failed.

    > 0 - Size of (successfully) uncompressed data.

--*/
{
    MDI_CONTEXT_HANDLE    mdiHandle;
    MAIL_COMPRESS_BLOCK * pCompressedData;  // better data type for pCompBuff

    ULONG cbUncompressed = 0; /* how much of pUncompBuff used?           */
    ULONG cbInChunk;          /* how much to decompress at a time.       */
    ULONG cbOutChunk;         /* how much it was decompressed to.        */
    UINT  cbInChunkMax;       /* how big a chunk can we give?            */
    UINT  cbOutChunkMax;      /* how big a chunk can we get?             */
    int   rc;
    BYTE  *pbDecompScratch;   /* decompression must be done into the same
                               * buffer for multiple block decompression,
                               * as state info is picked up out of the last
                               * decompression pass
                               */

    cbOutChunkMax = MSZIP_MAX_BLOCK;

    pCompressedData = (MAIL_COMPRESS_BLOCK *) pCompBuff;

    if(MDICreateDecompression(&cbOutChunkMax,
                              zipAlloc,
                              zipFree,
                              &cbInChunkMax,
                              &mdiHandle)) {
        /* couldn't create a compression context.  bag it and go home */
        return 0;
    }
    pbDecompScratch = THAllocEx(pTHS, MSZIP_MAX_BLOCK);

    while(cbCompBuff) {
        /* NOTE: remember we padded the compressed data to ULONG boundary,
         */

        cbOutChunk = pCompressedData->cbUncompressedSize;

        rc = MDIDecompress(mdiHandle,
                           pCompressedData->data,
                           pCompressedData->cbCompressedSize,
                           pbDecompScratch,
                           &cbOutChunk);

        if(rc || (cbOutChunk != pCompressedData->cbUncompressedSize)) {
            /* something went wrong */
            MDIDestroyDecompression(mdiHandle);
            THFreeEx(pTHS, pbDecompScratch);
            return 0;
        }


        memcpy(pUncompBuff, pbDecompScratch, cbOutChunk);

        /* move compressed data pointer forward to next data chunk,
         * which we do by taking the size of the compressed data and
         * rounding up to the nearest ULONG boundary and moving forward
         * that much (just like we did when we built this in
         * chunkycompressionZip above).
         */

        cbInChunk = ROUND_UP_COUNT(pCompressedData->cbCompressedSize,
                                   sizeof(ULONG));

        pCompressedData = (MAIL_COMPRESS_BLOCK *)
            &pCompressedData->data[cbInChunk];

        cbCompBuff -= cbInChunk + sizeof(MAIL_COMPRESS_BLOCK);

        pUncompBuff = &pUncompBuff[cbOutChunk];

        cbUncompressed += cbOutChunk;
    }

    THFreeEx(pTHS, pbDecompScratch);
    MDIDestroyDecompression(mdiHandle);

    return cbUncompressed;
}


ULONG
draCompressBlobDispatch(
    OUT BYTE               *pCompBuff,
    IN  ULONG               CompSize,
    IN  DRS_EXTENSIONS     *pExt,          OPTIONAL
    IN  BYTE               *pUncompBuff,
    IN  ULONG               UncompSize,
    OUT DRS_COMP_ALG_TYPE  *CompressionAlg
    )
/*++

Routine Description:

    Chooses a compression algorithm and uses it to compresses the reply message
    in the pUncompBuff buffer. The selected algorithm is returned in CompressionAlg.

    In debug mode, this function will randomly select an algorithm from the available
    algorithms.
    
Arguments:

    pCompBuff (OUT)      - Buffer to hold compressed data.

    CompSize (IN)        - Size of compressed data buffer.

    pExt (IN)            - Extension bits indicating the capabilities of the remote system.
                           This may be NULL if the extensions are unavailable.
    
    pUncompBuff (IN)     - Buffer containing the uncompressed data.

    UncompSize (IN)      - Size of uncompressed data.

    CompressionAlg (OUT) - The compression algorithm selected to compress this buffer.

Return Values:

    0 - Buffer not compressed (compression failure or compressed buffer
        was bigger than original buffer).

    > 0 - Size of (successfully) compressed data.

--*/
{
    DRS_COMP_ALG_TYPE   SelectedAlg, UserChosenAlg;
    ULONG               cbCompressedReply;

    UserChosenAlg = GetCompressionAlg();
    if ( (UserChosenAlg == DRS_COMP_ALG_NONE) ||
         (UserChosenAlg == DRS_COMP_ALG_MSZIP) ) {

        // These algorithms are supported for downlevel and do not need to be
        // negotiated
        SelectedAlg = UserChosenAlg;

    } else {
        /* Negotiate the compression algorithm to use */
        SelectedAlg = DRS_COMP_ALG_MSZIP;
        if(   NULL!=pExt
              && IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V7)
              && IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_XPRESS_COMPRESSION) )
        {
            /* Note that SMTP-based replication using Xpress does not actually
             * require use of GETCHGREPLY_V7 packets since the SMTP mail format
             * provides a field to specify the compression type. In actuality
             * this is a moot point because all DCs that support Xpress will
             * also support the V7 packets. */
            SelectedAlg = DRS_COMP_ALG_XPRESS;

#ifdef DBG
            {
                /* On debug builds, randomly try different compression algorithms */
                int r=rand()%100;
                if( r<10 ) {
                    SelectedAlg = DRS_COMP_ALG_NONE;
                } else if( r<25 ) {
                    SelectedAlg = DRS_COMP_ALG_MSZIP;
                }
            }
#else
            /* On free builds, don't bother to compress small messages */
            if( UncompSize<MIN_COMPRESS_SIZE ) {
                SelectedAlg = DRS_COMP_ALG_NONE;
            }
#endif
        }
    }
    /* Call the selected compression function */
    switch( SelectedAlg ) {
        case DRS_COMP_ALG_NONE:
            Assert( CompSize>=UncompSize );
            memcpy( pCompBuff, pUncompBuff, UncompSize );
            cbCompressedReply = UncompSize;
            break;
        case DRS_COMP_ALG_MSZIP:
            cbCompressedReply = draCompressBlobMszip(
                pCompBuff, CompSize,
                pUncompBuff, UncompSize);
            break;
        case DRS_COMP_ALG_XPRESS:
            cbCompressedReply = draCompressBlobXpress(
                pCompBuff, CompSize,
                pUncompBuff, UncompSize);
            break;
        default:
            Assert( !"Invalid algorithm selection in draCompressBlobDispatch" );
    }
    *CompressionAlg = SelectedAlg;

    return cbCompressedReply;
}


ULONG
draUncompressBlobDispatch(
    IN  THSTATE *   pTHS,
    IN  DRS_COMP_ALG_TYPE CompressionAlg,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    )
/*++

Routine Description:

    Uncompress data in pCompBuff using the algorithm specified by
    CompressionAlg. This function just acts as a dispatcher and calls
    the appropriate decompression function.

Arguments:

    pTHS - The thread-state structure.
    
    CompressionAlg - The algorithm used to compress the data.

    pUncompBuff (OUT) - Buffer to hold uncompressed data.

    cbUncomp (IN) - Size of buffer to hold uncompressed data.

    pCompBuff (IN) - Compressed data.

    cbCompBuff (IN) - Size of compressed data.
    
Return Values:

    0 - Uncompress failed.

    > 0 - Size of (successfully) uncompressed data.

--*/
{
    DWORD cbActualUncompressedSize;

    switch( CompressionAlg ) {
        case DRS_COMP_ALG_NONE:
            Assert( cbUncomp>=cbCompBuff );
            memcpy(pUncompBuff, pCompBuff, cbCompBuff);
            cbActualUncompressedSize = cbCompBuff;
            break;
        case DRS_COMP_ALG_MRCF:
            Assert( !"MRCF compression is obsolete and unsupported!" );
            return 0;
        case DRS_COMP_ALG_MSZIP:
            cbActualUncompressedSize = draUncompressBlobMszip(pTHS,
                pUncompBuff, cbUncomp,
                pCompBuff, cbCompBuff);
            break;
        case DRS_COMP_ALG_XPRESS:
            cbActualUncompressedSize = draUncompressBlobXpress(
                pUncompBuff, cbUncomp,
                pCompBuff, cbCompBuff);
            break;
        default:
            Assert( !"Unknown compression algorithm!" );
            DRA_EXCEPT(ERROR_INVALID_PARAMETER, CompressionAlg );
            return 0;
    }

    return cbActualUncompressedSize;
}


BOOL
draCompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppCmprsMailRepMsg,
    OUT DRS_COMP_ALG_TYPE *pCompressionAlg
    )
/*++

Routine Description:

    Try to compress the message in pMailRepMsg.
    
    If the message was successfully compressed
        ppCmprsMailRepMsg contains a pointer to the new, compressed message.
        pCompressionAlg indicates the compression algorithm used.
    Else
        ppCmpsMailRepMsg is set to NULL.
        pCompressionAlg is unmodified.

Arguments:

    pTHS - The thread-state structure.

Notes:
    
    This code is aware of variable length headers.

Return value:

    TRUE - Message was successfully compressed
    FALSE - Message was not compressed
    
--*/

{
    MAIL_REP_MSG *  pCmprsMailRepMsg = NULL;
    DWORD           cbCmprsMailRepMsg;
    ULONG           cbCompressedSize;
    PCHAR           pbDataIn, pbDataOut;

    Assert(NULL != MAIL_REP_MSG_DATA(pMailRepMsg));
    
    if( pMailRepMsg->cbDataSize > MIN_COMPRESS_SIZE ) {
        
        cbCmprsMailRepMsg = MAIL_REP_MSG_SIZE(pMailRepMsg) + sizeof(MAIL_COMPRESS_BLOCK);
        pCmprsMailRepMsg = THAllocEx(pTHS, cbCmprsMailRepMsg);

        // Copy all but message data.
        memcpy(pCmprsMailRepMsg, pMailRepMsg, pMailRepMsg->cbDataOffset);

        pbDataIn = MAIL_REP_MSG_DATA(pMailRepMsg);
        pbDataOut = MAIL_REP_MSG_DATA(pCmprsMailRepMsg);

        /* Compress Message */
        cbCompressedSize = draCompressBlobDispatch(
            pbDataOut, sizeof(MAIL_COMPRESS_BLOCK)+pMailRepMsg->cbDataSize,
            pTHS->pextRemote,
            pbDataIn, pMailRepMsg->cbDataSize,
            pCompressionAlg);

        if (cbCompressedSize) {
            // Data is compressible and has been compressed.
            pCmprsMailRepMsg->cbDataSize = cbCompressedSize;
            pCmprsMailRepMsg->dwMsgType |= MRM_MSG_COMPRESSED;
            pCmprsMailRepMsg->cbUncompressedDataSize = pMailRepMsg->cbDataSize;

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_MAIL_COMPRESSED,
                     szInsertUL(pCmprsMailRepMsg->cbUncompressedDataSize),
                     szInsertUL(pCmprsMailRepMsg->cbDataSize),
                     NULL);
        }
        else {
            THFreeEx(pTHS, pCmprsMailRepMsg);
            pCmprsMailRepMsg = NULL;
        }
    }

    *ppCmprsMailRepMsg = pCmprsMailRepMsg;

    return (NULL != pCmprsMailRepMsg);
}


void
draUncompressMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pMailRepMsg,
    OUT MAIL_REP_MSG ** ppUncompressedMailRepMsg
    )
{
    MAIL_REP_MSG *  pUncompressedMailRepMsg = NULL;
    DWORD           cbUncompressedDataSize;

    Assert(pMailRepMsg->dwMsgType & MRM_MSG_COMPRESSED);
    Assert(NULL != MAIL_REP_MSG_DATA(pMailRepMsg));
    Assert(   pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_NONE
           || pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_MSZIP
           || pMailRepMsg->CompressionVersionCaller==DRS_COMP_ALG_XPRESS );

    pUncompressedMailRepMsg = THAllocEx(pTHS,
                                        pMailRepMsg->cbDataOffset
                                        + pMailRepMsg->cbUncompressedDataSize);
    // Copy all but message data.
    memcpy(pUncompressedMailRepMsg, pMailRepMsg, pMailRepMsg->cbDataOffset);

    cbUncompressedDataSize =
        draUncompressBlobDispatch(pTHS,
                          (DRS_COMP_ALG_TYPE) pMailRepMsg->CompressionVersionCaller,
                          MAIL_REP_MSG_DATA(pUncompressedMailRepMsg),
                          pMailRepMsg->cbUncompressedDataSize,
                          MAIL_REP_MSG_DATA(pMailRepMsg),
                          pMailRepMsg->cbDataSize);

    if (cbUncompressedDataSize != pMailRepMsg->cbUncompressedDataSize) {
        // Decompression ended up with a different count of bytes. Log error and
        // discard message.
        LogAndAlertEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_INCOMPAT_MAIL_MSG_C,
                         NULL,
                         NULL,
                         NULL);
        DRA_EXCEPT(ERROR_BAD_LENGTH, 0);
    }

    // Message uncompressed successfully.  Substitute uncompressed message for
    // compressed message.
    pUncompressedMailRepMsg->dwMsgType &= ~MRM_MSG_COMPRESSED;
    pUncompressedMailRepMsg->cbDataSize = cbUncompressedDataSize;

    *ppUncompressedMailRepMsg = pUncompressedMailRepMsg;
}


MTX_ADDR *
draGetTransportAddress(
    IN OUT  DBPOS *   pDB,          OPTIONAL
    IN      DSNAME *  pDSADN,
    IN      ATTRTYP   attAddress
    )
/*++

Routine Description:

    Reads the transport-specific address associated with a particular ntdsDsa
    object.

Arguments:

    pDB (IN/OUT) - Required only if attAddress != ATT_DNS_HOST_NAME.

    pDSADN (IN) - ntdsDsa for which we want to get the address.

    attAddress (IN) - Attribute of the CLASS_SERVER object holding the address
        for the requested transport.

Return Values:

    A pointer to the thread-allocated MTX_ADDR for the given ntdsDsa.

    Throws a DRA exception if the transport-specific address
    attribute is not present on the ntdsDsa's parent server object.

    This can occur under normal circumstances when the ISM transport
    removes this attribute to indicate that the transport is no longer
    available.  The ISM removes the attribute to notify the KCC to not
    utilize this transport. Until the KCC runs again to remove the
    source over this transport, this attribute will be found missing.

--*/
{
    THSTATE *   pTHS = pDB ? pDB->pTHS : pTHStls;
    DWORD       cb;
    DWORD       cwchAddress;
    WCHAR *     pwchAddress;
    DWORD       cachAddress;
    MTX_ADDR *  pmtxAddress;
    DWORD       dwErr;

    Assert(!fNullUuid(&pDSADN->Guid));

    if (ATT_DNS_HOST_NAME == attAddress) {
        // No need to look this up -- we can derive it.
        pwchAddress = DSaddrFromName(pTHS, pDSADN);
        cwchAddress = wcslen(pwchAddress);
    }
    else {
        // Must derive from attribute of server object.

        // Find the server object.
        if (DBFindDSName(pDB, pDSADN) || DBFindDNT(pDB, pDB->PDNT)) {
            // Event will be logged in the exception handler
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // And read the transport-specific address from it.
        if (DBGetAttVal(pDB, 1, attAddress, 0, 0, &cb, (BYTE **)&pwchAddress)) {
            DRA_EXCEPT_NOLOG (ERROR_DS_MISSING_REQUIRED_ATT, 0);
        }
        cwchAddress = cb / sizeof(WCHAR);
    }

    // Translate Unicode transport address into MTX_ADDR.
    Assert(0 != cwchAddress);
    Assert(NULL != pwchAddress);
    Assert(L'\0' != pwchAddress[cwchAddress - 1]);

    cachAddress = WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                                      NULL, 0, NULL, NULL);
    if( 0==cachAddress ) {
        dwErr = GetLastError();
        DRA_EXCEPT(dwErr, 0);
    }

    pmtxAddress = (MTX_ADDR *) THAllocEx(pTHS, MTX_TSIZE_FROM_LEN(cachAddress));
    pmtxAddress->mtx_namelen = cachAddress + 1; // includes null-term

    WideCharToMultiByte(CP_UTF8, 0L, pwchAddress, cwchAddress,
                        (CHAR *) &pmtxAddress->mtx_name[0],
                        cachAddress, NULL, NULL);
    pmtxAddress->mtx_name[cachAddress] = '\0';

    THFreeEx(pTHS, pwchAddress);

    return pmtxAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\dramsg.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       dramsg.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

Author:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB "DRAMSG:"                /* define the subsystem for debugging */

#include "drserr.h"
#include "drautil.h"
#include "drauptod.h"
#include "dramail.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMSG


////////////////////////////////////////////////////////////////////////////////
//
//  REQUEST TRANSLATION FUNCTIONS
//

void
draXlateNativeRequestToOutboundRequest(
    IN  THSTATE *                   pTHS,
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq,
    IN  MTX_ADDR *                  pmtxLocalDSA            OPTIONAL,
    IN  UUID *                      puuidTransportDN        OPTIONAL,
    IN  DWORD                       dwMsgVersionToSend,
    OUT DRS_MSG_GETCHGREQ *         pOutboundReq
    )
/*++

Routine Description:

    Translates a native get changes request into a version appropriate for a
    given remote DSA.

Arguments:

    pTHS (IN)

    pNativeReq (IN) - Native (local) request.

    pmtxLocalDSA (IN, OPTIONAL) - Network address of the local DSA for transport
        with objectGuid *puuidTransportDN.  Ignored if dwMsgVersionToSend does
        not indicate a mail-based request.
        
    puuidTransportDN (IN, OPTIONAL) - objectGuid of interSiteTransport object
        representing the transport over which the reply to this request should
        be sent.  Ignored if dwMsgVersionToSend does not indicate a mail-based
        request.
        
    dwMsgVersionToSend (IN) - Desired message version.
    
    pOutboundReq (OUT) - On return, the translated message.  Can be the same
        as pNativeReq, in which case the message is translated in-place.

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    UPTODATE_VECTOR_V1_WIRE * pUTDV1;

    if (((DRS_MSG_GETCHGREQ *) pNativeReq == pOutboundReq)
        && (DRS_MSG_GETCHGREQ_NATIVE_VERSION != dwMsgVersionToSend)) {
        // We may have to shuffle some fields around; first copy native request.
        DRS_MSG_GETCHGREQ_NATIVE *pNativeReqCopy = alloca(sizeof(DRS_MSG_GETCHGREQ_NATIVE));
        *pNativeReqCopy = *pNativeReq;
        pNativeReq = pNativeReqCopy;
    }
    
    // Convert native UTD format to request wire format (always V1).
    pUTDV1 = UpToDateVec_Convert(pTHS, 1, pNativeReq->pUpToDateVecDest);

    switch (dwMsgVersionToSend) {
    case 4: // Win2k mail-based request.
        Assert(NULL != pmtxLocalDSA);
        Assert(NULL != puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V4.pmtxReturnAddress        = pmtxLocalDSA;
        pOutboundReq->V4.uuidTransportObj         = *puuidTransportDN;
        pOutboundReq->V4.V3.uuidDsaObjDest        = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V4.V3.uuidInvocIdSrc        = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V4.V3.pNC                   = pNativeReq->pNC;
        pOutboundReq->V4.V3.usnvecFrom            = pNativeReq->usnvecFrom;
        pOutboundReq->V4.V3.pUpToDateVecDestV1    = pUTDV1;
        pOutboundReq->V4.V3.pPartialAttrVecDestV1 = NULL; // unused by Win2k
        pOutboundReq->V4.V3.ulFlags               = pNativeReq->ulFlags;
        pOutboundReq->V4.V3.cMaxObjects           = pNativeReq->cMaxObjects;
        pOutboundReq->V4.V3.cMaxBytes             = pNativeReq->cMaxBytes;
        pOutboundReq->V4.V3.ulExtendedOp          = pNativeReq->ulExtendedOp;
        
        // V4.V3.PrefixTableDest is not used by Win2k source DSAs.
        memset(&pOutboundReq->V4.V3.PrefixTableDest,
               0,
               sizeof(pOutboundReq->V4.V3.PrefixTableDest));

        if (pNativeReq->ulFlags & DRS_SYNC_PAS) {
            // Source does not support PAS cycles.
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
        }
        break;
    
    case 5: // Win2k RPC request.
        Assert(NULL == pmtxLocalDSA);
        Assert(NULL == puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V5.uuidDsaObjDest     = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V5.uuidInvocIdSrc     = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V5.pNC                = pNativeReq->pNC;
        pOutboundReq->V5.usnvecFrom         = pNativeReq->usnvecFrom;
        pOutboundReq->V5.pUpToDateVecDestV1 = pUTDV1;
        pOutboundReq->V5.ulFlags            = pNativeReq->ulFlags;
        pOutboundReq->V5.cMaxObjects        = pNativeReq->cMaxObjects;
        pOutboundReq->V5.cMaxBytes          = pNativeReq->cMaxBytes;
        pOutboundReq->V5.ulExtendedOp       = pNativeReq->ulExtendedOp;
        pOutboundReq->V5.liFsmoInfo         = pNativeReq->liFsmoInfo;
        
        if (pNativeReq->ulFlags & DRS_SYNC_PAS) {
            // Source does not support PAS cycles.
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
        }
        break;

    case 7: // Whistler mail-based request.
        Assert(NULL != pmtxLocalDSA);
        Assert(NULL != puuidTransportDN);
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq);
        
        pOutboundReq->V7.pmtxReturnAddress     = pmtxLocalDSA;
        pOutboundReq->V7.uuidTransportObj      = *puuidTransportDN;
        pOutboundReq->V7.V3.uuidDsaObjDest     = pNativeReq->uuidDsaObjDest;
        pOutboundReq->V7.V3.uuidInvocIdSrc     = pNativeReq->uuidInvocIdSrc;
        pOutboundReq->V7.V3.pNC                = pNativeReq->pNC;
        pOutboundReq->V7.V3.usnvecFrom         = pNativeReq->usnvecFrom;
        pOutboundReq->V7.V3.pUpToDateVecDestV1 = pUTDV1;
        pOutboundReq->V7.V3.ulFlags            = pNativeReq->ulFlags;
        pOutboundReq->V7.V3.cMaxObjects        = pNativeReq->cMaxObjects;
        pOutboundReq->V7.V3.cMaxBytes          = pNativeReq->cMaxBytes;
        pOutboundReq->V7.V3.ulExtendedOp       = pNativeReq->ulExtendedOp;
        pOutboundReq->V7.pPartialAttrSet       = pNativeReq->pPartialAttrSet;
        pOutboundReq->V7.pPartialAttrSetEx     = pNativeReq->pPartialAttrSetEx;
        pOutboundReq->V7.PrefixTableDest       = pNativeReq->PrefixTableDest;
        
        // V7.V3.PrefixTableDest is not used by Whistler beta 1 source DSAs.
        // This is a bit confusing, since one of the fields *added* in the V7
        // structure over the V3 is *another* PrefixTableDest structure --
        // V7.PrefixTableDest.
        //
        // This is true for V7.V3.pPartialAttrVecDest vs. V7.pPartialAttrSet,
        // too.
        //
        // In the ideal world we would remove the V7 fields and re-use the
        // V3 fields, but this is more difficult now that we have Whistler
        // beta 1 DCs that rely on the V7 fields.
        
        pOutboundReq->V7.V3.pPartialAttrVecDestV1 = NULL;
        memset(&pOutboundReq->V7.V3.PrefixTableDest,
               0,
               sizeof(pOutboundReq->V7.V3.PrefixTableDest));
        break;

    case 8: // Whistler RPC request.
        Assert(NULL == pmtxLocalDSA);
        Assert(NULL == puuidTransportDN);
        
        if ((DRS_MSG_GETCHGREQ *) pNativeReq != pOutboundReq) {
            pOutboundReq->V8 = *pNativeReq;
        }

        pOutboundReq->V8.pUpToDateVecDest = (UPTODATE_VECTOR *) pUTDV1;
        break;
    
    default:
        DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwMsgVersionToSend);
    }
}


void
draXlateInboundRequestToNativeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwInboundReqVersion,
    IN  DRS_MSG_GETCHGREQ *         pInboundReq,
    IN  DRS_EXTENSIONS *            pExt,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pNativeReq,
    OUT DWORD *                     pdwReplyVersion,
    OUT MTX_ADDR **                 ppmtxReturnAddress      OPTIONAL,
    OUT UUID *                      puuidTransportObj       OPTIONAL
    )                           
/*++

Routine Description:

    Translates an inbound GetNCChanges request into the native request structure.
    Also determines the reply version desired by the remote DSA.

Arguments:

    pTHS (IN)

    dwInboundReqVersion (IN) - Version of inbound request.

    pInboundReq (IN) - Inbound request message.

    pExt (IN) - DRS extensions supported by the remote DSA.

    pNativeReq (OUT) - On return, holds the request in native format.  May be
        the same as pInboundReq, in which case the message is translated
        in-place.

    pdwReplyVersion (OUT) - Version of reply structure we should return to
        destination DSA.
        
    ppmtxReturnAddress (OUT, OPTIONAL) - If supplied, holds a pointer to the
        network address of the requesting (remote) DSA.  Returned/useful only
        if inbound request is in a mail-based format. 

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    CROSS_REF * pCR;
    DWORD    dwRet;
    DSNAME * pNC;
    MTX_ADDR * pmtxReturnAddress;
    UUID uuidTransportObj;

    // Convert older message formats (preserved for backward compatibility)
    // into the current format (a superset), and throw out requests sent by
    // DCs of long deceased builds.

    if (((DRS_MSG_GETCHGREQ *) pNativeReq == pInboundReq)
        && (DRS_MSG_GETCHGREQ_NATIVE_VERSION != dwInboundReqVersion)) {
        // We may have to shuffle some fields around; first copy native request.
        DRS_MSG_GETCHGREQ *pInboundReqCopy = alloca(sizeof(DRS_MSG_GETCHGREQ));
        *pInboundReqCopy = *pInboundReq;
        pInboundReq = pInboundReqCopy;
    }

    switch (dwInboundReqVersion) {
    case 4: // Win2k mail-based request.
        if (pTHS->fLinkedValueReplication) {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
        }
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V4.V3.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V4.V3.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V4.V3.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V4.V3.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V4.V3.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V4.V3.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V4.V3.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V4.V3.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V4.V3.ulExtendedOp;
        pNativeReq->pPartialAttrSet   = NULL;
        pNativeReq->pPartialAttrSetEx = NULL;
        
        memset(&pNativeReq->liFsmoInfo, 0, sizeof(pNativeReq->liFsmoInfo));
        memset(&pNativeReq->PrefixTableDest, 0, sizeof(pNativeReq->PrefixTableDest));
        
        *pdwReplyVersion = 1;
        pmtxReturnAddress = pInboundReq->V4.pmtxReturnAddress;
        uuidTransportObj = pInboundReq->V4.uuidTransportObj;
        break;
    
    case 5: // Win2k RPC request.
        if (pTHS->fLinkedValueReplication) {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
        }
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V5.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V5.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V5.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V5.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V5.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V5.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V5.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V5.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V5.ulExtendedOp;
        pNativeReq->liFsmoInfo        = pInboundReq->V5.liFsmoInfo;
        pNativeReq->pPartialAttrSet   = NULL;
        pNativeReq->pPartialAttrSetEx = NULL;
        
        memset(&pNativeReq->PrefixTableDest, 0, sizeof(pNativeReq->PrefixTableDest));

        *pdwReplyVersion = 1;
        pmtxReturnAddress = NULL;
        memset(&uuidTransportObj, 0, sizeof(uuidTransportObj));
        break;

    case 7: // Whistler mail-based request.
        Assert((DRS_MSG_GETCHGREQ *) pNativeReq != pInboundReq);
            
        pNativeReq->uuidDsaObjDest    = pInboundReq->V7.V3.uuidDsaObjDest;
        pNativeReq->uuidInvocIdSrc    = pInboundReq->V7.V3.uuidInvocIdSrc;
        pNativeReq->pNC               = pInboundReq->V7.V3.pNC;
        pNativeReq->usnvecFrom        = pInboundReq->V7.V3.usnvecFrom;
        pNativeReq->pUpToDateVecDest  = pInboundReq->V7.V3.pUpToDateVecDestV1;
        pNativeReq->ulFlags           = pInboundReq->V7.V3.ulFlags;
        pNativeReq->cMaxObjects       = pInboundReq->V7.V3.cMaxObjects;
        pNativeReq->cMaxBytes         = pInboundReq->V7.V3.cMaxBytes;
        pNativeReq->ulExtendedOp      = pInboundReq->V7.V3.ulExtendedOp;
        pNativeReq->pPartialAttrSet   = pInboundReq->V7.pPartialAttrSet;
        pNativeReq->pPartialAttrSetEx = pInboundReq->V7.pPartialAttrSetEx;
        pNativeReq->PrefixTableDest   = pInboundReq->V7.PrefixTableDest;
        
        memset(&pNativeReq->liFsmoInfo, 0, sizeof(pNativeReq->liFsmoInfo));
            
        if (IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V6)) {
            *pdwReplyVersion = 6;
        } else {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
        }
        pmtxReturnAddress = pInboundReq->V7.pmtxReturnAddress;
        uuidTransportObj = pInboundReq->V7.uuidTransportObj;
        break;

    case 8: // Whistler RPC request.
        // Already in the native request format.
        if (pNativeReq != &pInboundReq->V8) {
            *pNativeReq = pInboundReq->V8;
        }
        
        if (IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V6)) {
            *pdwReplyVersion = 6;
        } else {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
        }
        pmtxReturnAddress = NULL;
        memset(&uuidTransportObj, 0, sizeof(uuidTransportObj));
        break;
    
    default:
        // Either a request from an old unsupported build or someone added a
        // new request version to our IDL but hasn't yet taught us what to do
        // with it.
        DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwInboundReqVersion);
    }

    if (!(pNativeReq->ulFlags & DRS_WRIT_REP)
        && (NULL == pNativeReq->pPartialAttrSet)) {
        // Partial attribute set for Win2k replicas is derived from the
        // local schema.  We check elsewhere that the two schemas are
        // identical, although there exist degenerate cases where the
        // schemas may really differ but the checks pass -- ergo, one
        // reason the partial attribute set is an explicit parameter
        // post-Win2k.
        pNativeReq->pPartialAttrSet =
            (PARTIAL_ATTR_VECTOR_V1_EXT*)
                ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec;
    }
    
    // Convert embedded UTD vector to native format.
    pNativeReq->pUpToDateVecDest
        = UpToDateVec_Convert(pTHS,
                              UPTODATE_VECTOR_NATIVE_VERSION,
                              pNativeReq->pUpToDateVecDest);

    Assert(pNativeReq->pNC);
    if (pNativeReq->pNC->NameLen == 0) {

        // We shouldn't ever get a DN without a string name or a GUID!
        if ( fNullUuid(&(pNativeReq->pNC->Guid)) ) {
            Assert(!"We should always have a NameLen or a non-NULL guid");
            DRA_EXCEPT(ERROR_DS_DRA_BAD_NC, ERROR_INVALID_PARAMETER);
        }

        // Currently, the only time this code is used (and tested) is when
        // being used by an extended operation to replicate back a single
        // object, where the client system only knew the GUID.  Though it
        // should all work fine for any repl operation. ;)
        Assert(pNativeReq->ulExtendedOp);
        
        // We have a GUID only DN, we must fill in the rest of the string
        // name so that FindNCParentDSName() below can function properly.

        BeginDraTransaction(SYNC_READ_ONLY);
        __try {

            dwRet = DBFindDSName(pTHS->pDB, pNativeReq->pNC);
            if (dwRet) {
                __leave;
            }

            // Unfortunately, we don't know if the memory in pNativeReq->pNC
            // is safely reallocatable.  RPC could've smartly allocated 
            // memory for several variables at once, so to be safe we
            // freshly allocate this (meaning pass FALSE in the 3rd arg 
            // to DBFillDSName()).  Further, even though pNativeReq->pNC
            // is allocated by RPC, we can lose the original memory, 
            // because it is contained in some sort of THAllocated buffer
            // and so it'll get cleaned up!
            dwRet =  DBFillDSName(pTHS->pDB, &(pNativeReq->pNC), FALSE);

        } finally {
            EndDraTransaction(TRUE);
        }
        if (dwRet) {
            DRA_EXCEPT(ERROR_DS_OBJ_NOT_FOUND, dwRet);
        }
    }

    pCR = FindExactCrossRef(pNativeReq->pNC, NULL);
    if (NULL == pCR) {

        // NOTE: Despite the members name (pNativeReq->pNC) the 
        // variable is not necessarily an NC, it could be a DN for 
        // an extended operation (FSMO transfer, repl single obj).

        pNC = FindNCParentDSName(pNativeReq->pNC, FALSE, FALSE);

        if (NULL != pNC) {
            pCR = FindExactCrossRef(pNC, NULL);
        }
        if (NULL == pCR) {
            // We no longer have a cross-ref for this instantiated replica.
            // This NC must must have been recently removed from the forest.
            // We will remove our replica of this NC as soon as the KCC runs.
            DRA_EXCEPT(ERROR_DS_DRA_BAD_NC, 0);
        }
    }

    Assert(pCR->flags & FLAG_CR_NTDS_NC);

    if ((pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED)
        && !(pNativeReq->ulFlags & DRS_WRIT_REP)
        && !IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_NONDOMAIN_NCS)) {
        // This request is from a Win2k DSA that, because it's a GC and has
        // no knowledge of the special handling of non-domain NCs, falsely
        // thinks that it is supposed to host a copy of this non-domain NC.
        // Spoof it by returning only the NC head and the Deleted Objects
        // container.  This minimizes the additional replication traffic while
        // preventing the destination DSA from thinking we we are "stale" and
        // routing around us (as it would if we instead returned an error).
        // Win2k SP2 GCs are smart enough not to ask for NDNCs.

        // Why two objects?  Because Win2k DCs can't handle NCs with no interior
        // nodes.  (They generate an exception on outbound replication of that
        // NC in draGetNCSize().)
        
        // See also the companion functionality in
        // draXlateNativeReplyToOutboundReply.
        DPRINT(0, "Spoofing Win2k GC trying to replicate NDNC (part 1).\n");
        
        // Note that we can't reset the usnvecFrom here, as this vector is used
        // as a key at the dest when performing mail-based replication to ensure
        // that the reply corresponds to the last request.
        Assert(0 == pNativeReq->usnvecFrom.usnHighObjUpdate);
        Assert(0 == pNativeReq->usnvecFrom.usnHighPropUpdate);

        // Always send all attributes of the first two objects.  It's not
        // important that we always send all attributes, but it is important
        // that we not filter out either of the first two objects, thereby
        // slowly replicating out all objects in the NDNC.
        pNativeReq->pUpToDateVecDest = NULL;
        
        // Note that DRA_GetNCChanges enforces a minimum on the number of
        // objects it will put in a packet -- as of this writing that
        // minimum is greater than the number of objects we need to return.
        // If more than two objects are returned, we'll chop them out in
        // draXlateNativeReplyToOutboundReply.
        pNativeReq->cMaxObjects = 2;
    }

    if (NULL != ppmtxReturnAddress) {
        *ppmtxReturnAddress = pmtxReturnAddress;
    }

    if (NULL != puuidTransportObj) {
        *puuidTransportObj = uuidTransportObj;
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//  REPLY TRANSLATION FUNCTIONS
//

DWORD
draXlateNativeReplyToOutboundReply(
    IN      THSTATE *                       pTHS,
    IN      DRS_MSG_GETCHGREPLY_NATIVE *    pNativeReply,
    IN      DWORD                           dwXlateFlags,
    IN      DRS_EXTENSIONS *                pExt,
    IN OUT  DWORD *                         pdwMsgOutVersion,
    OUT     DRS_MSG_GETCHGREPLY *           pOutboundReply
    )
/*++

Routine Description:

    Translates a native get changes request into a version appropriate for a
    given remote DSA.

Arguments:

    pTHS (IN)

    pNativeReq (IN) - Native (local) request.

    dwXlateFlags - 0 or more of the following bits:
        DRA_XLATE_COMPRESS - Compress the reply.  If compression is successful,
        *pdwMsgOutVersion will be updated to denote a compressed reply.
    
    pExt (IN) - DRS extensions supported by the remote DSA.

    pdwMsgOutVersion (IN/OUT) - Message version to send to remote DSA.  The
        value may be modified if dwFlags & DRA_XLATE_COMPRESS.
        
    pOutboundReply (OUT) - The translated reply, ready to send to remote DSA.
        May be the same as pNativeReq, in which case the message is translated
        in-place.

Return Value:

    If the outbound reply is compressed, the number of compressed bytes is returned.
    Otherwise, 0 is returned.

--*/
{
    DWORD   cbEncodedReply = 0;
    BYTE *  pbEncodedReply;
    DWORD   cbCompressedReply = 0;
    BYTE *  pbCompressedReply;
    DRS_COMPRESSED_BLOB * pComprBlob = NULL;
    UPTODATE_VECTOR * pUTDV1;
    CROSS_REF * pCR;
    DSNAME * pNC;

    Assert(0 == (dwXlateFlags & ~DRA_XLATE_COMPRESS));

    if (((DRS_MSG_GETCHGREPLY *) pNativeReply == pOutboundReply)
        && (DRS_MSG_GETCHGREPLY_NATIVE_VERSION != *pdwMsgOutVersion)) {
        // We may have to shuffle some fields around; first copy native reply.
        DRS_MSG_GETCHGREPLY_NATIVE *pNativeReplyCopy = alloca(sizeof(DRS_MSG_GETCHGREPLY_NATIVE));
        *pNativeReplyCopy = *pNativeReply;
        pNativeReply = pNativeReplyCopy;
    }
    
    if (!IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_NONDOMAIN_NCS)) {
        // The destination DSA does not understand the instance type bits
        // IT_NC_COMING and IT_NC_GOING.  Filter them out of the outbound
        // replication stream.
        ATTR AttrITKey = {ATT_INSTANCE_TYPE};
        REPLENTINFLIST * pObj;
        ATTR * pAttrIT;
        SYNTAX_INTEGER * pIT;

        Assert(0 == offsetof(ATTR, attrTyp));

        for (pObj = pNativeReply->pObjects;
             NULL != pObj;
             pObj = pObj->pNextEntInf) {
            pAttrIT = bsearch(&AttrITKey,
                              pObj->Entinf.AttrBlock.pAttr,
                              pObj->Entinf.AttrBlock.attrCount,
                              sizeof(ATTR),
                              CompareAttrtyp);
            if (NULL != pAttrIT) {
                Assert(ATT_INSTANCE_TYPE == pAttrIT->attrTyp);
                Assert(1 == pAttrIT->AttrVal.valCount);
                Assert(sizeof(SYNTAX_INTEGER) == pAttrIT->AttrVal.pAVal->valLen);

                pIT = (SYNTAX_INTEGER *) pAttrIT->AttrVal.pAVal->pVal;

                if (*pIT & ~IT_MASK_WIN2K) {
                    DPRINT2(0, "Filtering IT bits 0x%x on obj %ls outbound to"
                                " Win2k replica.\n",
                            *pIT & ~IT_MASK_WIN2K,
                            pObj->Entinf.pName->StringName);
                    Assert(!(*pIT & ~IT_MASK_CURRENT));
                    *pIT &= IT_MASK_WIN2K;
                }
            } else {
                Assert(!"Outbound object data doesn't contain instance type?");
            }
        }

        // The destination DC doesn't understand NDNCs.  Is it a pre-SP2 Win2k
        // GC that (erroneously) thinks it should hold a read-only replica of an
        // NDNC?

        pCR = FindExactCrossRef(pNativeReply->pNC, NULL);
        if (NULL == pCR) {
            // Note that FSMO transfers send the FSMO object name in the "pNC"
            // field, which is not necessarily the name of the NC.
            pNC = FindNCParentDSName(pNativeReply->pNC, FALSE, FALSE);
    
            if (NULL != pNC) {
                pCR = FindExactCrossRef(pNC, NULL);
            }
    
            if (NULL == pCR) {
                // We no longer have a cross-ref for this instantiated replica.
                // This NC must must have been recently removed from the forest.
                // We will remove our replica of this NC as soon as the KCC runs.
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
        }
    
        Assert(pCR->flags & FLAG_CR_NTDS_NC);
    
        if (pCR->flags & FLAG_CR_NTDS_NOT_GC_REPLICATED) {
            // This request is from a Win2k DSA that, because it's a GC and has
            // no knowledge of the special handling of non-domain NCs, falsely
            // thinks that it is supposed to host a copy of this non-domain NC.
            // Spoof it by returning only the NC head and the Deleted Objects
            // container.  This minimizes the additional replication traffic
            // while preventing the destination DSA from thinking we we are
            // "stale" and routing around us (as it would if we instead returned
            // an error).  Win2k SP2 GCs are smart enough not to ask for NDNCs.
            
            // See also the companion functionality in
            // draXlateInboundRequestToNativeRequest.

            DPRINT(0, "Spoofing Win2k GC trying to replicate NDNC (part 2).\n");

            // Note that DRA_GetNCChanges enforces a minimum on the number of
            // objects it will put in a packet -- as of this writing that
            // minimum is greater than the number of objects we need to return.
            // So if we have prepared more objects to return than the two we
            // need, remove them from the returned object list.
            if (pNativeReply->cNumObjects > 2) {
                pNativeReply->pObjects->pNextEntInf->pNextEntInf = NULL;
                pNativeReply->cNumObjects = 2;
            }

            Assert((pNativeReply->cNumObjects < 1)
                   || NameMatched(pNativeReply->pObjects->Entinf.pName, pCR->pNC));
            Assert((pNativeReply->cNumObjects < 2)
                   || (0 == wcsncmp(pNativeReply->pObjects->pNextEntInf->Entinf.pName->StringName,
                                    L"CN=Deleted Objects,",
                                    ARRAY_SIZE("CN=Deleted Objects,") - 1)));
            
            memset(&pNativeReply->usnvecTo, 0, sizeof(pNativeReply->usnvecTo));
            pNativeReply->pUpToDateVecSrc = NULL;
            pNativeReply->fMoreData = FALSE;
        }
    }

    // Convert from native reply version to desired reply version (sans
    // compression).

    switch (*pdwMsgOutVersion) {
    case 1: // Win2k reply.
        Assert((DRS_MSG_GETCHGREPLY *) pNativeReply != pOutboundReply);
        
        pOutboundReply->V1.uuidDsaObjSrc     = pNativeReply->uuidDsaObjSrc;
        pOutboundReply->V1.uuidInvocIdSrc    = pNativeReply->uuidInvocIdSrc;
        pOutboundReply->V1.pNC               = pNativeReply->pNC;
        pOutboundReply->V1.usnvecFrom        = pNativeReply->usnvecFrom;
        pOutboundReply->V1.usnvecTo          = pNativeReply->usnvecTo;
        pOutboundReply->V1.pUpToDateVecSrcV1 = UpToDateVec_Convert(pTHS, 1, pNativeReply->pUpToDateVecSrc);
        pOutboundReply->V1.PrefixTableSrc    = pNativeReply->PrefixTableSrc;
        pOutboundReply->V1.ulExtendedRet     = pNativeReply->ulExtendedRet;
        pOutboundReply->V1.cNumObjects       = pNativeReply->cNumObjects;
        pOutboundReply->V1.cNumBytes         = pNativeReply->cNumBytes;
        pOutboundReply->V1.pObjects          = pNativeReply->pObjects;
        pOutboundReply->V1.fMoreData         = pNativeReply->fMoreData;

        // A V1 reply has the nc size in the ulExtendedRet field
        if (pNativeReply->cNumNcSizeObjects) {
            pOutboundReply->V1.ulExtendedRet = pNativeReply->cNumNcSizeObjects;
        }
        
        Assert(!pTHS->fLinkedValueReplication);

        // In a customer scenario, you should never have any values when
        // running in the old mode. However, for testing, we allow a new
        // mode system to be regressed to old. In that case, this assert
        // might go off.
        // Assert(pmsgOutNew->V3.cNumValues == 0);
        break;

    case 6: // Whistler reply.
        if (pNativeReply != &pOutboundReply->V6) {
            pOutboundReply->V6 = *pNativeReply;
        }
        break;

    default:
        // Logic error?
        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, *pdwMsgOutVersion);
    }

    // At this point, pOutboundReply now holds the desired reply format,
    // uncompressed.

    if (DRA_XLATE_COMPRESS & dwXlateFlags) {
        // Compress the outbound message.
        DRS_COMP_ALG_TYPE CompressionAlg;

        // First we encode it into a stream.
        if (!draEncodeReply(pTHS, *pdwMsgOutVersion, pOutboundReply, 0,
                            &pbEncodedReply, &cbEncodedReply)) {
            // Allocate a buffer for the compressed data.
            cbCompressedReply = cbEncodedReply;
            pbCompressedReply = THAllocEx(pTHS, cbCompressedReply);

            // And compress it.
            cbCompressedReply = draCompressBlobDispatch(
                pbCompressedReply, cbCompressedReply,
                pExt,
                pbEncodedReply, cbEncodedReply,
                &CompressionAlg);

            if (0 != cbCompressedReply) {
                // Compression successful; send the compressed form.
                // Note that we're abandoning all the allocations in the
                // original reply; they'll be freed in bulk when the
                // thread state is freed (momentarily).
                switch (*pdwMsgOutVersion) {
                case 1:
                    Assert( DRS_COMP_ALG_MSZIP==CompressionAlg );
                    pComprBlob = &pOutboundReply->V2.CompressedV1;
                    *pdwMsgOutVersion = 2;
                    break;

                case 6:
                    if( IS_DRS_EXT_SUPPORTED(pExt, DRS_EXT_GETCHGREPLY_V7) ) {
                        pComprBlob = &pOutboundReply->V7.CompressedAny;
                        pOutboundReply->V7.dwCompressedVersion = *pdwMsgOutVersion;
                        pOutboundReply->V7.CompressionAlg = CompressionAlg;
                        *pdwMsgOutVersion = 7;
                    } else {
                        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, *pdwMsgOutVersion);
                    }
                    break;

                default:
                    DRA_EXCEPT(DRAERR_InternalError, *pdwMsgOutVersion);
                }

                pComprBlob->cbUncompressedSize = cbEncodedReply;
                pComprBlob->cbCompressedSize = cbCompressedReply;
                pComprBlob->pbCompressedData = pbCompressedReply;
            }
            // Else compression failed (data may not be compressible);
            // go ahead and send uncompressed reply.

            THFreeEx(pTHS, pbEncodedReply);
        }
        // Else encoding failed; go ahead and send uncompressed reply.
    }

    if (NULL == pComprBlob) {
        // Returning uncompressed reply.
        IADJUST(pcDRAOutBytesTotal,       pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesTotalRate,   pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesNotComp,     pNativeReply->cNumBytes);
        IADJUST(pcDRAOutBytesNotCompRate, pNativeReply->cNumBytes);
    } else {
        // Returning compressed reply.
        IADJUST(pcDRAOutBytesTotal,        cbCompressedReply);
        IADJUST(pcDRAOutBytesTotalRate,    cbCompressedReply);
        IADJUST(pcDRAOutBytesCompPre,      cbEncodedReply);
        IADJUST(pcDRAOutBytesCompPreRate,  cbEncodedReply);
        IADJUST(pcDRAOutBytesCompPost,     cbCompressedReply);
        IADJUST(pcDRAOutBytesCompPostRate, cbCompressedReply);
    }

    return cbCompressedReply;
}


void
draXlateInboundReplyToNativeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwReplyVersion,
    IN  DRS_MSG_GETCHGREPLY *         pInboundReply,
    IN  DWORD                         dwXlateFlags,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pNativeReply
    )
/*++

Routine Description:

    Translates an inbound GetNCChanges reply into the native reply structure.

Arguments:

    pTHS (IN)

    dwReplyVersion (IN) - Version of inbound reply.

    pInboundReply (IN) - Inbound reply message.

    dwXlateFlags (IN) - 0 or more of the following bits:
        DRA_XLATE_FSMO_REPLY - Reply is the result of a FSMO operation.

    pNativeReply (OUT) - On return, holds the reply in native format.  May be
        the same as pInboundReply, in which case the message is translated
        in-place.

Return Value:

    None.  Generates exception on catastrophic failure.

--*/
{
    DWORD ret, dwOriginalReplyVersion = dwReplyVersion;
    DWORD cbCompressedSize = 0, cbDesiredUncompressedSize = 0, cbActualUncompressedSize = 0;
    BYTE * pbEncodedReply, * pbCompressedData;
    DRS_MSG_GETCHGREPLY UncompressedReply;
    DRS_COMP_ALG_TYPE CompressionAlg;

    // Is the reply encoded and compressed?
    switch (dwReplyVersion) {
    case 2:
        // Encoded/compressed Win2k-compatible V1 reply.
        if (pTHS->fLinkedValueReplication) {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwReplyVersion);
        }
        pbCompressedData = pInboundReply->V2.CompressedV1.pbCompressedData;
        cbCompressedSize = pInboundReply->V2.CompressedV1.cbCompressedSize;
        cbDesiredUncompressedSize = pInboundReply->V2.CompressedV1.cbUncompressedSize;
        dwReplyVersion = 1;
        CompressionAlg = DRS_COMP_ALG_MSZIP;
        break;
    
    case 7:
    	// Encoded/compressed Whistler reply with support for different
    	// compression algorithms.
        pbCompressedData = pInboundReply->V7.CompressedAny.pbCompressedData;
        cbCompressedSize = pInboundReply->V7.CompressedAny.cbCompressedSize;
        cbDesiredUncompressedSize = pInboundReply->V7.CompressedAny.cbUncompressedSize;
        dwReplyVersion = pInboundReply->V7.dwCompressedVersion;
        CompressionAlg = pInboundReply->V7.CompressionAlg;
        Assert( (6 == dwReplyVersion) );
    	break;

    case 1:
        // w2k reply
        if (pTHS->fLinkedValueReplication) {
            DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwReplyVersion);
        }
        // fall through
    case 6:
        // Whistler native reply 
        // Not encoded/compressed.
        pbCompressedData = NULL;
        break;

    default:
        DRA_EXCEPT(DRAERR_InternalError, dwReplyVersion);
    }

    // Decompress/decode if necessary.
    if (NULL != pbCompressedData) {
        // Reply message is compressed and encoded -- recreate original reply.
        BYTE *pbEncodedReply = THAllocEx(pTHS, cbDesiredUncompressedSize);

        // Uncompress the reply.
        cbActualUncompressedSize = draUncompressBlobDispatch(
            pTHS, CompressionAlg,
            pbEncodedReply, cbDesiredUncompressedSize,
            pbCompressedData, cbCompressedSize);

        if (cbDesiredUncompressedSize != cbActualUncompressedSize) {
            DPRINT2(0,
                    "Failed to decompress message; actual uncomp"
                    " size was %u but source says it should have been %u.\n",
                    cbActualUncompressedSize,
                    cbDesiredUncompressedSize);
            DRA_EXCEPT(DRAERR_InvalidParameter,
                       cbActualUncompressedSize - cbDesiredUncompressedSize);
        }

        // Decode the reply.
        ret = draDecodeReply(pTHS,
                             dwReplyVersion,
                             pbEncodedReply,
                             cbDesiredUncompressedSize,
                             &UncompressedReply);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        THFreeEx(pTHS, pbEncodedReply);

        pInboundReply = &UncompressedReply;
    }

    // Convert to native format.
    switch (dwReplyVersion) {
    case 1:
        // A V6 looks like a V1 with zeros at the end.
        if (pNativeReply != &pInboundReply->V6) {
            memcpy(pNativeReply, &pInboundReply->V1, sizeof(pInboundReply->V1));
        }

        memset((BYTE *) pNativeReply + sizeof(DRS_MSG_GETCHGREPLY_V1),
               0,
               sizeof(DRS_MSG_GETCHGREPLY_NATIVE) - sizeof(DRS_MSG_GETCHGREPLY_V1));

        if (!(DRA_XLATE_FSMO_REPLY & dwXlateFlags)) {
            pNativeReply->cNumNcSizeObjects = pNativeReply->ulExtendedRet;
            pNativeReply->ulExtendedRet = 0;
        }
        break;
    
    case 6:
        // Already in native format.
        if (pNativeReply != &pInboundReply->V6) {
            *pNativeReply = pInboundReply->V6;
        }
        break;

    default:
        DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwReplyVersion);
    }

    if ((NULL != pNativeReply->pUpToDateVecSrc)
        && (UPTODATE_VECTOR_NATIVE_VERSION
            != pNativeReply->pUpToDateVecSrc->dwVersion)) {
        // Convert UTD vector to native format.
        pNativeReply->pUpToDateVecSrc
            = UpToDateVec_Convert(pTHS,
                                  UPTODATE_VECTOR_NATIVE_VERSION,
                                  pNativeReply->pUpToDateVecSrc);

        // The converted UTD will contain no timestamps.  However we know we
        // just talked to this source DSA, so add the current time to the
        // entry in the vector corresponding to this source.
        UpToDateVec_AddTimestamp(&pNativeReply->uuidInvocIdSrc,
                                 GetSecondsSince1601(),
                                 pNativeReply->pUpToDateVecSrc);
    }
    
    // Switch to LVR mode we detect LVR data from source
    if (!pTHS->fLinkedValueReplication) {
        // We are not in LVR mode

        // Remote supports it, upgrade
        if ( pNativeReply->cNumValues ) {
            DsaEnableLinkedValueReplication( pTHS, TRUE );
        }
    }

    // Conversion complete -- update perf counters.
    if (NULL != pbCompressedData) {
        // Compressed.
        DPRINT1(2, "Uncompressed message V%d\n", dwOriginalReplyVersion);

        IADJUST(pcDRAInBytesTotal,        cbCompressedSize);
        IADJUST(pcDRAInBytesTotalRate,    cbCompressedSize);
        IADJUST(pcDRAInBytesCompPre,      cbActualUncompressedSize);
        IADJUST(pcDRAInBytesCompPreRate,  cbActualUncompressedSize);
        IADJUST(pcDRAInBytesCompPost,     cbCompressedSize);
        IADJUST(pcDRAInBytesCompPostRate, cbCompressedSize);
    } else {
        // Uncompressed.
        IADJUST(pcDRAInBytesTotal,       pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesTotalRate,   pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesNotComp,     pNativeReply->cNumBytes);
        IADJUST(pcDRAInBytesNotCompRate, pNativeReply->cNumBytes);
    }
}



////////////////////////////////////////////////////////////////////////////////
//
//  REQUEST ENCODE / DECODE FUNCTIONS
//

DWORD
draEncodeRequest(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_GETCHGREQ * pReq,
    IN  DWORD               cbHeaderSize,
    OUT BYTE **             ppbEncodedMsg,
    OUT DWORD *             pcbEncodedMsg
    )
/*++

Routine Description:

    Encodes a request structure into a byte stream.

Arguments:

    pTHS (IN)

    dwMsgVersion (IN) - Version of message to encode.

    pReq (IN) - Message to encode.

    cbHeaderSize (IN) - Number of additional bytes to allocate at beginning of
        the encoded buffer to hold a header or other data.  (0 if none.)

    ppbEncodedMsg (OUT) - On successful return, contains a pointer to the
        THAlloc()'ed buffer holding the encoded message (offset by cbHeaderSize,
        if specified).

    pcbEncodedMsg (OUT) - On successful return, holds the size in bytes of
        *ppbEncodedMsg.  Includes cbHeaderSize.

Return Values:

    Win32 error code.

--*/
{
    char *      pPickdUpdReplicaMsg;
    ULONG       cbPickdSize;
    ULONG       ret = ERROR_SUCCESS;
    handle_t    hEncoding;
    RPC_STATUS  status;
    ULONG       ulEncodedSize;

    *ppbEncodedMsg = NULL;
    *pcbEncodedMsg = 0;

    __try {
        // Create encoding handle. Use bogus parameters because we don't
        // know the size yet, we'll reset to correct parameters later.
        status = MesEncodeFixedBufferHandleCreate(grgbBogusBuffer,
                                                  BOGUS_BUFFER_SIZE,
                                                  &ulEncodedSize,
                                                  &hEncoding);
        if (status != RPC_S_OK) {
            // Event logged below
            DRA_EXCEPT(status, 0);
        }

        __try {
            // Determine size of pickled update replica message.
            switch (dwMsgVersion) {
            case 4:
                cbPickdSize = DRS_MSG_GETCHGREQ_V4_AlignSize(hEncoding, &pReq->V4);
                break;
            
            case 7:
                cbPickdSize = DRS_MSG_GETCHGREQ_V7_AlignSize(hEncoding, &pReq->V7);
                break;
    
            default:
                DRA_EXCEPT(DRAERR_InternalError, dwMsgVersion);
            }

            // Allocate additional space for a header to prefix the allocated
            // data (if requested).
            *ppbEncodedMsg = THAllocEx(pTHS, cbPickdSize + cbHeaderSize);
            *pcbEncodedMsg = cbPickdSize + cbHeaderSize;

            // Set up pointer to encoding area.
            pPickdUpdReplicaMsg = *ppbEncodedMsg + cbHeaderSize;

            // Reset handle so that data is pickled into mail message
            status = MesBufferHandleReset(hEncoding, MES_FIXED_BUFFER_HANDLE,
                                          MES_ENCODE, &pPickdUpdReplicaMsg,
                                          cbPickdSize, &ulEncodedSize);
            if (status != RPC_S_OK) {
                // Event logged below
                DRA_EXCEPT(status, 0);
            }

            // Pickle data into buffer within mail message.
            switch (dwMsgVersion) {
            case 4:
                DRS_MSG_GETCHGREQ_V4_Encode(hEncoding, &pReq->V4);
                break;
            
            case 7:
                DRS_MSG_GETCHGREQ_V7_Encode(hEncoding, &pReq->V7);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        } __finally {
            // Free encoding handle
            MesHandleFree(hEncoding);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_DRA_REQUPD_PICFAULT,
                  szInsertWin32Msg(ret),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        DPRINT2(0, "Failed to encode DRS_MSG_GETCHGREQ, v=%d, error %d.\n",
                dwMsgVersion, ret);

        if (NULL != *ppbEncodedMsg) {
            THFreeEx(pTHS, *ppbEncodedMsg);
            *ppbEncodedMsg = NULL;
            *pcbEncodedMsg = 0;
        }
    }

    return ret;
}


ULONG
draDecodeRequest(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwMsgVersion,
    IN  BYTE *              pbEncodedMsg,
    IN  DWORD               cbEncodedMsg,
    OUT DRS_MSG_GETCHGREQ * pReq
    )
/*++

Routine Description:

    Decodes a DRS_MSG_GETCHGREQ structure from a byte stream, presumably
    encoded by a prior call to draEncodeRequest().

Arguments:

    pTHS (IN)
    
    dwMsgVersion (IN) - Version of the encoded request structure.
    
    pbEncodedMsg (IN) - Byte stream holding encoded request structure.
    
    cbEncodedMsg (IN) - Size in bytes of byte stream.
    
    pReq (OUT) - On successful return, holds the decoded request structure.

Return Values:

    Win32 error code.

--*/
{
    handle_t    hDecoding;
    RPC_STATUS  status;
    ULONG       ret = 0;

    // Set the request to zero so that all pointers are NULL.
    memset(pReq, 0, sizeof(*pReq));

    __try {
        // Set up decoding handle
        status = MesDecodeBufferHandleCreate(pbEncodedMsg, cbEncodedMsg, &hDecoding);
        if (status != RPC_S_OK) {
            DRA_EXCEPT(status, 0);
        }

        __try {
            switch (dwMsgVersion) {
            case 4:
                DRS_MSG_GETCHGREQ_V4_Decode(hDecoding, &pReq->V4);
                break;
            
            case 7:
                DRS_MSG_GETCHGREQ_V7_Decode(hDecoding, &pReq->V7);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        } __finally {
            // Free decoding handle
            MesHandleFree(hDecoding);
        }
    } __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_DRA_MAIL_UPDREP_BADMSG,
                  szInsertWin32Msg(ret),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        DPRINT2(0, "Failed to decode DRS_MSG_GETCHGREQ v=%d, error %d.\n",
                dwMsgVersion, ret);
    }

    return ret;
}



////////////////////////////////////////////////////////////////////////////////
//
//  REPLY ENCODE / DECODE FUNCTIONS
//

ULONG
draEncodeReply(
    IN  THSTATE *               pTHS,
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_GETCHGREPLY *   pReply,
    IN  DWORD                   cbHeaderSize,
    OUT BYTE **                 ppbEncodedMsg,
    OUT DWORD *                 pcbEncodedMsg
    )
/*++

Routine Description:

    Encodes a reply structure into a byte stream.

Arguments:

    pTHS (IN)

    dwMsgVersion (IN) - Version of message to encode

    pReply (IN) - Message to encode.

    cbHeaderSize (IN) - Number of additional bytes to allocate at beginning of
        the encoded buffer to hold a header or other data.  (0 if none.)

    ppbEncodedMsg (OUT) - On successful return, contains a pointer to the
        THAlloc()'ed buffer holding the encoded message (offset by cbHeaderSize,
        if specified).

    pcbEncodedMsg (OUT) - On successful return, holds the size in bytes of
        *ppbEncodedMsg.  Includes cbHeaderSize.

Return Values:

    Win32 error code.

--*/
{
    char *      pPickdUpdReplicaMsg;
    ULONG       cbPickdSize;
    ULONG       ret = ERROR_SUCCESS;
    handle_t    hEncoding;
    RPC_STATUS  status;
    ULONG       ulEncodedSize;

    *ppbEncodedMsg = NULL;
    *pcbEncodedMsg = 0;

    __try {
        // Create encoding handle. Use bogus parameters because we don't
        // know the size yet, we'll reset to correct parameters later.

        status = MesEncodeFixedBufferHandleCreate(grgbBogusBuffer,
                                                  BOGUS_BUFFER_SIZE,
                                                  &ulEncodedSize,
                                                  &hEncoding);
        if (status != RPC_S_OK) {
            // Event logged below
            DRA_EXCEPT(status, 0);
        }

        __try {
            // Determine size of pickled update replica message
            switch (dwMsgVersion) {
            case 1:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V1_AlignSize(hEncoding,
                                                               &pReply->V1);
                break;
            
            case 6:
                cbPickdSize = DRS_MSG_GETCHGREPLY_V6_AlignSize(hEncoding,
                                                               &pReply->V6);
                break;
            
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }

            // Allocate additional space for a header to prefix the allocated
            // data (if requested).
            *ppbEncodedMsg = THAllocEx(pTHS, cbPickdSize + cbHeaderSize);
            *pcbEncodedMsg = cbPickdSize + cbHeaderSize;

            // Set up pointer to encoding area.
            pPickdUpdReplicaMsg = *ppbEncodedMsg + cbHeaderSize;

            // Reset handle so that data is pickled into mail message
            status = MesBufferHandleReset(hEncoding, MES_FIXED_BUFFER_HANDLE,
                                          MES_ENCODE, &pPickdUpdReplicaMsg,
                                          cbPickdSize, &ulEncodedSize);
            if (status != RPC_S_OK) {
                // Event logged below
                DRA_EXCEPT(status, 0);
            }

            // Pickle data into buffer within mail message.
            switch (dwMsgVersion) {
            case 1:
                DRS_MSG_GETCHGREPLY_V1_Encode(hEncoding, &pReply->V1);
                break;
            case 6:
                DRS_MSG_GETCHGREPLY_V6_Encode(hEncoding, &pReply->V6);
                break;
            default:
                DRA_EXCEPT(ERROR_UNKNOWN_REVISION, dwMsgVersion);
            }
        }
        __finally {
            // Free encoding handle
            MesHandleFree(hEncoding);
        }
    }
    __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_DRA_UPDREP_PICFAULT,
                  szInsertWin32Msg( ret ),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        DPRINT2(0, "Failed to encode DRS_MSG_GETCHGREPLY, v=%d, error %d.\n",
                dwMsgVersion, ret);

        if (NULL != *ppbEncodedMsg) {
            THFreeEx(pTHS, *ppbEncodedMsg);
            *ppbEncodedMsg = NULL;
            *pcbEncodedMsg = 0;
        }
    }

    return ret;
}


ULONG
draDecodeReply(
    IN  THSTATE *               pTHS,
    IN  DWORD                   dwMsgVersion,
    IN  BYTE *                  pbEncodedMsg,
    IN  DWORD                   cbEncodedMsg,
    OUT DRS_MSG_GETCHGREPLY *   pReply
    )
/*++

Routine Description:

    Decodes a DRS_MSG_GETCHGREPLY structure from a byte stream, presumably
    encoded by a prior call to draEncodeReply().

Arguments:

    pTHS (IN)
    
    dwMsgVersion (IN) - Version of the encoded reply structure.
    
    pbEncodedMsg (IN) - Byte stream holding encoded reply structure.
    
    cbEncodedMsg (IN) - Size in bytes of byte stream.
    
    pReply (OUT) - On successful return, holds the decoded reply structure.

Return Values:

    Win32 error code.

--*/
{
    handle_t    hDecoding;
    RPC_STATUS  status;
    ULONG       ret = 0;

    // Set the request to zero so that all pointers are NULL.
    memset(pReply, 0, sizeof(*pReply));

    // A comment regarding the elaborate exception handling below. GetDraException
    // knows how to decode a DRA exception vector, but will assert on a regalar
    // exception. HandleMostExceptions can handle any kind of exception, but does not
    // know how to dig the error code out of the DRA exception vector. The code below
    // raises both kinds of exceptions, DRA exceptions and regular.  The rule is that
    // either kind of handler can only handle its own type (DRA or non-DRA) of exception
    // within its scope.
    __try {
        // Set up decoding handle
        status = MesDecodeBufferHandleCreate(pbEncodedMsg, cbEncodedMsg, &hDecoding);
        if (status != RPC_S_OK) {
            DRA_EXCEPT(status, 0);
        }

        __try {
            __try {
                ret = 0;
                switch (dwMsgVersion) {
                case 1:
                    DRS_MSG_GETCHGREPLY_V1_Decode(hDecoding, &pReply->V1);
                    break;
                case 6:
                    DRS_MSG_GETCHGREPLY_V6_Decode(hDecoding, &pReply->V6);
                    break;
                default:
                    ret = ERROR_UNKNOWN_REVISION;
                }
            } __except (HandleMostExceptions(ret = GetExceptionCode())) {
                // We use HandleMostExceptions here because these rpc routines
                // can raise exceptions that are not in DRA format
                NOTHING;
            }
            if (ret) {
                // Re-raise the error as a DRA exception so that GetDraException
                // will be able to handle it.
                DRA_EXCEPT(ret, 0);
            }
        } finally {
            // Free decoding handle
            MesHandleFree(hDecoding);
        }
    } __except (GetDraException(GetExceptionInformation(), &ret)) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_BASIC,
                  DIRLOG_DRA_MAIL_UPDREP_BADMSG,
                  szInsertWin32Msg(ret),
                  szInsertWin32ErrCode(ret),
                  NULL, NULL, NULL, NULL, NULL, NULL );
        DPRINT2(0, "Failed to decode DRS_MSG_GETCHGREPLY v=%d, error %d.\n",
                dwMsgVersion, ret);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drancadd.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drancadd.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Methods to add a replica of a naming context from a given source DSA.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>            // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>             // schema cache
#include <dbglobal.h>           // The header for the directory database
#include <mdglobal.h>           // MD global definition header
#include <mdlocal.h>            // MD local definition header
#include <dsatools.h>           // needed for output allocation

#include <dnsapi.h>             // for dns validation routines

// Logging headers.
#include "dsevent.h"            /* header Audit\Alert logging */
#include "mdcodes.h"            /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"             /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include "debug.h"              /* standard debugging header */
#define DEBSUB "DRANCADD:"      /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drasch.h"
#include "drauptod.h"


#include <fileno.h>
#define  FILENO FILENO_DRANCADD


ULONG
DRA_ReplicaAdd(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  MTX_ADDR *  pmtx_addr,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions,
    OUT GUID *      puuidDsaObjSrc              OPTIONAL
    )
/*++

Routine Description:

    Add inbound replication of an NC (which may or may not already exist
    locally) from a given source DSA.

Arguments:

    pTHS (IN) - Thread state.

    pNC (IN) - NC for which to add the replica.  The NC record must exist
        locally as either an object (instantiated or not) or a reference
        phantom (i.e., a phantom with a guid).

    pSourceDsaDN (IN, OPTIONAL) - DN of the source DSA's ntdsDsa object.
        Required if ulOptions includes DRS_ASYNC_REP; ignored otherwise.

    pTransportDN (IN, OPTIONAL) - DN of the interSiteTransport object
        representing the transport by which to communicate with the source
        server.  Required if ulOptions includes DRS_MAIL_REP; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pszSourceDsaDnsDomainName (IN, OPTIONAL) - DNS domain name of the source
        server.  If pszSourceDsaAddress is not a GUID-based DNS name for an
        ntdsDsa object that is present on the local machine, this parameter
        is required if the caller wants mutual authentication.

    preptimesSync (IN, OPTIONAL) - Schedule by which to replicate the NC from
        this source in the future.

    ulOptions (IN) - Zero or more of the following bits:
        DRS_WRIT_REP
            Create a writeable replica.  Otherwise, read-only.
        DRS_MAIL_REP
            Sync from the source DSA via mail (i.e., an ISM transport) rather
            than RPC.
        DRS_ASYNC_REP
            Don't replicate the NC now -- just save enough state such that we
            know to replicate it later.
        DRS_INIT_SYNC
            Sync the NC from this source when the DSA is started.
        DRS_PER_SYNC
            Sync the NC from this source periodically, as defined by the
            schedule passed in the preptimesSync argument.
        DRS_CRITICAL_ONLY
            Sync only the critical objects now
        DRS_DISABLE_AUTO_SYNC
            Disable notification-based synchronization for the NC from this
            source.  (Synchronization can be forced by using the DRS_SYNC_FORCED
            bit in the sync request options.)
        DRS_DISABLE_PERIODIC_SYNC
            Disable periodic synchronization for the NC from this source.
            (Synchronization can be forced by using the DRS_SYNC_FORCED bit in
            the sync request options.)
        DRS_USE_COMPRESSION
            Replication messaged along this link should be compressed when
            possible.
        DRS_NEVER_NOTIFY
            Do not use notifications for this link.  Syncs must be triggered
            manually (i.e., by calling DsReplicaSync()) or by the periodic
            schedule.

    puuidDsaObjSrc (OUT) 
	    uuid of the source

Return Values:

    0 - Success.
    DRSERR_* - Failure.

--*/
{
    DBPOS *                 pDB;
    ULONG                   ret;
    SYNTAX_INTEGER          it;
    BOOL                    fHasRepsFrom = FALSE;
    REPLICA_LINK *          pVal;
    ULONG                   len;
    UUID                    uuidDsaObj;
    UUID                    uuidTransportObj;
    ULONG                   ulSyncFailure = 0;
    PARTIAL_ATTR_VECTOR *   pPartialAttrVec = NULL;
    DB_ERR                  dbFindErr;
    ATTCACHE *              pAC;
    CLASSCACHE *            pCC;
    ATTRTYP                 objClass;
    DSNAME *                pCat;
    ULONG                   dntNC = 0;
    SCHEMAPTR *             pSchema = NULL;
    UPTODATE_VECTOR *       pUpToDateVec = NULL;

    // Log parameters.
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_DRA_REPLICAADD_ENTRY,
             szInsertWC(pNC->StringName),
             szInsertSz(pmtx_addr->mtx_name),
             szInsertHex(ulOptions));

    // pmtx_addr must be aligned properly (just like everything else).
    Assert(0 == ((UINT_PTR) pmtx_addr) % sizeof(ULONG));

    // Code below assumes we don't add replicas asynchronously during install.
    Assert(!((ulOptions & DRS_ASYNC_REP) && DsaIsInstalling()));

    // Critical only is only allowed while installing
    if ( (ulOptions & DRS_CRITICAL_ONLY) && (!DsaIsInstalling()) ) {
        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    // Can't replicate from self!
    if ( (!DsaIsInstalling()) && (MtxSame( pmtx_addr, gAnchor.pmtxDSA )) ) {
        DRA_EXCEPT(ERROR_DS_CLIENT_LOOP, 0);
    }

    // Give initial values
    memset( &uuidDsaObj, 0, sizeof( UUID ) );
    memset( &uuidTransportObj, 0, sizeof( UUID ) );

    BeginDraTransaction(SYNC_WRITE);
    pDB = pTHS->pDB;

    __try {
        if (DRS_MAIL_REP & ulOptions) {
            // Verify the transport DN is valid.
            if ((NULL == pTransportDN)
                || DBFindDSName(pDB, pTransportDN)
                || DBIsObjDeleted(pDB)) {
                // Transport DN is invalid.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (fNullUuid(&pTransportDN->Guid)) {
                // Get the objectGuid of the transport object.
                GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &uuidTransportObj,
                                  sizeof(uuidTransportObj));
            }
            else {
                uuidTransportObj = pTransportDN->Guid;
            }
        }

        if (DRS_ASYNC_REP & ulOptions) {
            // Verify we already have a copy of the source DSA's ntdsDsa object.
            if ((NULL == pSourceDsaDN)
                || DBFindDSName(pDB, pSourceDsaDN)
                || DBIsObjDeleted(pDB)) {
                // Source DSA DN is invalid.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }

            if (fNullUuid(&pSourceDsaDN->Guid)) {
                // Get the objectGuid of the source DSA object.
                GetExpectedRepAtt(pDB, ATT_OBJECT_GUID, &uuidDsaObj,
                                  sizeof(uuidDsaObj));
            }
            else {
                uuidDsaObj = pSourceDsaDN->Guid;
            }
            if (memcmp( &uuidDsaObj, &(gAnchor.pDSADN->Guid), sizeof(UUID) ) == 0) {
                // Can't replicate from self!
                // Source DSA DN is invalid.
                DRA_EXCEPT(ERROR_DS_CLIENT_LOOP, 0);
            }
        }

        // Does the NC record exist?
        dbFindErr = DBFindDSName(pDB, pNC);

        switch (dbFindErr) {
        case DIRERR_OBJ_NOT_FOUND:
            // NC record exists neither as a phantom nor an object.  This
            // implies that we have no cross-ref for this NC.  Allowed only
            // during install.
            if (!DsaIsInstalling()) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
            Assert(NULL == pUpToDateVec);
            break;

        case DIRERR_NOT_AN_OBJECT:
            // NC record exists as a phantom.
            if (!DsaIsInstalling()) {
                if (!DBHasValues(pDB, ATT_OBJECT_GUID)) {
                    // But it's a structural phantom (i.e., it has no guid).
                    // Allowed only during install.
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                } else if ((DRS_WRIT_REP & ulOptions) && !fIsNDNC(pNC)) {
                    // You can add new writeable config/schema/domain NCs only
                    // during install.  (You can add new replication partners
                    // for a read-only or writeable NC anytime, but you can't
                    // make an installed DC a master replica of an NC that it
                    // didn't master before unless the NC is an NDNC.)
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                }
            }
            Assert(NULL == pUpToDateVec);
            break;

        case 0:
            // The NC prefix object already exists.  This is fine as long as:
            //
            // (1) the NC is not deleted (should never happen),
            // (2) the "writeable" flag in the options argument and the
            //     object's instance type are compatible,
            // (3) we don't already replicate this NC from the specified
            //     source, and
            // (4) the existing NC is not in the process of being removed
            //     (which would also imply it is a read-only replica).

            if (DBIsObjDeleted(pDB)) {
                // NC object is deleted.
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }

            GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

            if (!(it & IT_UNINSTANT)
                && (!(it & IT_WRITE) != !(ulOptions & DRS_WRIT_REP))) {
                // "Is writeable" option does not match the "is writeable" bit
                // in the pre-existing object's instance type.
                DRA_EXCEPT(DRAERR_BadInstanceType, it);
            }

            if (it & IT_UNINSTANT) {
                // NC is not yet instantiated.
                Assert(!(it & IT_NC_GOING));
                Assert(!DBHasValues(pDB, ATT_REPS_FROM));
                Assert(NULL == pUpToDateVec);

                if ((DRS_WRIT_REP & ulOptions)
                    && !DsaIsInstalling()
                    && !fIsNDNC(pNC)) {
                    // You can add new writeable config/schema/domain NCs only
                    // during install.  (You can add new replication partners
                    // for a read-only or writeable NC anytime, but you can't
                    // make an installed DC a master replica of an NC that it
                    // didn't master before unless the NC is an NDNC.)
                    DRA_EXCEPT(DRAERR_BadNC, 0);
                }
            } else {
                // NC is already instantiated.

                if (it & IT_NC_GOING) {
                    // This NC has been partially removed (i.e., we
                    // encountered an error while removing the NC previously);
                    // can't readd it until it is completely removed.

                    // The primary reason this is here is to prevent weird
                    // interactions with the SD propagator.  If an NC is
                    // partially removed, it may well be that we have removed
                    // an object's parent but not the object itself, which would
                    // mean if the SD propagator were in the middle of a
                    // propagation it would not propagate ACL changes to this
                    // object.  If we allowed the parent to be re-added without
                    // first removing the child, an SD propagation would not be
                    // requeued, and the child would never inherit the proper
                    // ACLs.

                    // This is a rare case, but so is demoting and re-promoting
                    // a GC in quick succession (a prerequisite for this
                    // exception), and ACL discrepancies are Bad.
                    DRA_EXCEPT(DRAERR_NoReplica, 0);
                }

                if (!FindDSAinRepAtt(pDB, ATT_REPS_FROM, DRS_FIND_DSA_BY_ADDRESS,
                                     NULL, pmtx_addr, &fHasRepsFrom, &pVal,
                                     &len)) {
                    // We already have a replica from this source.
                    DRA_EXCEPT(DRAERR_DNExists, 0);
                }

                // Get current UTD vector.
                UpToDateVec_Read(pDB,
                                 it,
                                 UTODVEC_fUpdateLocalCursor,
                                 DBGetHighestCommittedUSN(),
                                 &pUpToDateVec);
            }
            break;

        default:
            // Poorly constructed pNC parameter?
            DRA_EXCEPT(DRAERR_InvalidParameter, dbFindErr);
        }

        if (DIRERR_OBJ_NOT_FOUND != dbFindErr) {
            dntNC = pDB->DNT;
            DBFillGuidAndSid(pDB, pNC);
        }

        if (!(ulOptions & DRS_WRIT_REP)) {
            // request is to add a read-only replica - need to send the partial
            // attribute vector

            // Add a reference to the current schema to ensure our partial
            // attribute vector remains valid until we're done with it.
            pSchema = (SCHEMAPTR *) pTHS->CurrSchemaPtr;
            InterlockedIncrement(&pSchema->RefCount);

            if (!GC_ReadPartialAttributeSet(pNC, &pPartialAttrVec) ||
                !pPartialAttrVec)
            {
                // Unable to read the partial attribute set on the NCHead.
                // Or it isn't there.
                // try to get it from the schema cache.
                pPartialAttrVec = pSchema->pPartialAttrVec;
            }

            // Assert: we should always have it at this point
            Assert(pPartialAttrVec);

            if (0 == dbFindErr) {
                GC_ProcessPartialAttributeSetChanges(pTHS, pNC, &uuidDsaObj);

                // Restore our cursor if it was moved.
                if ((0 != dntNC) && (pDB->DNT != dntNC)) {
                    DBFindDNT(pDB, dntNC);
                }
            }
        }

        if ((ulOptions & DRS_ASYNC_REP) && (ulOptions & DRS_MAIL_REP)) {
            // Don't replicate anything now -- just save enough state such that
            // we know to replicate it later.

            if (DIRERR_NOT_AN_OBJECT == dbFindErr) {
                // We're going to create a new NC.  Either there's no NC above
                // it or we haven't yet replicated the subref from that NC.
                // If we do indeed hold the NC above this one,
                // AddPlaceholderNC() will conveniently OR in the IT_NC_ABOVE
                // bit.
                it = (DRS_WRIT_REP & ulOptions) ? NC_MASTER : NC_FULL_REPLICA;
            }
            else {
                Assert(0 == dbFindErr);

                if (IT_UNINSTANT & it) {
                    // A pure subref already exists for this NC.  It could be an
                    // auto-generated subref (with a class of CLASS_TOP, etc.)
                    // or a snapshot of the real NC head at some point in time.
                    // We want to make sure that the placeholder NC is not valid
                    // for user modifications, which is ensured only if it's an
                    // auto-generated subref.
                    //
                    // For consistency, we'll phantomize whatever subref we have
                    // and create a fresh placeholder NC in its place.

                    // A side-effect is that here we're removing all repsFrom
                    // values.  If the KCC added multiple repsFroms for this as
                    // yet uninstantiated NC, when we're done there will be but
                    // one -- the one corresponding to the source we're using
                    // now.  The KCC will re-add the repsFroms in 15 minutes so
                    // this isn't really an issue.

                    Assert(pDB->DNT == dntNC);
                    ret = DeleteLocalObj(pTHS, pNC, TRUE, TRUE, NULL);
                    if (ret) {
                        DRA_EXCEPT(DRAERR_InternalError, ret);
                    }

                    dbFindErr = DIRERR_NOT_AN_OBJECT;

                    // Calculate the instance type we should place on the NC.
                    // We're going to instantiate it, so strip the
                    // uninstantiated bit and add the writeable bit if
                    // appropriate.
                    it &= ~IT_UNINSTANT;
                    if (DRS_WRIT_REP & ulOptions) {
                        it |= IT_WRITE;
                    }
                }
            }

            if (DIRERR_NOT_AN_OBJECT == dbFindErr) {
                // No object exists for us to add a repsFrom to -- we do
                // have a phantom for it, however.  This is typically the case
                // when we're adding a read-only NC for which we do not
                // currently hold the NC above it (or no such NC exists).

                // So, we need to create a placeholder to which we can add a
                // repsFrom value.  Note that we don't create an uninstantiated
                // NC, as that would preclude clients (KCC, repadmin, etc.) from
                // reading its repsFrom values.  We instead create a temporary
                // but instantiated NC head that will be replaced once we get
                // our first packet from the source DSA.
                Assert(!fNullUuid(&pNC->Guid));
                it |= IT_NC_COMING;
                AddPlaceholderNC(pDB, pNC, it);

                if (0 != pTHS->errCode) {
                    ret = RepErrorFromPTHS(pTHS);
                    DRA_EXCEPT(ret, 0);
                }
            }
            else {
                // We already have an instantiated NC to which to add a
                // repsFrom value.
                Assert(0 == dbFindErr);
                Assert(!(IT_UNINSTANT & it));
            }

            // We have an instantiated NC to which to add our new repsFrom.
            Assert(!(it & IT_UNINSTANT));
            Assert(!(it & IT_WRITE) == !(ulOptions & DRS_WRIT_REP));

            // This is for the asynchronous, mail-based case
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_NEW_REPLICA_FULL_SYNC,
                     szInsertWC(pNC->StringName),
                     szInsertSz(pmtx_addr->mtx_name),
                     szInsertHex(ulOptions));

            // Add a repsFrom for this source.
            ret = UpdateRepsFromRef(pTHS,
                                    DRS_UPDATE_ALL,
                                    pNC,
                                    DRS_FIND_DSA_BY_ADDRESS,
                                    URFR_NEED_NOT_ALREADY_EXIST,
                                    &uuidDsaObj,
                                    &gNullUuid,
                                    &gusnvecFromScratch,
                                    &uuidTransportObj,
                                    pmtx_addr,
                                    ulOptions & RFR_FLAGS,
                                    preptimesSync,
                                    DRAERR_Success,
                                    NULL);
            if (ret) {
                DRA_EXCEPT(ret, 0);
            }
        }
        else {
            // Replicate some or all of the NC contents now.  If the caller
            // asked for DRS_ASYNC_REP, we will replicate only the NC head now
            // (to verify connectivity and security).  Otherwise we will
            // attempt to replicate the whole NC.

            if (ulOptions & DRS_MAIL_REP) {
                // Mail-based replicas must be added asynchronously.
                DRA_EXCEPT(DRAERR_InvalidParameter, 0);
            }  

            // validate source name (fq dns name)
            VALIDATE_RAISE_FQ_DOT_DNS_NAME_UTF8( pmtx_addr->mtx_name );

            // New source we haven't completed a sync from yet.
            ulOptions |= DRS_NEVER_SYNCED;

            // RPC case, either synchronous or ASYNC_REP
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_NEW_REPLICA_FULL_SYNC,
                     szInsertWC(pNC->StringName),
                     szInsertSz(pmtx_addr->mtx_name),
                     szInsertHex(ulOptions));

            // Replicate the NC from the source DSA.
            ret = ReplicateNC(pTHS,
                              pNC,
                              pmtx_addr,
                              pszSourceDsaDnsDomainName,
                              &gusnvecFromScratch,
                              ulOptions & REPADD_REPLICATE_FLAGS,
                              preptimesSync,
                              &uuidDsaObj,
                              NULL,
                              &ulSyncFailure,
                              TRUE,                 // New replica
                              pUpToDateVec,
                              pPartialAttrVec,      // GC: get pas based on schema cache
                              NULL,                 // GC: no extended PAS attrs
                              0,                    // No dynamic sync options
                              NULL );
            if (ret) {
                // If encountered error, (sync failure not included) fail
                // whole thing.

                // Note:- In this case, if we got DRAERR_SchemaMismatch, it
                // doesn't make sense to queue a schema sync and requeue the
                // request as DRA_ReplicaAdd() is synchronous.  When
                // DRS_ASYNC_REP is not set, DRA_ReplicaAdd() needs to tell if
                // it added the replica successfully or not to the caller, and
                // so we can't be doing an async handling for
                // DRAERR_SchemaMismatch.

                DRA_EXCEPT(ret, 0);
            }
        }

        Assert(!ret);
        if (!(ulOptions & DRS_WRIT_REP)
            && ((0 != dbFindErr) || (IT_UNINSTANT & it))) {
            // We have just added the first repsFrom for a read-only replica.
            // Write the partial attribute set to the NC head so that it can
            // keep track of partial set changes in the future.
            // ulSyncFailure may or may not imply a failure to create the NC
            // head.  If ReplicaAdd is going to succeed, we must try to add
            // the partial attribute set.
            GC_WritePartialAttributeSet(pNC, pPartialAttrVec);
        }
    }
    __finally {
        // If we had success, commit, else rollback
        EndDraTransaction(!(ret || AbnormalTermination()));

        // Can now free the schema cache we got the partial attr vec from if
        // it is obsolete.
        if (NULL != pSchema) {
            InterlockedDecrement(&pSchema->RefCount);
        }
    }

    // If not a mail-based replica, add the reps-to
    // Note we do this outside of the transaction
    if (!((ulOptions & DRS_ASYNC_REP) && (ulOptions & DRS_MAIL_REP))
        && !DsaIsInstalling()
        && !(ulOptions & DRS_NEVER_NOTIFY)) {
        // Update references on replica source. This call must be async to
        // avoid possible deadlock if the other DSA is doing the
        // same operation.

        // Note that in the install case this is explicitly done out-of-band
        // by NTDSETUP.

        // Also note that we pair DRS_ADD_REF and DRS_DEL_REF -- this
        // effectively tells the remote DSA to remove any Reps-To values it
        // has matching this UUID and/or network address and add a new one.

        I_DRSUpdateRefs(
            pTHS,
            TransportAddrFromMtxAddrEx(pmtx_addr),
            pNC,
            TransportAddrFromMtxAddrEx(gAnchor.pmtxDSA),
            &gAnchor.pDSADN->Guid,
            (ulOptions & DRS_WRIT_REP) | DRS_ADD_REF | DRS_DEL_REF
                | DRS_ASYNC_OP);
    }

    Assert(!ret);

    //
    // Queue async synchronize if we successfully added an async RPC replica.
    //
    // Exception:
    //   - If notifications are disabled on link (during this add)
    //     then we're either inter-site and/or mail based. Either way
    //     hold off w/ replication until the scheduled one fires.
    //
    if ( (ulOptions & DRS_ASYNC_REP)     &&
         !(ulOptions & DRS_NEVER_NOTIFY) &&
         !(ulOptions & DRS_MAIL_REP) ) {

        ULONG ulNewOptions =
            (ulOptions & AO_PRIORITY_FLAGS) | DRS_ASYNC_OP | DRS_ADD_REF;

        Assert( ulNewOptions & DRS_NEVER_SYNCED );

        DirReplicaSynchronize(pNC, NULL, &uuidDsaObj, ulNewOptions);
    }

    if (puuidDsaObjSrc) {
	memcpy(puuidDsaObjSrc, &uuidDsaObj, sizeof(GUID));
    }

    // If we had a sync failure but were otherwise successful,
    // return sync failure.
    Assert(!ret);
    if (ulSyncFailure) {
        ret = ulSyncFailure;
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drameta.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drameta.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines all per-property meta-data parsing,
    and updating functions.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support
#include <limits.h>

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include "dsutil.h"        // DSTIMEtoDisplayString

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAMETA:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drametap.h"
#include "drasch.h"
#include "drancrep.h"

#include <fileno.h>
#define  FILENO FILENO_DRAMETA

// The number of entries we grow the meta data vector by on each
// (re-)allocation.
#define MDV_ENTRIES_TO_GROW     ( 20 )

#define ReplIsReqAttr(attrtyp) (    (ATT_INSTANCE_TYPE == (attrtyp)) \
                                 || (ATT_PROXIED_OBJECT_NAME == (attrtyp)) )
#define g_cReqAttr (2)

//
// Forward declarations
//
BOOL
ReplIsNonShippedAttr(
    THSTATE *pTHS,
    ATTRTYP rdnType,
    ATTRTYP attrtyp
    );


BOOL
ReplValueIsChangeNeeded(
    IN USN usnPropWaterMark,
    IN UPTODATE_VECTOR *pUpTodateVecDest,
    VALUE_META_DATA *pValueMetaData
    )

/*++

Routine Description:

    Test whether a given value is needed at the destination according to the
    incoming USN, Up-To-Dateness Vector, and local metadata.

Arguments:

    usnPropWaterMark - dest's directly up to date usn
    pUpTodateVecDest - dest's UTD vector
    pValueMetaData - value metadata to check

Return Value:

    BOOL -

--*/

{
    if ( (usnPropWaterMark >= pValueMetaData->MetaData.usnProperty) ||
         (!UpToDateVec_IsChangeNeeded(pUpTodateVecDest,
                                      &pValueMetaData->MetaData.uuidDsaOriginating,
                                      pValueMetaData->MetaData.usnOriginating)) ) {
        // Log that change is not needed
        return FALSE;
    } else {
        // Log that change is needed
        return TRUE;
    }
} /* ReplValueIsChangeNeeded */


BOOL
ReplFilterGCAttr(
    IN  ATTRTYP                     attid,             
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrVec,   
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,            
    IN  BOOL                        fFilterGroupMember,
    OUT BOOL *                      pfIgnoreWatermarks 
    )
/*++

Routine Description:

    Global Catalog attribute filtering:
      - Should the attribute should be filtered?
      - Or should just the watermarks be reset for
        further evaluation?

Arguments:

    attid - attribute id to be evaluated
    pPartialAttrVec - generated PAS (base+extended in PAS cycles)
    pMsgIn - input request
    pfIgnoreWatermarks - decision for PAS cycles whether to ignore watermarks


Return Value:

    TRUE - filter it, ie don't include it
    FALSE - don't filter, include it

    pfIgnoreWatermarks is set to TRUE only if attid is in
    the extended set.

Remarks:



--*/
{


    // param sanity
    Assert(pPartialAttrVec &&
           pMsgIn &&
           pfIgnoreWatermarks)

    // default: don't ignore watermarks
    *pfIgnoreWatermarks = FALSE;

    // EITHER not member of set
    if ( !GC_IsMemberOfPartialSet( pPartialAttrVec, attid, NULL)  ||
         // OR explicit request to filter member attr
         (fFilterGroupMember && (ATT_MEMBER == attid)))

    {
        DPRINT1(3, "Filtered property %d due to PAS/group membership condition\n",
                attid);
        return TRUE;
    }

    if (pMsgIn->pPartialAttrSetEx &&
        GC_IsMemberOfPartialSet(
            (PARTIAL_ATTR_VECTOR*)pMsgIn->pPartialAttrSetEx,
            attid,
            NULL)) {
            // PAS replication: Attribute is in the extended set
            //  - zero out usnPropWatermark & UTD.
            Assert(pMsgIn->ulFlags & DRS_SYNC_PAS);
            DPRINT1(3, "Fixed usn & UTD for property %d to zero.\n", attid);
            *pfIgnoreWatermarks = TRUE;
    }

    // don't filter out this property
    return FALSE;
}




/*************************************************************************************
Routine Description:

    This routine parses an array of property meta data of an object and identifies
    all properties that are changed after the given water mark.

Arguments:
    pDSName - DSName of the object (used only for logging)
    rdnType - rdnType for this object
    fIsSubRef - is this object a subref of the NC we're replicating?
    fIsObjCreation - are we replicating the creation of this object?
    usnObjCreate - USN corresponding to the creation of the object
    usnPropWaterMark - USN beyond which we want to identify the changes
    pUpTodateVecDest - points tothe up-to-date vector of the destination DSA
    puuidDsaObjDest - points to the ntdsDsa objectGuid of the destination DSA
                        (used only for logging)
    pMetaData - points to the property meta-data of the object
    pAttrBlock - points to the ATTRBLOCK structure that would receive the list of
                    attributes to be shipped
    fFilterGroupMember - tells if the group member property should be explicitly
                            filtered
    pMsgIn - replication message for additional processing info

Return Value:

    None.  Throws appropriate exception on error.
**************************************************************************************/
void
ReplFilterPropsToShip(
    IN  THSTATE *                   pTHS,              
    IN  DSNAME *                    pDSName,           
    IN  ATTRTYP                     rdnType,
    IN  BOOL                        fIsSubRef,          
    IN  USN                         usnPropWaterMark,   
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrVec,   
    IN  PROPERTY_META_DATA_VECTOR * pMetaData,         
    OUT ATTRBLOCK *                 pAttrBlock,        
    IN  BOOL                        fFilterGroupMember, 
    IN  DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn
    )
{
    ULONG           i;
    BOOL            fShip = FALSE;
    BOOL            fShipEval;      // temp to simplify alg readability
    BOOL            fIgnoreWatermarks = FALSE;
    UUID            *puuidDsaObjDest = &pMsgIn->uuidDsaObjDest;

    if (!pDSName || !puuidDsaObjDest || !pMetaData || !pAttrBlock)
    {
        DRA_EXCEPT( DRAERR_InvalidParameter, 0 );
    }

    VALIDATE_META_DATA_VECTOR_VERSION(pMetaData);

    // The pAttr array of pAttrBlock is used by ReplPrepareDataToShip() as part
    // of ENTINFSEL structure we use as an output buffer, so we can't reuse any
    // pre-existing allocation.
    pAttrBlock->pAttr = THAllocEx(pTHS, pMetaData->V1.cNumProps * sizeof(ATTR));
    pAttrBlock->attrCount = 0;

    // for each entry of the meta data determine if the corresponding property
    // needs to be shipped
    for (i = 0; i < pMetaData->V1.cNumProps; i++)
    {
        // Property need not be shipped if any of the following conditions are met:
        // a) a partial set is specified and it is not one of the attributes in the
        //    partial set or it is group member attribute to be filtered
        // b) property changed prior  to prop water mark mentioned by the
        //    destination,
        // c) the property chage is already seen by the destination, or
        // d) it is one of the non-shipped attributes.
        // e) Partial Attr Set replication evaluation (see details below)
        //

        // Assume we ship this property-- Then negate as we find reasons not to.
        fShipEval = TRUE;


        // partial attr vector test
        // this vector can be the combined base+extended PAS vectors in PAS cycles
        if ( pPartialAttrVec )
        {
            fShipEval = !ReplFilterGCAttr(
                            pMetaData->V1.rgMetaData[i].attrType,
                            pPartialAttrVec,
                            pMsgIn,
                            fFilterGroupMember,
                            &fIgnoreWatermarks);

        }

        if ( fShipEval && !fIgnoreWatermarks &&
             (usnPropWaterMark >= pMetaData->V1.rgMetaData[i].usnProperty ||
              ReplIsNonShippedAttr(pTHS, rdnType, pMetaData->V1.rgMetaData[i]. attrType) ||
              !UpToDateVec_IsChangeNeeded(
                    pMsgIn->pUpToDateVecDest,
                    &pMetaData->V1.rgMetaData[i].uuidDsaOriginating,
                    pMetaData->V1.rgMetaData[i].usnOriginating) ) )

        {
            DPRINT1(3, "Filtered property %d due to watermark/UTD/schema condition\n",
                    pMetaData->V1.rgMetaData[i].attrType);
            fShipEval = FALSE;
        }


        if ( !fShipEval )
        {
            //
            // We're not shipping this attribute unless it is required
            //

            if (ReplIsReqAttr(pMetaData->V1.rgMetaData[i].attrType))
            {
                // This property doesn't have any new change, but still we will
                // have to ship this property as it is a required property
                pAttrBlock->pAttr[pAttrBlock->attrCount++].attrTyp = pMetaData->V1.rgMetaData[i].attrType;
            }
            else
            {
                CHAR  buf[150];

                LogEvent8(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_VERBOSE,
                          DIRLOG_DRA_PROPERTY_FILTERED,
                          szInsertAttrType(pMetaData->V1.rgMetaData[i].attrType,buf),
                          szInsertDN(pDSName),
                          szInsertUUID(&pDSName->Guid),
                          szInsertUUID(puuidDsaObjDest),
                          NULL, NULL, NULL, NULL);
                continue;
            }
        }
        else
        {
            CHAR  buf[150];

            // we are shipping this property because the destination hasn't seen it
            fShip = TRUE;

            // This property should be shipped - add it to the ATTRBLOCK
            pAttrBlock->pAttr[pAttrBlock->attrCount++].attrTyp = pMetaData->V1.rgMetaData[i].attrType;

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_NOT_FILTERED,
                      szInsertAttrType(pMetaData->V1.rgMetaData[i].attrType,buf),
                      szInsertDN(pDSName),
                      szInsertUUID(&pDSName->Guid),
                      szInsertUUID(puuidDsaObjDest),
                      NULL, NULL, NULL, NULL);
        }

    }

    // Note that if a subref is found by our USN search we will always
    // send its required attributes, even if no other attributes need to be
    // shipped.  This is to ensure that the SUBREF object is shipped to the
    // target DSA, even if that DSA is the one that sent it to use in the first
    // place.  This is required such that the target DSA can properly set the
    // Instance-Type of the object to include IT_NC_ABOVE (and properly modify
    // its NCDNT).
    //
    // To illustrate:
    //
    // Consider an enterprise composed of machines A and B, each in a seperate
    // domain.  A holds the parent domain; B, the child domain.  Initially,
    // replication has quiesced and neither machine is a GC.  This implies
    // the NC head for B's domain on B has an Instance-Type that does _not_
    // include IT_NC_ABOVE, as it does not hold a copy of domain A.  This
    // also implies that A has a SUBREF for B's domain.
    //
    // A is promoted to be a GC.  It replaces its SUBREF for B's domain with
    // the real NC head for B.
    //
    // B is then promoted to be a GC.  In doing so, it requests changes for
    // A's domain from A.  Since A got the NC_FULL_REPLICA_SUBREF for B's
    // domain from B, propagation dampening filters it out and it never gets
    // to B.  Thus, B never "realizes" the head of it own domain NC should
    // have the IT_NC_ABOVE bit set, as it never sees the object replicated
    // from A's domain corresponding to it.  (This logic to change the
    // Instance-Type on child NC heads when replicated a corresponding
    // SUBREF exists in UpdateRepObj().)
    //
    // Thus, we always send at least a minimal SUBREF if we're replicating its
    // creation.

    if (!fShip && !fIsSubRef)
    {
        // no property needs to be shipped, attrCount might still be non-zero due to the
        // addition of required attributes in the loop. But require attributes need to be
        // shipped only if there is at least one genuinely modified attribute exists.
        THFreeEx(pTHS, pAttrBlock->pAttr);
        pAttrBlock->attrCount = 0;
        pAttrBlock->pAttr = NULL;

        PERFINC(pcDRAOutObjsFiltered);
    }
    else
    {
        Assert(pAttrBlock->attrCount > 0);

        if (pAttrBlock->attrCount != pMetaData->V1.cNumProps) {
            // We're not shipping the whole object, so free the portion of the
            // ATTRBLOCK we're not using.
            pAttrBlock->pAttr = THReAllocEx(pTHS, pAttrBlock->pAttr,
                                            pAttrBlock->attrCount * sizeof(ATTR));
        }

        PERFINC(pcDRAObjShipped);

        IADJUST(pcDRAPropShipped, ((LONG) pAttrBlock->attrCount));
    }
}


/*************************************************************************************
Routine Description:
    Decides whether or not an attribute type is not to be shipped during replication

Arguments:
    attrType - the attribute type to check.

Return Value:
    TRUE if the attribute is Not to be shipped, false otherwise.
**************************************************************************************/
BOOL
ReplIsNonShippedAttr(THSTATE *pTHS,
                     ATTRTYP rdnType,
                     ATTRTYP attrtyp)
{
    ATTCACHE *pAC = NULL;

    pAC = SCGetAttById(pTHS, attrtyp);
    if (NULL == pAC)
    {
        DRA_EXCEPT(DRAERR_SchemaMismatch, attrtyp);
    }

    if (pAC->bIsNotReplicated) {
        return TRUE;
    }

    // RDN att should not be shipped
    // A superceding class may have an rdnattid that is different
    // from the object's rdnType. Use the rdnType from the object
    // and not the rdnattid from the class. 
    if ( rdnType == attrtyp ) {
        return TRUE;
    }

    // Some useful LVR debugging output
#if DBG
    if ( (pAC->ulLinkID) && (pTHS->fLinkedValueReplication) ) {
        DPRINT2( 1, "Source returning a legacy attribute change for object %s attribute %s\n",
                 GetExtDN( pTHS, pTHS->pDB), pAC->name );
    }
#endif

    // Attribute will be shipped
    return FALSE;
}

/*************************************************************************************
Routine Description:

    This routine creates a new unique RDN Attr using the given RDN and suffixing it
    with the string form of the given GUID. If the length of given RDN is too long
    to suffix a GUID the given RDN is truncated so that the new length doesn't exceed
    MAX_RDN_SIZE.

Arguments:
    pTHS - local thread state.
    pAttrRDN - pointer to the RDN Attr.
    pGuid - pointer to the object Guid

Return Value:
    None.
**************************************************************************************/
void
ReplMorphRDN(
    IN      THSTATE *   pTHS,
    IN OUT  ATTR *      pAttrRDN,
    IN      GUID *      pGuid
    )
{
    BYTE *    pbOldRDN;
    DWORD     cchRDN;

    if ( pAttrRDN->AttrVal.pAVal->valLen > (sizeof(WCHAR)*MAX_RDN_SIZE) ) {
        DRA_EXCEPT(DRAERR_InternalError, pAttrRDN->AttrVal.pAVal->valLen);
    }

    pbOldRDN = pAttrRDN->AttrVal.pAVal->pVal;

    // Make sure we have enough room to store the largest RDN we could
    // construct.  Note that we throw away the old allocation; we don't know
    // for sure that it was thread-allocated.  (It might be in an RPC buffer.)
    pAttrRDN->AttrVal.pAVal->pVal = THAllocEx(pTHS, sizeof(WCHAR)*MAX_RDN_SIZE);

    memcpy(pAttrRDN->AttrVal.pAVal->pVal,
           pbOldRDN,
           pAttrRDN->AttrVal.pAVal->valLen);

    cchRDN = pAttrRDN->AttrVal.pAVal->valLen / sizeof(WCHAR);

    MangleRDN(MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
              pGuid,
              (WCHAR *) pAttrRDN->AttrVal.pAVal->pVal,
              &cchRDN);

    pAttrRDN->AttrVal.pAVal->valLen = cchRDN * sizeof(WCHAR);
}


PROPERTY_META_DATA *
ReplLookupMetaData(
    IN  ATTRTYP                     attrtyp,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVec,
    OUT DWORD *                     piProp          OPTIONAL
    )
/*++

Routine Description:

    Find the meta data for the given attribute in the meta data vector.
    Optionally returns the index at which the entry was found, or, if the
    corresponding meta data is absent, the index at which the entry would be
    inserted to preserve the sort order.

Arguments:

    attrtyp - Attribute to search for.
    pMetaDataVec - Meta data vector to search.
    piProp (OUT) - If non-NULL, on return holds the index at which the meta data
        was found in the vector or, if absent, the index at which meta data for
        this attribute would be inserted to preserve the sort order.

Return Values:

    NULL - No pre-existing meta data for this attribute was found in the vector.
    non-NULL - A pointer to the pre-existing meta data for this attribute.

--*/
{
    BOOL        fFound;
    LONG        iPropBegin;
    LONG        iPropEnd;
    LONG        iPropCurrent;
    int         nDiff;

#if DBG
    ATTCACHE *  pAC;

    // We shouldn't be looking for meta data for non-replicated attributes.
    pAC = SCGetAttById(pTHStls, attrtyp);
    Assert((NULL != pAC) && !pAC->bIsNotReplicated);
#endif

    fFound = FALSE;
    iPropCurrent = 0;

    if ( NULL != pMetaDataVec )
    {
        iPropBegin = 0;
        iPropEnd   = pMetaDataVec->V1.cNumProps - 1;

        // Find meta data entry corresponding to the given attribute.
        while ( !fFound && ( iPropEnd >= iPropBegin ) )
        {
            iPropCurrent = ( iPropBegin + iPropEnd ) / 2;

            nDiff = CompareAttrtyp(&attrtyp, &pMetaDataVec->V1.rgMetaData[ iPropCurrent ].attrType);

            if ( nDiff < 0 )
            {
                if ( iPropEnd != iPropBegin )
                {
                    // Further narrow search.
                    iPropEnd = iPropCurrent - 1;
                }
                else
                {
                    // Entry not found; it should be inserted before this entry.
                    break;
                }
            }
            else if ( nDiff > 0 )
            {
                if ( iPropEnd != iPropBegin )
                {
                    // Further narrow search.
                    iPropBegin = iPropCurrent + 1;
                }
                else
                {
                    // Entry not found; it should be inserted after this entry.
                    iPropCurrent++;
                    break;
                }
            }
            else
            {
                // Found it.
                fFound = TRUE;
            }
        }
    }

    if ( NULL != piProp )
    {
        *piProp = iPropCurrent;
    }

    return fFound ? &pMetaDataVec->V1.rgMetaData[ iPropCurrent ] : NULL;
}

PROPERTY_META_DATA *
ReplInsertMetaData(
    IN      THSTATE                       * pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced,
    OUT     BOOL *                          pfIsNewElement          OPTIONAL
    )
/*++

Routine Description:

    Returns a pointer to the pre-existing meta data for the given attribute in
    the vector, or, if none exists, inserts new meta data in the vector for this
    attribute.

    If an entry is inserted, its elements will be nulled with the exception of
    the attribute type, which will be set to that passed as an argument.

Arguments:

    attrtyp (IN) - Attribute for which meta data is to be found or inserted.
    ppMetaDataVec (IN/OUT) - The current meta data vector.
    pcbMetaDataVecAlloced (IN/OUT) - The allocated size of the meta data vector.
    pfIsNewElement (OUT) - If present, holds TRUE if the returned meta data
        was inserted, or FALSE if meta data was already present.

Return Values:

    Pointer to the meta data for the given attribute.  (Never NULL.)

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   iProp;

    pMetaData = ReplLookupMetaData( attrtyp, *ppMetaDataVec, &iProp );

    if ( NULL != pfIsNewElement )
    {
        *pfIsNewElement = ( NULL == pMetaData );
    }

    if ( NULL == pMetaData )
    {
        // No pre-existing meta data found for this attribute.

        // We need to expand the vector and insert a new entry for this
        // attribute.

        // Is there enough memory allocated for the vector to grow an entry
        // in-place?
        if (    ( NULL == *ppMetaDataVec )
             || (   *pcbMetaDataVecAlloced
                  < MetaDataVecV1SizeFromLen( (*ppMetaDataVec)->V1.cNumProps + 1 )
                )
           )
        {
            // No, we must (re-)allocate memory for the vector.

            // Allocate more than we need right now to cut down on the number of
            // reallocations we'll potentially have to do later.

            DWORD cbNewSize;

            if ( NULL == *ppMetaDataVec )
            {
                // Allocate new vector.
                Assert( 0 == *pcbMetaDataVecAlloced );

                cbNewSize = MetaDataVecV1SizeFromLen( MDV_ENTRIES_TO_GROW );
                *ppMetaDataVec = THAllocEx(pTHS,  cbNewSize );

                (*ppMetaDataVec)->dwVersion = VERSION_V1;
                (*ppMetaDataVec)->V1.cNumProps = 0;

            }
            else
            {
                // Reallocate pre-existing vector.
                Assert( 0 != *pcbMetaDataVecAlloced );

                cbNewSize = MetaDataVecV1SizeFromLen(
                                (*ppMetaDataVec)->V1.cNumProps
                                    + MDV_ENTRIES_TO_GROW
                                );
                *ppMetaDataVec = THReAllocEx(pTHS, *ppMetaDataVec, cbNewSize );
            }

            *pcbMetaDataVecAlloced = cbNewSize;
        }

        pMetaData = &(*ppMetaDataVec)->V1.rgMetaData[ iProp ];

        // Shift up all entries after the index at which we're inserting.
        MoveMemory( pMetaData + 1,
                    pMetaData,
                    (   sizeof( PROPERTY_META_DATA )
                      * ( (*ppMetaDataVec)->V1.cNumProps - iProp ) ) );
        (*ppMetaDataVec)->V1.cNumProps++;

        // Initialize meta data for new attribute.
        memset( pMetaData, 0, sizeof( *pMetaData ) );
        pMetaData->attrType = attrtyp;
    }

    Assert( NULL != pMetaData );

// Check for metadata corruption
// These checks are looser than the corresponding checks in dbmeta.c: these checks
// occur before the meta data vector is completely filled in.
#if DBG
    {
        USN localHighestUsn = gusnEC;

        for( iProp = 0; iProp < (*ppMetaDataVec)->V1.cNumProps; iProp++ ) {
            PROPERTY_META_DATA *pTestMetaData =
                &((*ppMetaDataVec)->V1.rgMetaData[ iProp ]);
            if ((pTestMetaData->usnProperty == USN_PROPERTY_TOUCHED) || (pTestMetaData->usnProperty == USN_PROPERTY_GCREMOVED))
            {
                // Contents indeterminate, will be rewritten
                continue;
            }
            if ( (pTestMetaData == pMetaData) && (pTestMetaData->usnProperty == 0) )
            {
                // New record, initialized to zero
                continue;
            }
            // Should be properly constructed
            // For a replicated write, usnProperty is zero until flush-time
            Assert( (pTestMetaData->usnProperty >= 0) &&
                    (pTestMetaData->usnProperty < localHighestUsn) );
            // Assert( pTestMetaData->dwVersion ); // fails for underriden metadata
            Assert( pTestMetaData->timeChanged );

            Assert( pTestMetaData->usnOriginating );
        }
    }
#endif

    return pMetaData;
}

void
ReplOverrideMetaData(
    IN      ATTRTYP                     attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVec
    )
/*++

Routine Description:

    Override the meta data assoicated with the given attribute such that it is
    marked as an originating write on the local machine that will win
    reconciliation over the current meta data.

Arguments:

    attrtyp (IN) - Attribute for which to override meta data.

    pMetaDataVec (IN/OUT) - Vector containing the meta data to override.

Return Values:

    None.  Generates DRA exception if no meta data for the attribute currently
    exists.

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   iProp;

    // Find the meta data for this attribute.
    pMetaData = ReplLookupMetaData(attrtyp, pMetaDataVec, &iProp);

    if (NULL != pMetaData) {
        // Meta data is present for this attribute.  Flag it so we'll know to
        // override it in dbFlushMetaDataVector().
        pMetaData->usnProperty = USN_PROPERTY_TOUCHED;
    }
    else {
        DRA_EXCEPT(DRAERR_InternalError, (UINT_PTR) pMetaDataVec);
    }
}


void
ReplUnderrideMetaData(
    IN      THSTATE *                     pTHS,
    IN      ATTRTYP                       attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **  ppMetaDataVec,
    IN OUT  DWORD *                       pcbMetaDataVecAlloced    OPTIONAL
    )
/*++

Routine Description:

    Underride the meta data assoicated with the given attribute such that it
    will always lose when compared against a "real" change to the attribute.

Arguments:

    pTHS (IN)

    attrtyp (IN) - Attribute for which to override meta data.

    ppMetaDataVec (IN/OUT) - Vector containing the meta data to underride.

    pcbMetaDataVecAlloced (IN/OUT, OPTIONAL) - Size in bytes of the buffer
        allocated for *ppMetaDataVec.

Return Values:

    None.

--*/
{
    PROPERTY_META_DATA *    pMetaData;
    DWORD                   cbMetaDataVecAlloced = 0;

    if (NULL == pcbMetaDataVecAlloced) {
        // No buffer size specified.  Assume the buffer is just large enough to
        // hold the vector.
        cbMetaDataVecAlloced = *ppMetaDataVec
                                    ? (DWORD)MetaDataVecV1Size(*ppMetaDataVec)
                                    : 0;
        pcbMetaDataVecAlloced = &cbMetaDataVecAlloced;
    }

    // Find/insert the meta data for this attribute.
    pMetaData = ReplInsertMetaData(pTHS,
                                   attrtyp,
                                   ppMetaDataVec,
                                   pcbMetaDataVecAlloced,
                                   NULL);

    // Flag the meta data such that when we get ready to commit the change
    // we'll know what to do.  (See dbFlushMetaDataVector().)
    pMetaData->usnProperty = USN_PROPERTY_TOUCHED;
    pMetaData->dwVersion   = ULONG_MAX;
}


void
ReplPrepareDataToShip(
    IN      THSTATE                   * pTHS,
    IN      ENTINFSEL *                 pSel,
    IN      PROPERTY_META_DATA_VECTOR * pMetaDataVec,
    IN OUT  REPLENTINFLIST *            pList
    )
/*++

Routine Description:

    Given the attributes we decided should be shipped for an object, their
    corresponding meta data, and the values actually present on that object,
    construct the appropriate information to put on the wire such that these
    changes can be applied on a remote DSA.

Arguments:

    pSel (IN) - The subset of attributes we previously decided (in
        ReplFilterPropsToShip()) should be shipped to the remote DSA.
    pMetaDataVec (IN) - The complete meta data vector for this object.
    pList (IN/OUT) - The data to be put on the wire.  On entry should contain
        the appropriate value for fIsNCPrefix and the Entinf read from the
        local object.

Return Values:

    None.

--*/
{
    PROPERTY_META_DATA *        pMetaData;
    PROPERTY_META_DATA_EXT *    pMetaDataExt;
    ATTR *                      pAttrRead;
    ATTR *                      pAttrOut;
    DWORD                       cNumAttrsReadRemaining;
    DWORD                       iAttr;
    BOOL                        fIncludeParentGuid;
    DWORD                       cNumValues = 0;
    DWORD                       cNumDNValues = 0;
    ATTCACHE *                  pAC;

    // The entries in ENTINFSEL and the ENTINF are each sorted by attrtyp.

    // (This is because we build the ENTINFSEL entry by entry from the meta data
    // vector, which we maintain as sorted, and any attributes that occur in the
    // ENTINF should occur in the same order as they were in the ENTINFSEL
    // (though some attributes in the ENTINFSEL may be absent from the ENTINF).)

#if DBG
    pAttrOut = &pSel->AttrTypBlock.pAttr[ 0 ];
    for ( iAttr = 1; iAttr < pSel->AttrTypBlock.attrCount; iAttr++ )
    {
        Assert( pAttrOut->attrTyp < (pAttrOut + 1)->attrTyp );
        pAttrOut++;
    }

    pAttrOut = &pList->Entinf.AttrBlock.pAttr[ 0 ];
    for ( iAttr = 1; iAttr < pList->Entinf.AttrBlock.attrCount; iAttr++ )
    {
        Assert( pAttrOut->attrTyp < (pAttrOut + 1)->attrTyp );
        pAttrOut++;
    }
#endif

    // The meta data vector contains an entry for all replicable attributes.
    // The ENTINFSEL contains a subset of these attributes, specifically only
    // those attributes that replication deemed should be shipped to this
    // receiver.  The ENTINF, in turn, contains a subset of the attributes in
    // the ENTINFSEL, lacking any attributes from the ENTINFSEL that are not
    // currently present on the object (but once were).

    VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVec);
    Assert( 0 != pMetaDataVec->V1.cNumProps );
    Assert( pSel->AttrTypBlock.attrCount <= pMetaDataVec->V1.cNumProps );
    Assert( pList->Entinf.AttrBlock.attrCount <= pSel->AttrTypBlock.attrCount );

    // Allocate a wire-format meta data vector for this object.
    pList->pMetaDataExt = THAllocEx(pTHS,
                                MetaDataExtVecSizeFromLen(
                                    pSel->AttrTypBlock.attrCount
                                    )
                                );
    pList->pMetaDataExt->cNumProps = pSel->AttrTypBlock.attrCount;

    // Cue up the local meta data (which spans all local attributes) and the
    // on-the-wire meta data (which spans only those attributes we're going to
    // ship).
    pMetaData = &pMetaDataVec->V1.rgMetaData[ 0 ];
    pMetaDataExt = &pList->pMetaDataExt->rgMetaData[ 0 ];

    // Cue up the attributes we read (which excludes those we have deleted).
    cNumAttrsReadRemaining = pList->Entinf.AttrBlock.attrCount;
    pAttrRead = cNumAttrsReadRemaining
                    ? &pList->Entinf.AttrBlock.pAttr[ 0 ]
                    : NULL;

    // Cue up the attribute output list.  Note that we reuse the list from the
    // ENTINFSEL, filling in attribute values that we read as appropriate.
    pList->Entinf.AttrBlock = pSel->AttrTypBlock;
    pAttrOut = &pList->Entinf.AttrBlock.pAttr[ 0 ];

    // Default to not putting the GUID of the parent of this object on the wire.
    // We only need to do so if this is a rename or creation (indicated by the
    // presence of ATT_RDN amongst the attributes to be shipped) and this is not
    // the head of the NC we're replicating.
    fIncludeParentGuid = FALSE;

    // For each attribute we previously decided should be shipped...
    // (as reflected by the fact that it occurs in the ENTINFSEL)
    for ( iAttr = 0; iAttr < pList->Entinf.AttrBlock.attrCount; iAttr++ )
    {
        // Do we need to put the parent object's GUID on the wire?
        if ( ( ATT_RDN == pAttrOut->attrTyp ) && !pList->fIsNCPrefix )
        {
            fIncludeParentGuid = TRUE;
        }

        // Move to the meta data for this attribute (skipping over meta data for
        // attributes we're not going to ship).
        while ( pMetaData->attrType < pAttrOut->attrTyp )
        {
            pMetaData++;
        }
        Assert( pMetaData->attrType == pAttrOut->attrTyp );

        if (    ( NULL != pAttrRead )
             && ( pAttrOut->attrTyp == pAttrRead->attrTyp )
           )
        {
            // This attribute currently has values locally.  Put the values
            // we read onto the wire.
            pAttrOut->AttrVal = pAttrRead->AttrVal;
            pAttrRead = --cNumAttrsReadRemaining ? pAttrRead+1 : NULL;

            pAC = SCGetAttById(pTHS, pAttrOut->attrTyp);
            Assert((NULL != pAC) && "GetEntInf() found it, but we can't!");

            if (IS_DN_VALUED_ATTR(pAC)) {
                cNumDNValues += pAttrOut->AttrVal.valCount;
            }

            cNumValues += pAttrOut->AttrVal.valCount;
        }
        else
        {
            // This attribute currently has no values locally; i.e., all
            // previous values have been deleted.  Put "no value" onto the
            // wire (which will later be interpreted by ModifyLocalObj() as
            // an attribute deletion).
            Assert( 0 == pAttrOut->AttrVal.valCount );
            Assert( NULL == pAttrOut->AttrVal.pAVal );
        }

        // Put the meta data for this attribute onto the wire, too.
        pMetaDataExt->dwVersion          = pMetaData->dwVersion;
        pMetaDataExt->timeChanged        = pMetaData->timeChanged;
        pMetaDataExt->uuidDsaOriginating = pMetaData->uuidDsaOriginating;
        pMetaDataExt->usnOriginating     = pMetaData->usnOriginating;

        // Nnnnext!
        pAttrOut++;
        pMetaDataExt++;
        pMetaData++;
    }

    // We should have put all the attributes we read onto the wire.
    Assert( NULL == pAttrRead );

    // There should be a one-to-one correspondence between meta data and
    // attribute values.
    Assert(    pList->Entinf.AttrBlock.attrCount
            == pList->pMetaDataExt->cNumProps
          );

    // Include parent GUID if necessary.
    if ( fIncludeParentGuid )
    {
        DSNAME * pdnParent = (DSNAME *) THAllocEx(pTHS, pList->Entinf.pName->structLen );
        ULONG    err;

        Assert( !pList->fIsNCPrefix );

        // Since this is not the prefix of the NC, the parent must be
        // instantiated locally.

        err = TrimDSNameBy( pList->Entinf.pName, 1, pdnParent );
        Assert( 0 == err );

        err = FillGuidAndSid( pdnParent );
        if (err) {
            if (err == DIRERR_NOT_AN_OBJECT) {
                DRA_EXCEPT(DRAERR_MissingParent, 0);
            } else {
                DRA_EXCEPT(DRAERR_InternalError, err);
            }
        }

        pList->pParentGuid = THAllocEx(pTHS, sizeof( GUID ) );
        *pList->pParentGuid = pdnParent->Guid;

        if(pdnParent != NULL) THFreeEx(pTHS, pdnParent);

    }

    // Update perfmon with outbound value counts.
    IADJUST(pcDRAOutValues, cNumValues);
    IADJUST(pcDRAOutDNValues, cNumDNValues);
}

BOOL
ProperValueForDeletedObject (
                             ATTR * pAttr
    )
/*++
Description:
    Given an attribute from a deleted object, verify that the attribute has the
    expected value.
    Only two attributes have required values when an object is deleted:
        ATT_IS_DELETED - should be true
        ATT_RDN - should be set to invalid value

Arguments:
    pAttr - Attribute

Return Values:
    TRUE - Attribute has expected value
    FALSE - Attribute does not have expected value

--*/
{
    BOOL result = FALSE;

    switch (pAttr->attrTyp) {
    case ATT_RDN:
        if (pAttr->AttrVal.valCount == 1) {
            result = (fVerifyRDN( (WCHAR *)pAttr->AttrVal.pAVal->pVal,
                               pAttr->AttrVal.pAVal->valLen / sizeof( WCHAR) ) ?
                     TRUE : FALSE );
        }
        break;
    default:
        result = TRUE;
        break;
    }

    DPRINT3( 4, "ProperValueForDel: a:%x l:%d result:%d\n",
             pAttr->attrTyp, pAttr->AttrVal.pAVal->valLen, result );
    return result;
} /* ProperValueForDeletedObject */

VOID
FetchLocalValue(
    THSTATE *pTHS,
    ATTR * pAttr
    )
/*++

Routine Description:

    Populate the attribute structure with the local value(s) of the attribute

    It is implicit that the database is positioned on the desired object.

    We use GetEntInf instead of DBGetAttVal so that we can correctly fetch even
    multi-valued attributes and attributes with no value.

Arguments:

    pAttr - Attribute to be updated

Return Values:

    None

--*/
{
    ENTINFSEL sel;
    ATTR      attrSel;
    ENTINF    entinf;
    DWORD     retErr;

    memset(&attrSel, 0, sizeof(attrSel));
    attrSel.attrTyp = pAttr->attrTyp;

    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = EN_ATTSET_LIST_DRA;

    sel.AttrTypBlock.pAttr = &attrSel;
    sel.AttrTypBlock.attrCount = 1;

    // The memory allocated to the structures pointed to by pAttr
    // (which we are orphaning) and the memory for the new value are on the
    // per-transaction heap and will be freed when the call completes
    if (retErr = GetEntInf(pTHS->pDB, &sel, NULL, &entinf, NULL, 0, NULL,
                           GETENTINF_NO_SECURITY,
                           NULL, NULL))
    {
        DRA_EXCEPT(DRAERR_DBError, retErr);
    }

    // we asked for one attribute - so we should get back not more than 1
    Assert(entinf.AttrBlock.attrCount <= 1);

    if (entinf.AttrBlock.attrCount)
    {
        // we did fetch the attr - replace the contents of pAttr with fetched value
        *pAttr = entinf.AttrBlock.pAttr[0];
    }
    else
    {
        // attribute doesn't exist locally - set the attr's valCount to 0 so
        // that ModifyLocalObj will handle it correctly.
        pAttr->AttrVal.valCount = 0;
        pAttr->AttrVal.pAVal = NULL;
    }
}

void
OverrideWithLocalValue(
    THSTATE *pTHS,
    ATTR *pAttr,
    PROPERTY_META_DATA *pMetaDataRemote,
    DSTIME *pTimeNow,
    USN *pusnLocal)
/*++

Description:

    This routing takes overrides the value in attr with the local value, and
    updates the pMetaDataRemote to reflect the override.

Arguments:

    pAttr - Attribute being checked

    pMetaDataRemote - meta data entry constructed in the remote vector for this
        attribute (modified by this function to reflect the local override)

    pTimeNow - pointer the a new timestamp (if *pTimeNow is 0, then this call
        would  create new timestamp & usn and return them through pTimeNow and
        pusnLocal pointers)

    pusnLocal - pointer to the new usn

Return Value:

    None.

--*/
{
    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

    // Replace with local value
    FetchLocalValue( pTHS, pAttr );

    // Allocate timestamp and usn once, only when needed
    if (*pTimeNow == 0) {
        *pTimeNow = DBTime();
        *pusnLocal = DBGetNewUsn();
    }

    // Replace metadata with new metadata
    pMetaDataRemote->dwVersion++;
    pMetaDataRemote->timeChanged = *pTimeNow;
    pMetaDataRemote->uuidDsaOriginating = pTHS->InvocationID;
    pMetaDataRemote->usnOriginating = *pusnLocal;
}


void
OverrideValues (
    THSTATE *pTHS,
    DSNAME *pName,
    GUID **ppParentGuid,
    ATTR *pAttr,
    BOOL *pfApplyAttribute,
    BOOL fIsAncestorOfLocalDsa,
    BOOL fLocalObjDeleted,
    BOOL fDeleteLocalObj,
    USHORT RemoteObjDeletion,
    PROPERTY_META_DATA *pMetaDataLocal,
    PROPERTY_META_DATA *pMetaDataRemote,
    DSTIME *pTimeNow,
    USN *pusnLocal
    )
/*++
Description:

 [wlees 98763] Determine if we should override the value of a RDN

 There are two cases for overriding values:

 1. The remote value has won, the local value is already deleted, and the remote update
    is neither a deletion nor a undeletion, and the remote value is not proper for
    a deleted object ==> REJECT THE REMOTE VALUE

    Note: the proper value check is necessary to dampen the subsequent replication
    caused by the override

 2. The local value won, the local value is not deleted, and the remote value is a
    deletion, and the local value is not proper for a deletion ==> REJECT THE LOCAL VALUE

 When we override a value in either case, we must construct new metadata that is
 definitive for the local and remote.

Jeffparh wrote:

An alternative design might be to allow RDN "changes" on deleted objects if and only if
the metadata wins and the inbound "change" is the local value.
If the remote metadata wins and the inbound RDN value is not a proper value for a deleted object,
the DS should update its local meta data to "win" over the inbound change --
i.e., we should flag a local change, with a version number in the metadata that is 1
greater than that in the inbound metadata.  This will cause the override to replicate out
and quiesce even if the override is done by multiple servers.

A proper RDN for a deleted object must be invalid for normal operations -- see fVerifyRDN in
mdadd.c.

Whenever we have an inbound update for an attribute, we have
initial local metadata ML,
inbound metadata MI, and
resultant local metadata ML'.
Associated with each is a set of values -- VL, VI, and VL'.

If we claim to have successfully updated the object, we must have one of the following
conditions to ensure changes replicate out and machines quiesce to the same value/metadata.

Local metadata/value won.  ML >= MI, ML' = ML, VL' = VL.
Remote metadata/value won.  MI > ML, ML' = MI, VL' = VI.
Local metadata won, remote value overrides.  ML' > ML > MI, VL' = VI.
Remote metdata won, local value overrides.  ML' > MI > ML, VL' = VL.

This implies that the metadata we have after applying these changes must always be greater
than or equal to both the local and the inbound metadata; i.e., ML' >= ML, ML' >= MI.

---
JeffParh (99-08-25) re bug 374144 (server object getting moved to Lost&Found):

    There are two cases to be concerned about:
    (1) The move of an ancestor of the local DSA object is originated on a
        remote machine.
    (2) The move of an ancestor of the local DSA object is originated on the
        local machine.

    You can see below how (1) is handled.  (2) is a little more tricky, however.

    First, how does (2) occur?  Consider two DCs -- DC1 and DC2 -- in the
    same domain, and two sites S1 and S2.  Initially both DCs are in S1.  On
    DC1 delete S2 while simultaneously moving DC1 into S2 on DC2.  With
    currently checked in bits, DC1 receives the move of its own server object
    into S2 and, upon finding the new parent object is deleted, moves it into
    LostAndFoundConfig.  I.e., the damage to DC1 has been originated on DC1
    itself!

    Now, how does the fix for (1) also fix (2)?  The move to
    LostAndFoundConfig comes into UpdateRepObj() just like an inbound update.
    I.e., we make one call into UpdateRepObj() and discover the parent is
    missing, re-request the packet asking for parent objects (not terribly
    important to the topic at hand), retry the UpdateRepObj() again failing
    with missing parent (ditto re relevancy), then decide to move to L&F and
    make yet another call to UpdateRepObj() after changing the DN.  Thus our
    originating update to move to L&F comes in to UpdateRepObj() just like a
    replicated-in change -- the only difference is in the fMoveToLostAndFound
    flag (which triggers an originating write to the last known parent
    attribute) and the fact that the meta data dictates this is a local
    change.  Ergo the code for (1) is triggered and all is well.

Arguments:

    pTHS -
    pName - Name of the inbound object.
    ppParentGuid - Holds a pointer to the inbound guid of the parent object on
        the source DSA (for move operations).  Reset to NULL on return if we
        choose to override the move.
    pAttr - Remote attribute being checked
    pfApplyAttribute - Pointer to storage indicating
        Whether the remote value won reconcilliation.  Possibly updated.
    fIsAncestorOfLocalDsa - TRUE iff the object being replicated is a current
        config NC ancestor of (or is) the ntdsDsa object corresponding to the
        local machine.
    FLocalObjDeleted - Local object is already deleted
    fDeleteLocalObj - Local object is not yet deleted, but we will delete it in
        applying this change.
    RemoteObjDeletion - One of: being deleted, deletion being reversed, no deletion status change
    pMetaDataLocal - Current local meta data entry
    pMetaDataRemote - Current newly contructed output meta data entry, possible updated
    pTimeNow - Pointer to storage for new timestamp, if allocated
    pusnLocal - Pointer to storage for new usn, if allocated

Return Values:

--*/
{
    ATTR localAttr;
    ATTRVAL localAttrval;
    CHAR buf[150];

    // Performance note. This path is executed on every attribute we replicate
    // in. Try to defer doing any expensive work until deeper in the if nesting
    // when you know it is needed.

    // The DSA object itself is considered an ancestor for our purposes.
    Assert(fIsAncestorOfLocalDsa || !NameMatched(pName, gAnchor.pDSADN) || DsaIsInstalling());

    if ( (pAttr->attrTyp != ATT_RDN) &&
         !fIsAncestorOfLocalDsa ) {
        return;
    }

    Assert(!(fLocalObjDeleted && fDeleteLocalObj));
    Assert(!fDeleteLocalObj || (OBJECT_BEING_DELETED == RemoteObjDeletion));

    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

    if (*pfApplyAttribute) {

        // Case 1: remote metadata won, local value overrides

        if ( (fLocalObjDeleted) &&
             (RemoteObjDeletion == OBJECT_DELETION_NOT_CHANGED) &&
             (!ProperValueForDeletedObject( pAttr )) ) {
            Assert(!fDeleteLocalObj);

            // Get the local value of the attribute
            localAttr.attrTyp = pAttr->attrTyp;
            localAttr.AttrVal.valCount = 1;
            localAttr.AttrVal.pAVal = &localAttrval;

            FetchLocalValue( pTHS, &localAttr );

            // See if the local attribute is a better choice
            if (ProperValueForDeletedObject( &localAttr )) {
                // Override the attr with local value
                OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote, pTimeNow,
                                       pusnLocal);

                if ( *ppParentGuid ) {
                    // disallow modification of the parent of a locally
                    // deleted object (bugref 105173)
                    *ppParentGuid = NULL;
                }

                DPRINT2( 2, "Override: attr %x remote metadata won, local value overrides, new version = %d\n",
                         pAttr->attrTyp, pMetaDataRemote->dwVersion);
            } else {
                // The local attribute has been corrupted somehow.  The SD prop
                // probably rewrote it wrong. Allow the incoming attribute to win
                // so that we'll converge to something and not have a storm.

                // Note that this should not be necessary, since we no longer
                // have constant SDs for deleted objects, but keeping here as
                // failure detection.
                Assert( !"Local attribute does not have proper value for deleted object.\nCheck event log for details." );
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_VALUE_NOT_PROPER_FOR_DELETED,
                         szInsertDN(pName),
                         szInsertUUID(&(pName->Guid)),
                         szInsertAttrType(pAttr->attrTyp,buf) );
            }
        }

        if (fIsAncestorOfLocalDsa) {
            if (NameMatched(pName, gAnchor.pDSADN)) {
                // An inbound update for our own ntdsDsa object.  We are
                // authoritative for some attributes of our DSA object -- override
                // any inbound updates for those.

                if ((ATT_RDN == pAttr->attrTyp)
                    || (ATT_INVOCATION_ID == pAttr->attrTyp)
                    || (ATT_RETIRED_REPL_DSA_SIGNATURES == pAttr->attrTyp)
                    || (ATT_MS_DS_HAS_INSTANTIATED_NCS == pAttr->attrTyp)
                    || (ATT_MS_DS_BEHAVIOR_VERSION == pAttr->attrTyp)
                    || (ATT_HAS_MASTER_NCS == pAttr->attrTyp) // deprecated "old" hasMasterNCs
                    || (ATT_MS_DS_HAS_MASTER_NCS == pAttr->attrTyp)
                    || (ATT_HAS_PARTIAL_REPLICA_NCS == pAttr->attrTyp)) {
                    DPRINT1(0, "Overriding inbound update to attr 0x%x of our local DSA object.\n",
                            pAttr->attrTyp);
                    OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote,
                                           pTimeNow, pusnLocal);

                    if (ATT_RDN == pAttr->attrTyp) {
                        // If we override the rename, we also override the move.
                        *ppParentGuid = NULL;
                    }
                }
            }
            else if ((ATT_RDN == pAttr->attrTyp)
                     && (NULL != ppParentGuid)) {
                // Is a move of an ancestor of our local ntdsDsa object.
                GUID guidLostAndFound;

                draGetLostAndFoundGuid(pTHS, gAnchor.pConfigDN,
                                       &guidLostAndFound);

                if (0 == memcmp(&guidLostAndFound, *ppParentGuid,
                                sizeof(GUID))) {
                    // Inbound move of an ntdsDsa ancestor to the LostAndFound
                    // container.  Override.

                    DPRINT1(0, "Overriding inbound move of local DSA ancestor %ls to Lost&Found.\n",
                            pName->StringName);

                    OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote,
                                           pTimeNow, pusnLocal);
                    *ppParentGuid = NULL;
                }
            }
        }

    } else {

        // Case 2: local metadata won, remote value overrides

        if (fDeleteLocalObj) {
            // Get the local value of the attribute
            localAttr.attrTyp = pAttr->attrTyp;
            localAttr.AttrVal.valCount = 1;
            localAttr.AttrVal.pAVal = &localAttrval;

            FetchLocalValue( pTHS, &localAttr );

            // Verify that the local value needs to be updated
            if (!ProperValueForDeletedObject( &localAttr )) {

                // Make sure incoming value is right
                if (ProperValueForDeletedObject( pAttr )) {

                    // We will apply the attribute and the remote value is what we want
                    *pfApplyAttribute = TRUE;

                    // Allocate timestamp and usn once, only when needed
                    if (*pTimeNow == 0) {
                        *pTimeNow = DBTime();
                        *pusnLocal = DBGetNewUsn();
                    }

                    // Construct new metadata
                    Assert(pMetaDataRemote->attrType == pAttr->attrTyp);
                    pMetaDataRemote->dwVersion = pMetaDataLocal->dwVersion + 1;
                    pMetaDataRemote->timeChanged = *pTimeNow;
                    pMetaDataRemote->uuidDsaOriginating = pTHS->InvocationID;
                    pMetaDataRemote->usnOriginating = *pusnLocal;

                    DPRINT2( 2, "Override: attr %x local metadata won, remote value overrides, new version = %d\n",
                             pAttr->attrTyp, pMetaDataRemote->dwVersion);
                } else {
                    // The incoming deletion has an improperly valued attribute.
                    // Has pDeletedSD changed in a future version??
                    // Leave the improper local attribute value alone and allow it
                    // to win so that we'll quiece, even though its to different values.

                    // Note that this should not be necessary, since we no
                    // longer have constant SDs for deleted objects, but
                    // keeping here as failure detection.
                    Assert( "Incoming attribute does not have proper value for deleted object" );
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_VALUE_NOT_PROPER_FOR_DELETED,
                             szInsertDN(pName),
                             szInsertUUID(&(pName->Guid)),
                             szInsertAttrType(pAttr->attrTyp,buf) );
                }
            }
        }
    }

} /* OverrideValues */


DWORD
ReplReconcileRemoteMetaDataVec(
    IN      THSTATE *                       pTHS,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecLocal,      OPTIONAL
    IN      BOOL                            fIsAncestorOfLocalDsa,
    IN      BOOL                            fLocalObjDeleted,
    IN      BOOL                            fDeleteLocalObj,
    IN      BOOL                            fBadDelete,
    IN      USHORT                          RemoteObjDeletion,
    IN      ENTINF *                        pent,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecRemote,
    IN OUT  GUID **                         ppParentGuid,
    OUT     ATTRBLOCK *                     pAttrBlockOut,
    OUT     PROPERTY_META_DATA_VECTOR **    ppMetaDataVecOut
    )
/*++

Routine Description:

    Given a set of inbound attributes and their corresponding meta data in
    conjunction with the pre-existing local meta data for the object (if any),
    determine which of the inbound attributes should be applied, and return
    an appropriate internal version of the remote meta data vector to later
    be applied when the object is committed.

    If a local copy of the object does not exist (signified by a NULL local
    meta data vector), meta data for all inbound attributes is added to the
    remote meta data vector.

    If a local copy of the object does exist, each inbound attribute is
    individually reconciled with the pre-existing local version (if any).
    Only inbound attributes that win reconciliation are added to the remote
    meta data vector; those that lose will be removed from the ENTINF.

    [wlees #98763] Special attributes of deleted objects always win

Arguments:

    pMetaDataVecLocal (IN) - Pre-existing local meta data vector for this object
        (if any).

    fIsAncestorOfLocalDsa (IN) - TRUE iff the object being replicated is a
        current config NC ancestor of (or is) the ntdsDsa object corresponding
        to the local machine.

    fLocalObjDeleted (IN) - True if local object is deleted, otherwise false.

    fDeleteLocalObj (IN) - True if local object is not yet deleted, but will be
        deleted in applying this change.

    fBadDelete (IN) - True if the local object is a system-critical object and
                        the object has been deleted on the remote DS.

    RemoteObjDeletion (IN) - Deletion status of remote object as judged by its
        attributes: being deleted, deletion being reversed, or no deletion
        status change.

    pent (IN) - Inbound object name/attributes.

    pMetaDataVecRemote (IN) - Remote meta data for all attributes to be applied.

    ppParentGuid (IN/OUT) - Holds pointer to the inbound guid of this object's
        parent on the source DC (for move operations).  Reset to NULL on return
        if reconciliation dictates that the object should not be moved.

    pAttrBlockOut (OUT) - On return, holds the attributes (and their values)
        that should be applied.  (pAttrBlockOut->pAttr is THAlloc()'ed.)

    ppMetaDataVecOut (OUT) - On return, holds the meta data vector for the
        attributes returned in pAttrBlockOut.  (The vector is THAlloc()'ed.)

Return Values:

    TRUE - There are attributes to be applied.
    FALSE - All inbound attributes lost reconciliation.

--*/
{
    BOOL                        fHaveChangesToApply;
    DWORD                       cbMetaDataVecRemoteAlloced;
    ATTR *                      pAttr;
    PROPERTY_META_DATA *        pMetaDataRemote;
    PROPERTY_META_DATA *        pMetaDataLocal;
    PROPERTY_META_DATA *        pNextMetaDataLocal;
    DWORD                       cNumPropsLocal;
    BOOL                        fLocalObjExists;
    DWORD                       iAttr;
    BOOL                        fApplyAttribute;
    int                         nDiff;
    DSTIME                      TimeNow = 0;
    USN                         usnLocal;
    BOOL                        fIsCreation = FALSE;
    CHAR                        buf[150];


    Assert(NULL != pMetaDataVecRemote);
    VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecRemote);

    // There should be a one-to-one correspondence between remote attributes and
    // meta data for those attributes.
    Assert( pent->AttrBlock.attrCount == pMetaDataVecRemote->V1.cNumProps );

    // sanity check if the local object is a tombstone,it still has meta data
    Assert( !(fLocalObjDeleted && !pMetaDataVecLocal) );

    // Deleted objects shouldn't need to be re-deleted.
    Assert(!(fLocalObjDeleted && fDeleteLocalObj));

    // If it's a bad deletion, we certainly shouldn't be carrying it out.
    Assert(!(fDeleteLocalObj && fBadDelete));

    if (pMetaDataVecLocal)
    {
        VALIDATE_META_DATA_VECTOR_VERSION(pMetaDataVecLocal);
    }


    // Local object exists if we have pre-existing local meta data for it.
    fLocalObjExists = ( NULL != pMetaDataVecLocal );

    if (fBadDelete) {
        // If this is a bad deletion, don't move the object.
        *ppParentGuid = NULL;
    }


    // Cue up the first entry in the local meta data vector (if any).
    if (    ( NULL != pMetaDataVecLocal )
         && ( 0 != pMetaDataVecLocal->V1.cNumProps )
       )
    {
        pNextMetaDataLocal = &pMetaDataVecLocal->V1.rgMetaData[ 0 ];
        cNumPropsLocal = pMetaDataVecLocal->V1.cNumProps;
    }
    else
    {
        pNextMetaDataLocal = NULL;
    }

    // Allocate and cue up the resultant attrblock.
    pAttr = THAllocEx(pTHS, sizeof(ATTR) * pent->AttrBlock.attrCount);
    pAttrBlockOut->pAttr = pAttr;
    pAttrBlockOut->attrCount = 0;

    // Allocate and cue up the resultant meta data vector.
    *ppMetaDataVecOut = THAllocEx(pTHS, MetaDataVecV1Size(pMetaDataVecRemote));
    (*ppMetaDataVecOut)->dwVersion = 1;
    pMetaDataRemote = &(*ppMetaDataVecOut)->V1.rgMetaData[ 0 ];

    // Reconcile each replicated attribute.
    // Changes that are reconciled in favor of the inbound attribute have their
    // meta data added to the internal meta data vector we will return to the
    // caller, and the the attribute itself will be present in the returned
    // attrblock.

    for ( iAttr = 0; iAttr < pent->AttrBlock.attrCount; iAttr++ )
    {
        *pAttr = pent->AttrBlock.pAttr[iAttr];
        *pMetaDataRemote = pMetaDataVecRemote->V1.rgMetaData[ iAttr ];

        Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

        if ( fLocalObjExists )
        {
            // Local object exists; determine whether or not the inbound
            // attribute should be applied.

            // Skip over irrelevant local meta data.
            while (    ( NULL != pNextMetaDataLocal )
                    && ( pNextMetaDataLocal->attrType < pAttr->attrTyp )
                  )
            {
                if ( --cNumPropsLocal )
                    pNextMetaDataLocal++;
                else
                    pNextMetaDataLocal = NULL;
            }

            // Get corresponding local meta data (if any).
            if (    ( NULL != pNextMetaDataLocal )
                 && ( pNextMetaDataLocal->attrType == pAttr->attrTyp )
               )
            {
                pMetaDataLocal = pNextMetaDataLocal;
            }
            else
            {
                pMetaDataLocal = NULL;
            }

            // Should we apply this attribute?
            nDiff = ReplCompareMetaData(pMetaDataRemote,
                                        pMetaDataLocal);
            if (0 == nDiff) {
                // Same meta data; attribute already applied locally.
                fApplyAttribute = FALSE;
            }
            else {
                fApplyAttribute = (nDiff > 0);
            }
        }
        else
        {
            // No local object; apply all incoming attributes.
            fApplyAttribute = TRUE;
            pMetaDataLocal = NULL;
        }

        if (fBadDelete)
        {
            // we don't allow the deletion of this object - so, we can't let attributes from
            // the remote DS that were changed/removed as part of the deletion to win
            if (fApplyAttribute)
            {
                ATTCACHE *pAC = SCGetAttById(pTHS, pAttr->attrTyp);

                if (NULL == pAC)
                {
                    DsaExcept(DSA_EXCEPTION,
                              DIRERR_ATT_NOT_DEF_IN_SCHEMA,
                              pAttr->attrTyp);
                }

                // just a sanity assert - we shouldn't be getting any backlinks
                Assert(!FIsBacklink(pAC->ulLinkID));

                // Since we consider this to be a bad delete, we should override EVERY winning
                // change with the local value and force it to replicate out in an attempt to
                // revive the deleted object on the other machine(s). It should be noted that
                // this would reinstantiate only the replicated attributes. Non-replicated attributes
                // will not be revived. Links are revived using ReplOverrideLinks().
                OverrideWithLocalValue(pTHS, pAttr, pMetaDataRemote, &TimeNow,
                                       &usnLocal);
            }
        }
        else
        {
            // Check if we need to override special attributes for deleted objects
            OverrideValues(pTHS,
                           pent->pName,
                           ppParentGuid,
                           pAttr,
                           &fApplyAttribute,
                           fIsAncestorOfLocalDsa,
                           fLocalObjDeleted,
                           fDeleteLocalObj,
                           RemoteObjDeletion,
                           pMetaDataLocal,
                           pMetaDataRemote,
                           &TimeNow,
                           &usnLocal);
        }

        if ( fApplyAttribute )
        {
            CHAR buf1[SZDSTIME_LEN + 1];

            DPRINT5(2,
                    "APPLY: (a:%x, l:%d, v:%d, t:%I64x, u:%I64x)\n",
                    pAttr->attrTyp,
                    pAttr->AttrVal.valCount ? pAttr->AttrVal.pAVal->valLen : 0,
                    pMetaDataRemote->dwVersion,
                    (__int64) pMetaDataRemote->timeChanged,
                    pMetaDataRemote->usnOriginating);

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_APPLIED,
                      szInsertAttrType(pAttr->attrTyp,buf),
                      szInsertDN(pent->pName),
                      szInsertUUID(&pent->pName->Guid),
                      szInsertUL( pMetaDataRemote->dwVersion ),
                      szInsertDSTIME( pMetaDataRemote->timeChanged, buf1 ),
                      szInsertUSN( pMetaDataRemote->usnOriginating ),
                      NULL, NULL);
            // We should apply this replicated attribute.

            fIsCreation |= (ATT_OBJECT_CLASS == pAttr->attrTyp);

            // Move on to the next attribute.
            pAttrBlockOut->attrCount++;
            pAttr++;
            (*ppMetaDataVecOut)->V1.cNumProps++;
            pMetaDataRemote++;
        } else {
            DPRINT2( 2,
                     "ReplRecon: attr %x keep local value, local version = %d\n",
                     pAttr->attrTyp, pMetaDataLocal->dwVersion);

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_VERBOSE,
                      DIRLOG_DRA_PROPERTY_NOT_APPLIED,
                      szInsertAttrType(pAttr->attrTyp,buf),
                      szInsertDN(pent->pName),
                      szInsertUUID(&pent->pName->Guid),
                      szInsertUL( pMetaDataLocal->dwVersion ),
                      NULL, NULL, NULL, NULL);

            // Note that since we shifted the array we need not change the
            // values of iAttr or pAttr to move on to the next attribute.
        }
    }

    Assert(1 == (*ppMetaDataVecOut)->dwVersion);
    Assert((*ppMetaDataVecOut)->V1.cNumProps == pAttrBlockOut->attrCount);

    fHaveChangesToApply = (    ( NULL != *ppMetaDataVecOut )
                            && ( 0 != (*ppMetaDataVecOut)->V1.cNumProps )
                          );

    if (fHaveChangesToApply) {
        if (fIsCreation) {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_APPLYING_OBJ_CREATION,
                     szInsertDN(pent->pName),
                     szInsertUUID(&pent->pName->Guid),
                     NULL);
            return UPDATE_OBJECT_CREATION;
        }
        else {
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_APPLYING_OBJ_UPDATE,
                     szInsertDN(pent->pName),
                     szInsertUUID(&pent->pName->Guid),
                     NULL);
            return UPDATE_OBJECT_UPDATE;
        }
    } else {
        return UPDATE_NOT_UPDATED;
    }
}


int
ReplCompareMetaData(
    IN      PROPERTY_META_DATA *    pMetaData1,
    IN      PROPERTY_META_DATA *    pMetaData2  OPTIONAL
    )
/*++

Routine Description:

    Compare meta data to determine which "wins" for reconciliation.

    Order of precedence is higher version, higher timestamp, higher DSA guid.

Arguments:

    pMetaData1, pMetaData2 (IN) - meta data to compare.

Return Values:

    1   pMetaData1 wins
    0   pMetaData1 and pMetaData2 identical
    -1  pMetaData2 wins

--*/
{
    LONGLONG  diff = 0;

    Assert(pMetaData1);
    Assert(!pMetaData2 || (pMetaData1->attrType == pMetaData2->attrType));

    if (!pMetaData2) {
        diff = 1;
    }

    if (0 == diff) {
        diff = ReplCompareVersions(pMetaData1->dwVersion,
                                   pMetaData2->dwVersion);
    }

    if (0 == diff) {
        diff = pMetaData1->timeChanged - pMetaData2->timeChanged;
    }

    if (0 == diff) {
        diff = memcmp(&pMetaData1->uuidDsaOriginating,
                      &pMetaData2->uuidDsaOriginating,
                      sizeof(UUID));
    }

    return (diff < 0) ? -1
                      : (diff > 0) ? 1
                                   : 0;
}


int
ReplCompareValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2,
    BOOL *pfConflict OPTIONAL
    )

/*++

Routine Description:

    Compare to value meta data stamps and return the result

    Also return an indicator whether there was a difference in the timeCreated
    field, indicating a collision.

Arguments:

    pValueMetaData1 -
    pValueMetaData2 -
    pfConflict - true if values different in creation time

Return Value:

    int -
    1   pMetaData1 wins
    0   pMetaData1 and pMetaData2 identical
    -1  pMetaData2 wins

--*/

{
    LONGLONG  diff = 0;
    BOOL fConflict = FALSE;
    BOOL fIsLegacy1, fIsLegacy2;

    // If either is a legacy value, it loses
    fIsLegacy1 = IsLegacyValueMetaData( pValueMetaData1 );
    fIsLegacy2 = IsLegacyValueMetaData( pValueMetaData2 );

    if (fIsLegacy1 && fIsLegacy2) {
        // Both metadata are legacy
        // The only remaining field that is defined is timeCreated.
        Assert( !"It is not expected to have two legacy metadata items" );
        diff = pValueMetaData1->timeCreated - pValueMetaData2->timeCreated;
        fConflict = (diff != 0);
    } else if (fIsLegacy1) {
        // pMetaData1 is legacy
        return -1;
    } else if (fIsLegacy2) {
        // pMetaData2 is legacy
        return 1;
    } else {

        // The time created field is most significant and is checked first
        // Followed by the rest of the usual metadata

        diff = pValueMetaData1->timeCreated - pValueMetaData2->timeCreated;
        if (diff == 0) {
            diff = ReplCompareMetaData(
                &(pValueMetaData1->MetaData),
                &(pValueMetaData2->MetaData) );
        } else {
            fConflict = TRUE;
        }
    }

    if (pfConflict) {
        *pfConflict = fConflict;
    }
    return (diff < 0) ? -1
                      : (diff > 0) ? 1
                                   : 0;
} /* ReplCompareValueMetaData */


int
ReplCompareDifferentValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2
    )

/*++

Routine Description:

    Compare two value meta data stamps and return the result

    The two stamps are from different values, and thus their metadata are not
    directly comparable. The best we can do is a temporal ordering with an
    originating guid for a tie breaker.  Note especially that timeCreated and
    version should not be used for the comparision.

[Gregory Johnson] 2010: Same as logic to ReplCompareMetaData, and similar (but
different) to the code/logic on drancrep.c line 1989-2002 - why don't these
have identical conflict resolution rules (non-LVR name conflicts, non-LVR
value conflicts, and now single value LVR conflicts)?  Is there a reason that
non-LVR name conflicts use the object guid instead of the uuid of the
originating Dsa - I guess the answer is probably "why not?".  [Will] There is
metadata comparision for updates, and there is uniqueness conflicts for
creations. Metadata comparsion tells you an ordering for two changes to the
same thing. Uniqueness conflicts are when two different things are using the
same name or identity.  In the case of LVR values, the timeCreated field tells
us whether two values with the same dn are really derived from the same
creation.

I agree that these are all flavors of identity conflict stemming from
different creations using the same name. These three have sort of grown up
ad-hoc without a lot of coordination, though they seem to have the common
theme of using a timestamp to make decisions in these cases. That's what we do
for name conflicts.

You do make a valid observation that the three conflict mechanisms use a
different tie breaker scheme:

Object name conflict: uses object guid. Probably because it was
handy. Argueably this is inconsistent with the use of uuidDsaOriginating in
other metadata comparisions, but I wouldn't want to change it now.

LVR value identity conflict: the timestamp is how we detect the conflict, and
if there was a tie it wouldn't be a conflict. :-)

Single value conflict: The tiebreaker method of using originator guid is
similar to what is done for metadata comparisions, from which the code is
derived. Also, the owning object guid is identical in this scenario, so we
can't use that as we do for name conflicts. I guess we could use the value's
guid itself, but we may not always know it.

Arguments:

    pValueMetaData1 -
    pValueMetaData2 -

Return Value:

    int -
    1   pMetaData1 wins
    0   pMetaData1 and pMetaData2 identical
    -1  pMetaData2 wins

--*/

{
    LONGLONG  diff = 0;
    BOOL fIsLegacy1, fIsLegacy2;

    // If either is a legacy value, it loses
    fIsLegacy1 = IsLegacyValueMetaData( pValueMetaData1 );
    fIsLegacy2 = IsLegacyValueMetaData( pValueMetaData2 );

    if (fIsLegacy1 && fIsLegacy2) {
        // Both metadata are legacy
        // The only remaining field that is defined is timeCreated.
        Assert( !"It is not expected to have two legacy metadata items" );
        diff = pValueMetaData1->timeCreated - pValueMetaData2->timeCreated;
    } else if (fIsLegacy1) {
        // pMetaData1 is legacy
        return -1;
    } else if (fIsLegacy2) {
        // pMetaData2 is legacy
        return 1;
    } else {

        diff = pValueMetaData1->MetaData.timeChanged - pValueMetaData2->MetaData.timeChanged;

        if (0 == diff) {
            diff = memcmp(&pValueMetaData1->MetaData.uuidDsaOriginating,
                          &pValueMetaData2->MetaData.uuidDsaOriginating,
                          sizeof(UUID));
        }

    }

    return (diff < 0) ? -1
                      : (diff > 0) ? 1
                                   : 0;
} /* ReplCompareDifferentValueMetaData */


int
__inline
ReplCompareVersions(
    IN DWORD Version1,
    IN DWORD Version2
    )
/*++

Routine Description:

    This function compares two meta-data version numbers, taking wrap-around
    into account, and determines which is larger.

Arguments:

    Version1 - Supplies the first version number.
    Version2 - Supplies the second version number.

Return Value:

    1   Version1 > Version2
    0   Version1 = Version1
    -1  Version1 < Version2

--*/
{

    //
    // Our solution to handling version number wrap-around is the following.
    // For each number N, there is a range of numbers which are less than N
    // and a range of numbers which are greater than N.  Depending upon the
    // value of N, this range of numbers less than N may or may not wrap
    // around.  In the non-wrap-around case, these ranges will look something
    // like this:
    //
    //         0xFFFFFFFF +----------+  --+
    //                    |          |    |
    //                    |          |    |-- greater than N
    //                    |          |    |
    //                    |          |    |
    //                    |----------|  --+
    //                    |//////////|    |
    //                    |//////////|    |
    //         0x7FFFFFFF |/-/-/-/-/-|    |
    //                    |//////////|    |-- less than N
    //                    |//////////|    |
    //                    |//////////|    |
    //                    |//////////|    |
    //                    |----------|  --+
    //                    |          |    |-- greater than N
    //                    |          |    |
    //         0x00000000 +----------+  --+
    //
    // Another thing to consider is how large the range of numbers less than
    // N should be.  Since we have 2^32 total numbers to work with, it seems
    // fair that we should make half of them (2^31) less than N and the other
    // half greater than N.  Now, for any range of numbers [A,B], the number
    // of integers that fall in that range is B - A + 1.  We would like to
    // find a constant C such that the range [N-C,N] contains exactly 2^31
    // integers.  Thus, we must have
    //
    //     N - (N-C) + 1 = 2^31
    //
    //     N - N + C + 1 = 2^31
    //
    //     C + 1 = 2^31
    //
    //     C = 2^31 - 1 = 0x7FFFFFFF
    //
    // Now that we have found C, we can describe more precisely what these
    // ranges look like.  There are two cases to consider:  (1) the case where
    // the range of numbers less than N does not wrap around and (2) the case
    // where it does wrap around.  Let's examine these cases individually.
    //
    // 1) Range does not wrap-around:  N >= 0x7FFFFFFF
    //
    //         0xFFFFFFFF +----------+
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |----------| <--- N
    //                    |//////////|
    //                    |//////////|
    //         0x7FFFFFFF |/-/-/-/-/-|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |----------| <--- N - 0x7FFFFFFF
    //                    |          |
    //                    |          |
    //         0x00000000 +----------+
    //
    // In this case, another number M is greater than N if only if it falls
    // into the area beneath N - 0x7FFFFFFF or into the area above N.  Hence,
    //
    //    N < M if and only if M < (N - 0x7FFFFFFF) or N < M.
    //
    // 2) Range does wrap-around:  N < 0x7FFFFFFF
    //
    //         0xFFFFFFFF +----------+
    //                    |//////////|
    //                    |//////////|
    //                    |----------| <--- N - 0x7FFFFFFF
    //                    |          |
    //                    |          |
    //                    |          |
    //                    |          |
    //         0x7FFFFFFF | - - - - -|
    //                    |          |
    //                    |          |
    //                    |----------| <--- N
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //                    |//////////|
    //         0x00000000 +----------+
    //
    // In this case, another number M is greater than N if only if it falls
    // into the area in between N - 0x7FFFFFFF and N.  Hence,
    //
    //   N < M if and only if (N < M) && (M < N - 0x7FFFFFFF)
    //
    // Unfortunately, this scheme as described above does not work perfectly.
    // There is a set of pairs of numbers (A,B) for which this scheme says both
    // that A < B and B < A.  This is not right!  The set of pairs for which
    // this occurs is any pair (N, N + 0x80000000).  Instead of complicating
    // our technique, we will just handle these cases with special code.
    //

    // Let's get this possibility out of the way.
    if ( Version1 == Version2 ) {

        return 0;

    }

    if ( Version1 > 0x7FFFFFFF ) {

        // This is case 1, the no-wrap-around case.

        // Look for the special case pair.
        if ( Version2 == Version1 - 0x80000000 ) {

            return 1;

        }

        if ( (Version2 < Version1 - 0x7FFFFFFF) || (Version1 < Version2) ) {

            return -1;  // Version2 > Version1

        } else {

            return 1;   // Version2 < Version1

        }

    } else  if ( Version1 < 0x7FFFFFFF ) {

        // This is case 2, the wrap-around case.

        // Look for the special case pair.
        if ( Version2 == Version1 + 0x80000000 ) {

            return -1;

        }

        if ( (Version1 < Version2) && (Version2 < Version1 - 0x7FFFFFFF) ) {

            return -1;   // Version2 < Version1

        } else {

            return 1;  // Version2 > Version1

        }

    } else {

        // Technically, this is also case 1, the no-wrap-around case.  However,
        // the special case code is different here, so we'll handle it as a
        // separate case.

        // Look for the special case pair.
        if ( Version2 == 0xFFFFFFFF ) {

            return -1;

        }

        if ( (Version2 < Version1 - 0x7FFFFFFF) || (Version1 < Version2) ) {

            return -1;  // Version2 > Version1

        } else {

            return 1;   // Version2 < Version1

        }

    }

} // ReplCompareVersions

#define ReplMetaIsOverridden(pTHS, pMeta, pTime, pUsn) \
    ((0 == memcmp(&((pMeta)->uuidDsaOriginating), \
                  &(pTHS)->InvocationID, \
                  sizeof(UUID))) \
     && (*(pTime) == (pMeta)->timeChanged) \
     && (*(pUsn) == (pMeta)->usnOriginating))


BOOL
ReplPruneOverrideAttrForSize(
    THSTATE *                   pTHS,
    DSNAME *                    pName,
    DSTIME *                    pTimeNow,
    USN *                       pusnLocal,
    ATTRBLOCK *                 pAttrBlock,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )

/*++

Routine Description:

This routine is called when the incoming modification has resulted in the
record being too big.  This can happen under the following scenario:

Two systems each add a large number of values to two (or more) different
attributes, and the total record size is exceeded during replication

Note that two servers cannot each originate a large change to the same
attribute and have it cause a record to big condition.  This is because
two changes to the same attribute during the same window will result in a
version collision, with the older update winning.

In this case we want to prune some incoming attributes.
By prune in this case we mean override.  We want to
1. Not apply the incoming change, and
2. Make our local value override so this reverses the incoming change
at the originating site.

Jeff Parham:  Pruning the inbound data is the right thing to do, I believe.
Add or update the local meta data for that property to make the pre-existing
local values (if any) win.  The problem is you don;t necessarily know which
attribute's values (or attributes' values, for that matter -- there may be more
than one) pushed you over the limit.  The inbound packet has a bunch of attributes
and a bunch of values -- all that you'll know is that you attempted to apply
them as a whole and you exceeded the record size.

Now you have to decide which attribute to prune.
I'd start by pruning the non-system attribute that grew
the highest number of values.  If you exhaust all the inbound non-system attributes
you may be forced to prune system attributes or to prune unchanged pre-existing
local values.  The latter is probably better -- I'd avoid pruning system attributes
until the bitter end.  You could start with the most recently changed
non-system attribute on the local machine and move on from there.

Here is some more commentary about what contributes to record size:

Q: Is there one record limit for the whole object, or is each attribute its own record
and thus each attribute has its own limit?
Jeff Parham:  All non-linked attributes for the object reside on a single record
(the datatable (aka object table) record with the DNT associated with that
record's DN).  Some values also reside on the record (e.g., DWORD values;
there are more).  At any rate each non-linked value (not just the attributes
-- the values too) consumes a portion of the record for a header,
regardless of whether the value is stored on the record or in the long value table.

CODE.IMPROVEMENT: Consider a greater number of attributes as reserved. Sam owned
attributes are all single valued with the exception of linked valued attributes, so
they are not likely to be a source of trouble here.

CODE.IMPROVEMENT: Instead of rejecting an attribute change completely, it might
make sense to remove one value at a time until the record fits?

Arguments:

Assume: thread state, and positioned on object to be updated.

    pTHS -
    pName -
    pAttrBlock -
    pfRetryUpdate -

Return Value:

    None

--*/

{
    ATTR *pAttrCandidate;
    PROPERTY_META_DATA *pMetaDataRemCandidate;
    ULONG chooseReserved;
    CHAR buf[150]; // scratch buffer for event logging code
    CHAR buf1[SZDSTIME_LEN + 1]; // another

    DPRINT1( 1, "ReplPruneAttributesForSize, name = %ws\n", pName->StringName );

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert( pMetaDataVecRemote );

    // Perform two passes: non-reserved attributes first, then special ones...

    for( chooseReserved = 0; chooseReserved < 2; chooseReserved++ ) {

        ULONG i, largestValueDifference = 0;
        pAttrCandidate = NULL;
        pMetaDataRemCandidate = NULL;

        for( i = 0; i < pAttrBlock->attrCount; i++ ) {

            ATTR *pAttr = &(pAttrBlock->pAttr[i]);
            ATTCACHE *pAC = SCGetAttById(pTHS, pAttr->attrTyp);
            PROPERTY_META_DATA *pMetaDataRemote =
                &(pMetaDataVecRemote->V1.rgMetaData[ i ]);
            DWORD numberIncomingValues = pAttr->AttrVal.valCount;
            DWORD numberValueDifference, numberExistingValues;
            BOOL fReserved = (pAC->bSystemOnly);

            Assert(pMetaDataRemote->attrType == pAttr->attrTyp);

            // Exclude linked, already overridden, and attr removals
            if ( (pAC->ulLinkID) ||
                 (ReplMetaIsOverridden(pTHS, pMetaDataRemote, pTimeNow, pusnLocal)) ||
                 (numberIncomingValues == 0) ) {
                continue;
            }
            if ( (chooseReserved != 0) != (fReserved) ) {
                continue;
            }

            numberExistingValues = DBGetValueCount_AC( pTHS->pDB, pAC );

            // Value change does not make the problem worse
            if (numberIncomingValues <= numberExistingValues) {
                continue;
            }
            numberValueDifference = numberIncomingValues - numberExistingValues;

            if (numberValueDifference > largestValueDifference) {
                largestValueDifference = numberValueDifference;
                pAttrCandidate = pAttr;
                pMetaDataRemCandidate = pMetaDataRemote;
            }
        }

        if (pAttrCandidate) {
            goto success;
        }
    }

    DPRINT1( 0, "ReplPrune: no more attributes to prune for %ws\n",
             pName->StringName );
    Assert( FALSE && "Ran out of incoming attributes to prune, and record still too big" );
    LogEvent( DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_RECORD_TOO_BIG_PRUNE_FAILURE,
              szInsertDN(pName),
              szInsertUUID(&(pName->Guid)),
              NULL);

    return FALSE;

success:

    Assert( pAttrCandidate && pMetaDataRemCandidate );

    // Note that if this was an attribute creation, and the attribute
    // didn't exist locally, an attribute removal will be the override used

    OverrideWithLocalValue( pTHS, pAttrCandidate, pMetaDataRemCandidate,
                            pTimeNow, pusnLocal );

    DPRINT3( 1, "ReplPrune: pruned/override w/local value for attr %s, object %ws, new ver %d\n",
             ConvertAttrTypeToStr(pAttrCandidate->attrTyp,buf),
             pName->StringName,
             pMetaDataRemCandidate->dwVersion
        );

    LogEvent8(  DS_EVENT_CAT_REPLICATION,
                DS_EVENT_SEV_ALWAYS,
                DIRLOG_DRA_RECORD_TOO_BIG_OVERRIDE,
                szInsertDN(pName),
                szInsertUUID(&(pName->Guid)),
                szInsertAttrType(pAttrCandidate->attrTyp,buf),
                szInsertUL( pMetaDataRemCandidate->dwVersion ),
                szInsertDSTIME( pMetaDataRemCandidate->timeChanged, buf1 ),
                szInsertUSN( pMetaDataRemCandidate->usnOriginating ),
                NULL, NULL);

    return TRUE;
} /* ReplPruneAttributesForSize */



VOID
ReplOverrideLinks(
    IN THSTATE *pTHS
    )

/*++

Routine Description:

    Cause any linked values associated with this object to replicate out.

    This is essentially an authoritative restore of all links associated with
    this object.

    This is used to revive forward and backward links of an object that has been
    wrongly deleted.

    ISSUE wlees/jeffparh Sep 29, 2000
[JeffParh]  2432.  Might be worth a comment that this helps us only for those links
on objects held by the DSA that detects the bad deletion.  Links from objects in NCs
not hosted by this machine and links from objects that haven't yet replicated to this
machine will still end up being inconsistent.  I.e., this code is a good step in the
right direction, but doesn't fully solve the problem of link inconsistency on object
resuscitation.  (Same problem occurs in auth restore, for which there's an open
Blackcomb bug.)

Arguments:

    pTHS - 

Return Value:

    None

--*/

{
    BOOL fSaveScopeLegacyLinks;

    if (!pTHS->fLinkedValueReplication) {
        // OverrideWithLocalValue should have handled all the legacy values
        return;
    }

    DPRINT1( 0, "Reviving links for object %s\n",
             GetExtDN( pTHS, pTHS->pDB) );

    // This routine may be called during legacy replication, when links with
    // metadata are not visible.  Further, DBTouchLinks is not effective during
    // legacy replication because it will not write value metadata in this mode.
    // Temporarily make metadata visible so that we may re-write all links with
    // current metadata, forcing them to replicate out individually.
    fSaveScopeLegacyLinks = pTHS->pDB->fScopeLegacyLinks;
    pTHS->pDB->fScopeLegacyLinks = FALSE;
    __try {

        DBTouchLinks_AC( pTHS->pDB,
                         NULL /* all linked attributes */,
                         FALSE /* forward links */ );

        DBTouchLinks_AC( pTHS->pDB,
                         NULL /* all linked attributes */,
                         TRUE /* backward links */ );
    } __finally {
        pTHS->pDB->fScopeLegacyLinks = fSaveScopeLegacyLinks;
    }

} /* ReplOverrideLinks */


#if DBG
void
ReplCheckMetadataWasApplied(
    IN      THSTATE *                   pTHS,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )

/*++

Routine Description:

Jeffparh writes:
I've been thinking that perhaps we should add assertions in the replication path
to ensure that, after an inbound update has been successfully applied, the meta data
for the inbound attribute on the resultant local object is greater than or equal to
the inbound meta data.  I.e., that for each inbound attribute we either set the
local meta data to be the same as the inbound meta data or we have a "better" change
already.  That would help us catch these sorts of inconsistencies earlier.

   It is assumed that the metadata on the DBPOS has already been flushed to disk.
   That is, the update has already completed, but the transaction may be still open.

   The list of remote metadata being supplied to this function is the list of
   metadata that should have been applied. That is, the function
   ReplReconcileRemoteMetaDataVec has already been called. The remote metadata is
   that which should have won and been applied.

   This routine is called after metadata reconcilation, after any over or underriding
   requests, and after the update itself has taken place. The metadata vector
   passed in here was the final vector used to write the metadata to disk. Although
   the vector reflects the request for over or under-ride, it does not contain
   the actual version number or USN, since they were assigned by dbFlushMetaDataVector.

This check verifies that the remote metadata that we received from our partner was
actually used during the local replicated write to form the new metadata vector.  This
check verifies that all of the inbound attributes were actually touched during the
replicated write, and that the remote metadata was merged successfully.  This check
verifies the use of two routines:
    DBTouchMetaData
    dbFlushMetaDataVector

Arguments:

    pTHS -
    pMetaDataVecRemote - Metadata that should be applied

Return Value:

    None

--*/

{
    DWORD i, cProps, cbReturned;
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal = NULL;
    PROPERTY_META_DATA *pMetaDataRemote, *pMetaDataLocal;
    int nDiff;
    DBPOS *pDB = pTHS->pDB;
    PROPERTY_META_DATA metaDataAdjusted;
    ATTCACHE *pAC;
    CHAR buf[20];

    Assert(VALID_DBPOS(pDB));
    Assert( !pDB->fIsMetaDataCached );

    if ( (!pMetaDataVecRemote) || (!(pMetaDataVecRemote->V1.cNumProps)) ) {
        // Nothing to apply
        return;
    }

    // Read the local metadata
    if (DBGetAttVal(pTHS->pDB, 1,  ATT_REPL_PROPERTY_META_DATA,
                    0, 0, &cbReturned, (LPBYTE *) &pMetaDataVecLocal))
    {
        // This should always succeed since we assume that this routine is called
        // after successful add or modify operations.
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    // The list of remote metadata to be applied should have been applied.
    // All of these should have been applied.
    // Verify that local attributes were touched.
    pMetaDataRemote = &(pMetaDataVecRemote->V1.rgMetaData[0]);
    cProps = pMetaDataVecRemote->V1.cNumProps;
    for( i = 0; i < cProps; i++, pMetaDataRemote++ ) {
        ATTRTYP attrType = pMetaDataRemote->attrType;

        // Skip writing SchemaInfo if fDRA during normal running. It will
        // be written directly by the dra thread at the end of schema NC
        // sync.

        if (attrType == ATT_SCHEMA_INFO) {
            continue;
        }

        pMetaDataLocal = ReplLookupMetaData(
            pMetaDataRemote->attrType,
            pMetaDataVecLocal,
            NULL );

        if (!pMetaDataLocal) {
            DPRINT( 0, "Local metadata is missing.\n" );
        } else {
            // Account for the fact that during flush the metadata may have been
            // over- or underridden. Compensate to make remote metadata comparable.
            if (pMetaDataRemote->usnProperty == USN_PROPERTY_TOUCHED) {
                metaDataAdjusted = *pMetaDataRemote;
                metaDataAdjusted.dwVersion++;
                metaDataAdjusted.timeChanged = pMetaDataLocal->timeChanged;
                metaDataAdjusted.uuidDsaOriginating = pMetaDataLocal->uuidDsaOriginating;
                nDiff = ReplCompareMetaData(&metaDataAdjusted, pMetaDataLocal);
            } else {
                // Compare the adjusted pre-write remote vector with the post-flush vector.
                nDiff = ReplCompareMetaData(pMetaDataRemote, pMetaDataLocal);
            }

            // 1 = remote wins, 0 = same, -1 = local wins

            if (nDiff == 0) {
                // We expect that the winning remote metadata that we have is the same
                // as what is now on the object (what should have been written).
                continue;
            } else if (nDiff == 1) {
                // 1 means local metadata underrides (loses)
                DPRINT( 0, "Local metadata lost unexpectedly (bad underride).\n" );
            } else // if (nDiff == -1)
            {
                // -1 means local metadata overrides
                DPRINT( 0, "Local metadata won unexpectedly (bad override).\n" );
            }
        }

        pAC = SCGetAttById(pTHS, attrType);
        DPRINT1( 0, "Attribute %s metadata not written properly\n",
                 pAC ? pAC->name : _ultoa( attrType, buf, 16 ) );
        DPRINT1( 0, "Remote metadata vector:\n!dsexts.dump PROPERTY_META_DATA_VECTOR %p\n",
                 pMetaDataVecRemote );
        DPRINT1( 0, "Local metadata vector:\n!dsexts.dump PROPERTY_META_DATA_VECTOR %p\n",
                 pMetaDataVecLocal );


        Assert( FALSE && "metadata not written properly" );
    }

    // Be heap friendly
    if (NULL != pMetaDataVecLocal) {
        THFreeEx(pTHS, pMetaDataVecLocal);
        pMetaDataVecLocal = NULL;
    }

} /* ReplCheckMetadataWasApplied */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drancdel.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       drancdel.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                    // schema cache
#include <dbglobal.h>                  // The header for the directory database
#include <mdglobal.h>                  // MD global definition header
#include <mdlocal.h>                   // MD local definition header
#include <dsatools.h>                  // needed for output allocation

// Logging headers.
#include "dsevent.h"                   /* header Audit\Alert logging */
#include "mdcodes.h"                   /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                    /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRANCDEL:" /* define the subsystem for debugging */


// DRA headers
#include "dsaapi.h"
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "drsdra.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRANCDEL

ULONG DRA_ReplicaTearDown(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pmtxaddr,
    IN  ULONG       ulOptions
    )
 /*++

Routine Description:

    Teardown the given NC.

Arguments:

    pTHS

    pNC - naming context for which source should be removed.

    pmtxaddr - network address of server from which the local DS should no
        longer source this NC.

    ulOptions

Return Values:

    DRAERR_Success - success.

    DRAERR_ObjIsRepSource - cannot remove the last replica of a read-only NC
        (implying NC subtree deletion) when other DSAs use this machine as
        a source.
	
    DRAERR_InvalidParameter - The NC either _does_ have one or more sources 
    or it's a writeable replica.

    DRAERR_BadNC - local DSA does not replicate the NC from the given source.

    other DRAERR_* codes

--*/
{
    ULONG           ret = ERROR_SUCCESS;
    SYNTAX_INTEGER  it;
    ULONG           ncdnt;
    BOOL            fBeginningTeardown = FALSE;
    CROSS_REF *     pCR;
    BeginDraTransaction(SYNC_WRITE);

    __try {
	if (ret = FindNC(pTHS->pDB, pNC, FIND_REPLICA_NC | FIND_MASTER_NC,
			 &it)) {
	    DRA_EXCEPT_NOLOG(ret, 0);
	}

	ncdnt = pTHS->pDB->DNT;
	
	// tear down this NC.

	if (DBHasValues(pTHS->pDB, ATT_REPS_FROM)) {
	    // Must delete sources before tearing down the NC.
	    DRA_EXCEPT(DRAERR_InvalidParameter, 0);
	}

	if (!(ulOptions & DRS_REF_OK)) {
	    if (DBHasValues(pTHS->pDB, ATT_REPS_TO)) {
		// We're about to tear down the NC but it still has
		// remaining repsTo's, which the caller did not explicitly
		// tell us was okay.
		DRA_EXCEPT_NOLOG(DRAERR_ObjIsRepSource, 0);
	    }
	}

	if (!(it & IT_NC_GOING)) {
	    if ((it & IT_WRITE)
		&& (NULL != (pCR = FindExactCrossRef(pNC, NULL)))
		&& !fIsNDNCCR(pCR)) {
		// The only writeable NCs we allow to be torn down are
		// NDNCs.
		DRA_EXCEPT(DRAERR_InvalidParameter, 0);
	    }

	    // Change instance type to reflect that the NC is being torn
	    // down.
	    it = (it & ~IT_NC_COMING) | IT_NC_GOING;
	    ret = ChangeInstanceType(pTHS, pNC, it, DSID(FILENO,__LINE__));
	    if (ret) {
		DRA_EXCEPT(ret, 0);
	    }

	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_NC_TEARDOWN_BEGIN,
		     szInsertDN(pNC),
		     szInsertUL(DBGetEstimatedNCSizeEx(pTHS->pDB, ncdnt)),
		     szInsertUL(DBGetApproxNCSizeEx(pTHS->pDB,
						    pTHS->pDB->JetLinkTbl,
						    Idx_LinkDraUsn,
						    ncdnt))
		     );

	    // Log only one of DIRLOG_DRA_NC_TEARDOWN_BEGIN and
	    // DIRLOG_DRA_NC_TEARDOWN_RESUME.
	    fBeginningTeardown = TRUE;
	}

	if (DRS_ASYNC_REP & ulOptions) {
	    // Caller instructed us to do the tree deletion later.
	    DirReplicaDelete(pNC,
			     NULL,
			     (ulOptions & ~DRS_ASYNC_REP)
			     | DRS_ASYNC_OP
			     | DRS_NO_SOURCE);
	} else {
	    // Log only one of DIRLOG_DRA_NC_TEARDOWN_BEGIN and
	    // DIRLOG_DRA_NC_TEARDOWN_RESUME.
	    if (!fBeginningTeardown) {
		LogEvent(DS_EVENT_CAT_REPLICATION,
			 DS_EVENT_SEV_ALWAYS,
			 DIRLOG_DRA_NC_TEARDOWN_RESUME,
			 szInsertDN(pNC),
			 szInsertUL(DBGetEstimatedNCSizeEx(pTHS->pDB,ncdnt)),
			 szInsertUL(DBGetApproxNCSizeEx(pTHS->pDB,
							pTHS->pDB->JetLinkTbl,
							Idx_LinkDraUsn,
							ncdnt))
			 );
	    }

	    if (ret = DeleteRepTree(pTHS, pNC)) {
		// Note that in this case we probably have a partially deleted
		// NC with no Reps-From (not a good thing), but the KCC will
		// try to cleanup the damage on its next pass.
		BOOL fReenqueued = FALSE;

		if (DRAERR_Preempted == ret) {
		    // This is expected behavior when we're removing a large NC,
		    // as we will relinquish the replication lock if a higher
		    // priority operation is enqueued.

		    if (DRS_ASYNC_OP & ulOptions) {
			// Re-enqueue this task such that we pick back up where
			// we left off once we have finished executing the
			// higher priority operation(s).
			DirReplicaDelete(pNC,
					 NULL,
					 ulOptions | DRS_NO_SOURCE);
			fReenqueued = TRUE;
		    }
		}

		if (!fReenqueued) {
		    // Removal failed and we're not immediately rescheduling
		    // a retry.  Report our failure.
		    LogEvent8(DS_EVENT_CAT_REPLICATION,
			      DS_EVENT_SEV_ALWAYS,
			      DIRLOG_DRA_NC_TEARDOWN_FAILURE,
			      szInsertDN(pNC),
			      szInsertWin32Msg(ret),
			      szInsertWin32ErrCode(ret),
			      NULL, NULL, NULL, NULL, NULL );
		}

		DRA_EXCEPT(ret, 0);
	    }

	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_NC_TEARDOWN_SUCCESS,
		     szInsertDN(pNC),
		     NULL,
		     NULL);
	}
    } __finally {
	// If we had success, commit, else rollback
	if (EndDraTransaction(!(ret || AbnormalTermination()))) {
	    Assert (FALSE);
	    ret = DRAERR_InternalError;
	}
    }

    return ret;
}

ULONG
DRA_ReplicaDelSource(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pmtxaddr,
    IN  ULONG       ulOptions
    )
  /*++

Routine Description:

    Delete a source for a given NC.  If the options DRS_IGNORE_ERRORS is not passed
    then the caller wants semantics such that removing the source (updating 
    the reps-from) and updating the source machine itself (updating it's reps-to)
    happen with transaction semantics.  Since we don't want to go off machine
    holding a transaction open, we can't do this with 100% accuracy.  Instead
    we'll do our best and hope they can live with that - besides it's 
    debatable whether or not the callers really need these semantics in the
    first place.

Arguments:

    pTHS

    pNC - naming context for which source should be removed.

    pmtxaddr - network address of server from which the local DS should no
        longer source this NC.

    ulOptions

Return Values:

    DRAERR_Success - success.

    DRAERR_ObjIsRepSource - cannot remove the last replica of a read-only NC
        (implying NC subtree deletion) when other DSAs use this machine as
        a source.

    DRAERR_BadNC - local DSA does not replicate the NC from the given source.

    other DRAERR_* codes

--*/
{
    ULONG           ret = ERROR_SUCCESS;
    REPLICA_LINK *  pRepsFromRef = NULL;
    ULONG           len;
    BOOL            AttExists;
    SYNTAX_INTEGER  it;
    LPWSTR          pszSource = NULL;
    ULONG           retFixUp = ERROR_SUCCESS;

    BeginDraTransaction(SYNC_WRITE);

    __try {
	if (ret = FindNC(pTHS->pDB, pNC, FIND_REPLICA_NC | FIND_MASTER_NC,
			 &it)) {
	    DRA_EXCEPT_NOLOG(ret, 0);
	}

	// Caller has instructed us to remove a source for this NC.
	if (NULL == pmtxaddr) {
	    DRA_EXCEPT(DRAERR_InvalidParameter, 0);
	}

	if (FindDSAinRepAtt(pTHS->pDB, ATT_REPS_FROM,
			    DRS_FIND_DSA_BY_ADDRESS | DRS_FIND_AND_REMOVE,
			    NULL, pmtxaddr, &AttExists, &pRepsFromRef,
			    &len)) {
	    // NC is not currently replicated from the given source.
	    DRA_EXCEPT_NOLOG(DRAERR_NoReplica, 0);
	}

	// Existing attribute value for this replica removed.
	VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

    } __finally {
	// okay, if we succeeded, close the transaction before we go off machine
	// to update the source.  If we failed, it's safe to let the exception 
	// take us out here.
	if (EndDraTransaction(!(ret || AbnormalTermination()))) {
	    Assert (FALSE);
	    ret = DRAERR_InternalError;
	}
    }

    // any errors should have excepted already.
    Assert(ret==ERROR_SUCCESS);
    Assert(pRepsFromRef);
    Assert(len);

    // If this is an rpc (non-mail) replica and we have a source, inform
    // source DSA that we don't have a replica anymore.  This call must be
    // async to avoid possible deadlock if the other DSA is doing the same
    // operation.  Mail replicas don't do this because they are not
    // notified on change and so have no source side repsto reference.
    pszSource = TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef));

    if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP)
	&& !(ulOptions & DRS_LOCAL_ONLY)
	&& (ret = I_DRSUpdateRefs(pTHS,
				  pszSource,
				  pNC,
				  TransportAddrFromMtxAddr(gAnchor.pmtxDSA),
				  &gAnchor.pDSADN->Guid,
				  (pRepsFromRef->V1.ulReplicaFlags
				   & DRS_WRIT_REP)
				  | DRS_DEL_REF | DRS_ASYNC_OP))) {
	// If we are ignoring these errors, clear error, else abort

	// Callers who specify DRS_IGNORE_ERROR rely on the source DSA
	// to eventually clean out its dangling Reps-To.  This reference
	// should be removed the next time the source server notifies us of
	// a change, as the local server should correctly inform it that we
	// no longer replicate from it, and the source should then remove
	// its Reps-To reference.

	// Callers who DON'T specify DRS_IGNORE_ERROR don't want "eventual"
	// cleanup, they want it now.  If we succeeded in doing this, then
	// great - continue.  If we didn't succeed, then put the reps-from back
	// and except.  If we can't put the reps from back for some reason
	// then we really failed the caller and they got DRS_IGNORE_ERROR 
	// semantics anyhow, so attempt to complete the call.

	if (ulOptions & DRS_IGNORE_ERROR) {
	    ret = ERROR_SUCCESS;
	} 
    }

    if (ret!=ERROR_SUCCESS) { 
	// the I_DRSUpdateRefs call failed.
	DPRINT(0,"Unable to update the remote reps-to\n");

	// put the reps-from back
	retFixUp = DRAERR_InternalError;

	BeginDraTransaction(SYNC_WRITE);
	__try {
	    if (ERROR_SUCCESS==FindNC(pTHS->pDB, pNC, FIND_REPLICA_NC | FIND_MASTER_NC,
				      &it)) {
		#if DBG
		{
		    REPLICA_LINK * pRepsFromRefCheck;
		    BOOL AttExistsCheck;
		    ULONG lenCheck;
		    if (!FindDSAinRepAtt(pTHS->pDB, ATT_REPS_FROM,
					DRS_FIND_DSA_BY_ADDRESS,
					NULL, pmtxaddr, &AttExistsCheck, &pRepsFromRefCheck,
					&lenCheck)) {
			Assert(!"A reps-from has been added synchronously!\n");
		    }

		}
		#endif

		if (!DBAddAttVal(pTHS->pDB, ATT_REPS_FROM, len, pRepsFromRef)) {  

		    // Update object, but indicate that we don't want to
		    // awaken any ds_waits on this object 
		    if (!DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
				NULL, META_STANDARD_PROCESSING)) {
			// we did it, we reset the reps-from!	
			DPRINT(0,"Reset the reps-from since we failed to update the reps-to!\n");
			retFixUp = ERROR_SUCCESS;
		    }
		}
	    }

	} __finally {
	    // okay, if we managed to fix the reps-from, then commit, else rollback. 
	    if (EndDraTransaction(!(retFixUp || AbnormalTermination()))) {
		Assert (FALSE);
		ret = DRAERR_InternalError;
	    } 
	}

	if (retFixUp==ERROR_SUCCESS) {
	    // okay, we succeeded in fixing the reps from, but we still want to return with
	    // the error from the I_DRSUpdateRefs function.
	    DRA_EXCEPT_NOLOG(ret, 0);
	}

	// we didn't succeed in reseting the reps-from, so just attempt to contiue the operation.
	ret = ERROR_SUCCESS;
    }

    // if we are here, then if this is a writeable replica remove
    // it from the count of unsynced sources.
    if (pRepsFromRef->V1.ulReplicaFlags & DRS_INIT_SYNC) {
	InitSyncAttemptComplete(pNC,
				pRepsFromRef->V1.ulReplicaFlags | DRS_INIT_SYNC_NOW,
				DRAERR_NoReplica,
				pszSource);
    }

    THFreeEx(pTHS, pszSource);

    return ret;
}

ULONG
DRA_ReplicaDel(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pmtxaddr,
    IN  ULONG       ulOptions
    )
    /*++

Routine Description:

    Remove a replica of an NC from a given source.  If there are no sources
    for this NC and it is read-only, the NC subtree is torn down.
    Otherwise, only the sources list is affected.
    
    WARNING:  If DRS_IGNORE_ERRORS isn't specified, we do our best to honor
    the requirement that this call fails if the remote source is unable to
    update it's reps-to for this source.  We don't guarentee this behaivor -
    there exists paths where you get the DRS_IGNORE_ERRORS semantics whether
    you like it or not.

Arguments:

    pTHS

    pNC - naming context for which replica should be removed.

    pmtxaddr - network address of server from which the local DS should no
        longer source this NC.

    ulOptions

Return Values:

    DRAERR_Success - success.

    DRAERR_ObjIsRepSource - cannot remove the last replica of a read-only NC
        (implying NC subtree deletion) when other DSAs use this machine as
        a source.

    DRAERR_InvalidParameter - DRS_NO_SOURCE specified in ulOptions but the NC
        either _does_ have one or more sources or it's a writeable replica.

    DRAERR_BadNC - local DSA does not replicate the NC from the given source.

    other DRAERR_* codes

--*/
{
    ULONG           ret;

    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_DRA_REPLICADEL_ENTRY,
             szInsertDN(pNC),
             szInsertMTX(pmtxaddr),
             szInsertHex(ulOptions));

    // DRS_NO_SOURCE - if we are asked to delete with no sources, then
    // tear it down, otherwise remove the source as requested.

    if (ulOptions & DRS_NO_SOURCE) {
	ret = DRA_ReplicaTearDown(pTHS, pNC, pmtxaddr, ulOptions);
    } else {
	ret = DRA_ReplicaDelSource(pTHS, pNC, pmtxaddr, ulOptions);
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drarfmod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drarfmod.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Routines to update ATT_REPS_FROM values on NC heads.

DETAILS:

CREATED:

    03/06/97    Jeff Parham (jeffparh)
                UpdateRepsFromRef() moved from drancrep.c.

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <drs.h>                        // DRS_MSG_*

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"

#include "debug.h"                      /* standard debugging header */
#define DEBSUB "DRARFMOD:"              /* define the subsystem for debugging */

// DRA headers
#include "dsaapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "drancrep.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRARFMOD


ULONG
DRA_ReplicaModify(
    THSTATE *   pTHS,
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    MTX_ADDR *  pmtxSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    )
{
    ULONG           draError;

    // Parameter validation done in dradir.c:DirReplicaModify

    // Log parameters.
    LogEvent8(
        DS_EVENT_CAT_REPLICATION,
        DS_EVENT_SEV_EXTENSIVE,
        DIRLOG_DRA_REPLICAMODIFY_ENTRY,
        szInsertDN(   pNC            ),
        puuidSourceDRA ? szInsertUUID( puuidSourceDRA ) : szInsertSz( "" ),
        pmtxSourceDRA  ? szInsertMTX(  pmtxSourceDRA  ) : szInsertSz( "" ),
        szInsertHex(  ulReplicaFlags ),
        szInsertHex(  ulModifyFields ),
        szInsertHex(  ulOptions      ),
        0,
        0
        );

    BeginDraTransaction( SYNC_WRITE );

    __try
    {
        DWORD dwFindFlags = ((NULL != puuidSourceDRA) && !fNullUuid(puuidSourceDRA))
                                ? DRS_FIND_DSA_BY_UUID
                                : DRS_FIND_DSA_BY_ADDRESS;

        draError = UpdateRepsFromRef(
                        pTHStls,
                        ulModifyFields,
                        pNC,
                        dwFindFlags,
                        URFR_MUST_ALREADY_EXIST,
                        puuidSourceDRA,
                        NULL,
                        NULL,
                        puuidTransportObj,
                        pmtxSourceDRA,
                        ulReplicaFlags,
                        prtSchedule,
                        0, NULL );
    }
    __finally
    {
        BOOL fCommit = ( DRAERR_Success == draError ) && !AbnormalTermination();

        EndDraTransaction( fCommit );
    }

    return draError;
}


DWORD
draCalculateConsecutiveFailures(
    IN  REPLICA_LINK *  pRepsFromRef            OPTIONAL,
    IN  ULONG           ulResultThisAttempt
    )
/*++

Routine Description:

    Determine the number of consecutive failures to set on a replica link given
    its previous state (if not a new replica) and the result of the most recent
    replication attempt.

Arguments:

    pReplicaLink (IN, OPTIONAL) - Previous repsFrom state.  May be NULL if the
        most recent attempt was the first attempt to replicate this (NC, source)
        pair.

    ulResultThisAttempt (IN) - Win32 error code describing success/failure of
        most recent replication attempt.

Return Values:

    The number of consecutive failures that should be recorded on the new
    repsFrom.

--*/
{
    DWORD cConsecutiveFailures;
    BOOL fIsMailBasedRepl;

    if (0 == ulResultThisAttempt) {
        // Success!  Forget any previous failures.
        return 0;
    }

    // Start with the number of failures prior to the most recent attempt.
    cConsecutiveFailures = pRepsFromRef ? pRepsFromRef->V1.cConsecutiveFailures
                                        : 0;

    // Is this mail-based replication?  We know that if there was an error and
    // we have no repsFrom that this cannot be mail-based repl, as the first
    // thing we do when configuring a mail-based link is add it with no
    // error.  (We don't try to perform any replication from it until we have
    // a repsFrom, unlike RPC-based repl.)
    fIsMailBasedRepl = pRepsFromRef
                       && (pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP);

    switch (ulResultThisAttempt) {
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
        // The source cannot supply the partial attribute set requested
        // fall through...
    
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
        // A schema mismatch has been detected.  The most likely cause is that
        // we (the destination DSA) found a schema signature in the reply that
        // is different from our own.  This in turn is expected when the schema
        // is extended -- either the source or destination has the most recent
        // schema changes, but the other does not.
        //
        // The cases where this is not a transient failure due to recent schema
        // changes are due to either code errors (shouldn't happen) or second-
        // order failure modes (e.g., one DC can't sync the recent schema
        // changes because its disk is full).  For the latter case, we don't
        // route around servers when their disk is full and the schema has
        // *not* been extended, so we do not endeavor to do so here, either.
        //
        // Thus we assume schema mismatch is a transient failure and do not
        // include them in the failure count (which otherwise would cause us
        // to fail-over to another source, which is not desirable on schema
        // changes).
        //
        // Leave the failure count as-is, as we do e.g. on preemption.

        // fall through...
    
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
        // ERROR_DS_DRA_SCHEMA_INFO_SHIP - Schema cache is temporarily invalid, perhaps
        //      while indices are being rebuilt

    case ERROR_DS_OBJECT_BEING_REMOVED:
        // We are attempting to add an object for which a dirty phantom already exists.
        // We cannot re-add the same object until the link cleaner has had a chance
        // to run. This is strictly a local phenomena, and adding a new source won't help.
        // Don't route around.
        // Fall through...

    case ERROR_DS_CROSS_REF_BUSY:
        // We can't replicate in a cross ref object because the name is in use locally.
        // We need to wait for the KCC to finish removing the naming context.
        // Fall through...

    case ERROR_DISK_FULL:
    case ERROR_DS_OUT_OF_VERSION_STORE:
        // Local resource shortage. Failover will not help.

    case ERROR_DS_THREAD_LIMIT_EXCEEDED:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_OUT_SCHEDULE_WINDOW:
    case ERROR_DS_DRA_ABANDON_SYNC:
    case ERROR_DS_DRA_SHUTDOWN:
        // Replication was interrupted, but did not specifically fail.  Leave
        // the failure count at whatever it was previously (which may or may not
        // be 0).
        break;
    
    case ERROR_DS_DRA_REPL_PENDING:
        if (fIsMailBasedRepl) {
            // Mail-based replication.  This state indicates we have just
            // successfully enqueued an SMTP message containing our replication
            // request.
            Assert(pRepsFromRef);

            if (ERROR_DS_DRA_REPL_PENDING
                == pRepsFromRef->V1.ulResultLastAttempt) {
                // This is the second time we requested this same packet over
                // mail -- we never received a reply from our previous request.
                // Perhaps the mail message was lost, or the source DSA
                // encountered an error (ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET,
                // perhaps) processing the request.  In any case, treat this
                // lack of response as an error by incrementing the failure
                // count.
                cConsecutiveFailures++;
            } else {
                // We received a reply to our previous request and at least
                // attempted to apply it.  That attempt may have been successful
                // or unsuccessful.  In either case, leave the failure count
                // alone.
                break;
            }
        } else {
            // RPC-based replication.  This "error" code indicates we have
            // successfully applied packets from this source since any previous
            // failure(s) (if any) but have not yet completed the replication
            // cycle.  Treat this state as success.  This is analogous to mail-
            // based replication, where we clear the last error on a single
            // successful packet.  (Just in the RPC-based case we do this only
            // once every N packets for performance.)
            cConsecutiveFailures = 0;
        }
        break;

    case 0:
        Assert(!"Logic error -- we filtered out the success case already");
    default:
        // The most recent attempt resulted in an error.  Add one to the
        // previous failure count.
        cConsecutiveFailures++;
        break;
    }

    return cConsecutiveFailures;
}

DWORD
UpdateRepsFromRef(
    THSTATE *               pTHS,
    ULONG                   ulModifyFields,
    DSNAME *                pNC,
    DWORD                   dwFindFlags,
    BOOL                    fMustAlreadyExist,
    UUID *                  puuidDsaObj,
    UUID *                  puuidInvocId,
    USN_VECTOR *            pusnvecTo,
    UUID *                  puuidTransportObj,
    UNALIGNED MTX_ADDR *    pmtx_addr,
    ULONG                   RepFlags,
    REPLTIMES *             prtSchedule,
    ULONG                   ulResultThisAttempt,
    PPAS_DATA               pPasData
    )
//
// Add or update a Reps-From attribute value with the given state information.
//
// A note regarding the permission to update flags. Some flags are safe for the user
// to modify and other flags are "owned by the system".
//
// We may be called in the following situations:
// dramail.c - update after mail-based replication
// drancadd.c - ReplicaAdd()Creation of a reps-from on add of a replica
// drancrep.c - update after rpc-based replication
// drasch.c - update after gc partial attribute synchronization
// drarfmod.c - ReplicaModify
// 
// Regarding flags, we need to enforce that extra flags are not passed in, and that
// the caller is allowed to clear flags that are set. The former is accomplished in
// dradir at the DirApi level. For the latter, we only need to worry about the cases
// of explicit updating of an existing set of flags, which is cases 4 and 5 above.
// We distinguish between the system caller in case 4 and the user caller in case 5
// by the DRS_UPDATE_SYSTEM_FLAGS modify field.
//
// Note that we do not have to check for modification of system flags when
// DRS_UPDATE_ALL is specified.  We cannot reach this path on a DirReplicaModify,
// since DRS_UPDATE_ALL may not be specified. If this is a DirReplicaAdd, we will
// have already enforced that a reps-from does not already exist, and that the
// incoming flags are correct. Otherwise, we are here on behalf of the system, and
// updating system flags is permitted.
//
{
    ULONG                   ret = 0;
    BOOL                    AttExists;
    ULONG                   len;
    LONG                    diff;
    REPLICA_LINK *          pRepsFromRef = NULL;
    ULONG                   ulModifyFieldsUsed;
    DSTIME                  timeLastAttempt;
    DSTIME                  timeLastSuccess;
    ATTCACHE *              pAC;
    DWORD                   iExistingRef = 0;
    DWORD                   cbExistingAlloced = 0;
    DWORD                   cbExistingRet;
    REPLICA_LINK *          pExistingRef = NULL;
    DWORD                   cConsecutiveFailures;
    BOOL                    fNewRefHasDsaGuid;
    BOOL                    fNewRefHasInvocId;
    PPAS_DATA               pTmpPasData = NULL;

    Assert(0 == (dwFindFlags & DRS_FIND_AND_REMOVE));
    Assert(pPasData ? pPasData->size : TRUE);

    if (DBFindDSName(pTHS->pDB, pNC)) {
        // NOTE: This code is commonly hit when we're attempting to add a
        // new replica (e.g., at install time) and for whatever reason
        // the replication attempt failed completely (e.g., access denied)
        // and the NC head was not replicated.

        return DRAERR_BadNC;
    }

    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);

    // Mask the flags down to the ones we save

    RepFlags &= RFR_FLAGS;


    // Try and find this name in the repsfrom attribute.

    if ( !FindDSAinRepAtt( pTHS->pDB,
                           ATT_REPS_FROM,
                           dwFindFlags | DRS_FIND_AND_REMOVE,
                           puuidDsaObj,
                           pmtx_addr,
                           &AttExists,
                           &pRepsFromRef,
                           &len ) ) {

        // Existing att val for this DSA found and removed.
        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
        VALIDATE_REPLICA_LINK_SIZE(pRepsFromRef);
    }
    else if ( fMustAlreadyExist ) {
        return DRAERR_NoReplica;
    }

    timeLastAttempt = DBTime();

    // Determine the time of the last successful completion of a replication
    // cycle.
    if (ERROR_SUCCESS == ulResultThisAttempt) {
        if ((NULL != pusnvecTo)
            && (0 == memcmp(&gusnvecFromScratch, pusnvecTo, sizeof(USN_VECTOR)))
            && (NULL == pRepsFromRef)) {
            // Brand new source from whom we haven't yet completed a replication
            // cycle.
            timeLastSuccess = 0;
        }
        else {
            // This attempt resulted in successful completion of a replication
            // cycle.
            timeLastSuccess = timeLastAttempt;
        }
    }
    else if (NULL != pRepsFromRef) {
        // This attempt was incomplete or unsuccessful; our last success remains
        // unchanged.
        timeLastSuccess = pRepsFromRef->V1.timeLastSuccess;
    }
    else {
        // This is our first attempt and it was incomplete or unsuccessful.
        timeLastSuccess = 0;
    }

    // Determine the number of consecutive failures since the last successful
    // completion of a replication cycle.
    cConsecutiveFailures = draCalculateConsecutiveFailures(pRepsFromRef,
                                                           ulResultThisAttempt);

    // Now add new attribute value.

#ifdef CACHE_UUID
    if (!(RepFlags & DRS_MAIL_REP)) {
        if ( pmtx_addr ) {
            CacheUuid (puuidDsaObj, pmtx_addr->mtx_name);
        }
    }
#endif

    if (DRS_UPDATE_ALL != ulModifyFields) {

        // This check enforces that the reps-from already exists
        if (!pRepsFromRef || !len) {
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

        ulModifyFieldsUsed = ulModifyFields & DRS_UPDATE_MASK;

        if (    ( 0 == ulModifyFieldsUsed )
             || ( ulModifyFields != ulModifyFieldsUsed )
           )
        {
            DRA_EXCEPT( DRAERR_InternalError, ulModifyFields );
        }

        if (ulModifyFields & DRS_UPDATE_ADDRESS) {

            // Only want to update source name.
            // Determine new attribute value size.

            // offset new size by mtx difference
            diff = MTX_TSIZE(pmtx_addr) - MTX_TSIZE(RL_POTHERDRA(pRepsFromRef));
            if (diff) {
                //
                // size change
                //  - allocate & copy to new location
                //  - fix offsets
                //  - conditionally, fix PAS data offset & location
                //

                REPLICA_LINK *pOldRepsFrom = pRepsFromRef;

                // calc new RepsFrom size
                pOldRepsFrom->V1.cb += diff;
                // alloc new size & allow for alignment fixing
                pRepsFromRef = THAllocEx(pTHS, pOldRepsFrom->V1.cb+sizeof(DWORD));
                // copy all fixed fields
                memcpy (pRepsFromRef, pOldRepsFrom, offsetof(REPLICA_LINK, V1.rgb));

                // set other DRA new size
                pRepsFromRef->V1.cbOtherDra = MTX_TSIZE(pmtx_addr);

                //
                // PAS Data: Fix offsets & copy over
                //
                if ( pRepsFromRef->V1.cbPASDataOffset ) {
                    //
                    // we have PAS data:
                    //  - fix offset
                    //  - handle alignment fixup
                    //  - copy to new location
                    //
                    pTmpPasData = RL_PPAS_DATA(pOldRepsFrom);
                    // if offset is valid, there must be something there
                    Assert(pTmpPasData->size != 0);
                    // offset by mtx change, fix alignment & copy over
                    pRepsFromRef->V1.cbPASDataOffset += diff;
                    RL_ALIGN_PAS_DATA(pRepsFromRef);
                    memcpy(RL_PPAS_DATA(pRepsFromRef), pTmpPasData, pTmpPasData->size);
                }       // PAS data
            }           // diff != 0

            // regardless of size change copy new mtx address data
            memcpy (RL_POTHERDRA(pRepsFromRef), pmtx_addr, MTX_TSIZE(pmtx_addr));
        }

        if ( ulModifyFields & DRS_UPDATE_SYSTEM_FLAGS ) {

            pRepsFromRef->V1.ulReplicaFlags = RepFlags;

        } else if ( ulModifyFields & DRS_UPDATE_FLAGS ) {

            DWORD dwFlagsSet = RepFlags & (~pRepsFromRef->V1.ulReplicaFlags);
            DWORD dwFlagsClear = (~RepFlags) & pRepsFromRef->V1.ulReplicaFlags;

            if ((dwFlagsSet | dwFlagsClear) & RFR_SYSTEM_FLAGS) {
                return ERROR_INVALID_PARAMETER;
            }

            pRepsFromRef->V1.ulReplicaFlags = RepFlags;
        }

        if ( ulModifyFields & DRS_UPDATE_SCHEDULE )
        {
            if ( NULL == prtSchedule )
            {
                DRA_EXCEPT( DRAERR_InternalError, ulModifyFields );
            }

            memcpy( &pRepsFromRef->V1.rtSchedule, prtSchedule, sizeof( REPLTIMES ) );
        }

        if ( ulModifyFields & DRS_UPDATE_RESULT )
        {
            pRepsFromRef->V1.ulResultLastAttempt = ulResultThisAttempt;
            pRepsFromRef->V1.timeLastAttempt  = timeLastAttempt;
            pRepsFromRef->V1.timeLastSuccess  = timeLastSuccess;
            pRepsFromRef->V1.cConsecutiveFailures    = cConsecutiveFailures;
        }

        if (ulModifyFields & DRS_UPDATE_TRANSPORT) {
            // It is permissible for the transport uuid to be null
            pRepsFromRef->V1.uuidTransportObj = *puuidTransportObj;
        }

        //
        // update PAS state
        //
        if (ulModifyFields & DRS_UPDATE_PAS) {
            //
            // Update PAS data
            // if none given, we need to reset fields, otherwise write new data
            //
            if ( pPasData ) {
                // can't have reference to pas data w/ no info
                Assert(pPasData->size != 0);

                if (pRepsFromRef->V1.cbPASDataOffset) {
                    // we had previous data, see if we need to realloc
                    diff = pPasData->size - RL_PPAS_DATA(pRepsFromRef)->size;
                    // adjust blob size (regardless)
                    pRepsFromRef->V1.cb += diff;
                    // realloc if needed
                    if (diff>0) {
                        // note we preserve old ref ptr as well, allow for alignment fixup
                        pRepsFromRef = THReAllocEx(pTHS, pRepsFromRef, pRepsFromRef->V1.cb + sizeof(DWORD));
                    }
                }               // previous data
                else{
                    // no prev PAS data. adjust size, realloc, & set offsets
                    pRepsFromRef->V1.cb += pPasData->size;
                    // note we preserve old ref ptr as well
                    // just in case add alignment space (sizeof(DWORD))
                    pRepsFromRef = THReAllocEx(pTHS, pRepsFromRef, pRepsFromRef->V1.cb+sizeof(DWORD));
                    pRepsFromRef->V1.cbPASDataOffset = pRepsFromRef->V1.cbOtherDraOffset +
                                                       pRepsFromRef->V1.cbOtherDra;
                    // ensure alignment offsets
                    RL_ALIGN_PAS_DATA(pRepsFromRef);
                }               // no previous data
                // copy over
                memcpy(RL_PPAS_DATA(pRepsFromRef), pPasData, pPasData->size);
            }                   // we're given data to set
            else {
                //
                // we're reseting PAS info.
                //
                if ( pRepsFromRef->V1.cbPASDataOffset ) {
                    // we had previous PAS data.
                    // Eliminate it (no need to alloc, just set offsets & counts).
                    Assert(RL_PPAS_DATA(pRepsFromRef)->size);
                    pRepsFromRef->V1.cb = sizeof(REPLICA_LINK) + pRepsFromRef->V1.cbOtherDra;
                    pRepsFromRef->V1.cbPASDataOffset = 0;
                }
                // else, we had none, nothing to do.
            }   // reseting pas data
        }       // update PAS data

        //
        // update USN vector
        //
        if (ulModifyFields & DRS_UPDATE_USN) {
            pRepsFromRef->V1.usnvec = *pusnvecTo;
        }

    } else {

        //
        // DRS_UPDATE_ALL: Update all flags from function params
        //
        DWORD cbRepsFromRef;

        if ((NULL != pRepsFromRef)
            && (0 != memcmp(&pRepsFromRef->V1.usnvec, pusnvecTo,
                            sizeof(USN_VECTOR)))) {
            // We're improving the USN vector for this source; log it.
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_IMPROVING_USN_VECTOR,
                      szInsertUUID(puuidDsaObj),
                      szInsertUSN(pRepsFromRef->V1.usnvec.usnHighObjUpdate),
                      szInsertUSN(pRepsFromRef->V1.usnvec.usnHighPropUpdate),
                      szInsertUSN(pusnvecTo->usnHighObjUpdate),
                      szInsertUSN(pusnvecTo->usnHighPropUpdate),
                      szInsertDN(pNC),
                      NULL,
                      NULL);
        }

        // Making whole value, allocate and set up

        // PAS data: See if we need to allocate mem for PAS data
        // & preserve content in tmp variable. (see comment below about PAS data)
        Assert(pTmpPasData == NULL);                // don't overwrite anything
        if ( pPasData && pPasData->PAS.V1.cAttrs ) {
            // explicit data specified
            pTmpPasData = pPasData;
        }
        else if ( !pPasData &&
                  pRepsFromRef && pRepsFromRef->V1.cbPASDataOffset ){
            // if no explicit erase specified, use old data
            pTmpPasData = RL_PPAS_DATA(pRepsFromRef);
        }
        // else either no PasData passed  and no PasData in old ref.
        // or explicit erase request. Either way, leave empty.
        Assert(!pTmpPasData ||
               (pTmpPasData && pTmpPasData->size) );              // no such thing as empty PAS data.

        // If we're setting PAS cycle, we have to have PAS data.
        Assert((RepFlags & DRS_SYNC_PAS)? (NULL != pTmpPasData) : TRUE);

        // calculate new size:
        //  - structure size
        //  - variable fields:
        //      - mtx address
        //      - pas data.
        // regardless, in allocation we will add sizeof(DWORD) in case of
        // alignmnet adjustments
        cbRepsFromRef = sizeof(REPLICA_LINK) +
                        MTX_TSIZE(pmtx_addr) +
                        (pTmpPasData ? pTmpPasData->size : 0);

        pRepsFromRef = THAllocEx(pTHS, cbRepsFromRef + sizeof(DWORD));

        pRepsFromRef->dwVersion = VERSION_V1;

        pRepsFromRef->V1.cb = cbRepsFromRef;
        pRepsFromRef->V1.usnvec = *pusnvecTo;
        pRepsFromRef->V1.uuidDsaObj = *puuidDsaObj;
        pRepsFromRef->V1.uuidInvocId = *puuidInvocId;
        pRepsFromRef->V1.uuidTransportObj = *puuidTransportObj;
        pRepsFromRef->V1.ulReplicaFlags = RepFlags;

        pRepsFromRef->V1.cbOtherDraOffset = offsetof( REPLICA_LINK, V1.rgb );
        pRepsFromRef->V1.cbOtherDra = MTX_TSIZE(pmtx_addr);
        memcpy (RL_POTHERDRA(pRepsFromRef), pmtx_addr, MTX_TSIZE(pmtx_addr));

        if ( NULL != prtSchedule ) {
            memcpy( &pRepsFromRef->V1.rtSchedule, prtSchedule, sizeof( REPLTIMES ) );
        }

        pRepsFromRef->V1.ulResultLastAttempt = ulResultThisAttempt;
        pRepsFromRef->V1.timeLastAttempt     = timeLastAttempt;
        pRepsFromRef->V1.timeLastSuccess     = timeLastSuccess;
        pRepsFromRef->V1.cConsecutiveFailures= cConsecutiveFailures;

        pRepsFromRef->V1.dwReserved1 = 0;   // cleanup old uses
        //
        // PAS data:
        // If data was passed, use it. Note that to erase PAS data on a
        // DRS_UPDATE_ALL call, the request must be explicit-- i.e. pass in
        // PasData w/ 0 cAttrs (though size != 0).
        // This is done in order to prevent uninterested callers from erasing PAS data.
        //
        if ( pTmpPasData ) {
                // can't have reference to pas data w/ no info
                pRepsFromRef->V1.cbPASDataOffset = pRepsFromRef->V1.cbOtherDraOffset +
                                                   pRepsFromRef->V1.cbOtherDra;
                // ensure alignment and copy over
                RL_ALIGN_PAS_DATA(pRepsFromRef);
                Assert(pTmpPasData->size);
                memcpy(RL_PPAS_DATA(pRepsFromRef), pTmpPasData, pTmpPasData->size);
        }
    }


    Assert( !IsBadReadPtr( pRepsFromRef, pRepsFromRef->V1.cb ) );
    Assert( pRepsFromRef->V1.cbOtherDraOffset == offsetof( REPLICA_LINK, V1.rgb ) );
    Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );
    VALIDATE_REPLICA_LINK_SIZE(pRepsFromRef);
    Assert( 0 == pRepsFromRef->V1.cbPASDataOffset ||
            ( COUNT_IS_ALIGNED(pRepsFromRef->V1.cbPASDataOffset, ALIGN_DWORD) &&
              POINTER_IS_ALIGNED(RL_PPAS_DATA(pRepsFromRef), ALIGN_DWORD)) );

    // Make sure we don't already have a Reps-From for this Invocation-ID,
    // network address, or DSA object.

    fNewRefHasDsaGuid = !fNullUuid(&pRepsFromRef->V1.uuidDsaObj);
    fNewRefHasInvocId = !fNullUuid(&pRepsFromRef->V1.uuidInvocId);

    while (!DBGetAttVal_AC(pTHS->pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsFromRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsFromRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fNewRefHasDsaGuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsFromRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) )
             || (    fNewRefHasInvocId
                  && !memcmp( &pExistingRef->V1.uuidInvocId,
                              &pRepsFromRef->V1.uuidInvocId,
                              sizeof(UUID ) ) ) )
        {
            ret = DRAERR_RefAlreadyExists;
            goto Cleanup;
        }
    }


    // Add the new Reps-From.

    ret = DBAddAttVal( pTHS->pDB, ATT_REPS_FROM, pRepsFromRef->V1.cb, pRepsFromRef );
    if (ret){
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // Update object, but indicate that we don't want to
    // awaken any ds_waits on this object (since we're only updating
    // repsfrom).

    if (DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                    NULL, META_STANDARD_PROCESSING)) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // current code path does not permit reaching this point
    // on non-success. trap changes.
    Assert(DRAERR_Success == ret);

Cleanup:
    //
    // Do whatever cleanup we can
    //

    if ( pExistingRef ) {
        THFree(pExistingRef);
    }
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drancrep.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drancrep.c
//
//--------------------------------------------------------------------------
/*++

ABSTRACT:

    Worker routines to perform inbound replication.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                 // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <sdprop.h>                     // for SDP critical sections

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRANCREP:" /* define the subsystem for debugging */

// DRA headers
#include "drs.h"
#include "dsaapi.h"
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "drasig.h"             //DraXXXWriteableNc
#include "draerror.h"
#include "drancrep.h"
#include "draasync.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drasch.h"
#include "drsdra.h"  // for draReportSyncProgress
#include "samsrvp.h" // for SampAcquireReadLock
#include "xdommove.h"
#include "draaudit.h"

#include <fileno.h>
#define  FILENO FILENO_DRANCREP

// Number of packets we process before updating our on-disk USN vector.  See
// comments in ReplicateNC().
#define UPDATE_REPSFROM_PACKET_INTERVAL (10)

// Prototypes

void  GetUSNForExtendedOp(DSNAME *pOwner, DSNAME *pNC, USN_VECTOR *usnvecFrom);

ENTINF*
GetNcPreservedAttrs(
    IN  THSTATE     *pTHS,
    IN  DSNAME      *pNC);

// These are counts of priority oeprations pending and are used to determine
// if we should abandon a synchronize operation.

extern ULONG gulAsyncPriorityOpsWaiting;
extern ULONG gulSyncPriorityOpsWaiting;

// This flag indicates whether the current operation is a priority
// operation or not.

extern BOOL gfCurrentThreadPriority;

// This is the maximum number of entries and bytes that we ask for at a time,
// set via a registry variable.
ULONG gcMaxIntraSiteObjects = 0;
ULONG gcMaxIntraSiteBytes = 0;
ULONG gcMaxInterSiteObjects = 0;
ULONG gcMaxInterSiteBytes = 0;

// Counts to calculate efficiency of pre-fetching packets in ReplicateNC().
DWORD gcNumPreFetchesTotal = 0;
DWORD gcNumPreFetchesDiscarded = 0;

// Maximum number of milliseconds we have to wait for the SDP lock before we
// whine to the event log.  Optionally configured via the registry.
ULONG gcMaxTicksToGetSDPLock = 0;

// Wait 15 to 30 seconds for the schema cache to be reloaded
DWORD gInboundCacheTimeoutInMs = 15000;

// This is purely for debugging purposes, and (if set) is the address of the
// last other server we attempted a ReplicaSync call to.

UNALIGNED MTX_ADDR * pLastReplicaMTX = NULL;
extern CRITICAL_SECTION csLastReplicaMTX;

#define VALUES_APPLIED_PER_TRANS 100

#define SCHEDULE_UNIT (15 * 60) // 15 min in seconds

// Forward declarations

void
draHandleNameCollision(
    IN      THSTATE *                   pTHS,
    IN      SYNTAX_INTEGER              itInbound,
    IN      PROPERTY_META_DATA_VECTOR * pInboundMetaDataVec,
    IN      DSNAME *                    pPreviousDN,
    IN      DSNAME *                    pParentDN,
    IN      ATTRTYP                     RDNType,
    IN OUT  ATTR *                      pInboundRDN,
    IN OUT  DSNAME **                   ppInboundDN,
    OUT     BOOL *                      pfRetryUpdate
    );


/* AttrValFromAttrBlock - Given a attr block extract the (first) value of
*       the attribute given by 'atype'. The value is returned (in external
*       form ) through 'pVal', a pointer to the ATTR structure that the
*       value was extracted from is also returned through 'ppAttr'.
*
*  Notes: It is the caller's responsibility to ensure that pVal points to an
*       area big enougth to accept the value.
*
*  Returns:
*       ATTR_PRESENT_VALUE_RETURNED if a value is extracted.
*       ATTR_PRESENT_NO_VALUES  if the attribute has no values.
*       ATTR_NOT_PRESENT if the attribute does not exist
*
*       The return values are chosen so that the function returns TRUE if
*       no values are returned.
*/
USHORT
AttrValFromAttrBlock(
    IN  ATTRBLOCK * pAttrBlock,
    IN  ATTRTYP     atype,
    OUT VOID *      pVal,       OPTIONAL
    OUT ATTR **     ppAttr      OPTIONAL
    )
{
    ULONG      i;

    if (ppAttr) {
        *ppAttr = NULL;
    }

    for(i = 0; i < pAttrBlock->attrCount; i++) {
        if (pAttrBlock->pAttr[i].attrTyp == atype) {
            if (pAttrBlock->pAttr[i].AttrVal.valCount == 0) {
                return ATTR_PRESENT_NO_VALUES;
            }

            if (NULL != pVal) {
                memcpy(pVal, pAttrBlock->pAttr[i].AttrVal.pAVal->pVal,
                       pAttrBlock->pAttr[i].AttrVal.pAVal->valLen);
            }

            if (ppAttr) {
                *ppAttr = &(pAttrBlock->pAttr[i]);
            }

            return ATTR_PRESENT_VALUE_RETURNED;
        }
    }

    return ATTR_NOT_PRESENT;
}

USHORT
AttrDeletionStatusFromPentinf (
        ENTINF *pent
    )
/*++
Description:
    Given a ENTINF 'pent' (attribute update list), determine whether object
    is being deleted, having its deletion reversed, or that nothing is
    changing regarding its deletion.

Arguments:
    pent - attribute update list

Return Values:
    OBJECT_NO_DELETION_CHANGE - No change in deletion status
    OBJECT_BEING_DELETED - attribute IS_DELETED present and set to 1
    OBJECT_DELETION_REVERSED - attribute IS_DELETED present, either
        with no values, or set to 0

    The return values are chosen so that the function returns TRUE if
    if there was a status change
--*/
{
    SYNTAX_INTEGER isDeleted;
    USHORT result;

    switch (AttrValFromAttrBlock(&pent->AttrBlock, ATT_IS_DELETED, &isDeleted,
                                 NULL)) {

    case ATTR_PRESENT_VALUE_RETURNED:
        // Attribute present with a value.
        if (isDeleted == 0L) {
            return OBJECT_DELETION_REVERSED;
        } else {
            return OBJECT_BEING_DELETED;
        }

    case ATTR_PRESENT_NO_VALUES:
        // Attribute present with no value.
        return OBJECT_DELETION_REVERSED;

    default:
        Assert(!"Logic error!");
        // fall through...

    case ATTR_NOT_PRESENT:
        // Attribute not found.
        return OBJECT_DELETION_NOT_CHANGED;
    }
} /* AttrDeletionStatusFromAttrBlock */


/* RenameLocalObj - Rename the object given by dsname pName
*
*       It is assumed that the object to be renamed already exists
*       in the local DB, and the currency is on that object. We also
*       assume there is an open write transaction.
*
*       If fMoveToLostAndFound is TRUE then we will also set the LastKnownParent attribute
*
* pAttrRdn - RDN attribute containing new name
* pObjectGuid - GUID of the object to be renamed
* pParentGuid - Guid of the new parent
* pMetaDataVecRemote - remote meta data vector that came with the
*                      replication packet
* fMoveToLostAndFound - TRUE, if this operation is a special move to
*                       LostAndFound
* fDeleteLocalObj - Will object be deleted in applying this change?
*
* Note:
*       By using the DSA LocalModifyDN function we ensure appropriate system
*       attributes are not modified.
*
* Returns:
*       0 if the object is successfully renamed, an appropriate error if not.
*/
ULONG
RenameLocalObj(
    THSTATE                     *pTHS,
    ULONG                       dntNC,
    ATTR                        *pAttrRdn,
    GUID                        *pObjectGuid,
    GUID                        *pParentGuid,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )
{
    MODIFYDNARG modDNArg;
    MODIFYDNRES modDNRes;
    ULONG       cbReturned;
    DSNAME *    pNewDSName;
    DSNAME *    pLocalParent = NULL;
    DSNAME *    pLocalName = NULL;
    DSNAME *    pNewLocalParent = NULL;
    BOOL        bNewLocalParentAllocd = FALSE;
    BOOL        fLocalPhantomParent = FALSE;
    ULONG       dntObj = 0;
    DBPOS *     pDB = pTHS->pDB;
    BOOL        fNameCollisionHandled = FALSE;
    BOOL        fRetryUpdate;
    DWORD       err;
    BOOL        fIsObjAlreadyDeleted;
    BOOL        fIsMove;
    SYNTAX_INTEGER it;

    Assert( pAttrRdn->AttrVal.valCount == 1 );
    Assert( pAttrRdn->AttrVal.pAVal->valLen != 0 );
    Assert( pAttrRdn->AttrVal.pAVal->pVal != NULL );
    Assert( pAttrRdn->attrTyp == ATT_RDN );

    DPRINT3(2, "RenameLocalObj, new RDN = '%*.*ws'\n",
            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
            pAttrRdn->AttrVal.pAVal->pVal);

    // save the current DNT (so that we can restore currency quickly)
    dntObj = pTHS->pDB->DNT;

    // currency is on the local object - get its DSNAME
    if (DBGetAttVal(pDB,
                    1,
                    ATT_OBJ_DIST_NAME,
                    DBGETATTVAL_fREALLOC,
                    0,
                    &cbReturned,
                    (LPBYTE *) &pLocalName)) {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // Get the instance type of the object
    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

    fIsObjAlreadyDeleted = DBIsObjDeleted(pDB);

    // When using ModDn, attrTyp must match the class-specific RDN attribute
    if (DBGetSingleValue(pDB,
                         FIXED_ATT_RDN_TYPE,
                         &(pAttrRdn->attrTyp),
                         sizeof(DWORD), NULL)) {
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // get the local parents DSNAME
    pLocalParent = (DSNAME *) THAllocEx(pTHS, pLocalName->structLen);
    if (TrimDSNameBy(pLocalName, 1, pLocalParent)) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    if (FillGuidAndSid (pLocalParent)) {
        fLocalPhantomParent = TRUE;
        // We allow the replicator to move an object with a phantom parent
        // Note that in this code path, pLocalParent doesnt have a guid
    }

    // We do not allow moves of NC HEADs

    fIsMove = (0 == (it & IT_NC_HEAD))
        && (NULL != pParentGuid)
        && (0 != memcmp(&pLocalParent->Guid, pParentGuid, sizeof(GUID)));

    // initialize the modDNArg parameters with the appropriate values;
    memset(&modDNArg, 0, sizeof(modDNArg));
    memset(&modDNRes, 0, sizeof(modDNRes));
    modDNArg.pObject = pLocalName;
    modDNArg.pNewRDN = pAttrRdn;
    modDNArg.pNewParent = NULL;
    modDNArg.pMetaDataVecRemote = pMetaDataVecRemote;
    modDNArg.pDSAName = NULL;
    modDNArg.fAllowPhantomParent = fLocalPhantomParent;
    InitCommarg(&modDNArg.CommArg);

    if (fIsMove) {
        // Both the local and remote parents exist and are different
        // so this is a move
        pNewLocalParent = THAllocEx(pTHS, DSNameSizeFromLen(0));
        bNewLocalParentAllocd = TRUE;
        pNewLocalParent->Guid = *pParentGuid;
        pNewLocalParent->NameLen = 0;
        pNewLocalParent->structLen = DSNameSizeFromLen( 0 );

        if (DBFindDSName(pDB, pNewLocalParent)
            || (!fIsObjAlreadyDeleted
                && !fDeleteLocalObj
                && DBIsObjDeleted(pDB))) {
            // New parent doesn't exist *or* applying this change would result
            // in a live object underneath a deleted parent.  Re-request packet,
            // getting parent objects, too, in case the parent has been
            // resuscitated.  (Or if we have already done so, move this object
            // to the lost & found.)
            return DRAERR_MissingParent;
        }

        // currency is now on the new parent - get its DN
        if (DBGetAttVal(pDB, 1, ATT_OBJ_DIST_NAME, DBGETATTVAL_fREALLOC,
                0, &cbReturned, (LPBYTE *) &modDNArg.pNewParent))
        {
            DRA_EXCEPT(DRAERR_DBError, 0);
        }

        if (NamePrefix(pLocalName, modDNArg.pNewParent)) {
            // New parent is a child of the object we're moving.  This can
            // occur when the parent object has also been moved on the source
            // DSA, but we haven't yet seen that rename in the replication
            // stream.  Re-request the packet, inserting the parent records
            // into the replication stream first.
            DPRINT2(1, "New parent %ls is a child of %ls!\n",
                    pLocalName->StringName, modDNArg.pNewParent->StringName);
            return DRAERR_MissingParent;
        }

        if ((INVALIDDNT != dntNC)
            && (pDB->NCDNT != dntNC)
            && (pDB->DNT != dntNC)) {
            // The new parent object is in the wrong NC; i.e., it has been
            // moved across domains, and the source (remote) and dest
            // (local) DSAs don't agree on which NC the object is
            // currently in.  This is a transient condition that will be
            // rectified by replicating in the  other direction and/or
            // by replicating the other NC involved.
            DPRINT2(0,
                    "Cannot move object %ls because its local parent to-be "
                        "%ls is in an NC other than the one being replicated "
                        "-- should be a transient condition.\n",
                    pLocalName->StringName,
                    modDNArg.pNewParent->StringName);
            DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
        }

        pNewLocalParent = modDNArg.pNewParent;
    }
    else {
        pNewLocalParent = pLocalParent;
        // set bNewLocalParentAllocd to FALSE at beginning of function.
    }

    do {
        fRetryUpdate = FALSE;

        DBFindDNT(pDB, dntObj);

        if (NULL == modDNArg.pResObj) {
            modDNArg.pResObj = CreateResObj(pDB, modDNArg.pObject);
        }

        __try {
            LocalModifyDN(pTHS, &modDNArg, &modDNRes, FALSE);
            err = RepErrorFromPTHS(pTHS);
        }
        __except (GetDraNameException(GetExceptionInformation(), &err)) {
            // String name of the inbound object conflicts with that of a
            // pre-existing local object.
            if (!fNameCollisionHandled) {
                // Construct the DN of the post-renamed object.
                SpliceDN(pTHS,
                            pLocalName,
                            pNewLocalParent,
                            (WCHAR *) pAttrRdn->AttrVal.pAVal->pVal,
                            pAttrRdn->AttrVal.pAVal->valLen / sizeof(WCHAR),
                            pAttrRdn->attrTyp,
                            &pNewDSName);

                draHandleNameCollision(pTHS,
                                       modDNArg.pResObj->InstanceType,
                                       pMetaDataVecRemote,
                                       modDNArg.pObject,
                                       pNewLocalParent,
                                       pAttrRdn->attrTyp,
                                       pAttrRdn,
                                       &pNewDSName,
                                       &fRetryUpdate);

                fNameCollisionHandled = TRUE;
            }
        }
    } while (fRetryUpdate);

    THFreeEx(pTHS, modDNArg.pResObj);

    // Currency when we entered this function was on the object that was
    // renamed. Reset the currency back to the same object upon return.
    DBFindDNT( pDB, dntObj );

    if (fMoveToLostAndFound)
    {
        ULONG retErr;

        // We have just moved an orphaned object to Lost and found - set its
        // last known parent value
        // Note that if fLocalPhantomParent is true, then this DSNAME names a phantom
        // and does not have a guid.
        if (retErr = DBReplaceAttVal(pDB, 1, ATT_LAST_KNOWN_PARENT,
                        pLocalParent->structLen, pLocalParent))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }

        if (retErr = DBRepl( pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING ))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    if(pLocalParent != NULL) THFreeEx(pTHS, pLocalParent);
    if(bNewLocalParentAllocd && pNewLocalParent != NULL) THFreeEx(pTHS, pNewLocalParent);

    return err;
}

/* ModifyLocalObj - Modify the object given by 'pDN' at the local DSA.
*       'pAttrBlock' gives this list of attributes to be modified and the
*       new value(s) to give them.
*       Only the attributes mentioned in 'pAttrBlock' are changed.
*
*       It is assumed that the object to be modifed already exists.
*
* Note:
*       By using the DSA LocalModify function we ensure appropriate system
*       attributes are not modified.
*
* Returns:
*       0 if the object is successfully modified, an appropriate error if not.
*/
ULONG
ModifyLocalObj(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    DSNAME *                    pName,
    ATTRBLOCK *                 pAttrBlock,
    GUID *                      pParentGuid,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )
{
    ULONG           ret = 0;
    DBPOS *         pDB = pTHS->pDB;
    MODIFYARG       modarg;
    ATTRMODLIST *   pModList, *pModNext, *pModLast;
    ATTRMODLIST *   rgattrmodlist;
    ULONG           modCount = pAttrBlock->attrCount;
    ULONG           i;
    BOOL            fIsRename = FALSE;
    ATTR *          pAttrRdn;
    SYNTAX_TIME     timeCreatedRemote, timeCreatedLocal;
    SYNTAX_INTEGER  instanceType = 0;

    Assert(0 != modCount);
    if (modCount == 0)
        return 0;

    if (DBFindDSName(pDB, pName))
    {
        // We should not get here, the DRA should have previously
        // confirmed that this object does infact exist.
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // Duplicate guid detection.
    // See if we are trying to apply creation time attributes to an existing object.
    // The WhenCreated timestamp acts as an unchanging internal id of the object.  Even
    // if two objects get created with the same external id, the guid, we can distinguish
    // them based on their WhenCreated timestamp. This check allows for the attribute to
    // be rewritten with the same value, but never with a different one.
    // Skip this check if deleted so replication can be easily repaired.

    if ( (!fDeleteLocalObj) &&
         (gfStrictReplicationConsistency) &&
         (!DBGetSingleValue(pDB, ATT_INSTANCE_TYPE, &instanceType, sizeof(SYNTAX_INTEGER), NULL)) &&
         ( (instanceType & IT_NC_HEAD) == 0) &&
         (!AttrValFromAttrBlock(pAttrBlock, ATT_WHEN_CREATED, &timeCreatedRemote, NULL)) &&
         (!DBGetSingleValue(pDB, ATT_WHEN_CREATED, &timeCreatedLocal, sizeof(SYNTAX_TIME), NULL)) &&
         (memcmp(&timeCreatedLocal,&timeCreatedRemote,sizeof(SYNTAX_TIME))) ) {
        Assert( "Duplicate guid? Tried to merge two objects together!?" );
        DRA_EXCEPT (ERROR_DS_OBJ_GUID_EXISTS, 0);
    }

    memset(&modarg, 0, sizeof(modarg));
    modarg.pObject = pName;
    modarg.pMetaDataVecRemote = pMetaDataVecRemote;
    modarg.count = 0;
    InitCommarg(&modarg.CommArg);
    // Allow removal of non-existant values and addition of already-present values.
    // This can happen, for example, when replicating in a deletion (with
    // attribute removals), and the local object is already deleted, or
    // does not hold all the attributes being removed.
    modarg.CommArg.Svccntl.fPermissiveModify = TRUE;
    modarg.pResObj = CreateResObj(pDB, modarg.pObject);

    // Allocate memory for Modify List - Note we do not use THAlloc here
    // so that we can clean it up immediately we are done with it.

    // Note that because the first ATTRMODLIST structure is actually embedded
    // in the MODIFYARG, we build the linked list of ATTRMODLIST structures
    // using three pointers:
    //
    //      pModList -  the next structure to fill in
    //      pModNext -  the next "free" structure (the next-next structure to
    //                  fill in)
    //      pModLast -  the last structure we filled in (the tail)

    rgattrmodlist = THAllocEx(pTHS, sizeof(ATTRMODLIST)*(modCount-1));
    pModNext = rgattrmodlist;
    pModList = &(modarg.FirstMod);
    pModLast = pModList;

    for ( i = 0; i < pAttrBlock->attrCount; i++ )
    {
        if (ATT_RDN == pAttrBlock->pAttr[i].attrTyp)
        {
            // Replicating a rename - need to go through LocalModifyDN
            fIsRename = TRUE;
            pAttrRdn = &(pAttrBlock->pAttr[i]);
        }
        else
        {
            if (!pAttrBlock->pAttr[i].AttrVal.valCount)
            {
                pModList->choice = AT_CHOICE_REMOVE_ATT;
            }
            else if(DBHasValues(pDB, pAttrBlock->pAttr[i].attrTyp))
            {
                pModList->choice = AT_CHOICE_REPLACE_ATT;
            }
            else
            {
                pModList->choice = AT_CHOICE_ADD_ATT;
            }

            pModList->AttrInf = pAttrBlock->pAttr[i];
            pModLast = pModList;
            pModList->pNextMod = pModNext;
            pModList = pModNext++;
            modarg.count++;
        }
    }

    pModLast->pNextMod = NULL;

    if (fIsRename) {
        // replicating a rename, and bad deletion case also
        ret = RenameLocalObj(pTHS,
                             dntNC,
                             pAttrRdn,
                             &(pName->Guid),
                             pParentGuid,
                             pMetaDataVecRemote,
                             fMoveToLostAndFound,
                             fDeleteLocalObj);
        if (ret) {
            return ret;
        }
    }

    Assert(modarg.count <= modCount);

    if (modarg.count) {
        LocalModify(pTHS, &modarg);
        ret = RepErrorFromPTHS(pTHS);
    }

    THFreeEx(pTHS, modarg.pResObj);
    THFreeEx(pTHS, rgattrmodlist);

    return ret;
}


ULONG
ModifyLocalObjRetry(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    DSNAME *                    pName,
    ATTRBLOCK *                 pAttrBlock,
    GUID *                      pParentGuid,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    )

/*++

Routine Description:

    This routine extends the semantics of ModifyLocalObj() by wrapping it.
    The purpose of this routine is to catch record too big exceptions, modify
    the attribute list to apply fewer attributes, and to retry the operation.

Arguments:

    pTHS -
    pName -
    pAttrBlock -
    pParentGuid -
    pMetaDataVecRemote -
    fMoveToLostAndFound -
    fDeleteLocalObj -

Return Value:

    ULONG -

--*/

{
    BOOL fRetryUpdate = FALSE;
    DWORD err;
    DSTIME timeNow = 0;  // gets filled in the first time used
    USN usnLocal = 0;

    do {
        __try {
            err = ModifyLocalObj(
                pTHS,
                dntNC,
                pName,
                pAttrBlock,
                pParentGuid,
                pMetaDataVecRemote,
                fMoveToLostAndFound,
                fDeleteLocalObj
                );

            // If this a retry and we were successful...
            if ( (!err) && fRetryUpdate) {
                DPRINT1( 1, "ReplPrune: successfully modified RTB update for %ws\n",
                         pName->StringName );
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_RECORD_TOO_BIG_SUCCESS,
                          szInsertDN(pName),
                          szInsertUUID(&(pName->Guid)),
                          NULL);
            }
            fRetryUpdate = FALSE;
        }
        __except (GetDraRecTooBigException(GetExceptionInformation(), &err)) {
            // Modification causes record to exceed maximum size

            // We were in an update which failed, abort it
            DBCancelRec( pTHS->pDB );

            // Remove some attributes and try again
            fRetryUpdate = ReplPruneOverrideAttrForSize(
                pTHS,
                pName,
                &timeNow,
                &usnLocal,
                pAttrBlock,
                pMetaDataVecRemote
                );
        }
    } while (fRetryUpdate);

    return err;
} /* ModifyLocalObjRetry */

/* ModLocalAtt - Modify a single attribute (given by 'atype') on an object
*       (given by 'pDN) on the local DSA. Replaces the attribute's value(s)
*       with the single value specified by 'pVal', 'size'
*
*  Returns:
*       0 if successful an appropriate error code if not.
*/
ULONG
ModLocalAtt(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pName,
    IN  ATTRTYP     atype,
    IN  ULONG       size,
    IN  VOID *      pVal
    )
{
    ATTRBLOCK attrBlock;
    ATTR      attr;
    ATTRVAL   attrval;

    attrBlock.attrCount = 1;
    attrBlock.pAttr = &attr;
    attr.attrTyp = atype;
    attr.AttrVal.valCount = 1;
    attr.AttrVal.pAVal = &attrval;
    attrval.valLen=size;
    attrval.pVal=pVal;

    return ModifyLocalObj(pTHS, INVALIDDNT, pName, &attrBlock, NULL, NULL, FALSE, FALSE);
}


VOID
modifyLocalValue(
    IN  THSTATE *   pTHS,
    IN  ATTCACHE *  pAC,
    IN  BOOL        fPresent,
    IN  ATTRVAL *   pAVal,
    IN  DSNAME *    pdnValue,
    IN  VALUE_META_DATA *pRemoteValueMetaData
    )

/*++

Routine Description:

Apply the given attribute value locally.

Note that the calls below us are not set up to take pass-in
remote value metadata. We pass it down in the DBPOS.

Arguments:

    pTHS -
    pAC - ATTCACHE of attribute
    fPresent - Whether value is being made present or absent
    pAVal - ATTRVAL of actual value
    pdnValue - Pointer to the DSNAME inside the ATTRVAL, for logging
    pRemoteValueMetaData - remote metadata to be applied

Return Value:

   Exceptions raised

--*/

{
    ULONG ret;

    Assert( pTHS->fDRA );

    if (fPresent) {
        ret = DBAddAttValEx_AC(pTHS->pDB,
                               pAC,
                               pAVal->valLen,
                               pAVal->pVal,
                               pRemoteValueMetaData );
        switch (ret) {
        case DB_success:
        case DB_ERR_VALUE_EXISTS:
            ret = 0;
            break;
        default:
            DPRINT4( 0, "DRA DBAddAttVal_AC obj %s attr %s value %ls failed with db error %d\n",
                     GetExtDN( pTHS, pTHS->pDB), pAC->name, pdnValue->StringName, ret );
            DRA_EXCEPT (DRAERR_DBError, ret);
        }
    } else {
        ret = DBRemAttValEx_AC(pTHS->pDB,
                               pAC,
                               pAVal->valLen,
                               pAVal->pVal,
                               pRemoteValueMetaData );
        switch (ret) {
        case DB_success:
        case DB_ERR_VALUE_DOESNT_EXIST:
        case DB_ERR_NO_VALUE:
            ret = 0;
            break;
        default:
            DPRINT4( 0, "DRA DBRemAttVal_AC obj %s attr %s value %ls failed with db error %d\n",
                     GetExtDN( pTHS, pTHS->pDB), pAC->name, pdnValue->StringName, ret );
            DRA_EXCEPT (DRAERR_DBError, ret);
        }
    }

} /* modifyLocalValue */

/* ChangeInstanceType - change the instance type of object 'pDN' to 'it' on
*       the local DSA.
*
*  Returns:
*       0 if successful an error code if not.
*/
ULONG
ChangeInstanceType(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pName,
    IN  SYNTAX_INTEGER  it,
    IN  DWORD           dsid
    )
{
    DWORD ret;

    Assert(ISVALIDINSTANCETYPE(it));
    Assert(pTHS->fDRA);
    ret = ModLocalAtt(pTHS,
                      pName,
                      ATT_INSTANCE_TYPE,
                      sizeof(SYNTAX_INTEGER),
                      &it);
    if (!ret) {
        // Support for generating a change history of instance types
        DPRINT3( 1, "0x%x: %ls instanceType=0x%x\n",
                 dsid, pName->StringName, it );
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_SET_IT,
                 szInsertDN(pName),
                 szInsertHex(it),
                 szInsertHex(dsid));
    }
    return ret;
}

/* DeleteLocalObj - Delete the object given by 'pDN' on the local DSA.
*
*       If fGarbCollectASAP is TRUE, we convert the object into a phantom
*       and mark it for immediate garbage collection (which will be attempted
*       the next time garbage collection is run, which given the defaults
*       might be up to 12 hours from now).
*
*  Returns:
*       0 if successful, an error code otherwise.
*/
ULONG
DeleteLocalObj(
    THSTATE *                   pTHS,
    DSNAME *                    pDN,
    BOOL                        fPreserveRDN,
    BOOL                        fGarbCollectASAP,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    )
{
    REMOVEARG removeArg;

    DPRINT1(1, "Deleting object (%S)\n", pDN->StringName);

    Assert(CheckCurrency(pDN));

    // Must never preserve RDN if we're converting the object into a tombstone
    // -- otherwise no live object may be created with this object's name.
    Assert(!(fPreserveRDN && !fGarbCollectASAP));

    // Must never mangle RDN if we're converting it into a phantom --
    // otherwise we will e.g. leave forward links to what appears to be a
    // tombstone name.
    Assert(!(!fPreserveRDN && fGarbCollectASAP));

    memset(&removeArg, 0, sizeof(removeArg));
    removeArg.pObject = pDN;
    removeArg.fGarbCollectASAP = fGarbCollectASAP;
    removeArg.pMetaDataVecRemote = pMetaDataVecRemote;
    removeArg.fPreserveRDN = fPreserveRDN || fNullUuid(&pDN->Guid);
    removeArg.pResObj = CreateResObj(pTHS->pDB, pDN);

    LocalRemove(pTHS, &removeArg);

    THFreeEx(pTHS, removeArg.pResObj);

    return RepErrorFromPTHS(pTHS);
}

/* DeleteRepObj - Removes replica of an object.
*
*       This routine handles the removal of a replicated object. The object
*       may be deleted, or its instance type may be modified to indicate
*       that we no longer have a replica of this object.
*
*       fNotRoot indicates if this object is the root of an NC
*
*       If fGarbCollectASAP is TRUE, we convert the object into a phantom
*       and mark it for immediate garbage collection (which will be attempted
*       the next time garbage collection is run, which given the defaults
*       might be up to 12 hours from now).
*/
ULONG
DeleteRepObj (
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pDN,
    IN  BOOL                        fPreserveRDN,
    IN  BOOL                        fGarbCollectASAP,
    IN  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote  OPTIONAL
    )
/*++

Routine Description:

    Delete an interior node of an NC.  Converts the object into a tombstone
    or directly into a phantom, as directed by the caller.

Arguments:

    pTHS (IN)

    pDN (IN) - Name of the object to delete.

    fPreserveRDN (IN) - If true, don't delete-mangle the RDN.

    fGarbCollectASAP (IN) - If true, convert the object directly into a phantom
        without going through the usual interim tombstone state.  Typically used
        only during NC teardown.

    pMetaDataVecRemote (IN, OPTIONAL) - The meta data associated with the
        inbound object update that instructed us to delete the object (if any).

Return Values:

    0 or Win32 error.

--*/
{
    ULONG ret = 0;
    SYNTAX_INTEGER it;

    // Should always supply meta data if we're converting the object into a
    // tombstone (otherwise, this would be an originating delete -- we don't
    // currently do those).
    Assert(!(!fGarbCollectASAP && (NULL == pMetaDataVecRemote)));

    Assert(CheckCurrency(pDN));
    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));

    Assert(ISVALIDINSTANCETYPE(it));

    switch (it) {

        // This is the scenario where we are deleting objects above
        // another NC.

    case NC_MASTER_SUBREF:
    case NC_MASTER_SUBREF_COMING:
    case NC_MASTER_SUBREF_GOING:
    case NC_FULL_REPLICA_SUBREF:
    case NC_FULL_REPLICA_SUBREF_COMING:
    case NC_FULL_REPLICA_SUBREF_GOING:
        ret = ChangeInstanceType(pTHS, pDN, it & ~IT_NC_ABOVE, DSID(FILENO,__LINE__));
        break;

        // We may get this in certain failure conditions such as when we
        // have partially deleted an NC above another NC, including modifying
        // a subordinate NC's instance type, and then on the
        // retry we find the subordinate NC again as part of the NC we're
        // deleting. We don't want to delete the NC master of the
        // subordinate NC, so ignore it.

        // JeffParh 2000-04-14 - We can and should avoid this situation by
        // ensuring that NCDNT == ROOTTAG on all NC heads without
        // IT_NC_ABOVE.
        // Wlees 2002-04-11 - We do now (almost two years later)

    case NC_MASTER:
    case NC_MASTER_COMING:
    case NC_MASTER_GOING:
    case NC_FULL_REPLICA:
    case NC_FULL_REPLICA_COMING:
    case NC_FULL_REPLICA_GOING:
        Assert( !"These should not be found in our NCDNT" );
        break;

    case INT_MASTER:
    case SUBREF:
    case INT_FULL_REPLICA:
        ret = DeleteLocalObj(pTHS,
                             pDN,
                             fPreserveRDN,
                             fGarbCollectASAP,
                             pMetaDataVecRemote);
        break;

    default:
        DRA_EXCEPT(DRAERR_InternalError, ERROR_DS_BAD_INSTANCE_TYPE);
        break;
    }

    return ret;
}

ULONG
DeleteNCRoot(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    )
/*++

Routine Description:

    Remove an NC root object as part of an NC teardown.  Removal of the object
    may consist of converting it into a subref, tombstone, and/or phantom,
    depending upon its context.

Arguments:

    pTHS (IN)

    pNC (IN) - Name of the NC root object.  Must not have remaining interior
        nodes.

Return Values:

    0 or Win32 error.

--*/
{
    ULONG ret = 0;
    SYNTAX_INTEGER it;

    Assert(CheckCurrency(pNC));
    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, (VOID *) &it, sizeof(it));

    Assert(ISVALIDINSTANCETYPE(it));
    Assert(it & IT_NC_GOING);

    if (NULL == SearchExactCrossRef(pTHS, pNC)) {
        // There is no cross-ref corresponding to the domain NC we're
        // removing.  This implies the domain has been removed from the
        // enterprise, and thus we should delete-mangle the RDN of the
        // NC head such that an admin can choose to install a new domain
        // by the same name.

        // By the same token, we must convert subrefs into tombstones
        // rather than phantoms.  This is esp. important in the case where
        // we hold the NC above this one, as machines with auto-generated
        // subrefs (as opposed to subrefs with the properties of the real
        // NC head, like this one) will convert their auto-generated subrefs
        // into tombstones in DelAutoSubRef() upon seeing the deletion of
        // the corresponding cross-ref.  That tombstone will then propagate
        // here, and we must still have the subref (live or dead, but not
        // phantomized) to which to apply those inbound changes.

        // Aren't subrefs fun?

        if (it & IT_NC_ABOVE) {
            // Make NC head a pure subref to reflect the fact that the
            // replica contents have been deleted.
            ret = ChangeInstanceType(pTHS, pNC, SUBREF, DSID(FILENO,__LINE__));
        }

        if (!ret) {
            ret = DeleteLocalObj(pTHS,
                                 pNC,
                                 FALSE, // fPreserveRDN
                                 FALSE, // fGarbCollectASAP
                                 NULL);
            if (!ret) {
                CheckNCRootNameOwnership( pTHS, pNC );

                LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                         DS_EVENT_SEV_MINIMAL,
                         DIRLOG_DRA_DELETE_NC_ROOT,
                         szInsertDN(pNC),
                         szInsertUUID(&(pNC->Guid)),
                         szInsertUL(FALSE),
                         szInsertUL(FALSE),
                         szInsertHex(DSID(FILENO,__LINE__)),
                         NULL, NULL, NULL);
            }
        }
    } else if (it & IT_NC_ABOVE) {
        // We hold the NC above this one AND there is a live cross-ref for
        // this NC, so we need to convert this NC head into a pure SUBREF.
        // (This typically occurs when we demote a GC.)

        ret = ChangeInstanceType(pTHS, pNC, SUBREF, DSID(FILENO,__LINE__));

    } else {
        // There is a live cross-ref for this NC but we don't hold an NC
        // above it.  In this case, there's no need to hang on to any sort
        // of subref object for this NC.

        // We bypass the tombstone state and convert the object directly into a
        // phantom.  This preserves any linked references to the NC had, which
        // are still perfectly valid (despite the fact that we will no longer
        // hold the referred-to object).  For similar reasons we preserve the
        // RDN.

        ret = DeleteLocalObj(pTHS,
                             pNC,
                             TRUE, // fPreserveRDN
                             TRUE, // fGarbCollectASAP
                             NULL);
        if (!ret) {
            LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_DELETE_NC_ROOT,
                     szInsertDN(pNC),
                     szInsertUUID(&(pNC->Guid)),
                     szInsertUL(TRUE),
                     szInsertUL(TRUE),
                     szInsertHex(DSID(FILENO,__LINE__)),
                     NULL, NULL, NULL);
        }
    }

    if ( (!ret) && (it & IT_WRITE) ) {
        DraRetireWriteableNc( pTHS, pNC );
    }

    return ret;
}

/* DeleteRepTree - Delete a subtree from a replica NC on the local DSA.
*
*       The root of the subtree is given by 'pDN'.
*
*       fNCPrefix specifies if 'pDN' is an NC prefix object (i.e. if
*       the entire NC is to be deleted).
*/
ULONG
DeleteRepTree(
    IN  THSTATE * pTHS,
    IN  DSNAME *  pNC
    )
{
    ULONG ret = 0;
    PDSNAME pDNTemp = NULL;
    ULONG ncdnt;
    USN usnSeekStart = USN_START;
    ULONG cbSize = 0;
    ULONG cbReturned;
    ULONG dbErr;
    DWORD cNumObjects = 0;
    SYNTAX_INTEGER it;
    ULONG lastError = 0;

    // FInd the NC master
    if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
        DRA_EXCEPT_NOLOG(DRAERR_BadDN, ret);
    }

    // Save the DNT of the NC object
    ncdnt = pTHS->pDB->DNT;

    Assert(FPrefixIt(it));
    Assert(it & IT_NC_GOING);

    // Mark heap such that we can periodically free thread heap allocations.
    TH_mark(pTHS);

    __try {
        // Search for all objects in this NC until we reach the end of the NC
        // or start finding objects we've modified already in this routine.
        while (!GetNextObjByUsn(pTHS->pDB,
                                ncdnt,
                                usnSeekStart,
                                &usnSeekStart)) {
            if (eServiceShutdown) {
                ret = DRAERR_Shutdown;
                break;
            }

            if (IsHigherPriorityDraOpWaiting()) {
                ret = DRAERR_Preempted;
                break;
            }

#ifdef INCLUDE_UNIT_TEST
            // On debug builds, enforce round-robin scheduling to increase
            // cross-nc concurrency
            if (cNumObjects == 100) {
                ret = DRAERR_Preempted;
                break;
            }
#endif

            // Next seek will be for the next USN after that of the object we
            // just found.
            usnSeekStart++;

            // We won't find the NC head on this index.
            Assert(pTHS->pDB->DNT != ncdnt);

            // Get object distinguished name
            dbErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                DBGETATTVAL_fREALLOC, cbSize, &cbReturned,
                                (PUCHAR *) &pDNTemp);

            if ( 0 != dbErr ) {
                ret = DRAERR_DBError;
            }
            else {
                cbSize = max(cbSize, cbReturned);

                // Delete object. TRUE preserve RDN,
                // TRUE garb collect ASAP.
                ret = DeleteRepObj (pTHS, pDNTemp, TRUE, TRUE, NULL);
            }

            if (ret != 0) {
                // Don't bail out of the loop yet, let's delete as many objects as we can.
                // Remember that we had an error though.
                lastError = ret;

                // Clean the thread errors out, because if we clean the heap with
                // TH_free_to_mark() we'll have a pointer (pTHS->pErrInfo into 
                // the free'd memory and an error in pTHS->errCode indicating that
                // pointer should be valid.
                THClearErrors();
                
                // Call DBCancelRec to make sure any cached metadata is freed.
                // If pDB->JetRetrieveBits == 0 then there are no DB side effects.
                // Doing this now rather than at transaction abort time ensures
                // that the meta data vector we have cached (if any) is correctly
                // freed off the marked heap, rather than off the "org" heap.
                DBCancelRec(pTHS->pDB);
            }

            DBTransOut (pTHS->pDB, !ret, TRUE);

            if (0 == (++cNumObjects % 500)) {
                // We've removed a lot of objects and consumed a lot of memory.
                // Release that memory and re-mark the heap.
                TH_free_to_mark(pTHS);
                TH_mark(pTHS);

                pDNTemp = NULL;
                cbSize = 0;

                // Inform interested parties we're making progress.
                gfDRABusy = TRUE;
            }

            DBTransIn (pTHS->pDB);
        }

        if (lastError != 0) {
            // we had an error during the loop, so we should not be deleting this NC...
            ret = lastError;
        }

        if (DRAERR_Success == ret) {
            // Successful so far -- delete the NC head object.

            // Restore currency to NC object
            if (DBFindDNT(pTHS->pDB, ncdnt)) {
                DRA_EXCEPT (DRAERR_InternalError, 0);
            }

            ret = DeleteNCRoot(pTHS, pNC);

            DBTransOut (pTHS->pDB, !ret, TRUE);
            DBTransIn (pTHS->pDB);

        }
    } __finally {
        // Call DBCancelRec to make sure any cached metadata is freed.
        // If pDB->JetRetrieveBits == 0 then there are no DB side effects.
        // Doing this now rather than at transaction abort time ensures
        // that the meta data vector we have cached (if any) is correctly
        // freed off the marked heap, rather than off the "org" heap.
        DBCancelRec(pTHS->pDB);

        TH_free_to_mark(pTHS);
    }

    return ret;
}


ULONG
AddLocalObj(
    IN      THSTATE *                   pTHS,
    IN      ULONG                       dntNC,
    IN      ENTINF *                    pent,
    IN      GUID *                      pParentGuid,
    IN      BOOL                        fIsNCHead,
    IN      BOOL                        fAddingDeleted,
    IN OUT  ATTRBLOCK *                 pAttrBlock,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    IN      BOOL                        fMoveToLostAndFound
    )
/*++

Routine Description:

    Add inbound object to the local database.

Arguments:

    pTHS (IN)

    dntNC (IN) - DNT of the NC being replicated, or INVALIDDNT if the NC head
        has not yet been created.

    pent (IN) - The object to add.

    pParentGuid (IN) - The objectGuid of the parent of the object to add.
        May be NULL only if fIsNCHead.

    fIsNCHead (IN) - TRUE if the inbound object is the head of the NC being
        replicated; FALSE otherwise.

    fAddingDeleted (IN) - TRUE if the inbound object object is deleted.
    
    pMetaDataVecRemote (IN) - Meta data for the inbound object's attributes.

    fMoveToLostAndFound (IN) - If TRUE, the object is locally being moved to the
        lost-and-found container (i.e., as a local originating write, not a
        replicated write).

Return Values:

    DRAERR_Success - Success.

    other DRAERR_* code - Failure.

--*/
{
    ULONG       draError;
    DWORD       dirError;
    ADDARG      addarg = {0};
    WCHAR       szRDN[ MAX_RDN_SIZE ];
    DWORD       cchRDN;
    ATTRTYP     attrtypRDN;
    DSNAME *    pdnLocalParent = NULL;
    DWORD       retErr;
    DBPOS *     pDB = pTHS->pDB;
    DSNAME *    pLastKnownParent = NULL;
    RESOBJ *    pResParent;
    SYNTAX_INTEGER  it;
    ATTR *      pAttrRDN;
    DSNAME *    pDN = pent->pName;

    // Check that enough attributes are present to do an object creation.  They
    // should be, but sometimes the bookmarks get skewed so that the source
    // thinks we have an object that we don't.
    // Must have IT, OBJECT_CLASS, RDN and SD for instantiated objects
    if (AttrValFromAttrBlock(pAttrBlock, ATT_INSTANCE_TYPE, &it, NULL)
        || AttrValFromAttrBlock(pAttrBlock, ATT_OBJECT_CLASS, NULL, NULL)
        || AttrValFromAttrBlock(pAttrBlock, ATT_WHEN_CREATED, NULL, NULL)
        || AttrValFromAttrBlock(pAttrBlock, ATT_RDN, NULL, &pAttrRDN)
        || ( (0 == (it & IT_UNINSTANT)) &&
             (AttrValFromAttrBlock(pAttrBlock, ATT_NT_SECURITY_DESCRIPTOR,
                                   NULL, NULL)) ) ) {
        DraErrMissingObject( pTHS, pent );
    }

    Assert(ISVALIDINSTANCETYPE(it));

    // Retrieve RDN of new object.
    dirError = GetRDNInfo(pTHS, pDN, szRDN, &cchRDN, &attrtypRDN);
    Assert( 0 == dirError );

    if(fIsNCHead){
        // BUGBUG
        // This is not exactly accurate yet, because in promotion we
        // replicate in the Config and Schema NCs as well.  However,
        // this will still work, because currently we treat all
        // NCs besides NDNCs the same way they used to be treated.
        addarg.pCreateNC = THAllocEx(pTHS, sizeof(CREATENCINFO));
        addarg.pCreateNC->iKind = CREATE_DOMAIN_NC;
    }


    // Derive local name of new object.  If the parent on the remote DS
    // has been renamed since it was last replicated here, we will have
    // a different string name for the parent than it does.  This presents
    // a problem, because we find the parent on LocalAdd()'s by string name,
    // and a failure to find the parent will result in failure of the add.
    // (And infinite replication failures.)

    // So, we take the transmitted parent GUID, map it to its local string
    // name, then substitute the local parent DN for the remote parent DN
    // in the DN of the object before passing it on to LocalAdd.  Simple, eh?

    if ( NULL == pParentGuid )
    {
        // No parent GUID; the only case where this is okay is if the new
        // object is the NC head for this NC.

        if ( fIsNCHead )
        {
            // Success!
            addarg.pObject = pDN;
            addarg.pResParent = CreateResObj(pDB, NULL);
        }
        else
        {
            // No parent GUID for internal node -- BAD!
            Assert( !"Parent GUID not supplied for replicated internal node creation!" );
            LogUnhandledError( DRAERR_InternalError );
        }
    }
    else
    {
        DWORD       dbError;
        BYTE        rgbParentGuidOnlyDN[ DSNameSizeFromLen( 0 ) ];
        DSNAME *    pdnParentGuidOnly = (DSNAME *) rgbParentGuidOnlyDN;
        DWORD       cbParentGuidOnlyDN = sizeof( rgbParentGuidOnlyDN );

        memset( pdnParentGuidOnly, 0, cbParentGuidOnlyDN );
        pdnParentGuidOnly->Guid = *pParentGuid;
        pdnParentGuidOnly->structLen = cbParentGuidOnlyDN;

        dbError = DBFindDSName(pDB, pdnParentGuidOnly);

        if ( 0 != dbError )
        {
            // Can't find parent object; the only case where this is
            // okay is if the new object is the NC head for this NC.

            if ( fIsNCHead )
            {
                // Success!
                addarg.pObject = pDN;
                addarg.pResParent = CreateResObj(pDB, NULL);
            }
            else
            {
                // Failed to find parent of internal node; fail with
                // "missing parent" below such that we retry, this time
                // explicitly requesting parent objects.
                ;
            }
        }
        else if (!fAddingDeleted && DBIsObjDeleted(pDB))
        {
            // Parent object is deleted.  Fall through to return
            // "missing parent."
            ;
        }
        else
        {
            // Found parent.
            DWORD cbLocalParentDN;

            // Retrieve parent's DSNAME and use it plus the RDN of the new
            // object to create its local name.

            // Get parent DSNAME.
            dbError = DBGetAttVal(
                            pDB,
                            1,
                            ATT_OBJ_DIST_NAME,
                            DBGETATTVAL_fREALLOC,
                            0,
                            &cbLocalParentDN,
                            (BYTE **) &pdnLocalParent
                            );

            if ( 0 != dbError )
            {
                // Found parent, but can't retrieve ATT_OBJ_DIST_NAME?
                LogUnhandledError( dbError );
            }
            else
            {
                if ((INVALIDDNT != dntNC)
                    && (pDB->NCDNT != dntNC)
                    && (pDB->DNT != dntNC)) {
                    // The parent object is in the wrong NC; i.e., it has been
                    // moved across domains, and the source (remote) and dest
                    // (local) DSAs don't agree on which NC the object is
                    // currently in.  This is a transient condition that will be
                    // rectified by replicating in the  other direction and/or
                    // by replicating the other NC involved.
                    DPRINT2(0,
                            "Cannot add inbound object %ls because its local "
                                "parent %ls is in an NC other than the one "
                                "being replicated -- should be a transient "
                                "condition.\n",
                            pDN->StringName,
                            pdnLocalParent->StringName);
                    DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                }

                // Construct the DN of the object to be added.
                SpliceDN(pTHS,
                            pDN,
                            pdnLocalParent,
                            szRDN,
                            cchRDN,
                            attrtypRDN,
                            &addarg.pObject);

                addarg.pResParent = CreateResObj(pDB, pdnLocalParent);
            }
        }
    }

    if ( NULL == addarg.pObject )
    {
        // Remote-to-local name translation failure.
        draError = DRAERR_MissingParent;
    }
    else
    {
        // Name translated; continue on to LocalAdd.

        BOOL fNameMorphed = FALSE;
        BOOL fNameCollision;
        BOOL fRetry;

        InitCommarg(&addarg.CommArg);

        addarg.AttrBlock = *pAttrBlock;
        addarg.pMetaDataVecRemote = pMetaDataVecRemote;

        do
        {
            fNameCollision = FALSE;
            fRetry = FALSE;

            __try
            {
                LocalAdd( pTHS, &addarg, fAddingDeleted );
                draError = RepErrorFromPTHS(pTHS);

                if (fMoveToLostAndFound)
                {
                    // we have added the object successfully under LostAndFound
                    // update the last known parent
                    if (retErr = DBFindDSName(pDB, addarg.pObject))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }
                    pLastKnownParent = THAllocEx(pTHS, pDN->structLen);
                    if (!pLastKnownParent)
                    {
                        DRA_EXCEPT(DRAERR_OutOfMem, 0);
                    }

                    if (TrimDSNameBy(pDN, 1, pLastKnownParent))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, 0);
                    }

                    if (retErr = DBReplaceAttVal(pDB, 1, ATT_LAST_KNOWN_PARENT,
                                    pLastKnownParent->structLen, pLastKnownParent))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }

                    if (retErr = DBRepl(pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING))
                    {
                        DRA_EXCEPT(DRAERR_InternalError, retErr);
                    }

                }
            }
            __except ( GetDraNameException( GetExceptionInformation(), &draError ) )
            {
                // Name collision -- handle it.
                if (!fNameMorphed) {
                    draHandleNameCollision(pTHS,
                                           it,
                                           pMetaDataVecRemote,
                                           NULL,
                                           pdnLocalParent,
                                           attrtypRDN,
                                           pAttrRDN,
                                           &addarg.pObject,
                                           &fRetry);
                    fNameMorphed = TRUE;
                }
            }
        } while ( fRetry );
    }

    if (addarg.pResParent) {
        THFreeEx(pTHS, addarg.pResParent);
    }

    if(pLastKnownParent != NULL) THFreeEx(pTHS, pLastKnownParent);

    return draError;
}

void
draHandleNameCollision(
    IN      THSTATE *                   pTHS,
    IN      SYNTAX_INTEGER              itInbound,
    IN      PROPERTY_META_DATA_VECTOR * pInboundMetaDataVec,
    IN      DSNAME *                    pCurrentDN,             OPTIONAL
    IN      DSNAME *                    pParentDN,
    IN      ATTRTYP                     RDNType,
    IN OUT  ATTR *                      pInboundRDN,
    IN OUT  DSNAME **                   ppInboundDN,
    OUT     BOOL *                      pfRetryUpdate
    )
/*++

Routine Description:

    Resolve a DN conflict encountered while applying an inbound change (object
    addition or rename).

    Applies a set of rules to determine which object gets to keep the original
    DN (the inbound object or the pre-existing local object), such that when
    replication has quiesced across all replicas one object will have retained
    the original DN.

    If the conflict is resolved (i.e., *pfRetryUpdate is TRUE on return), the
    name of one of the conflicting objects has been modified -- either the
    pre-existing local object (in which case the rename has been committed)
    or the inbound object (in which case pInboundRDN and ppInboundDN have been
    updated with the new name).

Arguments:

    pTHS (IN) - THSTATE.

    itInbound (IN) - Instance type of the inbound object.

    pInboundMetaDataVec (IN) - Inbound object's meta data vector.
        Note that this may be null in the case that the outbound replicator is
        generating an originating rename. See MoveOrphanToLostAndFound.

    pCurrentDN (IN, OPTIONAL) - The DN of the inbound object as it currently
        appears in the local database.  NULL if the inbound object does not yet
        exist (i.e., is being added), non-NULL if it exists and is being
        renamed/moved.

    pParentDN (IN) - DN of the (new) parent object; i.e., the parent of
        *ppInboundDN.

    RDNType (IN) - Class-specific RDN of the inbound/local object.

    pInboundRDN (IN/OUT) - RDN attribute of the inbound object.  Updated with
        the new RDN if the inbound object is to be renamed.

    ppInboundDN (IN/OUT) - DN of the inbound object.  Updated with the new RDN
        if the inbound object is to be renamed.

    pfRetryUpdate (OUT) - On return, should the update operation (add or rename)
        be retried?  TRUE unless this the name conflict is a fatal problem
        (i.e., conflict with an NC head or an unhandled conflict between
        read-only interior nodes).

Return Values:

    None.

--*/
{
    DWORD                       err;
    DSNAME *                    pLocalDN;
    SYNTAX_INTEGER              itLocal;
    PROPERTY_META_DATA_VECTOR * pLocalMetaDataVec;
    DWORD                       cb;
    PROPERTY_META_DATA *        pLocalMetaData;
    PROPERTY_META_DATA *        pInboundMetaData;
    BOOL                        fRenameInboundObject;
    DSNAME *                    pLosingDN;
    ATTR *                      pNewRDN = NULL;
    BOOL                        bNewRDNAllocd = FALSE;
    DWORD                       LocalDNT;

    WCHAR                       szRDN[ MAX_RDN_SIZE ];
    DWORD                       cchRDN;
    ATTRTYP                     attrtypRDN;

    Assert(!fNullUuid(&(*ppInboundDN)->Guid));
    Assert((NULL == pCurrentDN) || !fNullUuid(&pCurrentDN->Guid));

    // Default to "don't retry the operation that evoked the collision."
    *pfRetryUpdate = FALSE;

    // Decide which object we want to rename.  We arbitrarily let the object
    // that last claimed the name hold onto that name, and modify the name of
    // the other.


    // Find the local object we conflict with and read its meta data vector and
    // objectGuid.
    // This is somewhat complex.
    // 1) We might be conflicting based on equal string names.
    // 2) Or, we might be conflicting based on equal RDN values and the same
    // parent, but not the same RDN type.
    // 3) Or, we could be conflicting based on having the same key in the
    // PDNT-RDN index.

    // Get the RDN value of the object we're adding.
    err = GetRDNInfo(pTHS,
                     (*ppInboundDN),
                     szRDN,
                     &cchRDN,
                     &attrtypRDN);
    if(err)  {
        DRA_EXCEPT(DRAERR_InternalError, err);
    }

    // Find the DNT of the parent.
    err = DBFindDSName(pTHS->pDB, pParentDN);
    if(err && err != DIRERR_NOT_AN_OBJECT) {
        // Huh?  We should have found something.  Instead we found nothing, not
        // even a phantom.
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    err = DBFindChildAnyRDNType(pTHS->pDB,
                                pTHS->pDB->DNT,
                                szRDN,
                                cchRDN);
    switch(err) {
    case 0:
        // We found an exact match, modulo Attribute Type, which we don't care
        // about.  This covers cases 1 and 2.
        break;
    case ERROR_DS_KEY_NOT_UNIQUE:
        // We didn't find a match, but we found the correct key.  This is case
        // 3.
        break;
    default:
        // Huh?  We should have found something.
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    // OK, we're positioned on the object we conflicted with.  Read the real DN,
    // the instance type, and the metadata.
    if (   (err = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                              0, 0,
                              &cb, (BYTE **) &pLocalDN))
        || (err = DBGetSingleValue(pTHS->pDB, ATT_INSTANCE_TYPE, &itLocal,
                              sizeof(itLocal), NULL))
        || (err = DBGetAttVal(pTHS->pDB, 1, ATT_REPL_PROPERTY_META_DATA, 0, 0,
                              &cb, (BYTE **) &pLocalMetaDataVec))) {
        DRA_EXCEPT(DRAERR_DBError, err);
    }

    Assert(ISVALIDINSTANCETYPE(itLocal));

    if ((itInbound & IT_NC_HEAD) && (itLocal & IT_NC_HEAD)) {
        // Name collision on two NC heads (each either the head of the NC we're
        // replicating or a SUBREF thereof) -- Very Bad News.  This will require
        // some sort of admin intervention.
        // This may happen under the following conditions in the lab:
//[Jeff Parham]  This is mostly here to detect the case where a domain is created
//simultaneously on two different DCs, so we end up with two NC heads with the same
//name but different SIDs/GUIDs.  This is much less likely than it used to be, now
//that we have a domain naming FSMO, but might still be good to keep around.  The
//only pseudo-legitimate case where this can happen is when a child domain has been
//removed and recreated and the local machine has seen neither the crossRef removal
//from the config container nor the deletion of the subref.
//Replication of this NC from this source should not proceed until the NCs are
//properly sorted out.  Failing and replicating the config NC would likely allow the
//next replication cycle for this NC/source to succeed.

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DRA_NC_HEAD_NAME_CONFLICT,
                 szInsertDN(*ppInboundDN),
                 szInsertUUID(&(*ppInboundDN)->Guid),
                 NULL);
        return;
    }

    LocalDNT = pTHS->pDB->DNT;

    // We have to rename one of the two objects -- which one?
    if (itInbound & IT_NC_HEAD) {
        // Local object is an interior node, inbound object is an NC head.
        // Give the name to the NC head.
        fRenameInboundObject = FALSE;
    }
    else if (itLocal & IT_NC_HEAD) {
        // Local object is an NC head, inbound object is an interior node.
        // Give the name to the NC head.
        fRenameInboundObject = TRUE;
    }
    else {
        // Both objects are interior nodes.  Let the object which assumed the
        // name last keep it.

        // This assertion only applies to interior nodes. Infrequently there may arise
        // collisions between an nc head if a domain has been deleted and recreated.
        Assert((itInbound & IT_WRITE) == (itLocal & IT_WRITE));

        // Get the meta data for the local object's RDN.
        pLocalMetaData = ReplLookupMetaData(ATT_RDN, pLocalMetaDataVec, NULL);
        Assert(NULL != pLocalMetaData);

        // Get the meta data for the inbound object's RDN.
        pInboundMetaData = ReplLookupMetaData(ATT_RDN, pInboundMetaDataVec, NULL);
        // pInboundMetaData may be null if pInboundMetaDataVec was NULL

        if ((pInboundMetaData == NULL) ||
            ((pLocalMetaData->timeChanged > pInboundMetaData->timeChanged)
             || ((pLocalMetaData->timeChanged == pInboundMetaData->timeChanged)
                 && (memcmp(&pLocalDN->Guid, &(*ppInboundDN)->Guid, sizeof(GUID))
                     > 0)))) {
            // Local object named last OR both objects named at the same time
            // and the local object has a higher objectGuid.  The local object
            // keeps the original name.
            fRenameInboundObject = TRUE;
        }
        else {
            // Otherwise the inbound object keeps the original name.
            fRenameInboundObject = FALSE;
        }
    }

    if (fRenameInboundObject) {
        pLosingDN = *ppInboundDN;

        // Note that we munge pInboundRDN in-place, since the caller may have
        // embedded references to it (e.g., in an ADDARG for the inbound object)
        // and we want those references to refer to the new RDN rather than to
        // the old one.
        pNewRDN = pInboundRDN;
    }
    else {
        pLosingDN = pLocalDN;

        // Note that we copy pInboundRDN first rather than munging it in-place,
        // since the caller may have embedded references to it (e.g., in an
        // ADDARG for the inbound object) and we want those references to remain
        // to the old RDN rather than to the new one.
        pNewRDN = THAllocEx(pTHS, sizeof(ATTR));
        bNewRDNAllocd = TRUE;
        DupAttr(pTHS, pInboundRDN, pNewRDN);
    }

    // Construct the new RDN.
    ReplMorphRDN(pTHS, pNewRDN, &pLosingDN->Guid);

    // Inform admins of the name change.
    if (NULL == pCurrentDN) {
        // Collision while adding an object that does not yet exist locally.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_NAME_CONFLICT_ON_ADD,
                  szInsertDN(*ppInboundDN),
                  szInsertUUID(&(*ppInboundDN)->Guid),
                  szInsertUUID(&pLocalDN->Guid),
                  szInsertWC2(pNewRDN->AttrVal.pAVal->pVal,
                              pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR)),
                  szInsertUUID(&pLosingDN->Guid),
                  NULL, NULL, NULL);
    }
    else {
        // Collision while renaming an object that already exists locally.
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_NAME_CONFLICT_ON_RENAME,
                  szInsertDN(pCurrentDN),
                  szInsertUUID(&(*ppInboundDN)->Guid),
                  szInsertDN(*ppInboundDN),
                  szInsertUUID(&pLocalDN->Guid),
                  szInsertWC2(pNewRDN->AttrVal.pAVal->pVal,
                              pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR)),
                  szInsertUUID(&pLosingDN->Guid),
                  NULL, NULL);
    }

    // Clear the name collision error.
    THClearErrors();

    if (fRenameInboundObject) {
        // Change the name of the inbound object.
        SpliceDN(pTHS,
                    *ppInboundDN,
                    pParentDN,
                    (WCHAR *) pNewRDN->AttrVal.pAVal->pVal,
                    pNewRDN->AttrVal.pAVal->valLen / sizeof(WCHAR),
                    RDNType,
                    ppInboundDN);

        // Flag remote metadata only on replicated rename
        if (pInboundMetaDataVec) {
            if (itInbound & IT_WRITE) {
                // Writeable NC.  Flag the meta data such that the name change is
                // replicated back out to other DSAs.
                ReplOverrideMetaData(ATT_RDN, pInboundMetaDataVec);
            }
            else {
                // Read-only NC.  Flag the meta data such that our temporary rename
                // will unilaterally lose compared to a "real" rename from a
                // writeable source.
                ReplUnderrideMetaData(pTHS, ATT_RDN, &pInboundMetaDataVec, NULL);
            }
        }
    }
    else {
        // Change the name of the pre-existing local object.
        MODIFYDNARG modDNArg;
        MODIFYDNRES modDNRes;

        memset(&modDNArg, 0, sizeof(modDNArg));
        memset(&modDNRes, 0, sizeof(modDNRes));

        // Pass class-specific RDN to LocalModifyDN().
        pNewRDN->attrTyp = RDNType;

        modDNArg.pObject = pLocalDN;
        modDNArg.pNewRDN = pNewRDN;
        InitCommarg(&modDNArg.CommArg);

        if (err = DBFindDNT(pTHS->pDB, LocalDNT)) {
            // The local object was there a second ago....
            DRA_EXCEPT(DRAERR_DBError, err);
        }

        modDNArg.pResObj = CreateResObj(pTHS->pDB, pLocalDN);

        if (!(itInbound & IT_WRITE)) {
            // Read-only NC.  Flag the meta data such that our temporary rename
            // will unilaterally lose compared to a "real" rename from a
            // writeable source.
            ReplUnderrideMetaData(pTHS,
                                  ATT_RDN,
                                  &modDNArg.pMetaDataVecRemote,
                                  NULL);
        }

        if (LocalModifyDN(pTHS, &modDNArg, &modDNRes, FALSE)) {
            // Rename failed; bail.
            DRA_EXCEPT(RepErrorFromPTHS(pTHS), 0);
        }

        // Clean up allocations we no longer need.
        THFreeEx(pTHS, modDNArg.pResObj);
        THFreeEx(pTHS, pNewRDN->AttrVal.pAVal->pVal);
        THFreeEx(pTHS, pNewRDN->AttrVal.pAVal);

        // Commit the rename.
        DBTransOut(pTHS->pDB, TRUE, TRUE);
        DBTransIn(pTHS->pDB);
    }

    if(bNewRDNAllocd && pNewRDN != NULL) THFreeEx(pTHS, pNewRDN);

    // Retry the operation that evoked the collision, which should succeed now
    // that we've altered the name of one of the conflicting objects.
    *pfRetryUpdate = TRUE;
} // end draHandleNameCollision()

#if DBG
BOOL
HasValidInstanceType(
    DSNAME * pDN)
{
    // start with a try - we don't want this debug code to except and make debugs builds
    // act differntly than free
    DWORD ret = 0;
    BOOL fHasValidInstanceType = TRUE;
    __try {
        DWORD ncdnt;
        SYNTAX_INTEGER it;
        DBPOS * pDB = NULL;
        DBOpen2(TRUE, &pDB);
        __try {
            ret = DBFindDSName(pDB, pDN);
            
            if (ret==ERROR_SUCCESS) {
                ret = DBGetSingleValue(pDB,
                                       ATT_INSTANCE_TYPE,
                                       &it,
                                       sizeof(it),
                                       NULL);
                if ((ret==ERROR_SUCCESS) && (FExitIt(it))) {
                    if (ISVALIDINSTANCETYPE(it)) {
                        // okay, looks good so far.
                        ret = DBGetSingleValue(pDB,
                                               FIXED_ATT_NCDNT,
                                               &ncdnt,
                                               sizeof(ncdnt),
                                               NULL);
                        if (ret==ERROR_SUCCESS) {
                            if (((it & IT_NC_ABOVE) && (ncdnt==ROOTTAG)) ||
                                (!(it & IT_NC_ABOVE) && (ncdnt!=ROOTTAG))) {
                                fHasValidInstanceType = FALSE;
                            }
                        } else {
                            fHasValidInstanceType = FALSE;
                        }
                    } else {
                        fHasValidInstanceType = FALSE;
                    }
                }
            }
        }__finally{
            DBClose(pDB, FALSE);
        }
    }
    __except(GetDraException((GetExceptionInformation()), &ret)){
        Assert(!"Failed to verify the instance type of this object!");
    }

    return fHasValidInstanceType;
}
#endif

void
SetRepIt(
    IN      THSTATE *           pTHS,
    IN OUT  ENTINF *            pent,
    IN      BOOL                fNCPrefix,
    IN      BOOL                writeable,
    IN      int                 FindAliveStatus,
    OUT     SYNTAX_INTEGER *    pitCurrent,
    OUT     SYNTAX_INTEGER *    pitOut,
    OUT     BOOL *              piTypeModified
    )
/*++

Routine Description:

    Translate inbound instance type into a local instance type.

Arguments:

    pTHS (IN)

    pent (IN OUT) - The inbound object.  If the calculated local instance type
        differs from the inbound remote instance type, the embedded remote value
        is replace with the local value.

    fNCPrefix (IN) - Is this the inbound object the head of the NC being
        replicated?

    writeable (IN) - Is the NC being replicated locally writeable?

    pitCurrent (OUT) - If the object already exists locally, on return holds the
        current instance type of the local object (i.e., as it existed prior to
        replicating in this update).

    pitOut (OUT) - On return holds the calculated instance type.

    piTypeModified (OUT) - On return holds TRUE if the object already exists
        locally and the calculated instance type differs from the pre-existing
        instance type.  Otherwise, holds FALSE.

Return Values:

    None.  Throws DRA exception on error.

--*/
{
    DBPOS *         pDB = pTHS->pDB;
    ATTR *          pAttr;
    SYNTAX_INTEGER  itHere;
    SYNTAX_INTEGER  itThere;
    SYNTAX_INTEGER  itHereInitial;
    ULONG           ret;
    ULONG           dntObj = pDB->DNT;
    BOOL            fIsLocalObjPresent;

    // Anticipate likeliest outcome.
    *piTypeModified = FALSE;

    fIsLocalObjPresent = (FindAliveStatus == FIND_ALIVE_FOUND)
                         || (FindAliveStatus == FIND_ALIVE_OBJ_DELETED);

    if (fIsLocalObjPresent) {
        // Read the current instance type for the local object.
        Assert(CheckCurrency(pent->pName));
        GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &itHere, sizeof(itHere));
        Assert(ISVALIDINSTANCETYPE(itHere));
        *pitCurrent = itHere;
    }

    // Get instance type of object on source DSA.
    if (AttrValFromAttrBlock(&pent->AttrBlock, ATT_INSTANCE_TYPE, &itThere,
                             &pAttr)) {
        // Instance type is not present in the inbound replication stream.
        if (fIsLocalObjPresent) {
            // 'Salright -- we have the instance type we calculated for this
            // object in the past.
            *pitOut = *pitCurrent;
            Assert(!*piTypeModified);
            return;
        } else {
            // We don't have enough data to create this object.
            DraErrMissingObject(pTHS, pent);
        }
    }

    // Ignore future inbound instance type bits our DSA version doesn't
    // understand.
    itThere &= IT_MASK_CURRENT;

    Assert(ISVALIDINSTANCETYPE(itThere));

    if (fNCPrefix && !FPrefixIt(itThere)) {
        // The NC root at the source does not have an NC root instance type.
        DraErrCannotFindNC(pent->pName);
    }

    if (fIsLocalObjPresent) {
        // Save initial instance type.
        itHereInitial = itHere;

        if (fNCPrefix) {
            // This is the head of the NC we're replicating, which already
            // exists locally.
            switch (itHere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // We're replicating in the NC head, but locally this object is
                // marked as an interior node.  This should never happen.
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;

            case NC_MASTER_GOING:
            case NC_FULL_REPLICA_GOING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF_GOING:
                // Local NC is in the process of being torn down.  We should
                // never get here, as an NC in this state should never have
                // repsFroms and DRA_ReplicaAdd() would have already bailed out.
                Assert(!"Inbound NC is being torn down locally!");
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;

            case SUBREF:
                // Local object is a pure subref; upgrade it to be instantiated.
                itHere = writeable ? NC_MASTER_SUBREF_COMING
                                   : NC_FULL_REPLICA_SUBREF_COMING;
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
                if (!writeable) {
                    // We're ostensibly populating a read-only NC but the
                    // instance type of the local NC head says it's writeable?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // Else current local instance type is fine; leave as-is.
                break;

            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
                if (writeable) {
                    // We're ostensibly populating a writeable NC but the
                    // instance type of the local NC head says it's read-only?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // Else current local instance type is fine; leave as-is.
                break;

            default:
                // Local instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;
            }
        } else {
            // This is an object other than the head of the NC we're currently
            // replicating and it already exists locally.
            switch (itHere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // The local object is a regular interior node.
                if (FExitIt(itThere)) {
                    // The source says this object is an exit point, but we
                    // believe it is an interior node.  This should never
                    // happen.
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                } else if ((INT_MASTER == itHere)
                           && (INT_FULL_REPLICA == itThere)) {
                    // The local object is writeable but the source is read-
                    // only.  This should never happen.
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                } else if (itHere != (writeable ? INT_MASTER : INT_FULL_REPLICA)) {
                    // One way this can occur if the source has the object in the
                    // current NC, but the destination has had the object cross domain
                    // moved to another NC on the machine of different writeability.
                    DPRINT1( 0, "Writeability of object %ls differs between that of the NC"
                             " and that of the object locally as found by GUID. Has object"
                             " been cross-domain moved?", pent->pName->StringName );
                    DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                }
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_GOING:
            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_GOING:
                // The local object is a child NC of the NC we're replicating
                // but its instance type does not yet reflect that (probably
                // because we are in the process of instantiating its parent NC
                // on the local DSA for the first time).  Add the "NC above"
                // bit.
                itHere |= IT_NC_ABOVE;
                // fall through...

            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
            case NC_FULL_REPLICA_SUBREF_GOING:
            case SUBREF:
                // The local object is an NC head of some sort (instantiated or
                // not).
                if (!FExitIt(itThere)) {
                    // The source DSA does not think this object corresponds to
                    // a different NC?
                    DraErrInappropriateInstanceType(pent->pName, itHere);
                }
                // If this inferior nc head arrived as part of this NC, it should
                // be a SUBREF
                Assert( itThere & IT_NC_ABOVE );
                // Else value of itHere is fine.
                break;

            default:
                // Local instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itHere);
                break;
            }
        }

        if (itHere != itHereInitial) {
            *piTypeModified = TRUE;
        }
    } else {
        // Object does not yet exist in the local DS.
        itHere = itThere;

        if (fNCPrefix)  {
            // This is the head of the NC we're replicating, and it does not
            // yet exist locally.  The local instance type of this object
            // depends on whether the parent NC has been instantiated on this
            // DSA.

            DSNAME * pParent = THAllocEx(pTHS, pent->pName->structLen);
            SYNTAX_INTEGER itParent;

            if (TrimDSNameBy(pent->pName, 1, pParent)
                || IsRoot(pParent)
                || DBFindDSName(pDB, pParent)
                || (GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &itParent,
                                      sizeof(itParent)),
                    (itParent & IT_UNINSTANT))) {
                // The parent NC is not instantiated on this DSA,
                itHere = writeable ? NC_MASTER_COMING : NC_FULL_REPLICA_COMING;
            } else {
                Assert(!DBIsObjDeleted(pDB)
                       && "Instantiated NCs can't be deleted!");
                itHere = writeable ? NC_MASTER_SUBREF_COMING
                                   : NC_FULL_REPLICA_SUBREF_COMING;
            }

            THFreeEx(pTHS, pParent);
        } else {
            // This is an object other than the head of the NC we're
            // replicating, and it does not yet exist locally.
            switch (itThere) {
            case INT_MASTER:
            case INT_FULL_REPLICA:
                // The inbound object is a regular interior node, as will be
                // the local instantiation of that object.
                if (writeable && (INT_FULL_REPLICA == itThere)) {
                    // We're performing writeable NC replication but the object
                    // on the source DSA is marked as read-only.  This should
                    // never happen.
                    DraErrInappropriateInstanceType(pent->pName, itThere);
                }
                itHere = writeable ? INT_MASTER : INT_FULL_REPLICA;
                break;

            case NC_MASTER:
            case NC_MASTER_COMING:
            case NC_MASTER_GOING:
            case NC_FULL_REPLICA:
            case NC_FULL_REPLICA_COMING:
            case NC_FULL_REPLICA_GOING:
                // The object on the source DSA is an NC head, but it should be
                // some sort of subref and is not flagged as such.
                DraErrInappropriateInstanceType(pent->pName, itThere);
                break;

            case NC_MASTER_SUBREF:
            case NC_MASTER_SUBREF_COMING:
            case NC_MASTER_SUBREF_GOING:
            case NC_FULL_REPLICA_SUBREF:
            case NC_FULL_REPLICA_SUBREF_COMING:
            case NC_FULL_REPLICA_SUBREF_GOING:
            case SUBREF:
                // The object on the source DSA is some sort of subref; locally
                // it will be a pure subref.
                itHere = SUBREF;
                break;

            default:
                // remote instance type unknown?
                DraErrInappropriateInstanceType(pent->pName, itThere);
                break;
            }
        }
    }

    Assert(ISVALIDINSTANCETYPE(itHere));
    *pitOut = itHere;

    memcpy(pAttr->AttrVal.pAVal->pVal, &itHere, sizeof(SYNTAX_INTEGER));

    // Currency should be on the local copy of this object, if any.
    Assert(!fIsLocalObjPresent || (pDB->DNT == dntObj));
}

/* CheckProxyStatus - Determines whether an object is a legitimate proxy
*  object and/or whether it just has an ATT_PROXIED_OBJECT_NAME property.
*
*       pent        - data for object
*       pfIsProxy   - return value indicating if full fledged proxy object
*       ppProxyVal  - return value indicating address of proxy value if present
*
*  Returns:
*       TRUE if the attribute is present, else FALSE.
*/
VOID
CheckProxyStatus(
    ENTINF                  *pent,
    USHORT                  DeletionStatus,
    BOOL                    *pfIsProxy,
    SYNTAX_DISTNAME_BINARY  **ppProxyVal
    )
{
    ATTRBLOCK   AttrBlock = pent->AttrBlock;
    ULONG       AttrCount = pent->AttrBlock.attrCount;
    ULONG       i;
    BOOL        fClass = FALSE;

    *pfIsProxy = FALSE;
    *ppProxyVal = NULL;

    for ( i = 0; i < AttrCount; i++ )
    {
        if ( ATT_PROXIED_OBJECT_NAME == AttrBlock.pAttr[i].attrTyp )
        {
            Assert(1 == AttrBlock.pAttr[i].AttrVal.valCount);
            *ppProxyVal = (SYNTAX_DISTNAME_BINARY *)
                                    AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal;
            continue;
        }

        if (    (ATT_OBJECT_CLASS == AttrBlock.pAttr[i].attrTyp)
             && (CLASS_INFRASTRUCTURE_UPDATE ==
                        * (DWORD *) AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal) )
        {
            fClass = TRUE;
            continue;
        }
    }

    *pfIsProxy = (    fClass
                   && (NULL != *ppProxyVal)
                   && (OBJECT_BEING_DELETED == DeletionStatus) );
}

/* PreProcessProxyInfo - Resolve conflicts related to adding a cross
 *  domain moved object (identified by existence of ATT_PROXIED_OBJECT_NAME
 *  on add) when an object with the same GUID already exists on this machine.
 *
 *  This routine is checking whether the local object is some form of moved object:
 *  a) A live pre-move object           (no proxy nor moved object)
 *  b) A phantomized pre-move object    (proxy but no moved object)
 *  c) A live post-move object          (moved object arrived)
 *  d) A phantomized post-move object   (moved object arrived)
 *
 *  This routine is called when any object except a proxy object is about to
 *  to be updated during replication.  Whether or not the incoming object is
 *  a cross domain moved object (c) is determined by whether it has a proxy value
 *  or not.
 *
 *  Note that ATT_PROXIED_OBJECT_NAME is always shipped on objects which have this
 *  attribute when they are modified.  It becomes a form of secondary metadata
 *  containing the move-epoch for this object.  Thus any modifications of moved
 *  objects are guaranteed to compare correctly.
 *
 *  The update could be an creation, modification or deletion.
 */
ULONG
PreProcessProxyInfo(
    THSTATE                     *pTHS,
    ENTINF                      *pent,
    SYNTAX_DISTNAME_BINARY      *pProxyVal,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    PROPERTY_META_DATA_VECTOR   **ppMetaDataVecLocal,
    BOOL                        *pfContinue)
{
    DWORD                   dwErr;
    DWORD                   localEpoch;
    DWORD                   incomingEpoch;
    SYNTAX_DISTNAME_BINARY  *pLocalProxyVal;
    ULONG                   len;
    DSNAME                  *pLocalDN;
    int                     diff;
    PROPERTY_META_DATA      *pMetaLocal;
    PROPERTY_META_DATA      *pMetaRemote;
    DWORD                   verLocal;
    DWORD                   verRemote;
    DWORD                   proxyEpoch;
    BOOL                    fProxyFound;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!fNullUuid(&pent->pName->Guid));
    Assert(pMetaDataVecRemote && !*ppMetaDataVecLocal);

    *pfContinue = TRUE;

    // Get the epoch numbers of the local and incoming objects.

    incomingEpoch = (pProxyVal ? GetProxyEpoch(pProxyVal) : 0);

    switch ( dwErr = DBFindDSName(pTHS->pDB, pent->pName) )
    {
    case 0:

        // We have it as a real object - derive its epoch number.

        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pLocalProxyVal);
        switch ( dwErr )
        {
        case 0:
            localEpoch = GetProxyEpoch(pLocalProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            localEpoch = 0;
            break;
        default:
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }
        break;

    case DIRERR_NOT_AN_OBJECT:

        // We have it as a phantom.  It should not have a proxy value.
        // If the proxy object has not arrived yet, there is some ambiguity as
        // to whether the phantom is of the pre-move or post-move object.  The post-
        // move object might have been phantomized due to GC demotion or another
        // cross-domain move.  If we don't have a proxy object, there isn't enough
        // information on the phantom to divine what epoch it is from, so we don't try.
        // It is possible that the phantom may be in a different nc than the one
        // we are currently operating on.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pLocalProxyVal));

        // There are two reasons we might have a phantom for an object in
        // the domain we are authoritative for.
        //
        // 1) Consider 3 replicas of this domain A, B and C where we are B.
        //    Object X was cross domain moved off of A, A created a proxy for X,
        //    the proxy replicated to B, and B phantomized X.  Now C for some
        //    reason re-plays the add of X to B.  B needs to determine if
        //    X ever existed in the domain in order to know whether to accept
        //    the add of X.  C may also send modifications to X, which need
        //    to be suppressed.
        //
        // 2) Consider the case where we are authoritatively restored and thus
        //    re-introduce objects which were moved ex-domain after the backup.
        //    Our objects will be phantomized as we replicate in the proxies
        //    from other replicas.  But other replicas need to reject the
        //    re-introduced objects for all replicas to be consistent.
        //    See spec\nt5\ds\xdommove.doc for authoritative restore details.
        //
        // Except in the install case, where we take everything as gospel ...

        if ( !DsaIsInstalling() )
        {
            if ( dwErr = DBFindBestProxy(pTHS->pDB, &fProxyFound, &proxyEpoch) )
            {
                DRA_EXCEPT(DRAERR_InternalError, dwErr);
            }

            if ( fProxyFound )
            {
                // Proxy objects get the pre-move epoch number of the moved
                // object.  So the incoming object wins only if its epoch is
                // greater than the proxy's epoch.

                if ( proxyEpoch >= incomingEpoch )
                {
                    *pfContinue = FALSE;
                    return(0);
                }
            }

        }

        // Fall through ...

    case DIRERR_OBJ_NOT_FOUND:

        // Consider this an add - this should jive with what caller thought too.

        *pfContinue = TRUE;
        return(0);

    default:

        DRA_EXCEPT(DRAERR_InternalError, dwErr);
    }

    if ( localEpoch > incomingEpoch )
    {
        // Local object is a newer incarnation than incoming object - don't
        // apply incoming update.  One might think that metadata handling
        // would do the right thing, but consider that if the epochs are
        // different, then these represent two distinct object creations
        // whose metadata is not comparable.  We don't need to create a proxy
        // for the incoming domain/object since there must be one already
        // else we wouldn't already have a local object with a higher epoch
        // number.  I.e. The proxy exists - its just that the remote add in
        // the new domain got here before this modify.

        *pfContinue = FALSE;
        return(0);
    }
    else if ( incomingEpoch > localEpoch )
    {
        // Incoming object is a newer incarnation than the local object -
        // therefore we prefer it.  Turn the existing object into a phantom
        // and process the modify as an add instead.

        if ( dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                 0, 0, &len, (UCHAR **) &pLocalDN) )
        {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        if ( dwErr = PhantomizeObject(pLocalDN, pLocalDN, TRUE) )
        {
            return(Win32ErrorFromPTHS(pTHS));
        }

        *pfContinue = TRUE;
        return(0);
    }

    // Both local and incoming objects have the same epoch numbers - this
    // could occur for two reasons.
    //
    // 1)   Incoming data is a replay of data we already have locally and
    //      there is no duplicity of epoch numbers - see item (2).  In
    //      this case the two object's metadata are comparable and we let
    //      the modify proceed and regular metadata processing do its thing.
    //
    // 2)   The logic of GetProxyObjects() is not working.  Consider
    //      two replicas of domain A.  Let (guid,A,0) represent an object with
    //      GUID guid, in domain A, with epoch number 0.  If the FSMO logic
    //      is broken, then the two respective replicas of A could contrive
    //      to both move the object such that we might have (guid,B,1) and
    //      (guid,C,1) concurrently in the system.  This should not happen,
    //      but we don't want replication to stop if it does.  Indeed, there's
    //      no immediate problem if two DCs for two distinct domains which are
    //      not GCs have an object with the same GUID.  The problem is on
    //      GCs where we need to pick one of the objects.  In this case we
    //      prefer the object the normal conflict resolution would if
    //      the version info were the same.  I.e. We wish to base conflict
    //      resolution on time and originating DSA UUID alone.
    //
    // For both cases then, we need to check the ATT_PROXIED_OBJECT_NAME
    // metadata.  The one exception is the when the epoch numbers are zero
    // as this value is never written, and thus by definition, we're dealing
    // with identical objects.

    Assert(localEpoch == incomingEpoch);

    if ( 0 == localEpoch )
    {
        *pfContinue = TRUE;
        return(0);
    }

    // Dig out the respective metadata - we're still positioned on the
    // local object so can just read immediately.

    if (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_REPL_PROPERTY_META_DATA,
                                 0, 0, &len, (UCHAR **) ppMetaDataVecLocal))
         || !(pMetaLocal = ReplLookupMetaData(ATT_PROXIED_OBJECT_NAME,
                                              *ppMetaDataVecLocal, NULL))
         || !(pMetaRemote = ReplLookupMetaData(ATT_PROXIED_OBJECT_NAME,
                                               pMetaDataVecRemote, NULL)) )
    {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    // Temporarily whack the version info so that we can reconcile on
    // time and originating DSA UUID only.

    verLocal = pMetaLocal->dwVersion;
    verRemote = pMetaRemote->dwVersion;
    _try
    {
        pMetaLocal->dwVersion = 1;
        pMetaRemote->dwVersion = 1;
        diff = ReplCompareMetaData(pMetaLocal, pMetaRemote);
    }
    _finally
    {
        pMetaLocal->dwVersion = verLocal;
        pMetaRemote->dwVersion = verRemote;
    }

    switch ( diff )
    {
    case 1:

        // Local object won.
        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                0, 0, &len, (UCHAR **) &pLocalDN)) {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        *pfContinue = FALSE;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DUPLICATE_MOVED_OBJECT,
                 szInsertDN(pent->pName),
                 szInsertDN(pLocalDN),
                 szInsertUUID(&pLocalDN->Guid));
        break;

    case 0:

        // Local and remote are identical.
        *pfContinue = TRUE;
        break;

    case -1:

        // Remote object won - same as (incomingEpoch > localEpoch) case.

        if ( dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                 0, 0, &len, (UCHAR **) &pLocalDN) )
        {
            DRA_EXCEPT(DRAERR_InternalError, dwErr);
        }

        if ( dwErr = PhantomizeObject(pLocalDN, pLocalDN, TRUE) )
        {
            return(Win32ErrorFromPTHS(pTHS));
        }

        // We have now phantomized the existing local object, eliminating the
        // local meta data.
        THFreeEx(pTHS, *ppMetaDataVecLocal);
        *ppMetaDataVecLocal = NULL;

        *pfContinue = TRUE;
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DUPLICATE_MOVED_OBJECT,
                 szInsertDN(pent->pName),
                 szInsertDN(pLocalDN),
                 szInsertUUID(&pLocalDN->Guid));
        break;

    default:

        Assert(!"Error in ReplCompareMetaData");
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    return(0);
}

/* ProcessProxyObject - Processes the ATT_PROXIED_OBJECT_NAME attribute
*  on a proxy object resulting from a cross domain move.  A proxy object
*  is a special deleted object in the Infrastructure container than indicates
*  where an object used to be.
*
*  Returns:
*       0 if successful, a DRAERR_* error otherwise.
*/
ULONG
ProcessProxyObject(
    THSTATE                 *pTHS,
    ENTINF                  *pent,
    SYNTAX_DISTNAME_BINARY  *pProxyVal
    )
{
    DSNAME                  *pGuidOnlyDN = NULL;
    DSNAME                  *pProxyDN = NULL;
    DSNAME                  *pProxiedDN = NULL;
    DWORD                   cb;
    DWORD                   dwErr;
    COMMARG                 commArg;
    CROSS_REF               *pProxyNcCr = NULL;
    BOOL                    fPhantomize = FALSE;
    ULONG                   i, j, len;
    DSNAME                  *pDN = NULL;
    DSNAME                  *pAccurateOldDN;
    CROSS_REF               *pCR;
    SYNTAX_DISTNAME_BINARY  *pLocalProxyVal;
    DWORD                   incomingEpoch;
    DWORD                   localEpoch;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);

    // First some clarification of what got us to this point.  A cross domain
    // move has been performed where an object was moved from domain 1 (our
    // domain) to domain 2.  The original operations which occured were:
    //
    // @Dst (some replica of domain 2): O(g1,sx,sn2) was added
    // @Src (some replica of domain 1): O(g1,s1,sn1) was morphed to
    //  P(g1,s1,sn2) where 'P' indicates a phantom.
    // @Src (some replica of domain 1): O(g2,sx,sn3) was added as a proxy
    //
    // The ATT_PROXIED_OBJECT_NAME in pent holds (g1,s1,sn2).

    pProxyDN = pent->pName;
    pProxiedDN = NAMEPTR(pProxyVal);

    // Proxy and proxied objects must both have string names.
    Assert(pProxyDN->NameLen);
    Assert(pProxiedDN->NameLen);

    // Proxy and proxied objects must both have guids.
    Assert(!fNullUuid(&pProxyDN->Guid));
    Assert(!fNullUuid(&pProxiedDN->Guid));

    // Proxy value should identify this as a proxy.
    Assert(PROXY_TYPE_PROXY == GetProxyType(pProxyVal));

    InitCommarg(&commArg);
    pProxyNcCr = FindBestCrossRef(pProxyDN, &commArg);
    Assert(pProxyNcCr);

    // Construct GUID-only DSNAME for g1 (the moved object) and see what
    // kind of object we already have for it.

    cb = DSNameSizeFromLen(0);
    pGuidOnlyDN = (DSNAME *) THAllocEx(pTHS, cb);
    memset(pGuidOnlyDN, 0, cb);
    memcpy(&pGuidOnlyDN->Guid, &pProxiedDN->Guid, sizeof(GUID));
    pGuidOnlyDN->structLen = cb;

    switch ( dwErr = DBFindDSName(pTHS->pDB, pGuidOnlyDN) )
    {
    case 0:

        // We have O(g1) as a real object.  Further action depends on
        // what domain (NC) this object is in - so get that now.
        // We also need a currently correct string name for PhantomizeObject.

        if (    DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                            0, 0, &len, (UCHAR **) &pAccurateOldDN)
             || !(pCR = FindBestCrossRef(pAccurateOldDN, &commArg))
             || !pProxyNcCr )
        {
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // Get epoch values.

        incomingEpoch = GetProxyEpoch(pProxyVal);
        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pLocalProxyVal);
        switch ( dwErr )
        {
        case 0:
            localEpoch = GetProxyEpoch(pLocalProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            localEpoch = 0;
            break;
        default:
            DRA_EXCEPT(DRAERR_InternalError, 0);
        }

        // pCR represents the NC of the proxied object found by GUID.
        // pProxyNcCr represents the NC we are replicating

        if ( NameMatched(pCR->pNC, pProxyNcCr->pNC) )
        {
            // Object we found is in the same NC that we're replicating - thus
            // we're authoritive for it on this replication cycle and can
            // phantomize it if we feel that's warrannted.  Epoch value on
            // proxy is always the epoch value of the object before it was
            // moved, thus local phantomization is required if incoming epoch
            // is greater or equal the local epoch.

            if ( incomingEpoch >= localEpoch )
            {
                fPhantomize = TRUE;

                // If incoming epoch is actually greater than local epoch, then
                // it must mean that the object moved out of the NC and back
                // again, else the epochs would be equal.  In that case, then
                // the incoming epoch must be at least 2 greater than the
                // local epoch to account for the move out and move back in.

                Assert( (incomingEpoch > localEpoch)
                            ? (incomingEpoch - localEpoch) >= 2
                            : TRUE);
                break;
            }
            else
            {
                // Local object is newer with respect to cross domain moves
                // than the inbound proxy - nothing to do.

                return(0);
            }
        }
        else
        {
            // Object we found is not in the same NC that we're replicating -
            // thus we are not authoritive for it - nothing to do.  However,
            // we know it used to be in the NC we are replicating by virtue
            // of the fact that this NC has a proxy object for it.  So we can
            // assert that the epoch numbers must be different.

            if (incomingEpoch == localEpoch) {
                LogEvent8(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DUPLICATE_MOVED_OBJECT_CLEANUP,
                          szInsertUUID(&pProxiedDN->Guid),
                          szInsertDN(pAccurateOldDN),
                          szInsertDN(pProxiedDN),
                          szInsertUL(incomingEpoch),
                          NULL, NULL, NULL, NULL );
            }
            return(0);
        }

        break;

    case DIRERR_NOT_AN_OBJECT:

        // We have P(g1) as a phantom - should we fix its name?  We could,
        // but since phantoms don't have an ATT_PROXIED_OBJECT_NAME value,
        // we can't tell if the inbound name is any better than the local
        // name.  The stale phantom cleanup daemon should take care of it
        // eventually.  However, we can assert on the lack of a proxy value.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pLocalProxyVal));
        return(0);
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Don't have the object in any form - nothing to do.
        return(0);

    default:

        // Some kind of lookup error.
        DRA_EXCEPT(DRAERR_DBError, dwErr);
    }

    if ( fPhantomize )
    {
        // Construct string name only DSNAME of phantom we want.
        pDN = (DSNAME *) THAllocEx(pTHS, pProxiedDN->structLen);
        memset(pDN, 0, pProxiedDN->structLen);
        pDN->structLen = pProxiedDN->structLen;
        pDN->NameLen = pProxiedDN->NameLen;
        wcscpy(pDN->StringName, pProxiedDN->StringName);

        dwErr = PhantomizeObject(pAccurateOldDN, pDN, TRUE);
        Assert(dwErr == pTHS->errCode);
        return(RepErrorFromPTHS(pTHS));
    }

    if(pGuidOnlyDN != NULL) THFreeEx(pTHS, pGuidOnlyDN);
    if(pDN != NULL) THFreeEx(pTHS, pDN);

    return(0);
} // end ProcessProxyObject()


VOID
GcCleanupUniversalGroupDemotion(
    THSTATE *pTHS,
    DSNAME *pDN,
    ATTRBLOCK *pAttrBlock,
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal
    )

/*++

Routine Description:

GC Cleanup. Cleanup a group that is no longer universal by removing its
memberships.

Normally, group filtering occurs at the source (see dragtchg.c,
IsFilterGroupMember, and drameta.c, ReplFilterPropsToShip).  In the case of
a universal group demotion, filtering at the source will not be enough to allow
the GC destination to delete the unneeded memberships.

Arguments:

    THSTATE *pTHS,
    ATTRBLOCK *pAttrBlock,
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal

Return Value:

    None

--*/

{
    DWORD retErr;
    SYNTAX_INTEGER newGroupType, oldGroupType, class, it;
    ATTCACHE *pAC;

    Assert(VALID_THSTATE(pTHS));

    // We should still be positioned on the object
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pMetaDataVecLocal);

    // Current object class should be class GROUP
    // Current instance type should be INT_FULL_REPLICA
    // Member attr should NOT be present; it should have been filtered

    // Is this object of class group?
    // Is this a read-only internal object?
    // Is the group type being changed to non-universal?
    // Was the old value universal?
    if (
         (AttrValFromAttrBlock( pAttrBlock, ATT_GROUP_TYPE, &newGroupType, NULL ) != ATTR_PRESENT_VALUE_RETURNED ) ||
         (newGroupType & GROUP_TYPE_UNIVERSAL_GROUP) ||
         (DBGetSingleValue(pTHS->pDB, ATT_GROUP_TYPE, &oldGroupType,
                           sizeof(oldGroupType), NULL)) ||
         (!(oldGroupType & GROUP_TYPE_UNIVERSAL_GROUP))
        )
    {
        return;
    }

    pAC = SCGetAttById(pTHS, ATT_MEMBER);
    if (!pAC) {
        DRA_EXCEPT(DIRERR_ATT_NOT_DEF_IN_SCHEMA, 0);
    }

    // Remove all links for the ATT_MEMBER attribute
    DBRemoveLinks_AC( pTHS->pDB, pAC );

    // GC cleanup of member metadata
    pTHS->fGCLocalCleanup = TRUE;
    __try {
        DBTouchMetaData( pTHS->pDB, pAC);
        DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);
    } __finally {
        pTHS->fGCLocalCleanup = FALSE;
    }

    DPRINT1( 1, "gcCleanupUniversalGroupDemotion: deleting memberships for group %ws\n", pDN->StringName );
}


DWORD
UpdateRepValue(
    THSTATE *pTHS,
    ULONG dntNC,
    ULONG RepFlags,
    BOOL fObjectCurrency,
    REPLVALINF *pReplValInf,
    DWORD *pdwUpdateValueStatus
    )

/*++

Routine Description:

Apply a single value

From the LVR spec, section on "Replication"

When you replicate the current state of an LVR row you send its name
(the object-guid of the containing object, the DSNAME of the target, and the
link ID), its isPresent value (where isPresent = (deletion-timestamp != 0)),
and its five metadata components. (Plus the value of "stuff" in an instance of
one of the "DN plus stuff" syntaxes.)

On a replicated write of a link-table row, the creation timestamp is used as
part of the normal metadata comparison. When comparing metadata, the items are
compared in order from left to right, with the left being most significant.
And there's an additional rule: legacy metadata always loses to LVR metadata.

The result of the metadata comparison is used just as it is today for attribute
updates: If the incoming row value's metadata loses the comparison the incoming
row value is discarded, otherwise the incoming row value completely replaces the
existing row value (including metadata.) If there's no existing row, no
comparison takes place and the incoming row value is used to initialize a new row.

When you replicate in a row with isPresent == false, you set the deletion timestamp
from the update timestamp of the incoming metadata. When you replicate in a row
with isPresent == true and the corresponding row is absent, that row becomes present:
its deletion timestamp is set to NULL.

Arguments:

    pTHS - thread state
    dntNC - dnt of NC of object and value
    pRepFlags - replication flags
    fObjectCurrency - Whether we still are positioned on object
    pReplValInf - Replication value to be applied
    pdwUpdateValueStutus - type of update performed
        UPDATE_NO_UPDATE, UPDATE_VALUE_UPDATE, UPDATE_VALUE_CREATION

Return Value:

   DWORD - success, or missing parent
   Exceptions raised

--*/

{
    DWORD ret, findAliveStatus, cchRDN, dntNCDNT;
    VALUE_META_DATA remoteValueMetaData;
    ATTCACHE *pAC;
    BOOL fPresent, fConflict;
    DSNAME *pdnValue;
    CHAR szTime1[SZDSTIME_LEN], szTime2[SZDSTIME_LEN];
    CHAR szUuid1[SZUUID_LEN], szUuid2[SZUUID_LEN];
    int iResult;
    WCHAR wchRDN[MAX_RDN_SIZE];
    GUID guidRDN;
    MANGLE_FOR mangleType;
    ATTRTYP attrtypRDN;

    *pdwUpdateValueStatus = UPDATE_NOT_UPDATED;

    // Get the attribute cache entry
    pAC = SCGetAttById(pTHS, pReplValInf->attrTyp);
    if (!pAC) {
        DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
    }

    // Get the DSNAME output of the ATTRVAL
    pdnValue = DSNameFromAttrVal( pAC, &(pReplValInf->Aval) );
    if (pdnValue == NULL) {
        DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
    }

    DPRINT4( 2, "UpdateRepValue, obj guid = %s, attr=%s, value = %ls, value guid=%s\n",
             DsUuidToStructuredString(&(pReplValInf->pObject->Guid), szUuid1),
             pAC->name,
             pdnValue->StringName,
             DsUuidToStructuredString(&(pdnValue->Guid), szUuid2)
             );

    // Convert metadata to internal form
    remoteValueMetaData.timeCreated = pReplValInf->MetaData.timeCreated;
    remoteValueMetaData.MetaData.attrType = pReplValInf->attrTyp;
    remoteValueMetaData.MetaData.dwVersion = pReplValInf->MetaData.MetaData.dwVersion;
    remoteValueMetaData.MetaData.timeChanged = pReplValInf->MetaData.MetaData.timeChanged;
    remoteValueMetaData.MetaData.uuidDsaOriginating =
        pReplValInf->MetaData.MetaData.uuidDsaOriginating;
    remoteValueMetaData.MetaData.usnOriginating =
        pReplValInf->MetaData.MetaData.usnOriginating;
    remoteValueMetaData.MetaData.usnProperty = 0; // not assigned yet

    Assert(!IsLegacyValueMetaData( &remoteValueMetaData ));

    //
    // Find containing object
    //

    if (!fObjectCurrency) {
        Assert( !fNullUuid( &(pReplValInf->pObject->Guid) ) );

        findAliveStatus = FindAliveDSName( pTHS->pDB, pReplValInf->pObject );
        switch (findAliveStatus) {
        case FIND_ALIVE_FOUND:
            break;
        case FIND_ALIVE_OBJ_DELETED:
            DPRINT( 2, "Object is already deleted, value not applied\n" );
            LogEvent( DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_EXTENSIVE,
                      DIRLOG_LVR_NOT_APPLIED_DELETED,
                      szInsertUUID( &(pReplValInf->pObject->Guid) ),
                      NULL, NULL );
            // nothing to do
            return ERROR_SUCCESS;
        case FIND_ALIVE_NOTFOUND:
            DPRINT( 2, "Object is not found, missing parent error\n" );
            // Missing parent, ie missing containing object

            if (RepFlags & DRS_GET_ANC) {
                // An object that has already been garbage collected?
                Assert( !"Value's containing obj is missing, even after get ancestors" );
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_LVR_NOT_APPLIED_MISSING2,
                          szInsertUUID( &(pReplValInf->pObject->Guid) ),
                          szInsertSz( pAC->name ),
                          szInsertDN( pdnValue ) );
                DRA_EXCEPT(DRAERR_InternalError, DRAERR_MissingParent);
            } else {
                // Containing object not included in same packet as value?
                LogEvent( DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_EXTENSIVE,
                          DIRLOG_LVR_NOT_APPLIED_MISSING,
                          szInsertUUID( &(pReplValInf->pObject->Guid) ),
                          szInsertSz( pAC->name ),
                          szInsertDN( pdnValue ) );
                // This is a "normal error" and not considered an exception
                return DRAERR_MissingParent;
            }
        default:
            Assert( !"Unexpected problem finding containing object" );
            DRA_EXCEPT(DRAERR_DBError, findAliveStatus);
        }

        // Make sure value's containing object is in the same NC
        if ((INVALIDDNT != dntNC)
            && (pTHS->pDB->NCDNT != dntNC)
            && (pTHS->pDB->DNT != dntNC)) {
            // The new parent object is in the wrong NC
            DPRINT1( 0, "Object %s is not in the NC being replicated. Value not applied.\n",
                     GetExtDN( pTHS, pTHS->pDB ) );
            DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
        }

    } else if (DBIsObjDeleted(pTHS->pDB)) {
        // Currency already established and object is deleted
        DPRINT( 2, "Object is already deleted, value not applied\n" );
        LogEvent( DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_EXTENSIVE,
                  DIRLOG_LVR_NOT_APPLIED_DELETED,
                  szInsertUUID( &(pReplValInf->pObject->Guid) ),
                  NULL, NULL );
        // nothing to do
        return ERROR_SUCCESS;
    }

    //
    // We are now positioned on an object: we can use GetExtDN()
    //

    // Log remote metadata


    DPRINT5( 5, "{%s,%d,%s,%I64d,%s}\n",
             DSTimeToDisplayString(pReplValInf->MetaData.timeCreated, szTime1),
             pReplValInf->MetaData.MetaData.dwVersion,
             DsUuidToStructuredString(&pReplValInf->MetaData.MetaData.uuidDsaOriginating, szUuid1),
             pReplValInf->MetaData.MetaData.usnOriginating,
             DSTimeToDisplayString(pReplValInf->MetaData.MetaData.timeChanged, szTime2)
             );

    // Log the remote metadata
    LogEvent8( DS_EVENT_CAT_LVR,
               DS_EVENT_SEV_VERBOSE,
               DIRLOG_LVR_REMOTE_META_INFO,
               szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
               szInsertUUID( &(pReplValInf->pObject->Guid) ),
               szInsertDN( pdnValue ),
               szInsertDSTIME(pReplValInf->MetaData.timeCreated, szTime1),
               szInsertUL(pReplValInf->MetaData.MetaData.dwVersion),
               szInsertUUID(&pReplValInf->MetaData.MetaData.uuidDsaOriginating),
               szInsertUSN(pReplValInf->MetaData.MetaData.usnOriginating),
               szInsertDSTIME(pReplValInf->MetaData.MetaData.timeChanged, szTime2)
        );

    // Check for tombstone name
    if (GetRDNInfo(pTHS, pdnValue, wchRDN, &cchRDN, &attrtypRDN)) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }
    if (IsMangledRDN( wchRDN, cchRDN, &guidRDN, &mangleType ) &&
        (mangleType == MANGLE_OBJECT_RDN_FOR_DELETION) ) {
        DPRINT1(0, "Value %ls has tombstone name, will not be applied\n",
                pdnValue->StringName );
        // Log that value references a tombstone
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_NOT_APPLIED_VALUE_DELETED,
                   szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                   szInsertUUID( &(pReplValInf->pObject->Guid) ),
                   szInsertSz( pAC->name ),
                   szInsertDN( pdnValue ),
                   szInsertUUID( &(pdnValue->Guid) ),
                   NULL, NULL, NULL );

        // nothing to do
        return ERROR_SUCCESS;
    }

    //
    // Position on value in order to check the local metadata
    //

    ret = DBFindAttLinkVal_AC(
        pTHS->pDB,
        pAC,
        pReplValInf->Aval.valLen,
        pReplValInf->Aval.pVal,
        &fPresent
        );
    if (DB_ERR_VALUE_DOESNT_EXIST == ret) {
        DPRINT3( 3, "Attribute %s value %ls present %d does not exist locally, will be applied\n",
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
        // Value does not exist in any form locally
        // The incoming value will be applied

        // It is ok for the incoming value to be absent. This just means the value
        // was added and removed remotely before we ever saw it.
        *pdwUpdateValueStatus = UPDATE_VALUE_CREATION;
    } else if (ERROR_DS_NO_DELETED_NAME == ret) {
        // The DN names an object that has been deleted locally. This can happen
        // since the incoming external form may have a GUID in it, thus allowing
        // a deleted DN to be found that way.  We should not receive an external
        // form stringname DN that is mangled.

        DPRINT1(3, "Value %ls is deleted locally, will not be applied\n",
                pdnValue->StringName );
        // Log that value references a tombstone
        LogEvent8( DS_EVENT_CAT_REPLICATION,
                   DS_EVENT_SEV_EXTENSIVE,
                   DIRLOG_LVR_NOT_APPLIED_VALUE_DELETED,
                   szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                   szInsertUUID( &(pReplValInf->pObject->Guid) ),
                   szInsertSz( pAC->name ),
                   szInsertDN( pdnValue ),
                   szInsertUUID( &(pdnValue->Guid) ),
                   NULL, NULL, NULL );


        // nothing to do
        return ERROR_SUCCESS;
    } else if (ret) {
        // Error looking up value
        DRA_EXCEPT( DIRERR_DATABASE_ERROR, ret);
    } else {
        // Value exists locally, compare metadata to see if needed
        VALUE_META_DATA localValueMetaData;

        DPRINT4( 3, "Attribute %s value %ls present %d exist locally, fPresent=%d\n",
                 pAC->name, pdnValue->StringName,
                 pReplValInf->fIsPresent, fPresent );

        // Get value metadata
        DBGetLinkValueMetaData( pTHS->pDB, pAC, &localValueMetaData );

        // Do we need to apply this change?
        iResult = ReplCompareValueMetaData(
            &localValueMetaData,
            &remoteValueMetaData,
            &fConflict );

        if (fConflict) {
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_MINIMAL,
                       DIRLOG_LVR_CONFLICT,
                       szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                       szInsertUUID( &(pReplValInf->pObject->Guid) ),
                       szInsertSz( pAC->name ),
                       szInsertDN( pdnValue ),
                       szInsertUUID( &(pdnValue->Guid) ),
                       szInsertDSTIME(pReplValInf->MetaData.timeCreated, szTime1),
                       szInsertDSTIME(localValueMetaData.timeCreated, szTime2),
                       NULL
                );
        }

        if (iResult != -1) {

            DPRINT( 3, "Local value metadata is greater, value not applied\n" );

            // Log that value was not applied
            LogEvent8( DS_EVENT_CAT_REPLICATION,
                       DS_EVENT_SEV_EXTENSIVE,
                       DIRLOG_LVR_NOT_APPLIED_NOT_NEEDED,
                       szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
                       szInsertUUID( &(pReplValInf->pObject->Guid) ),
                       szInsertSz( pAC->name ),
                       szInsertDN( pdnValue ),
                       szInsertUUID( &(pdnValue->Guid) ),
                       NULL, NULL, NULL );

            // Nothing to do
            IADJUST(pcDRASyncPropSame, 1 );
            return ERROR_SUCCESS;
        } else {
            DPRINT( 3, "Remote value metadata is greater, value applied\n" );
            *pdwUpdateValueStatus = UPDATE_VALUE_UPDATE;
        }

    } // end of if value exists locally

    // Handle single value semantics
    if ( (pAC->isSingleValued) && (pReplValInf->fIsPresent) ) {
        ATTRVAL attrval;

        DPRINT2( 3, "Single value attribute %s remote value %ls being made present\n",
                 pAC->name, pdnValue->StringName );

        // Does there exist another present value?
        // Note, we do not include absent values flag in this call.
        // Note also that we could have requested the value in internal form, but the
        // later call to DbRemAttVal assumes external form, so that is what we use.
        memset( &attrval, 0, sizeof( attrval ) );
        ret = DBGetNextLinkVal_AC (
            pTHS->pDB,
            TRUE, // bFirst
            pAC,
            0, // We want external values
            0, // in buff size
            &(attrval.valLen),
            &(attrval.pVal) );
        if (0 == ret) {
            DSNAME *pdnRemovalValue;
            VALUE_META_DATA localValueMetaData;
            // There exists atleast one value

            // Get the DSNAME output of the ATTRVAL
            pdnRemovalValue = DSNameFromAttrVal( pAC, &attrval );
            if (pdnRemovalValue == NULL) {
                DRA_EXCEPT(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX, 0);
            }

            DPRINT2( 3, "Single value attribute %s local value %ls already present\n",
                     pAC->name, pdnRemovalValue->StringName );

            // Get value metadata
            DBGetLinkValueMetaData( pTHS->pDB, pAC, &localValueMetaData );

            // Does this new single value win over the previous single value?
            iResult = ReplCompareDifferentValueMetaData(
                &localValueMetaData,
                &remoteValueMetaData );
            if (iResult != -1) {
                // The remote single value loses
                // Mark the value as explicitly absent.
                // This is needed for scenarios where the single valued ness of the
                // attribute is changed in the schema later.

                // Since we are reversing an incoming change, flag a metadata override
                remoteValueMetaData.MetaData.usnProperty = USN_PROPERTY_TOUCHED;

                // Construct a call to modify
                modifyLocalValue(
                    pTHS,
                    pAC,
                    FALSE, // Remove, make absent
                    &(pReplValInf->Aval),
                    pdnValue,
                    &remoteValueMetaData       // overriding originating update
                    );

                DPRINT( 3, "Local value metadata is greater, remote value made absent\n" );
                *pdwUpdateValueStatus = UPDATE_NOT_UPDATED;
                IADJUST(pcDRASyncPropSame, 1 );
                return ERROR_SUCCESS;
            }

            // The remote single value wins
            // Remove existing value
            DPRINT( 3, "Remote value metadata is greater, value replaces previous\n" );

            // Construct a call remove the attribute
            modifyLocalValue(
                pTHS,
                pAC,
                FALSE, // Remove value
                &attrval,
                pdnRemovalValue,
                NULL   // Originating update
                );

        } else if (ret != DB_ERR_NO_VALUE) {
            // Error looking up value
            DRA_EXCEPT( DIRERR_DATABASE_ERROR, ret);
        } else {
            // else no present values => fall through to add first one
            DPRINT1( 3, "Single value attribute %s has no local values.\n", pAC->name );
        }

        // We are about to add a present value to a single valued attribute. It
        // better not already have one.
        Assert( !DBHasValues_AC( pTHS->pDB, pAC ) );
    }

    //
    // We need to apply the change
    //

    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_LVR_APPLIED,
               szInsertSz( GetExtDN( pTHS, pTHS->pDB ) ),
               szInsertUUID( &(pReplValInf->pObject->Guid) ),
               szInsertSz( pAC->name ),
               szInsertDN( pdnValue ),
               szInsertUUID( &(pdnValue->Guid) ),
               szInsertUL( pReplValInf->fIsPresent ),
               NULL, NULL );

    // Construct a call to modify
    modifyLocalValue(
        pTHS,
        pAC,
        pReplValInf->fIsPresent,
        &(pReplValInf->Aval),
        pdnValue,
        &remoteValueMetaData
        );

#if DBG
    if (*pdwUpdateValueStatus == UPDATE_VALUE_CREATION)
    {
        DPRINT4( 1, "Created object %s attr %s value %ws present %d\n",
                 GetExtDN( pTHS, pTHS->pDB ),
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
    }
    else if (*pdwUpdateValueStatus == UPDATE_VALUE_UPDATE) {
        DPRINT4( 1, "Updated object %s attr %s value %ws present %d\n",
                 GetExtDN( pTHS, pTHS->pDB ),
                 pAC->name,
                 pdnValue->StringName,
                 pReplValInf->fIsPresent );
    }
#endif

    IADJUST(pcDRASyncPropUpdated, 1);
    // A DN-valued attribute.
    IADJUST(pcDRAInDNValues, 1);
    // DN-valued or not it gets added to the total.
    IADJUST(pcDRAInValues, 1);
    // Properties
    IADJUST(pcDRAInProps, 1);

    return ERROR_SUCCESS;
} /* UpdateRepValue */

ULONG
UpdateRepObj(
    THSTATE *                   pTHS,
    ULONG                       dntNC,
    ENTINF *                    pent,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote,
    ULONG *                     pUpdateStatus,
    ULONG                       RepFlags,
    BOOL                        fNCPrefix,
    GUID *                      pParentGuid,
    BOOL                        fMoveToLostAndFound
    )
/*++

Routine Description:

    Perform any updates required to comply with the given inbound object data.

    These are the rules for how replication handles deletions:
    1. The object already exists and is not deleted

    We call LocalModify on the winning replicated attributes. This looks like it
    includes is_deleted as well, although you would have to look at LocalModify to
    see if it ignores it.  We call LocalDelete.

    2. The object already exists and is deleted

    We call LocalModify on the winning replicated attributes. This looks like it
    includes is_deleted as well, although you would have to look at LocalModify to
    see if it ignores it.  We do not call LocalDelete.

    3. The object does not exist

    We call AddLocalObject with the fAddingDeleted flag set to true. We are
    creating the object in the deleted state. The incoming attributes have
    is_deleted present and true.  We call LocalDelete

Arguments:

    pTHS

    dntNC (IN) - The DNT of the NC head of the NC being replicated, or
        INVALIDDNT if that object has not yet been created.

    pent (IN) - Inbound object attributes/values.

    pMetaDataVecRemote (IN) - Inbound object meta data.

    pUpdateStatus (OUT) - On successful return, holds one of the following:
        UPDATE_NOT_UPDATED - no update required
        UPDATE_INSTANCE_TYPE - instance type of the object was updated
        UPDATE_OBJECT_CREATION - new object created
        UPDATE_OBJECT_UPDATE - pre-exisiting object modified

    RepFlags (IN) - Bit field -- only DRS_WRIT_REP is inspected, which expresses
        whether the inbound object is in a read-only or writeable NC.
    
    fNCPrefix (IN) - Is this the head of the NC being replicated?

    pParentGuid (IN) - Pointer to the objectGuid of the parent object, or NULL
        if none was supplied by the source.

    fMoveToLostAndFound (IN) - In addition to inbound updates, the object is
        being moved to the LostAndFound container as an originating write.

Return Values:

    0 or ERROR_DS_DRA_*.

--*/
{
    ULONG                       ret;
    SYNTAX_INTEGER              itNew;
    BOOL                        iTypeModified;
    int                         FindAliveStatus;
    USHORT                      DeletionStatus;
    BOOL                        fBadDelete = FALSE;
    BOOL                        fIsProxyObject = FALSE;
    BOOL                        fContinue = TRUE;
    SYNTAX_DISTNAME_BINARY    * pProxyVal = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVecLocal = NULL;
    PROPERTY_META_DATA_VECTOR * pMetaDataVecToApply = NULL;
    ULONG                       cbReturned = 0;
    SYNTAX_INTEGER              itCurrent = 0;
    PROPERTY_META_DATA *        pMetaDataLocal;
    PROPERTY_META_DATA *        pMetaDataRemote;
    DWORD                       i;
    SYNTAX_INTEGER              objectClassId = 0;
    BOOL                        fDeleteLocalObj = FALSE;
    ULONG                       dntObj = INVALIDDNT;
    ULONG                       dntObjNC = INVALIDDNT;
    ATTRBLOCK                   AttrBlockToApply;
    BOOL                        fIsAncestorOfLocalDsa = FALSE;
    ENTINF                      *pPreservedAttrs = NULL;

    ret = 0;
    *pUpdateStatus = UPDATE_NOT_UPDATED;       // Clear out any old values

    DPRINT1(1, "Updating (%ls)\n", pent->pName->StringName);

    // See if object on source server is deleted, or is undeleted,
    // or otherwise interesting requiring special handling.
    DeletionStatus = AttrDeletionStatusFromPentinf( pent );
    CheckProxyStatus(pent, DeletionStatus, &fIsProxyObject, &pProxyVal);

    // Handle the case where a cross domain moved object might
    // collide with an existing object.
    if ( !fIsProxyObject )
    {
        ret = PreProcessProxyInfo(pTHS,
                                  pent,
                                  pProxyVal,
                                  pMetaDataVecRemote,
                                  &pMetaDataVecLocal,
                                  &fContinue);
        if (ret || !fContinue) {
            return ret;
        }
    }

    // See if local object exists, doesn't exist, or exists and is deleted
    FindAliveStatus = FindAliveDSName(pTHS->pDB, pent->pName);

    if (    ( FIND_ALIVE_FOUND       == FindAliveStatus )
         || ( FIND_ALIVE_OBJ_DELETED == FindAliveStatus )
       )
    {
        dntObj = pTHS->pDB->DNT;
        dntObjNC = pTHS->pDB->NCDNT;

        // Get the meta-data vector of the object if required.
        if ( !pMetaDataVecLocal )
        {
            if (DBGetAttVal(pTHS->pDB, 1,  ATT_REPL_PROPERTY_META_DATA,
                    0, 0, &cbReturned, (LPBYTE *) &pMetaDataVecLocal))
            {
                DRA_EXCEPT (DRAERR_DBError, 0);
            }

            GetExpectedRepAtt(pTHS->pDB, ATT_OBJECT_CLASS, &objectClassId,
                              sizeof(objectClassId));
        }
    } else {
        Assert(NULL == pMetaDataVecLocal);
    }

    // Translate inbound instance type to local instance type.
    SetRepIt(pTHS,
             pent,
             fNCPrefix,
             RepFlags & DRS_WRIT_REP,
             FindAliveStatus,
             &itCurrent,
             &itNew,
             &iTypeModified);
    Assert(ISVALIDINSTANCETYPE(itNew));

    // If we need to modify the instance type on an existing object,
    // then we need to update the object.

    if (iTypeModified) {
        *pUpdateStatus = UPDATE_INSTANCE_TYPE;        // Object needs update
    }

    Assert( ret == DRAERR_Success );

    if ( !fNCPrefix && FPrefixIt(itNew) )
    {
        // The replicated object is not the head of the NC we're replicating,
        // but the instance type we calculated for the target object is that
        // of an instantiated NC head (which also serves as a SUBREF), which
        // implies that this replicated object is the head of an NC that is
        // already instantiated locally.
        //
        // In this case, we don't want to update the local object with the
        // replicated object's properties; we'll update that object when its
        // NC is synced.
        //
        // We do, however, want to take this opportunity to ensure that the
        // information on the local child NC head properly reflects the fact
        // that we hold a copy of the NC above it.
        //
        // Update the instance type on the NC head to reflect that which
        //     we just calculated (which now includes IT_NC_ABOVE, if it
        //     didn't before)
        //
        // The NCDNT is updated as a side effect of the instance type change.

        Assert((FindAliveStatus == FIND_ALIVE_FOUND)
               || (FindAliveStatus == FIND_ALIVE_OBJ_DELETED));

        *pUpdateStatus = UPDATE_NOT_UPDATED;
        if (iTypeModified) {
            DPRINT2( 1, "Instance type of SUBREF %ws was adjusted to 0x%x during superior NC replication.\n", pent->pName->StringName, itNew );
            LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DRA_SUBREF_SET_IT,
                      szInsertDN(pent->pName),
                      szInsertHex(itCurrent),
                      szInsertHex(itNew),
                      szInsertHex(DSID(FILENO,__LINE__)),
                      NULL, NULL, NULL, NULL);

            ret = ChangeInstanceType(pTHS, pent->pName, itNew, DSID(FILENO,__LINE__));
        }

    } else {

        /* Either add or modify the replica object.
        */

        Assert(!ret);

        if (fNCPrefix) {
            // This inbound object is the root of the NC we are currently
            // replicating.
            if ((FIND_ALIVE_FOUND == FindAliveStatus)
                && ((IT_UNINSTANT & itCurrent)
                    || (CLASS_TOP == objectClassId))) {
                // We're now instantiating the head of this NC, for which we
                // previously had only a placeholder NC (SUBREF or otherwise).
                // Strip all attributes from the local object and replace its
                // attributes en masse from those replicated from the source
                // DSA.

                //
                // Store attributes we wish to preserve for instantiated obj
                // Do not attempt for pure subref, only those created via
                // DRA_ReplicaAdd
                //
                if (!(IT_UNINSTANT & itCurrent)) {
                    pPreservedAttrs = GetNcPreservedAttrs( pTHS, pent->pName);
                }

                // Delete the object
                ret = DeleteLocalObj(
                            pTHS, pent->pName,
                            TRUE,           // preserve RDN
                            TRUE,           // Garbage Collection
                            NULL);          // Remote Metadata

                if (!ret) {
                    // Treat this operation as an add.
                    FindAliveStatus = FIND_ALIVE_NOTFOUND;

                    if (NULL != pMetaDataVecLocal) {
                        THFreeEx(pTHS, pMetaDataVecLocal);
                        pMetaDataVecLocal = NULL;
                    }
                }
            }

            if ((FIND_ALIVE_NOTFOUND == FindAliveStatus)
                && (RepFlags & DRS_WRIT_REP)
                && !DsaIsInstalling()) {
                DraHostWriteableNc( pTHS, pent->pName );
            }
        }

        if (!ret) {
            // Check that we aren't trying to delete a protected object
            // (e.g., the local DSA object, one of its ancestors, or a
            // cross-ref for a locally writeable NC).

            if (OBJECT_BEING_DELETED == DeletionStatus) {

                if (FindAliveStatus == FIND_ALIVE_FOUND) {
                    // Proxy objects are deleted at the outset -- we shouldn't find
                    // a "live" proxy object that we need to delete.
                    Assert(!fIsProxyObject);

                    // Deleting an existing object, see if it's a protected one.
                    // Note that we can flag a bad delete even if we wouldn't
                    // otherwise apply the deletion -- this is important now that
                    // deletion implies removal of many other attributes.  (The
                    // "bad delete" detection will ensure that these attributes are
                    // not removed.)
                    fBadDelete = fDNTInProtectedList(dntObj, NULL)
                        || IsCrossRefProtectedFromDeletion(pent->pName);

                    if (!fBadDelete) {
                        // The inbound data says the object should be deleted, and
                        // the object has no special protection locally against
                        // deletion; does the meta data imply we should accept this
                        // change?
                        pMetaDataLocal = ReplLookupMetaData(ATT_IS_DELETED,
                                                            pMetaDataVecLocal,
                                                            NULL);
                        pMetaDataRemote = ReplLookupMetaData(ATT_IS_DELETED,
                                                             pMetaDataVecRemote,
                                                             NULL);
                        Assert(NULL != pMetaDataRemote);

                        fDeleteLocalObj = (ReplCompareMetaData(pMetaDataRemote,
                                                               pMetaDataLocal)
                                           > 0);
                    }
                } else if (FindAliveStatus == FIND_ALIVE_NOTFOUND) {
                    // Normally we want to redelete locally when adding deleted.
                    // However, certain well known containers are deleted but do not have
                    // mangled names and their deletion time should be in the future. They
                    // rely on the fact that replication adds them without deleting them.
                    // We detect these containers by the fact that their names are not mangled.
                    if (IsMangledDSNAME( pent->pName, NULL )) {
                        fDeleteLocalObj = TRUE;
                    }
                }
            }

            // Determine if this is an update to an ancestor of the local DSA
            // (or the local DSA object itself) in the config NC.
            if ((FIND_ALIVE_FOUND == FindAliveStatus)
                && (dntNC != INVALIDDNT)
                && (dntNC == gAnchor.ulDNTConfig)) {
                for (i = 0; i < gAnchor.AncestorsNum; i++) {
                    if (dntObj == gAnchor.pAncestors[i]) {
                        fIsAncestorOfLocalDsa = TRUE;
                        break;
                    }
                }
            }

            // The RepFlags are checked to enable a special repair mode where existing
            // objects always lose in replication, allowing then to be readded in place
            *pUpdateStatus = ReplReconcileRemoteMetaDataVec(
                                pTHS,
                                ( ((RepFlags & DRS_FULL_SYNC_IN_PROGRESS) && (RepFlags & DRS_SYNC_FORCED)) ?
                                  NULL : pMetaDataVecLocal),
                                fIsAncestorOfLocalDsa,
                                (FindAliveStatus == FIND_ALIVE_OBJ_DELETED),
                                fDeleteLocalObj,
                                fBadDelete,
                                DeletionStatus,
                                pent,
                                pMetaDataVecRemote,
                                &pParentGuid,
                                &AttrBlockToApply,
                                &pMetaDataVecToApply
                                );
            Assert(*pUpdateStatus || !fDeleteLocalObj);

            if (*pUpdateStatus)
            {
                if (fMoveToLostAndFound) {
                    if (itNew & IT_WRITE) {
                        // Writeable NC.  Flag the meta data such that the name
                        // change is replicated back out to other DSAs.
                        ReplOverrideMetaData(ATT_RDN, pMetaDataVecToApply);
                    } else {
                        // Read-only NC.  Flag the meta data such that our
                        // temporary rename will unilaterally lose compared to
                        // a "real" rename from a writeable source.
                        ReplUnderrideMetaData(pTHS,
                                              ATT_RDN,
                                              &pMetaDataVecToApply,
                                              NULL);
                    }
                }

                if (    ( FIND_ALIVE_FOUND       == FindAliveStatus )
                     || ( FIND_ALIVE_OBJ_DELETED == FindAliveStatus )
                   )
                {
                    Assert(INVALIDDNT != dntObj);
                    Assert(INVALIDDNT != dntObjNC);

                    if ((INVALIDDNT != dntNC)
                        && (dntObjNC != dntNC)
                        && (dntObj != dntNC)) {
                        // This object is in the wrong NC; i.e., it has been moved across
                        // domains, and the source (remote) and destination (local) DSAs
                        // don't agree on which NC the object is currently in.  This is a
                        // transient condition that will be rectified by replicating in the
                        // other direction and/or by replicating the other NC involved.
                        DPRINT1(0,
                                "Cannot update inbound object %ls because it exists "
                                    "locally in an NC other than the one being replicated "
                                    "-- should be a transient condition.\n",
                                pent->pName->StringName);
                        DRA_EXCEPT(ERROR_DS_DRA_OBJ_NC_MISMATCH, 0);
                    }

                    // Trim unneeded group memberships
                    if ( (FIND_ALIVE_FOUND == FindAliveStatus) &&
                         (CLASS_GROUP == objectClassId) &&
                         (itNew == INT_FULL_REPLICA) && /* readonly */
                         (!fMoveToLostAndFound) &&
                         (!fDeleteLocalObj) ) {

                        GcCleanupUniversalGroupDemotion(
                            pTHS,
                            pent->pName,
                            &AttrBlockToApply,
                            pMetaDataVecLocal
                            );
                    }
                    DPRINT2(4, "Modifying %d attrs on %ws\n",
                                pent->AttrBlock.attrCount, pent->pName->StringName);

                    ret = ModifyLocalObjRetry(pTHS,
                                              dntNC,
                                              pent->pName,
                                              &AttrBlockToApply,
                                              pParentGuid,
                                              pMetaDataVecToApply,
                                              fMoveToLostAndFound,
                                              fDeleteLocalObj);
                }
                else
                {
                    // Process proxy objects for their side effect before
                    // adding them.  Want side effect AND add so that proxy
                    // propagates to other replicas.

                    if ( fIsProxyObject )
                    {
                        Assert(OBJECT_BEING_DELETED == DeletionStatus);
                        Assert(pProxyVal);
                        ret = ProcessProxyObject(pTHS, pent, pProxyVal);
                    }

                    if (!ret)
                    {
                        ret = AddLocalObj(pTHS,
                                          dntNC,
                                          pent,
                                          pParentGuid,
                                          fNCPrefix,
                                          fDeleteLocalObj,
                                          &AttrBlockToApply,
                                          pMetaDataVecToApply,
                                          fMoveToLostAndFound);

                        if (pPreservedAttrs && !ret) {
                            // we have some preserved non-replicated attrs to add here
                            Assert( NameMatchedStringNameOnly( pent->pName, pPreservedAttrs->pName ) );
                            ret = ModifyLocalObjRetry(pTHS,
                                                      dntNC,
                                                      pPreservedAttrs->pName,
                                                      &pPreservedAttrs->AttrBlock,
                                                      pParentGuid,
                                                      NULL,
                                                      FALSE,
                                                      FALSE);
                            if (ret) {
                                Assert(!"Error: Failed to add new PreservedAttrs to new source");
                                DRA_EXCEPT(ret, 0);
                            }
                            // we don't need the mem any longer.
                            THFreeEx(pTHS, pPreservedAttrs);
                        }

                        if (!ret && fDeleteLocalObj) {
                            // Refresh dntObj 'cause we need it below
                            dntObj = pTHS->pDB->DNT;
                            Assert(dntObj == DBGetDntFromDSName( pTHS->pDB,pent->pName));
                        }
                    }
                }

                THFreeEx(pTHS, AttrBlockToApply.pAttr);

                PERFINC(pcRepl);
            }
            else {
                // No updates to apply for this object.
                PERFINC(pcDRAInObjsFiltered);
                DPRINT2(4, "Skipped update for %d attrs in %ws\n",
                        pent->AttrBlock.attrCount, pent->pName->StringName);
            }
        }

        // If all Ok so far, see if master object was deleted and we
        // need to update.

        if (!ret && fDeleteLocalObj) {
            Assert(*pUpdateStatus);
            Assert(!fNCPrefix);

            // make sure the currency is on the object to be removed
            if (DBFindDNT(pTHS->pDB, dntObj)) {
                // Unable to set currency.
                DRA_EXCEPT (DRAERR_DBError, 0);
            }

            // Object is alive here and was deleted remotely, so delete it here.
            // Don't preserve its RDN or force it to be immediately garbage
            // collected.
            ret = DeleteRepObj(pTHS,
                               pent->pName,
                               FALSE,
                               FALSE,
                               pMetaDataVecToApply);
        }

        // If an object was revived, revive its link values
        if (!ret && fBadDelete) {
            CHAR szTime1[SZDSTIME_LEN];

            ReplOverrideLinks( pTHS );

            // The scene of the crime
            pMetaDataRemote = ReplLookupMetaData(ATT_IS_DELETED,
                                                 pMetaDataVecRemote,
                                                 NULL);
            Assert(NULL != pMetaDataRemote);

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_OBJECT_REVIVED,
                     szInsertDN(pent->pName),
                     szInsertDN(
                         draGetServerDsNameFromGuid(
                             pTHS,
                             Idx_InvocationId,
                             &(pMetaDataRemote->uuidDsaOriginating) ) ),
                     szInsertDSTIME(pMetaDataRemote->timeChanged, szTime1) );
        }

        if (0 == ret) {
            // Success -- update attrs applied/discarded performance counters.
            DWORD cPropsApplied = pMetaDataVecToApply
                                    ? pMetaDataVecToApply->V1.cNumProps
                                    : 0;
            Assert(pMetaDataVecRemote->V1.cNumProps >= cPropsApplied);

            // Applied and discarded inbound attributes.
            IADJUST(pcDRASyncPropUpdated, cPropsApplied);
            IADJUST(pcDRASyncPropSame,
                    pMetaDataVecRemote->V1.cNumProps - cPropsApplied);

#if DBG
            ReplCheckMetadataWasApplied(
                pTHS,
                pMetaDataVecToApply
                );
#endif
        }

        if (NULL != pMetaDataVecToApply) {
            THFreeEx(pTHS, pMetaDataVecToApply);
        }
    }

    if (NULL != pMetaDataVecLocal) {
        THFreeEx(pTHS, pMetaDataVecLocal);
    }

    if (0 == ret) {
        // Success -- update inbound props/values/DN values counters.
        ATTR * pAttr = &pent->AttrBlock.pAttr[0];
        for (i = 0; i < pent->AttrBlock.attrCount; i++, pAttr++) {
            ATTCACHE * pAC = SCGetAttById(pTHS, pAttr->attrTyp);
            Assert((NULL != pAC) && "We just found this att moments ago...?");
            if (IS_DN_VALUED_ATTR(pAC)) {
                // A DN-valued attribute.
                IADJUST(pcDRAInDNValues, pAttr->AttrVal.valCount);
            }

            // DN-valued or not it gets added to the total.
            IADJUST(pcDRAInValues, pAttr->AttrVal.valCount);
        }

        IADJUST(pcDRAInProps, pMetaDataVecRemote->V1.cNumProps);
    }

    return ret;
}


/* LogUpdateFailure - Log a replication update failure.
 * Note, this is called when the error is DRAERR_BUSY
 * This is a warning.  The operation will be retried.
 *
 */
void
LogUpdateFailure(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName
    )
{
    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DRA_UPDATE_FAILURE,
             szInsertDN(pDistName),
             szInsertWC(pszServerName),
             NULL);
}

/* LogUpdateFailureNB - Log a non busy replication update failure.
 * This is for non-transient errors.
 */
void
LogUpdateFailureNB(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName,
    IN  GUID *      puuidObject,
    IN  ULONG       ulError
    )
{
    LogEvent8(DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_UPDATE_FAILURE_NOT_BUSY,
              szInsertDN(pDistName),
              szInsertUUID(puuidObject),
              szInsertWC(pszServerName),
              szInsertWin32Msg(ulError),
              szInsertWin32ErrCode(ulError),
              NULL, NULL, NULL );
}

/* LogUpdateValueFailureNB - Log a non busy replication update failure.
 * This is for non-transient errors.
 */
void
LogUpdateValueFailureNB(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pDistName,
    IN  REPLVALINF *pReplValInf,
    IN  ULONG       ulError
    )
{
    ATTCACHE *pAC;
    DSNAME dnDummy;
    DSNAME *pdnValue;

    // Get the attribute cache entry
    if ((NULL == (pAC = SCGetAttById(pTHS, pReplValInf->attrTyp)))
        || (NULL == (pdnValue = DSNameFromAttrVal(pAC, &pReplValInf->Aval)))) {
        // Try to keep going even if errors occur
        pdnValue = &dnDummy;
        memset( pdnValue, 0, sizeof( DSNAME ) );
    }

    LogEvent8(DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_ALWAYS,
              DIRLOG_DRA_UPDATE_VALUE_FAILURE_NOT_BUSY,
              szInsertDN(pDistName),
              szInsertUUID(&(pReplValInf->pObject->Guid)),
              szInsertWC(pszServerName),
              szInsertWin32Msg(ulError),
              szInsertSz( pAC ? pAC->name : "bad attribute type" ),
              szInsertDN( pdnValue ),
              szInsertUUID( &(pdnValue->Guid) ),
              szInsertUL( pReplValInf->fIsPresent ) );
}


BOOL
draCheckReplicationLifetime(
    IN      THSTATE *pTHS,
    IN      UPTODATE_VECTOR *       pUpToDateVecDest,
    IN      UUID *                  puuidInvocIdSrc,
    IN      UUID *                  puuidDsaObjSrc,
    IN      LPWSTR                  pszSourceServer
    )

/*++

Routine Description:

    We assume we are only called on a successful replication with the source so as
    not to generate messages when we can't reach the source.

    We assume we are called with the most recent invocation id for the source.

    We have just received the first packet back from a source. See if we have
    a replication latency timestamp from the invocation id of this source. If we
    do, it means we replicated with him in the past. Verify that the time since
    the last replication has not exceeded a tombstone lifetime

    This routine returns TRUE if it cannot tell:
    o We don't have an up to date vector
    o We haven't replicated with this source before
    o The source hasn't returned a timestamp for us to use (W2K source)

    W2K machines are not validated. The reason is that W2K machines don't return
    a timestamp. .net machines will transitively generate one for them. But if we
    ever go from generating one to not generating one, we will create a false negative.
    Consider the following:
    A-net <- B-net <- C-w2k         A has a timestamp for C by virtue of B
    A-net <- D-w2k <- C-w2k         A no longer gets timestamps for C
    A-net <- C-w2k                  Incorrectly denied

    It would be cool to track average replication latency somewhere. The UTDVEC is not a place
    to keep statistics. The logical place to keep per-machine, per-source data is the reps-
    from. Someday it would be nice to enhance UpdateRefs to calculate average latency
    for hour, day and weekly windows.  Keep a count of replications might be neat too.

Arguments:

    pTHS - thread state
    pUpToDateVec - Up to date vector for this NC, if we have one. We may not if a
                   first full sync has not occurred for this NC yet.
    puuidInvocIdSrc - The most current invocation id of this source
                  

Return Value:

    Whether or not replication has occurred within a tombstone lifetime

--*/

{
    DSTIME timeLastSyncSuccess;
    DSTIME timeNow;
    ULONG ulSecondsSinceLastRepl;
    ULONG ulTombstoneLifetimeSecs;
    CHAR szUuid1[SZUUID_LEN];
    CHAR szTime1[SZDSTIME_LEN];
    BOOL fOverrideLimit = FALSE;

    // This routine is called at the start of every replication cycle. We postpone the
    // expensive checks until after we know whether we have a potential failure.

    if (!pUpToDateVecDest) {
        // If we don't have one, can't check. Generally this means a very new nc
        return TRUE;
    }

    // See if the up to date vec has a latency timestamp for this invocation id
    // W2K sources won't have one.
    // We assume that once a source has a timestamp, it will never revert to not
    // returning one.
    if ((!UpToDateVec_GetCursorTimestamp( pUpToDateVecDest,
                                         puuidInvocIdSrc,
                                         &timeLastSyncSuccess )) ||
        (timeLastSyncSuccess == 0) ) {
        return TRUE;
    }

    // Calculate how long since last replication
    timeNow = GetSecondsSince1601();
    if (timeNow >= timeLastSyncSuccess) {
        ulSecondsSinceLastRepl = (ULONG) (timeNow - timeLastSyncSuccess);
    } else {
        ulSecondsSinceLastRepl = 0;
    }

    // Get the tombstone lifetime
    ulTombstoneLifetimeSecs = gulTombstoneLifetimeSecs ?
        gulTombstoneLifetimeSecs :
        DEFAULT_TOMBSTONE_LIFETIME * DAYS_IN_SECS;

    // Do the timliness check
    if (ulSecondsSinceLastRepl < ulTombstoneLifetimeSecs) {
        // There is a timstamp and it is current. Return true.
        return TRUE;
    }

    //
    // Timestamp is not current
    //

    // Give user a way to override the limit
    GetConfigParam(DRA_OVERRIDE_TOMBSTONE_LIMIT, &fOverrideLimit, sizeof(DWORD));
    if (fOverrideLimit) {
        return TRUE;
    }

    // Don't count w2k sources
    // Improvement:
    // It would be nice to have a more efficient way to tell the behavior version of
    // the source. Perhaps it could be returned in the reply or in the bind extensions.
    // If we could get at the version number of the reply, that would tell us.
    if ( gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
        DSNAME dsTarget;
        DWORD dwTargetBehavior = 0;
        DWORD ulErr;
        DBPOS *pDB = NULL;  

        // Get target behavior version
        ZeroMemory(&dsTarget, sizeof(DSNAME));
        dsTarget.structLen = DSNameSizeFromLen(0);
        dsTarget.Guid = *puuidDsaObjSrc;

        // Don't disturb currency
        DBOpen(&pDB);
        __try {
            ulErr = GetBehaviorVersion(pDB, &dsTarget, &dwTargetBehavior);
        } __finally {
            DBClose(pDB, TRUE);
        }

        DPRINT2( 2, "Behavior version of %s is %d.\n",
                 DsUuidToStructuredString(puuidDsaObjSrc, szUuid1),
                 dwTargetBehavior );

        if ( ERROR_SUCCESS == ulErr &&
             dwTargetBehavior < DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
            // Don't count w2k sources
            return TRUE;
        }
    }

    Assert( !"Servers have not replicated in a tombstone lifetime. Did someone adjust the tombstone lifetime?" );

    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_ALWAYS,
               DIRLOG_DRA_SOURCE_LIFETIME_EXPIRED,
               szInsertDSTIME(timeLastSyncSuccess, szTime1),
               szInsertUUID(&puuidInvocIdSrc),
               szInsertWC(pszSourceServer),
               szInsertUL(ulTombstoneLifetimeSecs / (24 * 60 * 60 )),
               szInsertSz(DRA_OVERRIDE_TOMBSTONE_LIMIT), 
               NULL, NULL, NULL);

    return FALSE;
}

/* ReplicateNC - Replicate the NC specified by pNC on the local DSA.
*
*  Notes:
*       We expect to enter this routine with a READ lock set. We exit the
*       routine with a WRITE lock set, unless an error occurs in which case
*       there may or may not be a write lock set.
*
* A note on sync options:
* RepFlags - persistant flags plus subset of caller flags. We pass to the source and also
*            store in the replica link.
* ulOptions - Just the dynamic options which the sync call supplied. Does not include all
*             persistent flags. Used to detect special temporary modes set by caller.
*
* When the DRS_CRITICAL_ONLY option is set, this routine is modified in the
* following ways.  First, this option is passed to GetChanges so that only
* critical objects are returned.  Second, since this operation does not get
* all changed objects, the bookmarks are not updated.
*
* There are atleast three ways to indicate a "full sync" in this routine:
* 1. pusnvecLast set to gusnvecfromScratch.  The UTD is used in this case,
*    and may or may not have a filter for the source.  This case is done
*    by Replica Add.
* 2. Caller specified FULL_SYNC_NOW.  In this case, we set the usn vec from to
*    scratch, and we don't load the UTD, making it NULL. This flag is NOT
*    preserved in the reps-from. We also set the reps-from flag
*    FULL_SYNC_IN_PROGRESS, so we can remember on reboot that we are in this
*    mode.
* 3. RepFlags has FULL_SYNC_IN_PROGRESS set.  This indicates we crashed or
*    failed to finish a FULL_SYNC_NOW.  We take whatever usn from vec we last
*    saved.  We force the UTD to be NULL.
*
*  Results:
*       0 if successfull, an error code otherwise.
*/

ULONG
ReplicateNC(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN      MTX_ADDR *              pmtx_addr,
    IN      LPWSTR                  pszSourceDsaDnsDomainName,
    IN      USN_VECTOR *            pusnvecLast,
    IN      ULONG                   RepFlags,
    IN      REPLTIMES *             prtSchedule,
    IN OUT  UUID *                  puuidDsaObjSrc,
    IN      UUID *                  puuidInvocIdSrc,
    IN      ULONG *                 pulSyncFailure,
    IN      BOOL                    fNewReplica,
    IN      UPTODATE_VECTOR *       pUpToDateVec,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx,
    IN      ULONG                   ulOptions,
    OUT     BOOL *                  pfBindSuccess
    )
{
    ULONG                       ret = 0, err = 0, retNextPkt = 0;
    ULONG                       ulFlags;
    DWORD                       dwNCModified = MODIFIED_NOTHING;
    DRS_MSG_GETCHGREQ_NATIVE    msgReqUpdate = {0};
    DRS_MSG_GETCHGREQ_NATIVE    msgReqUpdateNextPkt;
    DRS_MSG_GETCHGREPLY_NATIVE  msgUpdReplica = {0};
    ULONG                       ulResult, len;
    ULONG                       dntNC = INVALIDDNT;
    ULONG                       ret2 = DRAERR_Generic;
    UUID                        uuidDsaObjSrc;
    DWORD                       sourceNCSize;
    DWORD                       sourceNcSizeObjects, sourceNcSizeValues;
    DWORD                       totalObjectsReceived, totalObjectsCreated;
    DWORD                       objectsCreated;
    DWORD                       totalValuesReceived;
    LPWSTR                      pszSourceServer;
    BYTE                        schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    DWORD                       cNumPackets = 0;
    BOOL                        fSchInfoChanged = FALSE;
    DRS_ASYNC_RPC_STATE         AsyncState = {0};
    SYNTAX_INTEGER              it;
    DRA_REPL_SESSION_STATISTICS replStats = {0};
    BOOL                        fIsPreemptable = FALSE;

#if DBG
// Debugging variables:
    ULONG           iobjs = 0;
#endif

    // if this a PAS cycle, we better have PAS data.
    Assert(!(RepFlags & DRS_SYNC_PAS) ||
           (pPartialAttrSet && pPartialAttrSetEx) );

    pszSourceServer = TransportAddrFromMtxAddrEx(pmtx_addr);

    DPRINT2(3, "ReplicateNC, NC='%ws', options=%x\n", pNC->StringName, RepFlags );

    // Critical only is only allowed with new replicas...
    Assert( !(RepFlags & DRS_CRITICAL_ONLY) || fNewReplica );
    // Critical only requires get ancestors since parents may not be critical
    if (RepFlags & DRS_CRITICAL_ONLY) {
        RepFlags |= DRS_GET_ANC;
    }

    // Find the NC object, get and save its DNT.
    // This may not succeed if the NC head has not be replicated in yet
    if (0 == FindNC(pTHS->pDB, pNC,
                     FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
        dntNC = pTHS->pDB->DNT;
    }

    *pulSyncFailure = 0;

    msgReqUpdate.uuidDsaObjDest = gAnchor.pDSADN->Guid;
    msgReqUpdate.uuidInvocIdSrc = puuidInvocIdSrc ? *puuidInvocIdSrc : gNullUuid;
    msgReqUpdate.pNC            = pNC;
    msgReqUpdate.ulFlags        = RepFlags;

    // Packet size will be filled in by I_DRSGetNCChanges().
    Assert(0 == msgReqUpdate.cMaxObjects);
    Assert(0 == msgReqUpdate.cMaxBytes);

    // Save the UUIDs we will set in the Reps-From property should we add or
    // modify it.
    if (fNewReplica) {
        uuidDsaObjSrc = gNullUuid;
    }
    else {
        uuidDsaObjSrc  = *puuidDsaObjSrc;
    }

    // If we want to sync from scratch, set sync to usn start point
    if (msgReqUpdate.ulFlags & DRS_FULL_SYNC_NOW) {
        msgReqUpdate.usnvecFrom = gusnvecFromScratch;
        msgReqUpdate.ulFlags |= DRS_FULL_SYNC_IN_PROGRESS | DRS_NEVER_SYNCED;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_USER_REQ_FULL_SYNC,
                 szInsertWC(pNC->StringName),
                 szInsertSz(pmtx_addr->mtx_name),
                 szInsertHex(RepFlags));
    }
    else {
        msgReqUpdate.usnvecFrom = *pusnvecLast;
    }

    // partial attr set
    msgReqUpdate.pPartialAttrSet   = (PARTIAL_ATTR_VECTOR_V1_EXT*)pPartialAttrSet;
    msgReqUpdate.pPartialAttrSetEx = (PARTIAL_ATTR_VECTOR_V1_EXT*)pPartialAttrSetEx;

    if ( msgReqUpdate.pPartialAttrSet ||
         msgReqUpdate.pPartialAttrSetEx ) {
        // send mapping table if we send any attr list.
        msgReqUpdate.PrefixTableDest = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
        ret = AddSchInfoToPrefixTable(pTHS, &msgReqUpdate.PrefixTableDest);
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }
    }


    // There are three "restartable modes", DRS_FULL_SYNC_IN_PROGRESS, and
    // DRS_FULL_SYNC_PACKET & DRS_SYNC_PAS.  We keep a flag in
    // the replica link while they are active.  If we crash and restart, we
    // detect that we are still in the mode, and enable them again

    if (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) {
        // Send source our current up-to-date vector to use as a filter.
        msgReqUpdate.pUpToDateVecDest = pUpToDateVec;
    }

    // Request source NC size on first packet of a full sync
    if (msgReqUpdate.usnvecFrom.usnHighPropUpdate == 0) {
        msgReqUpdate.ulFlags |= DRS_GET_NC_SIZE;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_FULL_SYNC_CONTINUED,
                 szInsertWC(pNC->StringName),
                 szInsertSz(pmtx_addr->mtx_name),
                 szInsertHex(RepFlags));

        // Determine initial count of objects if NC already exists
        if (dntNC != INVALIDDNT) {
            replStats.ulTotalObjectsCreated = DraGetNcSize(pTHS, 
                                                           (RepFlags & DRS_CRITICAL_ONLY),
                                                           dntNC);
            if (pTHS->fLinkedValueReplication) {
                // Only values in the database after LVR mode enabled
                replStats.ulTotalValuesCreated = DBGetApproxNCSizeEx(
                    pTHS->pDB,
                    pTHS->pDB->JetLinkTbl,
                    Idx_LinkDraUsn,
                    dntNC );
            }
        }
        // currency is lost after this, but ok, since reestablished below
    }

    // We entered this routine with a READ_ONLY transaction which
    // we don't need anymore.
    EndDraTransaction(TRUE);

    __try {


        // Mark the heap so that we can discard heap allocated memory after
        // each getnccchanges call.
        TH_mark(pTHS);

        EnterCriticalSection(&csLastReplicaMTX);
        pLastReplicaMTX = pmtx_addr;
        LeaveCriticalSection(&csLastReplicaMTX);

        if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
            goto LABORT;
        }

        // Abort if inbound replication is disabled and this is not a forced
        // sync.
        if (gAnchor.fDisableInboundRepl && !(RepFlags & DRS_SYNC_FORCED)) {
            *pulSyncFailure = DRAERR_SinkDisabled;
            goto LABORT;
        }

        // Abort if this is an intersite periodic sync and the time is outside
        // of the replication schedule window. A queue backup could have
        // delayed its execution. We do this check here (as opposed to drasync)
        // so that the error will be communicated back to the user in the reps-from.
        // FUTURE: This feature is optional because it is incomplete. What we want to
        // enforce is the site link availability schedule, and that is not available
        // here. What is on the reps-from is the polling start schedule. What we are
        // enforcing here is that the sync starts on a polling start point, but that
        // is only 15 minutes wide. Second, since connections cover all nc's, there could
        // be a large number of per-nc syncs queued at the same time. This current check
        // assumes that all nc's can be started within the window, which may not be true.
        // Third, some customers don't care about schedules, or haven't set up their
        // schedules to be staggered. For these customers, strict windows will cause errors
        // where there were none before. This feature is for advanced users.
        if ( gfStrictScheduleWindow && (ulOptions & DRS_PER_SYNC) && (RepFlags & DRS_NEVER_NOTIFY) ) {
            DSTIME timeNow = DBTime();
            DSTIME timeLastIteration = timeNow - SCHEDULE_UNIT;

            // This check is indended to match the window at which scheduled syncs are put
            // into the queue (drainit.c), plus allowing for some delay in getting here.
            if (!fIsBetweenTime( prtSchedule, timeLastIteration, timeNow )) {
                DPRINT2( 0, "repl queue overload:sync out of window stopped: nc %ws source %ws\n",
                         pNC->StringName, pszSourceServer );
                *pulSyncFailure = ERROR_DS_DRA_OUT_SCHEDULE_WINDOW;
                goto LABORT;
            }
        }

        PERFINC(pcDRASyncRequestMade);

        ret = I_DRSGetNCChanges(pTHS,
                                pszSourceServer,
                                pszSourceDsaDnsDomainName,
                                pNC,
                                &msgReqUpdate,
                                &msgUpdReplica,
                                schemaInfo,
                                NULL,
                                pfBindSuccess );
        if (ret) {
            goto LABORT;
        }

        if (0 == memcmp(&msgUpdReplica.uuidDsaObjSrc,
                        &gAnchor.pDSADN->Guid,
                        sizeof(GUID))) {
            // Can't replicate from self!
            ret = ERROR_DS_CLIENT_LOOP;
            goto LABORT;
        }

        // If this is not a new replica, verify that we contacted the correct
        // source server.
        if (!fNewReplica
            && memcmp(&msgUpdReplica.uuidDsaObjSrc, puuidDsaObjSrc,
                      sizeof(UUID))) {
            // This not a new replica, but the DSA object guid mentioned by
            // the source is different from that recorded in the Reps-From.
            // Since the network name that we associate with the source is
            // derived from its GUID-based DNS name, this usually indicates
            // stale entries in DNS; i.e., the IP address given us by DNS no
            // longer corresponds to the right server.
            ret = DRAERR_NoReplica;
            goto LABORT;
        }

        if ( (!(RepFlags & DRS_SYNC_FORCED)) &&
             (!draCheckReplicationLifetime( pTHS,
                                            pUpToDateVec,
                                            &msgUpdReplica.uuidInvocIdSrc,
                                            &msgUpdReplica.uuidDsaObjSrc,
                                            pszSourceServer))) {
            ret = ERROR_DS_REPL_LIFETIME_EXCEEDED;
            goto LABORT;
        }

        uuidDsaObjSrc  = msgUpdReplica.uuidDsaObjSrc;

        msgReqUpdate.ulFlags &= ~DRS_GET_NC_SIZE; // Clear bit for next call

        msgUpdReplica.ulExtendedRet = 0;

        replStats.SourceNCSizeObjects = msgUpdReplica.cNumNcSizeObjects;
        replStats.SourceNCSizeValues = msgUpdReplica.cNumNcSizeValues;

        // We have done our initial read of the other DSA and are about
        // to start updating this DSA.

        ulFlags = msgReqUpdate.ulFlags;

        do {
            Assert( msgUpdReplica.dwDRSError == ERROR_SUCCESS );

            if (0 != memcmp(&uuidDsaObjSrc,
                            &msgUpdReplica.uuidDsaObjSrc,
                            sizeof(UUID))) {
                // Source changed identities between packets?
                DRA_EXCEPT(DRAERR_InternalError, 0);
            }
            // uuidInvocIdSrc may change from packet to packet

            // if we are here, we have made one successful GetNCChanges() and
            // are about to process the results.
            PERFINC(pcDRASyncRequestSuccessful);

            if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
                *pulSyncFailure = DRAERR_Preempted;
                break;
            }

            if (msgUpdReplica.fMoreData) {
                // Send async request to source to begin compiling the next
                // packet of changes for us.
                msgReqUpdateNextPkt            = msgReqUpdate;
                // Usnvec and Invocation id must be updated together
                msgReqUpdateNextPkt.uuidInvocIdSrc = msgUpdReplica.uuidInvocIdSrc;
                msgReqUpdateNextPkt.usnvecFrom = msgUpdReplica.usnvecTo;
                msgReqUpdateNextPkt.ulFlags    = ulFlags;

                gcNumPreFetchesTotal++;
                retNextPkt = I_DRSGetNCChanges(pTHS,
                                               pszSourceServer,
                                               pszSourceDsaDnsDomainName,
                                               pNC,
                                               &msgReqUpdateNextPkt,
                                               &msgUpdReplica,
                                               schemaInfo,
                                               &AsyncState,
                                               pfBindSuccess );
            }

            // Indicate we're busy (for dead thread check)
            gfDRABusy = TRUE;

            // Set the count of remaining entries to update.
            ISET (pcRemRepUpd, msgUpdReplica.cNumObjects);
            ISET (pcDRARemReplUpdLnk, msgUpdReplica.cNumValues);
            ISET (pcDRARemReplUpdTot, msgUpdReplica.cNumValues+msgUpdReplica.cNumObjects);  

            // set the cumulative count of objects received
            IADJUST(pcDRASyncObjReceived, ((LONG) msgUpdReplica.cNumObjects));

            replStats.ObjectsReceived += msgUpdReplica.cNumObjects;
            replStats.ValuesReceived += msgUpdReplica.cNumValues;
#if DBG
            iobjs += msgUpdReplica.cNumObjects;
#endif
            ret = UpdateNC(pTHS,
                           pNC,
                           &msgUpdReplica,
                           pszSourceServer,
                           pulSyncFailure,
                           msgReqUpdate.ulFlags,
                           &dwNCModified,
                           &replStats.ObjectsCreated,
                           &replStats.ValuesCreated,
                           schemaInfo,
                           fIsPreemptable ? UPDNC_IS_PREEMTABLE : 0);

            // Make final updates.
            // Do the following if we succeed and there is no more data.
            // The initial inbound replication of this NC is now complete.
            // Even though the fMoreData flag is false, indicating the source
            // has run out of objects, the source may itself still be coming.
            // Wait until the source returns a non-NULL UTD as an additional
            // measure that the NC is ready.
                        
            // We do these final operations here instead of at the end of the
            // routine because we release the RPC results in this loop.

            if (    !ret
                 && !*pulSyncFailure
                 && !msgUpdReplica.fMoreData
                 &&  msgUpdReplica.pUpToDateVecSrc
                 && !(RepFlags & DRS_ASYNC_REP)
                 && (!(RepFlags & DRS_CRITICAL_ONLY)) )
            {
                // we're now up-to-date with respect to the source DSA, so
                // we're also now transitively up-to-date with respect to
                // other DSAs to at least the same point as the source DSA

                // if this is the schema NC, trigger a schema cache update,
                // except when it is installing, since during install, any
                // new schema object is added to the cache immediately anyway

                if ((MODIFIED_NCTREE_INTERIOR == dwNCModified)
                    && NameMatched(gAnchor.pDMD, pNC)
                    && DsaIsRunning() )
                {
                    // we just synced a schema NC successfully and atleast one
                    // modification is made to the schema. Trigger a schema cache update
                    if (!SCSignalSchemaUpdateImmediate())
                    {
                        // couldn't even signal a schema update
                        DRA_EXCEPT (DRAERR_InternalError, 0);
                    }
                }

                BeginDraTransaction(SYNC_WRITE);
                __try {
                    ret = FindNC(pTHS->pDB,
                                 pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC,
                                 &it);
                    if (ret) {
                        DRA_EXCEPT(DRAERR_InconsistentDIT, ret);
                    }

                    if (it & IT_NC_COMING) {
                        ret = ChangeInstanceType(pTHS, pNC, it & ~IT_NC_COMING, DSID(FILENO,__LINE__));
                        if (ret) {
                            DRA_EXCEPT(ret, 0);
                        }
                        Assert(CheckCurrency(pNC));
                    }

                    if (RepFlags & DRS_SYNC_PAS) {
                        //
                        // We've had completed a successful PAS cycle.
                        // At this point we can only claim to be as up to date as our source.
                        // Action:
                        //  - Overwrite our UTD w/ the source's UTD.
                        //  - complete PAS replication:
                        //      - reset other links USN vectors
                        //      - reset this source's flags
                        //
                        UpToDateVec_Replace(pTHS->pDB,
                                            &msgUpdReplica.uuidInvocIdSrc,
                                            &msgUpdReplica.usnvecTo,
                                            msgUpdReplica.pUpToDateVecSrc);

                        // asset: must have PAS data for PAS cycles
                        Assert(pPartialAttrSet && pPartialAttrSetEx);

                        // do the rest: USN water marks & update repsFrom
                        (void)GC_CompletePASReplication(
                                pTHS,
                                pNC,
                                &uuidDsaObjSrc,
                                pPartialAttrSet,
                                pPartialAttrSetEx);
                        msgReqUpdate.ulFlags &= ~DRS_SYNC_PAS;
                    } else {

                        // pUpToDateVecSrc may be null here for legitimate reasons
                        Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(msgUpdReplica.pUpToDateVecSrc));
#if DBG
                        {
                            USN usn;
                            // puptodvecRemote should already contain an entry for the source DSA.
                            Assert(
                                ( UpToDateVec_GetCursorUSN(
                                    msgUpdReplica.pUpToDateVecSrc,
                                    &msgUpdReplica.uuidInvocIdSrc,
                                    &usn) &&
                                  (usn >= msgUpdReplica.usnvecTo.usnHighPropUpdate) ) );
                        }
#endif
                        // improve our up-to-date vector for this NC
                        UpToDateVec_Improve(pTHS->pDB, msgUpdReplica.pUpToDateVecSrc);
                    }

                    // Since we have just completed a replication session,
                    // Notify other replicas if there has been at least one
                    // modification to the NC tree.
                    if (MODIFIED_NOTHING != dwNCModified) {
                        DBNotifyReplicas(pNC,
                                         RepFlags & DRS_SYNC_URGENT);
                    }

                    // If we were full-syncing, we're done.
                    msgReqUpdate.ulFlags &= ~DRS_FULL_SYNC_IN_PROGRESS;

                    // And we've completed at least one sync now.
                    msgReqUpdate.ulFlags &= ~DRS_NEVER_SYNCED;
                } __finally {
                    EndDraTransaction(!AbnormalTermination());
                }
            }

            // Release results now that we've tried to apply them.
            TH_free_to_mark(pTHS);
            TH_mark(pTHS);

            if (ret == DRAERR_MissingParent) {
                // Ok we failed to apply the update becuase we had a
                // missing parent, so ask again for that packet with
                // ancestors.

                Assert (!(msgReqUpdate.ulFlags & DRS_GET_ANC));

                msgReqUpdate.ulFlags |= DRS_GET_ANC;

                goto NEXTPKT;
            }

            if (ret == DRAERR_NotEnoughAttrs) {

                // Ok we failed to apply the update becuase we had a
                // missing object, so ask again for that packet with all
                // properties

                Assert((!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_PACKET)) &&
                       (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_NOW)) &&
                       (!(msgReqUpdate.ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) );

                msgReqUpdate.ulFlags |= DRS_FULL_SYNC_PACKET;

                goto NEXTPKT;
            }

            if (!ret) {

                if ( *pulSyncFailure ) {

                    // Give up at sync failure.
                    break;
                } else {
                    // Request was successful

                    // Report progress of full sync at installation time
                    if (msgReqUpdate.usnvecFrom.usnHighPropUpdate == 0) {
                        draReportSyncProgress(
                            pTHS,
                            pNC,
                            pszSourceServer,
                            msgUpdReplica.fMoreData,
                            &replStats );
                    }

                    // Clear "full sync packet" mode
                    msgReqUpdate.ulFlags &= ~DRS_FULL_SYNC_PACKET;

                    // successfully received and applied these changes
                    // Usnvec and Invocation id must be updated together
                    msgReqUpdate.uuidInvocIdSrc = msgUpdReplica.uuidInvocIdSrc;
                    msgReqUpdate.usnvecFrom = msgUpdReplica.usnvecTo;

                    // We've made some progress. Allow further work to be preempted
                    fIsPreemptable = TRUE;

                    if ((0 == (++cNumPackets % UPDATE_REPSFROM_PACKET_INTERVAL))
                        && msgUpdReplica.fMoreData
                        && !(msgReqUpdate.ulFlags & DRS_CRITICAL_ONLY)
                        && !(msgReqUpdate.ulFlags & DRS_ASYNC_REP)
                        && (!fNewReplica
                            || memcmp(&gusnvecFromScratch,
                                      &msgReqUpdate.usnvecFrom,
                                      sizeof(USN_VECTOR)))) {
                        // Every N packets, update our USN vector & other state
                        // for this source in the database.  This is so that if
                        // we're hard reset (e.g., lose power) we won't have to
                        // restart really long syncs from the beginning.

                        BeginDraTransaction(SYNC_WRITE);
                        __try {
                            ret2 = UpdateRepsFromRef(pTHS,
                                                     DRS_UPDATE_ALL,
                                                     pNC,
                                                     DRS_FIND_DSA_BY_ADDRESS,
                                                     URFR_NEED_NOT_ALREADY_EXIST,
                                                     &uuidDsaObjSrc,
                                                     &msgReqUpdate.uuidInvocIdSrc,
                                                     &msgReqUpdate.usnvecFrom,
                                                     &gNullUuid, // transport objectGuid n/a
                                                     pmtx_addr,
                                                     msgReqUpdate.ulFlags,
                                                     prtSchedule,
                                                     ERROR_DS_DRA_REPL_PENDING,
                                                     NULL);
                        } __finally {
                            EndDraTransaction(!(ret2 || AbnormalTermination()));
                        }
                    }
                }
            }

            // If we got an error, or all the objects, quit loop

            if (ret || !msgUpdReplica.fMoreData) {
                break;
            }

            // If we're init syncing and we have a continuation, and we didn't
            // apply any objects and we haven't abandoned before, give up on
            // this init sync. This will allow us to attempt another init
            // sync from another server that should make more progress.

            if (    ( msgReqUpdate.ulFlags & DRS_INIT_SYNC_NOW )
                 && (MODIFIED_NOTHING == dwNCModified)
                 && msgUpdReplica.fMoreData
                 && ( msgReqUpdate.ulFlags & DRS_ASYNC_OP )
                 && !( msgReqUpdate.ulFlags & DRS_ABAN_SYNC ) )
            {
                *pulSyncFailure = DRAERR_AbandonSync;
                break;
            }

            // Reset the flags in case we set ancestors previously
            msgReqUpdate.ulFlags = ulFlags;

NEXTPKT:
            if (eServiceShutdown) {
                break;
            }

            if (0 != memcmp(&msgReqUpdate,
                            &msgReqUpdateNextPkt,
                            sizeof(msgReqUpdate))) {
                // The request we sent asynchronously is not what we want now.
                // Cancel previous request and post a new one.
                DPRINT(1, "Throwing away pre-fetched next packet and re-requesting.\n");
                gcNumPreFetchesDiscarded++;
                gcNumPreFetchesTotal++;
                DPRINT3(1, "Pre-fetch efficiency: %d of %d (%d%%).\n",
                        gcNumPreFetchesTotal - gcNumPreFetchesDiscarded,
                        gcNumPreFetchesTotal,
                        100 * (gcNumPreFetchesTotal - gcNumPreFetchesDiscarded)
                            / gcNumPreFetchesTotal);

                DRSDestroyAsyncRpcState(pTHS, &AsyncState);
                retNextPkt = I_DRSGetNCChanges(pTHS,
                                               pszSourceServer,
                                               pszSourceDsaDnsDomainName,
                                               pNC,
                                               &msgReqUpdate,
                                               &msgUpdReplica,
                                               schemaInfo,
                                               &AsyncState,
                                               pfBindSuccess );
            }

            ret = retNextPkt;
            if (!ret && !eServiceShutdown) {
                PERFINC(pcDRASyncRequestMade);
                ret = I_DRSGetNCChangesComplete(pTHS, pNC, &AsyncState, pfBindSuccess);
            }
        } while (!eServiceShutdown && !ret);

        // Is the service trying to shutdown? if so, return failure.
        if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
        }

        // We're assuming that DRS_ASYNC_REP is only set on a new
        // replica, not sync, so check for this.
        if ((!fNewReplica) && (msgReqUpdate.ulFlags & DRS_ASYNC_REP)) {
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }

LABORT:;

#if DBG
        DPRINT1(3, "Received %d objects\n", iobjs);
#endif
        // Update Reps-From with result of this sync attempt.
        // If this is a new async replica, we set usn so that
        // we completely sync the replica next sync.
        // Ditto for a "critical only" replica
        //
        // NOTE: We now update Reps-From at the end of most ReplicateNC()
        // calls in order to properly set the (new) last-try-result,
        // last-try-time, and last-success-time fields.

        ulResult = ret ? ret : *pulSyncFailure;

        // Save bookmarks unless we totally failed to add a new replica (i.e.,
        // unless we tried to add a new replica but couldn't complete the first
        // packet).
        //
        // This is a little confiusing, since we might be returning "failure"
        // on an add replica operation even though we did really add a RepsFrom.

        if ((DRAERR_Success == ulResult)
            || !fNewReplica
            || memcmp(&gusnvecFromScratch, &msgReqUpdate.usnvecFrom,
                      sizeof(USN_VECTOR))) {
            BeginDraTransaction (SYNC_WRITE);
            __try {
                USN_VECTOR *pusnvec;
                ULONG ulNewFlags;

                if ( (fNewReplica && (msgReqUpdate.ulFlags & DRS_ASYNC_REP)) ||
                     (msgReqUpdate.ulFlags & DRS_CRITICAL_ONLY) ) {
                    pusnvec = &gusnvecFromScratch;
                } else {
                    pusnvec = &msgReqUpdate.usnvecFrom;
                }
                
                // The PREEMPTED flag on the repsFrom is important because it helps
                // ensure that one replication partner is favored when doing full syncs.
                // We want to ensure that the PREEMPTED flag is written to the repsFrom
                // whenever this function returns DRAERR_Preempted. Conversely, if
                // any other error code is returned, we should clear the PREEMPTED flag.
                // One exception: if DRAERR_Shutdown is returned, we leave the PREEMPTED
                // flag as is so that the same partner will be favored after a reboot.
                ulNewFlags = msgReqUpdate.ulFlags;
                switch( ulResult ) {
                    case DRAERR_Preempted:
                        ulNewFlags |= DRS_PREEMPTED;
                        break;
                    case DRAERR_Shutdown:
                        break;
                    default:
                        ulNewFlags &= ~DRS_PREEMPTED;
                        break;
                }

                ret2 = UpdateRepsFromRef( pTHS,
                                          DRS_UPDATE_ALL,     // Modify whole repsfrom
                                          pNC,
                                          DRS_FIND_DSA_BY_ADDRESS,
                                          URFR_NEED_NOT_ALREADY_EXIST,
                                          &uuidDsaObjSrc,
                                          &msgReqUpdate.uuidInvocIdSrc,
                                          pusnvec,
                                          &gNullUuid, // transport objectGuid n/a
                                          pmtx_addr,
                                          ulNewFlags,
                                          prtSchedule,
                                          ulResult,
                                          NULL);
            } __finally {
                EndDraTransaction (!(ret2 || AbnormalTermination()));
            }
        }

        if (!ret) {

            // Return invocation id if new replica and caller wants it.
            Assert( NULL != puuidDsaObjSrc );

            if ( fNewReplica ) {
                *puuidDsaObjSrc = msgUpdReplica.uuidDsaObjSrc;
            }
        }

        // if this is a schema NC sync, and we are successful so far,
        // write the schemaInfo on the schema container if the other
        // side sent it. Don't write during install, when it will be
        // writen normally during schema container replication

        if (DsaIsRunning() && NameMatched(gAnchor.pDMD,pNC) ) {

             fSchInfoChanged = FALSE;
             if (!ret && !(*pulSyncFailure)) {
                 // Update the schema-info value only if the replication
                 // is successful
                 if ( err = WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged) ) {
                     // failed to write Schema Info. May not be harmful
                     // depending on schema change history. Always
                     // log a warning so that admin can manually resync
                     // again to force writing it if the version is indeed
                     // different

                     LogEvent(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_DRA_SCHEMA_INFO_WRITE_FAILED,
                              szInsertUL(err), szInsertDbErrMsg(err), NULL);
                 }
             }

            // if any "real" schema changes happened, up the global
            // to keep track of schema changes since boot, so that
            // later schema replications can check if thy have an updated
            // schema cache. Do this even if the whole NC replication
            // failed, since this indicates at least one object has
            // been changed.

            if (MODIFIED_NCTREE_INTERIOR == dwNCModified) {
                IncrementSchChangeCount(pTHS);
            }

            // signal a schema cache update either if any real schema change
            // occurred or if the schemaInfo value is changed

            if ( (MODIFIED_NCTREE_INTERIOR == dwNCModified) || fSchInfoChanged ) {
                if (!SCSignalSchemaUpdateImmediate()) {
                     // couldn't even signal a schema update
                     DRA_EXCEPT (DRAERR_InternalError, 0);
                }
            }
        }

    } __finally {
        // Destroy oustanding async RPC state, if any.
        DRSDestroyAsyncRpcState(pTHS, &AsyncState);

        // No more remaining entries.
        ISET (pcRemRepUpd, 0);
        ISET (pcDRARemReplUpdLnk, 0);
        ISET (pcDRARemReplUpdTot, 0);

        // Clear RPC call details
        EnterCriticalSection(&csLastReplicaMTX);
        pLastReplicaMTX = NULL;
        LeaveCriticalSection(&csLastReplicaMTX);

        TH_free_to_mark(pTHS);

        if (NULL != msgReqUpdate.pUpToDateVecDest) {
            // free allocated up-to-date vector
            THFreeEx(pTHS, msgReqUpdate.pUpToDateVecDest);
        }

        // Entered with transaction, so exit with transaction.
        BeginDraTransaction(SYNC_WRITE);
    }

    return ret;
}


DWORD
updateNCValuesNotify(
    IN THSTATE *pTHS,
    IN REPLVALINF *pReplValInf,
    ULONG cModAtts,
    ATTRTYP *pModAtts
    )

/*++

Routine Description:

    Perform notifications if a linked value is changed on an object

    This is called when a batch of values on the same object is being finished.

    CODE.IMPROVEMENT
    This routine performs notification functions similar to those done at the end
    of LocalModify(). Perhaps inbound replication of link values should call LocalModify
    instead of calling the dblayer directly (see modifyLocalValue). Then this
    modification notification logic would not be needed. Oh well.


Arguments:

    pTHS - thread state
    pReplValInf - last value in batch being applied
    cModAtts - Count of linked attributes modified
    pModAtts - Array of linked attributes modified

Return Value:

    DWORD - 

--*/

{
    DWORD ret;
    ULONG cb;
    DSNAME *pDN = NULL;
    RESOBJ *pResObj = NULL;
    CLASSCACHE *pClassSch;
    ULONG iClass;

    // Prepare a notification for SAM if necessary
    if (!DsaIsRunning()) {
        return 0;
    }

    // Obj Dist Name should always be present
    if ( ret = DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                           0, 0, &cb, (UCHAR **) &pDN) )
    {
        DRA_EXCEPT(DRAERR_InternalError, ret);
    }

    // Positioned correctly?
    Assert(0 == memcmp(&pDN->Guid, &pReplValInf->pObject->Guid, sizeof(GUID)));

    // In order to determine if SAM needs notifying we need to know
    // if this is a SAM owned object.  Obtain the most specific
    // object class as SampSamClassReferenced() will inspect the 
    // inheritance chain to see if the object is either a SAM object
    // or inherited from one.

    pResObj = CreateResObj( pTHS->pDB, pDN );
    Assert( pResObj );     // Always succeeds or excepts
    Assert( pResObj->MostSpecificObjClass );

    // Object class should always be present
    if (!(pClassSch = SCGetClassById(pTHS,pResObj->MostSpecificObjClass))) {
        DRA_EXCEPT (DRAERR_DBError, ERROR_DS_OBJECT_CLASS_REQUIRED);
    }

    // Perform modify related notifications
    if (ModObjCaching(pTHS, 
                      pClassSch,
                      cModAtts,
                      pModAtts,
                      pResObj)) {
        ret = RepErrorFromPTHS(pTHS);
        Assert( !ret && "not expecting this to fail" );
    }
    
    // Finally, determine if this is a SAM object and if so
    // prepare a notification to go on the thread state. This
    // notification will be proceed on transaction commit (with
    // an appropriate parameter indicating whether the transaction 
    // committed or failed).
    if ( (0 == ret) && (SampSamClassReferenced(pClassSch, &iClass)) ) {
  
        ret = SampAddNetlogonAndLsaNotification(
            pDN,                    // object that is changing
            iClass,                 // SAM class
            0,                      // LSA class, not used
            SecurityDbChange,       // a change to the database
            FALSE,                  // native mode change?
            FALSE,                  // role transfer?
            DomainServerRoleBackup, // not used for this notify
            FALSE                   // user account control change
            );
        Assert( !ret && "not expecting this to fail" );

    }

    if (pDN) {
        THFreeEx( pTHS, pDN );
    }

    if (pResObj) {
        THFreeEx( pTHS, pResObj );
    }

    return ret;
} /* updateNCValuesNotify */


DWORD
UpdateNCValuesHelp(
    IN  THSTATE *pTHS,
    IN  ULONG dntNC,
    IN  SCHEMA_PREFIX_MAP_HANDLE hPrefixMap,
    IN  DWORD cNumValues,
    IN  REPLVALINF *rgValues,
    IN  LPWSTR pszServerName,
    IN  ULONG RepFlags,
    IN  BOOL fIsPreemptable,
    OUT ULONG *pulSyncFailure,
    OUT DWORD *pdwValueCreationCount,
    OUT DWORD *pdwNCModified
    )

/*++

Routine Description:

Apply an array of value updates.

This routine is currently designed to be run from inside UpdateNC.
1. Schema checks have been made
2. Prefix map is open
3. Schema critical section is held if necessary
4. A DRA Transaction has already been started

Periodic transaction commitment: We commit every n values, same object or not.
We don't explicitly commit the last n since that will be done when the trans
ends.  Committing causes a loss of currency.

Object currency optimization: If we are not committing, and the next object is
the same as the current object, we note that we are current.

Object notification:  We notify everytime we lose currency and we haven't
encountered any errors. Thus we notify every time we switch objects, and
when we commit. Notifying every commit is a feature since this way we don't have
to keep track when we hit an error whether there were previously committed
changes that need to be notified.

Arguments:

pTHS -
hPrefixMap - Schema cache prefix map, to convert attrtyp's
cNumValues - Number of values to apply
rgValues - Array of values
pszServerName - Name of source server
RepFlags - Replication flags
pulSyncFailure - Set for warnings, preempted and schema mismatch
pdwNCModified - Whether nc was modified

Return Value:

DWORD -

--*/

{
    DWORD count, ret = 0;
    REPLVALINF *pReplValInf;
    BOOL fObjectCurrency = FALSE;
    DWORD cCommits = 0, cNotifies = 0;
    LONG cAppliedThisTrans = 0; // signed quantity
    DWORD cTickStart, cTickDiff;
    DWORD dwUpdateValueStatus;
    ULONG cModAtts = 0;
    ATTRTYP *pModAtts = NULL;

    // We better be in LVR mode
    if (!(pTHS->fLinkedValueReplication)) {
        Assert( !"Can't apply value metadata when not in proper mode!" );
        DRA_EXCEPT(DRAERR_InternalError, ERROR_REVISION_MISMATCH);
    }


    cTickStart = GetTickCount();

    // Values are already sorted, count is 1-based
    for( count = 1, pReplValInf = rgValues;
         count <= cNumValues;
         count++, pReplValInf++ ) {

        __try {
            ret = DRAERR_Generic;
            __try {
                // Convert attr type to local
                if (!PrefixMapTypes( hPrefixMap, 1, &(pReplValInf->attrTyp) )) {
                    DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
                }

                // Apply a single value change
                ret = UpdateRepValue(
                    pTHS,
                    dntNC,
                    RepFlags,
                    fObjectCurrency,  // Are we already on the object?
                    pReplValInf,
                    &dwUpdateValueStatus
                    );
            } __except (GetDraException((GetExceptionInformation()), &ret)) {
                ;
            }  

            Assert( ret != DRAERR_Preempted );

            // If we are shutting down, abandon this update.
            if (eServiceShutdown) {
                ret = DRAERR_Shutdown;
            }

            // If we have waiting priority threads, stop here
            if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
                ret = DRAERR_Preempted;
            }

            // There are three interesting things going on here: periodic transaction
            // commitment, object notification, and object currency optimization.

            if ( (!ret) || (ret == DRAERR_Preempted) )
            {
                cAppliedThisTrans++;
                if (dwUpdateValueStatus == UPDATE_VALUE_CREATION) {
                    (*pdwValueCreationCount)++;
                }

                // Keep an array of attrtyps applied this batch
                // Incoming attrtypes are sorted
                if ( (0 == cModAtts) ||
                     (pModAtts[cModAtts-1] != pReplValInf->attrTyp) ) {
                    cModAtts++;
                    if (pModAtts) {
                        pModAtts = THReAllocEx( pTHS, pModAtts, cModAtts * sizeof(ATTRTYP) );
                    } else {
                        pModAtts = THAllocEx( pTHS, cModAtts * sizeof(ATTRTYP) );
                    }
                    pModAtts[cModAtts-1] = pReplValInf->attrTyp;
                }

                // See if we need to close off the current batch
                if ( ( ( count % VALUES_APPLIED_PER_TRANS ) == 0) ||
                     (count == cNumValues) ||
                     (ret == DRAERR_Preempted) ||
                     (memcmp( &(pReplValInf->pObject->Guid),
                              &((pReplValInf+1)->pObject->Guid),
                              sizeof( GUID ) ) != 0) )
                {
                    ULONG ret2; // don't clobber ret

                    // Indicate that a linked value was updated
                    ret2 = DBRepl( pTHS->pDB, TRUE, 0, NULL, META_STANDARD_PROCESSING );
                    if (0 == ret2) {
                        cNotifies++;  
                        // TODO: detect nc head only modification
                        // at least one interior node modified
                        *pdwNCModified = MODIFIED_NCTREE_INTERIOR;

                        ret2 = updateNCValuesNotify( pTHS, pReplValInf, cModAtts, pModAtts );
                    }

                    __try {
                        DBTransOut (pTHS->pDB, !ret2, TRUE);
                    } __except(GetDraBusyException(GetExceptionInformation(), &ret2)) {
                        Assert(DRAERR_Busy == ret2);
                    }

                    if (!ret2) {  
                        // Note that the link counters are decremented by the chunks that
                        // are applied in one transaction. Thus they will tend to decrease
                        // in a stairstep rather than a smooth slope.
                        IADJUST(pcDRARemReplUpdLnk, (-cAppliedThisTrans));
                        IADJUST(pcDRARemReplUpdTot, (-cAppliedThisTrans));
                    }

                    DBTransIn (pTHS->pDB);

                    cAppliedThisTrans = 0;
                    cCommits++;

                    if (ret2) {
                        ret = ret2;  // only clobber ret if update failed
                    }

                    if (cModAtts) {
                        THFreeEx( pTHS, pModAtts );
                        pModAtts = NULL;
                    }
                    cModAtts = 0;

                    // Currency lost after DBTransOut
                    fObjectCurrency = FALSE;

                } else {
                    // Still positioned on same object
                    fObjectCurrency = TRUE;
                }

            } else {
                // Abort the last batch if one was in progress
                if (pTHS->pDB->JetRetrieveBits) {
                    DBCancelRec(pTHS->pDB);
                }
            }
        }
        __finally {

            // note that DBGetHighestCommittedUSN isn't perfect here.  There is a window between the DBTransOut
            // and this call which other transactions can commit.  This makes the USN value we write to the log
            // a "best guess" value which could be higher than the actual value used to write the update.  This value
            // isn't critical to the logging - it is more of a guideline to the overall USN change from replication
            // begin to replication end.  Also note that no two .._UpdateRep* will have the same usn logged.

            DRA_AUDITLOG_UPDATEREPVALUE(pTHS,
                                        gulSyncSessionID,
                                        pReplValInf,
                                        DBGetHighestCommittedUSN(),
                                        dwUpdateValueStatus,
                                        ret);
        }
        // Finish loop on error or preempted
        if (ret) {
            break; // exit for loop
        }
    } // end for



    // This switch statement is intended to mirror the error handling
    // in UpdateNC().
    if (ret) {
        switch (ret) {
        case DRAERR_Shutdown:
        case DRAERR_MissingParent:
            // Don't log for these errors
            break;
        case DRAERR_Busy:
            LogUpdateFailure (pTHS,
                              pszServerName,
                              GetExtDSName( pTHS->pDB ) );
            pTHS->errCode = 0;
            // fall through
        case DRAERR_Preempted:
        case DRAERR_SchemaMismatch:
            *pulSyncFailure = ret;
            ret = 0;
            break;
        default:
            LogUpdateValueFailureNB (pTHS,
                                     pszServerName,
                                     GetExtDSName( pTHS->pDB ),
                                     pReplValInf,
                                     ret);
        }
    }

    cTickDiff = GetTickCount() - cTickStart;

    DPRINT3( 1, "cNumValues = %d, cCommits = %d, cNotifies = %d\n",
             cNumValues, cCommits, cNotifies );
    DPRINT2( 1, "apply time = %d:%d\n",
             ((cTickDiff/1000) / 60),
             ((cTickDiff/1000) % 60) );


    // Make sure that we don't have an update open if we are going to commit...
    Assert( ret || (pTHS->pDB->JetRetrieveBits == 0) );

    if (cModAtts) {
        THFreeEx( pTHS, pModAtts );
        pModAtts = NULL;
    }
    cModAtts = 0;

    return ret;
} /* UpdateNCValuesHelp */

// Note:- When UpdateNC() returns successfully, contents of pdwNCModified tells if
//          the NC has been modified or not.
//          MODIFIED_NOTHING, if nothing in the NC has been modified;
//          MODIFIED_NCHEAD_ONLY, if nc head is the only object that has been modified;
//          MODIFIED_NCTREE_INTERIOR, if at least one object in the NC other than the NC head has been modified;
//
ULONG
UpdateNC(
    IN  THSTATE *                       pTHS,
    IN  DSNAME *                        pNC,
    IN  DRS_MSG_GETCHGREPLY_NATIVE *    pmsgReply,
    IN  LPWSTR                          pszServerName,
    OUT ULONG *                         pulSyncFailure,
    IN  ULONG                           RepFlags,
    OUT DWORD *                         pdwNCModified,
    OUT DWORD *                         pdwObjectCreationCount,
    OUT DWORD *                         pdwValueCreationCount,
    IN  BYTE  *                         pSchemaInfo,
    IN  ULONG                           UpdNCFlags
    )
{
#define MAX_WRITE_CONFLICT_RETRIES (5)

    REPLENTINFLIST *        pentinflist;
    BOOL                    fMoveToLostAndFound = FALSE;
    ULONG                   UpdateStatus = UPDATE_NOT_UPDATED;
    ULONG                   ret = 0;
    SCHEMA_PREFIX_TABLE *     pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap = NULL;
    GUID                    objGuidLostAndFound = {0};
    REPLENTINFLIST *        pentinflistLookAhead = NULL;
    BOOL                    fSDPLocked = FALSE, fSchemaConflict = FALSE;
    BOOL                    fSchemaSync = FALSE;
    BOOL                    fTransStarted = FALSE;
    PROPERTY_META_DATA_VECTOR * pMetaDataVec = NULL;
    DWORD                       cNumMDVEntriesAlloced = 0;
    BOOL                    fMatch = FALSE;
    ULONG                   dntNC = INVALIDDNT;
    DWORD                   cTickStart, cTickStartRaisePriority;
    DWORD                   cTickDiff;
    DWORD                   NewSchemaIsBetter;
    int                     nOrigThreadPriority;
    BOOL                    fResetThreadPriority = FALSE;
    DWORD                   cNumWriteConflictRetries = 0;
    BOOL                    fRetry = FALSE;
    ULONG                   retTransOut = 0;
    REPLENTINFLIST *        pResults = pmsgReply->pObjects;
    SCHEMA_PREFIX_TABLE *   pRemotePrefixTable = &pmsgReply->PrefixTableSrc;
    USN_VECTOR *            pusnvecSyncPoint = &pmsgReply->usnvecFrom;
    BOOL                    fBypassUpdatesEnabledCheck = FALSE;
    DRS_EXTENSIONS *        pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;
    REPLENTINFLIST *        pentinflistWriteConflict = NULL;
    SYNTAX_INTEGER          it;
    BOOL                    fIsPreemptable = !!(UpdNCFlags & UPDNC_IS_PREEMTABLE);
    BOOL                    fExistingNC = !!(UpdNCFlags & UPDNC_EXISTING_NC);

    // assume no modification
    *pdwNCModified = MODIFIED_NOTHING;

    if (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
        != REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)) {
        // The replication epoch has changed (usually as the result of a domain
        // rename).  We are not supposed to communicate with DCs of other
        // epochs.
        DSNAME *pdnRemoteDsa = draGetServerDsNameFromGuid(pTHS,
                                                          Idx_ObjectGuid,
                                                          &pmsgReply->uuidDsaObjSrc);

        DPRINT3(0, "GetChanges request from %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                pdnRemoteDsa->StringName,
                REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote),
                REPL_EPOCH_FROM_DRS_EXT(pextLocal));

        LogEvent(DS_EVENT_CAT_RPC_SERVER,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                 szInsertDN(pdnRemoteDsa),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pTHS->pextRemote)),
                 szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));

        THFreeEx(pTHS, pdnRemoteDsa);

        return ERROR_DS_DIFFERENT_REPL_EPOCHS;
    }

    // In the normal running case, check if the schema versions match.
    // If not, fail the call now before doing anything more for
    // domain and config NC

    if (DsaIsRunning()) {
        if ( !NameMatched(gAnchor.pDMD, pNC) ) {
            // Not schema NC. Check schema-info for mismatch
            SCReplReloadCache(pTHS, gInboundCacheTimeoutInMs);

            fMatch = CompareSchemaInfo(pTHS, pSchemaInfo, &NewSchemaIsBetter);
            if (!fMatch) {
                // Set schema mismatch code so that a schema NC
                // sync will be requeued if it is not a new
                // replica add
                LogEvent(
                    DS_EVENT_CAT_REPLICATION,
                    DS_EVENT_SEV_MINIMAL,
                    DIRLOG_DRA_SCHEMA_INFO_MISMATCH,
                    szInsertDN(pNC),
                    szInsertWC(pszServerName),
                    0 );
                if (NewSchemaIsBetter) {
                    // sync the schemaNC and retry syncing the triggering NC
                    *pulSyncFailure = DRAERR_SchemaMismatch;
                    return 0;
                } else {
                    // Don't attempt schemaNC sync
                    return DRAERR_SchemaMismatch;
                }
            }
        }
    }


    // Incorporate any new remote prefixes into our own prefix table.
    if (!PrefixTableAddPrefixes(pRemotePrefixTable)) {
        return DRAERR_SchemaMismatch;
    }

    // Open prefix mapping handle to map remote ATTRTYPs to local ATTRTYPs.
    pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
    hPrefixMap = PrefixMapOpenHandle(pRemotePrefixTable, pLocalPrefixTable);

    // Lock the SDP as a reader before entering transaction (bug # 170459) if needed
    pentinflistLookAhead = pResults;
    if ( pentinflistLookAhead && pentinflistLookAhead->pParentGuid)
    {
        // replicated-addition or a rename
        cTickStart = GetTickCount();
        if (!SDP_EnterAddAsReader())
        {
            // Only possible reason for failure here is shutdown
            Assert(eServiceShutdown);

            PrefixMapCloseHandle(&hPrefixMap);

            return DRAERR_Shutdown;
        }

        fSDPLocked = TRUE;

        cTickDiff = GetTickCount() - cTickStart;
        if (cTickDiff > gcMaxTicksToGetSDPLock) {
            Assert(!"Replication was blocked for an inordinate amount of time waiting for the SDP lock!");
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_SDP_LOCK_CONTENTION,
                     szInsertUL((cTickDiff/1000) / 60),
                     szInsertUL((cTickDiff/1000) % 60),
                     NULL);
        }
    }

    // if this is a schema NC sync, serialize this with any originating schema
    // change or schema cache load in progress. We use the global no. of schema
    // changes since boot to ascertain if we have a uptodate schema cache or
    // not, since we will be validating against this cache

    if (DsaIsRunning() && NameMatched(gAnchor.pDMD, pNC) ) {
        // Before we acquire the lock, make sure the cache is up-to-date
        SCReplReloadCache(pTHS, gInboundCacheTimeoutInMs);
        SCHEMASTATS_INC(SchemaRepl);
        EnterCriticalSection(&csNoOfSchChangeUpdate);
        fSchemaSync = TRUE;
    }

    __try {
        // Allocate buffer for meta data vector.
        cNumMDVEntriesAlloced = 50;
        pMetaDataVec = THAllocEx(pTHS, MetaDataVecV1SizeFromLen(cNumMDVEntriesAlloced));

        // If updates are disabled, it's okay to generate writes iff we're
        // demoting this DC and this is us completing a FSMO transfer we
        // initiated as part of the demotion.
        fBypassUpdatesEnabledCheck = draIsCompletionOfDemoteFsmoTransfer(NULL);

        BeginDraTransactionEx(SYNC_WRITE, fBypassUpdatesEnabledCheck);
        fTransStarted = TRUE; 

        // Force all updates to ignore values with metadata
        // This is how we guarantee that old updates are applied with old
        // semantics, even when operating in the new value mode.
        pTHS->pDB->fScopeLegacyLinks = TRUE;

        if ( fSchemaSync &&
                  (((SCHEMAPTR *) pTHS->CurrSchemaPtr)->lastChangeCached < gNoOfSchChangeSinceBoot) ) {

             // The schema cache has gone stale or couldn't be reloaded.
             // Kick off a cache reload and tell our caller to reschedule
             // the resync (ret = 0 and *pulSyncFailure = SchemaMismatch).
             SCHEMASTATS_INC(StaleRepl);
             ret = 0;
             *pulSyncFailure = DRAERR_SchemaMismatch;
             if (!SCSignalSchemaUpdateImmediate()) {
                // couldn't even signal a schema update
                DRA_EXCEPT (DRAERR_InternalError, 0);
             }
             __leave;
        }

        for (pentinflist = pResults;
             pentinflist != NULL;
             pentinflist = fRetry ? pentinflist : pentinflist->pNextEntInf) {

            // fMoveToLostAndFound implies fRetry.
            Assert(!(fMoveToLostAndFound && !fRetry));
 
        __try { 
        ret = DRAERR_Generic;
        __try {
	    
	    
	    // If we haven't yet determined the DNT of the NC head, try to
	    // do so now.
	    
	    // NOTE:  There are cases, like the first replication of a new
	    // NC when we don't have an NC head yet, that this will fail.  However
	    // there are also cases when we don't want to find anything but
	    // a fully instantiated, stable (not going or coming) nc head 
	    // (like FSMO transfer), hence the fExistingNC flag.  Also, there
	    // are NO cases when we want the NC going if we're trying to update
	    // it.
	    if (INVALIDDNT == dntNC) {  
		DWORD retFindNC = ERROR_SUCCESS;
		it = 0;
		retFindNC = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it);
		if (retFindNC==ERROR_SUCCESS) {
		    dntNC = pTHS->pDB->DNT;		  
		}
		if (((retFindNC!=ERROR_SUCCESS) && fExistingNC) || ((it & IT_NC_GOING) || (fExistingNC && (it & IT_NC_COMING)))) {
		    DRA_EXCEPT(DRAERR_BadNC, retFindNC);
		}  
	    } 
	    
	    if (!fRetry) {
            // This is our first time to visit this particular REPLENTINF.
            // Convert its embedded remote ATTRTYPs to the corresponding
            // local values.
            PROPERTY_META_DATA_EXT_VECTOR * pMetaDataVecExt;
            PROPERTY_META_DATA_EXT *        pMetaDataExt;
            PROPERTY_META_DATA *            pMetaData;
            ATTR *                          pAttr;
            ENTINF *                        pent;
            DWORD                           i;

            pMetaDataVecExt = pentinflist->pMetaDataExt;
            pent = &pentinflist->Entinf;

            if (!PrefixMapAttrBlock(hPrefixMap, &pent->AttrBlock)) {
                DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
            }

            // Convert remote meta data vector from wire format.
            if (cNumMDVEntriesAlloced < pMetaDataVecExt->cNumProps) {
                DWORD cb = MetaDataVecV1SizeFromLen(pMetaDataVecExt->cNumProps);
                pMetaDataVec = THReAllocEx(pTHS, pMetaDataVec, cb);
                cNumMDVEntriesAlloced = pMetaDataVecExt->cNumProps;
            }

            pMetaDataVec->dwVersion = VERSION_V1;
            pMetaDataVec->V1.cNumProps = pMetaDataVecExt->cNumProps;

            pMetaData = &pMetaDataVec->V1.rgMetaData[0];
            pMetaDataExt = &pMetaDataVecExt->rgMetaData[0];
            pAttr = &pent->AttrBlock.pAttr[0];
            for (i = 0;
                 i < pMetaDataVecExt->cNumProps;
                 i++, pMetaData++, pMetaDataExt++, pAttr++) {
                pMetaData->attrType           = pAttr->attrTyp;
                pMetaData->dwVersion          = pMetaDataExt->dwVersion;
                pMetaData->timeChanged        = pMetaDataExt->timeChanged;
                pMetaData->uuidDsaOriginating = pMetaDataExt->uuidDsaOriginating;
                pMetaData->usnOriginating     = pMetaDataExt->usnOriginating;
            }

            // Remote-to-local ATTRTYP conversion may have munged our
            // sort order; re-sort.
            Assert(0 == offsetof(PROPERTY_META_DATA, attrType));
            Assert(0 == offsetof(ATTR, attrTyp));
            qsort(pent->AttrBlock.pAttr,
                  pent->AttrBlock.attrCount,
                  sizeof(pent->AttrBlock.pAttr[0]),
                  &CompareAttrtyp);
            qsort(pMetaDataVec->V1.rgMetaData,
                  pMetaDataVec->V1.cNumProps,
                  sizeof(pMetaDataVec->V1.rgMetaData[0]),
                  &CompareAttrtyp);

            // First attempt to commit this update.
            cNumWriteConflictRetries = 0;
            }
            else if (fMoveToLostAndFound) {
            // if it is a move to LostAndFound, set the
            // peninflist->pParentGuid to LostAndFound container's
            // object guid.
            if (fNullUuid(&objGuidLostAndFound)) {
                draGetLostAndFoundGuid(pTHS, pNC, &objGuidLostAndFound);
                Assert(!fNullUuid(&objGuidLostAndFound));
            }

            pentinflist->pParentGuid = &objGuidLostAndFound;
            }

            // Apply any necessary updates.
            ret = UpdateRepObj(pTHS,
                       dntNC,
                       &pentinflist->Entinf,
                       pMetaDataVec,
                       &UpdateStatus,
                       RepFlags,
                       pentinflist->fIsNCPrefix,
                       pentinflist->pParentGuid,
                       fMoveToLostAndFound);

            Assert(HasValidInstanceType(pentinflist->Entinf.pName));

            // If we are shutting down, abandon this update.
            if (eServiceShutdown) {
            ret = DRAERR_Shutdown;
            }
        } __except (GetDraException((GetExceptionInformation()), &ret)) {
              ;
        }

        // One less entry to update.

        // reset MoveToLostAndFound after each iteration so that it
        // will be done only if set explicitly in the switch statement below
        fMoveToLostAndFound = FALSE;
        fRetry = FALSE;

        // Commit or abort the transaction.  Catch only "busy" exceptions;
        // allow all other exceptions to be caught by the outside exception
        // handler.
        //
        // Note that we differentiate between "busy" errors during
        // transaction commit and "busy" errors during the UpdateRepObj()
        // call.  We want to retry only in the specific case where the
        // escrowed update fails.
        __try {  
            DBTransOut (pTHS->pDB, !ret, TRUE);
            retTransOut = 0;
        } __except(GetDraBusyException(GetExceptionInformation(), &retTransOut)) {
              Assert(DRAERR_Busy == retTransOut);
        }

        ret = ret ? ret : retTransOut;
        }
        __finally { 

        // note that DBGetHighestCommittedUSN isn't perfect here.  There is a window between the DBTransOut
        // and this call which other transactions can commit.  This makes the USN value we write to the log
        // a "best guess" value which could be higher than the actual value used to write the update.  This value
        // isn't critical to the logging - it is more of a guideline to the overall USN change from replication
        // begin to replication end.  Also note that no two .._UpdateRep* will have the same usn logged.

        DRA_AUDITLOG_UPDATEREPOBJ(pTHS, 
                      gulSyncSessionID, 
                      pentinflist->Entinf.pName,
                      pentinflist->Entinf.AttrBlock,      
                      DBGetHighestCommittedUSN(),
                      UpdateStatus,
                      ret);
        }

            // Just came out of the outer transaction - unlock SDP if needed
            if (fSDPLocked)
            {
                SDP_LeaveAddAsReader();
                fSDPLocked = FALSE;
            }

            if (!ret && !pmsgReply->ulExtendedRet) {
                // Replication operation (as opposed to FSMO op) successfully
                // applied update -- dec the number of outstanding updates.
                PERFDEC(pcRemRepUpd); 
        PERFDEC(pcDRARemReplUpdTot); 
            }

            // About to enter a outer transaction again
            // Lock SDP if the next change to be processed is an addition or rename
            pentinflistLookAhead = pentinflist->pNextEntInf;
            if ((DRAERR_MissingParent == ret) ||
                ((DRAERR_Busy == retTransOut) && pentinflist->pParentGuid) ||
                (pentinflistLookAhead && pentinflistLookAhead->pParentGuid))
            {
                // if UpdateRepObj() returned Missing Parent, we are likely to process
                // the same object again and move it into lostandfound . In this case
                // LockSDP before opening the transaction anyways.
                // Same goes for "busy" on transaction commit of an op that had
                // the lock -- we are likely going to try it again.
                // Otherwise, LockSDP only if the next entry to be processed is an addition or move.
                cTickStart = GetTickCount();
                if (!SDP_EnterAddAsReader())
                {
                    // Only possible reason for failure here is shutdown
                    Assert(eServiceShutdown);
                    ret = DRAERR_Shutdown;
                    __leave;
                }

                fSDPLocked = TRUE;

                cTickDiff = GetTickCount() - cTickStart;
                if (cTickDiff > gcMaxTicksToGetSDPLock) {
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_MINIMAL,
                             DIRLOG_DRA_SDP_LOCK_CONTENTION,
                             szInsertUL((cTickDiff/1000) / 60),
                             szInsertUL((cTickDiff/1000) % 60),
                             NULL);
                }
            }

            DBTransIn (pTHS->pDB);

            // If a higher priority operation is pending, stop here.
            if (fIsPreemptable && IsHigherPriorityDraOpWaiting()) {
                ret = DRAERR_Preempted;
            }

            if (ret) {

                // Update failed. Try to figure out the cause of failure.

                switch (ret) {

                case DRAERR_Shutdown:
                    // System is shutting down, not an error, don't log
                    break;

        case DRAERR_NotEnoughAttrs:
            // Object isn't a lingering object, but we need to request
            // the object again with full attributes.  

            LogEvent8(
            DS_EVENT_CAT_REPLICATION,
            DS_EVENT_SEV_MINIMAL,
            DIRLOG_DRA_NOT_ENOUGH_ATTRS,
            szInsertDN( pentinflist->Entinf.pName ),
            szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
            szInsertDN( pNC ),
            szInsertWC( pszServerName ),
            szInsertUSN(pusnvecSyncPoint->usnHighPropUpdate),
            NULL,
            NULL, NULL
            );
  
            break;

                case DRAERR_MissingObject:
                     // An update came in, to an object which does not exist.
                     // Log a specific error

            LogEvent8(
            DS_EVENT_CAT_REPLICATION,
            DS_EVENT_SEV_ALWAYS,
            DIRLOG_DRA_MISSING_OBJECT,
            szInsertDN( pentinflist->Entinf.pName ),
            szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
            szInsertDN( pNC ),
            szInsertWC( pszServerName ),
            szInsertUSN(pusnvecSyncPoint->usnHighPropUpdate),
            szInsertSz(DRA_STRICT_REPLICATION_CONSISTENCY), 
            NULL, NULL
            );

            // now we want to re-request the object with full attributes
            // exactly like DRAERR_NotEnoughAttrs.
            // so set to the same value to guarentee the same functionality.
            ret = DRAERR_NotEnoughAttrs;

                    break;

                case DRAERR_MissingParent:

                    // The parent of the object we tried to add is missing.
                    // We need to determine if this is because we haven't yet
                    // received the parent (in which case we return the error
                    // and the caller will request the ancestors and retry).

                    if (RepFlags & DRS_GET_ANC) {
                        // We already asked for the parent, so the parent object
                        // must also be deleted on the source DSA.  This can
                        // occur in scenarios where an object is deleted on one
                        // replica and a child is added to that object on
                        // another replica within a replication latency.

                        // Move the object to the LostAndFound.  For writeable
                        // replicas, this move will replicate back out to other
                        // DSAs; for read-only replicas, it will not be applied
                        // elsewhere (unless replicating to another GC that has
                        // no better information re the "true" name of this
                        // object than we do).
                        fMoveToLostAndFound = TRUE;
                        fRetry = TRUE;
                        ret = 0;
                        continue;
                    }

                    break;

                case DRAERR_SchemaConflict:
                case DRAERR_EarlierSchemaConflict:
                     // failed because we are replicating in a schema change
                     // that is conflicting with existing schema, or such
                     // a conflict has occured earlier. Go on for now so
                     // that we find other conflicts (but will not commit
                     // anything), but remember for later to return correct
                     // error code.
                     // Clear out thstate error info so that we can continue

                     fSchemaConflict = TRUE;
                     // continue wiith the next object
                     Assert(pTHS->fSchemaConflict);
                     THClearErrors();
                     ret = 0;
                     continue;

                // The following errors are sync failure type errors,
                // we move the error into sync failure and return
                // ret = 0. This allows caller to report general
                // success, save sync point, and return sync
                // failure warning to user.


                case DRAERR_Busy:
                    if ((DRAERR_Busy == retTransOut)
                        && (cNumWriteConflictRetries++ < MAX_WRITE_CONFLICT_RETRIES)) {
                        // We failed to commit the transaction due to a write
                        // conflict during escrowed update.  This indicates e.g.
                        // that one or more members of a group we're adding were
                        // modified between the start of our transaction and the
                        // escrowed update.  This is not unlikely in the case of
                        // a large group, which may take on the order of a
                        // minute to update.
                        //
                        // Bump priority to try to run our update through ahead
                        // of contending clients and try again.

                        if (!fResetThreadPriority) {
                            // Note that priority remains raised until end of packet
                            fResetThreadPriority = TRUE;
                            nOrigThreadPriority = GetThreadPriority(GetCurrentThread());
                            SetThreadPriority(GetCurrentThread(),
                                              THREAD_PRIORITY_ABOVE_NORMAL);
                            cTickStartRaisePriority = GetTickCount();
                            pentinflistWriteConflict = pentinflist;
                        }

                        fRetry = TRUE;
                        ret = 0;
                        continue;
                    }

                    // Log busy error.
                    LogUpdateFailure (pTHS, pszServerName,
                                      pentinflist->Entinf.pName);
                    pTHS->errCode = 0;

                // Warning, fAll through

                case DRAERR_Preempted:

                    *pulSyncFailure = ret;
                    ret = 0;
                    break;

                // This is an unexpected error case, which we return to
                // user.

                case DRAERR_SchemaMismatch:
                    // Log Schema mismatch error, abort updating and return
                    *pulSyncFailure = ret;
                    ret = 0;

                    // Increment the perfmon counter
                    PERFINC(pcDRASyncRequestFailedSchemaMismatch);

                    LogEvent(
                        DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_ALWAYS,
                        DIRLOG_DRA_SCHEMA_MISMATCH,
                        szInsertDN(pentinflist->Entinf.pName),
                        szInsertWC(pszServerName),
                        szInsertDN(pNC)
                        );
                    return ret;
                    break;

                case ERROR_DISK_FULL:
                    LogEvent(DS_EVENT_CAT_REPLICATION,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DRA_UPDATE_FAILURE_DISK_FULL,
                             szInsertDN(pentinflist->Entinf.pName),
                         szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                             szInsertWC(pszServerName) );
                    break;

                case ERROR_DS_OUT_OF_VERSION_STORE:  // Jet out of version store
                    LogEvent8(DS_EVENT_CAT_REPLICATION,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_DRA_UPDATE_FAILURE_TOO_LARGE,
                              szInsertDN(pentinflist->Entinf.pName),
                              szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                              szInsertWC(pszServerName),
                              szInsertWin32Msg(ret),
                              szInsertWin32ErrCode(ret),
                              NULL, NULL, NULL );
                    break;

        case ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT:
            // lingering object found - abort replication!
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_LINGERING_OBJECT_FOUND_ABORT,
                  szInsertWC(pszServerName),
                  szInsertDN(pentinflist->Entinf.pName),
                  szInsertUUID( &(pentinflist->Entinf.pName->Guid) ),
                  szInsertSz(DRA_STRICT_REPLICATION_CONSISTENCY), 
                  NULL, NULL, NULL, NULL);
            break;

        case ERROR_DS_DRA_OBJ_NC_MISMATCH:
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_OBJ_NC_MISMATCH,
                  szInsertDN(pNC),
                  szInsertDN(pentinflist->Entinf.pName),
                  szInsertUUID(&pentinflist->Entinf.pName->Guid),
                  pentinflist->pParentGuid
                  ? szInsertUUID(pentinflist->pParentGuid)
                  : szInsertSz(""),
                  szInsertWC(pszServerName),
                  NULL, NULL, NULL);

        default:

                    // General error.

                    LogUpdateFailureNB (pTHS,
                                        pszServerName,
                                        pentinflist->Entinf.pName,
                                        &(pentinflist->Entinf.pName->Guid),
                                        ret);
                    break;
                }

                break;          // Exit for(each object) loop

            } else {

                // If we modified an object, record NC as modified
                if (UpdateStatus)
                {
                    if (!pentinflist->fIsNCPrefix)
                    {
                        // at least one interior node modified
                        *pdwNCModified = MODIFIED_NCTREE_INTERIOR;
                    }
                    else if (MODIFIED_NOTHING == *pdwNCModified)
                    {
                        // nc head is the only thing that has been modified so far
                        *pdwNCModified = MODIFIED_NCHEAD_ONLY;
                    }
                    // Count object creations and updates
                    if (UpdateStatus == UPDATE_OBJECT_CREATION)
                    {
                        (*pdwObjectCreationCount)++;
                        DPRINT1( 1, "Created: %ws\n", pentinflist->Entinf.pName->StringName );
                    }
                    else {
                        DPRINT1( 1, "Modified: %ws\n", pentinflist->Entinf.pName->StringName );
                    }
                }

            }
        } // for ()

        // One more try in case no objects applied
        if ((INVALIDDNT == dntNC)
            && !DBFindDSName(pTHS->pDB, pNC)) {
            dntNC = pTHS->pDB->DNT;
        }

        // If there are values, we better be in lvr mode
        Assert( (pmsgReply->cNumValues == 0) || pTHS->fLinkedValueReplication);
        // Should not have been cleared prematurely
        Assert( pTHS->pDB->fScopeLegacyLinks );

        // Apply value changes
        if (!ret && !*pulSyncFailure && pmsgReply->cNumValues) {
            pTHS->pDB->fScopeLegacyLinks = FALSE;

            ret = UpdateNCValuesHelp(
                pTHS,
                dntNC,
                hPrefixMap,
                pmsgReply->cNumValues,
                pmsgReply->rgValues,
                pszServerName,
                RepFlags,
                fIsPreemptable,
                pulSyncFailure,
                pdwValueCreationCount,
                pdwNCModified
                );
        }

    } __finally {
        ULONG ret1;

        if (NULL != pTHS->pDB) {
            pTHS->pDB->fScopeLegacyLinks = FALSE;
        }

        if (fTransStarted) {
            ret1 = EndDraTransactionSafe (!(ret || AbnormalTermination()));
            if (ret == 0 && ret1 != 0) {
                ret = ret1;
            }
        }

        if (fSchemaSync) {
            LeaveCriticalSection(&csNoOfSchChangeUpdate);
        }

        if (fSDPLocked)
        {
            SDP_LeaveAddAsReader();
            fSDPLocked = FALSE;
        }

        if (fResetThreadPriority) {
            SetThreadPriority(GetCurrentThread(), nOrigThreadPriority);
            cTickDiff = GetTickCount() - cTickStartRaisePriority;
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_WRITE_CONFLICT_INFO,
                     szInsertDN(pentinflistWriteConflict->Entinf.pName),
                     szInsertUL((cTickDiff/1000)),
                     NULL);
        }

        THFreeEx(pTHS, pMetaDataVec);

        PrefixMapCloseHandle(&hPrefixMap);
    }

    if (fSchemaConflict) {
        // detected at least one schema conflict. Override all other
        // errors?
        ret = DRAERR_SchemaConflict;
    }
    return ret;
} // end UpdateNC()


LPWSTR
DSaddrFromName(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pdnServer
    )
/*++

Routine Description:

    Derive the network name of a server from its DSNAME.  The returned name is
    thread-allocated and is of the form

    c330a94f-e814-11d0-8207-a69f0923a217._msdcs.CLIFFVDOM.NTDEV.MICROSOFT.COM

    where "CLIFFVDOM.NTDEV.MICROSOFT.COM" is the DNS name of the root domain of
    the DS enterprise (not necessarily the DNS name of the _local_ domain of the
    target server) and "c330a94f-e814-11d0-8207-a69f0923a217" is the stringized
    object guid of the server's NTDS-DSA object.

Arguments:

    pdnServer - DSNAME of the NTDS-DSA object of the server for which the
        network name is desired.  Must have filled-in GUID.

Return Values:

    The corresponding network name, or NULL on failure.

--*/
{
    RPC_STATUS  rpcStatus;
    DWORD       cch;
    LPWSTR      pszServerGuid;
    LPWSTR      pszNetName = NULL;

    Assert( !fNullUuid( &pdnServer->Guid ) );
    Assert( NULL != gAnchor.pwszRootDomainDnsName );

    if ( !gfRunningInsideLsa )
    {
        // Replication is only supported between like configurations.
        // I.e. Either dsamain to dsamain or real DC to real DC.  Thus
        // if we're !gfRunningInsideLsa then so is our partner and netlogon
        // is not registering his GUID names in DNS.  So we revert
        // to netbios machine names and extract it from the NTDS-DSA DN.

        DSNAME  *pdnToCrack;
        DSNAME  *pdnTmp;
        ULONG   len;
        WCHAR   *rdnVal;
        ULONG   rdnLen = MAX_RDN_SIZE;
        ATTRTYP rdnTyp;
        LPWSTR  pszErr;
        LPWSTR  errText = L"DSaddrFromName_ERROR";
        BOOL    fDbOpen = FALSE;

        if ( !pdnServer->NameLen )
        {
            // GUID only name - get the full DN - which we should have!

            if ( !pTHS->pDB )
            {
                DBOpen2(TRUE, &pTHS->pDB);
                fDbOpen = TRUE;
            }

            __try
            {
                if (    DBFindDSName(pTHS->pDB, pdnServer)
                     || DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                                    0, 0, &len, (UCHAR **) &pdnToCrack ) )
                {
                    LogUnhandledError(ERROR_DS_INTERNAL_FAILURE);
                    pszErr = (LPWSTR) THAllocEx(pTHS,
                                                sizeof(WCHAR)
                                                * (wcslen(errText) + 1));
                    wcscpy(pszErr, errText);
                    return(pszErr);
                }
            }
            __finally
            {
                if ( fDbOpen )
                {
                    DBClose(pTHS->pDB, TRUE);
                }
            }
        }
        else
        {
            pdnToCrack = pdnServer;
        }

        pdnTmp = (DSNAME *) THAllocEx(pTHS, pdnToCrack->structLen);
        rdnVal = (WCHAR *) THAllocEx(pTHS, sizeof(WCHAR) * MAX_RDN_SIZE);
        if (    TrimDSNameBy(pdnToCrack, 1, pdnTmp)
             || GetRDNInfo(pTHS, pdnTmp, rdnVal, &rdnLen, &rdnTyp) )
        {
            LogUnhandledError(ERROR_DS_INTERNAL_FAILURE);
            pszErr = (LPWSTR) THAllocEx(pTHS,
                                        sizeof(WCHAR) * (wcslen(errText) + 1));
            wcscpy(pszErr, errText);
            return(pszErr);
        }

        return rdnVal;
    }

    // Stringize the server's GUID.
    rpcStatus = UuidToStringW(&pdnServer->Guid, &pszServerGuid);

    if ( RPC_S_OK == rpcStatus )
    {
        __try
        {
            Assert(36 == wcslen(pszServerGuid));

            cch = 36 /* guid */ + 8 /* "._msdcs." */
                  + wcslen(gAnchor.pwszRootDomainDnsName) + 1 /* \0 */;

            pszNetName = THAllocEx(pTHS, cch * sizeof(WCHAR));

            swprintf(pszNetName, L"%ls._msdcs.%ls",
                     pszServerGuid, gAnchor.pwszRootDomainDnsName);
        }
        __finally
        {
            RpcStringFreeW(&pszServerGuid);
        }
    }
    else
    {
        // Failed to convert server GUID to string.
        LogUnhandledError( rpcStatus );
    }

    return pszNetName;
}


ULONG
ReqExtendedOpAux(THSTATE *        pTHS,
         DSNAME  *        pDN,
         DSNAME *         pNC,
         DSNAME  *        pTarget,
         ULONG            RepFlags,
         ULONG            ulOp,
         ULARGE_INTEGER * pliInfo,
         ULONG   *        pulRet)
{
    DRS_MSG_GETCHGREQ_NATIVE msgReq = {0};
    DRS_MSG_GETCHGREPLY_NATIVE msgUpd = {0};
    ULONG ulSyncFailure = 0;
    DWORD dwNCModified = MODIFIED_NOTHING;
    LPWSTR pszServerAddr;
    ULONG err, err1 = 0;
    ULONG stringLen, objectsCreated, valuesCreated;
    BOOL  fSamLock = FALSE;
    BYTE  schemaInfo[SCHEMA_INFO_LENGTH] = {0};
    BOOL  fSchInfoChanged = FALSE;
    SYNTAX_INTEGER it;

    Assert(!fNullUuid(&(gAnchor.pDSADN->Guid)));
    msgReq.uuidDsaObjDest = gAnchor.pDSADN->Guid;
    // Note this may be a GUID only DN.
    Assert(pDN->NameLen != 0 || !fNullUuid(&(pDN->Guid)));
    msgReq.pNC = pDN;
    msgReq.ulFlags = RepFlags;
    msgReq.ulExtendedOp = ulOp;
    if ( pliInfo ) {
        msgReq.liFsmoInfo = *pliInfo;
    }

    if (pNC == NULL) {
        Assert(!"All callers should provide this ...");
        return (ERROR_INVALID_PARAMETER);
    }

    // If the current owner of the object is in the reps-from list of this NC,
    // get the usn vector (else, the usn vector is already set to 0)
    GetUSNForExtendedOp(pTarget, pNC, &msgReq.usnvecFrom);


    err = FindNC(pTHS->pDB, pNC, (RepFlags & DRS_WRIT_REP) ? FIND_MASTER_NC : FIND_REPLICA_NC, &it);
    if (err) {
        return err;
    }

    if ((it & IT_NC_GOING) || (it & IT_NC_COMING)) {
	return ERROR_DS_DRA_BAD_NC;
    }

    // Get current UTD vector.
    UpToDateVec_Read(pTHS->pDB,
                     it,
                     UTODVEC_fUpdateLocalCursor,
                     DBGetHighestCommittedUSN(),
                     &msgReq.pUpToDateVecDest);

    /* get address for server represented by pTarget */

    pszServerAddr = DSaddrFromName(pTHS, pTarget);
    if ( NULL == pszServerAddr ) {
        // Translation failed.
        DRA_EXCEPT( DRAERR_InternalError, 0 );
    }


    /* We came in with a transaction, which we ought to close before
     * we go galavanting off to some other server.
     */
    SyncTransEnd(pTHS, TRUE);



    if ( I_DRSIsIntraSiteServer(pTHS, pszServerAddr) ) {
        //
        // Set Fsmo operation to use compression for intra-site operations.
        // If src & dest are both in the same site, we'll take advantage
        // of repl compression.
        //
        msgReq.ulFlags |= DRS_USE_COMPRESSION;
    }

    err = I_DRSGetNCChanges(pTHS,
                            pszServerAddr,
                            NULL,
                            pNC,
                            &msgReq,
                            &msgUpd,
                            schemaInfo,
                            NULL,
                            NULL);
    if (err) {
        // FUTURE: we could get the bind success and use it to purge the sync queue
        // like we do in the regular inbound sync path?
        return err;
    }

    if (!draCheckReplicationLifetime( pTHS, msgReq.pUpToDateVecDest,
                                      &msgUpd.uuidInvocIdSrc,
                                      &msgUpd.uuidDsaObjSrc,
                                      pszServerAddr )) {
        return ERROR_DS_REPL_LIFETIME_EXCEEDED;
    }

    if ( ulOp == EXOP_FSMO_REQ_RID_ALLOC )
    {
        //
        // Grab the SAM lock to avoid write conflicts
        // on the rid set objects - write conflicts
        // could mean a loss of rid pool.
        // Don't start any  "SAM" style transactions
        //
        SampAcquireWriteLock();
        fSamLock = TRUE;
        Assert( pTHS->fSAM == FALSE );
        Assert( pTHS->fSamDoCommit == FALSE );
    }

    _try
    {
        if ( (msgUpd.cNumObjects) || (msgUpd.cNumValues) ) {

            BOOL oldfDRA;
            PVOID oldNewPrefix;
            ULONG oldcNewPrefix;


            // Set the fDRA flag so that schema update, if necessary, can
            // go through

            oldfDRA = pTHS->fDRA;
            pTHS->fDRA = 1;

            // The caller may depend on pTHS->NewPrefix retaining its
            // state across the fsmo transfer. Eg, SampRequestRidPool
            // will use this same thread state and update other attrs
            // after returning from this call. Unfortunately, the update
            // fails in LocalModify if UpdateNC has set pTHS->NewPrefix.
            //
            // Save and restore the state of NewPrefix.

            oldNewPrefix = pTHS->NewPrefix;
            oldcNewPrefix = pTHS->cNewPrefix;

            // Do the way the FSMO protocol rides on top of the replication calls,
            // msgUpd.pNC does not contain the NC DN, but the FSMO object DN, when
            // performing an extended FSMO operation.
            // Pass the true NC in explicitly as the second argument.
            err = UpdateNC(pTHS,
                           pNC,
                           &msgUpd,
                           pszServerAddr,       /* used for logging only */
                           &ulSyncFailure,
                           msgReq.ulFlags,
                           &dwNCModified,
                           &objectsCreated,
                           &valuesCreated,
                           schemaInfo,
                           UPDNC_EXISTING_NC /* must be in an existing NC, not coming or going */);
            pTHS->fDRA = oldfDRA;
            pTHS->NewPrefix = oldNewPrefix;
            pTHS->cNewPrefix = oldcNewPrefix;

            if (!err &&
                !ulSyncFailure) {
                BeginDraTransaction( SYNC_READ_ONLY );
                __try {
                    DBNotifyReplicas(pDN, FALSE /* not urgent */ );
                }
                __finally {
                    EndDraTransaction( !AbnormalTermination() );
                }
            }
        }

        // if this is a schema FSMO transfer, and we are successful so far,
        // write the schemaInfo on the schema container if the other
        // side sent it.

        if ( DsaIsRunning() && NameMatched(gAnchor.pDMD,pNC)
               && (msgUpd.ulExtendedRet == EXOP_ERR_SUCCESS) && !err && !ulSyncFailure ) {

            // Since this is schema fsmo transfer, write always irrespective
            // of whether any actual schema changes were done or not; the
            // current fsmo owner should always have the most uptodate
            // schema-info value

            if ( err1 = WriteSchInfoToSchema(schemaInfo, &fSchInfoChanged) ) {

                 // failed to write Schema Info. May not be harmful
                 // depending on schema change history. Always
                 // log a warning so that admin can manually resync
                 // again to force writing it if the version is indeed
                 // different

                 LogEvent(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_SCHEMA_INFO_WRITE_FAILED,
                          szInsertUL(err1), szInsertDbErrMsg(err1), NULL);
            }

            // if any "real" schema changes happened, up the global
            // to keep track of schema changes since boot, so that
            // later schema replications can check if they have an updated
            // schema cache

            if ( msgUpd.cNumObjects > 1 ) {
                // at least something other than the schema container itself
                // has come in

                IncrementSchChangeCount(pTHS);

            }

            // request a schema cache update if anything worthwhile changed

            if ( (msgUpd.cNumObjects > 1) || fSchInfoChanged ) {

                if (!SCSignalSchemaUpdateImmediate()) {
                     // couldn't even signal a schema update
                     DRA_EXCEPT (DRAERR_InternalError, 0);
                }
            }
        }

    }
    _finally
    {

        if ( fSamLock )
        {
            // Release the sam lock
            Assert( pTHS->fSAM == FALSE );
            Assert( pTHS->fSamDoCommit == FALSE );
            SampReleaseWriteLock( TRUE );  // Commit the non existent changes
            fSamLock = FALSE;
        }

    }

    *pulRet = msgUpd.ulExtendedRet;

    return err;
}
/*++ ReqFSMOOp
 *
 * The client side of a FSMO operation, roughly parallel to ReplicateNC
 *
 * INPUT:
 *  pTHS     - THSTATE pointer
 *  pFSMO    - name of FSMO object
 *  RepFlags - passthrough to replication routines
 *  ulOp     - FSMO operation code (FSMO_REQ_* from mdglobal.h)
 *  pllInfo  - Some extra info to pass to the server
 * OUTPUT:
 *  ulRet    - FSMO result code (EXOP_ERR_* from mdglobal.h)
 * RETURN VALUE:
 *  0        - operation performed, ulRet contains results
 *  non-0    - operation failed, ulRet is not set
 *
 * Note: This routine must be entered with a valid read transaction,
 *       but exits with no transaction open.
 *
 */
ULONG ReqFSMOOp(THSTATE *        pTHS,
                DSNAME  *        pFSMO,
                ULONG            RepFlags,
                ULONG            ulOp,
                ULARGE_INTEGER * pliInfo,
                ULONG   *        pulRet)
{
    DSNAME *pNC;
    DSNAME *pOwner;
    ULONG cbRet;
    ULONG err;
    DWORD isDeleted = FALSE;

    *pulRet = 0; /* set an invalid code */
    
        
    /* Find the relevant FSMO object */
    err = DBFindDSName(pTHS->pDB, pFSMO);
    if (err) {
        return err;
    }

    /* Find the role-owner */
    err = DBGetAttVal(pTHS->pDB,
                      1,
                      ATT_FSMO_ROLE_OWNER,
                      0,
                      0,
                      &cbRet,
                      (UCHAR **)&pOwner);
    if (err) {
        return err;
    }

    if (NameMatched(pOwner, gAnchor.pDSADN))
    {
        // It says we are the FSMO owner. The only reason
        // we could have entered here is if IsFSMOSelfOwnershipValid()
        // was FALSE; Fail it with DRAERR_Busy in that case, so that the
        // caller can retry the operation at a later point
        return DRAERR_Busy;
    }

    do {
    
        /*
         * Make sure the owner is still alive
         */
        err = DBFindDSName(pTHS->pDB, pOwner);
        if (err) {
            *pulRet = EXOP_ERR_FSMO_OWNER_DELETED;
            err = 0;
            break;
        }
        err = DBGetSingleValue(pTHS->pDB, ATT_IS_DELETED,
                         &isDeleted, sizeof(DWORD),NULL);
    
        if ( DB_ERR_NO_VALUE == err )
        {
            // Because DBGetSingleValue seems to overwrite isDeleted
            // with trash in the no value case.
            isDeleted = FALSE;
        }
        else if ( DB_success != err )
        {
            *pulRet = EXOP_ERR_EXCEPTION;
            err = 0;
            break;
        }
    
        if (isDeleted) {
            *pulRet = EXOP_ERR_FSMO_OWNER_DELETED;
            err = 0;
            break;
        }

        pNC = FindNCParentDSName(pFSMO, FALSE, FALSE);    
        if (pNC == NULL) {
            err = ERROR_DS_CANT_FIND_EXPECTED_NC;
            break;
        }

    err = ReqExtendedOpAux(pTHS,
                   pFSMO,
                   pNC,
                   pOwner,
                   RepFlags,
                   ulOp,
                   pliInfo,
                   pulRet);
    } while(0);

    if(    ulOp == EXOP_FSMO_REQ_ROLE
        || ulOp == EXOP_FSMO_RID_REQ_ROLE
        || ulOp == EXOP_FSMO_REQ_PDC ){
        // only log when requesting for a role

        if ( err || (*pulRet) != EXOP_ERR_SUCCESS )  {
           LogEvent8( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_FSMO_XFER_FAILURE,
                      szInsertDN(pFSMO),          
                      szInsertDN(pOwner),
                      szInsertDN(gAnchor.pDSADN),
                      szInsertUL((err) ? err : (*pulRet)),
                      NULL, NULL, NULL, NULL
                      );
        }
        else {
    
            LogEvent( DS_EVENT_CAT_INTERNAL_CONFIGURATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_FSMO_XFER,
                      szInsertDN(pFSMO),          
                      szInsertDN(gAnchor.pDSADN),          
                      szInsertDN(pOwner)
                      );
        }
    }
    return err;
}


ULONG
ReqFsmoGiveaway(THSTATE *pTHS,
                DSNAME  *pFSMO,
                DSNAME  *pTarget,
                ULONG   *pExtendedRet)
{
    DSNAME * pNC;
    ULONG err;

    pNC = FindNCParentDSName(pFSMO, FALSE, FALSE);    
    if (pNC == NULL) {
        err = ERROR_DS_CANT_FIND_EXPECTED_NC;
        return(err);
    }


    err = ReqExtendedOpAux(pTHS,
                           pFSMO,
                           pNC,
                           pTarget,
                           DRS_WRIT_REP,
                           EXOP_FSMO_ABANDON_ROLE,
                           0,
                           pExtendedRet);

    return err;
}


/*++GetUSNForFSMO
 *
 * If the current FSMO role owner is in the reps-from list of this NC,
 * get the usn vector
 *
 * INPUT: pOwner     : current FSMO Role Owner
 *        pNC        : NC containing the FSMO object
 *        usnvecFrom : place to put the usn vecor in
 *
 * Note: On an error in this routine, we simply exit without setting the
 *       usn vector
*/

void GetUSNForExtendedOp(DSNAME *pOwner, DSNAME *pNC, USN_VECTOR *usnvecFrom)
{
    REPLICA_LINK *pRepsFromRef;
    ULONG NthValIndex=0;
    UCHAR *pVal = NULL;
    ULONG bufsize = 0, len, err = 0;
    BOOL fFound = FALSE;
    THSTATE *pTHS=pTHStls;

    if ( (pNC == NULL) || (pOwner == NULL) ) {
       return;
    }

    // Assert that the owner's guid is non-null
    Assert(!fNullUuid(&pOwner->Guid));

    // Check if the owner is in our reps-from list

    if (err = DBFindDSName(pTHS->pDB, pNC)) {
        return;
    }

    while (!(DBGetAttVal(pTHS->pDB,++NthValIndex,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        bufsize = max(bufsize,len);

        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        // recalc size if fixed.
        Assert(bufsize >= pRepsFromRef->V1.cb);

        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

        if (!memcmp(&pOwner->Guid, &(pRepsFromRef->V1.uuidDsaObj), sizeof(UUID))) {
            fFound = TRUE;
            break;
        }
    }
    if (fFound) {
        *usnvecFrom = pRepsFromRef->V1.usnvec;
    }
    if ( pVal )
    {
        THFreeEx(pTHS, pVal );
    }
    return;
}


ENTINF*
GetNcPreservedAttrs(
    IN  THSTATE     *pTHS,
    IN  DSNAME      *pNC)
/*++

Routine Description:

    We're now instantiating the head of this NC, for which we previously had only
    an instantiated placeholder NC (with object class CLASS_TOP). An instantiated
    placeholder NC is created during DRA_ReplicaAdd when a mail-based replica is
    added. In the mail-based path, the placeholder NC is created, a reps-from is
    added, but the first synchronization of the NC head does not occur until the
    next scheduled replication.  In the time before the first sync occurs, the KCC
    may have added other mail-based reps-from which we wish to preserve.

    This code is called from in-bound replication, either rpc-based or mail-based.
    It is possible that since the placeholder NC was added, the KCC may have decided
    to remove the mail-based reps-from. Alternately, the KCC may have decided to start
    the addition of an rpc-based replica.  In the rpc case the reps-from is not
    added until after the replication of the NC head. Thus there may or may not be any
    reps-from here to preserve.
    
    Read attributes we wish to preserve from NC head that will be restored
    upon instantiation.
    Note: Only non-replicated attributes are handled here.

Arguments:

    pTHS -- thread state
    pName -- NC object


Return Value:

    Error: NULL
    Success: read list of attrvals

Remarks:
None.


--*/
{
    ENTINFSEL sel;
    // Non-replicated attribute list we wish to preserve
    ATTR      attrSel[] =
    {//   ATTRTYP         ATTRVALBLOCK{valCount, ATTRVAL*}
        { ATT_REPS_TO,               {0, NULL} },
        { ATT_REPS_FROM,             {0, NULL} },
        { ATT_PARTIAL_ATTRIBUTE_SET, {0, NULL} }
    };
    DWORD   cAttrs = sizeof(attrSel) / sizeof(ATTR);
    ENTINF  *pent;
    DWORD   dwErr;

    sel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    sel.attSel = EN_ATTSET_LIST;

    sel.AttrTypBlock.pAttr = attrSel;
    sel.AttrTypBlock.attrCount = cAttrs;

    // we should be on the object
    Assert(CheckCurrency(pNC));

    // alloc entinf to pass GetEntInf & eventually return
    pent = THAllocEx(pTHS, sizeof(ENTINF));
    // ThAlloc zero's out everything. Sanity here.
    Assert(!pent->AttrBlock.attrCount);

    //
    // Get persistent attributes if there are any.
    //
    if (dwErr = GetEntInf(pTHS->pDB, &sel, NULL, pent, NULL, 0, NULL,
                           GETENTINF_NO_SECURITY,
                           NULL, NULL))
    {
        Assert(!"Failed to GetEntInf in GetNcPreservedAttrs");
        DRA_EXCEPT(dwErr, 0);
    }

    if (!pent->AttrBlock.attrCount)
    {
        // attribute doesn't exist locally -
        THFree(pent);
        pent = NULL;
    }

    return pent;
}

DWORD
DraReplicateSingleObject(
    THSTATE * pTHS,
    DSNAME * pSource,
    DSNAME * pDN,
    DSNAME * pNC,
    DWORD * pExOpError
    ) 
/*++

Routine Description:

    Replicate a single object (pDN) from pSource to this DC.  The Source must
    have at least a GUID in the DSNAME, and the object must have at least a 
    string name in it's DSNAME.  The pExOpError is the GetNCChanges extended operation
    result - specifically, this function can return ERROR_SUCCESS when the 
    operation didn't succeed.  If the source can't handle the request (if it's Win2K) it
    will return success, but pExOpError will contain EXOP_ERR_UNKNOWN_OP.
    
    Notes:
    The caller must make sure to have checked the control access right
    Replication Synchronization (RIGHT_DS_REPL_SYNC) for this call.
    
    The pDB pointer in pTHS must not already have an open transaction.

Arguments:

    pTHS -- thread state with unused pDB
    pSource -- source (DN to the NTDS Settings Object of the server you want to talk to)
    pDN -- objec to replicate, this DN must either have a valid string name,
        portion or must have a non-NULL GUID of the object to replicate.
    pNC -- the naming context (NC) the object (pDN) is contained in
    pExOpError - extended operation error - check this and verify with special
    EXOP_ERR_ codes (note that 1 is success and 0 is undefined in these codes).

Return Value:

    0 or WinErrors. 

--*/
{
    DWORD err = 0;
    DWORD ExOpErr = EXOP_ERR_EXCEPTION;
    ULONG ulReplOptions = 0;

    Assert(pSource);
    Assert(pDN);

    Assert(!fNullUuid(&(pSource->Guid)));

    SYNC_TRANS_READ();
    __try { 

        Assert(gAnchor.pMasterNC);
        if (pNC == NULL) {
            Assert(!"All callers must provide the NC to this function.");
            err = ERROR_INVALID_PARAMETER;
            ExOpErr = EXOP_ERR_PARAM_ERR;
            __leave;
        }
        
        if (IsMasterForNC(pTHS->pDB, gAnchor.pDSADN, pNC) ||
            (DsaIsInstalling() && NameMatched(gAnchor.pConfigDN, pNC)) ) {
            // I am a master, I'm requesting an update to a master copy
            ulReplOptions = DRS_WRIT_REP;
        } else {
            // do not use this for read-only NC's 
            Assert(!"This function shouldn't be used for read only NC's!");
            err = ERROR_INVALID_PARAMETER;
            ExOpErr = EXOP_ERR_PARAM_ERR;
            __leave;
        }

        err = ReqExtendedOpAux(pTHS,
                               pDN,
                               pNC,
                               pSource,
                               ulReplOptions,
                               EXOP_REPL_OBJ,
                               0,
                               &ExOpErr); 
    }
    __finally {
        // We may or may not have a transaction here, as ReqExtendedOpAux closes
        // its transaction in a success path.  If an error has occurred,
        // though, it's anyone's guess.
        //

        if (pExOpError) {
            *pExOpError = ExOpErr;
        }

        if (pTHS->pDB) {
            CLEAN_BEFORE_RETURN(pTHS->errCode);
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drarpc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drarpc.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Defines DRS Rpc Test hooks and functions.

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <01/30/01>  gregjohn

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include "debug.h"              // standard debugging header
#define DEBSUB "DRARPC:"       // define the subsystem for debugging

#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <winsock2.h>
#include "drarpc.h"

#include <mdcodes.h>
#include <dsevent.h>

#include <fileno.h>
#define  FILENO FILENO_DRARPC

#define MAX_COMPONENTS 8

// why doesn't rpc define this?  As soon as they do, get rid of this.
static PWCHAR aRPCComponents[MAX_COMPONENTS+1] = {
    L"Unknown",              // 0
    L"Application",          // 1
    L"RPC Runtime",          // 2	
    L"Security Provider",    // 3
    L"NPFS",                 // 4
    L"RDR",                  // 5
    L"NMP",                  // 6
    L"IO",                   // 7
    L"Winsock",              // 8
    };

VOID					 
LogRpcExtendedErrorInfo(
    THSTATE * pTHS,
    RPC_STATUS status,
    LPWSTR pszServer,
    ULONG dsid
    )
{
    RPC_STATUS Status2;
    RPC_ERROR_ENUM_HANDLE EnumHandle;
    RPC_EXTENDED_ERROR_INFO ErrorInfo;
    LPWSTR pszComputerName = NULL;
    DWORD cchComputerName = 0;
    BOOL fFreeComputerName = FALSE;
    DWORD dwErr = 0;
    int iRecords = 0;
    WCHAR pszTime[20];

    if (status) { 

	Status2 = RpcErrorStartEnumeration(&EnumHandle);
	if (Status2 == RPC_S_ENTRY_NOT_FOUND)
	    {
	    DPRINT(3,"RPC_S_ENTRY_NOT_FOUND\n");
	}
	else if (Status2 != RPC_S_OK)
	    {
	    DPRINT1(3,"Couldn't get EEInfo: %d\n", Status2);  
	}
	else { 
	    // calculate local hostname for logging
	    GetComputerNameExW(ComputerNameDnsHostname, pszComputerName, &cchComputerName);
	    pszComputerName = THAllocEx(pTHS, cchComputerName*sizeof(WCHAR));
	    fFreeComputerName = TRUE;
	    if (pszComputerName!=NULL) {
		GetComputerNameExW(ComputerNameDnsHostname, pszComputerName, &cchComputerName);
	    } 

	    // get number of entries
	    if (Status2==RPC_S_OK) {   
		Status2 = RpcErrorGetNumberOfRecords(&EnumHandle,
						     &iRecords);
	    }

	    // goto last entry
	    if (Status2==RPC_S_OK) {
		while ((iRecords-->0) && (Status2 == RPC_S_OK)) {
		    ErrorInfo.Version = RPC_EEINFO_VERSION;
		    ErrorInfo.Flags = 0;
		    ErrorInfo.NumberOfParameters = 4;
		    Status2 = RpcErrorGetNextRecord(&EnumHandle,
						    FALSE,  // BOOL CopyStrings - FALSE = do not free strings
						    &ErrorInfo);
		    // computer name is only listed at the head of the block
		    // for each computer in the chain, so if one is there,
		    // get it (and keep it until the next block).  If there isn't a 
		    // computer name, then use the local hostname.
		    if (Status2==RPC_S_OK) {
			if (ErrorInfo.ComputerName) {
			    if (fFreeComputerName) {
				// since we use CopyStrings, we don't need to free the ErrorInfo.ComputerName
				// string, however, the first records (for the local host) don't specify the
				// computer name, so we need to free the one we created above with GetCompterNameEx
				THFreeEx(pTHS, pszComputerName);
				fFreeComputerName = FALSE;
			    }
			    pszComputerName = ErrorInfo.ComputerName;
			}
		    }

		    if ((Status2==RPC_S_OK) && (iRecords>0)) {  
			// log extensive info - this is irrelevant data, and mostly a sanity check
			LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
				  DS_EVENT_SEV_INTERNAL,
				  DIRLOG_DRA_RPC_EXTENDED_ERROR_INFO_EXTENSIVE,    
				  szInsertWin32Msg(status),
				  szInsertUL(status),
				  szInsertWC(pszServer),
				  szInsertWin32Msg(ErrorInfo.Status),
				  szInsertUL(ErrorInfo.Status),
				  szInsertWC(pszComputerName),    
				  szInsertUL(ErrorInfo.ProcessID),
				  szInsertHex(dsid));
			swprintf(pszTime,
				 L"%04d-%02d-%02d %02d:%02d:%02d",
				 ErrorInfo.u.SystemTime.wYear % 10000,
				 ErrorInfo.u.SystemTime.wMonth,
				 ErrorInfo.u.SystemTime.wDay,
				 ErrorInfo.u.SystemTime.wHour,
				 ErrorInfo.u.SystemTime.wMinute,
				 ErrorInfo.u.SystemTime.wSecond);
			LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
				 DS_EVENT_SEV_INTERNAL,
				 DIRLOG_DRA_RPC_EXTENDED_ERROR_INFO_PART_II,
				 szInsertWin32Msg(ErrorInfo.Status),
				 szInsertUL(ErrorInfo.Status),
				 szInsertWC(pszComputerName),
				 szInsertUL(ErrorInfo.DetectionLocation),
				 szInsertWC((ErrorInfo.GeneratingComponent <= MAX_COMPONENTS)
					    ? aRPCComponents[ErrorInfo.GeneratingComponent]
					    : L"Unknown"),
				 szInsertWC(pszTime),
				 NULL,
				 NULL); 
    
			DPRINT_RPC_EXTENDED_ERROR_INFO(1, pszComputerName, dsid, &ErrorInfo);
		    }
		}
	    }
 
	    // log info in ErrorInfo
	    if (Status2==RPC_S_OK) {
		
		LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
			  DS_EVENT_SEV_MINIMAL,
			  DIRLOG_DRA_RPC_EXTENDED_ERROR_INFO,
			  szInsertWin32Msg(status),
			  szInsertUL(status),
			  szInsertWC(pszServer),
			  szInsertWin32Msg(ErrorInfo.Status),
			  szInsertUL(ErrorInfo.Status),
			  szInsertWC(pszComputerName),
			  szInsertUL(ErrorInfo.ProcessID),
			  szInsertHex(dsid));
		swprintf(pszTime,
			L"%04d-%02d-%02d %02d:%02d:%02d",
			ErrorInfo.u.SystemTime.wYear % 10000,
			ErrorInfo.u.SystemTime.wMonth,
			ErrorInfo.u.SystemTime.wDay,
			ErrorInfo.u.SystemTime.wHour,
			ErrorInfo.u.SystemTime.wMinute,
			ErrorInfo.u.SystemTime.wSecond);
		LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
			  DS_EVENT_SEV_BASIC,
			  DIRLOG_DRA_RPC_EXTENDED_ERROR_INFO_PART_II,
			  szInsertWin32Msg(ErrorInfo.Status),
			  szInsertUL(ErrorInfo.Status),
			  szInsertWC(pszComputerName),
			  szInsertUL(ErrorInfo.DetectionLocation),
			  szInsertWC((ErrorInfo.GeneratingComponent <= MAX_COMPONENTS)
				    ? aRPCComponents[ErrorInfo.GeneratingComponent]
				     : L"Unknown"),
			  szInsertWC(pszTime),
			  NULL,
			  NULL); 

		DPRINT_RPC_EXTENDED_ERROR_INFO(1, pszComputerName, dsid, &ErrorInfo);  
	    }  
	    RpcErrorEndEnumeration(&EnumHandle);
	    if (fFreeComputerName) { 
		THFreeEx(pTHS, pszComputerName);
		fFreeComputerName = FALSE;
	    }
	}
	if (Status2!=RPC_S_OK) {
	    LogEvent(DS_EVENT_CAT_RPC_CLIENT,
		      DS_EVENT_SEV_EXTENSIVE,
		      DIRLOG_DRA_RPC_NO_EXTENDED_ERROR_INFO,
		      szInsertWin32Msg(status),
		      szInsertUL(status),
		      szInsertWC(pszServer));   
	}
    }
}


#if DBG

VOID
DebugPrintRpcExtendedErrorInfo(
    IN USHORT level,
    IN LPWSTR pszComputerName,
    IN ULONG dsid,
    IN RPC_EXTENDED_ERROR_INFO * pErrorInfo
    )
/*++
Routine Description:


Arguments:


Return Value:
    None.
--*/
{
    LONG    i;

    pszComputerName = (pErrorInfo->ComputerName ? pErrorInfo->ComputerName : pszComputerName);
    // Dump it with findstr tag RPC EXTENDED
    DPRINT1(level, "RPC_EXTENDED: Server   : %ws\n", pszComputerName);
    DPRINT1(level, "RPC_EXTENDED: ProcessId: %d\n", pErrorInfo->ProcessID);
    DPRINT1(level, "RPC_EXTENDED: Dsid     : %08X\n", dsid);
    DPRINT2(level, "RPC_EXTENDED: Component: %d (%ws)\n", 
	    pErrorInfo->GeneratingComponent,
	    (pErrorInfo->GeneratingComponent <= MAX_COMPONENTS)
	    ? aRPCComponents[pErrorInfo->GeneratingComponent]
	    : L"Unknown");
    DPRINT1(level, "RPC_EXTENDED: Status   : %d\n", pErrorInfo->Status);
    DPRINT1(level, "RPC_EXTENDED: Location : %d\n", (int)pErrorInfo->DetectionLocation);
    DPRINT1(level, "RPC_EXTENDED: Flags    : 0x%x\n", pErrorInfo->Flags);
    
    DPRINT7(level, "RPC_EXTENDED: System Time is: %d/%d/%d %d:%d:%d:%d\n", 
		pErrorInfo->u.SystemTime.wMonth,
		pErrorInfo->u.SystemTime.wDay,
		pErrorInfo->u.SystemTime.wYear,
		pErrorInfo->u.SystemTime.wHour,
		pErrorInfo->u.SystemTime.wMinute,
		pErrorInfo->u.SystemTime.wSecond,
		pErrorInfo->u.SystemTime.wMilliseconds);

    DPRINT1(level, "RPC_EXTENDED: nParams  : %d\n", pErrorInfo->NumberOfParameters);
    for (i = 0; i < pErrorInfo->NumberOfParameters; ++i) {
	switch(pErrorInfo->Parameters[i].ParameterType) {
	case eeptAnsiString:
	    DPRINT1(level, "RPC_EXTENDED: Ansi string   : %s\n", 
		    pErrorInfo->Parameters[i].u.AnsiString);
	    break;

	case eeptUnicodeString:
	    DPRINT1(level, "RPC_EXTENDED: Unicode string: %ws\n", 
		    pErrorInfo->Parameters[i].u.UnicodeString);
	    break;

	case eeptLongVal:
	    DPRINT2(level, "RPC_EXTENDED: Long val      : 0x%x (%d)\n", 
		    pErrorInfo->Parameters[i].u.LVal,
		    pErrorInfo->Parameters[i].u.LVal);
	    break;

	case eeptShortVal:
	    DPRINT2(level, "RPC_EXTENDED: Short val     : 0x%x (%d)\n", 
		    (int)pErrorInfo->Parameters[i].u.SVal,
		    (int)pErrorInfo->Parameters[i].u.SVal);
	    break;

	case eeptPointerVal:
	    DPRINT1(level, "RPC_EXTENDED: Pointer val   : 0x%x\n", 
		    (ULONG)pErrorInfo->Parameters[i].u.PVal);
	    break;

	case eeptNone:
	    DPRINT(level, "RPC_EXTENDED: Truncated\n");
	    break;

	default:
	    DPRINT2(level, "RPC_EXTENDED: Invalid type  : 0x%x (%d)\n", 
		    pErrorInfo->Parameters[i].ParameterType,
		    pErrorInfo->Parameters[i].ParameterType);
	}
    }
}

// global barrier for rpcsync tests
BARRIER gbarRpcTest;

void
BarrierInit(
    IN BARRIER * pbarUse,
    IN ULONG    ulThreads,
    IN ULONG    ulTimeout
    )
/*++

Routine Description:

    Barrier Init function.  See BarrierSync

Arguments:
    
    pbarUse - The barrier to use for the threads.
    ulThreads - Number of threads to wait on
    ulTimeout - length of time in minutes to wait before giving up

Return Value:

    None

--*/
{
    pbarUse->heBarrierInUse = CreateEventW(NULL, TRUE, TRUE, NULL);
    pbarUse->heBarrier = CreateEventW(NULL, TRUE, FALSE, NULL);

    InitializeCriticalSection(&(pbarUse->csBarrier));
    pbarUse->ulThreads = ulThreads;
    pbarUse->ulTimeout = ulTimeout*1000*60;
    pbarUse->ulCount = 0;

    pbarUse->fBarrierInUse = FALSE;
    pbarUse->fBarrierInit = TRUE;
}

void
BarrierReset(
    IN BARRIER * pbarUse
    )
/*++

Routine Description:

    Barrier Reset function.  See BarrierSync

Arguments:
    
    pbarUse - The barrier struct to use

Return Value:

    None

--*/
{
    // enable all threads to leave	
    EnterCriticalSection(&pbarUse->csBarrier);
    __try { 
	pbarUse->fBarrierInUse = TRUE;
	ResetEvent(pbarUse->heBarrierInUse);
	SetEvent(pbarUse->heBarrier);
    }
    __finally { 
	LeaveCriticalSection(&pbarUse->csBarrier);
    }
}


void
BarrierSync(
    IN BARRIER * pbarUse
    )
/*++

Routine Description:

    Mostly generalized barrier function.  Threads wait in this function until
    #ulThreads# have entered, then all leave simultaneously

Arguments:
    
    pbarUse - The barrier struct to use

Return Value:

    None

--*/
{
    if (pbarUse->fBarrierInit) { 
	BOOL fInBarrier = FALSE;
	DWORD ret = 0;
	do {
	    ret = WaitForSingleObject(pbarUse->heBarrierInUse, pbarUse->ulTimeout); 
	    if (ret) {
		DPRINT(0,"Test Error, BarrierSync\n");
		BarrierReset(pbarUse);
		return;
	    }
	    EnterCriticalSection(&pbarUse->csBarrier);
	    __try { 
		if (!pbarUse->fBarrierInUse) {
		    fInBarrier=TRUE;
		    if (++pbarUse->ulCount==pbarUse->ulThreads) {
			DPRINT2(0,"Barrier (%d) contains %d threads\n", pbarUse, pbarUse->ulThreads);
			pbarUse->fBarrierInUse = TRUE;
			ResetEvent(pbarUse->heBarrierInUse);
			SetEvent(pbarUse->heBarrier);
		    }  
		}
	    }
	    __finally { 
		LeaveCriticalSection(&pbarUse->csBarrier);
	    }
	} while ( !fInBarrier );
	ret = WaitForSingleObject(pbarUse->heBarrier, pbarUse->ulTimeout);
	if (ret) {
	    DPRINT(0,"Test Error, BarrierSync\n");
	    BarrierReset(pbarUse); 
	}
	EnterCriticalSection(&pbarUse->csBarrier);
	__try { 
	    if (--pbarUse->ulCount==0) {
		DPRINT1(0,"Barrier (%d) contains 0 threads\n", pbarUse);
		ResetEvent(pbarUse->heBarrier);
		SetEvent(pbarUse->heBarrierInUse);
		pbarUse->fBarrierInUse = FALSE;
	    }
	}
	__finally { 
	    LeaveCriticalSection(&pbarUse->csBarrier);
	}
    }
}

RPCTIME_INFO grgRpcTimeInfo[MAX_RPCCALL];
ULONG        gRpcTimeIPAddr;
RPCSYNC_INFO grgRpcSyncInfo[MAX_RPCCALL];
ULONG        gRpcSyncIPAddr;

void
RpcTimeSet(ULONG IPAddr, RPCCALL rpcCall, ULONG ulRunTimeSecs) 
/*++

Routine Description:

    Enable a time test of DRA Rpc calls for the given client
    and the given Rpc call.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT3(1,"RpcTimeSet Called with IP = %s, RPCCALL = %d, and RunTime = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall,
	    ulRunTimeSecs);
    gRpcTimeIPAddr = IPAddr;
    grgRpcTimeInfo[rpcCall].fEnabled = TRUE;
    grgRpcTimeInfo[rpcCall].ulRunTimeSecs = ulRunTimeSecs;
}

void
RpcTimeReset() 
/*++

Routine Description:

    Reset all the set tests.  Do not explicitly wake threads.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    ULONG i = 0;
    gRpcTimeIPAddr = INADDR_NONE;
    for (i = MIN_RPCCALL; i < MAX_RPCCALL; i++) {
	grgRpcTimeInfo[i].fEnabled = FALSE;
	grgRpcTimeInfo[i].ulRunTimeSecs=0;
    }
}

void
RpcTimeTest(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Check to see if a test has been enabled for this IP and this
    rpc call, if so, sleep the allotted time, else nothing

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcTimeTest Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    if (grgRpcTimeInfo[rpcCall].fEnabled && (gRpcTimeIPAddr == IPAddr)) {
	DPRINT3(0,"RPCTIME TEST:  RPC Call (%d) from %s will sleep for %d secs!\n",
	       rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)), grgRpcTimeInfo[rpcCall].ulRunTimeSecs);
	Sleep(grgRpcTimeInfo[rpcCall].ulRunTimeSecs * 1000);
	DPRINT2(0,"RPCTIME TEST:  RPC Call (%d) from %s has awoken!\n",
		rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
    }
}

void
RpcSyncSet(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Enable a syncronized test of DRA Rpc calls for the given client
    and the given Rpc call.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcSyncSet Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    gRpcSyncIPAddr = IPAddr;
    grgRpcSyncInfo[rpcCall].fEnabled = TRUE;
    grgRpcSyncInfo[rpcCall].ulNumThreads = 2;
}

void
RpcSyncReset() 
/*++

Routine Description:

    Reset all the set tests, and free all waiting threads.

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    ULONG i = 0;
    gRpcSyncIPAddr = INADDR_NONE;
    for (i = MIN_RPCCALL; i < MAX_RPCCALL; i++) {
	grgRpcSyncInfo[i].fEnabled = FALSE;
	grgRpcSyncInfo[i].ulNumThreads=2;
    }
    // free any waiting threads.
    BarrierReset(&gbarRpcTest);
}

void
RpcSyncTest(ULONG IPAddr, RPCCALL rpcCall) 
/*++

Routine Description:

    Check to see if a test has been enabled for this IP and this
    rpc call, if so, call into a global barrier, else nothing

Arguments:

    IPAddr - IP of the client caller
    rpcCall - the call in question

Return Value:

    None

--*/
{
    DPRINT2(1,"RpcSyncTest Called with IP = %s, RPCCALL = %d.\n",
	    inet_ntoa(*((IN_ADDR *) &IPAddr)),
	    rpcCall);
    if (grgRpcSyncInfo[rpcCall].fEnabled && (gRpcSyncIPAddr == IPAddr)) {
       

	DPRINT2(0,"RPCSYNC TEST:  RPC Call (%d) from %s will enter barrier!\n",
	       rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
	BarrierSync(&gbarRpcTest);
	DPRINT2(0,"RPCSYNC TEST:  RPC Call (%d) from %s has left barrier!\n",
		rpcCall, inet_ntoa(*((IN_ADDR *) &IPAddr)));
    }
}

void RpcTest(ULONG IPAddr, RPCCALL rpcCall) 
{
    RpcTimeTest(IPAddr, rpcCall);
    RpcSyncTest(IPAddr, rpcCall);
}

RPCCALL
GetRpcCallA(LPSTR pszDsa)
{
    RPCCALL returnVal;
    if (!_stricmp(pszDsa,"bind")) {
	returnVal=IDL_DRSBIND;
    }
    else if (!_stricmp(pszDsa,"addentry")) {
	returnVal=IDL_DRSADDENTRY;
    }
    else if (!_stricmp(pszDsa,"addsidhistory")) {
	returnVal=IDL_DRSADDSIDHISTORY;
    }
    else if (!_stricmp(pszDsa,"cracknames")) {
	returnVal=IDL_DRSCRACKNAMES;
    }
    else if (!_stricmp(pszDsa,"domaincontrollerinfo")) {
	returnVal=IDL_DRSDOMAINCONTROLLERINFO;
    }
    else if (!_stricmp(pszDsa,"executekcc")) {
	returnVal=IDL_DRSEXECUTEKCC;
    }
    else if (!_stricmp(pszDsa,"getmemberships")) {
	returnVal=IDL_DRSGETMEMBERSHIPS;
    }
    else if (!_stricmp(pszDsa,"getmemberships2")) {
	returnVal=IDL_DRSGETMEMBERSHIPS2;
    }
    else if (!_stricmp(pszDsa,"getncchanges")) {
	returnVal=IDL_DRSGETNCCHANGES;
    }
    else if (!_stricmp(pszDsa,"getnt4changelog")) {
	returnVal=IDL_DRSGETNT4CHANGELOG;
    }
    else if (!_stricmp(pszDsa,"getreplinfo")) {
	returnVal=IDL_DRSGETREPLINFO;
    }
    else if (!_stricmp(pszDsa,"inheritsecurityidentity")) {
	returnVal=IDL_DRSINHERITSECURITYIDENTITY;
    }
    else if (!_stricmp(pszDsa,"interdomainmove")) {
	returnVal=IDL_DRSINTERDOMAINMOVE;
    }
    else if (!_stricmp(pszDsa,"removedsdomain")) {
	returnVal=IDL_DRSREMOVEDSDOMAIN;
    }
    else if (!_stricmp(pszDsa,"removedsserver")) {
	returnVal=IDL_DRSREMOVEDSSERVER;
    }
    else if (!_stricmp(pszDsa,"replicaadd")) {
	returnVal=IDL_DRSREPLICAADD;
    }
    else if (!_stricmp(pszDsa,"replicadel")) {
	returnVal=IDL_DRSREPLICADEL;
    }
    else if (!_stricmp(pszDsa,"replicamodify")) {
	returnVal=IDL_DRSREPLICAMODIFY;
    }
    else if (!_stricmp(pszDsa,"replicasync")) {
	returnVal=IDL_DRSREPLICASYNC;
    }
    else if (!_stricmp(pszDsa,"unbind")) {
	returnVal=IDL_DRSUNBIND;
    }
    else if (!_stricmp(pszDsa,"updaterefs")) {
	returnVal=IDL_DRSUPDATEREFS;
    }
    else if (!_stricmp(pszDsa,"verifynames")) {
	returnVal=IDL_DRSVERIFYNAMES;
    }
    else if (!_stricmp(pszDsa,"writespn")) {
	returnVal=IDL_DRSWRITESPN;
    }
    else if (!_stricmp(pszDsa,"replicaverifyobjects")) {
	returnVal=IDL_DRSREPLICAVERIFYOBJECTS;
    }
    else if (!_stricmp(pszDsa,"getobjectexistence")) {
	returnVal=IDL_DRSGETOBJECTEXISTENCE;
    }
    else if (!_stricmp(pszDsa,"querysitesbycost")) {
	returnVal=IDL_DRSQUERYSITESBYCOST;
    }
    else {
	returnVal=MIN_RPCCALL;
    }
    return returnVal;
}

ULONG
GetIPAddrA(
    LPSTR pszDSA
    )
/*++

Routine Description:

    Given a string which contains either the hostname or an IP address, return
    the ULONG form of the IP address

Arguments:

    pszDSA - the input hostname or IP address

Return Value:

    IP Address

--*/
{

    ULONG err = 0;
    ULONG returnIPAddr = 0;
 
    THSTATE * pTHS = pTHStls;
    LPWSTR pszMachine = NULL;
    ULONG Length = 0;
    ULONG cbSize = 0;
    HOSTENT *lpHost=NULL;

    // see if the input is an ip address
    returnIPAddr = inet_addr(pszDSA);
    if (returnIPAddr!=INADDR_NONE) {
	// we found an IP address
	return returnIPAddr;
    }

    // else lookup the ip address from the hostname.
    // convert to wide char
    Length = MultiByteToWideChar( CP_ACP,
				  MB_PRECOMPOSED,
				  pszDSA,
				  -1,  
				  NULL,
				  0 );

    if ( Length > 0 ) {
	cbSize = (Length + 1) * sizeof( WCHAR );
	pszMachine = (LPWSTR) THAllocEx( pTHS, cbSize );
	RtlZeroMemory( pszMachine, cbSize );

	Length = MultiByteToWideChar( CP_ACP,
				      MB_PRECOMPOSED,
				      pszDSA,
				      -1,  
				      pszMachine,
				      Length + 1 );
    } 
    if ( 0 == Length ) {
	err = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!err) {
	lpHost = gethostbyname( pszDSA ); 

	if (lpHost) { 
	    memcpy(&returnIPAddr,lpHost->h_addr_list[0], lpHost->h_length);
	}
	else {
	    err = ERROR_OBJECT_NOT_FOUND;
	}
    }
    if (pszMachine) {
	THFreeEx(pTHS,pszMachine);
    }
    if (err) {
	DPRINT1(1,"RPCTEST:  Error getting the IP address (%d)\n", err);
	return INADDR_NONE;
    }
    return returnIPAddr;
}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drasch.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drasch.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines the structures and
    functions to manipulate partial attribute set

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <dsconfig.h>                   // defines such as HOURS_IN_SECS

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRASCH:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"
#include "drancrep.h"
#include "dsaapi.h"
#include "drasch.h"

#include <fileno.h>
#define  FILENO FILENO_DRASCH

// Global pointer to the in-memory deletion list that is being processed currently
// and the critical section that guards access to this list
GCDeletionListProcessed *gpGCDListProcessed = NULL;
CRITICAL_SECTION csGCDListProcessed;

// This is the number purges each time we are scheduled, if more purgest to be done
// we will reschedule ourselves immediately (this is to avoid holding up the taskQ
// for too long and to let other overdue tasks to proceed)
#define MAX_PURGES_PER_TASK_SESSION (20)

// We update the usnLastProcessed marker on the NCHead only infrequently to avoid
// frequent writes to the NCHead.
#define MAX_PURGES_WITHOUT_UPDATING_NCHEAD (200)


// PAS defaults
#define DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE       (32)
#define DEFAULT_PAS_TIME_TOLERANCE                 (2 * HOURS_IN_SECS)  // Seconds.

//
// global variables
//
// (local to this file)
DWORD gPASFailureTolerance = DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE;
DWORD gPASTimeTolerance    = DEFAULT_PAS_TIME_TOLERANCE;

typedef struct _DSACRITERIA{
    INT iTag;               // relative location in repsFrom
    UUID uuidDsa;           // DSA id
    DWORD dwFlag;           // store DSA attributes
    DWORD dwWeight;         // to determine preference
} DSACRITERIA;

////
// Local prototypes
//
VOID
GC_DbgValidatePASLinks(
    DSNAME*      pNC                  // [in]
    );

VOID
GC_ReadRegistryThresholds( VOID  );

//
// Local Definitions
//
#if DBG
#define DBG_VALIDATE_PAS_LINKS(nc)      GC_DbgValidatePASLinks(nc)
#else
#define DBG_VALIDATE_PAS_LINKS(nc)
#endif


BOOL
GC_IsMemberOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in]
    ATTRTYP                     attid,              // [in]
    OUT DWORD                   *pdwAttidPosition)  // [out, optional]

/*************************************************************************************
Routine Description:

    This routine tells if a given attribute is a member of the given partial attribute
    set.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids)
    attid - attribute id of the attribute to be located in the partial set.
    pdwAttidPosition -  returns the index where the attid is located in the
                        vector;
                        if the given attid is NOT a member of partial set,
                        the appropriate index at which this attribute
                        should be inserted to preserve the sort order is
                        returned.
Return Value:

    TRUE, if the given attribute is a member of the default partial
        attribute set, or in the given partial attribute vec;
    FALSE, otherwise.
**************************************************************************************/
{
    int i,nStart, nEnd, nMid;

    if (!pPartialAttrVec || !pPartialAttrVec->V1.cAttrs)
    {
        // vector is empty or zero-lengthed
        if (pdwAttidPosition)
            *pdwAttidPosition = 0;

        return FALSE;
    }

    // Do a binary search for attid
    nStart = 0;
    nEnd = (int) pPartialAttrVec->V1.cAttrs - 1;

    do
    {
        nMid = (nStart + nEnd) /2;

        if (pPartialAttrVec->V1.rgPartialAttr[nMid] < attid)
        {
            // no need to search the lower portion of the array
            nStart = nMid + 1;
        }
        else if (pPartialAttrVec->V1.rgPartialAttr[nMid] > attid)
        {
            // no need to search the upper portion of the array
            nEnd = nMid - 1;
        }
        else
        {
            // found a match
            if (pdwAttidPosition)
            {
                *pdwAttidPosition = nMid;
            }

            return TRUE;
        }
    }
    while (nStart <= nEnd);

    // we didn't find the attid
    if (pdwAttidPosition)
    {
        // need to fill-up the potential position if this attid were to be inserted
        *pdwAttidPosition = (DWORD) nStart;
    }

    return FALSE;
}

BOOL
GC_AddAttributeToPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in, out]
    ATTRTYP                     attid)              // [in]
/*************************************************************************************
Routine Description:

    This routine adds the given attribute to the given partial attribute vector
    at the right place. We assume the caller has already allocated enough space in
    the vector to accommodate the addition.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids and
                        there is enough space to add one more attid)
    attid - attribute id of the attribute to be added to the partial set.

Return Value:

    TRUE, if the given attribute is really added to the partial set;
    FALSE, if we couldn't add or there was no need to add the attribute (i.e. the
            attribute was already part of the given partial set)
**************************************************************************************/
{
    DWORD dwPosition;
    ATTRTYP *pAttr;

    if (!pPartialAttrVec)
    {
        return FALSE;
    }

    if (GC_IsMemberOfPartialSet(pPartialAttrVec, attid, &dwPosition))
    {
        // already a member - no need to add it again
        return FALSE;
    }

    // dwPosition now holds the index for inserting the new attid
    pAttr = & pPartialAttrVec->V1.rgPartialAttr[dwPosition];

    // shift all attributes >= to the given position to the right by 1 position
    // Note:- we assume enough memory is allocated by the caller to shift right
    //          by 1 position
    MoveMemory(pAttr + 1, pAttr,
        sizeof(ATTRTYP) * (pPartialAttrVec->V1.cAttrs - dwPosition));

    // insert the new attid
    *pAttr = attid;

    pPartialAttrVec->V1.cAttrs++;

    return TRUE;
}

BOOL
GC_IsSamePartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec1,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec2)        // [in]
/*************************************************************************************
Routine Description:

    This routine tells if the give two partial sets are same are not.

Arguments:
    pPartialAttrVec1 - pointer to the first partial set
    pPartialAttrVec2 - pointer to the second partial set

Return Value:

    TRUE, if the partial sets are the same;
    FALSE, if they are different.
**************************************************************************************/
{
    if (pPartialAttrVec1 && pPartialAttrVec2 &&
        (pPartialAttrVec1->V1.cAttrs == pPartialAttrVec2->V1.cAttrs) &&
        !memcmp(&pPartialAttrVec1->V1.rgPartialAttr[0],
                &pPartialAttrVec2->V1.rgPartialAttr[0],
                pPartialAttrVec1->V1.cAttrs * sizeof(ATTRTYP)))
    {
        // both partial sets are non-empty and identical
        return TRUE;
    }

    if ((!pPartialAttrVec1 || !pPartialAttrVec1->V1.cAttrs)
        && (!pPartialAttrVec2 || !pPartialAttrVec2->V1.cAttrs))
    {
        // both partial sets are empty - and by definition they are identical
        return TRUE;
    }

    return FALSE;
}


BOOL
GC_GetDiffOfPartialSets(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecOld,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecNew,        // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecAdded,    // [out]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecDeleted)  // [out]
/*************************************************************************************
Routine Description:

    This routine computes the difference between two partial attribute sets.

Arguments:
    pPartialAttrVecOld - pointer to the old partial attribute vector
    pPartialAttrVecNew - pointer to the new partial attribute vector
    ppPartialAttrVecAdded - pointer to receive the set of partial attributes
            that are in the new vector but not in the old; NULL is returned if
            new vector doesn't have any attr that is not present in the old.
            Memory for this has been using THAlloc() and the caller doesn't need
            to explicitly free it.
    ppPartialAttrVecDeleted - pointer to receive the set of partial attributes
            that are in the old vector but not in the new. Again memory for this
            is allocated using THAlloc() and NULL is returned if there are no such
            attributes


Return Value:

    TRUE, if the diff is successfully computed and returned to through the out params
    FALSE, if we couldn't return the diff successfully.
**************************************************************************************/
{
    DWORD i;

    if (!ppPartialAttrVecAdded ||  !ppPartialAttrVecDeleted)
        return FALSE;

    *ppPartialAttrVecAdded = NULL;
    *ppPartialAttrVecDeleted = NULL;

    // compute the additions
    if (pPartialAttrVecNew)
    {
        for (i = 0; i < pPartialAttrVecNew->V1.cAttrs; i++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecOld, pPartialAttrVecNew->V1.rgPartialAttr[i], NULL))
            {
                // this attribute is present only in the new parial set
                if (!*ppPartialAttrVecAdded)
                {
                    // this is the first new attribute detected - allocate space for the
                    // maximum possible new attributes at this stage
                    *ppPartialAttrVecAdded = THAlloc(PartialAttrVecV1SizeFromLen(pPartialAttrVecNew->V1.cAttrs - i));
                    if (!*ppPartialAttrVecAdded)
                        return FALSE;   // unable to alloc memory - can't return the diff successfully.

                    (*ppPartialAttrVecAdded)->dwVersion = VERSION_V1;
                    (*ppPartialAttrVecAdded)->V1.cAttrs = 0;
                }

                // memory is allocated just now or enough memory has been allocated in a previous iteration
                // in any case, we can just add the attribute
                GC_AddAttributeToPartialSet(*ppPartialAttrVecAdded, pPartialAttrVecNew->V1.rgPartialAttr[i]);
            }
        } // end of 1st for loop
    }

    // compute the deletions
    if (pPartialAttrVecOld)
    {
        for (i =0; i < pPartialAttrVecOld->V1.cAttrs; i++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecNew, pPartialAttrVecOld->V1.rgPartialAttr[i], NULL))
            {
                // this attribute is present only in the old partial set
                if (!*ppPartialAttrVecDeleted)
                {
                    // this is the first deleted attribute detected - allocate space for the
                    // maximum possible deleted attributes at this stage
                    *ppPartialAttrVecDeleted = THAlloc(PartialAttrVecV1SizeFromLen(pPartialAttrVecOld->V1.cAttrs - i));
                    if (!*ppPartialAttrVecDeleted)
                        return FALSE; //unable to alloc memory - can't return the diff successfully

                    (*ppPartialAttrVecDeleted)->dwVersion = VERSION_V1;
                    (*ppPartialAttrVecDeleted)->V1.cAttrs = 0;
                }

                // memory is allocated just now or enough memory has been allocated in a previous iteration
                // just add the attribute to deleted set
                GC_AddAttributeToPartialSet(*ppPartialAttrVecDeleted, pPartialAttrVecOld->V1.rgPartialAttr[i]);
            }
        } // end of 2nd for loop
    }

    // successfully computed the difference and returned them through the out params.
    return TRUE;
}

BOOL
GC_IsSubsetOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,           // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecSuper)      // [in]
/*************************************************************************************
Routine Description:

    This routine tells if a partial set is a subset ofmember of the given partial set.

Arguments:
    pPartialAttrVec - pointer to the partial attribute vector (assume the vector
                        is already sort in the increasing order of attids)
    pPartialAttrVecSuper - pointer to the partial attribute vector that is supposed
                        to be superset

Return Value:

    TRUE, if pPartialAttrVec is a subset of pPartialAttrVecSuper
    FALSE, otherwise.
**************************************************************************************/
{

    if (GC_IsSamePartialSet(pPartialAttrVec, pPartialAttrVecSuper))
    {
        // if they are they same, return TRUE  (given that partial attribute set changes
        // are rare, this would be the typical case)
        return TRUE;
    }

    if (pPartialAttrVec)
    {
        DWORD i;

        for (i = 0; i < pPartialAttrVec->V1.cAttrs; i ++)
        {
            if (!GC_IsMemberOfPartialSet(pPartialAttrVecSuper, pPartialAttrVec->V1.rgPartialAttr[i], NULL))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL
GC_ReadPartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVec) // [out]
/*************************************************************************************
Routine Description:

    This routine reads and returns the partial attribute set stored in the NCHead
    of the given NC. Assume we already have an open read transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    ppPartialAttrVec - pointer to receive the partial attribute vector;
                        memory allocated from thread memory; will contain NULL
                        if there is no partial attribute vector
                        Caller can free the allocated memory with THFree() or it will
                        be automatically free as part of thread cleanup.

Return Value:

    TRUE, if pPartialAttrVec is successfully read
    FALSE, otherwise.
**************************************************************************************/
{
    THSTATE * pTHS = pTHStls;
    DWORD cb;
    DWORD retErr;

    *ppPartialAttrVec = NULL;

    if (DRAERR_Success == FindNC(pTHS->pDB, pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC, NULL))
    {
        // NC found successfully
        if (!(retErr = DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_SET,
                                0, 0, &cb, (LPBYTE *) ppPartialAttrVec))
                                || (DB_ERR_NO_VALUE == retErr))
        {
            // either we got the value or no value exists
            // both means the read was successful
            if (*ppPartialAttrVec)
            {
                VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(*ppPartialAttrVec);
            }

            return TRUE;
        }
    }
    else
    {
        // FindNC() failed -- this NC must be a subref, and therefore has no
        // partial set.
        return TRUE;
    }

    // unable to read the attribute set
    return FALSE;
}

VOID
GC_WritePartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec)   // [in]
/*************************************************************************************
Routine Description:

    This routine writes the given partial attribute set on the NCHead
    of the given NC. Assume we already have an open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    pPartialAttrVec - pointer to the partial attribute vector to be written

Return Value:
    None. Exception raised on error.
**************************************************************************************/
{
    DWORD retErr = 0;
    THSTATE *pTHS = pTHStls;

    // set currency on the NC
    if (retErr = DBFindDSName(pTHS->pDB, pNC))
    {
        // Tolerate the NC still being a phantom. This can occur when
        // DRA_ReplicaAdd/Sync fails to bring in the NC head because of a
        // sync failure.
        if (retErr == DIRERR_NOT_AN_OBJECT) {
            return;
        }
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }

    if (pPartialAttrVec)
    {
        VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(pPartialAttrVec);

        // write the given set on the NC
        if (retErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_SET,
                        PartialAttrVecV1Size(pPartialAttrVec), pPartialAttrVec))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }
    else
    {
        // remove the current set
        retErr = DBRemAtt(pTHS->pDB, ATT_PARTIAL_ATTRIBUTE_SET);
        if ( (retErr != DB_success) && (retErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) )
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    // Update the object, but mark it not to wake up ds_waits
    if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                    NULL, META_STANDARD_PROCESSING))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }
}

VOID
GC_TriggerSyncFromScratchOnAllLinks(
    DSNAME                      *pNC)               // [in]
/*************************************************************************************
Routine Description:

    This routine triggers sync from scratch from all replication links
    by resetting the watermarks on all replica links and nuking the UtoD vector.
    Assumes an Open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC that should be triggered for sync from scratch

Return Value:
    None; Exception raised on error.
**************************************************************************************/
{
    DWORD           retErr = DRAERR_Success;
    DWORD           dbErr = DB_success;
    THSTATE         *pTHS = pTHStls;
    REPLICA_LINK    *pLink = NULL;
    DWORD           cbAllocated = 0;
    DWORD           cbReturned = 0;
    ATTCACHE        *pAC = NULL;
    DWORD           i;

    retErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, NULL);

    if (DRAERR_Success == retErr)
    {
        // currency is on the NC Head

        // Nuke UtoD vector
        dbErr = DBRemAtt(pTHS->pDB, ATT_REPL_UPTODATE_VECTOR);
        if (dbErr) {
            if (dbErr == DB_ERR_ATTRIBUTE_DOESNT_EXIST) {
                dbErr = DB_success;
            }
            else {
                // remove attribute failed
                DRA_EXCEPT(DRAERR_InternalError, dbErr);

            }
        }

        pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
        if (NULL == pAC)
        {
            DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ATT_REPS_FROM);
        }

        // reset watermarks on all replica links of this NC
        for (i = 1; (DB_success == dbErr); i++)
        {
            dbErr = DBGetAttVal_AC(pTHS->pDB, i, pAC,
                                DBGETATTVAL_fREALLOC, cbAllocated,
                                &cbReturned, (PBYTE *) &pLink);

            if ((DB_success != dbErr) && (DB_ERR_NO_VALUE != dbErr))
            {
                // hit some unexpected error
                DRA_EXCEPT(DRAERR_DBError, dbErr);
            }


            if (DB_success == dbErr)
            {
                VALIDATE_REPLICA_LINK_VERSION(pLink);

                Assert(pLink->V1.cb == cbReturned);

                cbAllocated = max(cbAllocated, cbReturned);
                pLink = FixupRepsFrom(pLink, &cbAllocated);

                // fixup could realloc larger buffer
                Assert(cbAllocated >= pLink->V1.cb);

                // sanity checks
                Assert(pLink->V1.cbOtherDra == MTX_TSIZE(RL_POTHERDRA(pLink)));

                // reset watermark on this replica link and rewrite
                pLink->V1.usnvec = gusnvecFromScratch;
                pLink->V1.ulReplicaFlags |= DRS_NEVER_SYNCED;
                dbErr = DBReplaceAttVal_AC(pTHS->pDB, i, pAC,
                                           pLink->V1.cb, pLink);

                // Log so the admin knows what's going on.
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_PARTIAL_ATTR_ADD_FULL_SYNC,
                         szInsertDN(pNC),
                         szInsertMTX(RL_POTHERDRA(pLink)),
                         NULL );
            }
        }

        if (DB_ERR_NO_VALUE == dbErr)
        {
            // Update the object, but mark it not to wake up ds_waits
            if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                                    NULL, META_STANDARD_PROCESSING))
            {
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }

            // we successfully nuked the UtoD vector and reset water marks on all replica links
        }
        else
        {
            // above for loop terminated with an unexpected error code (only way
            // we will be here is if DBReplaceAttVal_AC() failed above).
            DRA_EXCEPT(DRAERR_DBError, dbErr);
        }

    }
}

BOOL
GC_ReadGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              **ppGCDList)        // [out]
/*************************************************************************************
Routine Description:

    This routine reads and returns the GCDeletionList stored in the NCHead
    of the given NC. Assume we already have an open read transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    ppGCDList - pointer to receive the GCDeletionList;
                        memory allocated from thread memory; will contain NULL
                        if there is no GCDeletion list on the NCHead
                        Caller can free the allocated memory with THFree() or it will
                        be automatically free as part of thread cleanup.

Return Value:

    TRUE, if GCDeletionList is successfully read
    FALSE, otherwise.
**************************************************************************************/
{
    THSTATE * pTHS = pTHStls;
    DWORD cb;
    DWORD retErr;

    *ppGCDList = NULL;

    if (DRAERR_Success == FindNC(pTHS->pDB, pNC,
                                 FIND_MASTER_NC | FIND_REPLICA_NC, NULL))
    {
        // NC found successfully
        if (!(retErr = DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                                0, 0, &cb, (LPBYTE *) ppGCDList))
                                || (DB_ERR_NO_VALUE == retErr))
        {
            // either we got the value or no value exists
            // both means the read was successful
            if (*ppGCDList)
            {
                VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&(*ppGCDList)->PartialAttrVecDel)
            }

            return TRUE;
        }
    }
    else
    {
        // FindNC() failed -- this NC must be a subref, and therefore has no
        // deletion list.
        return TRUE;
    }

    // unable to read the DeletionList set
    return FALSE;
}

VOID
GC_WriteGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              *pGCDList)          // [in]
/*************************************************************************************
Routine Description:

    This routine writes the given GCDeletionList set on the NCHead
    of the given NC.
    if pGCDList is NULL, it removes the deletion list from the NCHead.

    Assume we already have an open write transaction.

Arguments:
    pNC - pointer to the DSNAME of the NC
    pGCDList - pointer to the Deletin List to be written; if pGCDList is NULL,
                we would remove the attr from the object.

Return Value:
    None; Raises exception on error.
**************************************************************************************/
{
    DWORD retErr = 0;
    THSTATE *pTHS = pTHStls;

    // set currency on the NC
    if (retErr = DBFindDSName(pTHS->pDB, pNC))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }

    if (pGCDList)
    {
        VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&pGCDList->PartialAttrVecDel);

        // write the given deletion list on the NC
        if (retErr = DBReplaceAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                        GCDeletionListSize(pGCDList), pGCDList))
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }
    else
    {
        // remove the current deletion list
        retErr = DBRemAtt(pTHS->pDB, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST);
        if ( (retErr != DB_success) && (retErr != DB_ERR_ATTRIBUTE_DOESNT_EXIST) )
        {
            DRA_EXCEPT(DRAERR_InternalError, retErr);
        }
    }

    // Update the object, but mark it not to wake up ds_waits
    if (retErr = DBRepl(pTHS->pDB, pTHS->fDRA, DBREPL_fKEEP_WAIT,
                            NULL, META_STANDARD_PROCESSING))
    {
        DRA_EXCEPT(DRAERR_InternalError, retErr);
    }
}


BOOL
GC_GetGCDListToProcess(
    DSNAME **ppNC,                  // [out]
    GCDeletionList **ppGCDList)     // [out]
/*************************************************************************************
Routine Description:

    This routine walks through the values of hasPartialReplicaNCs on the local
    msft-dsa object and finds the first NC in the list that has a non-empty
    GCDeletionList. If one such partial replica NC is found the DSNAME and GCDeletionList
    are return through the out parameters (allocation in thread memory).

    Assumes a open read transaction.


Arguments:
    ppNC - pointer to the DSName to receive dsname of partial replica nc head that has
            a non-empty GCDeletionList. NULL, if there are no partial replica NCs with
            non-empty GCDeletionList.
    ppGCDList - pointer to receive the corresponding GCDeletionList.

Return Value:
    TRUE, if a partial replica NC with non-empty deletion list is found;
    FALSE, if no such NC found.
**************************************************************************************/
{
    THSTATE *pTHS = pTHStls;
    ULONG ulRet;
    ULONG len;
    DBPOS *pDBDSAObj;
    ULONG bufSize = 0;
    BOOL  fRet = FALSE;

    *ppNC = NULL;
    *ppGCDList = NULL;

    // have a separate DBPOS to iterate through the values on the local msft-dsa so that
    // we can avoid switching currencies back-and-forth between msft-dsa object and NC Heads
    DBOpen(&pDBDSAObj);

    __try
    {
        // Find the local msft-dsa object
        if (ulRet = DBFindDSName(pDBDSAObj, gAnchor.pDSADN))
        {
            DRA_EXCEPT(DRAERR_InternalError, ulRet);
        }

        if (DBHasValues(pDBDSAObj, ATT_HAS_PARTIAL_REPLICA_NCS))
        {
            ULONG i = 1;

            // the dsa has partial replicas - iterate through the NC names and check their
            // deletion lists
            while (!fRet && !DBGetAttVal(pDBDSAObj, i++, ATT_HAS_PARTIAL_REPLICA_NCS,
                                DBGETATTVAL_fREALLOC, bufSize, &len, (PBYTE *) ppNC))
            {
                bufSize = max(bufSize, len);

                if (ulRet = DBFindDSName(pTHS->pDB, *ppNC))
                {
                    DRA_EXCEPT(DRAERR_InternalError, ulRet);
                }

                // pTHS->pDB currency is on the NCHead
                if (!DBGetAttVal(pTHS->pDB, 1, ATT_PARTIAL_ATTRIBUTE_DELETION_LIST,
                            DBGETATTVAL_fREALLOC, 0, &len, (PBYTE *) ppGCDList))
                {
                    // found a partial replica NC with a non-empty deletion list
                    // *ppGCDList and *ppNC are already pointing to the correct stuff
                    // to be returned

                    VALIDATE_PARTIAL_ATTR_VECTOR_VERSION(&(*ppGCDList)->PartialAttrVecDel);

                    fRet = TRUE;
                }
            }
        }
    }
    __finally
    {
        DBClose(pDBDSAObj, fRet || !AbnormalTermination());
    }

    if (!fRet && (*ppNC))
    {
        // No partial replica NC with non-empty deletion list available
        THFreeEx(pTHS, *ppNC);
        *ppNC = NULL;
    }

    return fRet;
}

BOOL
GC_ReinitializeGCDListProcessed(
    BOOL fCompletedPrevious,     // [in]
    BOOL *pfMorePurging)         // [out]
/*************************************************************************************
Routine Description:

    This routine updates the in-memory global GCDListProcessed pointer with appropriate
    values so that the purge task can proceed. If the
    GDListProcessed pointer was pointing a valid NC/Deletion list pair, it removes the
    DeletionList from this previous NC which is already processed if fCompletedPrevious
    flag is set to TRUE.

Arguments:
    fCompletedCurrent - tells if the processing of the previous NC's deletion list is
                            completed.
    pfMorePurging - if non-NULL it would receive the a TRUE if there is a Deletion List
                            to process at the end of reinitialization;

Return Value:
    TRUE, if successfully updated;
    FALSE, if there was an error.
**************************************************************************************/
{
    DSNAME *pNC;
    GCDeletionList *pGCDList;
    BOOL fRet = FALSE;

    if (pfMorePurging)
        *pfMorePurging = FALSE; // assume no more purging by default

    EnterCriticalSection(&csGCDListProcessed);

    __try
    {
        if (!gpGCDListProcessed)
        {
            // this will be done only when the UpdateGCDListProcessed() is called for the
            // first time.
            gpGCDListProcessed = (GCDeletionListProcessed *) malloc(sizeof(GCDeletionListProcessed));
            if (!gpGCDListProcessed)
            {
                __leave; // memory allocation failed
            }

            gpGCDListProcessed->pNC = NULL;
            gpGCDListProcessed->pGCDList = NULL;
        }

        if (gpGCDListProcessed->pNC)
        {
            // cleanup the contents of old list and update the NCHead whose purging is
            // already completed
            if (fCompletedPrevious)
            {
                GC_WriteGCDeletionList(gpGCDListProcessed->pNC, NULL);
            }

            free(gpGCDListProcessed->pNC);
            gpGCDListProcessed->pNC = NULL;

            if (gpGCDListProcessed->pGCDList)
            {
                free(gpGCDListProcessed->pGCDList);
                gpGCDListProcessed->pGCDList = NULL;
            }

        }


        // reset the purgeCount & reload flag
        gpGCDListProcessed->purgeCount = 0;
        gpGCDListProcessed->fReload = FALSE;
        gpGCDListProcessed->fNCHeadPurged = FALSE;

        if (GC_GetGCDListToProcess(&pNC, &pGCDList))
        {
            // got a deletion list to process - returned values are in thread memory
            // make a permanent copy
            gpGCDListProcessed->pNC = (DSNAME *) malloc(DSNameSizeFromLen(pNC->NameLen));
            if (!gpGCDListProcessed->pNC)
            {
                __leave;   // memory allocation failed
            }

            memcpy(gpGCDListProcessed->pNC, pNC, DSNameSizeFromLen(pNC->NameLen));

            gpGCDListProcessed->pGCDList = (GCDeletionList *) malloc(GCDeletionListSize(pGCDList));
            if (!gpGCDListProcessed->pGCDList)
            {
                // memory allocation failed
                free(gpGCDListProcessed->pNC);
                gpGCDListProcessed->pNC = NULL;
                __leave;
            }

            memcpy(gpGCDListProcessed->pGCDList, pGCDList, GCDeletionListSize(pGCDList));

            if (pfMorePurging)
                *pfMorePurging = TRUE;

            // No need keep around the thread-allocated memory
            THFree(pNC);
            THFree(pGCDList);
        }

        fRet = TRUE;
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    return fRet;
}

BOOL
GC_UpdateLastUsnProcessedAndPurgeCount(
    USN     usnLastProcessed,       // [in]
    ULONG   cPurged)                // [in]
/*************************************************************************************
Routine Description:

    This routine usnLastProcessed marker & purgeCount on the global in-memory GCDListProcessed.
    It also updates the copy on the NC Head if MAX_PURGES_WITHOUT_UPDATING_NCHEAD
    limit is hit.

Arguments:
    usnLastProcessed - create usn of the object that was last processed
    cPurged - number of objects purged since the last time this function was called

Return Value:
    None.
**************************************************************************************/
{
    BOOL fRet = FALSE;

    EnterCriticalSection(&csGCDListProcessed);

    __try
    {
        if (cPurged > 0)
        {
            // NCHead is the first thing to get purged - and we have a
            // positive purge count
            gpGCDListProcessed->fNCHeadPurged = TRUE;
        }

        gpGCDListProcessed->purgeCount += cPurged;
        gpGCDListProcessed->pGCDList->usnLastProcessed = usnLastProcessed;

        if (!(gpGCDListProcessed->purgeCount % MAX_PURGES_WITHOUT_UPDATING_NCHEAD))
        {
            // time to update the copy on the NC Head
            GC_WriteGCDeletionList(gpGCDListProcessed->pNC, gpGCDListProcessed->pGCDList);
        }

        fRet = TRUE;
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    return fRet;
}

VOID
PurgePartialReplica(
    void * pv,                  // [in]
    void ** ppvNext,            // [out]
    DWORD * pcSecsUntilNextIteration ) // [out]
/*************************************************************************************
Routine Description:

    This routine is called by the taskq to purge attributes deleted from partial set.

Arguments:
    pv - parameter passed
    ppvNext - parameter to be passed for the next instance of this task
    pTimeNext - time when this function should be invoked again.

Return Value:
    None.
**************************************************************************************/
{
    THSTATE         *pTHS = pTHStls;
    USN             usnLast;
    USN             usnHighestToBeProcessed;
    DSNAME          *pNC = NULL;
    ULONG           cb;
    ULONG           cPurged = 0;
    ULONG           dntNC;
    ULONG           retErr = 0;
    BOOL            fDone = FALSE;
    BOOL            fReload = FALSE;
    BOOL            fMorePurging = FALSE;
    BOOL            fNCHeadPurged;
    PARTIAL_ATTR_VECTOR *pvecDel = NULL;
    ULONG i;
    BOOL            fDRASave;

    Assert(ppvNext);
    Assert(pcSecsUntilNextIteration);

    *ppvNext = NULL;

    // Check to see if the in-memory struct has anything to purge
    EnterCriticalSection(&csGCDListProcessed);
    __try
    {
        BeginDraTransaction(SYNC_WRITE);
        __try
        {
            if (!gpGCDListProcessed              // gloabl-struct not built yet
                || !gpGCDListProcessed->pNC      // no pending stuff to process, should confirm w/ NCHeads
                || gpGCDListProcessed->fReload)  // currently processed deletion list has changed and we are asked to reload
            {
                // in-memory deletion list is empty or someone explicitly asked us to reload
                if (!GC_ReinitializeGCDListProcessed(FALSE, NULL))
                {
                    // unable to reinitialize
                    DRA_EXCEPT(DRAERR_InternalError, 0);
                }
            }

            if (gpGCDListProcessed->pNC)
            {
                // have purging to do
                fNCHeadPurged = gpGCDListProcessed->fNCHeadPurged;
                usnLast = gpGCDListProcessed->pGCDList->usnLastProcessed;  
                cb = PartialAttrVecV1SizeFromLen(gpGCDListProcessed->pGCDList->PartialAttrVecDel.V1.cAttrs);
                pvecDel = (PARTIAL_ATTR_VECTOR *) THAllocEx(pTHS, cb);
                memcpy(pvecDel, &gpGCDListProcessed->pGCDList->PartialAttrVecDel, cb);

                // Make a copy of the pNC from the gloabl deletion list
                cb = DSNameSizeFromLen(gpGCDListProcessed->pNC->NameLen);
                pNC = (DSNAME *) THAllocEx(pTHS, cb);
                memcpy(pNC, gpGCDListProcessed->pNC, cb);
            }

        }
        __finally
        {
            EndDraTransaction(!AbnormalTermination());
        }
    }
    __finally
    {
        LeaveCriticalSection(&csGCDListProcessed);
    }

    if (!pvecDel || !pNC)
    {
        // nothing to process now - recheck later (this should be the case 99% of the times)
        // by default set timer for next check
        *pcSecsUntilNextIteration = PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS;

        return;
    }

    // If we are here we have things to purge - begin a transaction
    // set ourselves to be the repl thread (to bypass security)
    fDRASave = pTHS->fDRA;
    pTHS->fDRA = TRUE;
    BeginDraTransaction(SYNC_WRITE);
    __try
    {
        // set currency on the NC Head
        if (retErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                            NULL)) {
            DRA_EXCEPT_NOLOG(DRAERR_BadDN, retErr);
        }

        // Save the DNT of the NC Head
        dntNC = pTHS->pDB->DNT;

        // reset retErr so that we know if we should commit or rollback during the iteration
        retErr = 0;

        // iterate through and start purging
        while ((cPurged < MAX_PURGES_PER_TASK_SESSION) && !fDone)
        {
            // don't hold transaction for long - do a lazy commit (NCHead holds a reasonably
            // recent status on usnLastProcessed, so even if the system crashes before the
            // lazy commit gets to flush things out to the disk we will restart iterations
            // reasonably closer to where we left it)
            DBTransOut(pTHS->pDB, TRUE, TRUE);
            DBTransIn(pTHS->pDB);

            if (!fNCHeadPurged)
            {
                // NC Head is not purged yet, NCDNT of the NCHead
                // will have the DNT of its parents NC's NCHead (if instantiated).
                // => we won't find it in the indexed search below, so process it
                // as a special case
                if (retErr = DBFindDNT(pTHS->pDB, dntNC))
                {
                    DRA_EXCEPT(DRAERR_DBError, retErr);
                }

                // GC_UpdateLastUsnProcessedAndPurgeCount() will take care of
                // setting fNCHeadPurged to TRUE in the global struct for future
                // task sessions. Set the local BOOL to take care of iterations
                // in this task session.
                fNCHeadPurged = TRUE;
            }
            else if (GetNextObjByUsn(pTHS->pDB, dntNC, usnLast + 1,
				     NULL))
            {
                // no more objects - done purging this NC
                fDone = TRUE;
            }
            else
            {
		SYNTAX_INTEGER it;
		// got to the object through indexed search
                // get it's usnChanged for using in the next iteration.
                if (retErr = DBGetSingleValue(pTHS->pDB, ATT_USN_CHANGED, &usnLast,
                    sizeof(usnLast), NULL))
                {
                    DRA_EXCEPT(DRAERR_DBError, retErr);
                }
		// If this is the head of a subordinate NC, skip it. 
		GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it,
				  sizeof(it));
		if (it & IT_NC_HEAD) {
		    // Is the head of a subordinate NC -- move on to the
		    // next object.
		    continue;
                }
            }

            if (!fDone)
            {  
                // positioned on the object to be purged
                // Loop through all attrs to be removed and remove them from the object
                // Set thread state appropriately so that DBTouchMetaData() will remove
                // the meta data for this cleanup
                pTHS->fGCLocalCleanup = TRUE;

                for (i = 0; i < pvecDel->V1.cAttrs; i++)
                {
                    retErr = DBRemAtt(pTHS->pDB, pvecDel->V1.rgPartialAttr[i]);  
                    if (retErr) {
                        if (retErr == DB_ERR_ATTRIBUTE_DOESNT_EXIST) {
                            retErr = DB_success;
                        }
                        else {
                            DRA_EXCEPT(DRAERR_DBError, retErr);
                        }
		    }
		}

                DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);

                pTHS->fGCLocalCleanup = FALSE;

                cPurged++;

                // Check to see if the last modification should be committed or rolledback
                EnterCriticalSection(&csGCDListProcessed);
                if (gpGCDListProcessed->fReload)
                {
                    // the in-memory deletion list has been updated while we were
                    // purging the object in this iteration - shouldn't rollback the last purging
                    fReload = TRUE;
                }
                LeaveCriticalSection(&csGCDListProcessed);

                if (fReload)
                {
                    // go to the finally block and rollback the last purge & reschedule immediately
                    fMorePurging = TRUE;
                    __leave;
                }

            }

        } // while()

        if (!fDone)
        {
            // more purging to be done
            // write back the usn marker and purge count
            if (!GC_UpdateLastUsnProcessedAndPurgeCount(usnLast, cPurged))
            {
                // unable to update - raise exception
                retErr = DB_ERR_DATABASE_ERROR;
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }

            // schedule ourselves to run as soon as possible; this would give taskQ a
            // chance to run other tasks that are overdue. Be a good taskQ citizen!
            fMorePurging = TRUE;
        }
        else
        {
            // we are done purging this NC
            if (!GC_ReinitializeGCDListProcessed(TRUE, &fMorePurging))
            {
                // unable to re-initialize - except
                retErr = DB_ERR_DATABASE_ERROR;
                DRA_EXCEPT(DRAERR_InternalError, retErr);
            }
        }
    }
    __finally
    {
        // commit if there are no errors and no reloads
        EndDraTransaction(!(retErr || fReload || AbnormalTermination()));
        pTHS->fDRA = fDRASave;

        // if more purging to be done schedule ourselves immediately
        // otherwise, schedule for the next purge check interval

        *pcSecsUntilNextIteration = fMorePurging
                                    ? 0
                                    : PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS;
    }
}



PARTIAL_ATTR_VECTOR     *
GC_RemoveOverlappedAttrs(
    PARTIAL_ATTR_VECTOR     *pAttrVec1,              // [in, out]
    PARTIAL_ATTR_VECTOR     *pAttrVec2,              // [in]
    BOOL                    *pfRemovedOverlaps)      // [out]
/*************************************************************************************
Routine Description:

    This routine removes any attribute in pAttrVec2 from the given pAttrVec1.

Note:
    Similar to string processing convention-- remove all items in param1 that exist
    in param2, return result & a flag if changes occured.

Arguments:
    pAttrVec1 - points to vector that should be updated
    pAttrVec2 - points to vector containing attrs we want to remove from the deletion
                list.
    pfRemovedOverlaps - pointer to a BOOL that would receive TRUE if there was really
                a overlap and at least one attr was removed from the deletion list

Return Value:
    pointer to the updated vector, or NULL if all attrs are removed from the vector
**************************************************************************************/
{
    ULONG i;
    ULONG iLocated;
    ATTRTYP *pAttr;

    *pfRemovedOverlaps = FALSE;     // assume no removal by default

    for (i = 0;
         0 != pAttrVec1->V1.cAttrs &&           // while there's still attrs in the dest vector
         i < pAttrVec2->V1.cAttrs;              // & we haven't consumed all attrs in the list of removables
         i++)
    {
        if (GC_IsMemberOfPartialSet(pAttrVec1, pAttrVec2->V1.rgPartialAttr[i], &iLocated))
        {
            if (iLocated != (pAttrVec1->V1.cAttrs - 1))
            {
                // element to be removed is not the last one
                // - left shift all attrs to the right of iLocated by 1 position
                pAttr = &(pAttrVec1->V1.rgPartialAttr[iLocated]);

                MoveMemory(pAttr, pAttr + 1,
                    sizeof(ATTRTYP) * ((pAttrVec1->V1.cAttrs - 1) - iLocated));
            }

            pAttrVec1->V1.cAttrs--;

            *pfRemovedOverlaps = TRUE;
        }
    }

    return (pAttrVec1->V1.cAttrs ? pAttrVec1 : NULL);
}


GCDeletionList *
GC_AddMoreAttrs(
    GCDeletionList           *pGCDList,             // [in]
    PARTIAL_ATTR_VECTOR     *pAttrVec)              // [in]
/*************************************************************************************
Routine Description:

    This routine adds the attrs in the given vector to the deletion list, and returns
    pointer to the new deletion list
    Memory for the new deletion list is allocated from thread-memory, and THFree()
    should be used to free it, or it will automatically be deleted when thread heap
    is freed.

Arguments:
    pGCDList - points to DeletionList that should be updated
    pAttrVec - points to vector containing attrs we want to add.

Return Value:
    pointer to the new deletion list, or NULL if couldn't allocate memory
**************************************************************************************/
{
    ULONG           cbNew;
    GCDeletionList  *pGCDListNew = NULL;
    ULONG           i;
    ULONG           cAttrs;

    // Sanity assert If there is no vector of attrs to add, we shouldn't have
    // been inside this function at all.
    Assert(pAttrVec);

    // Calculate the total possible attrs in the new deletion list
    cAttrs = pAttrVec->V1.cAttrs;
    if (pGCDList)
    {
        cAttrs += pGCDList->PartialAttrVecDel.V1.cAttrs;
    }

    cbNew = GCDeletionListSizeFromLen(cAttrs);

    pGCDListNew = (GCDeletionList *) THAlloc(cbNew);

    if (pGCDListNew)
    {
        if (pGCDList)
        {
            // copy the existing deletion list first
            memcpy(pGCDListNew, pGCDList, GCDeletionListSize(pGCDList));
        }
        else
        {
            // there is no existing deletion list - start with zero attrs in the new deletion list
            pGCDListNew->PartialAttrVecDel.dwVersion = VERSION_V1;
            pGCDListNew->PartialAttrVecDel.V1.cAttrs = 0;
        }

        for (i = 0; i < pAttrVec->V1.cAttrs; i++)
        {
            GC_AddAttributeToPartialSet(&pGCDListNew->PartialAttrVecDel, pAttrVec->V1.rgPartialAttr[i]);
        }

        // we have added new attrs to the deletion list - so purging process should restart from
        // scratch - update the usnLastProcessed also
        pGCDListNew->usnLastProcessed = USN_START - 1;
    }

    return pGCDListNew;
}


PARTIAL_ATTR_VECTOR*
GC_ExtendPartialAttributeSet(
    THSTATE                     *pTHS,                       // [in]
    PARTIAL_ATTR_VECTOR         *poldPAS,                    // [in, out]
    PARTIAL_ATTR_VECTOR         *paddedPAS )                 // [in]
/*++

Routine Description:

    Extends poldPAS to contain attributes in paddedPAS & return it.


Arguments:
    poldPAS -- old PAS to extend
    paddedPAS -- added attributes

Return Value:

    Success: new PAS ptr
    Error: NULL

Remarks:
None.


--*/

{
    SIZE_T cbNew;
    PARTIAL_ATTR_VECTOR         *pnewPAS;
    UINT                         i;

    // must either have old, or new
    if (poldPAS && (!paddedPAS || 0 == paddedPAS->V1.cAttrs) ) {
        // Only poldPAS--> return old
        return poldPAS;
    } else if ( !poldPAS && (paddedPAS && 0 != paddedPAS->V1.cAttrs) ) {
        // only new PAS--> return added
        return paddedPAS;
    } else if ( !poldPAS && (!paddedPAS || (paddedPAS &&  0 == paddedPAS->V1.cAttrs)) ){
        Assert(poldPAS || (paddedPAS && paddedPAS->V1.cAttrs) );
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    //
    // re-alloc & extend
    //

    cbNew = PartialAttrVecV1SizeFromLen(poldPAS->V1.cAttrs +
                                        paddedPAS->V1.cAttrs);
    pnewPAS = (PARTIAL_ATTR_VECTOR*)THReAllocEx(
                                        pTHS,
                                        (PVOID)poldPAS,
                                        (ULONG)cbNew);
    if (!pnewPAS) {
        DRA_EXCEPT(DRAERR_OutOfMem, 0);
    }

    // add in sorted order.
    for (i=0; i<paddedPAS->V1.cAttrs; i++) {
        GC_AddAttributeToPartialSet(pnewPAS, paddedPAS->V1.rgPartialAttr[i]);
    }

    return pnewPAS;
}



PARTIAL_ATTR_VECTOR*
GC_CombinePartialAttributeSet(
    THSTATE                     *pTHS,                     // [in]
    PARTIAL_ATTR_VECTOR         *pPAS1,                    // [in]
    PARTIAL_ATTR_VECTOR         *pPAS2 )                   // [in]
/*++

Routine Description:

    allocates mem & return pPAS1+pPAS2

Arguments:
    pPAS1 -- partial attribute set 1
    pPAS2 -- partial attribute set 2

Return Value:

    combined partial attribute set
    NULL if both are empty




Remarks:
None.


--*/
{

    PARTIAL_ATTR_VECTOR     *pPAS;
    DWORD                   cbPAS;
    UINT                    i;

    if (!pPAS1 && !pPAS2) {
        // we know of no condition that can have both NULL
        Assert(pPAS1 || pPAS2);
        return NULL;
    }
    else if (!pPAS1) {
        // return a copy of pas2
        cbPAS = PartialAttrVecV1Size(pPAS2);
        pPAS = THAllocEx(pTHS, cbPAS);
        CopyMemory(pPAS, pPAS2, cbPAS);
    }
    else if (!pPAS2) {
        // return a copy of pas1
        cbPAS = PartialAttrVecV1Size(pPAS1);
        pPAS = THAllocEx(pTHS, cbPAS);
        CopyMemory(pPAS, pPAS1, cbPAS);
    }
    else {
        // combine both & return a copy of the sum.
         cbPAS = PartialAttrVecV1SizeFromLen(pPAS1->V1.cAttrs + pPAS2->V1.cAttrs);
         pPAS = THAllocEx(pTHS, cbPAS);
         // copy first
         CopyMemory(pPAS, pPAS1, PartialAttrVecV1Size(pPAS1));
         Assert(pPAS->V1.cAttrs == pPAS1->V1.cAttrs);
         // append second in sorted order.
         for (i=0; i<pPAS2->V1.cAttrs; i++) {
             GC_AddAttributeToPartialSet(pPAS, pPAS2->V1.rgPartialAttr[i]);
         }
    }
    return pPAS;
}





VOID
GC_ProcessPartialAttributeSetChanges(
    THSTATE     *pTHS,               // [in]
    DSNAME*      pNC,                // [in]
    UUID*        pActiveSource       // [optional, in]
    )
/*************************************************************************************
Routine Description:

    This routine processes all partial attribute set changes - compares the copy in
    the NC Head with one on the schema cache, triggers necessary actions, and updates
    the NC Head copy.

    Assume we enter the function with a WRITE transaction.

    If there is failure, we raise exception which is expected to be handled by the
    caller. In the replication sync case, the exception will be handled by the
    try/except block in ReplicaSync() and replication will be failed. This is the
    correct course of action as we can't allow replication to proceed without
    processing the partial attribute set changes successfully.

Arguments:
    pTHS - current thread state
    pNC - points to the DSName of the NCHead that needs to be processed for partial
                set changes.
    pActiveSource - Replication engine is initiating a cycle from this one at the moement.

Return Value:
    None.
**************************************************************************************/
{

    PARTIAL_ATTR_VECTOR     *pPartialAttrVecNew;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecOld = NULL;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecAdded;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecDeleted;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecCommit;
    PARTIAL_ATTR_VECTOR     *pPartialAttrVecTmp;
    GCDeletionList          *pGCDListOld;
    GCDeletionList          *pGCDListNew;
    ULONG                   cb;
    BOOL                    fRemovedOverlaps = FALSE;
    BOOL                    fAddedMore = FALSE;
    ULONG                   retErr = DRAERR_DBError;


    //
    // Get old partial attribute set from NC head.
    //  - Note that w/out it, there's nothing we can do.
    //

    if (!GC_ReadPartialAttributeSet(pNC, &pPartialAttrVecOld))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    // is it realy there?
    if ( !pPartialAttrVecOld ) {
        //
        // This NC has just been added now & there is no partialAttrVec on
        // it. Thus, there's nothing to compare for PAS changes. Let
        // DRA_ReplicaAdd finish initial sync first.
        //
        DPRINT1(0, "GC_ProcessPartialAttributeSetChanges: No PAS on partition %ws\n",
                   pNC->StringName);
        return;
    }

    //
    // Ok, it's there, see if there's a discrepancy w/ the schema cache--
    // if so, process changes.
    //
    pPartialAttrVecNew = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->pPartialAttrVec;

    if (GC_IsSamePartialSet(pPartialAttrVecOld, pPartialAttrVecNew))
    {
        // - No changes to process
        return;
    }

    // The partial set has changed - get the difference
    if (!GC_GetDiffOfPartialSets(pPartialAttrVecOld,
                                 pPartialAttrVecNew,
                                 &pPartialAttrVecAdded,
                                 &pPartialAttrVecDeleted))
    {
        // Unable to get the diff - something is wrong
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }


    // First see if we have a deletion list on the NCHead
    if (!GC_ReadGCDeletionList(pNC, &pGCDListOld))
    {
        // unable to read deletion list - error
        DRA_EXCEPT(DRAERR_DBError, 0);
    }

    if (!pGCDListOld && pPartialAttrVecDeleted)
    {
        // some attributes have been deleted from the partial attribute set
        // - create a deletion list & put it on the NCHead
        cb = GCDeletionListSizeFromLen(pPartialAttrVecDeleted->V1.cAttrs);
        pGCDListNew = (GCDeletionList *) THAllocEx(pTHS, cb);
        pGCDListNew->usnLastProcessed = USN_START - 1; // start purging from scratch

        memcpy(&pGCDListNew->PartialAttrVecDel,
                pPartialAttrVecDeleted,
                PartialAttrVecV1Size(pPartialAttrVecDeleted));

        GC_WriteGCDeletionList(pNC, pGCDListNew);
    }
    else
    {
        // start with the assumption that the new DeletionList is same as the old DeletionList
        pGCDListNew = pGCDListOld;

        // there is an existing deletion list on the NCHead
        // - we might have to update that deletion list
        if (pPartialAttrVecAdded && pGCDListNew)
        {
            // new attributes have been added - first remove if they appear in the deletion list
            pPartialAttrVecTmp = GC_RemoveOverlappedAttrs(&(pGCDListNew->PartialAttrVecDel), pPartialAttrVecAdded, &fRemovedOverlaps);
            if ( !pPartialAttrVecTmp )
            {
                // nothing's left in deletion list. Null it out.
                pGCDListNew = NULL;
            }
        }

        if (pPartialAttrVecDeleted)
        {
            // some attributes have been deleted
            pGCDListNew = GC_AddMoreAttrs(pGCDListNew, pPartialAttrVecDeleted);

            if (!pGCDListNew)
            {
                // running out of memory - can't finish operation
                DRA_EXCEPT(DRAERR_OutOfMem, 0);
            }

            fAddedMore = TRUE;
        }

        // if deletion list changed write it back on the NCHead
        if (fRemovedOverlaps || fAddedMore)
        {
            EnterCriticalSection(&csGCDListProcessed);
            __try
            {
                GC_WriteGCDeletionList(pNC, pGCDListNew);

                if (   (NULL != gpGCDListProcessed)
                    && (NULL != gpGCDListProcessed->pNC)
                    && NameMatched(pNC, gpGCDListProcessed->pNC))
                {
                    // This NC is being currently purged and we have changed deletion list,
                    // mark the in-memory struct for reload & repurging of NCHead.
                    gpGCDListProcessed->fReload = TRUE;
                    gpGCDListProcessed->fNCHeadPurged = FALSE;
                }

                // GCDeletion List is successful
                retErr = DRAERR_Success;
            }
            __finally
            {
                DBTransOut(pTHS->pDB, !retErr, TRUE);
                LeaveCriticalSection(&csGCDListProcessed);

                DBTransIn(pTHS->pDB);

                if (retErr != DRAERR_Success)
                {
                    // Hit an exception in the above __try block,
                    // Pass on the exception up to the caller
                    DRA_EXCEPT(retErr, 0);
                }
            }

        }
    }

    //
    // Action:
    //  - write old_PAS minus deleted_PAS
    //  - process added_PAS:
    //     if DRS_SYNC_PAS --> backfill else trigger sync all.
    //
    if ( pPartialAttrVecDeleted )
    {
        // the list to commit now is old_PAS minus deleted_PAS
        pPartialAttrVecCommit = GC_RemoveOverlappedAttrs(pPartialAttrVecOld, pPartialAttrVecDeleted, &fRemovedOverlaps);
        // Write the new partial attr vec on the NCHead
        GC_WritePartialAttributeSet(pNC, pPartialAttrVecCommit);
    }


    // new attributes have been added to partial attribute set
    // Assess & launch PAS replication cycle.
    if (pPartialAttrVecAdded)
    {
        // process & setup for PAS cycle.
        GC_LaunchSyncPAS(
            pTHS,
            pNC,
            pActiveSource,
            pPartialAttrVecAdded);
    }


    // Commit everything upto this point
    DBTransOut(pTHS->pDB, TRUE, FALSE);
    DBTransIn(pTHS->pDB);
}





//
// Efficient PAS replication (see design doc GcPASRepl-New.doc) (PAS-- Partial Attribute Set)
//


void
GC_LaunchSyncPAS (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    UUID*                   pActiveSource,       // [optional, in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS)
/*++

Routine Description:

    This routine is the entry point for testing & launching PAS replication.
    Steps:
        - Process RepsFrom to potentially find & continue an interrupted PAS cycle.
        - If this is a new PAS cycle or an interrupted cycle that indicates a need for
          a fail over to a new source, get & switch to the preferred source.
          Also, in case of failure, test for no compatible sources for launching
          of Win2K procedure.
        - Prepare args & launch DirReplicaSynchronize to queue a PAS pao.

Arguments:
    pTHS -- active Thread state
    pNC -- the active NC we're working on.
    pActiveSource -- if given, replication engine is currently is initiating replication
                     from this source. Thus we don't need to enqueue repl item if PAS cycle
                     is needed.
    pAddedPAS -- the set of attrs, extending the old PAS



Return Value:
    raises exception on invalid state.

Remarks:
    None.


--*/
{

    UUID currUuidDsa;
    UUID *pCurrentDsa = NULL;           // current DSA
    UUID *pPrefDsa = NULL;              // preferred DSA
    ULONG ulErr = DRAERR_Success;
    BOOL fNewSource;                    // identify need for getting a new source
    BOOL fResetUsn = FALSE;             // reset usn upon registration of new active

    // Assert: We must have a valid added PAS vector.
    Assert(pAddedPAS && pAddedPAS->V1.cAttrs);

    DPRINT2(1,"GC_LaunchSyncPAS: setting PAS replication in %ws for %d attributes\n",
              pNC->StringName, pAddedPAS->V1.cAttrs);

    // Read & set global threshold variables (see comment in function header)
    // It's done here in order to minimize consecutive calls into the registry.
    GC_ReadRegistryThresholds();

    //
    // Find current PAS source
    // (by looking at PAS flags on repsfrom)
    //
    currUuidDsa = gNullUuid;
    ulErr = GC_FindValidPASSource(pTHS, pNC, &currUuidDsa);

    if ( DRAERR_BadNC == ulErr ) {
        //
        // This NC has just got added ==> let DRA_ReplicaAdd finish it's
        // operation, there's nothing to process at the moment.
        //
        // Assert: when do we reach this?
        DPRINT1(0, "GC_LaunchSyncPAS: Attempt to launch PAS replication on an bad NC %ws\n",
                pNC->StringName);
        Assert(!"Bad NC in GC_LaunchSyncPAS");
        // but it is recoverable
        return;
    }

    // set convinience ptr
    pCurrentDsa = fNullUuid(&currUuidDsa) ? NULL : &currUuidDsa;


    if ( DRAERR_Success != ulErr ) {
        //
        // Either we had found an interrupted one (re-start again)
        // Or no valid PAS source at all
        // -- try to find a new preferred source.
        // -- If none, revert to win2k full sync.
        //

        // get preferred source
        ulErr = GC_GetPreferredSource(pTHS, pNC, &pPrefDsa );

        if ( ulErr == DRAERR_Success ) {
            //
            // Found new preferred source
            //  - reset usn so as to start traversing objects
            //    on the source from time 0. Note-- this is
            //    the only time we reset usn. For restartable cases
            //    we'll continue from wherever we left.
            //
            fResetUsn = TRUE;
        }
        else if ( ulErr == DRAERR_NoReplica && pCurrentDsa ) {
            //
            // couldn't find better then previously set one--
            // try it again (restart state, no reset of usn).
            //
            pPrefDsa = pCurrentDsa;
        }
        else if ( ulErr ==  ERROR_REVISION_MISMATCH ) {
            //
            // Best one we have is win2k--
            //   do win2k full sync
            //

            GC_TriggerFullSync(pTHS, pNC, pAddedPAS);
            return;
        }
        else {
            //
            // No sources at all (& no previously set one).
            // Try again later, abort now.
            // Note that this could be due to all being stale (bad net connectivity
            // for instance), so we should just retry later.
            //

            // Log debug event
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_GC_NO_SOURCES,
                     szInsertDN(pNC),
                     szInsertInt(ulErr),
                     szInsertWin32Msg(ulErr) );

            return;
        }

        //
        // Got new (or re-new'ed) source to use.
        //
        // clean prev (most likely failing) PAS entries & (re)register this one.
        Assert(pPrefDsa);
        (void)GC_RegisterPAS(
                pTHS,
                pNC,
                NULL,
                NULL,
                PAS_RESET,
                FALSE);
        ulErr = GC_RegisterPAS(
                    pTHS,
                    pNC,
                    pPrefDsa,
                    pAddedPAS,
                    PAS_ACTIVE,
                    fResetUsn);
        if ( ulErr ) {
            DRA_EXCEPT(ulErr, 0);
        }
    }
    else {
        //
        // We have a previously good  PAS partner to continue
        //
        pPrefDsa = pCurrentDsa;
    }

    // The previous design called for us to enqueue a sync here of pPrefDsa if it was
    // different from pActiveSource. This is not done for two reasons.
    // 1. It generates too many syncs. During the time that the PAS needs rebuilding,
    // we execute this code every time we sync a source. Further, if a source sync is
    // requeued for whatever reason, we execute this code as well.
    // 2. Rapid syncing of a mail based replica without giving time for the reply can
    // cause the mail replica to register consecutive failures.
    // 3. During a sync of source 1, queuing a sync of another source can lead to a preemption
    // loop. Consider if source 1 is being synced, and source 2 is the pas source and has a
    // higher priority. Syncing 1 causes 2 to be enqueued at a higher priority, the sync of
    // 1 is preempted, 2 runs, 1 runs, causes 2 to be enqueued, 1 runs, 1 is preempted, 2
    // runs, etc.
    //
    // The downside is that we must wait for the pas source to be synced by either schedule
    // or notification in order to trigger the pas process.

    // Assert: no failure code paths exist at this point
    Assert(DRAERR_Success == ulErr);
}


ULONG
GC_FindValidPASSource(
    THSTATE*     pTHS,                // [in]
    DSNAME*      pNC,                 // [in]
    UUID*        pUuidDsa             // [optional, out]
    )
/*++

Routine Description:

    Finds a PAS DSA in RepsFrom's sources list.

Arguments:

    pNC: active NC we're working on
    pUuidDsa: the dsa's uuid we had found.

Return Value:

    DRAERR_RefNotFound:
        if dsa wasn't found. *pUuidDsa is set to gNullUuid;

    DRAERR_InternalError:
        if link isn't in consistent state. pUuidDsa is set.

    DRAERR_Success:
        valid entry was found & placed in *pUuidDsa (if avail)


Remarks:

    May raise exception with error in DRAERR error space.

--*/
{

    DWORD           iTag=0;
    UCHAR           *pVal = NULL;
    ULONG           bufsize = 0, len;
    REPLICA_LINK *  pRepsFromRef = NULL;
    BOOL            fFoundSource = FALSE;
    ULONG           ulErr;                  // all paths asign value.

    // sanity on PAS storage consistency (DBG only)
    DBG_VALIDATE_PAS_LINKS(pNC);


    // position on NC
    if (ulErr = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                       NULL)) {
        DPRINT1(0, "GC_FindValidPASSource: FindNC returned %d\n", ulErr);
        return (ulErr);
    }

    //
    // Find PAS entry in RepsFrom
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);

        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        // note: we preserve pVal for DBGetAttVal realloc above.
        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);


        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS)
        {
            // Got it.
            fFoundSource = TRUE;
            break;
        }
    }

    if (fFoundSource) {
        //
        // See if the source is valid & prepare return values
        //

        // we have a source, return it.

        if ( pUuidDsa ) {
            CopyMemory(pUuidDsa, &pRepsFromRef->V1.uuidDsaObj, sizeof(UUID));;
        }

        // is it in valid state?
        ulErr = GC_ValidatePASLink(pRepsFromRef) ?
                    DRAERR_Success :
                    DRAERR_InternalError;

        // Log debug event
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_EXTENSIVE,
                 ulErr ?
                    DIRLOG_GC_FOUND_INVALID_PAS_SOURCE :
                    DIRLOG_GC_FOUND_PAS_SOURCE,
                 szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                 szInsertDN(pNC),
                 NULL );
    }
    else {
        // set return to not found
        if ( pUuidDsa ) {
            *pUuidDsa = gNullUuid;
        }
        ulErr = DRAERR_RefNotFound;

        // Log debug event
        LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_GC_PAS_SOURCE_NOT_FOUND,
                 szInsertDN(pNC),
                 NULL,
                 NULL );
    }

    THFreeEx(pTHS, pVal);

    return ulErr;
}


BOOL
GC_ValidatePASLink(
    REPLICA_LINK *  pPASLink          // [in]
    )
/*++

Routine Description :

    Tests the validity of a given replica link for PAS replication

Arguments:

    pPASLink: The link to validate


Return Value:

    TRUE: this link is good
    FALSE: it isn't, will require to revert to another source.



Remarks:
    Note that this function assumes that the link evaluated is in PAS state!
    Why? cause we're testing PAS flags, consecutive failures for PAS repl, and
    time lapse since last success which for non-PAS replication can be very
    different.



--*/
{
    PPAS_DATA pPasData;
    //
    // Consistency validity
    //
    //

    if (!pPASLink->V1.cbPASDataOffset) {
        // must point to valid PAS data
        return FALSE;
    }
    pPasData = RL_PPAS_DATA(pPASLink);
    Assert(pPasData->size);

    if ( !PAS_IS_VALID(pPasData->flag) ) {
        DPRINT1(1, "GC_ValidatePASLink: Invalid PASData flag 0x%x\n",
                pPasData->flag);
        Assert(FALSE);
        return FALSE;
    }

    // see if the link is stale
    if ( GC_StaleLink(pPASLink) ) {
        return FALSE;
    }
    else {
        return TRUE;
    }

}

VOID
GC_DbgValidatePASLinks(
    DSNAME*      pNC                  // [in]
    )
/*++

Routine Description:

    Cycles thru RepsFrom & does sanity on PAS consistency:
    1. Only a single PAS entry
    2. entry contains a valid flag

Arguments:

    NC: active NC


Return Value:
    Success: DRAERR_Success
    Error: DRAERR_InternalError if anything went wrong.

Remarks:
    - Should be called in DBG only builds.
    - Defined only local to this file.


--*/
{
    THSTATE         *pTHS = pTHStls;
    DWORD           iTag=0;
    UCHAR           *pVal = NULL;
    ULONG           bufsize = 0, len=0;
    REPLICA_LINK *  pRepsFromRef = NULL;
    INT             iPASSources=0;
    ULONG           ulRet = DRAERR_Success;
    PPAS_DATA       pPasData = NULL;


    // position on NC
    if (ulRet = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                       NULL)) {
        DPRINT1(0, "GC_DbgValidatePASLinks: FindNC returned %d\n", ulRet);
        return;
    }

    //
    // Find PAS entry in RepsFrom
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);

        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        // Note: the following assertion isn't necessarily true post FixupRepsFrom.
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );
        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        Assert(bufsize >= pRepsFromRef->V1.cb);

        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS)
        {
            // got one.
            iPASSources++;

            //
            // Consistency Asserts
            //

            // We should have PAS data
            Assert(pRepsFromRef->V1.cbPASDataOffset);
            // PAS data should always have a valid size, & contains some attrs.
            pPasData = RL_PPAS_DATA(pRepsFromRef);
            Assert(pPasData->size);
            Assert(pPasData->PAS.V1.cAttrs != 0);
            Assert(PAS_IS_VALID(pPasData->flag));

        }
    }


    if ( iPASSources > 1) {
        DPRINT2(0, "DRA PAS Inconsistency: %d PAS entries in repsFrom in NC %S\n",
                iPASSources, pNC->StringName);
        // this will break
        Assert(iPASSources==0 || iPASSources==1);
    }
    THFreeEx(pTHS, pVal);
}



VOID
GC_TriggerFullSync (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS)
/*++

Routine Description:

    Similarly to Win2k full sync setup, we'll reset water marks to initiate
    a full sync

Arguments:
    pNC -- the active NC we're working on.
    pAddedPAS -- the set of attrs, extending the old PAS

Return Value:
    Success:  DRAERR_Success.
    Error: Error value in DRAERR error space.

Remarks:
    None.


--*/
{
    PARTIAL_ATTR_VECTOR     *poldPAS;
    PARTIAL_ATTR_VECTOR     *pnewPAS;
    ULONG                    ulErr = ERROR_SUCCESS;

    //
    // Procedure:
    // a) Reset watermarks
    // b) get PAS from NC head, add to it addedPAS, write to NC head
    //

    DPRINT1(1,"GC_TriggerFullSync: Scratching watermarks for %ws\n",
            pNC->StringName);

    GC_TriggerSyncFromScratchOnAllLinks(pNC);

    if (!GC_ReadPartialAttributeSet(pNC, &poldPAS))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT(DRAERR_DBError, 0);
    }
    pnewPAS = GC_ExtendPartialAttributeSet(pTHS, poldPAS, pAddedPAS);
    GC_WritePartialAttributeSet(pNC, pnewPAS);

    //
    // reset PAS flag, there's no PAS cycle anywhere anymore.
    //
    ulErr = GC_RegisterPAS(pTHS, pNC, NULL, NULL, PAS_RESET, FALSE);
    if ( ulErr ) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    // Log so the admin knows what's going on.
    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_GC_TRIGGER_FULL_SYNC,
             szInsertDN(pNC),
             NULL, NULL
             );

#if DBG
    //
    // Consistency sanity.
    // this must happen in order not to trigger yet another PAS cycle.
    // When called from Replica_Add for instance pnewPAS can be NULL, thus
    // the check.
    //
    if (GC_ReadPartialAttributeSet(pNC, &pnewPAS) &&
        pnewPAS &&
        !GC_IsSamePartialSet(pnewPAS, ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->pPartialAttrVec)){
        Assert(FALSE);
    }
#endif
}


int __cdecl
compareDsaCriteria(
    const void * Arg2,  // reversed for decreasing sort
    const void * Arg1
    )

/*++

Routine Description:

    Comparison function for sorting DSACRITERIA functions

    The qsort MSDN page says:
The array is sorted in increasing order, as defined by the comparison function. To sort an array in decreasing order, reverse the sense of greater than and less than in the comparison function.

    Since we want the sort in decreasing order, we reverse the order of the arguments.
Arguments:

    Arg2, Arg1 - entries to be compared

Return Value:

    <0, =0, >0 for sort order

--*/

{
    int state;

    DSACRITERIA *pDsa1 = (DSACRITERIA *) Arg1;
    DSACRITERIA *pDsa2 = (DSACRITERIA *) Arg2;

    // Sort by weight first
    state = ((int) pDsa1->dwWeight) - ((int) pDsa2->dwWeight) ;
    if (state) {
        return state;
    }

    // Sort by source guid second as tiebreaker
    state = memcmp(&pDsa1->uuidDsa, &pDsa2->uuidDsa, sizeof(GUID));
    if (state) {
        return state;
    }

    Assert( !"Shouldn't be any duplicates in this list" );

    return 0;
}


ULONG
GC_GetPreferredSource(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    UUID        **ppPrefUuid         // [ptr in, out]
    )
/*++

Routine Description:

    Finds the best suitable source for the given NC. If given, exclude pUUidDsa
    from potential sources list.
    Variations:
        - If all are stale/excluded, return the last one in the list.
        - If none are version compatible, return none in order to trigger
          a full sync.

    In order for the algorithm to converge, we must guarantee that all sources are tried before
    repeating any source. Otherwise we might get into an oscillation in the upper part of the
    order and never reach a necessary source later in the list. This is done by weighting all
    the sources in a repeatable way. Dynamic factors such as staleness should never affect the
    order of the candidates. The we note where the current source is in the list, and choose
    the following entry in the list using wraparound. Staleness may be used to exclue candidates,
    as long as the remaining members retain their relative ordering.

Arguments:
    pNC -- The NC on which to operate

Return Value:

    DRAERR_SUccess: found a compatible PAS replication partent. ppPrefUuid != NULL.
    DRAERR_NoReplica: No preferred source was found (stale links?). ppPrefUuid == NULL.
    ERROR_REVISION_MISMATCH: Found a Win2K partner (doesn't understand PAS cycles). ppPrefUuid != NULL.
    Other Errors: DRAERR error space & potentially Raises an exception

Remarks:
    Side effect: Allocates memory for returned UUID!

--*/
{

    DWORD           iTag=0, iCurrPasTag = 0;
    UCHAR           *pVal=NULL;
    ULONG ulErr;
    DWORD bufsize=0, len=0;
    REPLICA_LINK *pRepsFromRef = NULL;
    ATTCACHE *pAC;
    DSACRITERIA *rgDsaCriteria, *pPrefDsa;
    INT DsaCount;
    INT cDsa=0;
    ULONG dnt;
    BOOL fCurrPasStale = FALSE;

    Assert(ppPrefUuid);
    Assert(CheckCurrency(pNC));

    //
    // Get attr count
    //
    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
    if (!pAC) {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }
    DsaCount = (INT)DBGetValueCount_AC( pTHS->pDB, pAC );
    if (!DsaCount) {
        //
        // No sources in repsFrom, thus cannot select
        // a preferred one.
        //
        return DRAERR_NoReplica;
    }

    // alloc dsa data
    rgDsaCriteria = THAllocEx(pTHS, sizeof(DSACRITERIA)*DsaCount);
    // note that mem is allocated & zero'ed out.

    //
    // Traverse RepsFrom to find a candidate source.
    //   - filter undesired DSAs.
    //   - Collect information about potential candidates.
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, (ULONG)bufsize, (PULONG)&len,
                         (UCHAR**)&pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, (PDWORD)&bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);

        // debug validations
        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        // store current dnt
        dnt = pTHS->pDB->DNT;

        if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS)
        {
            iCurrPasTag = iTag;
        }

        //
        // Filter out stale DSA's
        //
        if ( GC_StaleLink(pRepsFromRef) ) {
            if (iCurrPasTag == iTag) {
                // We must keep the current source in the list so that we can determine
                // which source is next. Note if current source is stale.
                fCurrPasStale = TRUE;
            } else {
                DPRINT(1, "GC_GetPreferredSource: Skipped Stale link Dsa\n");
                // restore dnt in case we change it above (in the future)
                if (pTHS->pDB->DNT != dnt) {
                    // seek back to NC dnt
                    if (ulErr = DBFindDNT(pTHS->pDB, dnt)) {
                        DRA_EXCEPT (DRAERR_DBError, ulErr);
                    }
                }
                continue;
            }
        }

        //
        // Collect DSA data
        //

        // init flags data
        rgDsaCriteria[cDsa].iTag = iTag;
        CopyMemory(&rgDsaCriteria[cDsa].uuidDsa, &pRepsFromRef->V1.uuidDsaObj, sizeof(UUID) );

        // get DSA data
        GC_GetDsaPreferenceCriteria(
            pTHS,
            pNC,
            pRepsFromRef,
            &(rgDsaCriteria[cDsa].dwFlag));

        //
        // Assign weight to DSA preference criteria
        //
        // we're interested in the following preference criteria:
        // (x>Y means x preferred over Y)
        //    Criteria                  Weight for being in preferred criteria
        //  A - Post Win2k > win2k        +10
        //  B - intra-site > inter-site   +7
        //  C - RW > RO                   +5
        //  D - IP > SMTP                 +1
        // Permutations:
        // Category Value     location         Characteristics
        // ABC      = 22          1  -  post-w2k intra   rw    --
        // AB       = 17          2  -  post-w2k intra   ro    --
        // ACD      = 16          3  -  post-w2k inter   rw    ip
        // AC       = 15          4  -  post-w2k inter   rw    smtp
        // BC       = 12          5  -  w2k      intra   rw    --
        // AD       = 11          6  -  post-w2k inter   ro    ip
        // A        = 10          7  -  post-w2k inter   ro    smtp
        // B        = 7           8  -  w2k      intra   ro    --
        // CD       = 6           9  -  w2k      inter   rw    ip
        // C        = 5           10 -  w2k      inter   rw    smtp
        // D        = 1           11 -  w2k      inter   ro    ip
        // Nill     = 0           12 -  w2k      inter   ro    smtp
        // Invalid combinations: ABCD, BCD, BD, ABD, thus total of 2^4.
        // Interpretation:
        //   Generally, post w2k is preferred except if it has no other preference criteria
        //   and another source has all the rest. If category A is irrelevant, (all or none have it)
        //   then, intra is preferred (except if there's ip rw), then RW, then IP (relevant for inter only).
        // Justification:
        // This is a convinient way to select a data point while analyzing the global problem
        // space. (assign weights & pick the heaviest one...).
        // Next, The reason we'll be using numbers rather then #defines below is to maintain locality
        // between the weight value & the algorithm. Had we assigned a #define somewhere else,
        // it would be easy to get someone twicking the numbers resulting with undesired algorithm.

        rgDsaCriteria[cDsa].dwWeight  = (rgDsaCriteria[cDsa].dwFlag & DSA_PREF_VER) ? 10 : 0;
        rgDsaCriteria[cDsa].dwWeight += (rgDsaCriteria[cDsa].dwFlag & DSA_PREF_INTRA) ? 7 : 0;
        rgDsaCriteria[cDsa].dwWeight += (rgDsaCriteria[cDsa].dwFlag & DSA_PREF_RW) ? 5 : 0;
        rgDsaCriteria[cDsa].dwWeight += (rgDsaCriteria[cDsa].dwFlag & DSA_PREF_IP) ? 1 : 0;

        cDsa++;
        // restore dnt
        if (pTHS->pDB->DNT != dnt) {
            // seek back to NC dnt
            if (ulErr = DBFindDNT(pTHS->pDB, dnt)) {
                DRA_EXCEPT (DRAERR_DBError, ulErr);
            }
        }
    }

    // we must have traversed all of them at the most, most likely fewer
    Assert(cDsa <= DsaCount );

    //
    // Determine which do we return.
    //


    if ( (cDsa == 0) ||
         ( (cDsa == 1) && (iCurrPasTag) && (fCurrPasStale) )
        ) {
        //
        // There are no valid sources at the moment.
        //
        DPRINT(1, "GC_GetPreferredSource: No valid PAS sources found.\n");
        Assert(!*ppPrefUuid);
        ulErr = DRAERR_NoReplica;
    } else {
        DPRINT1(1, "GC_GetPreferredSource: found %d candidates.\n", cDsa);
        Assert( cDsa > 0 );
        // Sort the candidates by weight, including current pas source if any
        qsort(rgDsaCriteria, cDsa, sizeof(DSACRITERIA), compareDsaCriteria );
#if DBG
        {
            INT iDsa;
            CHAR szUuid1[SZUUID_LEN];
            DPRINT2( 1, "iCurrPasTag = %d, fCurrPasStale = %d\n",
                     iCurrPasTag, fCurrPasStale );
            for (iDsa = 0; iDsa<cDsa; iDsa++) {
                DPRINT5( 1, "%d: t=%d,u=%s,f=%x,w=%d\n",
                         iDsa,
                         rgDsaCriteria[iDsa].iTag,
                         DsUuidToStructuredString(&(rgDsaCriteria[iDsa].uuidDsa), szUuid1),
                         rgDsaCriteria[iDsa].dwFlag,
                         rgDsaCriteria[iDsa].dwWeight );
            }
        }
#endif

        if (!iCurrPasTag) {
            DPRINT(1, "GC_GetPreferredSource: no current pas, picking best.\n");
            // If there is no current pas source, pick the first&best one
            pPrefDsa = &(rgDsaCriteria[0]);

        } else {
            INT iDsa;
            // There is a current pas source

            // Find it
            for (iDsa = 0, pPrefDsa = &(rgDsaCriteria[0]);
                 iDsa<cDsa && (iCurrPasTag != pPrefDsa->iTag);
                 iDsa++, pPrefDsa++) ;

            // Should be there...
            Assert( iDsa < cDsa );

            // If it is not stale, use it, otherwise
            // Choose the next in the ordering with wraparound
            if (fCurrPasStale) {
                DPRINT(1, "GC_GetPreferredSource: current pas stale, picking next.\n");
                Assert( cDsa > 1 );
                pPrefDsa = &(rgDsaCriteria[ ((iDsa+1)%cDsa) ]);
                Assert( pPrefDsa->iTag != iCurrPasTag );
            }
        }

        // copy over
        *ppPrefUuid = THAllocEx(pTHS, sizeof(UUID));
        CopyMemory(*ppPrefUuid, &pPrefDsa->uuidDsa, sizeof(UUID));

        //
        // Test version compatibility
        //

        if ( (pPrefDsa->dwFlag & DSA_PREF_VER) ) {
            // we're happy: got a good PAS partner
            DPRINT(1, "GC_GetPreferredSource: Found good PAS replica partner.\n");
            ulErr = DRAERR_Success;
        }
        else {
            //
            // We'd settled on win2k-- this means full sync. Return None!
            //
            DPRINT(1, "GC_GetPreferredSource: Found Win2K non-PAS replica partner.\n");
            ulErr = ERROR_REVISION_MISMATCH;
        }
    }

    //
    // Cleanup temps
    //
    THFreeEx(pTHS, rgDsaCriteria);
    THFreeEx(pTHS, pRepsFromRef);

    return ulErr;
}


VOID
GC_GetDsaPreferenceCriteria(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    REPLICA_LINK *pRepsFrom,         // [in]
    PDWORD      pdwFlag)             // [out]
/*++

Routine Description:

    Query the dsa object for information as follows:
    -- is it RW or RO (for given NC)? DSA_PREF_RW
    -- is it intra or inter-site relative to us? DSA_PREF_INTRA
    -- is it's version is win2k or post win2k? DSA_PREF_VER
    -- can we talk to it IP? DSA_PREF_IP


    All is retrieved locally via the info stored in the config container.

Arguments:

    pNC-- the NC we're working on.
    pRepsFrom -- the Dsa RL entry we query about
    pdwFlag-- returned info


Return Value:
    none.

Remarks:
    Throws exception on error (justification: should be called only when valid data
    can be returned on the local query).

--*/
{

    DSNAME          OtherDsa, *pRwNc = NULL;
    INT             iTag=0;
    ULONG           ulErr;
    DWORD           cb = 0, bufsize=0;
    DWORD           cbOtherAncestors = 0;
    DWORD           cNumMyAncestors = 0, cNumOtherAncestors = 0;
    DWORD           *pMyAncestors = NULL, *pOtherAncestors = NULL;
    DWORD            dwDsaVersion = 0;
    CHAR             szUuid1[SZUUID_LEN];

    Assert(pNC);
    Assert(pdwFlag && *pdwFlag == 0);   // caller supplied flag &&
                                        // caller should initialize
    //
    // Local DSA object info
    // set convinience ptrs
    //
    pMyAncestors = gAnchor.pAncestors;
    cNumMyAncestors = gAnchor.AncestorsNum;

    //
    // Get source DSA object
    //


    // set dsname of destination dsa
    ZeroMemory(&OtherDsa, sizeof(DSNAME));
    OtherDsa.structLen = DSNameSizeFromLen(0);
    CopyMemory(&(OtherDsa.Guid),&(pRepsFrom->V1.uuidDsaObj), sizeof(UUID));

    // Seek to other DSA object
    if (ulErr = DBFindDSName(pTHS->pDB, &OtherDsa)) {
        DRA_EXCEPT (DRAERR_DBError, ulErr);
    }

    DPRINT3( 3, "Checking writeable ncs on %s for %ws guid %s\n",
             GetExtDN(pTHS,pTHS->pDB),
             pNC->StringName,
             DsUuidToStructuredString(&(pNC->Guid), szUuid1) );

    // get RW info
    bufsize = cb = 0;
    while(!DBGetAttVal(
               pTHS->pDB,
               ++iTag,
               GetRightHasMasterNCsAttr(pTHS->pDB),
               DBGETATTVAL_fREALLOC,
               bufsize,
               &cb,
               (UCHAR**)&pRwNc))
    {
        if (DsIsEqualGUID(&(pRwNc->Guid), &(pNC->Guid))) {
            // found dsa is RW replica
            *pdwFlag |= DSA_PREF_RW;
            break;
        }
        bufsize = max(bufsize, cb);
    }
    THFreeEx(pTHS, pRwNc);

    // Get behavior version number.
    // If our enterprise version is >= Whistler (homogeneous) we're ok.
    // Otherwise, decide based on read source DS behavior version

    if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
        // enterprise is whistler+.
        *pdwFlag |= DSA_PREF_VER;
    }
    else {
        // read it off & evaluate.
        ulErr = DBGetSingleValue(
                    pTHS->pDB,
                    ATT_MS_DS_BEHAVIOR_VERSION,
                    &dwDsaVersion,
                    sizeof(DWORD),
                    NULL);
        if (ERROR_SUCCESS == ulErr &&
            dwDsaVersion >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
            // version is set & preferred.
            *pdwFlag |= DSA_PREF_VER;
        }
    }

    // get ancestors
    DBGetAncestors(
        pTHS->pDB,
        &cbOtherAncestors,
        &pOtherAncestors,
        &cNumOtherAncestors
        );

    //
    // Intra or Inter site
    //

    //
    // They're in the same site if their site container is
    // the same object.
    // Objectclass hierarchy:
    //  site          << next up (Num-3)          // within the same site
    //   Servers      << next up (Num-2)
    //    server      << last ancestor (Num-1)
    //     nTDSDSA    << this object
    //
    Assert(cNumMyAncestors-3 > 0 &&
           cNumOtherAncestors-3 > 0 );
    if ( pOtherAncestors[cNumOtherAncestors-3] ==
         pMyAncestors[cNumMyAncestors-3] ) {
        *pdwFlag |= DSA_PREF_INTRA;
    }

    //
    // IP Connectivity
    //

    if ( !(*pdwFlag & DSA_PREF_INTRA) ) {
        // if it's intra-site, no need to care about mail
        if (!(pRepsFrom->V1.ulReplicaFlags & DRS_MAIL_REP) ) {
            *pdwFlag |= DSA_PREF_IP;
        }
    }

    //
    // Cleanup
    // note: we're relying on THFree ignoring NULLs
    //
    DPRINT1( 3, "dwFlags = 0x%x\n", *pdwFlag );
    THFreeEx(pTHS, pOtherAncestors);
}



ULONG
GC_RegisterPAS(
    THSTATE               *pTHS,        // [in]
    DSNAME                *pNC,         // [in]
    UUID                  *pUuidDsa,    // [optional, in]
    PARTIAL_ATTR_VECTOR   *pPAS,        // [optional, in]
    DWORD                 dwOp,         // [in]
    BOOL                  fResetUsn     // [in]
    )
/*++

Routine Description:

    Resets PAS state by:
    a) writing RepsFrom values

Arguments:

    pNC -- active NC
    pUuidDsa -- the dsa (source) entry we wish to modify
                optional: if none specified, applied to all
    pPAS -- partial attribute set to register
    dwOp -- what operation should we do here.
        Values:
         PAS_RESET - Reset to 0. No PAS is running
         PAS_ACTIVE - Set to given state based on in params.
    fResetusn - rest usn watermark


Return Value:

    Success: DRAERR_Success
    Error: in Dra error space, or exception raised.

Remarks:
None.


--*/
{

    int             iTag= 0;
    UCHAR           *pVal=NULL;
    DWORD           bufsize=0, len=0;
    REPLICA_LINK    *pRepsFromRef=NULL;
    ULONG           ulErr = DRAERR_Success;
    ULONG           ulModifyFields;
    PPAS_DATA       pPasData = NULL;
    BOOL            fNoOp;

    // position on NC
    // set currency on the NC
    if (ulErr = DBFindDSName(pTHS->pDB, pNC))
    {
        // Tolerate the NC still being a phantom. This can occur when
        // DRA_ReplicaAdd/Sync fails to bring in the NC head because of a
        // sync failure.
        if (ulErr == DIRERR_NOT_AN_OBJECT) {
            return (ulErr);
        }
        DRA_EXCEPT(DRAERR_InternalError, ulErr);
    }

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         &pVal))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        // debug validations
        VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);
        Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

        pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
        //note: we preserve pVal for DBGetAttVal realloc
        pVal = (PUCHAR)pRepsFromRef;
        Assert(bufsize >= pRepsFromRef->V1.cb);

        Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

        if (!pUuidDsa ||
            ( pUuidDsa &&
              DsIsEqualGUID(pUuidDsa, &(pRepsFromRef->V1.uuidDsaObj)) )) {
            //
            // Setup state
            //
            fNoOp = FALSE;
            switch ( dwOp ) {
                case PAS_RESET:
                    //
                    // Reset repsFrom PAS flags
                    //
                    if ( !(pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS) ) {
                        // it's already reset. no op.
                        fNoOp = TRUE;
                    }
                    else{
                        // reset an existing PAS cycle (most likely upon completion or
                        // failover to another source):
                        //  - reset flag
                        //  - reset PAS usn info (to zero). If we don't, following PAS cycles on new attrs
                        //    are in the risk of continuing from older water marks.
                        //
                        pRepsFromRef->V1.ulReplicaFlags &= ~DRS_SYNC_PAS;
                    }
                    Assert(!pPAS);
                    break;

                case PAS_ACTIVE:
                    pRepsFromRef->V1.ulReplicaFlags |= DRS_SYNC_PAS;
                    // the only valid operation on ALL is RESET
                    // if op is active, a uuiddsa must have been specified
                    // And a PAS must have been specified
                    Assert(pPAS);
                    Assert(pUuidDsa);
                    break;

                default:
                    Assert(FALSE);
                    DRA_EXCEPT(DRAERR_InternalError, 0);
            }

            // see if we can bail out early
            if ( fNoOp && pUuidDsa ) {
                // dsa specified & it's a no op. we're done
                break;
            }
            else if ( fNoOp ) {
                // this is apply to all entries, but this specific one is a no op.
                continue;
            }

            //
            // prepare pas info & commit
            //

            // if we're here we must update flags & pas data.
            ulModifyFields = DRS_UPDATE_SYSTEM_FLAGS| DRS_UPDATE_PAS;

            if (pPAS) {
                //
                // set PAS data
                //
                len = sizeof(PAS_DATA) + PartialAttrVecV1Size(pPAS);
                pPasData = THAllocEx(pTHS, len);
                pPasData->version = PAS_DATA_VER;
                pPasData->size = (USHORT)len;
                pPasData->flag = dwOp;
                CopyMemory(&(pPasData->PAS), pPAS, PartialAttrVecV1Size(pPAS));
            }
            // otherwise, we're reseting pas data & NULL is fine

            if ( fResetUsn ) {
                //
                // Reset USN vector
                //
                pRepsFromRef->V1.usnvec.usnHighObjUpdate = 0;
                ulModifyFields |= DRS_UPDATE_USN;
            }

            // Log debug event
            LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                     DS_EVENT_SEV_EXTENSIVE,
                     dwOp == PAS_ACTIVE ?
                        DIRLOG_GC_REGISTER_ACTIVE_PAS :
                        DIRLOG_GC_REGISTER_RESET_PAS,
                     szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                     szInsertDN(pNC),
                     NULL );

            //
            // Commit changes to repsFrom
            //
            ulErr = UpdateRepsFromRef(
                        pTHS,
                        ulModifyFields,
                        pNC,
                        DRS_FIND_DSA_BY_UUID,
                        URFR_MUST_ALREADY_EXIST,
                        &(pRepsFromRef->V1.uuidDsaObj),
                        &(pRepsFromRef->V1.uuidInvocId),
                        &(pRepsFromRef->V1.usnvec),
                        &(pRepsFromRef->V1.uuidTransportObj),
                        RL_POTHERDRA(pRepsFromRef),
                        pRepsFromRef->V1.ulReplicaFlags,
                        &(pRepsFromRef->V1.rtSchedule),
                        DRAERR_Success,
                        pPasData );

            if ( pPasData ) {
                THFreeEx(pTHS, pPasData);
            }

            if ( ulErr ) {
                DRA_EXCEPT(DRAERR_InternalError, ulErr);
            }

            if ( pUuidDsa ) {
                //
                // Handle only specified one. done.
                //
                break;
            }

            // we'll potentially set more then one dsa.
            // only valid for a RESET op.
            Assert(dwOp == PAS_RESET);
        }

        // Next cycle: continue searching for next pUuidDsa

    }

    //
    // Cleanup
    //
    THFreeEx(pTHS, pRepsFromRef);

    return ulErr;
}


ULONG
GC_CompletePASReplication(
    THSTATE               *pTHS,                    // [in]
    DSNAME                *pNC,                     // [in]
    UUID                  *pUuidDsa,                // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSet,           // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSetEx          // [in]
    )
/*++

Routine Description:

    Executes tasks upon successfull completion of PAS replication:
        - Resets all USN vectors in repsFrom except for current PAS replica
        - replaces UTD vector w/ PAS replica's UTD vector
        - write new PAS onto NC head
        - remove PAS flag & data from NC head

Arguments:

    pNC-- active NC
    pUuidDsa -- uuid of peer dsa for which we'd completed a successful
                PAS repl cycle.


Return Value:

    Success: DRAERR_Success;
    Error: in DRAERR error space

Remarks:
    Raises DRA exception


--*/
{

    ULONG ulErr = DRAERR_Success;
    REPLICA_LINK *pRepsFromRef;
    PARTIAL_ATTR_VECTOR     *pNewPAS;
    ULONG len=0, bufsize=0;
    DWORD iTag=0;
    PUCHAR pVal=NULL;
    ATTCACHE* pAC=NULL;
    ULONG DsaCount;
    UUID* rgSrc;
    BOOL fExist=FALSE;

    // sanity on params.
    Assert(pNC && pUuidDsa);
    Assert(CheckCurrency(pNC));

    DPRINT1(1, "GC_CompletePASReplication: for NC %ws\n", pNC->StringName);

    //
    // Get attr count
    //
    pAC = SCGetAttById(pTHS, ATT_REPS_FROM);
    if (!pAC) {
        DRA_EXCEPT (DRAERR_DBError, 0);
    }
    DsaCount = (INT)DBGetValueCount_AC( pTHS->pDB, pAC );
    // we should never get here if there are no sources.
    if (!DsaCount) {
        Assert(DsaCount != 0);
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    // alloc dsa data
    rgSrc = THAllocEx(pTHS, sizeof(UUID)*DsaCount);
    // note that mem is allocated & zero'ed out.

    //
    // Traverse RepsFrom & collect all source's UUID
    //

    while (!(DBGetAttVal(pTHS->pDB,++iTag,
                         ATT_REPS_FROM,
                         DBGETATTVAL_fREALLOC, bufsize, &len,
                         (PUCHAR*)&pRepsFromRef ))) {
        // point at link & remember buffer allocation
        bufsize = max(bufsize,len);
        VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
        Assert( pRepsFromRef->V1.cb == len );

        rgSrc[iTag-1] = pRepsFromRef->V1.uuidDsaObj;
    }
    Assert(iTag-1 == DsaCount);


    //
    // For each found
    //   - reset USN for all peers but PAS source
    //

    for (iTag=0; iTag<DsaCount; iTag++) {


        //
        // Filter out known undesired DSA.
        //
        if (DsIsEqualGUID(pUuidDsa, &(rgSrc[iTag])) ) {
            // skip this dsa, we don't want it. This is our successful peer
            continue;
        }

        //
        // Reset USN vector
        //
        ulErr = UpdateRepsFromRef(
                    pTHS,
                    DRS_UPDATE_USN,
                    pNC,
                    DRS_FIND_DSA_BY_UUID,
                    URFR_MUST_ALREADY_EXIST,
                    &rgSrc[iTag],
                    NULL,
                    &gusnvecFromScratch,
                    NULL, NULL, 0, NULL, 0, NULL );
    }


    //
    // Write new PAS on NC head
    //

    // combine into new one
    pNewPAS = GC_CombinePartialAttributeSet(pTHS, pPartialAttrSetEx, pPartialAttrSet);
    Assert(pNewPAS);
    GC_WritePartialAttributeSet(pNC, pNewPAS);

    //
    // Last, remove PAS registration on repsFrom
    //
    ulErr = GC_RegisterPAS(pTHS, pNC, pUuidDsa, NULL, PAS_RESET, FALSE);
    if ( ulErr ) {
        DRA_EXCEPT(DRAERR_InternalError, ulErr);
    }

    // Log so the admin knows what's going on.
    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_GC_PAS_COMPLETED,
             szInsertDN(pNC),
             szInsertUUID(pUuidDsa),
             NULL
             );

    THFreeEx(pTHS, rgSrc);
    return ulErr;
}


BOOL
GC_StaleLink(
    REPLICA_LINK *prl           // [in]
    )
/*++

Routine Description:

    Determines whether the input link is stale.

Arguments:

    prl -- the link in question

Return Value:

    TRUE: it is stale according to our guidelines (see code below)
    FALSE: it's ok

--*/
{

    if ( DRAERR_Shutdown != prl->V1.ulResultLastAttempt &&
         DRAERR_AbandonSync != prl->V1.ulResultLastAttempt &&
         DRAERR_Preempted != prl->V1.ulResultLastAttempt &&
         DRAERR_Success != prl->V1.ulResultLastAttempt) {
        //
        // Last attempt was failure, see how long ago & how many in sequence
        //
        DSTIME  diff;

        // I considered declaring staleness for DRAERR_IncompatiblePartialSet
        // immediately instead of waiting for the 2 hour timeout (it is one of the
        // special errors in drarfmod that doesn't increment the count). This would
        // speed convergence, but also runs the risk that we will cycle through our
        // .net sources quickly and find a w2k source which is very expensive.  The
        // two hour failover here allows for other sources to perhaps replicate the
        // PAS in through other routes and become viable partners.
        if ( gAnchor.ForestBehaviorVersion >= DS_BEHAVIOR_WIN_DOT_NET_WITH_MIXED_DOMAINS ) {
            if (DRAERR_IncompatiblePartialSet == prl->V1.ulResultLastAttempt) {
                // staleness due to lack of new pas yet
                return TRUE;
            }
        }

        // consecutive failures
        if ( prl->V1.cConsecutiveFailures > gPASFailureTolerance ) {
            DPRINT1(1, "GC_StaleLink: Too many consecutive failures: %d\n",
                    prl->V1.cConsecutiveFailures);
            // stale due to too many failures
            return TRUE;
        }
        // time since last success
        diff = DBTime() - prl->V1.timeLastSuccess;
        if ( diff > gPASTimeTolerance ) {
            DPRINT1(1, "GC_StaleLink: too long since last success: %i64d\n",
                    diff);
            // stale due to too much time since last success
            return TRUE;
        }
    }

    // it isn't stale
    return FALSE;
}



VOID
GC_ReadRegistryThresholds( VOID  )
/*++

Routine Description:

    Reads Registry thresholds for GC Partial Attribute Set
    replication (preferred source stale criteria)

Return:

    Sets global variables: gdwMaxConsecFailures, gdwTimeToleranceThreshold

Remark:
    BUGBUG: This function is part of a temprorary solution.
    Permanent solution should be using the KCC criteria when determining
    server validity.
--*/
{
    DWORD dwErr;

    dwErr = GetConfigParam(KCC_CRIT_FAILOVER_TRIES, &gPASFailureTolerance, sizeof(DWORD));
    if ( dwErr ) {
        // report error to debugger, continue w/ defaults
        DPRINT1(3, "GC_StaleLink: Failed to get KCC_CRIT_FAILOVER_TRIES. Error %lu.\n",
                dwErr);
        Assert(gPASFailureTolerance == DEFAULT_PAS_CONSEC_FAILURE_TOLERANCE);
    }
    dwErr = GetConfigParam(KCC_CRIT_FAILOVER_TIME, &gPASTimeTolerance, sizeof(DWORD));
    if ( dwErr ) {
        // report error to debugger, continue w/ defaults
        DPRINT1(3, "GC_StaleLink: Failed to get KCC_RIT_FAILOVER_TIME. Error %lu.\n",
                dwErr);
        Assert(gPASTimeTolerance == DEFAULT_PAS_TIME_TOLERANCE);
    }
}


void
GC_GetPartialAttrSets(
    THSTATE                     *pTHS,              // [in]
    DSNAME                      *pNC,               // [in]
    REPLICA_LINK                *pRepLink,          // [in]
    PARTIAL_ATTR_VECTOR         **ppPas,            // [out]
    PARTIAL_ATTR_VECTOR         **ppPasEx           // [out, optional]
    )
/*++

Routine Description:

    Extract partial attribute sets

Arguments:

    pNC - active naming context
    pRepLink - source repsfrom link
    ppPas - base partial attribute set
    ppPasEx - extended partial attribute set

Return Value:

    fill in out params

Remarks:
    raise exception on error


--*/
{

    // param sanity
    Assert(ppPas && pRepLink && pNC);

    //
    // Get base PAS
    // caller must have intended for us to have it
    //
    if (!GC_ReadPartialAttributeSet(pNC, ppPas))
    {
        // Unable to read the partial attribute set on the NCHead
        DRA_EXCEPT (DRAERR_DBError, 0);
    }

    if (NULL == *ppPas) {
        //
        // No PAS on NC head, take it from schema cache
        //
        *ppPas = ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->pPartialAttrVec;
    }

    // if called, we must at least supply the main PAS vector.
    Assert(NULL != *ppPas);

    if ( ppPasEx &&
         (pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ) {
        //
        // Requested extended PAS
        //
        if ( 0 == pRepLink->V1.cbPASDataOffset ) {
            //
            // Inconsistency: There is no PAS data to process. Abort
            //
            DPRINT(0, "Error: GC_GetPartialAttrSets failed to get required PAS.\n");
            Assert(!(pRepLink->V1.ulReplicaFlags & DRS_SYNC_PAS) ||
                   pRepLink->V1.cbPASDataOffset);
            LogUnhandledError(DRAERR_InternalError);
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }
        *ppPasEx =  &(RL_PPAS_DATA(pRepLink)->PAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drasync.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drasync.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop


#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include <dstrace.h>
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRASYNC:" /* define the subsystem for debugging */


// DRA headers
#include "drsuapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "usn.h"
#include "drauptod.h"
#include "drasch.h"
#include "draasync.h"

#include <fileno.h>
#define  FILENO FILENO_DRASYNC


/* LogSyncFailure - Log a replication synchronization failure.
*
*/
void
LogSyncFailure(
    THSTATE *pTHS,
    MTX_ADDR *pmtx_addr,
    DSNAME *pDistName,
    DWORD FailureCode
    )
{
    LogEvent8(DS_EVENT_CAT_REPLICATION,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_DRA_SYNC_FAILURE,
              szInsertDN(pDistName),
              szInsertMTX(pmtx_addr),
              szInsertWin32Msg(FailureCode),
              szInsertWin32ErrCode(FailureCode),
              NULL, NULL, NULL, NULL );
}

ULONG DRA_ReplicaSync(
    THSTATE *       pTHS,
    DSNAME *        pNC,
    UUID *          puuidDsaObj,
    LPWSTR          pszDSA,
    ULONG           ulOptions
    )
{
    ULONG                   ret;
    USN_VECTOR              usnvecLastSync;
    REPLICA_LINK *          pRepsFromRef = 0;
    ULONG                   len;
    ULONG                   dntNC;
    BOOL                    AttExists;
    ULONG                   RepFlags = 0;
    ULONG                   ulSyncFailure = 0;
    SYNTAX_INTEGER          it;
    BOOL                    fDoTwoWaySync = FALSE;
    UPTODATE_VECTOR *       pUpToDateVec;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx = NULL;
    PARTIAL_ATTR_VECTOR *   pPartialAttrSet = NULL;
    BOOL                    fAsyncStarted = FALSE;
    BOOL                    fBindSuccess = FALSE;

    // Log parameters
    LogAndTraceEvent(TRUE,
             DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_DRA_REPLICASYNC_ENTRY,
             EVENT_TRACE_TYPE_START,
             DsGuidReplicaSync,
             szInsertDN(pNC),
             ulOptions & DRS_SYNC_BYNAME
                 ? szInsertWC(pszDSA)
                 : szInsertUUID(puuidDsaObj),
             szInsertHex(ulOptions),NULL,NULL,NULL,NULL,NULL);

    BeginDraTransaction(SYNC_WRITE);

    __try {


        if (ret = FindNC(pTHS->pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
                         &it)) {
            DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, ret);
        }

        // Save the DNT of the NC Head
        dntNC = pTHS->pDB->DNT;
        
        // Future maintainers: note the subtle difference 
        // ulOptions - what the caller requested. MAY NOT BE ACCURATE.
        // ulReplicaFlags - persistant flags. Definitive of what state we're in.
        // RepFlags - persistant flags plus subset of caller flags

        if (FPartialReplicaIt(it)) {

            // process any partial attribute set changes - if no change below doesn't
            // do anything; if change, it triggers the necessary actions.
            GC_ProcessPartialAttributeSetChanges(pTHS, pNC, puuidDsaObj);

                // restore in case we'd changed it
            if (pTHS->pDB->DNT != dntNC) {
                if (ret = DBFindDNT(pTHS->pDB, dntNC)) {
                    DRA_EXCEPT (DRAERR_DBError, ret);
                }
            }

            //
            // We have munged repsFrom to initiate PAS cycle, full sync
            // or just let go (in case of all stale). And we had potentially
            // placed a repl AO task which will follow this one if this
            // executes below. Either way, we're ok to continue here.
            //
        }

        // If we are syncing all, find each replica link and queue a
        // sync from each DRA from which we replicate.

        if (ulOptions & DRS_SYNC_ALL) {

            ULONG NthValIndex=0;
            UCHAR *pVal;
            ULONG bufsize = 0;

            // We only do this synchronously, so check that's what the
            // caller wants.

            if (!(ulOptions & DRS_ASYNC_OP)) {
                DRA_EXCEPT_NOLOG (DRAERR_InvalidParameter, 0);
            }

            // Get the repsfrom attribute

            while (!(DBGetAttVal(pTHS->pDB,++NthValIndex,
                                 ATT_REPS_FROM,
                                 DBGETATTVAL_fREALLOC, bufsize, &len,
                                 &pVal))) {
                bufsize = max(bufsize,len);

                VALIDATE_REPLICA_LINK_VERSION((REPLICA_LINK*)pVal);

                Assert( ((REPLICA_LINK*)pVal)->V1.cb == len );

                pRepsFromRef = FixupRepsFrom((REPLICA_LINK*)pVal, &bufsize);
                //note: we preserve pVal for DBGetAttVal realloc
                pVal = (PUCHAR)pRepsFromRef;
                Assert(bufsize >= pRepsFromRef->V1.cb);

                Assert( pRepsFromRef->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( pRepsFromRef ) ) );

                if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_AUTO_SYNC) ||
                    (ulOptions & DRS_SYNC_FORCED)) {

                    // Ignore persistant flags except for writeability
                    RepFlags = pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP;

                    // Or in any special flags from caller such as
                    // sync mods made by anyone or sync from scratch.
                    // Also pass in no discard flag if set by caller.

                    RepFlags |= (ulOptions & REPSYNC_SYNC_ALL_FLAGS );

                    DirReplicaSynchronize(pNC,
                                          NULL,
                                          &pRepsFromRef->V1.uuidDsaObj,
                                          RepFlags | DRS_ASYNC_OP);
                }
            }
            if(bufsize)
                THFree(pVal);
            ret = 0;

        } else {

            // Find the DSA from which we sync. This is either by name or
            // UUID.

            MTX_ADDR * pmtxDSA = NULL;

            if (ulOptions & DRS_SYNC_BYNAME) {
                pmtxDSA = MtxAddrFromTransportAddrEx(pTHS, pszDSA);
            }

            if ( FindDSAinRepAtt(
                        pTHS->pDB,
                        ATT_REPS_FROM,
                        ( ulOptions & DRS_SYNC_BYNAME )
                            ? DRS_FIND_DSA_BY_ADDRESS
                            : DRS_FIND_DSA_BY_UUID,
                        puuidDsaObj,
                        pmtxDSA,
                        &AttExists,
                        &pRepsFromRef,
                        &len
                        )
               ) {

                // Failed to find replication reference on replica.

                // First ensure that if we are trying to initially sync
                // from this source and it's writeable, we don't anymore.

                if (ulOptions & DRS_SYNC_BYNAME) {
                    InitSyncAttemptComplete (pNC, ulOptions, DRAERR_NoReplica, pszDSA);
                }

                // Then error out.
                DRA_EXCEPT_NOLOG (DRAERR_NoReplica, 0);

            }

            // If found, sync up replica from caller.
            VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);

            // Get current UTD vector.
            UpToDateVec_Read(pTHS->pDB,
                             it,
                             UTODVEC_fUpdateLocalCursor,
                             DBGetHighestCommittedUSN(),
                             &pUpToDateVec);

            if (!(pRepsFromRef->V1.ulReplicaFlags & DRS_WRIT_REP)){
                //
                // GC ReadOnly cycle
                //  - get partial attr sets
                //

                GC_GetPartialAttrSets(
                    pTHS,
                    pNC,
                    pRepsFromRef,
                    &pPartialAttrSet,
                    &pPartialAttrSetEx);

                Assert(pPartialAttrSet);

                if (pRepsFromRef->V1.ulReplicaFlags & DRS_SYNC_PAS) {
                    // PAS cycle: Ensure consitency: we must have the extended set and
                    // notify admin (event log).
                    // Note the difference between ulOptions and ulReplicaFlags. ulReplicaFlags
                    // is the definitive, persistant state of the pas cycle. PAS is indicated in
                    // ulOptions on a best effort basis and may not always match. It may still be set
                    // on a lingering sync, or may not be set on a periodic sync. PAS gets set/cleared
                    // on ulReplicaFlags through UpdateRepsFromRep, it does NOT passed through here
                    // from ulOptions to ulReplicaFlags (see REPSYNC_REPLICATE_FLAGS).

                    Assert(pPartialAttrSetEx);

                    // Log so the admin knows what's going on.
                    LogEvent(DS_EVENT_CAT_GLOBAL_CATALOG,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GC_PAS_CYCLE,
                             szInsertWC(pNC->StringName),
                             szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                             NULL
                             );
                }

            }

            // Sync up only if it is not controlled
            if ((pRepsFromRef->V1.ulReplicaFlags & DRS_DISABLE_AUTO_SYNC) &&
                !(ulOptions & (DRS_SYNC_FORCED | DRS_PER_SYNC))) {
                 // auto-sync is disabled for this link and sync op didn't
                 // explicitly force it nor is it a periodic sync.
                 ret = DRAERR_SinkDisabled;
                 InitSyncAttemptComplete(pNC, ulOptions, DRAERR_SinkDisabled,
                               TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef)));
            }
            else if (pRepsFromRef->V1.ulReplicaFlags & DRS_MAIL_REP) {

                // If mail replica, send request update message to source.
                draSendMailRequest(
                    pTHS,
                    pNC,
                    ulOptions,
                    pRepsFromRef,
                    pUpToDateVec,
                    pPartialAttrSet,
                    pPartialAttrSetEx
                    );
                
                // By it's very definition mail based replication is 
                // asynchronous, so we should return that the replication is 
                // pending if the ASYNC flag wasn't specified.
                if( !(ulOptions & DRS_ASYNC_OP) ){
                    fAsyncStarted = TRUE;
                }

            } else if ( ( (pRepsFromRef->V1.ulReplicaFlags & AO_PRIORITY_FLAGS) !=
                          (ulOptions & AO_PRIORITY_FLAGS) )
                       && (ulOptions & DRS_ASYNC_OP)) {
                // This operation was enqueued at a different priority than
                // it should have been. There is code in the replication
                // queue (FixupSyncOptions) that tries to avoid this condition
                // but that code is not completely reliable because the
                // repsFrom options can change at any time. We re-enqueue
                // ourselves at the proper priority and bail.
                ret = DirReplicaSynchronize(
                            pNC,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                            | (pRepsFromRef->V1.ulReplicaFlags &
                               AO_PRIORITY_FLAGS)
                            | (ulOptions &
                               REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED &
                                ~AO_PRIORITY_FLAGS ));
                // Set the return status so it is obvious to callers reading the
                // event log that a wasteful, undesirable reschedule took place
                if (!ret) {
                    ret = ERROR_INVALID_PRIORITY;
                }
            } else {

                BOOL fRequeueOfInitSync = FALSE;

                // If RPC replica, sync now.

                usnvecLastSync = pRepsFromRef->V1.usnvec;

                RepFlags = pRepsFromRef->V1.ulReplicaFlags;

                // When the sync is complete, we will do a two-way sync
                // if we've been configured for two-way syncs from this
                // source *and* the inbound sync was not enqueued as a
                // result of a two-way sync at the other end.  (The latter
                // to avoid circular syncs.)
                fDoTwoWaySync = (RepFlags & DRS_TWOWAY_SYNC)
                                && !(ulOptions & DRS_TWOWAY_SYNC);

                // Or in any special flags from caller such as
                // sync mods made by anyone or sync from scratch.
                // See note about ulOptions vs RepFlags above

                RepFlags |= (ulOptions & REPSYNC_REPLICATE_FLAGS);

                // If we're in the midst of a TH_mark / TH_free_to_mark, we
                // need to copy the parameters we're passing to
                // ReplicateNC().
                Assert(NULL == pTHS->hHeapOrg);

                // Replicate from source.
                ret = ReplicateNC( pTHS,
                                   pNC,
                                   RL_POTHERDRA(pRepsFromRef),
                                   NULL,
                                   &usnvecLastSync,
                                   RepFlags,
                                   &pRepsFromRef->V1.rtSchedule,
                                   &pRepsFromRef->V1.uuidDsaObj,
                                   &pRepsFromRef->V1.uuidInvocId,
                                   &ulSyncFailure,
                                   FALSE,               // Not new replica
                                   pUpToDateVec,
                                   pPartialAttrSet,
                                   pPartialAttrSetEx,
                                   ulOptions,
                                   &fBindSuccess );

                // Comment on urgent replication.  If replication failed, do not propagate
                // urgent flag on subsequent attempts.  If failure was congestion related,
                // urgency will only compound the problem.

                if (!ret) {

                    // Retry on flawed sync.  Note, if you add more retriable conditions,
                    // please update the list in drautil.c as well.

                    switch (ulSyncFailure) {

                    case 0:
                        // Success.

                        break;

                    case ERROR_DS_DRA_OUT_SCHEDULE_WINDOW:
                        // Don't log failure
                        // Don't retry
                        break;

                    case DRAERR_SourceDisabled:
                    case DRAERR_SinkDisabled:
                        // Replication disabled on one or both ends.
                        // Log failure and don't retry.
                        LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ulSyncFailure);
                        break;

                    case DRAERR_SchemaMismatch:
                        // no need to log event - already logged as soon as we hit the mismatch
                        // in UpdateNC()

                        // Sync of this NC failed because of schema mismatch - so queue a
                        // schema sync from the same source and requeue a sync for
                        // the current NC.

                        // queue a schema sync -- will be executed first
                        DirReplicaSynchronize(
                            gAnchor.pDMD,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                              | (ulOptions
                                 & (DRS_SYNC_BYNAME
                                     | DRS_SYNC_FORCED)));

                        if ( ulOptions & DRS_SYNC_REQUEUE ) {
                            //
                            // We had already requeued this request.
                            // Do not allow yet another requeue cause in some cases
                            // we can get into a tight requeue loop.
                            //
                            // For instance, consider what happens when the schema sync
                            // keeps failing due to, say, missing links in repsFrom due to
                            // bad admin intervention:
                            //   :loop
                            //      - sync NC <x> --> fail w/ DRAERR_SchemaMismatch
                            //      - sync schema here followed by sync NC <x>
                            //      - schema sync failed w/ DRAERR_NoReplica
                            //      - requeued sync of NC <x> fails here, i.e. goto loop...
                            //
                            // Thus, we break the loop here by just notifying the admin
                            // that they need to take action to correct the critical failure to
                            // sync the schema.

                            // Log so the admin knows what's going on.
                            LogEvent8(DS_EVENT_CAT_REPLICATION,
                                      DS_EVENT_SEV_ALWAYS,
                                      DIRLOG_REPLICATION_SKIP_REQUEUE,
                                      szInsertWC(pNC->StringName),
                                      szInsertUUID(puuidDsaObj),
                                      szInsertUL(ulSyncFailure),
                                      szInsertWin32Msg(ulSyncFailure),
                                      NULL, NULL, NULL, NULL
                                      );

                        }
                        else {
                            //
                            // requeue sync for the NC for which we aborted the sync due to schema mismatch
                            //
                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_ASYNC_OP |
                                DRS_SYNC_REQUEUE |
                                (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }

                        break;

                    default:

                        // Unexpected error, log it.

                        LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ulSyncFailure);

                        // Warning! Fall through to resync NC

                    case DRAERR_Busy:

                        // No need to log these.

                        // If this is an asynchronous synchronize, and not retried,
                        // requeue the operation to run again. (If the
                        // synchronize is sychronous, it's the caller's
                        // responsibility to try again)

                        if ( (ulOptions & DRS_ASYNC_OP)
                             && !(ulOptions & DRS_SYNC_REQUEUE)) {

                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_SYNC_REQUEUE
                                | DRS_ASYNC_OP
                                | (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }
                        break;

                    case DRAERR_Preempted:

                        // No need to log these.

                        // If this is an asynchronous synchronize,
                        // requeue the operation to run again. (If the
                        // synchronize is sychronous, it's the caller's
                        // responsibility to try again)

                        if (ulOptions & DRS_ASYNC_OP) {

                            DirReplicaSynchronize(
                                pNC,
                                pszDSA,
                                puuidDsaObj,
                                DRS_ASYNC_OP
                                  | DRS_PREEMPTED
                                  | (ulOptions & REPSYNC_REENQUEUE_FLAGS));

                            // Don't trigger opposite sync until our sync is
                            // complete or we've given up.
                            fDoTwoWaySync = FALSE;
                        }
                        break;

                    case DRAERR_AbandonSync:

                        // We abandoned an initial sync because we
                        // weren't making progress, so reschedule it.
                        // Note that because of the special flag mask used here, the
                        // DRS_INIT_SYNC_NOW flag is preserved, where it generally
                        // isn't preserved in the other requeues.
                        Assert( ulOptions & DRS_ASYNC_OP );
                        Assert( ulOptions & DRS_INIT_SYNC_NOW );

                        DirReplicaSynchronize(
                            pNC,
                            pszDSA,
                            puuidDsaObj,
                            DRS_ASYNC_OP
                            | DRS_ABAN_SYNC
                            | (ulOptions &
                               REPSYNC_REENQUEUE_FLAGS_INIT_SYNC_CONTINUED));

                        // The purpose of this flag is to detect when we are truely
                        // continuing an init sync (and preserving the INIT_SYNC_NOW
                        // flag), instead of terminating the init sync (throwing away
                        // the flag) and requeuing a normal sync.
                        fRequeueOfInitSync = TRUE;
                        // Don't trigger opposite sync until our sync is
                        // complete or we've given up.
                        fDoTwoWaySync = FALSE;

                        break;
                    }
                } else {
                    // General error, log it.

                    LogSyncFailure (pTHS, RL_POTHERDRA(pRepsFromRef), pNC, ret);

                    // Poor man's negative rpc binding cache
                    // Used to prevent queue overload
                    if (!fBindSuccess) {
                        // Sync failed and we have no binding handle
                        // Assume this is a NC-wide problem
                        // Remove other syncs from this server from the queue
                        // so we don't waste time trying this server again and again.
                        DPRINT3(1,"Failed to sync NC %ws, error %d, source %ws: purging from queue\n",
                                pNC->StringName,
                                ret,
                                TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef)));

                        DraRemovePeriodicSyncsFromQueue( &pRepsFromRef->V1.uuidDsaObj );
                    }

                    // Note that we do not retry here. Retriable errors are returned using the
                    // ulSyncFailure mechanism above. All the known retry scenarios are handled
                    // there already. General errors here do not benfit from retrying since they
                    // are no more likely to work a second time and only generate extra work.
                }

                // During initial synchronizations, record whether we synced
                // successfully or encountered an error (such as RPC failure)
                // that means we should give up on this source.
                // We can tell whether this sync is actually an init sync because
                // the DRS_INIT_SYNC_NOW mode flag will be present.

                if (!fRequeueOfInitSync)
                {
                    InitSyncAttemptComplete(pNC, ulOptions,
                             ret ? ret : ulSyncFailure,
                             TransportAddrFromMtxAddrEx(RL_POTHERDRA(pRepsFromRef))
                        );
                }

            } // end of else RPC based replica, sync now.

            if (NULL != pmtxDSA) {
                THFreeEx(pTHS, pmtxDSA);
            }
        }

    } __finally {

        // If we had success, commit, else rollback

        if (pTHS->transactionlevel)
        {
            EndDraTransaction(!(ret || AbnormalTermination()));
        }
    }

    if (fDoTwoWaySync && !eServiceShutdown) {
        // Ask source to now replicate from us.  This is essentially an
        // immediate notification to one specific machine, where that machine
        // generally does not otherwise receive notifications from us (i.e.,
        // because it's in another site).  This functionality is to handle
        // the branch office connecting through the Internet -- see bug 292860.
        DWORD err;
        LPWSTR pszServerName = TransportAddrFromMtxAddrEx(
                                    RL_POTHERDRA(pRepsFromRef));

        Assert(!(ulOptions & DRS_SYNC_ALL));
        Assert(!(ulOptions & DRS_MAIL_REP));
        Assert(NULL != pRepsFromRef);

        err = I_DRSReplicaSync(pTHS,
                               pszServerName,
                               pNC,
                               NULL,
                               &gAnchor.pDSADN->Guid,
                               (DRS_ASYNC_OP
                                | DRS_TWOWAY_SYNC
                                | DRS_UPDATE_NOTIFICATION
                                | (RepFlags & DRS_WRIT_REP)));
        if (err) {
            // If a readonly replica gets the TWOWAY_SYNC flag, it may notify a
            // readonly source.  Ignore resulting errors.
            if ( (err != DRAERR_NoReplica) || (ulOptions & DRS_WRIT_REP) ) {
                // Log notification failure.
                LogEvent8(DS_EVENT_CAT_REPLICATION,
                          DS_EVENT_SEV_BASIC,
                          DIRLOG_DRA_NOTIFY_FAILED,
                          szInsertMTX(RL_POTHERDRA(pRepsFromRef)),
                          szInsertDN(pNC),
                          szInsertWin32Msg(err),
                          szInsertWin32ErrCode(err),
                          NULL, NULL, NULL, NULL );
            }
        }
    }

    // If we had a sync failure but were otherwise successful,
    // return sync failure.

    if ((!ret) && ulSyncFailure) {
        ret = ulSyncFailure;
    }
    if ((!ret) && fAsyncStarted) {
        // Not this fAsyncStarted flag and thus this error is only
        // returned if the ASYNC flag is _not_ specified and the
        // operation was inheriantly asynchronous, such as mail
        // based replication.
        ret = ERROR_DS_DRA_REPL_PENDING;
    }

    LogAndTraceEvent(TRUE,
             DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_EXTENSIVE,
             DIRLOG_DRA_REPLICASYNC_EXIT,
             EVENT_TRACE_TYPE_END,
             DsGuidReplicaSync,
             szInsertUL(ret),NULL,NULL,NULL,NULL,NULL,NULL,NULL);

    return ret;
} // DRA_ReplicaSync


void
draConstructGetChgReq(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pNC,
    IN  REPLICA_LINK *              pRepsFrom,
    IN  UPTODATE_VECTOR *           pUtdVec             OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSet     OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSetEx   OPTIONAL,
    IN  ULONG                       ulOptions,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pMsgReq
    )
/*++

Routine Description:

    Construct a "GetNCChanges" request from the current replication state.

    Common pre-processing or setup for sending a get changes request.

    This code serves asynchonous mail replicas only at present, but could be
    combined in the future with the RPC-based path.

    This code performs similar setup to what happens for the RPC case, see
    line 340-360, and the setup in ReplicateNC.

Arguments:

    pNC (IN) - NC to replicate.

    pRepsFrom (IN) - repsFrom state corresponding to the source DSA.

    pUtdVec (IN) - Current UTD vector for this NC.

    ulOptions (IN) - Caller-supplied options to supplement those embedded in
        the repsFrom.

    pMsgReq (OUT) - The constructed request message.

Return Values:

    None.

--*/
{
    Assert(NULL != pNC);
    Assert(NULL != pRepsFrom);
    Assert(NULL != pMsgReq);

    memset(pMsgReq, 0, sizeof(*pMsgReq));

    VALIDATE_REPLICA_LINK_VERSION(pRepsFrom);

    pMsgReq->ulFlags = pRepsFrom->V1.ulReplicaFlags;

    // Or in any special flags from caller.
    pMsgReq->ulFlags |= ulOptions & GETCHG_REQUEST_FLAGS;

    // Note, ulFlags and ulOptions contain different sets, as follows:
    // ulOptions - What the caller requested, may be >= GETCHG_REQUEST_FLAGS
    // ulFlags - Persistant replica flags, <= RFR_FLAGS,
    //    plus Options, only GETCHG_REQUEST_FLAGS

    if (pMsgReq->ulFlags & DRS_MAIL_REP) {
        // Use ISM transport for replication.
        pMsgReq->cMaxObjects = gcMaxAsyncInterSiteObjects;
        pMsgReq->cMaxBytes   = gcMaxAsyncInterSiteBytes;

        // Note that we currently always request ancestors for
        // mail-based replication, just as Exchange did.  We should be able to
        // eliminate this requirement, though, by properly handling the "missing
        // parent" case in the mail-based code.  The easiest way to do this
        // would be to better integrate the mail- and RPC-based processing of
        // inbound replication messages, in which case the mail-based code would
        // acquire the same handling for this case as the RPC-based code.
        pMsgReq->ulFlags |= DRS_GET_ANC;
        // Tell the source to check for a reps-to, and if so, remove it
        Assert( pMsgReq->ulFlags & DRS_NEVER_NOTIFY );
    }
    else {
        // Use RPC transport for replication.
        Assert( !"This routine is not shared with the RPC path yet" );

        // Packet size will be filled in by I_DRSGetNCChanges().
        Assert(0 == pMsgReq->cMaxObjects);
        Assert(0 == pMsgReq->cMaxBytes);

        // Check reps-to's if caller wants us to, only for non-mail
        pMsgReq->ulFlags |= (ulOptions & DRS_ADD_REF);
    }

    // If we want to sync from scratch, set sync to usn start point.
    if (pMsgReq->ulFlags & DRS_FULL_SYNC_NOW) {
        // Sync from scratch.
        pMsgReq->usnvecFrom = gusnvecFromScratch;
        pMsgReq->ulFlags |= DRS_FULL_SYNC_IN_PROGRESS;

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_DRA_USER_REQ_FULL_SYNC,
                 szInsertDN(pNC),
                 szInsertUUID(&(pRepsFrom->V1.uuidDsaObj)),
                 szInsertHex(pMsgReq->ulFlags));
    }
    else {
        // Sync picking back up where we left off.
        pMsgReq->usnvecFrom = pRepsFrom->V1.usnvec;

        if (!(pMsgReq->ulFlags & DRS_FULL_SYNC_IN_PROGRESS)) {
            // Send source our current up-to-date vector to use as a filter.
            pMsgReq->pUpToDateVecDest = pUtdVec;
        } else {
            // UTDVEC is null
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_VERBOSE,
                     DIRLOG_DRA_FULL_SYNC_CONTINUED,
                     szInsertDN(pNC),
                     szInsertUUID(&(pRepsFrom->V1.uuidDsaObj)),
                     szInsertHex(pMsgReq->ulFlags));
        }
    }

    // Request the nc size on the first packet of a full sync series
    if (0 == memcmp( &pMsgReq->usnvecFrom, &gusnvecFromScratch,
                     sizeof(USN_VECTOR) )) {
        pMsgReq->ulFlags |= DRS_GET_NC_SIZE;
    }

    pMsgReq->uuidDsaObjDest    = gAnchor.pDSADN->Guid;
    pMsgReq->uuidInvocIdSrc    = pRepsFrom->V1.uuidInvocId;
    pMsgReq->pNC               = pNC;
    pMsgReq->pPartialAttrSet   = (PARTIAL_ATTR_VECTOR_V1_EXT *) pPartialAttrSet;
    pMsgReq->pPartialAttrSetEx = (PARTIAL_ATTR_VECTOR_V1_EXT *) pPartialAttrSetEx;

    if ((NULL != pMsgReq->pPartialAttrSet)
         || (NULL != pMsgReq->pPartialAttrSetEx)) {
        // send mapping table if we send any attr list.
        pMsgReq->PrefixTableDest = ((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
        if (AddSchInfoToPrefixTable(pTHS, &pMsgReq->PrefixTableDest)) {
            DRA_EXCEPT(DRAERR_SchemaInfoShip, 0);
        }
    }
}


void
draReportSyncProgress(
    THSTATE *pTHS,
    DSNAME *pNC,
    LPWSTR pszSourceServer,
    BOOL fMoreData,
    DRA_REPL_SESSION_STATISTICS *pReplStats
    )

/*++

Routine Description:

Report on the progress of the sync.

This routine may be called from either the mail-based code (dramail/
ProcessUpdReplica), or the rpc-based code (drancrep/ReplicateNC).

This routine also updates the performance counter variable
DRASyncFullRemaining, which is the number of remaining objects until the
completion of the full sync.

The caller of this function may or may not know the context in which the
latest batch of objects was received.  Incremental or full sync?  First
message, middle or last message?  The mail-based code is organized more like
a asynchonrous completion routine and doesn't have alot of context about
the messages that preceeded it.

Note that the count of objects returned includes both creations and updates.
In the case of a full sync, we should only count the creations when calculating
how many objecs we have received toward the total nc size.

Note, we do not use draGetNCSize to calculate the number of objects received
in this NC because that call does not scale well.

One final note. The performance counter should really be nc specific. If more than one
full sync is going on, the counter will alternate between whichever nc is being processed.
A better design would store the estimated size, counts, and remaining objects in the
reps-from.

Arguments:

    pNC - Naming context
    pSourceServer - transport server name of source
    pReplStats - Replication session statistics


Return Value:

    None

--*/

{
    ULONG remaining;

    // If no objects received, don't bother
    if ( (pReplStats->ObjectsReceived == 0) &&
         (pReplStats->ValuesReceived == 0) ) {
        return;
    }

    pReplStats->ulTotalObjectsReceived += pReplStats->ObjectsReceived;
    pReplStats->ulTotalObjectsCreated += pReplStats->ObjectsCreated;
    pReplStats->ulTotalValuesReceived += pReplStats->ValuesReceived;
    pReplStats->ulTotalValuesCreated += pReplStats->ValuesCreated;

    // If we have no estimate for number of objects at source, use created
    // If the estimate was too small, improve it

    if (pReplStats->SourceNCSizeObjects < pReplStats->ulTotalObjectsCreated) {
        pReplStats->SourceNCSizeObjects = pReplStats->ulTotalObjectsCreated;
    }

    if (pReplStats->SourceNCSizeValues < pReplStats->ulTotalValuesCreated) {
        pReplStats->SourceNCSizeValues = pReplStats->ulTotalValuesCreated;
    }

    // Log event
    LogEvent8( DS_EVENT_CAT_REPLICATION,
               DS_EVENT_SEV_EXTENSIVE,
               DIRLOG_DRA_UPDATENC_PROGRESS,
               szInsertDN(pNC),
               szInsertWC(pszSourceServer),
               szInsertUL(pReplStats->ulTotalObjectsReceived),
               szInsertUL(pReplStats->ulTotalObjectsCreated),
               szInsertUL(pReplStats->SourceNCSizeObjects),
               szInsertUL(pReplStats->ulTotalValuesReceived),
               szInsertUL(pReplStats->SourceNCSizeValues),
               szInsertUL(pReplStats->ulTotalValuesCreated)
               );

    // DCPROMO progress reporting hook
    // Do we want to report objects created or objects received here?
    // The source nc size is the maximum objects created
    // We could receive 100 objects, but create none because they are redundant
    if ( gpfnInstallCallBack ) {
        WCHAR numbuf1[20], numbuf2[20];
        WCHAR numbuf3[20], numbuf4[20];
        _itow( pReplStats->ulTotalObjectsCreated, numbuf1, 10 );
        _itow( pReplStats->SourceNCSizeObjects, numbuf2, 10 );
        _itow( pReplStats->ulTotalValuesCreated, numbuf3, 10 );
        _itow( pReplStats->SourceNCSizeValues, numbuf4, 10 );

        if ( (pTHS->fLinkedValueReplication) &&
             (pReplStats->SourceNCSizeValues) ) {
            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATE_PROGRESS_VALUES,
                                     pNC->StringName,
                                     numbuf1,
                                     numbuf2,
                                     numbuf3,
                                     numbuf4 );
        } else {
            SetInstallStatusMessage( DIRMSG_INSTALL_REPLICATE_PROGRESS,
                                     pNC->StringName,
                                     numbuf1,
                                     numbuf2,
                                     NULL,
                                     NULL );
        }
    }

    // How many objects are left?
    if ( (pReplStats->SourceNCSizeObjects > pReplStats->ulTotalObjectsCreated) &&
         fMoreData ) {
        remaining = pReplStats->SourceNCSizeObjects -
            pReplStats->ulTotalObjectsCreated;
    } else {
        remaining = 0;
    }

    // Performance counter hook
    ISET(pcDRASyncFullRemaining, remaining);

    // Debug output hook
    DPRINT8( 0, "DS FullSync: nc:%ws from:%ws\n"
             "Objects received:%d applied:%d source:%d\n"
             "Values received:%d applied:%d source:%d\n",
             pNC->StringName, pszSourceServer,
             pReplStats->ulTotalObjectsReceived,
             pReplStats->ulTotalObjectsCreated,
             pReplStats->SourceNCSizeObjects,
             pReplStats->ulTotalValuesReceived,
             pReplStats->ulTotalValuesCreated,
             pReplStats->SourceNCSizeValues );

    // Counts for this pass has been reported. Clear them for the next pass.

    pReplStats->ObjectsReceived = 0;
    pReplStats->ObjectsCreated = 0;
    pReplStats->ValuesReceived = 0;
    pReplStats->ValuesCreated = 0;

} /* draReportSyncProgress */

DWORD
ReplicateObjectsFromSingleNc(
    DSNAME *                 pdnNtdsa,
    ULONG                    cObjects,
    DSNAME **                ppdnObjects,
    DSNAME *                 pNC
    )
/*++

Routine Description:

    This routine is just basically supposed to sync/get the 
    objects that are created.
    
    This code was originally used to get the cross-ref and 
    new DSA object during dcpromo, As a result THIS CODE
    MUST WORK DURING INSTALL!
    
    Note: This routine requites RPC/IP connectivity to the
    pdnNtdsa server.
    
Arguments:
                                        
    pdnNtdsa - The DN of the server's NtdsNtdsa object that
        we wish to replicate these new objects from.
    cObjects - Number of objects in ppdnObjects.
    ppdnObjects - Array of pointers to DNs of the objects we
        need to replicate.  DNs can be string name, or GUID
        only specified.
    pNC - The NC these objects are in.  Currently, we only
        support getting objects in a single NC.
        
Return Value:

    Win32 Error, as returned by the various DRA APIs.

--*/
{
    THSTATE *                pSaveTHS;
    DWORD                    dwErr = ERROR_SUCCESS;
    REPLTIMES                repltimes;
    ULONG                    i;
    ULONG                    iTry = 1;
    ULONG                    nTries = 8;
    WCHAR *                  wszNamingFsmoDns;
    DWORD                    dwExtErr = 0;
    ULONG                    cTries = 5;
    ULONG                    cTriesLeft;
    DSNAME *                 pdnGetMe;
    ULONG                    iObject;
    ULONG                    ulBackoff;

    Assert(cObjects >= 1);
    Assert(gAnchor.pConfigDN);
    Assert(gAnchor.pDMD);

    Assert(pTHStls->pDB == NULL); // Ensure we don't leave with a transaction open.

    //
    //   First ... try to get the objects via DraReplicateSingleObject()
    //
    for (iObject = 0; iObject < cObjects; iObject++) {

        Assert(ppdnObjects[iObject]);
        ulBackoff = 250; // 1/4 of a second seems like plenty of time.
        cTriesLeft = cTries;
        do {

            if (cTriesLeft < cTries) {
                DPRINT1(1, "Failed to apply update from DraReplicateSingleObject(), backing off %d milliseconds\n", ulBackoff);
                Sleep(ulBackoff);
                ulBackoff *= 2; // Back off exponentially next time.
            }

            dwExtErr = EXOP_ERR_PARAM_ERR;
            dwErr = DraReplicateSingleObject(pTHStls, pdnNtdsa, ppdnObjects[iObject], pNC, &dwExtErr);
            Assert((dwErr != ERROR_SUCCESS || 
                    dwExtErr == EXOP_ERR_SUCCESS || 
                    dwExtErr == EXOP_ERR_UNKNOWN_OP) &&
                   "Unexpected error from DraReplicateSingleObject(), email DsRepl");
            
            Assert(pTHStls->pDB == NULL);

            cTriesLeft--;
        } while (cTriesLeft &&
                  (dwErr == ERROR_DS_DATABASE_ERROR ||
                   dwErr == ERROR_DS_BUSY) );

        if (dwErr != ERROR_SUCCESS || dwExtErr != EXOP_ERR_SUCCESS) {
            break;
        }
    }

    //
    // If we had an unexpected error log an event.
    //
    if (dwErr != ERROR_SUCCESS || 
        (dwExtErr != EXOP_ERR_SUCCESS &&
         dwExtErr != EXOP_ERR_UNKNOWN_OP)) {
        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_MINIMAL,
                  DIRLOG_REPLICATE_SINGLE_OBJECT_FAILED,
                  szInsertDN(pdnNtdsa),
                  szInsertDN(ppdnObjects[iObject]),
                  szInsertWin32Msg(dwErr),
                  szInsertUL(dwExtErr),
                  NULL, NULL, NULL, NULL);
    }

    //
    // Second ... if we failed try to get the objects via DirReplica*() APIs.
    //

    if (dwErr != ERROR_SUCCESS || dwExtErr != EXOP_ERR_SUCCESS) {

        // Fail over to Win2k code.  This can be removed when we no longer
        // require Win2k compatibility.

        // This most like means that either the server was unavailable, or 
        // the source/target server didn't understand the extended operation
        // because they're a Win2k server not a Whistler or .NET Server, so
        // fail back to the Win2k code.
        
        DPRINT2(0, "Failing back to win2k method of replicating cross-ref/DSA object.\ndwErr = %d, dwExtErr = %d\n", dwErr, dwExtErr);

        Assert(gAnchor.pwszRootDomainDnsName);
        wszNamingFsmoDns = GuidBasedDNSNameFromDSName(pdnNtdsa);
        if (wszNamingFsmoDns == NULL) {
            Assert(!"This call to GuidBasedDNSNameFromDSName() really shouldn't fail. Email DsRepl");
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        memset(&repltimes, 0, sizeof(repltimes));
        for (i=0;i< 84;i++){
            repltimes.rgTimes[i] = 0xff;        // Every 15 minutes
        }

        // ---------------------------------------------------------------
        // First, try to add the replica.
        pSaveTHS = THSave();
        __try{

            dwErr = DirReplicaAdd(pNC,
                                  NULL,
                                  NULL,
                                  wszNamingFsmoDns,
                                  NULL,
                                  &repltimes,
                                  DRS_DISABLE_PERIODIC_SYNC | DRS_WRIT_REP);

            DPRINT2(2, "Adding replica to '%S' returned %u\n",
                    wszNamingFsmoDns,
                    dwErr);

        } __finally {

            THDestroy();
            THRestore(pSaveTHS);

        }

        if(dwErr != DRAERR_DNExists){
            // Whether error or success return, as long as it wasn't 
            // DNExists.
            // If it was an error, we couldn't add the replica.
            // If it was success, we did a ReplicateNC in DirReplicaAdd().
            // If it was DNExists, the repsFrom exists, but we didn't
            //   sync, so fall through and sync.

            return(dwErr);
        }
        // Fall through and do a sync, because the DirReplicaAdd()
        // didn't do the sync if it returned DRAERR_DNExists().

        // ---------------------------------------------------------------
        // Second, try to do a sync
        pSaveTHS = THSave();
        __try{

            dwErr = DirReplicaSynchronize(pNC,
                                          wszNamingFsmoDns,
                                          NULL,
                                          DRS_SYNC_BYNAME);

            DPRINT3(2, "Synchronizing NC '%S' from server '%S' returned %u\n",
                    pNC->StringName,
                    wszNamingFsmoDns,
                    dwErr);

            // We set up the DirReplicaAdd() just so we wouldn't be able
            // to get this mail based replica error.
            Assert(dwErr != ERROR_DS_DRA_REPL_PENDING);

        } __finally {

            THDestroy();
            THRestore(pSaveTHS);

        }

    } // end if/else Whistler/Win2k path ...
    
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draserv.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       draserv.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

Server-side RPC entrypoints for the DRS functions


Author:

    DS group

Environment:

Notes:

Context handle is defined in ds\src\dsamain\include\drautil.h

Our context handles are not serialized (see drs.acf), but we must synchronize
concurrent accesses to the context in order to free it.  This is done in 
IDL_DRSUnBind.

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation
#include <filtypes.h>
#include <winsock2.h>
#include <lmaccess.h>                   // UF_* constants
#include <crypt.h>                      // password encryption routines
#include <cracknam.h>

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include <prefix.h>
#include <dsconfig.h>
#include <gcverify.h>
#include <ntdskcc.h>

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "drauptod.h"
#include "dramail.h"
#include "mappings.h"
#include <samsrvp.h>                    // for SampAcquireWriteLock()
#include "sspi.h"                       // SECPKG_CRED_INBOUND
#include "kerberos.h"                   // MICROSOFT_KERBEROS_NAME_A
#include "pek.h"
#include <xdommove.h>                   // cross domain move helpers
#include <drameta.h>                    // META_STANDARD_PROCESSING
#include <taskq.h>
#include "drarpc.h"
#include <ismapi.h>                     // For I_ISMQuerySitesByCost
#include "dnsresl.h"
#include "dsutil.h"

#include <fileno.h>
#define  FILENO FILENO_DRASERV

const GUID g_guidNtdsapi = NtdsapiClientGuid;

// enable X forest version without being in Whistler mode
DWORD gEnableXForest = 0;

extern HANDLE hsemDRAGetChg;

// Wait 15 to 30 seconds for the schema cache to reloaded.
DWORD gOutboundCacheTimeoutInMs = 15000;

// Wait for thread slot in get changes. 5 minutes.

#if DBG
#define DRAGETCHG_WAIT (1000*60*1)
#else
#define DRAGETCHG_WAIT (1000*60*5)
#endif

/* Macro to force alignment of a buffer.  Asumes that it may move pointer
 * forward up to 7 bytes.
 */
#define ALIGN_BUFF(pb)  pb += (8 - ((DWORD)(pb) % 8)) % 8
#define ALIGN_PAD(x) (x * 8)

// List of all outstanding client contexts (and a critsec to serialize access).
LIST_ENTRY gDrsuapiClientCtxList;
CRITICAL_SECTION gcsDrsuapiClientCtxList;
BOOL gfDrsuapiClientCtxListInitialized = FALSE;
DWORD gcNumDrsuapiClientCtxEntries = 0;

VOID
drsReferenceContext(
    IN DRS_HANDLE hDrs
    )

/*++

Routine Description:

    Add a reference to the context

Arguments:

    hDrs - context handle

Return Value:

    VOID -
    
    because of the position this function has in all RPC server side calls,
    it shouldn't except.

--*/

{
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    
    // Account for another caller using the context
    InterlockedIncrement( &(pCtx->lReferenceCount) );

    DPRINT2( 3, "drsReferenceContext 0x%p, after = %d\n",
        pCtx, pCtx->lReferenceCount );

    pCtx->timeLastUsed = GetSecondsSince1601();

    // Move this context to the end of the list (thereby maintaining ascending
    // sort by last use).
    EnterCriticalSection(&gcsDrsuapiClientCtxList);
    __try {
        RemoveEntryList(&pCtx->ListEntry);
        InsertTailList(&gDrsuapiClientCtxList, &pCtx->ListEntry);
    }
    __finally {
        LeaveCriticalSection(&gcsDrsuapiClientCtxList);
    }

} /* drsReferenceContext */

VOID
drsDereferenceContext(
    IN DRS_HANDLE hDrs
    )

/*++

Routine Description:

Remove a reference to a context.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    LONG lNewValue;

    lNewValue = InterlockedDecrement( &(pCtx->lReferenceCount) );
    Assert( lNewValue >= 0 );

    DPRINT2( 3, "drsDereferenceContext 0x%p, after = %d\n", pCtx, lNewValue );
} /* drsDereferenceContext */

BOOL
IsEnterpriseDC(
              IN THSTATE *        pTHS,
              OUT DWORD *         pdwError )
/*++

Routine Description:

    Verify if the caller is an enterprise DC.

Arguments:

    pTHS (IN) - Thread state;

    pdwError (OUT) - The error code if access is denied.

Return Values:

    TRUE - Access granted.

    FALSE - Access denied.

--*/

{

    SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pEnterpriseControllersSid = NULL;
    BOOL                        fFound = FALSE;
    NTSTATUS                    NtStatus;

    DPRINT(3,"IsEnterpriseDC entered.\n");

    *pdwError = 0;

    //make SID from RID
    NtStatus = RtlAllocateAndInitializeSid( &ntAuthority,
                                            1,
                                            SECURITY_ENTERPRISE_CONTROLLERS_RID,
                                            0, 0, 0, 0, 0, 0, 0,
                                            &pEnterpriseControllersSid );

    if ( NtStatus != ERROR_SUCCESS )
    {
        *pdwError = RtlNtStatusToDosError(NtStatus);
        goto finished;
    }

    // check group membership
    *pdwError = CheckGroupMembershipAnyClient(pTHS, NULL, &pEnterpriseControllersSid, 1, &fFound);

finished:
    //
    // if not found, and no error code is set,
    // set it to ERROR_ACCESS_DENIED
    //

    if (!fFound && (0 == *pdwError) ) 
    {
        *pdwError = ERROR_ACCESS_DENIED;
    }

    //
    // clean up
    //

    if (pEnterpriseControllersSid)
    {
        RtlFreeSid(pEnterpriseControllersSid);
    }

    DPRINT1(3,"IsEnterpriseDC returns %s.\n", fFound?"TRUE":"FALSE");

    return fFound;
}

// the _Validate functions should only return DRAERR_Success or DRAERR_InvalidParameter, for
// ease of translation into regular ERROR_* values.

__inline ULONG
LPSTR_Validate(
    LPCSTR         pszInput,
    BOOL           fNullOkay
    ) 
/*++

Routine Description:

    Validate a string as input.

Arguments:

    pszInput - string to validate

    fNullOkay - is it okay for pszInput to be NULL?  (Note that
      this is different that the empty string, ie one
      character which is NULL - the empty string is
      never allowed by this function).

Return Values:

    DRAERR_Success if it validates, DRAERR_* otherwise.

--*/
{
    ULONG ret = DRAERR_Success;

    if(((!fNullOkay) && (pszInput==NULL)) || ((pszInput!=NULL) && (pszInput[0]=='\0'))) {
   ret = DRAERR_InvalidParameter;
    }

    return ret;
}


ULONG
LPWSTR_Validate(
    LPCWSTR         pszInput,
    BOOL            fNullOkay
    ) 
/*++

Routine Description:

    Validate a string as input.

Arguments:

    pszInput - string to validate

    fNullOkay - is it okay for pszInput to be NULL?  (Note that
      this is different that the empty string, ie one
      character which is NULL - the empty string is
      never allowed by this function).

Return Values:

    DRAERR_Success if it validates, DRAERR_* otherwise.

--*/
{
    ULONG ret = DRAERR_Success;

    if(((!fNullOkay) && (pszInput==NULL)) || ((pszInput!=NULL) && (pszInput[0]==L'\0'))) {
   ret = DRAERR_InvalidParameter;
    }

    return ret;
}

__inline ULONG 
DSNAME_Validate(
    DSNAME * pDN,
    BOOL     fNullOkay
    )
/*++

Routine Description:

    Validate a DSNAME as input.

Arguments:

    pDN - DSNAME to validate

    fNullOkay - is it okay for pDN to be NULL?
    
    DSNAME struct:
    
    typedef struct _DSNAME {
   ULONG structLen;
   RANGE(0,MAX_NT4_SID_SIZE) ULONG SidLen;
   GUID Guid;               
   NT4SID Sid;              
   RANGE(0,MAX_WCHAR_IN_DSNAME) ULONG NameLen;
   STRING_SIZE_IS(NameLen+1) WCHAR StringName[VAR_SIZE_ARRAY];
    } DSNAME;

Return Values:

    DRAERR_Success if it validates, DRAERR_* otherwise.
*/
{
    ULONG ret = DRAERR_Success;

    if ((pDN!=NULL) && (pDN->structLen != DSNameSizeFromLen(pDN->NameLen))) {
   // some legitimate clients - including at least I_DrsGetMemberships do this to us
   // so we don't want to reject - so instead, let's just fix it. 
   pDN->structLen = DSNameSizeFromLen(pDN->NameLen);
    }

    if ((pDN!=NULL) && (pDN->SidLen > MAX_NT4_SID_SIZE)) {
   // some legitimate clients - including win2k do this to us
   // so we can't reject, but they also don't use the sid field (how could they?)
   // so we'll invalidate the sid - we don't want malicious clients to use this 
   pDN->SidLen=0;
   memset(&(pDN->Sid), 0, MAX_NT4_SID_SIZE);
    }

    if ((!fNullOkay) && (pDN==NULL)) {
   ret = DRAERR_InvalidParameter; 
    }

    if ((pDN!=NULL) && (pDN->NameLen!=0) && (pDN->StringName[pDN->NameLen]!=L'\0')) {
   // Seperate assert here to catch this condition.
   Assert(!"Dsname isn't NULL terminated!");
   ret = DRAERR_InvalidParameter;
    }

    // SidLen - Range does the work
    // StringName - If NameLen is 0, this could be NULL
    //              Also, string name can contain any symbol, don't validate.

    return ret;
}

__inline ULONG
ENTINF_Validate(
    ENTINF * pEnt
    )
/*++

Routine Description:

    Validate an ENTINF as input.

Arguments:

    pEnt - ENTINF to validate
    
    ENTINF struct:
    typedef struct _ENTINF
    {
   DSNAME       *pName;                // Object name and identity
   ULONG            ulFlags;           // Entry flags
   ATTRBLOCK        AttrBlock;         // The attributes returned.
    } ENTINF;

Return Values:

    DRAERR_Success if it validates, DRAERR_* otherwise.

*/
{
    return DSNAME_Validate(pEnt->pName, FALSE);
}

__inline ULONG
ENTINFLIST_Validate(
    ENTINFLIST * pEntInf
    )
/*++

Routine Description:

    Validate an ENTINFLIST as input.

Arguments:

    pEntInf - ENINFLIST to validate
    
    ENTINFLIST struct:
    typedef struct _ENTINFLIST
    {
   UNIQUE struct _ENTINFLIST   *pNextEntInf;  
   ENTINF           Entinf;            // information about this entry
    } ENTINFLIST;
    

Return Values:

    DRAERR_Success if it validates, DRAERR_* otherwise.
*/
{
    ULONG ret = DRAERR_Success;

    while ((pEntInf!=NULL) && (ret==DRAERR_Success)) {
   ret = ENTINF_Validate(&(pEntInf->Entinf));
   pEntInf = pEntInf->pNextEntInf;
    }

    return ret;
}

VOID
DRS_ValidateInput(
    THSTATE *  pTHS,
    DRS_HANDLE hDrs,
    RPCCALL    rpcCall
    )
/*++

Routine Description:

    The generic validation routine for *all* drsuapi server rpc functions.
    
    THIS ROUTINE IS REQUIRED FOR ALL DRSUAPI SERVER RPC FUNCTIONS.

Arguments:

   pTHS -
   hDrs - context handle passed to the rpc function
   rpcCall - what rpc function made this call

Return Values:

    None - excepts on validation error.
*/
{
    ULONG ret = DRAERR_Success;

    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    DRS_EXTENSIONS * pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;
    BOOL fIsNtdsapiClient;

    // Unbind doesn't have a thread state.
    Assert((rpcCall==IDL_DRSUNBIND) || pTHS);

    ///////////
    // Security
    ///////////

    // validate handle (if it's ref for all calls, why are we checking for NULL?  got me.  "secure" coding
    // with rpc requires it.)  
    if (NULL == hDrs) {
        // Raise as exception code ERROR_INVALID_HANDLE rather than
        // DSA_EXCEPTION, etc. as the exception code gets propagated to the
        // client side.
        RaiseDsaException(ERROR_INVALID_HANDLE, 0, 0, FILENO, __LINE__,
                          DS_EVENT_SEV_MINIMAL);
    }

    //////////////////////////
    // Server State Validation
    //////////////////////////

    // we don't care about extensions during an unbind (also, unbind doesn't have a thread state, so
    // don't use pTHS outside of this block.
    if (rpcCall!=IDL_DRSUNBIND) {
   // First - check server DRS extensions.
   fIsNtdsapiClient = (0 == memcmp(&pCtx->uuidDsa,
               &g_guidNtdsapi,
               sizeof(GUID)));

   if (   // Not an NTDSAPI client.
       !fIsNtdsapiClient
       && // Our local DRS extensions have changed since the client DC bound.
       ((pCtx->extLocal.cb != pextLocal->cb)
        || (0 != memcmp(pCtx->extLocal.rgb,
              pextLocal->rgb,
              pCtx->extLocal.cb)))) {
       // Force the client DC to rebind so that it picks up our recent DRS
       // extension changes.  Note that we don't force NTDSAPI clients to
       // re-bind since they're usually not very interested in our extensions
       // bits and we don't control their rebind logic (i.e., they might just
       // error out on this error rather than attempt to rebind).
       //
       // Note that it's important that we raise an exception that reaches the
       // RPC exception handler (outside of our code) so that an exception is
       // raised on the client side.  This causes this condition to be seen as
       // a communications error (which it is, more or less).  Simply
       // returning an error would be seen by the client as a failure in the
       // DRS RPC function being invoked by the client and would not result in
       // a rebind.
       //
       // Raise as exception code ERROR_DS_DRS_EXTENSIONS_CHANGED rather than
       // DSA_EXCEPTION, etc. as the exception code gets propagated to the
       // client side.
       DPRINT1(0, "Forcing rebind from %s because our DRS_EXTENSIONS have changed.\n",
          inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr)));

       RaiseDsaException(ERROR_DS_DRS_EXTENSIONS_CHANGED, 0, 0, FILENO,
               __LINE__, DS_EVENT_SEV_MINIMAL);
   }

   // next, check replication epoch.
   if (!fIsNtdsapiClient
       && (REPL_EPOCH_FROM_DRS_EXT(pextLocal)
      != REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote))) {
       // The replication epoch has changed (usually as the result of a domain
       // rename).  We are not supposed to communicate with DCs of other
       // epochs.
       DPRINT3(0, "RPC from %s denied - replication epoch mismatch (remote %d, local %d).\n",
          inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr)),
          REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote),
          REPL_EPOCH_FROM_DRS_EXT(pextLocal));

       if ((pTHS) && (IsEnterpriseDC(pTHS, &ret))) {
      // we only want to log this if it's actually a DC calling.  If a client is faking
      // and not using the ntdsapi guid, we don't want to log SEV_ALWAYS, otherwise 
      // it's a DOS attack and it can fill our drive with these messages.
      LogEvent(DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_ALWAYS,
          DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
          szInsertSz(inet_ntoa(*((IN_ADDR *) &pCtx->IPAddr))),
          szInsertUL(REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote)),
          szInsertUL(REPL_EPOCH_FROM_DRS_EXT(pextLocal)));
       }

       RaiseDsaException(ERROR_DS_DIFFERENT_REPL_EPOCHS,
               REPL_EPOCH_FROM_DRS_EXT(pextLocal)
               - REPL_EPOCH_FROM_DRS_EXT(&pCtx->extRemote),
               0, FILENO, __LINE__, DS_EVENT_SEV_MINIMAL);
   }
    }

    /////////////////////////
    // Other Tests/Validation
    /////////////////////////

    // Debug test only.
    RPC_TEST(pCtx->IPAddr, rpcCall); 

    return;
}

THSTATE * pGetDrsTHSTATE() 
/*++

Routine Description:

    Get a thread state for server side rpc calls.
    
    typically, we already have pTHStls, since RPC uses midl_thread_allocate
    to allocate our parameters, and midl_thread_allocate initializes pTHStls.
    unforetunately, RPC "optimizes" by sometimes re-using the wire buffers
    for parameters and not ever calling midl_thread_allocate.  Unfortunately
    for us, it's not knowable when and where this optimizing might get
    done, so we just can't count on having a thread state.  Many of our server side
    functions require a thread state, so if pTHStls doesn't exist, we'll 
    simply create one, just as RPC would.  The notification routines will
    take care of freeing the thread state we create here, just as they do
    when RPC creates it through midl_user_allocate.

Arguments:


Return Values:

    THSTATE or an exception is raised

--*/
{
    THSTATE * pTHS = pTHStls;
    if (pTHS==NULL) {
   pTHS = create_thread_state();
   if (pTHS==NULL) {
       // note that we want to throw the RPC memory error here to mimick
       // the case when rpc calls midl_user_allocate and we fail to create
       // a thread state in that function.
       RaiseDsaException(RPC_S_OUT_OF_MEMORY, 0, 0, FILENO,
               __LINE__, DS_EVENT_SEV_MINIMAL);
   }
    }
    return pTHS;
}

VOID
DRS_Prepare(
    THSTATE ** ppTHS,
    DRS_HANDLE hDrs,
    RPCCALL rpcCall
    )
/*++

Routine Description:

    Do initial preparation of a server side RPC call.  Set the thread state (if not
    already done so) and validate the context handle and server state.

Arguments:

    [IN,OUT] ppTHS - thread state (if it's NULL, it will be initialized)
    [IN] hDrs - context handle
    [IN] rpcCall - which server side call this is from.

Return Values:

    NONE

--*/
{
    Assert(ppTHS!=NULL);
    if (*ppTHS==NULL) {
   *ppTHS = pGetDrsTHSTATE();    
    } 
       
    Assert(*ppTHS==pTHStls);

    DRS_ValidateInput(*ppTHS, hDrs, rpcCall);
}

ULONG
ValidateSiteRDN(
    IN  LPCWSTR     str
    )
/*++

Routine Description:

    Validate a site RDN which was passed as input to IDL_DRSQuerySitesByCost.
    The string may not be NULL, may not have 0 length and may not have
    length greater than MAX_LENGTH. It may not contain '=' or ',' either.

    Note that if the site's DN is "CN=Foo,CN=Sites,CN=Configuration,...",
    the site's RDN is simply "foo".

Arguments:

    str: Unicode string to validate

Return Values:

    Raises an exception on failure - returns ULONG for compatibility.

--*/
{
    size_t         len;
    const WCHAR    EQUALS=L'=', COMMA=L',';
    const size_t   MAX_LENGTH=64;
    ULONG          ret = DRAERR_Success;

    // Check for null / empty strings
    if( NULL==str || 0==str[0] ) {
        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    // Check for strings that are too long
    len = wcslen( str );
    if( len>MAX_LENGTH ) {
        DRA_EXCEPT(ERROR_DS_NAME_TOO_LONG, 0);
    }

    // Check for invalid characters
    if( wcschr(str,EQUALS) || wcschr(str,COMMA) ) {
        DRA_EXCEPT(DRAERR_InvalidParameter, 0);
    }

    return ret;
}


ULONG
DRS_MSG_UPDREFS_V1_Validate(
    DRS_MSG_UPDREFS_V1 * pmsg
    )
/*
    typedef struct _DRS_MSG_UPDREFS_V1
    {
     [ref]  DSNAME *pNC;
     [ref] SZ pszDsaDest;
    UUID uuidDsaObjDest;
    ULONG ulOptions;
    }    DRS_MSG_UPDREFS_V1;
    */
{
    ULONG ret = DRAERR_Success;

    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    if (ret==DRAERR_Success) {
   ret = LPSTR_Validate(pmsg->pszDsaDest, FALSE);
    }

    return ret;
}

/////////////////////////////////////////////
// TEMPLATE NOTE:
// Create <Type>_Validate functions for all
// MIDL data types that need validation.  Any
// parent type which contains a child type
// which needs validation should have a validation
// function.
ULONG
DRS_MSG_REPSYNC_V1_Validate(
    DRS_MSG_REPSYNC_V1 * pmsg
    )

/*
Routine Description:

    Validate the DRS_MSG_REPSYNC_V1 data type.  The type definition in the  
    interface is:
    
    // TEMPLATE NOTE:  Be sure to include the type definition from the 
    // interface files.
    typedef struct _DRS_MSG_REPSYNC_V1
    {
    [ref]  DSNAME *pNC;
    UUID uuidDsaSrc;
    [unique]  SZ pszDsaSrc;
    ULONG ulOptions;
    }    DRS_MSG_REPSYNC_V1;

Arguments:

    msg

Return Values:

    DRAERR_Success if valid input, DRAERR_* otherwise.

    */
{
    ULONG ret = DRAERR_Success;

    // TEMPLATE NOTE:  All DSNAMEs must be validated.  
    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    // TEMPLATE NOTE:  Your specific validation below:
    if (ret==DRAERR_Success) {
   // if sourced, then we need one or the other or both
   if (!(pmsg->ulOptions & DRS_SYNC_ALL) && fNullUuid(&(pmsg->uuidDsaSrc)) && (DRAERR_Success != LPSTR_Validate(pmsg->pszDsaSrc,FALSE))) { 
       ret = DRAERR_InvalidParameter;
   }
    }

    if (ret==DRAERR_Success) {
   // Restrict out of process callers from setting reserved flags
   if (pmsg->ulOptions & (~REPSYNC_RPC_OPTIONS)) { 
       ret = DRAERR_InvalidParameter;
       DRA_EXCEPT(ret, 0);
   }
    }

    return ret;
}

ULONG
DRS_MSG_GETCHGREQ_V8_InputValidate(
    THSTATE * pTHS,
    DRS_MSG_GETCHGREQ_V8 * pmsg
    )
/*

typedef struct _DRS_MSG_GETCHGREQ_V8
    {
    UUID uuidDsaObjDest;
    UUID uuidInvocIdSrc;
    [ref]  PDSNAME pNC;
    USN_VECTOR usnvecFrom;
    [unique] UPTODATE_VECTOR_V1_WIRE *pUpToDateVecDest;
    ULONG ulFlags;
    ULONG cMaxObjects;
    ULONG cMaxBytes;
    ULONG ulExtendedOp;
    ULARGE_INTEGER liFsmoInfo;
    [unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSet;
    [unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSetEx;
    SCHEMA_PREFIX_TABLE PrefixTableDest;
    }    DRS_MSG_GETCHGREQ_V8;

*/
{
    ULONG ret = DRAERR_Success;
        
    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    return ret;

}

ULONG
DRS_MSG_GETCHGREQ_V5_InputValidate(
    THSTATE * pTHS,
    DRS_MSG_GETCHGREQ_V5 * pmsg
    )
/*

typedef struct _DRS_MSG_GETCHGREQ_V5
    {
    UUID uuidDsaObjDest;
    UUID uuidInvocIdSrc;
    [ref] PDSNAME pNC;
    USN_VECTOR usnvecFrom;
    [unique]  UPTODATE_VECTOR_V1_WIRE *pUpToDateVecDestV1;
    ULONG ulFlags;
    ULONG cMaxObjects;
    ULONG cMaxBytes;
    ULONG ulExtendedOp;
    ULARGE_INTEGER liFsmoInfo;
    }    DRS_MSG_GETCHGREQ_V5;

*/
{
    ULONG ret = DRAERR_Success;

    if (pTHS->fLinkedValueReplication) {
   DRA_EXCEPT(ERROR_REVISION_MISMATCH, 5);
    }
    
    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    return ret;
}

ULONG
DRS_MSG_REPADD_V1_InputValidate(
    DRS_MSG_REPADD_V1 * pmsg
    ) 
/*
typedef struct _DRS_MSG_REPADD_V1
    {
    [ref] DSNAME *pNC;
    [ref] SZ pszDsaSrc;
    REPLTIMES rtSchedule;
    ULONG ulOptions;
    }    DRS_MSG_REPADD_V1;
*/
{
    ULONG ret = DRAERR_Success;

    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    if (ret==DRAERR_Success) {
   ret = LPSTR_Validate(pmsg->pszDsaSrc, FALSE);
    }

    return ret;
}

ULONG
DRS_MSG_REPADD_V2_InputValidate(
    DRS_MSG_REPADD_V2 * pmsg
    ) 
/*
typedef struct _DRS_MSG_REPADD_V2
    {
    [ref]  DSNAME *pNC;
    [unique]  DSNAME *pSourceDsaDN;
    [unique]  DSNAME *pTransportDN;
    [ref]  SZ pszSourceDsaAddress;
    REPLTIMES rtSchedule;
    ULONG ulOptions;
    }    DRS_MSG_REPADD_V2;
*/
{
    ULONG ret = DRAERR_Success;

    ret = DSNAME_Validate(pmsg->pNC, FALSE);
    if (ret==DRAERR_Success) {
   ret = DSNAME_Validate(pmsg->pSourceDsaDN, TRUE);
    }
    if (ret==DRAERR_Success) {
   ret = DSNAME_Validate(pmsg->pTransportDN, TRUE);
    }
    if (ret==DRAERR_Success) {
   ret = LPSTR_Validate(pmsg->pszSourceDsaAddress, FALSE);
    }

    return ret;
}

ULONG
DRS_MSG_REPMOD_V1_InputValidate(
    DRS_MSG_REPMOD_V1 * pmsg
    ) 
/*
typedef struct _DRS_MSG_REPMOD_V1
    {
    [ref]  DSNAME *pNC;
    UUID uuidSourceDRA;
    [unique]  SZ pszSourceDRA;
    REPLTIMES rtSchedule;
    ULONG ulReplicaFlags;
    ULONG ulModifyFields;
    ULONG ulOptions;
    }    DRS_MSG_REPMOD_V1;
*/
{
    ULONG ret = DRAERR_Success;

    ret = DSNAME_Validate(pmsg->pNC, FALSE);

    if (fNullUuid(&(pmsg->uuidSourceDRA)) && (pmsg->pszSourceDRA==NULL)) {
   ret = DRAERR_InvalidParameter;
    }
    if (ret==DRAERR_Success) {
   ret = LPSTR_Validate(pmsg->pszSourceDRA, TRUE);
    }

    return ret;
}

ULONG
DRS_MSG_REPDEL_V1_InputValidate(
    DRS_MSG_REPDEL_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_REPDEL_V1
    {
    [ref]  DSNAME *pNC;
    [unique]  SZ pszDsaSrc;
    ULONG ulOptions;
    }    DRS_MSG_REPDEL_V1;
*/
{
    ULONG ret = DRAERR_Success;

    ret = DSNAME_Validate(pmsg->pNC, FALSE);
    if (ret==DRAERR_Success) {
   ret = LPSTR_Validate(pmsg->pszDsaSrc, TRUE);
    }

    return ret;

}

ULONG
DRS_MSG_VERIFYREQ_V1_InputValidate(
    DRS_MSG_VERIFYREQ_V1 * pmsg
    )
/*
  typedef struct _DRS_MSG_VERIFYREQ_V1
  {
  DWORD dwFlags;
  [range] DWORD cNames;
  [size_is]  PDSNAME *rpNames;
  ATTRBLOCK RequiredAttrs;
  SCHEMA_PREFIX_TABLE PrefixTable;
  }    DRS_MSG_VERIFYREQ_V1;
*/
{
    ULONG ret = DRAERR_Success;  
    ULONG i;

    if (!(DRS_VERIFY_DSNAMES == pmsg->dwFlags)
        && !(DRS_VERIFY_SAM_ACCOUNT_NAMES == pmsg->dwFlags)
        && !(DRS_VERIFY_SIDS == pmsg->dwFlags)
        && !(DRS_VERIFY_FPOS == pmsg->dwFlags)) {
        DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
    }

    if ((pmsg->cNames > 0) && (pmsg->rpNames==NULL)) {
        DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
    }

    // Note that we do not validate the StringName because:
    // 1. The name can contain any character
    // 2. This call is made when the name is invalid and may need correcting
    // 3. The phantom is looked up by guid anyway
    for ( i = 0; i < pmsg->cNames; i++ ) {
        if ((ret = DSNAME_Validate(pmsg->rpNames[i], FALSE))!=DRAERR_Success) {
            DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, ret );
        }
    }

    return ret;
}

ULONG
DRS_MSG_MOVEREQ_V2_InputValidate(
    DRS_MSG_MOVEREQ_V2 * pmsg
    )
/*
  typedef struct _DRS_MSG_MOVEREQ_V2
  {
  DSNAME *pSrcDSA;
  ENTINF *pSrcObject;
  DSNAME *pDstName;
  DSNAME *pExpectedTargetNC;
  DRS_SecBufferDesc *pClientCreds;
  SCHEMA_PREFIX_TABLE PrefixTable;
  ULONG ulFlags;
  }    DRS_MSG_MOVEREQ_V2;
*/
{
    ULONG ret = DRAERR_Success;  

    ret = DSNAME_Validate(pmsg->pSrcDSA, FALSE);
    if (ret==DRAERR_Success) {
        if (pmsg->pSrcObject) { 
            ret = ENTINF_Validate(pmsg->pSrcObject);
        } else {
            ret = DRAERR_InvalidParameter;
        }
    }
    if (ret==DRAERR_Success) {
        ret = DSNAME_Validate(pmsg->pDstName, FALSE);
    }
    if (ret==DRAERR_Success) {
        ret = DSNAME_Validate(pmsg->pExpectedTargetNC, FALSE);
    }
    if ( (ret==DRAERR_Success) && (pmsg->pClientCreds) ) {
        DWORD i;
        if ((pmsg->pClientCreds->cBuffers > 0) &&
            (pmsg->pClientCreds->Buffers==NULL)) {
            ret = ERROR_INVALID_PARAMETER;
        }
        for( i = 0; (ret==DRAERR_Success) && (i < pmsg->pClientCreds->cBuffers); i++ ) {
            DRS_SecBuffer *psb = pmsg->pClientCreds->Buffers + i;
            if ((psb->cbBuffer > 0) && (psb->pvBuffer==NULL)) {
                ret = ERROR_INVALID_PARAMETER;
            }
        }
    }

    return ret;
}

ULONG
DRS_MSG_ADDENTRYREQ_V2_InputValidate(
    DRS_MSG_ADDENTRYREQ_V2 * pmsg
    )
/*
typedef struct _DRS_MSG_ADDENTRYREQ_V2
    {
    ENTINFLIST EntInfList;
    }    DRS_MSG_ADDENTRYREQ_V2;
*/
{
    ULONG ret = DRAERR_Success;  
    
    ret = ENTINFLIST_Validate(&(pmsg->EntInfList));

    return ret;
}

ULONG
DRS_MSG_ADDENTRYREQ_V3_InputValidate(
    DRS_MSG_ADDENTRYREQ_V3 * pmsg
    )
/*
typedef struct _DRS_MSG_ADDENTRYREQ_V3
    {
    ENTINFLIST EntInfList;
    [unique]  DRS_SecBufferDesc *pClientCreds;
    }    DRS_MSG_ADDENTRYREQ_V3;
*/
{
    ULONG ret = DRAERR_Success;  
    
    ret = ENTINFLIST_Validate(&(pmsg->EntInfList));

    return ret;
}

ULONG
DRS_MSG_QUERYSITESREQ_V1_InputValidate(
    DRS_MSG_QUERYSITESREQ_V1 * pmsg
    )
/*
  typedef struct _DRS_MSG_QUERYSITESREQ_V1
  {
  [string]  const WCHAR *pwszFromSite;
  [range]  DWORD cToSites;
  [size_is][string]  WCHAR **rgszToSites;
  DWORD dwFlags;
  }    DRS_MSG_QUERYSITESREQ_V1;
*/
{
    ULONG ret = DRAERR_Success;  
    ULONG cToSites = pmsg->cToSites;
    ULONG iSites = 0;

    ret = ValidateSiteRDN(pmsg->pwszFromSite);

    if ( (ret==DRAERR_Success) && (pmsg->cToSites > 0) && (pmsg->rgszToSites==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==DRAERR_Success) { 
        for( iSites=0; (iSites<cToSites) && (ret==DRAERR_Success); iSites++ ) {
            ret = ValidateSiteRDN(pmsg->rgszToSites[iSites]);
        }
    }

    return ret;
}

BOOL
IsDraAccessGranted(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pNC,
    IN  const GUID *    pControlAccessRequired,
    OUT DWORD *         pdwError
    )
/*++

Routine Description:

    Verify the caller has the required control access rights for a given
    replication operation.

Arguments:

    pNC (IN) - The NC the operation is being made against.

    pControlAccessRequired (IN) - The GUID of the control access right required
        to perform this operation.

Return Values:

    TRUE - Access granted.

    FALSE - Access denied.

--*/
{
    BOOL                    fAccessGranted;
    ULONG                   err;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    ULONG                   cbSD = 0;
    CLASSCACHE *            pCC;
    BOOL                    fDRA;
    SYNTAX_INTEGER          it;
    BOOL                    bCachedSD = FALSE;
    DBPOS *                 pDBSaved, *pDBNew=NULL;

    Assert(!pTHS->fDSA && "Shouldn't perform access checks for trusted clients");

    // Try-Except
    __try {

        // Try-Finally
        __try {
            // Save away the current fDRA flag setting as we will turn it off below
            fDRA = pTHS->fDRA;

            // Save away the current dbpos on the thread state and install a new one
            pDBSaved = pTHS->pDB;
            DBOpen(&pDBNew);
            pTHS->pDB = pDBNew;
        
            // Check Access.  This is a check of the control access right
            // on the NC object.

            // We have three valid cases:
            // (1) The NC is an instantiated object on this machine.
            // (2) The NC is an uninstantiated subref object on this machine.
            // (3) The NC is a phantom on this machine.

            // Cases (2) and (3) cover, e.g., when we're being asked to add a
            // replica of an NC we haven't yet instantiated on this machine.

            // In case (1), we check access against the SD on the object.
            // In cases (2) and (3), we check access against the default SD (the
            // default SD for Domain-DNS objects).

            // There is a special (and frequent) sub-case of (1), which is that
            // the NC in question is our domain NC, whose SD is already
            // cached on the anchor.

            if (NULL == pNC) {
                DRA_EXCEPT(DRAERR_BadNC, 0);
            }
            else if (NameMatched(pNC, gAnchor.pDomainDN) && gAnchor.pDomainSD) {
                pNC = gAnchor.pDomainDN; // Make sure we have a GUID & SID
                pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
                pSD = gAnchor.pDomainSD;
                bCachedSD = TRUE;
            }
            else {

                err = DBFindDSName(pTHS->pDB, pNC);
                if (0 == err) {
                    // pNC is an instantiated object.

                    // Get the instance type.
                    GetExpectedRepAtt(pTHS->pDB, ATT_INSTANCE_TYPE, &it,
                                      sizeof(it));
                    if (!(it & IT_NC_HEAD)) {
                        // Not the head of an NC.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_DRA_BAD_INSTANCE_TYPE);
                    }
                    else if (!(it & IT_UNINSTANT)) {
                        // Case (1).  The NC head is instantiated on this
                        // machine; check access against its SD.
                        err = DBGetAttVal(pTHS->pDB,
                                          1,
                                          ATT_NT_SECURITY_DESCRIPTOR,
                                          0,
                                          0,
                                          &cbSD,
                                          (UCHAR **) &pSD);
                        if(err) {
                            Assert(!err);
                            DRA_EXCEPT(DRAERR_BadNC,
                                       ERROR_DS_MISSING_REQUIRED_ATT);
                        }

                        // Get its object class while we're at it.
                        GetObjSchema(pTHS->pDB,&pCC);
                    }
                    // Else case (2) (handled below).
                }
                else if (DIRERR_NOT_AN_OBJECT == err) {
                    // The supposed NC is a phantom on this machine.  Make sure
                    // it really is an NC somewhere by scanning our crossRefs.
                    CROSS_REF * pCR;
                    COMMARG     CommArg;

                    InitCommarg(&CommArg);
                    Assert(!CommArg.Svccntl.dontUseCopy); // read-only is okay

                    pCR = FindExactCrossRef(pNC, &CommArg);
                    if (NULL == pCR) {
                        // Not the head of an NC.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_NO_CROSSREF_FOR_NC);
                    }
                    // Else case (3) (handled below).
                }
                else {
                    // pNC is neither a phantom nor an instantiated object --
                    // we've never heard of it.
                    DRA_EXCEPT(DRAERR_BadNC, err);
                }

                // The DN must have a GUID (required by the access check).
                // If the caller didn't supply it, retrieve it now.
                if (fNullUuid(&pNC->Guid)) {
                    err = DBFillGuidAndSid(pTHS->pDB, pNC);

                    if (err) {
                        LogUnhandledError(err);
                        DRA_EXCEPT(DRAERR_DBError, err);
                    }

                    if (fNullUuid(&pNC->Guid)) {
                        // This is the case where we have a local crossRef that
                        // was created with no guid for the object referred to
                        // by the ncName attribute.  Treat this the same as the
                        // case where the crossRef could not be found, since as
                        // far as this machine is concerned it doesn't really
                        // exist yet.
                        DRA_EXCEPT(DRAERR_BadNC, ERROR_DS_NOT_AN_OBJECT);
                    }
                }

                if (NULL == pSD) {
                    // Case (2) or (3).  Check access against the default SD
                    // for Domain-DNS objects.
                    pCC = SCGetClassById(pTHS, CLASS_DOMAIN_DNS);
                    Assert(NULL != pCC);

                    err = GetPlaceholderNCSD(pTHS, &pSD, &cbSD);
                    if (err) {
                        LogUnhandledError(err);
                        DRA_EXCEPT(err, 0);
                    }
                }
            }

            Assert(NULL != pCC);
            Assert(NULL != pSD);

            pTHS->fDRA = FALSE;
            fAccessGranted = IsControlAccessGranted(pSD,
                                                    pNC,
                                                    pCC,
                                                    *pControlAccessRequired,
                                                    FALSE);
            if (!fAccessGranted) {
                DPRINT1(0, "Replication client access to %ls was denied.\n",
                        pNC->StringName);
                err = DRAERR_AccessDenied;
            } else {
                err = ERROR_SUCCESS;
            }
        }
        __finally {
            pTHS->pDB = pDBSaved;
            if( pDBNew ) {
                DBClose( pDBNew, TRUE );
                pDBNew = NULL;
            }
            pTHS->fDRA = fDRA;
        }
    }
    __except(GetDraException(GetExceptionInformation(), &err)) {
        Assert( err );
        fAccessGranted = FALSE;
    }

    if (!bCachedSD) {
        THFreeEx(pTHS, pSD);
    }

    *pdwError = err;

    return fAccessGranted;
}


ULONG
drsGetClientIPAddr(
    IN  RPC_BINDING_HANDLE  hClientBinding,
    OUT ULONG *             pIPAddr,
    OUT BOOL  *             fLPC              
    )
{
    RPC_BINDING_HANDLE hServerBinding;
    unsigned char * pszStringBinding = NULL;
    unsigned char * pszNetworkAddr = NULL;
    unsigned char * pszProtSeq = NULL;
    ULONG err;

    // Assume this is not an LPC connection
    *fLPC = FALSE;

    // Derive a partially bound handle with the client's network address.
    err = RpcBindingServerFromClient(hClientBinding, &hServerBinding);
    if (err) {
        DPRINT1(0, "RpcBindingServerFromClient() failed, error %d!\n", err);
        return err;
    }

    __try {
        // Convert binding handle into string form, which contains, amongst
        // other things, the network address of the client.
        err = RpcBindingToStringBinding(hServerBinding, &pszStringBinding);
        if (err) {
            DPRINT1(0, "RpcBindingToStringBinding() failed, error %d!\n", err);
            __leave;
        }

        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_VERBOSE,
                 DIRLOG_RPC_CONNECTION,
                 szInsertSz(pszStringBinding),
                 NULL,
                 NULL);

        // Parse out the network address.
        err = RpcStringBindingParse(pszStringBinding,
                                    NULL,
                                    &pszProtSeq,
                                    &pszNetworkAddr,
                                    NULL,
                                    NULL);
        if (err) {
            DPRINT1(0, "RpcBindingToStringBinding() failed, error %d!\n", err);
            __leave;
        }

        if (!strcmp(pszProtSeq, LPC_PROTSEQ)) {
            *fLPC = TRUE;
        }

        *pIPAddr = inet_addr(pszNetworkAddr);
        Assert((0 != *pIPAddr) && "Has bind via LPC been re-enabled?");
    }
    __finally {
        RpcBindingFree(&hServerBinding);

        if (NULL != pszStringBinding) {
            RpcStringFree(&pszStringBinding);
        }

        if (NULL != pszNetworkAddr) {
            RpcStringFree(&pszNetworkAddr);
        }

        if (NULL != pszProtSeq) {
            RpcStringFree(&pszProtSeq);
        }
    }

    return err;
}

ULONG
DRSBind_InputValidate(
    UUID *              puuidClientDsa,
    DRS_EXTENSIONS *    pextClient,
    PDRS_EXTENSIONS *   ppextServer,
    DRS_HANDLE *        phDrs
    )
/*
ULONG
IDL_DRSBind(
    [in]            handle_t                rpc_handle,
    [in]  [unique]  UUID *                  puuidClientDsa,
    [in]  [unique]  DRS_EXTENSIONS *        pextClient,
    [out]           PDRS_EXTENSIONS *       ppextServer,
    [out] [ref]     DRS_HANDLE *            phDrs
    );
    */
{
    ULONG ret = DRAERR_Success;

    if (puuidClientDsa && fNullUuid(puuidClientDsa)) {
   ret = DRAERR_InvalidParameter;
   return ret;
    }

    return ret;
}

ULONG
IDL_DRSBind(
    IN  RPC_BINDING_HANDLE  rpc_handle,
    IN  UUID *              puuidClientDsa,
    IN  DRS_EXTENSIONS *    pextClient,
    OUT PDRS_EXTENSIONS *   ppextServer,
    OUT DRS_HANDLE *        phDrs
    )
{
    ULONG                   ret = DRAERR_Success;
    DRS_CLIENT_CONTEXT *    pCtx;
    DWORD                   cb;
    RPC_AUTHZ_HANDLE        hAuthz;
    ULONG                   authnLevel;
    BOOL                    fIsNtDsApiClient = FALSE;
    ULONG                   IPAddr;
    BOOL                    fLPC;
    RPC_STATUS              rpcStatus;
    DRS_EXTENSIONS *        pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;
    THSTATE *               pTHS = pGetDrsTHSTATE();

    // All code paths until the NtdsapiMapping label should set
    // DRAERR_* codes.  The are mapped later to WIN32 error codes
    // if the client is NTDSAPI.DLL.

    __try { 
   // Initialize the context handle to NULL in case of error.
        *phDrs = NULL;

   if ((ret = DRSBind_InputValidate(puuidClientDsa,
                pextClient,
                ppextServer,
                phDrs))!=DRAERR_Success){
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

        ret = drsGetClientIPAddr(rpc_handle, &IPAddr, &fLPC);
        if (ret) {
            __leave;
        } 

   // This routine does double duty for true DRS (aka replication)
   // activities as well as NTDSAPI.DLL activities.  We tell the two
   // apart by the puuidClientDsa GUID - for which the NTDSAPI.DLL
   // client uses a fixed, known value.

   fIsNtDsApiClient = (NULL != puuidClientDsa)
                       && (0 == memcmp(&g_guidNtdsapi, puuidClientDsa,
                                       sizeof(GUID)));
   
        if (fIsNtDsApiClient) {
            PERFINC(pcDsClientBind);
        }
        else {
            PERFINC(pcDsServerBind);
        }

        pCtx = malloc(sizeof(*pCtx));
        if (NULL == pCtx) {
            // Could not allocate client context.
            ret = DRAERR_OutOfMem;
            __leave;
        }

        // Client context allocated; initialize it.
        memset(pCtx, 0, sizeof(DRS_CLIENT_CONTEXT));
   pCtx->lReferenceCount = 1;  // +1 for the bind
        pCtx->uuidDsa = puuidClientDsa ? *puuidClientDsa : gNullUuid;
        pCtx->IPAddr = IPAddr;
        pCtx->fLPC = fLPC;
        pCtx->timeLastUsed = GetSecondsSince1601();
        pCtx->extLocal.cb = min(pextLocal->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
        memcpy(pCtx->extLocal.rgb, pextLocal->rgb, pCtx->extLocal.cb);
   RPC_TEST(IPAddr,IDL_DRSBIND);

        if (NULL != pextClient) {
            pCtx->extRemote.cb = min(pextClient->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
            memcpy(pCtx->extRemote.rgb, pextClient->rgb, pCtx->extRemote.cb);
        }
        else {
            pCtx->extRemote.cb = 0;
        }

        // The following can legitimately fail if the connection is
        // over LPC (which implies RPC_C_AUTHN_WINNT authentication)
        // or if the client explicitly asked for or got negotiated
        // down to RPC_C_AUTHN_WINNT authentication.  Rather than fail
        // the connect, we just ignore the error.  Any server side
        // code which expects to have session keys in the client context
        // should explicitly check and return an appropriate error
        // if the session key is missing.

        PEKGetSessionKey2(&pCtx->sessionKey,
                          I_RpcGetCurrentCallHandle());

        // Return context handle to client.
        DPRINT2(3, "DRSBIND from client %s, context = 0x%p\n",
                inet_ntoa(*((IN_ADDR *) &IPAddr)), pCtx);
        *phDrs = pCtx;

        // Save context handle in list.
        EnterCriticalSection(&gcsDrsuapiClientCtxList);
        __try {
            if (!gfDrsuapiClientCtxListInitialized) {
                InitializeListHead(&gDrsuapiClientCtxList);
                Assert(0 == gcNumDrsuapiClientCtxEntries);
                gfDrsuapiClientCtxListInitialized = TRUE;
            }
            InsertTailList(&gDrsuapiClientCtxList, &pCtx->ListEntry);
            ++gcNumDrsuapiClientCtxEntries;
        }
        __finally {
            LeaveCriticalSection(&gcsDrsuapiClientCtxList);
        }

        if (NULL != ppextServer) {
            // Return server extensions to client.

            // NOTE: We don't need to copy the server extension string because
            // we've explicitly defined PDRS_EXTENSIONS in the DRS ACF as
            // allocate(dont_free), which prevents RPC from attempting to
            // free it.
            *ppextServer = pextLocal;
        }
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        ret = DRAERR_InternalError;
    }

    if (fIsNtDsApiClient) {
        // Massage error codes for NTDSAPI.DLL clients.
        switch (ret) {
        case DRAERR_OutOfMem:
            ret = ERROR_NOT_ENOUGH_MEMORY;
            break;

        case DRAERR_AccessDenied:
            ret = ERROR_NOT_AUTHENTICATED;
            break;

        default:
            // Leave return code unchanged.
            break;
        }
    }

    return ret;
}


VOID
drsReleaseContext(
    DRS_CLIENT_CONTEXT *pCtx
    )

/*++

Routine Description:

Do the actual work of freeing the context handle.

This routine should only be called when no other calls are active using
the same context.

May also be called by the context rundown routine if necessary.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{

    DPRINT1( 3, "drsReleaseContext 0x%p\n", pCtx );

    if (NULL != pCtx) {
   pCtx->lReferenceCount = 0; 

   // Free RPC session encryption keys if present.
   if ( pCtx->sessionKey.SessionKeyLength ) {
       Assert(pCtx->sessionKey.SessionKey);
       memset(pCtx->sessionKey.SessionKey,
         0,
         pCtx->sessionKey.SessionKeyLength);
       free(pCtx->sessionKey.SessionKey);
   }

   // Remove ctx from list.
   EnterCriticalSection(&gcsDrsuapiClientCtxList);
   __try {
       RemoveEntryList(&pCtx->ListEntry);
       --gcNumDrsuapiClientCtxEntries;
   }
   __finally {
       LeaveCriticalSection(&gcsDrsuapiClientCtxList);
   }
   // Free client context.
   free(pCtx);
    }
} /* drsReleaseContext */

ULONG
IDL_DRSUnbind(
    IN OUT  DRS_HANDLE *phDrs
    )

/*++

Routine Description:

Indicate that the client is finished with the handle.

Mark the handle as no longer valid.

    // I am assuming that execution of this function (and all idl entries)
    // is atomic wrt the rundown routine.  The rundown routine should not run
    // while any call is in progress, and will never ever be run once this
    // routine is entered and does its work.

Arguments:

    hDrs - context handle

Return Value:

    None

--*/

{
    DRS_CLIENT_CONTEXT *pCtx;
    RPC_STATUS rpcstatus = RPC_S_OK;
    LONG lNewValue;
    ULONG ret = DRAERR_Success;

    DRS_ValidateInput(NULL, 
            *phDrs, 
            IDL_DRSUNBIND);
    

    DPRINT1(3, "DRSUNBIND, context = 0x%p\n", *phDrs );

    // This routine does not create a thread state nor open the DB
    // as the routines that it calls, including event logging, do not
    // require a thread state.


    RPC_TEST(((DRS_CLIENT_CONTEXT *)*phDrs)->IPAddr,IDL_DRSUNBIND);
    drsDereferenceContext( *phDrs );

    rpcstatus = RpcSsContextLockExclusive(NULL, *phDrs);
    if (RPC_S_OK == rpcstatus) {
   // if another thread was in this function simultaneous with the current thread,
   // it could have deleted the handle and yet rpcstatus is still 0 (we don't necessarily get
   // ERROR_MORE_WRITES)
   pCtx = (DRS_CLIENT_CONTEXT *) *phDrs;       
   drsReleaseContext(pCtx);
   *phDrs = NULL;
    }
    else if (ERROR_MORE_WRITES != rpcstatus) {
   DPRINT1(0,"RPC Exception (%d) trying to serialize execution.\n", rpcstatus);
   RpcRaiseException(rpcstatus);
    }

    return DRAERR_Success;
}

void
__RPC_USER
DRS_HANDLE_rundown(
    IN  DRS_HANDLE  hDrs
    )
/*++

Routine Description:

    Called by RPC.  Frees RPC client context as a result of client connection
    failure.

    This is also called in general when a client bound, never unbound
    explicitly, and now the client is going away.

    The RPC runtime guarantees that we are serialized wrt other calls

    // I am assuming that execution of this function (and all idl entries)
    // is atomic wrt the rundown routine.  The rundown routine should not run
    // while any call is in progress, and will never ever be run once the
    // unbind routine is entered and does its work.

Arguments:

    hDrs (IN) - the client's context handle.

Return Values:

    None.

--*/
{
    CHAR szUuidDsa[SZUUID_LEN];
    DRS_CLIENT_CONTEXT *pCtx = (DRS_CLIENT_CONTEXT *) hDrs;

    DPRINT2(0, "Running down replication handle 0x%x for server %s.\n",
            hDrs, UuidToStr(&(pCtx->uuidDsa), szUuidDsa, sizeof(szUuidDsa)/sizeof(szUuidDsa[0])));
   
    // count <=0 means rundown called after unbind, which is bad
    // count >1 means rundown called when other calls still active, bad
    Assert( (pCtx->lReferenceCount == 1) && "error: rundown invoked when it should not have been" );

    // Ignore reference count and release the context
    drsReleaseContext( pCtx );
}

///////////////////////////////////////////////
// TEMPLATE NOTE:
// Create a *_InputValidate function for new 
// rpc server side functions in the drsuapi interface.
ULONG
DRSReplicaSync_InputValidate(
    DWORD               dwMsgVersion,
    DRS_MSG_REPSYNC *   pmsgSync
    )
/*
Routine Description:

    Validate the input to DRSReplicaSync.  The function description in the 
    interface is:
    
    // TEMPLATE NOTE:  Be sure to include the function description from the
    // interface files.
    ULONG
    IDL_DRSReplicaSync(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_REPSYNC *       pmsgSync
    );

Arguments:

    dwMsgVersion - version of pmsgSync
    pmsgSync - [ref] = non-NULL.

Return Values:

    DRAERR_Success if valid input, DRAERR_* otherwise.

    */
{
    // Returns DRAERR_* errors.
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgVersion ) {
   ret = DRAERR_InvalidParameter; 
    }

    // TEMPLATE NOTE:  All datatypes that must be validated
    // should have their own <TYPE>_Validate function.
    if (ret==DRAERR_Success) {
   ret = DRS_MSG_REPSYNC_V1_Validate(&(pmsgSync->V1));
    }
    
    return ret;
}

/////////////////////////////////////////////////////////
// TEMPLATE NOTE:
// Use this function as a template for new server side 
// functions in the drsuapi rpc interface.  Please set
// up new functions like this.  
ULONG
IDL_DRSReplicaSync(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_REPSYNC *   pmsgSync
    )
{
    THSTATE *   pTHS = pTHStls;
    
    // TEMPLATE NOTE:  ret
    ULONG       ret;

    // TEMPLATE NOTE:  Your variables here:
    LPWSTR      pwszSourceServer = NULL;

    // TEMPLATE NOTE:  *ALL* callers must call this as
    // the *FIRST* call in the function right before this
    // try block.  It set's the thread state (if not already)
    // and validates the DRS_HANDLE and server state.
    DRS_Prepare(&pTHS, hDrs, IDL_DRSREPLICASYNC);

    // TEMPLATE NOTE:  Required reference counting for server side rpc calls
    drsReferenceContext(hDrs);   

    // TEMPLATE NOTE:  Your applicable perfmon hooks here
    INC( pcThread  );   // Perfmon hook

    // TEMPLATE NOTE:  This try is required so that the drsDereferenceContext
    // after this try-except block is guarenteed to run.
    __try {

   // TEMPLATE NOTE:  If you have a returned pmsgOut and pdwOutVersion, you must
   // set the pdwOutVersion here, otherwise, if you return an error without 
   // excpeting the RPC layer will not be able to figure out what version the pmsgOut
   // structure is to marshall.  Even if you have only 1 output message type, set
   // it here.  You can also zero the output message just for conformity.  Note that
   // you needn't check if pmsgOutVersion!=NULL, because it *should* be a [ref] parameter
   // (unless you didn't read the comments in drs.idl)
   // Example:
   // *pmsgOutVersion=1;
   // memset(pmsgOut, 0, sizeof(*pmsgOut));

   // TEMPLATE NOTE:  Initialize your thread state here for use in the next function.
   InitDraThread(&pTHS);

   // TEMPLATE NOTE:  You must create a corresponding XXX_InputValidate function
   // See comments/template on DRSReplicaSync_InputValidate
   if ((ret = DRSReplicaSync_InputValidate(dwMsgVersion, 
                  pmsgSync))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   // TEMPLATE NOTE:  Log here if needed, but it must be at severity EXTENSIVE or above, otherwise
   // it has denial of service implications.  (since we haven't security checked yet).
   Assert(1 == dwMsgVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_SYNC_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsReplicaSync,
          szInsertDN(pmsgSync->V1.pNC),
          pmsgSync->V1.pszDsaSrc
          ? szInsertSz(pmsgSync->V1.pszDsaSrc)
          : szInsertSz(""),
       szInsertUUID(&pmsgSync->V1.uuidDsaSrc),
       szInsertUL(pmsgSync->V1.ulOptions),
       NULL, NULL, NULL, NULL);

   // TEMPLATE NOTE:  Security check now!
   if (!IsDraAccessGranted(pTHS, pmsgSync->V1.pNC, &RIGHT_DS_REPL_SYNC, &ret)) {
       DRA_EXCEPT_NOLOG(ret, 0);
   }

   // TEMPLATE NOTE:  Your function specific code below:
/////////////////////////////////////////////////////////

   if (NULL != pmsgSync->V1.pszDsaSrc) {
       pwszSourceServer = UnicodeStringFromString8(CP_UTF8,
                     pmsgSync->V1.pszDsaSrc,
                     -1);
   }

   ret = DirReplicaSynchronize(
       pmsgSync->V1.pNC,
       pwszSourceServer,
       &pmsgSync->V1.uuidDsaSrc,
       pmsgSync->V1.ulOptions
       );

////////////////////////////////////////////////////////
   // TEMPLATE NOTE:  Your function specific code above:

   // TEMPLATE NOTE:  Except
    }
    __except( GetDraException( GetExceptionInformation(), &ret ) )
    {
   ;
    }

    // TEMPLATE NOTE:  Put your perf hooks here, then drsDereferenceContext.  Make sure that your
    // perf hooks cannot except or return.
    DEC( pcThread  );   // Perfmon hook
    drsDereferenceContext( hDrs );

    // TEMPLATE NOTE:  Log and leave.
    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_SYNC_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsReplicaSync,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL, NULL, NULL, NULL);
    }
   
    return ret;
}
// TEMPLATE NOTE:  End drsuapi server side rpc function template
//////////////////////////////////////////////////////////

ULONG
DRSGetNCChanges_InputValidate(
    THSTATE *               pTHS,
    DWORD                   dwMsgInVersion,
    DRS_MSG_GETCHGREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_GETCHGREPLY *   pmsgOut
    )
/*
     [notify]  ULONG IDL_DRSGetNCChanges( 
     [ref][in]  DRS_HANDLE hDrs,
     [in]  DWORD dwInVersion,
     [switch_is][ref][in]  DRS_MSG_GETCHGREQ *pmsgIn,
     [ref][out]  DWORD *pdwOutVersion,
     [switch_is][ref][out]  DRS_MSG_GETCHGREPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if (ret==DRAERR_Success) {
   // dwMsgInVersion, and pmsgIn
   if (dwMsgInVersion==5) { 
       ret = DRS_MSG_GETCHGREQ_V5_InputValidate(pTHS, &(pmsgIn->V5));
   } else if (dwMsgInVersion==8) {
       ret = DRS_MSG_GETCHGREQ_V8_InputValidate(pTHS, &(pmsgIn->V8));
   } else { 
       DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwMsgInVersion);
   }
    }

    Assert(!ret);
    return ret;
}

ULONG
IDL_DRSGetNCChanges(
                   DRS_HANDLE              hDrs,
                   DWORD                   dwMsgInVersion,
                   DRS_MSG_GETCHGREQ *     pmsgIn,
                   DWORD *                 pdwMsgOutVersion,
                   DRS_MSG_GETCHGREPLY *   pmsgOut
                   )
{
    ULONG ret;
    THSTATE *pTHS=pTHStls;
    RPC_STATUS RpcStatus;
    DWORD dwret;
    DSNAME *pNC;
    DRS_MSG_GETCHGREPLY * pmsgOutNew = NULL;
    DRS_CLIENT_CONTEXT * pCtx = (DRS_CLIENT_CONTEXT *) hDrs;
    DRS_MSG_GETCHGREQ_NATIVE NativeReq;
    DRS_MSG_GETCHGREPLY_NATIVE NativeReply;
    DWORD cbCompressedBytes=0;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSGETNCCHANGES);
    drsReferenceContext( hDrs ); 
    INC(pcThread);                      // PerfMon hook
    INC(pcDRATdsInGetChngs);
    PERFINC(pcRepl);                                // PerfMon hook           
    
    __try {   
   // Default to old-style reply.  It is important that we set some valid
   // value before we exit this routine, particulalry in the case where we
   // don't except, but we return an error.
   *pdwMsgOutVersion = 1; 
   memset(pmsgOut, 0, sizeof(*pmsgOut));
   
   InitDraThread(&pTHS);

   if ((ret = DRSGetNCChanges_InputValidate(pTHS, 
                   dwMsgInVersion, 
                   pmsgIn, 
                   pdwMsgOutVersion, 
                   pmsgOut))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   // If the schema cache is stale, reload it
   SCReplReloadCache(pTHS, gOutboundCacheTimeoutInMs);

   draXlateInboundRequestToNativeRequest(pTHS,
                     dwMsgInVersion,
                     pmsgIn,
                     &pCtx->extRemote,
                     &NativeReq,
                     pdwMsgOutVersion,
                     NULL,
                     NULL);

   UpToDateVec_Validate(NativeReq.pUpToDateVecDest);
   UsnVec_Validate(&NativeReq.usnvecFrom);

   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_GETCHG_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsReplicaGetChg,
          szInsertUUID(&NativeReq.uuidDsaObjDest),
          szInsertDN(NativeReq.pNC),
          szInsertUSN(NativeReq.usnvecFrom.usnHighObjUpdate),
          szInsertUSN(NativeReq.usnvecFrom.usnHighPropUpdate),
          szInsertUL(NativeReq.ulFlags),
          szInsertUL(NativeReq.cMaxObjects),
          szInsertUL(NativeReq.cMaxBytes),
          szInsertUL(NativeReq.ulExtendedOp));

   //
   // Set the set of extensions specified in the context handle into
   // the thread state.
   //

   pTHS->pextRemote = THAllocEx(pTHS, DrsExtSize(&pCtx->extRemote));
   CopyExtensions(&pCtx->extRemote, pTHS->pextRemote);

   //
   // Retreive the security context and session key from RPC and set it
   // on the thread state
   //

   PEKGetSessionKey(pTHS, I_RpcGetCurrentCallHandle());

   // Note that extended transfers send the extended object name in the "pNC"
   // field, which is not necessarily the name of the NC. 
   pNC = FindNCParentDSName(NativeReq.pNC, FALSE, FALSE);
   if (pNC == NULL) {
       // Just like the BUGBUG mentions below a timing window can allow 
       // us to miss the NC, and get a NULL instead of the parent NC, so 
       // instead of AVing we'll error out.  If the in memory cache or
       // if the BUGBUG addendum is implemented this can be removed,
       // because we validate this condition in draXlateInboundRequestToNativeRequest()
       DRA_EXCEPT(ERROR_DS_CANT_FIND_EXPECTED_NC, 0);
   }
   // BUGBUG - gregjohn 8/7/01 - this can return a valid NC for an invalid NC request
   // for example, if we hold dc=parent,dc=microsoft,dc=com, and the request NC is
   // dc=child,dc=parent,dc=microsoft,dc=com - which we don't hold (say if we aren't a
   // GC, or if it's an NDNC an we don't hold it) then it will return a value of
   // dc=parent,dc=microsoft,dc=com which is used for granting access below.  This
   // is a one-in-a-million race condition for a security violation.
   // BUGBUG - BrettSh 11/9/2001 - Adendum, if we want to close this in the
   // transaction above, we could write a function that uses DmitriG's new 
   // EnumerateCrossRefs() function (as seen in mdupdate.c) and then do a 
   // FindNC() on the NC returned. And as we've seen with large numbers of NCs
   // on a single host, this might be only a one-in-a-hundre-thousand race 
   // condition ;)

   // check the access rights depending on what they are requesting
   if ((NativeReq.ulFlags & DRS_WRIT_REP) &&
       (!IsDraAccessGranted(pTHS, pNC, &RIGHT_DS_REPL_GET_CHANGES_ALL, &ret))
       ) {
       DWORD err = 0;
       if (IsEnterpriseDC(pTHS,&err)) {
      // log an event that states an enterprise DC has access denied.
      // don't log anything else just in case this is a DOS attack  
      LogEvent(DS_EVENT_CAT_REPLICATION,
          DS_EVENT_SEV_ALWAYS,
          DIRLOG_DRA_REPLICATION_ALL_ACCESS_DENIED_DC,    
          szInsertWC(pNC->StringName),
          szInsertUUID(&(NativeReq.uuidDsaObjDest)),
          NULL);
       }
       DRA_EXCEPT_NOLOG(ret, 0);
   } else if (!IsDraAccessGranted(pTHS, pNC, &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
       DRA_EXCEPT_NOLOG(ret, 0);
   }

   // One try to get a thread slot
   dwret = WaitForSingleObject (hsemDRAGetChg, DRAGETCHG_WAIT);
   if (dwret != WAIT_OBJECT_0) {
       // WAIT_TIMEOUT, WAIT_FAILED, unexpected WAIT codes, ...
       DRA_EXCEPT_NOLOG(ERROR_DS_THREAD_LIMIT_EXCEEDED, dwret);
   }

   INC(pcDRATdsInGetChngsWSem);

   __try {
       // Got a slot, check if we have been cancelled
       RpcStatus = RpcTestCancel();
       if (RpcStatus == RPC_S_OK) {
      // We've been cancelled, free semaphore and exit.
      DRA_EXCEPT_NOLOG(DRAERR_RPCCancelled, 0);
       }

       ret = DRA_GetNCChanges(pTHS,
               NULL,  // Search filter, not used
               0, // Not the DirSync Control
               &NativeReq,
               &NativeReply);

       // The code should have updated this value in all cases
       Assert( ret == NativeReply.dwDRSError );

       if (ret) {
      __leave;
       }

       UpToDateVec_Validate(NativeReply.pUpToDateVecSrc);
       UsnVec_Validate(&NativeReply.usnvecTo);

       // Add the schemaInfo to the prefix table if client supports it
       if (IS_DRS_SCHEMA_INFO_SUPPORTED(pTHS->pextRemote)) {
      if (AddSchInfoToPrefixTable(pTHS, &NativeReply.PrefixTableSrc)) {
          ret = DRAERR_SchemaInfoShip;
          __leave;
      }
       }

       // Convert reply into desired format.
       // Note that we perform compression while still holding the
       // semaphore to avoid saturating the CPU with compression.
       cbCompressedBytes =
      draXlateNativeReplyToOutboundReply(pTHS,
                     &NativeReply,
                     (NativeReq.ulFlags & DRS_USE_COMPRESSION) ? DRA_XLATE_COMPRESS : 0,
      &pCtx->extRemote,
      pdwMsgOutVersion,
      pmsgOut);
   } __finally {
       ReleaseSemaphore (hsemDRAGetChg, 1, NULL);
       DEC(pcDRATdsInGetChngsWSem);
   }

   if ((NativeReq.ulFlags & DRS_ADD_REF)
       && !fNullUuid(&NativeReq.uuidDsaObjDest)) {
       // Add a Reps-To the target server if one does not already exist.
       DSNAME DN;
       LPWSTR pszDsaAddr;

       memset(&DN, 0, sizeof(DN));
       DN.Guid = NativeReq.uuidDsaObjDest;
       DN.structLen = DSNameSizeFromLen(0);

       pszDsaAddr = DSaddrFromName(pTHS, &DN);

       DirReplicaReferenceUpdate(
      NativeReq.pNC,
      pszDsaAddr,
      &NativeReq.uuidDsaObjDest,
      (NativeReq.ulFlags & DRS_WRIT_REP) | DRS_ADD_REF | DRS_ASYNC_OP
      | DRS_GETCHG_CHECK
      );
   }
    }
    __except (GetDraException((GetExceptionInformation()), &ret)) {
   ;
    }

    // Because we have an except directly before this statement, we don't
    // need to worry about bypassing the following statements.

    DEC(pcThread);
    DEC(pcDRATdsInGetChngs);
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_GETCHG_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsReplicaGetChg,
          szInsertUSN(NativeReply.usnvecTo.usnHighObjUpdate),
          szInsertUSN(NativeReply.usnvecTo.usnHighPropUpdate),
          szInsertUL(NativeReply.cNumObjects),
          szInsertUL(NativeReply.cNumBytes),
          szInsertUL(NativeReply.ulExtendedRet),
          szInsertUL(ret),
          szInsertUL(cbCompressedBytes),
          NULL);
    }

    if (ret)
   {
   if (pTHS && pmsgIn) {
       DSNAME DN;
       LPWSTR pszDsaAddr;

       memset(&DN, 0, sizeof(DN));
       DN.Guid = NativeReq.uuidDsaObjDest;
       DN.structLen = DSNameSizeFromLen(0);

       pszDsaAddr = DSaddrFromName(pTHS, &DN);

       DraLogGetChangesFailure( NativeReq.pNC,
                 pszDsaAddr,
                 ret,
                 NativeReq.ulExtendedOp );
   } else {
       LogEvent(DS_EVENT_CAT_REPLICATION,
           DS_EVENT_SEV_BASIC,
           DIRLOG_DRA_CALL_EXIT_BAD,
           szInsertUL(ret),
           szInsertWin32Msg(ret),
           NULL);
   }
    }

    if (pTHS) {
   ret = DraReturn(pTHS, ret);
    }

    return ret;
}

ULONG
DRSUpdateRefs_InputValidate(
    DWORD                   dwMsgVersion,
    DRS_MSG_UPDREFS *       pmsgUpdRefs
    )
/*
    [notify] ULONG IDL_DRSUpdateRefs( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwVersion,
    [switch_is][ref][in]  DRS_MSG_UPDREFS *pmsgUpdRefs)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgVersion ) {
   ret = DRAERR_InvalidParameter; 
    }

    // pmsgSync
    if (ret==DRAERR_Success) {
   ret = DRS_MSG_UPDREFS_V1_Validate(&(pmsgUpdRefs->V1));
    }

    return ret;
}

ULONG
IDL_DRSUpdateRefs(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_UPDREFS *   pmsgUpdRefs
    )
{
    ULONG       ret;
    THSTATE *   pTHS = pTHStls;
    LPWSTR      pwszDestServer = NULL;
    
    DRS_Prepare(&pTHS, hDrs, IDL_DRSUPDATEREFS);
    drsReferenceContext( hDrs );
    INC( pcThread  );   // Perfmon hook   

    __try {

   InitDraThread(&pTHS);

   if ((ret = DRSUpdateRefs_InputValidate(dwMsgVersion, 
                      pmsgUpdRefs))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   Assert(1 == dwMsgVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_UPDREFS_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsUpdateRefs,
          szInsertDN(pmsgUpdRefs->V1.pNC),
          pmsgUpdRefs->V1.pszDsaDest
          ? szInsertSz(pmsgUpdRefs->V1.pszDsaDest)
          : szInsertSz(""),
       szInsertUUID(&pmsgUpdRefs->V1.uuidDsaObjDest),
       szInsertUL(pmsgUpdRefs->V1.ulOptions),
       NULL, NULL, NULL, NULL);

   if (!IsDraAccessGranted(pTHS, pmsgUpdRefs->V1.pNC,
            &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
       DRA_EXCEPT_NOLOG(ret, 0);
   }

   if (NULL != pmsgUpdRefs->V1.pszDsaDest) {
       pwszDestServer
      = UnicodeStringFromString8(CP_UTF8,
                  pmsgUpdRefs->V1.pszDsaDest,
                  -1);
   }

   ret = DirReplicaReferenceUpdate(
       pmsgUpdRefs->V1.pNC,
       pwszDestServer,
       &pmsgUpdRefs->V1.uuidDsaObjDest,
       pmsgUpdRefs->V1.ulOptions
       );
    }
    __except( GetDraException( GetExceptionInformation(), &ret ) )
    {
   ;
    }

    DEC( pcThread  );   // Perfmon hook
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_UPDREFS_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsUpdateRefs,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }

    return ret;
}

ULONG
DRSReplicaAdd_InputValidate(
    DWORD                   dwMsgVersion,
    DRS_MSG_REPADD *        pmsgAdd
    )
/*
    [notify]  ULONG IDL_DRSReplicaAdd( 
    [ref][in]  DRS_HANDLE hDrs,
    [in] DWORD dwVersion,
    [switch_is][ref][in] DRS_MSG_REPADD *pmsgAdd)
*/
{
    ULONG ret = DRAERR_Success;

    if (!gfInitSyncsFinished) {
   ret = DRAERR_Busy; 
    }

    if (ret==DRAERR_Success) {
   // dwMsgInVersion, and pmsgIn
   if (dwMsgVersion==1) { 
       ret = DRS_MSG_REPADD_V1_InputValidate(&(pmsgAdd->V1));
   } else if (dwMsgVersion==2) {
       ret = DRS_MSG_REPADD_V2_InputValidate(&(pmsgAdd->V2));
   } else { 
       DRA_EXCEPT(ERROR_REVISION_MISMATCH, dwMsgVersion);
   }
    }

    return ret;
}

ULONG
IDL_DRSReplicaAdd(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgVersion,
    IN  DRS_MSG_REPADD *    pmsgAdd
    )
{
    THSTATE *   pTHS = pTHStls;
    ULONG       ret;
    LPWSTR      pwszSourceServer = NULL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSREPLICAADD);
    drsReferenceContext( hDrs );
    INC( pcThread  );   // Perfmon hook
    
    __try { 

   InitDraThread(&pTHS);

   if ((ret = DRSReplicaAdd_InputValidate(dwMsgVersion, 
                      pmsgAdd))!=DRAERR_Success) {
       Assert((ret!=DRAERR_Busy) && !"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   switch (dwMsgVersion) {
   case 1:
       LogAndTraceEvent(TRUE,
              DS_EVENT_CAT_RPC_SERVER,
              DS_EVENT_SEV_EXTENSIVE,
              DIRLOG_IDL_DRS_REPLICA_ADD_ENTRY,
              EVENT_TRACE_TYPE_START,
              DsGuidDrsReplicaAdd,
              szInsertDN(pmsgAdd->V1.pNC),
              szInsertSz(""),
              szInsertSz(""),
              pmsgAdd->V1.pszDsaSrc
              ? szInsertSz(pmsgAdd->V1.pszDsaSrc)
              : szInsertSz(""),
      szInsertUL(pmsgAdd->V1.ulOptions),
      NULL, NULL, NULL);

       if (!IsDraAccessGranted(pTHS,
                pmsgAdd->V1.pNC,
                &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
      DRA_EXCEPT_NOLOG(ret, 0);
       }

       if (NULL != pmsgAdd->V1.pszDsaSrc) {
      pwszSourceServer
          = UnicodeStringFromString8(CP_UTF8,
                      pmsgAdd->V1.pszDsaSrc,
                      -1);
       }
       ret = DirReplicaAdd(
      pmsgAdd->V1.pNC,
      NULL,
      NULL,
      pwszSourceServer,
      NULL,
      &pmsgAdd->V1.rtSchedule,
      pmsgAdd->V1.ulOptions
      );
       break;

   case 2:
       LogAndTraceEvent(TRUE,
              DS_EVENT_CAT_RPC_SERVER,
              DS_EVENT_SEV_EXTENSIVE,
              DIRLOG_IDL_DRS_REPLICA_ADD_ENTRY,
              EVENT_TRACE_TYPE_START,
              DsGuidDrsReplicaAdd,
              szInsertDN(pmsgAdd->V2.pNC),
              pmsgAdd->V2.pSourceDsaDN
              ? szInsertDN(pmsgAdd->V2.pSourceDsaDN)
              : szInsertSz(""),
      pmsgAdd->V2.pTransportDN
      ? szInsertDN(pmsgAdd->V2.pTransportDN)
       : szInsertSz(""),
      pmsgAdd->V2.pszSourceDsaAddress
      ? szInsertSz(pmsgAdd->V2.pszSourceDsaAddress)
       : szInsertSz(""),
             szInsertUL(pmsgAdd->V2.ulOptions),
             NULL, NULL, NULL);

       if (!IsDraAccessGranted(pTHS,
                pmsgAdd->V2.pNC,
                &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
      DRA_EXCEPT_NOLOG(ret, 0);
       }

       if (NULL != pmsgAdd->V2.pszSourceDsaAddress) {
      pwszSourceServer
          = UnicodeStringFromString8(CP_UTF8,
                      pmsgAdd->V2.pszSourceDsaAddress,
                      -1);
       }

       ret = DirReplicaAdd(
      pmsgAdd->V2.pNC,
      pmsgAdd->V2.pSourceDsaDN,
      pmsgAdd->V2.pTransportDN,
      pwszSourceServer,
      NULL,
      &pmsgAdd->V2.rtSchedule,
      pmsgAdd->V2.ulOptions
      );
       break;

   default:
       Assert(!"Logic error!");
       ret = DRAERR_InvalidParameter;
   }
    }
    __except( GetDraException( GetExceptionInformation(), &ret ) )
    {
   ;
    }

    DEC( pcThread  );   // Perfmon hook
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_ADD_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsReplicaAdd,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }

    return ret;
}

ULONG
DRSReplicaModify_InputValidate(
    DWORD               dwMsgVersion,
    DRS_MSG_REPMOD *    pmsgMod
    )
/*
    [notify]  ULONG IDL_DRSReplicaModify( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwVersion,
    [switch_is][ref][in]  DRS_MSG_REPMOD *pmsgMod)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgVersion ) {
   ret = DRAERR_InvalidParameter; 
    }

    ret = DRS_MSG_REPMOD_V1_InputValidate(&(pmsgMod->V1)); 

    return ret;
}

ULONG
IDL_DRSReplicaModify(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPMOD *    pmsgMod
    )
{
    THSTATE *   pTHS = pTHStls;
    ULONG       draError = DRAERR_InternalError;
    LPWSTR      pwszSourceServer = NULL;
    
    DRS_Prepare(&pTHS, hDrs, IDL_DRSREPLICAMODIFY);
    drsReferenceContext( hDrs );
    INC( pcThread  );   // Perfmon hook

    __try {

   InitDraThread(&pTHS);

   if ((draError = DRSReplicaModify_InputValidate(dwMsgVersion, 
                         pmsgMod))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   Assert(1 == dwMsgVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_MODIFY_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsReplicaModify,
          szInsertDN(pmsgMod->V1.pNC),
          szInsertUUID(&pmsgMod->V1.uuidSourceDRA),
          pmsgMod->V1.pszSourceDRA
          ? szInsertSz(pmsgMod->V1.pszSourceDRA)
          : szInsertSz(""),
       szInsertUL(pmsgMod->V1.ulReplicaFlags),
       szInsertUL(pmsgMod->V1.ulModifyFields),
       szInsertUL(pmsgMod->V1.ulOptions),
       NULL, NULL);

   if (!IsDraAccessGranted(pTHS,
            pmsgMod->V1.pNC,
            &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &draError)) {
       DRA_EXCEPT_NOLOG(draError, 0);
   }

   if (NULL != pmsgMod->V1.pszSourceDRA) {
       pwszSourceServer
      = UnicodeStringFromString8(CP_UTF8,
                  pmsgMod->V1.pszSourceDRA,
                  -1);
   }

   draError = DirReplicaModify(
       pmsgMod->V1.pNC,
       &pmsgMod->V1.uuidSourceDRA,
       NULL, // puuidTransportObj
       pwszSourceServer,
       &pmsgMod->V1.rtSchedule,
       pmsgMod->V1.ulReplicaFlags,
       pmsgMod->V1.ulModifyFields,
       pmsgMod->V1.ulOptions
       );
    }
    __except ( GetDraException( GetExceptionInformation(), &draError ) )
    {
   ;
    }

    DEC( pcThread  );   // Perfmon hook      
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_MODIFY_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsReplicaModify,
          szInsertUL(draError),
          szInsertWin32Msg(draError),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }

    return draError;
}

ULONG
DRSReplicaDel_InputValidate(
    DWORD               dwMsgVersion,
    DRS_MSG_REPDEL *    pmsgDel
    )
/*
    [notify]  ULONG IDL_DRSReplicaDel( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwVersion,
    [switch_is][ref][in]  DRS_MSG_REPDEL *pmsgDel)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgVersion ) {
   ret = DRAERR_InvalidParameter; 
    }

    ret = DRS_MSG_REPDEL_V1_InputValidate(&(pmsgDel->V1)); 

    return ret;
}

ULONG
IDL_DRSReplicaDel(
    DRS_HANDLE          hDrs,
    DWORD               dwMsgVersion,
    DRS_MSG_REPDEL *    pmsgDel
    )
{
    THSTATE *   pTHS = pTHStls;
    ULONG       ret;
    LPWSTR      pwszSourceServer = NULL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSREPLICADEL);
    drsReferenceContext( hDrs );
    INC( pcThread );    // Perfmon hook

    __try {

   InitDraThread(&pTHS);

   if ((ret = DRSReplicaDel_InputValidate(dwMsgVersion, 
                      pmsgDel))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   Assert(1 == dwMsgVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_DEL_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsReplicaDel,
          szInsertDN(pmsgDel->V1.pNC),
          pmsgDel->V1.pszDsaSrc
          ? szInsertSz(pmsgDel->V1.pszDsaSrc)
          : szInsertSz(""),
       szInsertUL(pmsgDel->V1.ulOptions),
       NULL, NULL, NULL, NULL, NULL);

   if (!IsDraAccessGranted(pTHS,
            pmsgDel->V1.pNC,
            &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
       DRA_EXCEPT_NOLOG(ret, 0);
   }

   if (NULL != pmsgDel->V1.pszDsaSrc) {
       pwszSourceServer
      = UnicodeStringFromString8(CP_UTF8,
                  pmsgDel->V1.pszDsaSrc,
                  -1);
   }

   ret = DirReplicaDelete(
       pmsgDel->V1.pNC,
       pwszSourceServer,
       pmsgDel->V1.ulOptions
       );
    }
    __except( GetDraException( GetExceptionInformation(), &ret ) )
    {
   ;
    }

    DEC( pcThread  );   // Perfmon hook   
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_REPLICA_DEL_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsReplicaDel,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }

    return ret;
}

VOID
SplitSamAccountName(
    IN  WCHAR *AccountName,
    OUT WCHAR **DomainName,
    OUT WCHAR **UserName,
    OUT WCHAR **Separator
    )
//
// This simple routine breaks up a nt4 style composite name
// Note: the in arg AccountName is modified; Separator can be
// used to reset
//
{
    Assert( AccountName );
    Assert( DomainName );
    Assert( UserName );
    Assert( Separator );

    (*Separator) = wcschr( AccountName, L'\\' );
    if ( (*Separator) ) {
        *(*Separator) = L'\0';
        (*UserName) = (*Separator) + 1;
        (*DomainName) = AccountName;
    } else {
        (*UserName)  = AccountName;
        (*DomainName) = NULL;
    }

    return;
}

VOID
VerifySingleSamAccountNameWorker(
    IN THSTATE *    pTHS,
    IN PVOID        FilterValue,
    IN ULONG        FilterValueSize,
    IN ULONG        AttrType,
    IN DSNAME *     pSearchRoot,
    IN ULONG        Scope,
    IN BOOL         fSearchEnterprise,
    IN ATTRBLOCK    RequiredAttrs,
    OUT SEARCHRES **pSearchRes
)
/*++

    Routine Description

        This routine does a SearchBody() call on the parameters passed in.

    Parameters:

        pTHS              -- thread state
        UserName          -- the single name to lookup
        AttrType          -- sam account name or UPN
        pSearchRoot       -- the base of the search (domain or enterprise)
        fSearchEnterprise -- boolean on whether to span NC's
        RequiredAttrs     -- the attributes to return to the caller
        pSearchRes        -- the results of the search (allocated in this routine)

    Return Values:

        None --  the results of the search contain the desired information

--*/
{
    FILTER          filter;
    SEARCHARG       searchArg;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;

    // Set up the search arg
    attrValFilter.valLen = FilterValueSize;
    attrValFilter.pVal = (UCHAR *) FilterValue;

    memset(&filter, 0, sizeof(filter));
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = AttrType;
    filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    // We just want one result
    searchArg.CommArg.ulSizeLimit = 1;
    // PAS attributes only.
    searchArg.CommArg.Svccntl.fGcAttsOnly = TRUE;

    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = (UCHAR) Scope;
    searchArg.bOneNC = !fSearchEnterprise;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;

    (*pSearchRes) = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    (*pSearchRes)->CommRes.aliasDeref = FALSE;
    (*pSearchRes)->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, (*pSearchRes),0);

    return;

}


VOID
VerifySingleSamAccountName(
    IN THSTATE * pTHS,
    IN WCHAR*    AccountName,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine verifies a Single sam account name, by issuing a Search.
        If the name does not have a domain component, then we first try to
        search by UPN.

    Parameters:

        AccountName   -- The name to search
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf       -- Pointer to enfinf structure returning the
                         DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
        The error is in the thread state.

--*/
{
    NTSTATUS        NtStatus;
    DSNAME          *pSearchRoot = NULL;
    BOOL            fFreeSearchRoot = FALSE;
    SEARCHRES       *pSearchRes = NULL;
    BOOL            fSearchEnterprise = FALSE;
    ULONG           len;
    ULONG           AttrType;
    BOOL            fCheckXForest = FALSE;

    WCHAR           *DomainName = NULL, *UserName = NULL, *Separator = NULL;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    _try
    {
        ULONG cNamesCracked = 0;
        CrackedName *pCrackedNames = NULL;
        PVOID pData = NULL;
        ULONG cbData = 0;
        ULONG Scope = 0;

        //
        // First, split the name so we can determine what domain to search
        // for; if no domain then search the entire catalog.  Since sam account
        // name is indexed this isn't a bad as it sounds.
        //
        SplitSamAccountName( AccountName, &DomainName, &UserName, &Separator );

        Assert( UserName );
        if ( !UserName ) {
            // No user name? -- this is a bad parameter
            DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
        }

        if ( DomainName ) {

            len = 0;
            NtStatus = MatchDomainDnByNetbiosName( DomainName,
                                                   NULL,
                                                   &len );
            if ( NT_SUCCESS( NtStatus ) ) {

                pSearchRoot = (DSNAME*) THAllocEx(pTHS,len);
                fFreeSearchRoot = TRUE;
                NtStatus = MatchDomainDnByNetbiosName( DomainName,
                                                       pSearchRoot,
                                                       &len );
            }

            if ( !NT_SUCCESS( NtStatus)  ) {
                //
                // Try by dns name
                //
                len = 0;
                NtStatus = MatchDomainDnByDnsName( DomainName,
                                                   NULL,
                                                  &len );
                if ( NT_SUCCESS( NtStatus ) ) {

                    if (fFreeSearchRoot) {
                        THFreeEx(pTHS,pSearchRoot);
                        fFreeSearchRoot = FALSE;
                    }
                    pSearchRoot = (DSNAME*) THAllocEx(pTHS,len);
                    fFreeSearchRoot = TRUE;
                    NtStatus = MatchDomainDnByDnsName( DomainName,
                                                       pSearchRoot,
                                                       &len );
                }
            }

            if ( !NT_SUCCESS( NtStatus ) ) {

                //
                // Hmm. The domain can't be found.  Could it be
                // a cross-forest name? Will verify outside the _try block.
                //
                
                fCheckXForest = TRUE;
                _leave;
            }

            //
            // Set up parameters to the worker function
            //
            Scope = SE_CHOICE_WHOLE_SUBTREE;
            fSearchEnterprise = FALSE;
            AttrType = ATT_SAM_ACCOUNT_NAME;
            pData = UserName;
            cbData = wcslen(UserName) * sizeof(WCHAR);
            Assert( pSearchRoot );


        } else {

            //
            // Crack the name as a UPN.
            // N.B. If there are duplicate UPN's then crack name will
            // fail with
            //
            CrackNames( (gEnableXForest||(gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WIN_DOT_NET))?
                                DS_NAME_FLAG_TRUST_REFERRAL
                               :DS_NAME_NO_FLAGS,
                        GetACP(),  // what is the right value here?
                        GetSystemDefaultLangID(),
                        DS_USER_PRINCIPAL_NAME,
                        DS_NT4_ACCOUNT_NAME,
                        1,
                        &AccountName,
                        &cNamesCracked,
                        &pCrackedNames );

            // The function definition of CrackNames is such that the count
            // returned should always be the count given
            Assert( cNamesCracked == 1 );
            Assert( pCrackedNames );

            // Parse the results
            if ( CrackNameStatusSuccess(pCrackedNames[0].status)
             &&  (pCrackedNames[0].pDSName)
             &&  (pCrackedNames[0].pDSName->SidLen > 0) )
             {
                 //
                 // This is a UPN
                 //
                 Scope = SE_CHOICE_BASE_ONLY;
                 fSearchEnterprise = FALSE;
                 AttrType = ATT_OBJECT_SID;
                 pData = &pCrackedNames[0].pDSName->Sid;
                 cbData = pCrackedNames[0].pDSName->SidLen;
                 pSearchRoot = pCrackedNames[0].pDSName;

             } 
            else if ( DS_NAME_ERROR_TRUST_REFERRAL == pCrackedNames[0].status ) {
               
                // A hint is only returned to the caller if the whole forest
                // is in Whistler mode.

                Assert(gEnableXForest||gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WIN_DOT_NET);

                Assert(pCrackedNames[0].pDnsDomain);
                
                //
                // fabricate ENTINF data structure
                //

                pEntinf->pName = NULL;          
                pEntinf->ulFlags = 0;        
                pEntinf->AttrBlock.attrCount = 1;
                pEntinf->AttrBlock.pAttr = THAllocEx(pTHS, sizeof(ATTR));
                

                // Attribute FIXED_ATT_EX_FOREST is used as a hint
                pEntinf->AttrBlock.pAttr[0].attrTyp = FIXED_ATT_EX_FOREST;
                
                pEntinf->AttrBlock.pAttr[0].AttrVal.valCount = 1;
                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal = THAllocEx(pTHS,sizeof(ATTRVAL));
                
                //  pCrackedNames[0].pDnsDomain stores the DNS name of the trust forest
                // return this as part of the hint

                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen = sizeof(WCHAR)*(wcslen(pCrackedNames[0].pDnsDomain)+1);
                pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal = (UCHAR*)pCrackedNames[0].pDnsDomain;

                _leave;
                  
            }
            else if ( DS_NAME_ERROR_NOT_UNIQUE == pCrackedNames[0].status) {

                 //
                 // Duplicate UPN -- don't resolve
                 //
                 _leave;


             } else {

                 //
                 // Didn't crack as UPN -- try isolated name
                 //

                 // No domain name given -- use the root of the enterprise
                 // Note:  the "root" of the enterprise here means the top
                 // of the directory, which is represented by a DSNAME with
                 // with a NULL guid, 0 sid len and 0 name len.
                 Scope = SE_CHOICE_WHOLE_SUBTREE;
                 fSearchEnterprise = TRUE;
                 AttrType = ATT_SAM_ACCOUNT_NAME;
                 pData = UserName;
                 cbData = wcslen(UserName) * sizeof(WCHAR);

                 pSearchRoot = (DSNAME*) THAllocEx(pTHS,DSNameSizeFromLen( 0 ));
                 fFreeSearchRoot = TRUE;
                 pSearchRoot->structLen = DSNameSizeFromLen( 0 );

                 fCheckXForest = TRUE;
                 
             }
        }
        // Get the attributes
        Assert( pSearchRoot );
        Assert( pData );
        Assert( 0 != cbData );

        VerifySingleSamAccountNameWorker( pTHS,
                                          pData,
                                          cbData,
                                          AttrType,
                                          pSearchRoot,
                                          Scope,
                                          fSearchEnterprise,
                                          RequiredAttrs,
                                          &pSearchRes );

        //
        // Note that there may be more that one value returned (especially
        // in the case of searching for an unadorned sam account name. Return
        // the first one
        //
        Assert( pSearchRes );
        if ( pSearchRes->count >= 1 ) {
            *pEntinf = pSearchRes->FirstEntInf.Entinf;
        }

    }
    finally
    {
        if (fFreeSearchRoot) {
            THFreeEx(pTHS,pSearchRoot); 
        }
    }

    // OK, there are two cases we need to check if the name is a Xforet
    // domain name. 
    // 1. DomainName != NULL, but DomainName can be found locally;
    // 2. DomainName == NULL, but UserName can not be cracked as a UPN 
    // or a local samAccountName.
        
    if (fCheckXForest 
        && ( 0==pEntinf->AttrBlock.attrCount && NULL==pEntinf->pName )
        && ( gEnableXForest || gAnchor.ForestBehaviorVersion>=DS_BEHAVIOR_WIN_DOT_NET )) {
                        
        LSA_UNICODE_STRING Destination;
        LSA_UNICODE_STRING Domain;
        
        //
        // The cross-forest authorization feature is only for Whistler forest.
        // If the client DC is a win2k, the virtual attribute FIXED_ATT_EX_FOREST
        // may break the client.  So skip if the forest version is not at least whistler.
        //
        
              
        Domain.Buffer = (DomainName)?(DomainName):(UserName);
        Domain.Length = Domain.MaximumLength = (USHORT)(sizeof(WCHAR)*wcslen(Domain.Buffer));

        //
        // Try to find the NT4 domain name in the forest trust info.
        //

        NtStatus = LsaIForestTrustFindMatch( RoutingMatchDomainName,
                                             &Domain,
                                             &Destination );

        if( NT_SUCCESS(NtStatus) ){

            //
            // construct an ENTINF
            //
            pEntinf->pName = NULL;          
            pEntinf->ulFlags = 0;        
            pEntinf->AttrBlock.attrCount = 1;
            pEntinf->AttrBlock.pAttr = THAllocEx(pTHS, sizeof(ATTR));


            // Attribute FIXED_ATT_EX_FOREST is used as a hint
            pEntinf->AttrBlock.pAttr[0].attrTyp = FIXED_ATT_EX_FOREST;

            pEntinf->AttrBlock.pAttr[0].AttrVal.valCount = 1;
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal = THAllocEx(pTHS,sizeof(ATTRVAL));

            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen = Destination.Length+sizeof(WCHAR);
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal = THAllocEx(pTHS, Destination.Length+sizeof(WCHAR));
            memcpy(pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal, Destination.Buffer, Destination.Length);                
            pEntinf->AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal[Destination.Length/sizeof(WCHAR)] = 0;
            LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (LSAPR_UNICODE_STRING*)&Destination );
        }
    }


    // Reset the in arg
    if ( Separator ) {
        *Separator = L'\\';
    }
    
    return;
}

VOID
VerifySingleSid(
    IN THSTATE * pTHS,
    IN PSID pSid,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine verifies a Single Sid, by issuing a Search.

    Parameters:
        pSid -- The SID to verify.
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf -- Pointer to enfinf structure returning the
                   DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
--*/
{
    DSNAME          *pSearchRoot;
    FILTER          filter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRVAL         attrValFilter;
    ATTRBLOCK       *pAttrBlock;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    if (!FindNcForSid(pSid,&pSearchRoot))
    {
        // Could not find, continue cracking other Sids
        return;
    }

    attrValFilter.valLen = RtlLengthSid(pSid);
    attrValFilter.pVal = (UCHAR *) pSid;

    memset(&filter, 0, sizeof(filter));
    filter.choice = FILTER_CHOICE_ITEM;
    filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    filter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    filter.FilterTypes.Item.FilTypes.ava.Value = attrValFilter;

    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    // Search for multiples so as to verify uniqueness.
    searchArg.CommArg.ulSizeLimit = 2;
    // PAS attributes only.
    searchArg.CommArg.Svccntl.fGcAttsOnly = TRUE;

    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    // Do not Cross NC boundaries.
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &filter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;

    pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;
    pSearchRes->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, pSearchRes,0);

    if (1 == pSearchRes->count)
    {
        *pEntinf = pSearchRes->FirstEntInf.Entinf;
    }

    return;
}


VOID
VerifySingleFPO(
    IN THSTATE * pTHS,
    IN PSID pSid,
    IN ATTRBLOCK RequiredAttrs,
    OUT ENTINF * pEntinf
    )
/*++

    Routine Description

        This routine tries to find the Non FPO object, corresponding to
        the SID, by issuing a Search.

    Parameters:
        pSid -- The SID to verify.
        RequiredAttrs -- Set of Attrs that need to be read off the object
        pEntinf -- Pointer to enfinf structure returning the
                   DSName and requested attributes

    Return Values:

        On sucess the pEntInf is filled with all the information.
        Upon an error the pEntInf is zeroed out
--*/
{
    DSNAME          *pSearchRoot;
    FILTER          SidFilter;
    FILTER          FpoFilter;
    FILTER          AndFilter;
    FILTER          NotFilter;
    SEARCHARG       searchArg;
    SEARCHRES       *pSearchRes;
    ENTINFSEL       entInfSel;
    ATTRBLOCK       *pAttrBlock;
    ULONG           ObjectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);
    Assert(NULL != pEntinf);

    memset(pEntinf,0,sizeof(ENTINF));

    // Find the Root Domain Object, for the specified Sid
    // This ensures that we find only real security prinicpals,
    // but not turds ( Foriegn Domain Security Principal ) and
    // other objects in various other domains in the G.C that might
    // have been created in the distant past before all the DS
    // stuff came together

    if (!FindNcForSid(pSid,&pSearchRoot))
    {
        // Could not find, continue cracking other Sids
        return;
    }


    memset(&SidFilter, 0, sizeof(SidFilter));
    SidFilter.choice = FILTER_CHOICE_ITEM;
    SidFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    SidFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_SID;
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = RtlLengthSid(pSid);
    SidFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) pSid;

    memset(&FpoFilter, 0, sizeof(FILTER));
    FpoFilter.choice = FILTER_CHOICE_ITEM;
    FpoFilter.pNextFilter = NULL;
    FpoFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    FpoFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    FpoFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) &ObjectClass;

    memset(&NotFilter, 0, sizeof(FILTER));
    NotFilter.choice = FILTER_CHOICE_NOT;
    NotFilter.FilterTypes.pNot = &FpoFilter;

    memset(&AndFilter, 0, sizeof(FILTER));
    AndFilter.choice = FILTER_CHOICE_AND;
    AndFilter.pNextFilter = NULL;
    AndFilter.FilterTypes.And.count = 2;
    AndFilter.FilterTypes.And.pFirstFilter = &SidFilter;
    SidFilter.pNextFilter = &NotFilter;


    //
    // Build search arguement.
    // Note: set makeDeletionsAvail since we want to
    //       get TombStones
    //
    memset(&searchArg, 0, sizeof(SEARCHARG));
    InitCommarg(&searchArg.CommArg);
    searchArg.CommArg.Svccntl.makeDeletionsAvail = TRUE;
    // Search for multiples so as to verify uniqueness.
    searchArg.CommArg.ulSizeLimit = 2;
    // PAS attributes only.
    searchArg.CommArg.Svccntl.fGcAttsOnly = TRUE;

    entInfSel.attSel = EN_ATTSET_LIST;
    entInfSel.AttrTypBlock = RequiredAttrs;
    entInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    searchArg.pObject = pSearchRoot;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    // Do not Cross NC boundaries.
    searchArg.bOneNC = TRUE;
    searchArg.pFilter = &AndFilter;
    searchArg.searchAliases = FALSE;
    searchArg.pSelection = &entInfSel;
    searchArg.pSelectionRange = NULL;

    pSearchRes = (SEARCHRES *) THAllocEx(pTHS, sizeof(SEARCHRES));
    pSearchRes->CommRes.aliasDeref = FALSE;
    pSearchRes->PagedResult.pRestart = NULL;

    SearchBody(pTHS, &searchArg, pSearchRes,0);

    if (1 == pSearchRes->count)
    {
        *pEntinf = pSearchRes->FirstEntInf.Entinf;
    }

    return;
}

VOID
VerifyDSNAMEs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
{
    DWORD       i, dwErr;
    ULONG       len;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    // Verify each name via simple database lookup.
    // If name found, read ATT_OBJ_DIST_NAME property.

    for ( i = 0; i < pmsgIn->cNames; i++ )
    {
        memset(&(pmsgOut->rpEntInf[i]),0,sizeof(ENTINF));

        if ((fNullUuid(&pmsgIn->rpNames[i]->Guid))
            && (0==pmsgIn->rpNames[i]->NameLen)
            && (pmsgIn->rpNames[i]->SidLen>0))
        {
            //
            // For the special case of a SID only DS Name
            // do a VerifySingleSid
            //

            VerifySingleSid(
                pTHS,
                &(pmsgIn->rpNames[i]->Sid),
                pmsgIn->RequiredAttrs,
                &(pmsgOut->rpEntInf[i])
                );
        }
        else
        {
            __try
            {
                dwErr = DBFindDSName(pTHS->pDB,
                                     pmsgIn->rpNames[i]);
            }
            __except (HandleMostExceptions(GetExceptionCode()))
            {
                dwErr = DIRERR_OBJ_NOT_FOUND;
            }

            if ( !dwErr )
            {
                ENTINFSEL EntInfSel;

                EntInfSel.attSel =  EN_ATTSET_LIST;
                EntInfSel.AttrTypBlock = pmsgIn->RequiredAttrs;
                EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

                dwErr = GetEntInf(
                    pTHS->pDB,
                    &EntInfSel,
                    NULL,
                    &(pmsgOut->rpEntInf[i]),
                    NULL,
                    0,      // sd flags
                    NULL,
                    GETENTINF_GC_ATTRS_ONLY,
                    NULL,
                    NULL
                    );

                if ( dwErr )
                {
                    // Be safe.
                    memset(&(pmsgOut->rpEntInf[i]),0,sizeof(ENTINF));
                }
            }
        }
    }

    pmsgOut->cNames = pmsgIn->cNames;
}



VOID
VerifySamAccountNames_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
/*++

Routine Description

    This routine iterates through the passed in sam account names trying
    to resolve each one.  The sam account names are hidden in the StringName
    field of the dsname!

Parameters:

    pTHS    -- thread state
    pmsgIn  -- struct containing the sam account names
    psgmOut -- struct containing the entinf's of each resolved name

Return Values:

    None -- Any errors are set in the thread state

--*/

{
    DWORD           i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for ( i = 0; i < pmsgIn->cNames; i++ ) {

        //
        // Note the DSNAME is checked for to be valid in our
        // calling function -- this includes the StringName
        // being NULL terminated.
        //

        VerifySingleSamAccountName(pTHS,
                                   pmsgIn->rpNames[i]->StringName,
                                   pmsgIn->RequiredAttrs,
                                  &(pmsgOut->rpEntInf[i])
                                  );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}

VOID
VerifySIDs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut)
{
    DWORD           i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for ( i = 0; i < pmsgIn->cNames; i++ ) {

        VerifySingleSid(pTHS,
                       &pmsgIn->rpNames[i]->Sid,
                        pmsgIn->RequiredAttrs,
                       &(pmsgOut->rpEntInf[i])
                                  );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}


VOID
VerifyFPOs_V1(
    THSTATE                 *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut
    )
{
    DWORD   i;

    Assert(NULL != pTHS);
    Assert(NULL != pTHS->pDB);

    for (i = 0; i < pmsgIn->cNames; i++)
    {
        VerifySingleFPO(pTHS,
                        &pmsgIn->rpNames[i]->Sid,
                         pmsgIn->RequiredAttrs,
                        &(pmsgOut->rpEntInf[i])
                        );
    }

    pmsgOut->cNames = pmsgIn->cNames;
}

ULONG
DRSVerifyNames_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY *   pmsgOut
    ) 
/*
    [notify] ULONG IDL_DRSVerifyNames( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwInVersion,
    [switch_is][ref][in]  DRS_MSG_VERIFYREQ *pmsgIn,
    [ref][out]  DWORD *pdwOutVersion,
    [switch_is][ref][out]  DRS_MSG_VERIFYREPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgInVersion ) {
   DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
    }

    ret = DRS_MSG_VERIFYREQ_V1_InputValidate(&(pmsgIn->V1)); 

    return ret;
}

ULONG
IDL_DRSVerifyNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY *   pmsgOut
    )
{
    THSTATE *                   pTHS = pTHStls;
    ULONG                       ret = 0;
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap;
    SCHEMA_PREFIX_TABLE *       pLocalPrefixTable;
    DWORD                       i;
    CALLERTYPE                  callerType;
    
    DRS_Prepare(&pTHS, hDrs, IDL_DRSVERIFYNAMES);
    drsReferenceContext( hDrs );
    INC(pcThread);          // PerfMon hook
    
    __try {
        *pdwMsgOutVersion = 1; 
        memset(pmsgOut, 0, sizeof(DRS_MSG_VERIFYREPLY));
           
       // Initialize thread state and open data base.
       if (pmsgIn->V1.dwFlags==DRS_VERIFY_DSNAMES) {
           callerType=CALLERTYPE_INTERNAL;
       }
       else {
           callerType=CALLERTYPE_SAM;
       }
       if(!(pTHS = InitTHSTATE(callerType))) {
           // Failed to initialize a THSTATE.
           DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0);
       }

       if ((ret = DRSVerifyNames_InputValidate(dwMsgInVersion, 
                      pmsgIn,
                      pdwMsgOutVersion,
                      pmsgOut
                      ))!=DRAERR_Success) {
           Assert(!"RPC Server input validation error, contact Dsrepl");
           __leave;
       }

       Assert(1 == dwMsgInVersion);
       LogAndTraceEvent(TRUE,
              DS_EVENT_CAT_RPC_SERVER,
              DS_EVENT_SEV_EXTENSIVE,
              DIRLOG_IDL_DRS_VERIFY_NAMES_ENTRY,
              EVENT_TRACE_TYPE_START,
              DsGuidDrsVerifyNames,
              szInsertUL(pmsgIn->V1.cNames),
              szInsertUL(pmsgIn->V1.dwFlags),
              NULL, NULL, NULL, NULL, NULL, NULL);

       if (!IsDraAccessGranted(pTHS,
                gAnchor.pDomainDN,
                &RIGHT_DS_REPL_GET_CHANGES, &ret)) {
           DRA_EXCEPT_NOLOG(ret, 0);
       }
       
       // All of these name types require a GC for verification.
       switch (pmsgIn->V1.dwFlags)
       {
           case DRS_VERIFY_SIDS:
           case DRS_VERIFY_SAM_ACCOUNT_NAMES:
           case DRS_VERIFY_FPOS:
                
               if (!SampAmIGC()) {
                   ret = ERROR_DS_GC_REQUIRED; 
                    
                   // Set errCode equal to 0 to trigger failover to a GC
                   pmsgOut->V1.error = 0;
                   _leave;
               }
               break;
               
           default:
               break;
       }

       // Map ATTRTYPs from remote to local values.
       pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
       hPrefixMap = PrefixMapOpenHandle(&pmsgIn->V1.PrefixTable,
                    pLocalPrefixTable);

       if (!PrefixMapAttrBlock(hPrefixMap, &pmsgIn->V1.RequiredAttrs)) {
           DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
       }
       PrefixMapCloseHandle(&hPrefixMap);

       pTHS->fDSA = TRUE;
       DBOpen2(TRUE, &pTHS->pDB);
       
       __try
           {
           pmsgOut->V1.rpEntInf = (ENTINF *) THAllocEx(pTHS,
                         pmsgIn->V1.cNames * sizeof(ENTINF));
           pmsgOut->V1.PrefixTable = *pLocalPrefixTable;
           
           switch ( pmsgIn->V1.dwFlags )
           {
           case DRS_VERIFY_DSNAMES:
               
               // Verify we hold a local copy of the crossref each object is in.
               for ( i = 0; i < pmsgIn->V1.cNames; i++ )
               {   
                   DSNAME *pNC;
                   
                   if (pmsgIn->V1.rpNames[i]->NameLen > 0) {
                       
                       pNC = FindNCParentDSName(pmsgIn->V1.rpNames[i], 
                                                TRUE, 
                                                FALSE
                                                ); 
                       
                       if ( NULL == pNC && !SampAmIGC() ) {
                           // We don't hold the crossref, return an error to 
                           // indicate the caller should try a replica that 
                           // does or a GC.
                           ret = ERROR_DS_GC_REQUIRED; 
                             
                           // Set errCode equal to 0 to trigger failover to a GC
                           pmsgOut->V1.error = 0;
                           _leave;   
                       }
                   }
               }
               VerifyDSNAMEs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);   
               break;

           case DRS_VERIFY_SIDS:

               VerifySIDs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
               break;

           case DRS_VERIFY_SAM_ACCOUNT_NAMES:

               VerifySamAccountNames_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
               break;

           case DRS_VERIFY_FPOS:

               VerifyFPOs_V1(pTHS, &pmsgIn->V1, &pmsgOut->V1);
               break;

           default:

               DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
               break;
           }
       }
       __finally
       {
           // End the transaction.  Faster to commit a read only
           // transaction than abort it - so set commit to TRUE.
           DBClose(pTHS->pDB, TRUE);    
           
       }
    }
    __except (GetDraException((GetExceptionInformation()), &ret)) {
        ;
    }

    DEC(pcThread);
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
    LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_VERIFY_NAMES_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsVerifyNames,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    } 

    if ( ret ) {
    LogEvent(DS_EVENT_CAT_REPLICATION,
        DS_EVENT_SEV_BASIC,
        DIRLOG_DRA_CALL_EXIT_BAD,
        szInsertUL(ret),
        szInsertWin32Msg(ret),
        NULL);
    }
   
    return(ret);
}

BOOL
VerifyNCForMove(
    IN  DSNAME          *pSrcObject,
    IN  DSNAME          *pDstObject,
    IN  DSNAME          *pExpectedTargetNC,
    OUT NAMING_CONTEXT  **ppSrcNC,
    OUT DWORD           *pErr
    )
/*++

  Routine Description:

    Determines whether the NC which will hold the cross-domain-moved
    object is writeable at this replica and that various other cross
    domain move constraints are met.

  Parameters:

    pSrcObject - DSNAME pointer of the source object.

    pDstObject - DSNAME pointer identifying the new/destination object.

    pExpectedTargetNC - DSNAME pointer identifying the NC the source
        thinks should contain the target object.

    ppSrcNC - Receives naming context of source object on return.

    pErr = Receives DIRERR_* error code on return.

  Return Values:

    TRUE or FALSE as appropriate.

--*/
{
    CROSS_REF       *pCR;
    NAMING_CONTEXT  *pNC;
    COMMARG         commArg;
    ATTRBLOCK       *pBN;
    NTSTATUS        status;
    BOOLEAN         fMixedMode = TRUE;

    *ppSrcNC = NULL;
    *pErr = DIRERR_INTERNAL_FAILURE;
    InitCommarg(&commArg);

    // We may or may not have the source object depending on if we're
    // a GC or not.  Had we the source object, then we'd expect our
    // cross ref cache to be correct, thus FindBestCrossRef should be
    // accurate.  Had we not the source object, then FindBestCrossRef
    // is still the best we can do to determine the source object's NC,
    // though it may not be accurate due to replication latency, etc.

    if ( NULL == (pCR = FindBestCrossRef(pSrcObject, &commArg)) )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    *ppSrcNC = pCR->pNC;

    // Check destination values.

    if ( NULL == (pCR = FindBestCrossRef(pDstObject, &commArg)) )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    if ( !NameMatched(pCR->pNC, pExpectedTargetNC) )
    {
        // Source and destination are not in synch with respect
        // to the NCs in the enterprise.
        *pErr = DIRERR_DST_NC_MISMATCH;
        return(FALSE);
    }

    if ( NameMatched(*ppSrcNC, pCR->pNC) )
    {
        // Intra-domain move masquerading as inter-domain move.
        *pErr = DIRERR_SRC_AND_DST_NC_IDENTICAL;
        return(FALSE);
    }

    if (    NameMatched(pCR->pNC, gAnchor.pConfigDN)
         || NameMatched(pCR->pNC, gAnchor.pDMD) )
    {
        // Attempt to move into config or schema NC.
        *pErr = ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION;
        return(FALSE);
    }

    if ( DSNameToBlockName(pTHStls, pDstObject, &pBN, DN2BN_LOWER_CASE) )
    {
        *pErr = DIRERR_INTERNAL_FAILURE;
        return(FALSE);
    }

    commArg.Svccntl.dontUseCopy = TRUE;
    pNC = FindNamingContext(pBN, &commArg);
    FreeBlockName(pBN);

    if ( !pNC )
    {
        *pErr = DIRERR_CANT_FIND_EXPECTED_NC;
        return(FALSE);
    }

    if ( !NameMatched(pNC, pCR->pNC) )
    {
        *pErr = DIRERR_NOT_AUTHORITIVE_FOR_DST_NC;
        return(FALSE);
    }

    // Disallow move into mixed-mode domains.  This is because the downlevel
    // DCs don't understand SID-History, and thus clients will have different
    // tokens depending on whether an uplevel or downlevel DC authenticated
    // them.  The effect of this is deemed undesirable - especially considering
    // the possibility of deny ACEs.  Its also a difficult scenario to
    // identify in the field, so we disallow it.

    Assert(RtlValidSid(&pNC->Sid));
    status = SamIMixedDomain2((PSID) &pNC->Sid, &fMixedMode);

    if ( !NT_SUCCESS(status) )
    {
        *pErr = RtlNtStatusToDosError(status);
        return(FALSE);
    }

    if ( fMixedMode )
    {
        *pErr = ERROR_DS_DST_DOMAIN_NOT_NATIVE;
        return(FALSE);
    }

    *pErr = 0;
    return(TRUE);
}

ULONG
PrepareForInterDomainMove(
    IN THSTATE                  *pTHS,
    IN PDSNAME                  pOldDN,
    IN PDSNAME                  pNewDN,
    IN SYNTAX_DISTNAME_BINARY   *pSrcProxyVal
    )
/*++

  Routine Description:

    Determines if it is legal to to perform the remote add and if
    necessary, converts an existing object to a phantom in preparation.

  Parameters:

    pTHS - pointer to THSTATE with open DBPOS.

    pOldDN - Pointer to DSNAME of object we wish to replace.

    pNewDN - Pointer to DSNAME of object we wish to add.

    pSrcProxyVal - NULL or pointer to value for ATT_PROXIED_OBJECT_NAME
        for the source object.

  Return Values:

     pTHS->errCode

--*/
{
    // Let's use a notation like O(g1,s1,sn1) where:
    //
    //      g1  - indicates GUID of value 1 (pre-move GUID)
    //      s1  - indicates SID of value 1 (pre-move SID)
    //      sn1 - indicates StringName of value 1 (pre-move StringName)
    //
    // and 'X' will mean don't care and '!' means negation..
    //
    // The source is asking us to add O(g1,s2,sn2) where g1 is
    // the GUID from the source domain, s2 is the SID we will
    // assign in the destination domain and sn2 is a StringName
    // in the destination domain (us) chosen by the original caller
    // in the source domain.  We further assume that VerifyNCForMove
    // has passed - thus we are authoritive for sn2's domain.
    //
    // We don't have to make any checks on SID under the assumption
    // that we're not providing a SID on the add - we'll be assigning
    // a new one of our own.

    DSNAME                  *pGuidDN;
    DSNAME                  *pOldStringDN;
    DSNAME                  *pNewStringDN;
    DWORD                   cb;
    DWORD                   fPhantomConversionRequired = FALSE;
    DWORD                   dwErr;
    DSNAME                  *pXDN;
    DSNAME                  *pAccurateOldDN;
    ULONG                   len;
    GUID                    *pGuid;
    CROSS_REF               *pCR, *pSrcCR, *pDstCR;
    COMMARG                 commArg;
    NAMING_CONTEXT          *pNC;
    DWORD                   srcEpoch;
    DWORD                   dstEpoch;
    SYNTAX_DISTNAME_BINARY  *pDstProxyVal;
    SYNTAX_BOOLEAN          fIsDeleted;
    UCHAR                   *pfIsDeleted = (UCHAR *) &fIsDeleted;

    if (    fNullUuid(&pOldDN->Guid)
         || fNullUuid(&pNewDN->Guid)
         || !pOldDN->NameLen
         || !pNewDN->NameLen
         || memcmp(&pOldDN->Guid, &pNewDN->Guid, sizeof(GUID)) )
    {
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
    }

    // GUID only DSNAME checks:

    cb = DSNameSizeFromLen(0);
    pGuidDN = (DSNAME *) THAllocEx(pTHS,cb);
    pGuidDN->structLen = cb;
    memcpy(&pGuidDN->Guid, &pOldDN->Guid, sizeof(GUID));

    dwErr = DBFindDSName(pTHS->pDB, pGuidDN);

    THFreeEx(pTHS,pGuidDN);

    switch ( dwErr )
    {
    case 0:

        // O(g1,SX,snX) exists as a real object.  Check its string name.

        if ( DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME,
                         0, 0, &len, (UCHAR **) &pAccurateOldDN) )
        {
            return(SetSvcError(SV_PROBLEM_DIR_ERROR,
                               DIRERR_INTERNAL_FAILURE));
        }

        if ( !NameMatchedStringNameOnly(pAccurateOldDN, pOldDN) )
        {
            // Source and destination do not agree on current string name
            // of object.  Reject the call as this implies they don't have
            // a consistent view of O(g1,SX,snX) at this time.

            // DaveStr - 10/29/98 - Weaken this condition for the move tree
            // utility which renames objects at the source before moving them.
            // In this case, the destination won't have the proper name.  But
            // its OK as long as source and destination agree on the NC.

            InitCommarg(&commArg);
            if (    !(pSrcCR = FindBestCrossRef(pOldDN, &commArg))
                 || !(pDstCR = FindBestCrossRef(pAccurateOldDN, &commArg))
                 || !NameMatched(pSrcCR->pNC, pDstCR->pNC) )
            {
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_SRC_NAME_MISMATCH));
            }
        }

        // N.B. Its really only now that we can trust VerifyNCForMove's
        // decisions about the source NC as it based its tests on what
        // the source claimed was the source NC.  Since the string
        // names matched in the above test, we now know that source and
        // destination are truly in agreement regarding the source NC.

        // Check deletion status.

        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_IS_DELETED,
                            DBGETATTVAL_fCONSTANT, sizeof(fIsDeleted),
                            &len, &pfIsDeleted);
        switch ( dwErr )
        {
        case 0:
            if ( fIsDeleted )
            {
                // The object is deleted but source doesn't know it yet.
                return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                    DIRERR_CANT_MOVE_DELETED_OBJECT));
            }
            break;
        case DB_ERR_NO_VALUE:
            break;
        default:
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE));
            break;
        }

        // Check respective epoch numbers.

        srcEpoch = (pSrcProxyVal ? GetProxyEpoch(pSrcProxyVal) : 0);
        dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_PROXIED_OBJECT_NAME,
                             0, 0, &len, (UCHAR **) &pDstProxyVal);
        switch ( dwErr )
        {
        case 0:
            dstEpoch = GetProxyEpoch(pDstProxyVal);
            break;
        case DB_ERR_NO_VALUE:
            dstEpoch = 0;
            break;
        default:
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_INTERNAL_FAILURE));
        }

        if ( srcEpoch != dstEpoch )
        {
            // Source and destination do not agree on current epoch number
            // of object.  Reject the call as this implies they don't have
            // a consistent view of O(g1,SX,snX) at this time.

            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                DIRERR_EPOCH_MISMATCH));
        }

        // All tests passed.

        fPhantomConversionRequired = TRUE;
        break;

    case DIRERR_NOT_AN_OBJECT:

        // O(g1,sX,snX) exists as a phantom.  We don't particularly care
        // if the string names match as we know phantom string names converge
        // with the real name of the object with much higher latency due
        // to the scheduling of the phantom cleanup daemon.  This phantom
        // will get the new name when promoted during the add.  However, we
        // can assert that the phantom doesn't have an ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // Old StringName only DSNAME checks:

    if ( pNewDN->structLen > pOldDN->structLen )
        cb = pNewDN->structLen;
    else
        cb = pOldDN->structLen;
    pOldStringDN = (DSNAME *) THAllocEx(pTHS, cb);
    pOldStringDN->structLen = cb;
    pOldStringDN->NameLen = pOldDN->NameLen;
    wcscpy(pOldStringDN->StringName, pOldDN->StringName);

    dwErr = DBFindDSName(pTHS->pDB, pOldStringDN);

    switch ( dwErr )
    {
    case 0:

        // O(gX,sX,sn1) exists as an object. Check its GUID.

        if (    DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_GUID,
                            0, 0, &len, (UCHAR **) &pGuid)
             || memcmp(pGuid, &pOldDN->Guid, sizeof(GUID)) )
        {
            // Source and destination do not agree on GUID of object.
            // Reject the call as this implies they don't have a consistent
            // view of O(gX,SX,sn1) at this time.

            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                DIRERR_SRC_GUID_MISMATCH));
        }

        // No need to check epoch numbers or deletion status as we now know
        // this is the same object that was tested above and which already
        // passed those tests.

        fPhantomConversionRequired = TRUE;
        break;

    case DIRERR_NOT_AN_OBJECT:

        // O(gX,sX,sn1) exists as a phantom.  If its GUID matches the object
        // being added, then we're covered as described in the pGuidDN case
        // above.  If its GUID doesn't match the object being added, then
        // this must be a stale phantom whose string name the phantom cleanup
        // daemon will improve over time.  However, we can still assert
        // that the phantom doesn't have an ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:

        return(SetNamError( NA_PROBLEM_BAD_ATT_SYNTAX,
                            pOldStringDN,
                            DIRERR_BAD_NAME_SYNTAX));
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // New StringName only DSNAME checks.  Note that VerifyNCForMove already
    // verified that the new string name is in an NC we are authoritive for.

    pNewStringDN = pOldStringDN;
    memset(pNewStringDN, 0, cb);
    pNewStringDN->structLen = cb;
    pNewStringDN->NameLen = pNewDN->NameLen;
    wcscpy(pNewStringDN->StringName, pNewDN->StringName);

    dwErr = DBFindDSName(pTHS->pDB, pNewStringDN);

    switch ( dwErr )
    {
    case 0:

   //
   // Object already exists.  Just fall through and let LocalAdd
   // handle this problem since it has logic for figuring out whether
   // the client is allowed to know the existence of this object.
   //
   break;

    case DIRERR_NOT_AN_OBJECT:

        // O(gX,sX,sn2) exists as a phantom.  If this phantom's GUID
        // matches that of the object being added, then its name won't
        // need to change during promotion.  If its GUID does not match
        // the object being added, then CheckNameForAdd will kindly mangle
        // its name such that our add proceeds as desired.  However,
        // we can still assert that the phantom doesn't have an
        // ATT_PROXIED_OBJECT_NAME.

        Assert(DB_ERR_NO_VALUE == DBGetAttVal(pTHS->pDB, 1,
                                              ATT_PROXIED_OBJECT_NAME,
                                              0, 0, &len,
                                              (UCHAR **) &pDstProxyVal));
        break;

    case DIRERR_OBJ_NOT_FOUND:

        // Nothing found - nothing to complain about!
        break;

    case DIRERR_BAD_NAME_SYNTAX:
    case DIRERR_NAME_TOO_MANY_PARTS:
    case DIRERR_NAME_TOO_LONG:
    case DIRERR_NAME_VALUE_TOO_LONG:
    case DIRERR_NAME_UNPARSEABLE:
    case DIRERR_NAME_TYPE_UNKNOWN:

        return(SetNamError( NA_PROBLEM_BAD_ATT_SYNTAX,
                            pNewStringDN,
                            DIRERR_BAD_NAME_SYNTAX));
        break;

    default:

        // Some kind of lookup error.
        return(SetSvcError(SV_PROBLEM_DIR_ERROR, DIRERR_INTERNAL_FAILURE));
        break;
    }

    // All checks pass - create phantom if required.

    if ( fPhantomConversionRequired )
    {
        if ( dwErr = PhantomizeObject(pAccurateOldDN, pOldStringDN, TRUE) )
        {
            Assert(dwErr == pTHS->errCode);
            return(dwErr);
        }

        Assert(DIRERR_NOT_AN_OBJECT == DBFindDSName(
                                            pTHS->pDB,
                                            pOldStringDN));
    }

    return(pTHS->errCode);
}

VOID
DupAttr(
    THSTATE *pTHS,
    ATTR    *pInAttr,
    ATTR    *pOutAttr
    )
/*++

  Routine Description:

    Reallocate a single ATTR.

  Parameters:

    pInAttr = Pointer to IN ATTR to dup.

    pOutAttr - Pointer to OUT ATTR which receives dup'd value.

  Return Values:

    None.

--*/
{
    ULONG   valCount;
    ULONG   valLen;
    ULONG   i;

    pOutAttr->attrTyp = pInAttr->attrTyp;
    valCount = pInAttr->AttrVal.valCount;
    pOutAttr->AttrVal.valCount = valCount;
    pOutAttr->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                                    sizeof(ATTRVAL) * valCount);
    memset(pOutAttr->AttrVal.pAVal, 0, sizeof(ATTRVAL) * valCount);

    for ( i = 0; i < valCount; i++ )
    {
        valLen = pInAttr->AttrVal.pAVal[i].valLen;
        pOutAttr->AttrVal.pAVal[i].valLen = valLen;
        pOutAttr->AttrVal.pAVal[i].pVal = (UCHAR *) THAllocEx(pTHS, valLen);
        memcpy( pOutAttr->AttrVal.pAVal[i].pVal,
                pInAttr->AttrVal.pAVal[i].pVal,
                valLen);
    }
}

ULONG
DupAndFilterRemoteAttr(
    THSTATE     *pTHS,
    ATTR        *pInAttr,
    CLASSCACHE  *pCC,
    BOOL        *pfKeep,
    ATTR        *pOutAttr,
    BOOL        fSamClass,
    ULONG       iSamClass
    )
/*++

  Routine Description:

    Filter and morph remote add ATTR to a form the destination (us)
    will find acceptable.  For example, we don't want the original SD,
    we don't want the full class hierarchy in ATT_OBJECT_CLASS, etc.

  Parameters:

    pInAttr - Pointer to IN ATTR to dup/filter.

    pCC - Pointer to CLASS_CACHE for this object.

    pfKeep - Pointer to BOOL set to TRUE if this attribute is to be kept.

    pOutAttr - Pointer to OUT ATTR to receive dup/filter data.

    fSamClass - BOOL indicating whether this is a SAM class of object.

    iSamClass - Index into ClassMappingTable if this is a SAM class of object.

  Return Values:

    pTHS->errCode

--*/
{
    ATTCACHE                *pAC;
    DWORD                   control;
    ULONG                   samAttr;
    ULONG                   cAttrMapTable;
    SAMP_ATTRIBUTE_MAPPING  *rAttrMapTable;
    LARGE_INTEGER           li;

    *pfKeep = FALSE;

    if (!(pAC = SCGetAttById(pTHS, pInAttr->attrTyp)))
    {
        return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                            DIRERR_OBJ_CLASS_NOT_DEFINED));
    }

    // Pre-emptively drop all backlink attributes as they are
    // constructed by the DB layer, not written explicitly.
    // Ditto for non-replicated attributes, system add reserved
    // attributes, secret data attributes which require special
    // decryption/encryption, and attributes identifying the RDN
    // as they are reverse engineered by LocalAdd.  See ATT_RDN
    // below as well.
    //
    // A crossDomainMove is treated as an originating add at the
    // target (us). LocalAdd will determine which attr is the
    // rdnType and will insure that the column is set correctly.
    // Or it will fail if the needed values are not present.
    // For now, ignore the rdnattid of the object's class because
    // that class may have been superceded.

    if (    FIsBacklink(pAC->ulLinkID)
         || pAC->bIsNotReplicated
         || SysAddReservedAtt(pAC)
         || DBIsSecretData(pAC->id) )
    {
        return(0);
    }

    // Now strip out those things that SAM doesn't allow write for.
    // This logic is similar to that of SampAddLoopbackRequired.

    if ( fSamClass )
    {
        cAttrMapTable = *ClassMappingTable[iSamClass].pcSamAttributeMap;
        rAttrMapTable = ClassMappingTable[iSamClass].rSamAttributeMap;

        // Iterate over this SAM class' mapped attributes.

        for ( samAttr = 0; samAttr < cAttrMapTable; samAttr++ )
        {
            if ( pInAttr->attrTyp == rAttrMapTable[samAttr].DsAttributeId )
            {
                switch ( rAttrMapTable[samAttr].writeRule )
                {
                case SamReadOnly:           return(0);                  break;
                case SamWriteRequired:      NULL;                       break;
                case NonSamWriteAllowed:    NULL;                       break;
                default:                    Assert(!"Missing case");    break;
                }
            }
        }
    }

    // Finish up with some attribute-specific filtering.

    switch ( pInAttr->attrTyp )
    {
    case ATT_OBJECT_CLASS:

        // The object-class attribute is multivalued, containing the
        // hierarchy of class values for this object. Only use the most
        // specific class ID, the one in the first value, and do this by
        // just resetting the value count to 1, Don't bother resizing
        // the memory block.

        DupAttr(pTHS, pInAttr, pOutAttr);
        pOutAttr->AttrVal.valCount = 1;
        *pfKeep = TRUE;
        return(0);

    case ATT_USER_ACCOUNT_CONTROL:

        // Note that the DS persists UF_* values as per lmaccess.h,
        // not USER_* values as per ntsam.h.  Restrict moves of DCs
        // and trust objects.  WKSTA and server can move.

        if (    (1 != pInAttr->AttrVal.valCount)
             || (NULL == pInAttr->AttrVal.pAVal)
             || (sizeof(DWORD) != pInAttr->AttrVal.pAVal->valLen)
                // Abort on things that we refuse to move.
             || (control = * (DWORD *) pInAttr->AttrVal.pAVal->pVal,
                 (control & UF_SERVER_TRUST_ACCOUNT))       // DC
             || (control & UF_INTERDOMAIN_TRUST_ACCOUNT) )  // SAM trust
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
        }

        DupAttr(pTHS, pInAttr, pOutAttr);

        // Murli claims that since we're creating a new account it
        // should not be locked by default.  Note that other state
        // comes over as is - eg: account disabled or password
        // change required on next logon.

        control = * (DWORD *) pOutAttr->AttrVal.pAVal->pVal;
        control &= ~UF_LOCKOUT;
        * (DWORD *) pOutAttr->AttrVal.pAVal->pVal = control;
        *pfKeep = TRUE;
        return(0);

    case ATT_PWD_LAST_SET:

        // Carry forward zero value as zero, non-zero as 0xffff...
        // See _SampWriteUserPasswordExpires for more info.

        if (    (1 != pInAttr->AttrVal.valCount)
             || (NULL == pInAttr->AttrVal.pAVal)
             || (sizeof(LARGE_INTEGER) != pInAttr->AttrVal.pAVal->valLen) )
        {
            return(SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                                ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION));
        }

        DupAttr(pTHS, pInAttr, pOutAttr);
        li = * (LARGE_INTEGER *) pOutAttr->AttrVal.pAVal->pVal;
        if ( (0 != li.LowPart) || (0 != li.HighPart) )
        {
            li.LowPart = li.HighPart = 0xffffffff;
            * (LARGE_INTEGER *) pOutAttr->AttrVal.pAVal->pVal = li;
        }
        *pfKeep = TRUE;
        return(0);

    // NOTE - FOLLOWING ARE FALL-THROUGH FALSE CASES.

    case ATT_PROXIED_OBJECT_NAME:
        // Cross domain move code sets this explicitly itself.
    case ATT_RDN:
        // Core will create RDN from the DN automatically.  We strip it
        // here in case this is a rename (as well as move) as the ATT_RDN
        // sent over from the source doesn't match the last component
        // of the DN any more.
    case ATT_OBJECT_CATEGORY:
        // We assign our own based on the defaulting mechanism.
    case ATT_OBJECT_GUID:
        // Don't need this as the GUID should have been in the DSNAME.
    case ATT_OBJ_DIST_NAME:
        // This will be recreated locally by DirAddEntry.
    case ATT_OBJECT_SID:
        // SAM will assign one of its own.
    case ATT_SID_HISTORY:
        // We'll treat this one specially later on so skip it.
    case ATT_NT_SECURITY_DESCRIPTOR:
        // Core will assign a new one based on local defaults so skip it.
    case ATT_ADMIN_COUNT:
    case ATT_OPERATOR_COUNT:
    case ATT_PRIMARY_GROUP_ID:
        // SAM will reset to domain users.
    case ATT_REPL_PROPERTY_META_DATA:
    case ATT_WHEN_CREATED:
    case ATT_WHEN_CHANGED:
    case ATT_USN_CREATED:
    case ATT_USN_CHANGED:
        // Misc. attributes that should not move across domains or we
        // will generate outselves.

    case ATT_SYSTEM_FLAGS:
    case ATT_INSTANCE_TYPE:
        // Destination will set this.

        return(0);


    default:

        DupAttr(pTHS, pInAttr, pOutAttr);
        *pfKeep = TRUE;
        return(0);
    }

    Assert(!"Should never get here");
    return(0);
}

ULONG
DupAndMassageInterDomainMoveArgs(
    THSTATE                     *pTHS,
    ATTRBLOCK                   *pIn,
    SCHEMA_PREFIX_MAP_HANDLE    hPrefixMap,
    ATTRBLOCK                   **ppOut,
    BOOL                        *pfSamClass,
    SYNTAX_DISTNAME_BINARY      **ppProxyValue,
    ULONG                       *pSrcRid
    )
/*++

  Routine Description:

    The incoming attribute buffer may not have been allocated with
    MIDL_user_allocate, since RPC may unmarshall the arguments in place
    in the RPC transmit buffer. If the attribute buffer does not contain
    a security descriptor, DirAddEntry will reallocate the attributes,
    adding in a descriptor. If the buffer was unmarshalled in place,
    the reallocation will fail with an invalid memory address
    (because the block was not allocated via THAlloc (or HeapAlloc).
    To avoid this problem, the attributes are explicitly reallocated
    with the DS allocator, and then passed into DirAddEntry.  Also
    performs ATTRTYP mapping.  Also filters attributes and values so
    they conform to what we want to add at destination.

  Parameters:

    pIn - Pointer to original ATTRBLOCK.

    hPrefixMap - Handle for mapping ATTRTYPs.

    ppOut - Pointer to pointer to out ATTRBLOCK.

    pSrcRid - Pointer to receive value of source RID if present.

  Return Values:

    pTHS->errCode

--*/
{
    ATTR            *pInAttr, *pOutAttr;
    ATTR            *pSid = NULL;
    ATTR            *pSidHistory = NULL;
    ATTR            *pNewSidHistory = NULL;
    ATTR            *pObjectClass = NULL;
    ULONG           i, j, valCount, valLen;
    CROSS_REF_LIST  *pCRL;
    NT4SID          domainSid;
    CLASSCACHE      *pCC;
    ULONG           iSamClass;
    BOOL            fKeep;
    DWORD           dwErr;

    Assert(VALID_THSTATE(pTHS));

    *ppProxyValue = NULL;
    *pSrcRid = 0;

    // Grab the object class right away as we need it as an argument for
    // subsequent helper routines.  Map attrTyps while we're there.
    // Identify a few other special attributes as well.

    for ( i = 0; i < pIn->attrCount; i++ )
    {
        pInAttr = &pIn->pAttr[i];

        // Map ATTRTYPs in the inbound ATTR to their local equivalents.

        if ( !PrefixMapAttr(hPrefixMap, pInAttr) )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_DRA_SCHEMA_MISMATCH));
        }

        switch ( pInAttr->attrTyp )
        {
        case ATT_OBJECT_SID:            pSid = pInAttr;             break;
        case ATT_SID_HISTORY:           pSidHistory = pInAttr;      break;
        case ATT_OBJECT_CLASS:          pObjectClass = pInAttr;     break;
        case ATT_PROXIED_OBJECT_NAME:
            Assert(1 == pInAttr->AttrVal.valCount);
            Assert(pInAttr->AttrVal.pAVal[0].valLen > sizeof(DSNAME));
            Assert(NULL != pInAttr->AttrVal.pAVal[0].pVal);
            *ppProxyValue = (SYNTAX_DISTNAME_BINARY *)
                                            pInAttr->AttrVal.pAVal[0].pVal;
            break;
        }
    }

    if (    !pObjectClass
         || (0 == pObjectClass->AttrVal.valCount)
         || (!pObjectClass->AttrVal.pAVal)
         || (pObjectClass->AttrVal.pAVal[0].valLen != sizeof(DWORD))
         || (!pObjectClass->AttrVal.pAVal[0].pVal)
         || (NULL == (pCC = SCGetClassById(pTHS,
                        * (ATTRTYP *) pObjectClass->AttrVal.pAVal[0].pVal))))
    {
        return(SetUpdError( UP_PROBLEM_OBJ_CLASS_VIOLATION,
                            DIRERR_OBJ_CLASS_NOT_DEFINED));
    }

    // A crossDomainMove is treated as an originating add at the
    // target (us). LocalAdd will determine which attr is the
    // rdnType and will insure that the column is set correctly.
    // Or it will fail if the needed values are not present.
    // For now, ignore the rdnattid of the object's class because
    // that class may have been superceded.

    // See if this is a SAM class.

    *pfSamClass = SampSamClassReferenced(pCC, &iSamClass);

    // Dup/filter attributes appropriately.

    *ppOut = (ATTRBLOCK *) THAllocEx(pTHS, sizeof(ATTRBLOCK));
    memset(*ppOut, 0, sizeof(ATTRBLOCK));
    // Allocate one extra for ATT_SID_HISTORY if we need it.
    (*ppOut)->pAttr = (ATTR *) THAllocEx(pTHS, sizeof(ATTR) * (pIn->attrCount+1));
    memset((*ppOut)->pAttr, 0, sizeof(ATTR) * (pIn->attrCount+1));
    pOutAttr = &(*ppOut)->pAttr[0];

    for ( i = 0; i < pIn->attrCount; i++ )
    {
        pInAttr = &pIn->pAttr[i];

        if ( dwErr = DupAndFilterRemoteAttr(pTHS,
                                            pInAttr,
                                            pCC,
                                            &fKeep,
                                            pOutAttr,
                                            *pfSamClass,
                                            iSamClass) )
        {
            Assert(dwErr == pTHS->errCode);
            return(dwErr);
        }
        else if ( !fKeep )
        {
            // This attribute is not to be retained.
            continue;
        }

        pOutAttr = &(*ppOut)->pAttr[++((*ppOut)->attrCount)];
    }

    // Handle SID and SID history.  We're assuming the source DC sent us
    // the object as-is without any munging.  General plan is to place
    // current SID into the SID history.  Perform sanity checks as we go.
    // Test for both existing SID and whether we think this is a SAM class.

    if ( pSid && *pfSamClass )
    {
        Assert(ATT_OBJECT_SID == pSid->attrTyp);

        // Abort if SID is malformed or doesn't represent a domain we
        // know about.  Shouldn't happen if we trust our peer DC, but
        // caution is in order when dealing with security principals.

        if (    (1 != pSid->AttrVal.valCount)
             || (pSid->AttrVal.pAVal[0].valLen > sizeof(NT4SID))
             || !RtlValidSid((PSID) pSid->AttrVal.pAVal[0].pVal) )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC));
        }

        SampSplitNT4SID(
                    (PSID) pSid->AttrVal.pAVal[0].pVal,
                    &domainSid,
                    pSrcRid);

        for ( pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR )
        {
            if (    (pCRL->CR.flags & FLAG_CR_NTDS_NC)
                 && (pCRL->CR.flags & FLAG_CR_NTDS_DOMAIN)
                 && (RtlEqualSid(&domainSid, &pCRL->CR.pNC->Sid) ) )
            {
                break;
            }
        }

        if ( !pCRL )
        {
            return(SetSvcError( SV_PROBLEM_DIR_ERROR,
                                DIRERR_CANT_FIND_EXPECTED_NC));
        }

        // pOutAttr points at next free attr in array - use it to construct
        // a new SID history.  Note that we're inside a test on pSid.  This
        // means we won't carry forward a SID history for an object which
        // itself has no SID.

        pNewSidHistory = pOutAttr;

        if ( !pSidHistory )
        {
            // No old SID history, build a new, 1-element SID history.
            *pNewSidHistory = *pSid;
            pNewSidHistory->attrTyp = ATT_SID_HISTORY;
        }
        else
        {
            // There is an old SID history.   Build a new one which is
            // stretched to include both old SID and old history.

            Assert(ATT_SID_HISTORY == pSidHistory->attrTyp);

            pNewSidHistory->attrTyp = ATT_SID_HISTORY;
            pNewSidHistory->AttrVal.valCount = 0;
            pNewSidHistory->AttrVal.pAVal = (ATTRVAL *) THAllocEx(pTHS,
                    (pSidHistory->AttrVal.valCount + 1) * sizeof(ATTRVAL));
            pNewSidHistory->AttrVal.valCount = 1;
            pNewSidHistory->AttrVal.pAVal[0] = pSid->AttrVal.pAVal[0];

            for ( i = 0, j = 1; i < pSidHistory->AttrVal.valCount; i++ )
            {
                // Filter out of the SID history any mal-formed SIDs.  Do not
                // check whether we can map the SIDs in the history to existing
                // domains as there may be legitimate reason for that domaain
                // to no longer exist.

                if (    (pSidHistory->AttrVal.pAVal[i].valLen <= sizeof(NT4SID))
                     && RtlValidSid((PSID) pSidHistory->AttrVal.pAVal[i].pVal) )
                {
                    pNewSidHistory->AttrVal.pAVal[j++] =
                                                pSidHistory->AttrVal.pAVal[i];
                    pNewSidHistory->AttrVal.valCount++;
                }
            }
        }

        ((*ppOut)->attrCount)++;
    }

    return(pTHS->errCode);
}

ULONG
PrepareSecretData(
    DRS_HANDLE  hDrs,
    THSTATE     *pTHS,
    DSNAME      *pObj,
    ATTRTYP     attrTyp,
    ATTRVAL     *pAttrVal,
    DWORD       srcRid,
    DWORD       dstRid
    )
/*++

  Description:

    We used to think that all cross domain move had to do was perform RPC
    session encryption to insure that DBIsSecretData wasn't visible during
    transit.  It turns out that not all DBIsSecretData is encrypted the
    same.  Some items are additionally encrypted with the RID, and different
    encryption is used as well.  This routine undoes session and source
    RID encryption, and further adds destination RID encrption where needed,
    such that the data can be considered clear text and ready for DB layer
    encryption during the subsequent write to the database.

  Arguments:

    hDrs - DRS context handle.

    pTHS - Valid THSTATE.

    pObj - DSNAME of object being modified.

    attrTyp - ATTRTYP of value to be munged.

    pAttrVal - ATTRVAL which needs to be munged.  We may realloc it.

    srcRid - RID of source object.

    dstRid - RID of destination object.

  Return Values:

    pTHS->errCode

--*/
{
    DRS_CLIENT_CONTEXT  *pCtx = (DRS_CLIENT_CONTEXT * ) hDrs;
    ULONG               cb1 = 0, cb2 = 0;
    VOID                *pv1 = NULL, *pv2 = NULL;
    NTSTATUS            status = STATUS_SUCCESS;
    NT_OWF_PASSWORD     ntOwfPassword;
    LM_OWF_PASSWORD     lmOwfPassword;
    DWORD               i, cPwd = 1;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!pTHS->fDRA);
    Assert(DBIsSecretData(attrTyp));

    // Verify that IDL_DRSBind successfully set up session keys required
    // for encryption.

    if (    !pCtx->sessionKey.SessionKeyLength
         || !pCtx->sessionKey.SessionKey )
    {
        // See comments in IDL_DRSBind.  We assume the lack of keys is
        // not an error condition per se, but rather an invalid pre-condition
        // with respect to the authentication protocol, etc.

        return(SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                           ERROR_ENCRYPTION_FAILED));
    }

    // Set extensions in the thread state.
    Assert(!pTHS->pextRemote);
    pTHS->pextRemote = &pCtx->extRemote;

    // Set RPC session key in the thread state.
    Assert(    !pTHS->SessionKey.SessionKeyLength
            && !pTHS->SessionKey.SessionKey);
    pTHS->SessionKey = pCtx->sessionKey;

    // Turn on fDRA so as to get RPC session encryption.  Call PEKEncrypt
    // which decrypts the session level encryption and adds database layer
    // encryption.

    pTHS->fDRA = TRUE;
    __try
    {
        PEKEncrypt(pTHS, pAttrVal->pVal, pAttrVal->valLen, NULL, &cb1);
        pv1 = THAllocEx(pTHS, cb1);
        PEKEncrypt(pTHS, pAttrVal->pVal, pAttrVal->valLen, pv1, &cb1);
    }
    __finally
    {
        pTHS->fDRA = FALSE;
        pTHS->pextRemote = NULL;
        memset(&pTHS->SessionKey, 0, sizeof(pTHS->SessionKey));
    }

    // Data is now DB layer encrypted.  Get back to clear text for data which
    // is not source RID encrypted, or source RID encrypted for data which is.

    PEKDecrypt(pTHS, pv1, cb1, NULL, &cb2);
    pv2 = THAllocEx(pTHS, cb2);
    PEKDecrypt(pTHS, pv1, cb1, pv2, &cb2);
    THFreeEx(pTHS, pv1);

    // Now undo source RID encryption and apply destination RID encryption
    // depending on the ATTRTYP.

    Assert(sizeof(srcRid) == sizeof(CRYPT_INDEX));
    Assert(sizeof(dstRid) == sizeof(CRYPT_INDEX));

    switch ( attrTyp )
    {
    case ATT_NT_PWD_HISTORY:

        if ( 0 != (cb2 % sizeof(ENCRYPTED_NT_OWF_PASSWORD)) )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        cPwd = cb2 / sizeof(ENCRYPTED_NT_OWF_PASSWORD);

        // Intentional fall through.

    case ATT_UNICODE_PWD:

        if ( !srcRid || !dstRid )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        pAttrVal->valLen = cPwd * sizeof(ENCRYPTED_NT_OWF_PASSWORD);
        pAttrVal->pVal = THReAllocEx(pTHS, pAttrVal->pVal,
                                     cPwd * sizeof(ENCRYPTED_NT_OWF_PASSWORD));

        for ( i = 0; i < cPwd; i++ )
        {
            status = RtlDecryptNtOwfPwdWithIndex(
                                    &((PENCRYPTED_NT_OWF_PASSWORD) pv2)[i],
                                    (PCRYPT_INDEX) &srcRid,
                                    &ntOwfPassword);

            if ( NT_SUCCESS(status) )
            {
                status = RtlEncryptNtOwfPwdWithIndex(
                            &ntOwfPassword, (PCRYPT_INDEX) &dstRid,
                            &((PENCRYPTED_NT_OWF_PASSWORD) pAttrVal->pVal)[i]);
            }

            if ( !NT_SUCCESS(status) )
            {
                break;
            }
        }

        THFreeEx(pTHS, pv2);
        break;

    case ATT_LM_PWD_HISTORY:

        if ( 0 != (cb2 % sizeof(ENCRYPTED_LM_OWF_PASSWORD)) )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        cPwd = cb2 / sizeof(ENCRYPTED_LM_OWF_PASSWORD);

        // Intentional fall through.

    case ATT_DBCS_PWD:

        if ( !srcRid || !dstRid )
        {
            status = STATUS_ILL_FORMED_PASSWORD;
            break;
        }

        pAttrVal->valLen = cPwd * sizeof(ENCRYPTED_LM_OWF_PASSWORD);
        pAttrVal->pVal = THReAllocEx(pTHS, pAttrVal->pVal,
                                     cPwd * sizeof(ENCRYPTED_LM_OWF_PASSWORD));

        for ( i = 0; i < cPwd; i++ )
        {
            status = RtlDecryptLmOwfPwdWithIndex(
                                    &((PENCRYPTED_LM_OWF_PASSWORD) pv2)[i],
                                    (PCRYPT_INDEX) &srcRid,
                                    &lmOwfPassword);


            if ( NT_SUCCESS(status) )
            {
                status = RtlEncryptLmOwfPwdWithIndex(
                            &lmOwfPassword, (PCRYPT_INDEX) &dstRid,
                            &((PENCRYPTED_LM_OWF_PASSWORD) pAttrVal->pVal)[i]);
            }

            if ( !NT_SUCCESS(status) )
            {
                break;
            }
        }

        THFreeEx(pTHS, pv2);
        break;

    default:

        THFreeEx(pTHS, pAttrVal->pVal);
        pAttrVal->pVal = (UCHAR *) pv2;
        pAttrVal->valLen = cb2;
        break;
    }

    // Assuming no errors, data is now either in the clear or destination
    // RID encrypted and ready for write to the DB layer - eg: DirModifyEntry.

    if ( !NT_SUCCESS(status) )
    {
        SetAttError(pObj, attrTyp, PR_PROBLEM_CONSTRAINT_ATT_TYPE,
                    NULL, RtlNtStatusToDosError(status));
    }

    return(pTHS->errCode);
}

ULONG
WriteSecretData(
    DRS_HANDLE  hDrs,
    THSTATE     *pTHS,
    ULONG       srcRid,
    ADDARG      *pAddArg,
    ATTRBLOCK   *pAttrBlock
    )
/*++

  Description:

    The add we did for the inter domain move had all its DBIsSecretData attrs
    stripped because we didn't want to perform the add with fDRA set, which is
    required in order to handle sesison encryption correctly.  So we now
    find all DBIsSecretData attrs in the original ATTRBLOCK, and write them
    as fDRA.

  Arguments:

    hDrs - DRS context handle.

    pTHS - Active THSTATE.

    srcRid - RID of source object if present.

    pAddArg - Same ADDARG as was used for the original add.

    pAttrBlock - Original ATTRBLOCK sent by peer DC which contains the
        session-encrypted DBIsSecretData attributes.

  Return Values:

    pTHS->errCode

--*/
{
    ULONG               i, j, cBytes, ret;
    USHORT              cSecret;
    MODIFYARG           modifyArg;
    ATTRMODLIST         *pMod = NULL;
    ULONG               dstRid = 0;
    NT4SID              domainSid;
    NT4SID              fullSid;
    NT4SID              *pFullSid = &fullSid;
    DWORD               dwErr;
    ULONG               cbSid;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(pTHS->transactionlevel);
    Assert(!pTHS->fDRA);

    // First see if there is any secret data to handle at all.

    for ( i = 0, cSecret = 0; i < pAttrBlock->attrCount; i++ )
    {
        if ( DBIsSecretData(pAttrBlock->pAttr[i].attrTyp) )
        {
            cSecret++;
        }
    }

    if ( !cSecret )
    {
        return(0);
    }

    // Prepare MODIFYARG.  First position for subsequent CreateResObj
    // and read of SID if present.

    if (    DBFindDSName(pTHS->pDB, pAddArg->pObject)
         || (    (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_OBJECT_SID,
                                      DBGETATTVAL_fCONSTANT, sizeof(fullSid),
                                      &cbSid, (PUCHAR *) &pFullSid))
              && (DB_ERR_NO_VALUE != dwErr)) )
    {
        return(SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR));
    }

    if ( !dwErr )
    {
        SampSplitNT4SID(&fullSid, &domainSid, &dstRid);
    }

    memset(&modifyArg, 0, sizeof(modifyArg));
    memcpy(&modifyArg.CommArg, &pAddArg->CommArg, sizeof(COMMARG));
    modifyArg.pObject = pAddArg->pObject;
    modifyArg.pResObj = CreateResObj(pTHS->pDB, pAddArg->pObject);
    modifyArg.count = cSecret;
    pMod = &modifyArg.FirstMod;

    for ( i = 0; i < pAttrBlock->attrCount; i++ )
    {
        if ( DBIsSecretData(pAttrBlock->pAttr[i].attrTyp) )
        {
            pMod->pNextMod = NULL;
            pMod->choice = AT_CHOICE_REPLACE_ATT;

            // We must duplicate the attr as pAttrBlock is one of the
            // original IDL_DRSInterDomainMove arguments which was
            // unmarshalled by RPC, and thus we are not guaranteed that
            // it was allocated from the thread heap - which we need in
            // order for THReAlloc and other core routines to work properly.

            DupAttr(pTHS, &pAttrBlock->pAttr[i], &pMod->AttrInf);

            for ( j = 0; j < pMod->AttrInf.AttrVal.valCount; j++ )
            {
                if ( ret = PrepareSecretData(hDrs, pTHS,
                                             modifyArg.pResObj->pObj,
                                             pMod->AttrInf.attrTyp,
                                             &pMod->AttrInf.AttrVal.pAVal[j],
                                             srcRid, dstRid) )
                {
                    Assert(pTHS->errCode);
                    return(ret);
                }
            }

            if ( --cSecret )
            {
                cBytes = sizeof(ATTRMODLIST);
                pMod->pNextMod = (ATTRMODLIST *) THAllocEx(pTHS, cBytes);
                pMod = pMod->pNextMod;
            }
        }
    }

    // MODIFYARG is ready.  Write as fDSA to avoid security checks.  fDRA
    // should not be set else we'll get RPC session decryption again which
    // PrepareSecretData already took care of.

    Assert(!pTHS->fDRA);
    pTHS->fDSA = TRUE;

    __try
    {
        ret = LocalModify(pTHS, &modifyArg);
        Assert(ret ? ret == pTHS->errCode : TRUE);
    }
    __finally
    {
        pTHS->fDSA = FALSE;
    }

    return(ret);
}

VOID
LogRemoteAddStatus(
    IN DWORD Severity,
    IN DWORD Mid,
    IN PSTR  String1,
    IN PSTR  String2,
    IN DWORD ErrCode
    )
{
    // It is assume that whatever mid is passed in here must follow the pattern
    // of having either 2 or 4 parameters.
    LogEvent8(DS_EVENT_CAT_DIRECTORY_ACCESS,
             Severity,
             Mid,
             szInsertSz(String1),
             szInsertSz(String2),
             (ErrCode == 0) ? NULL : szInsertInt(ErrCode),
             (ErrCode == 0) ? NULL : szInsertWin32Msg(ErrCode),
              NULL, NULL, NULL, NULL
             );
}

ULONG
DRSInterDomainMove_InputValidate(
    DWORD               dwMsgInVersion,
    DRS_MSG_MOVEREQ     *pmsgIn,
    DWORD               *pdwMsgOutVersion,
    DRS_MSG_MOVEREPLY   *pmsgOut
    ) 
/*
    [notify]  ULONG IDL_DRSInterDomainMove( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwInVersion,
    [switch_is][ref][in]  DRS_MSG_MOVEREQ *pmsgIn,
    [ref][out]  DWORD *pdwOutVersion,
    [switch_is][ref][out]  DRS_MSG_MOVEREPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 2 != dwMsgInVersion ) {
   // it might be possible to get rid of the dwMsgInVersion checks
   // of some of the other calls - ie, RPC won't let anyone call
   // with version 3 if I've only defined versions 1 and 2, but in
   // this case, we have a version 1 defined - and it's not currently used. 
   // so we can't remove it.
   DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 );
    }

    ret = DRS_MSG_MOVEREQ_V2_InputValidate(&(pmsgIn->V2)); 

    return ret;
}

ULONG
IDL_DRSInterDomainMove(
    IN  DRS_HANDLE          hDrs,
    IN  DWORD               dwMsgInVersion,
    IN  DRS_MSG_MOVEREQ     *pmsgIn,
    IN  DWORD               *pdwMsgOutVersion,
    OUT DRS_MSG_MOVEREPLY   *pmsgOut
    )
{
    THSTATE                 *pTHS = pTHStls;
    ULONG                   draErr = DRAERR_Success;
    ULONG                   dwErr = 0;
    SCHEMA_PREFIX_TABLE     *pLocalPrefixTable;
    SCHEMA_PREFIX_MAP_HANDLE hPrefixMap = NULL;
    ATTRBLOCK               *pAttrBlock;
    ADDARG                  addArg;
    ADDRES                  *pAddRes = NULL;
    BOOL                    fSamClass = FALSE;
    BOOL                    fTransaction = FALSE;
    DSNAME                  dsName;
    DSNAME                  *pParentObj;
    ULONG                   len;
    ULONG                   ulCrossDomainMove;
    BOOL                    fContinue;
    SYNTAX_DISTNAME_BINARY  *pSrcProxy;
    SYNTAX_DISTNAME_BINARY  *pDstProxy;
    NAMING_CONTEXT          *pSrcNC;
    DWORD                   proxyType;
    DWORD                   proxyEpoch;
    ATTCACHE                *pAC;
    DWORD                   srcRid;
    BYTE                    SchemaInfo[SCHEMA_INFO_LENGTH] = {0};

    DRS_Prepare(&pTHS, hDrs, IDL_DRSINTERDOMAINMOVE);
    drsReferenceContext( hDrs );
    INC( pcThread );    // Perfmon hook

    __try {
   // We currently support just one output message version.
   // All IDL_* routines should return DRAERR_* values.
   // Ideally the routine returns DRAERR_Success and actual error
   // info is returned in pmsgOut->V2.win32Error.  This way the
   // caller can distinguish between connectivity/RPC errors and
   // processing errors.  But we still throw the usual DRA exceptions
   // for busy and such for compatability with other IDL_* calls.
   *pdwMsgOutVersion = 2;
        memset(pmsgOut, 0, sizeof(*pmsgOut));
   pmsgOut->V2.win32Error = DIRERR_GENERIC_ERROR;
   
   if (!(pTHS = InitTHSTATE(CALLERTYPE_INTERNAL)) )
       {
       // Failed to initialize a THSTATE.
       DRA_EXCEPT_NOLOG(DRAERR_OutOfMem, 0);
   }

   if ((draErr = DRSInterDomainMove_InputValidate(dwMsgInVersion, 
                         pmsgIn,
                         pdwMsgOutVersion,
                         pmsgOut
                         ))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   Assert(VALID_THSTATE(pTHS));
   //
   // PREFIX: PREFIX complains that there is the possibility
   // of pTHS->CurrSchemaPtr being NULL at this point.  However,
   // the only time that CurrSchemaPtr could be NULL is at the
   // system start up.  By the time that the RPC interfaces
   // of the DS are enabled and this function could be called,
   // CurrSchemaPtr will no longer be NULL.
   //
   Assert(NULL != pTHS->CurrSchemaPtr);

   Assert(2 == dwMsgInVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsInterDomainMove,
          szInsertDN(pmsgIn->V2.pSrcDSA),
          szInsertDN(pmsgIn->V2.pSrcObject->pName),
          szInsertDN(pmsgIn->V2.pDstName),
          szInsertDN(pmsgIn->V2.pExpectedTargetNC),
          NULL, NULL, NULL, NULL);

   // The security model for a remote add is that we want to impersonate
   // the caller who requested a cross domain move at the source DC - but
   // only while we're doing the actual add call.  For other operations
   // like phantomization, we want to be running as the replicator.  At
   // the same time, we need to insure that the remote add call indeed
   // came from a peer DC, else any client could send a remote add call to
   // this interface directly, thereby providing a back door means of
   // generating security principals with a SID history of their choice.

   if (!IsEnterpriseDC(pTHS, &dwErr))
       {
       DRA_EXCEPT_NOLOG(dwErr, 0);
   }

   // Check if the schema-infos match if both sides support it
   // We know Dsa is running at this point, so no need to check
   // for that

   if (IS_DRS_SCHEMA_INFO_SUPPORTED(&((DRS_CLIENT_CONTEXT * )hDrs)->extRemote)) {
       StripSchInfoFromPrefixTable(&(pmsgIn->V2.PrefixTable), SchemaInfo);
       if (!CompareSchemaInfo(pTHS, SchemaInfo, NULL)) {
      // doesn't match. Fail, but signal a schema cache update first

      if (!SCSignalSchemaUpdateImmediate()) {
          // couldn't even signal a schema update
          DRA_EXCEPT (DRAERR_InternalError, 0);
      }
      DRA_EXCEPT(DRAERR_SchemaMismatch, 0);
       }
   }

   pLocalPrefixTable = &((SCHEMAPTR *) pTHS->CurrSchemaPtr)->PrefixTable;
   hPrefixMap = PrefixMapOpenHandle(&pmsgIn->V2.PrefixTable,
                pLocalPrefixTable);

   // All errors after here should not throw DRA_EXCEPT and instead
   // set pTHStls->errCode.

   __try   // misc and transaction cleanup try/finally
       {
       // Make sure we're authoritive for the destination and that
       // we are consistent on which naming context the desired object
       // falls in.

       if ( !VerifyNCForMove(  pmsgIn->V2.pSrcObject->pName,
                pmsgIn->V2.pDstName,
                pmsgIn->V2.pExpectedTargetNC,
                &pSrcNC,
                &dwErr) )
      {
      DRA_EXCEPT_NOLOG(DRAERR_Generic, 0);
       }

       Assert(!dwErr);

       // Verify we can authenticate the credentials blob.
       // Do this before acquiring SAM lock as SAM doesn't
       // expect/want locks held during authentication.

       if ( dwErr = AuthenticateSecBufferDesc(pmsgIn->V2.pClientCreds) )
      {
      SetSecError(SE_PROBLEM_INVALID_CREDENTS, dwErr);
      _leave;
       }

       // Work around RPC allocation issues, map ATTRTYPs, and
       // morph/strip attrs as required by DirAddEntry.

       if ( dwErr = DupAndMassageInterDomainMoveArgs(
      pTHS,
      &pmsgIn->V2.pSrcObject->AttrBlock,
      hPrefixMap,
      &pAttrBlock,
      &fSamClass,
      &pSrcProxy,
      &srcRid) )
      {
      Assert(pTHS->errCode && (dwErr == pTHS->errCode));
      _leave;
       }

       //
       // SAM lock is no longer a require ment
       //
       Assert(!pTHS->fSamWriteLockHeld);


       // Start a multi-call transaction.
       SYNC_TRANS_WRITE();
       fTransaction = TRUE;

       // Phantomize old object if required.

       pTHS->fDRA = TRUE;
       _try
      {
      dwErr = PrepareForInterDomainMove(
          pTHS,
          pmsgIn->V2.pSrcObject->pName,
          pmsgIn->V2.pDstName,
          pSrcProxy);
       }
       _finally
      {
      pTHS->fDRA = FALSE;
       }

       if ( dwErr )
      {
      Assert(pTHS->errCode && (dwErr == pTHS->errCode));
      _leave; // misc and transaction cleanup try/finally
       }

       pTHS->fCrossDomainMove = TRUE;
       _try    // fCrossDomainMove try/finally
      {
      memset(&addArg, 0, sizeof(ADDARG));
      InitCommarg(&addArg.CommArg);

      // Clear destination name SID, prime GUID with that
      // of old object.
      pmsgIn->V2.pDstName->SidLen = 0;
      memset(&pmsgIn->V2.pDstName->Sid, 0, sizeof(NT4SID));
      memcpy(&pmsgIn->V2.pDstName->Guid,
             &pmsgIn->V2.pSrcObject->pName->Guid,
             sizeof(GUID));

      addArg.pObject = pmsgIn->V2.pDstName;
      addArg.AttrBlock = *pAttrBlock;
      addArg.pMetaDataVecRemote = NULL;

      // Assert this is 100% access controlled - no flags set.
      Assert(    !pTHS->fDSA
            && !pTHS->fDRA
            && !pTHS->fSAM
            && !pTHS->fLsa );

      pParentObj = (DSNAME *) THAllocEx(pTHS,
                    addArg.pObject->structLen);
      if ( TrimDSNameBy(addArg.pObject, 1, pParentObj) )
          {
          dwErr = SetNamError(NA_PROBLEM_BAD_NAME,
               addArg.pObject,
               DIRERR_BAD_NAME_SYNTAX);
          _leave; // fCrossDomainMove try/finally
      }

      if ( dwErr = DBFindDSName(pTHS->pDB, pParentObj) )
          {
          dwErr = SetNamError(NA_PROBLEM_BAD_NAME,
               pParentObj,
               ERROR_DS_NO_PARENT_OBJECT);
          _leave; // fCrossDomainMove try/finally
      }

      addArg.pResParent = CreateResObj(pTHS->pDB, pParentObj);

      // Subsequent calls will NOT validate ex-machine references
      // against the GC because GC verification is bypassed when
      // pTHS->fCrossDomainMove is set.  I.e. We are trusting our
      // peer DC to have given us DSNAME-valued attributes which
      // refer to real things in the enterprise.  See also
      // VerifyDsnameAtts.

      if (    !(dwErr = SampAddLoopbackCheck(&addArg, &fContinue))
         && fContinue )
          {
          dwErr = LocalAdd(pTHS, &addArg, FALSE);
      }

      if ( !dwErr )
          {
          // Prior calls added everything except DBIsSecretData
          // attributes which were filtered out earlier.  Now
          // write those attributes, if present, as fDRA so
          // that session encrypted data is decrypted correctly.

          dwErr = WriteSecretData(
         hDrs, pTHS, srcRid, &addArg,
         &pmsgIn->V2.pSrcObject->AttrBlock);
      }

      if ( dwErr )
          {
          Assert(dwErr == pTHS->errCode);
          _leave; // fCrossDomainMove try/finally
      }

      // Now read the added object so as to get the parent
      // name with the proper casing and new SID so that phantom
      // at source is case and SID correct.

      Assert(pTHS->transactionlevel);
      memset(&dsName, 0, sizeof(DSNAME));
      dsName.structLen = sizeof(DSNAME);
      memcpy( &dsName.Guid,
         &pmsgIn->V2.pSrcObject->pName->Guid,
         sizeof(GUID));

      if (    (dwErr = DBFindDSName(pTHS->pDB, &dsName))
         || (dwErr = DBGetAttVal(pTHS->pDB,
                  1,                  // get 1 value
                  ATT_OBJ_DIST_NAME,
                  0,                  // allocate return data
                  0,                  // supplied buffer size
                  &len,               // output data size
                  (UCHAR **) &pmsgOut->V2.pAddedName)) )
          {
          SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
          _leave; // misc and transaction cleanup try/finally
      }

      // since we are here, we should have something added
      Assert (pmsgOut->V2.pAddedName);

      // Every cross-domain-moved object is given an
      // ATT_PROXIED_OBJECT_NAME attribute which 1) points back
      // at the domain it was last moved from, and 2) advances the
      // epoch number.  If the attribute is missing from the inbound
      // object, then it has never been moved yet and needs an
      // initial value with (1 == epoch).

      Assert(pSrcNC);
      Assert(pSrcProxy
             ? PROXY_TYPE_MOVED_OBJECT == GetProxyType(pSrcProxy)
             : TRUE);
      proxyType = PROXY_TYPE_MOVED_OBJECT;
      proxyEpoch = (pSrcProxy
               ? GetProxyEpoch(pSrcProxy) + 1
               : 1);
      MakeProxy(pTHS, pSrcNC, proxyType,
           proxyEpoch, &len, &pDstProxy);
      pAC = SCGetAttById(pTHS, ATT_PROXIED_OBJECT_NAME);

      // We should still be positioned on the object from prior read
      // and it should not have an ATT_PROXIED_OBJECT_NAME since we
      // stripped that from the incoming data in DupAndMassage...

      if (    (dwErr = DBAddAttVal_AC(pTHS->pDB, pAC,
                  len, pDstProxy))
         || (dwErr = DBRepl(pTHS->pDB, FALSE, 0, NULL,
                  META_STANDARD_PROCESSING)) )
          {
          SetSvcError(SV_PROBLEM_BUSY, DIRERR_DATABASE_ERROR);
          _leave; // misc and transaction cleanup try/finally
      }
       }
       _finally
      {
      pTHS->fCrossDomainMove = FALSE;
       }

       Assert(dwErr == pTHS->errCode);
   }
   __finally   // misc and transaction cleanup try/finally
       {
       if ( hPrefixMap )
      PrefixMapCloseHandle(&hPrefixMap);

       // Grab error code from above operations before failure
       // to commit (possibly) overwrites pTHS->errCode and
       // pTHS->pErrInfo.

       pmsgOut->V2.win32Error = Win32ErrorFromPTHS(pTHS);

       if ( fTransaction )
      {
      CLEAN_BEFORE_RETURN(pTHS->errCode);
       }
       else if ( pTHS->fSamWriteLockHeld )
      {
      Assert(FALSE && "We should not fall into this because we don't acquire SAM lock any more");
      SampReleaseWriteLock(FALSE);
      pTHS->fSamWriteLockHeld = FALSE;
       }

       // Log what happened - security errors are logged separately.

       if ( pTHS->errCode != securityError )
      {
      UCHAR *pszSrcDN, *pszDstDN;

      pszSrcDN = MakeDNPrintable(pmsgIn->V2.pSrcObject->pName);
      pszDstDN = MakeDNPrintable(pmsgIn->V2.pDstName);

      if ( pTHS->errCode || AbnormalTermination() )
          {
          LogRemoteAddStatus(
         DS_EVENT_SEV_EXTENSIVE,
         DIRLOG_REMOTE_ADD_FAILED,
         pszSrcDN,
         pszDstDN,
         pmsgOut->V2.win32Error);
      }
      else
          {
          LogRemoteAddStatus(
         DS_EVENT_SEV_INTERNAL,
         DIRLOG_REMOTE_ADD_SUCCEEDED,
         pszSrcDN,
         pszDstDN,
         0);
      }
       }
   }
    }
    __except(GetDraException(GetExceptionInformation(), &draErr))
    {
   ;
    }

    DEC(pcThread);      // Perfmon hook
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_INTERDOMAIN_MOVE_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsInterDomainMove,
          szInsertUL(draErr),
          szInsertWin32Msg(draErr),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    } 

    if ( draErr )
   {
   LogEvent(DS_EVENT_CAT_REPLICATION,
       DS_EVENT_SEV_BASIC,
       DIRLOG_DRA_CALL_EXIT_BAD,
       szInsertUL(dwErr),
       szInsertWin32Msg(dwErr),
       NULL);
    }
    
    Assert ( draErr != 0 || 
            (draErr == 0) && (pmsgOut->V2.win32Error != 0) ||
            ((draErr == 0) && (pmsgOut->V2.pAddedName != NULL) && (pmsgOut->V2.win32Error == 0)));

    return(draErr);
}


ULONG AddNewNtdsDsa(IN  THSTATE *pTHS,
                    IN  DRS_HANDLE hDrs,
                    IN  DWORD dwInVersion,
                    IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                    IN  ENTINF *pEntInf,
                    IN  DSNAME *pDomain,
                    IN  DSNAME *pServerReference,
                    OUT GUID* objGuid,
                    OUT NT4SID* objSid  )
/*++

  Routine Description:

    This routine creates an ntdsa object

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for the ntdsa object
    pDomain     - DN of the domain this ntdsa object will host
    ulSysFlags  - flags that the caller wants placed on the CR
    objGuid     - the guid of the object
    objSid      - the sid of the object

  Return Values:

    embedded in output message

--*/
{

    COMMARG CommArg;
    ATTRVAL AVal;
    COMMRES CommRes;
    CROSS_REF *pCR = NULL;
    ULONG err;
    ADDARG AddArg;
    DSNAME *pParent = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG  ulLen;
    ULONG  AccessGranted = 0;
    ULONG  sysflags = 0;
    CLASSCACHE *pCC;
    ULONG  cbSD;
    BOOL   fAccessAllowed = FALSE;
    WCHAR  *pszServerGuid = NULL;
    ATTR   *AttrArray;
    ATTRBLOCK AttrBlock;
    ULONG i, j;
    LONG lDsaVersion;

    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pDomain, &CommArg);
    CommArg.Svccntl.dontUseCopy = TRUE;

    __try {

        //
        // Make sure the cross ref exists
        //
        if (NULL == pCR) {
            // Couldnt find the cross ref normally.  Look in the transactional
            // view.
            OBJCACHE_DATA *pTemp = pTHS->JetCache.dataPtr->objCachingInfo.pData;

            while(pTemp) {
                switch(pTemp->type) {
                case OBJCACHE_ADD:
                    if(NameMatched(pTemp->pCRL->CR.pNC, pDomain)) {
                        Assert(!pCR);
                        pCR = &pTemp->pCRL->CR;
                    }
                    pTemp = pTemp->pNext;
                    break;
                case OBJCACHE_DEL:
                    if(pCR && NameMatched( pTemp->pDN, pCR->pObj)) {
                        pCR = NULL;
                    }
                    pTemp = pTemp->pNext;
                    break;
                default:
                    LogUnhandledError(pTemp->type);
                    pCR = NULL;
                    pTemp = NULL;
                }
            }
        }
        if (NULL == pCR) {
            // Still coulndt find the correct cross ref.
            err = ERROR_DS_NO_CROSSREF_FOR_NC;
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_CROSSREF_FOR_NC,
                          err);
            __leave;
        }

        //
        // Make sure it is a NTDS cross ref
        //
        err = DBFindDSName(pTHS->pDB, pCR->pObj);
        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_OBJ_NOT_FOUND,
                          err);
            __leave;
        }
        err = DBGetSingleValue(pTHS->pDB,
                               ATT_SYSTEM_FLAGS,
                               &sysflags,
                               sizeof(sysflags),
                               NULL);
        if ( err
          || !(FLAG_CR_NTDS_DOMAIN & sysflags) ) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_CROSSREF_FOR_NC,
                          err);
            __leave;
        }

        //
        // Ok, perform the security check
        //

        // Read the domain object
        err = DBFindDSName(pTHS->pDB, pDomain);
        if ( 0 == err )
        {
            // The domain object exists
            DBFillGuidAndSid( pTHS->pDB, pDomain );

            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_NT_SECURITY_DESCRIPTOR,
                              0,
                              0,
                              &cbSD,
                              (UCHAR **) &pSD);

            // Get it's object class while we're at it.
            if ( 0 == err )
            {
                GetObjSchema(pTHS->pDB, &pCC);

                // Domain exists
                fAccessAllowed = IsControlAccessGranted( pSD,
                                                         pDomain,
                                                         pCC,
                                                         RIGHT_DS_REPL_MANAGE_REPLICAS,
                                                         FALSE );
            }
        }

        // N.B err means error access either the domain object or reading
        // the security descriptor
        if ( err )
        {
            // Check to see if we added the domain in this AddEntry call

            ENTINFLIST *pCur = &pmsgIn->V2.EntInfList;
            while ( pCur ) {

                ATTRBLOCK *pAttrBlock;
                ATTR      *pAttr;
                ULONG      class = CLASS_TOP;
                DSNAME    *pNCName = NULL;

                if ( &(pCur->Entinf) == pEntInf ) {
                    // we're reached the current ntdsa object and not found the
                    // cross-ref
                    Assert( FALSE == fAccessAllowed );
                    break;
                }

                // Dissect the object
                pAttrBlock = &pCur->Entinf.AttrBlock;
                for (i=0; i< pAttrBlock->attrCount; i++) {
                    pAttr = &(pAttrBlock->pAttr[i]);
                    switch (pAttr->attrTyp) {
                      case ATT_OBJECT_CLASS:
                        class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
                      break;

                      case ATT_NC_NAME:
                        pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
                        break;

                      default:
                        ;
                    }
                }

                // Is this the object we are looking for?
                if (   (CLASS_CROSS_REF == class)
                   &&  NameMatched( pNCName, pDomain ) ) {

                    fAccessAllowed = TRUE;
                    break;
                }

                // Try the next object
                pCur = pCur->pNextEntInf;
            }
        }

        if ( !fAccessAllowed ) {

            err = ERROR_ACCESS_DENIED;
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_ACCESS_DENIED,
                          err);
           _leave;
        }


        //check if the DSA binary version is too low
        //this is only for win2k candidate DC
        //Whistler and later version should have already performed a verification
        //locally, and is never supposed to submit such a request
        lDsaVersion = 0;

        for ( i = 0; i < pEntInf->AttrBlock.attrCount; i++) {

            if ( pEntInf->AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_BEHAVIOR_VERSION ) {

                lDsaVersion = (LONG) *(pEntInf->AttrBlock.pAttr[i].AttrVal.pAVal->pVal);

                break;

            }
        }
        if (  lDsaVersion < gAnchor.ForestBehaviorVersion ) {

            DPRINT(2, "AddNewNtdsDsa: too low version number(forest).\n");

            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_TOO_LOW_VERSION,
                     szInsertInt(lDsaVersion),
                     szInsertInt(gAnchor.ForestBehaviorVersion),
                     NULL);
            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_INCOMPATIBLE_VERSION );
            __leave;

        }
        if (     NameMatched(pDomain,gAnchor.pDomainDN)
             &&  lDsaVersion < gAnchor.DomainBehaviorVersion ) {

            DPRINT(2, "AddNewNtdsDsa: too low version number(domain).\n");
            LogEvent(DS_EVENT_CAT_REPLICATION,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_TOO_LOW_VERSION,
                     szInsertInt(lDsaVersion),
                     szInsertInt(gAnchor.DomainBehaviorVersion),
                     NULL);

            SetSvcError( SV_PROBLEM_WILL_NOT_PERFORM,
                         ERROR_DS_INCOMPATIBLE_VERSION );
            __leave;

        }


        //
        // We've made it this far, it is time to create the object
        //
        pTHS->fDSA = TRUE;

        //
        // For this release, we aren't writing the server reference
        // on the ntds-settings object, so remove it from
        // the AttrBlock.  In case we decide to set it at some point
        // only remove the first one we see.
        //
        AttrArray = THAllocEx(pTHS, sizeof(ATTR) * pEntInf->AttrBlock.attrCount );
        j = 0;
        for ( i = 0; i < pEntInf->AttrBlock.attrCount; i++) {

            BOOL FoundIt = FALSE;

            if (   FoundIt
                || pEntInf->AttrBlock.pAttr[i].attrTyp != ATT_SERVER_REFERENCE ) {

                AttrArray[j] = pEntInf->AttrBlock.pAttr[i];
                j++;
            } else {
                FoundIt = TRUE;
            }
        }
        memset( &AttrBlock, 0, sizeof(AttrBlock) );
        AttrBlock.attrCount = j;
        AttrBlock.pAttr = AttrArray;


        // Prepare the add arg
        memset(&AddArg, 0, sizeof(AddArg));
        AddArg.pObject = pEntInf->pName;
        AddArg.AttrBlock = AttrBlock;
        AddArg.CommArg = CommArg;
        InitCommarg(&CommArg);

        pParent = THAllocEx(pTHS, AddArg.pObject->structLen);
        TrimDSNameBy(AddArg.pObject, 1, pParent);

        // Find the parent
        err = DoNameRes(pTHS,
                        0,
                        pParent,
                        &AddArg.CommArg,
                        &CommRes,
                        &AddArg.pResParent);

        if (err) {
            SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                          ERROR_DS_NO_PARENT_OBJECT,
                          err);
            __leave;
        }

        //
        // Make the object replicate urgently
        //
        CommArg.Svccntl.fUrgentReplication = TRUE;

        // Do the add!
        err = LocalAdd(pTHS, &AddArg, FALSE);
        if (err) {
            __leave;
        }

        //
        // Return the guid and sid of the object created
        //
        *objGuid = AddArg.pObject->Guid;
        *objSid  = AddArg.pObject->Sid;

        // Give the server reference, write an SPN so other servers can
        // replicate with this new server
        if ( pServerReference ) {

            MODIFYARG ModArg;
            MODIFYRES ModRes;
            ATTRVAL  AttrVal;
            LPWSTR   DnsDomainName;

            Assert( pCR );
            Assert( pCR->DnsName );
            if ( !pCR->DnsName) {

                //
                // No dns name?
                //
                err = ERROR_DS_INTERNAL_FAILURE;
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
               _leave;

            }

            //
            // First construct the SPN and put it into a ATTRVAL
            //
            memset( &AttrVal, 0, sizeof(AttrVal));
            err = UuidToStringW( objGuid, &pszServerGuid );
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;
            }

            //
            // Magic steps to make replication SPN
            // N.B.  This should be the same SPN as written in
            // WriteServerInfo().
            //
            if(err = WrappedMakeSpnW(pTHS,
                                     DRS_IDL_UUID_W, // RPC idl guid
                                     pCR->DnsName,   // dns name of the domain
                                     pszServerGuid,  // guid of the server
                                     0,
                                     NULL,
                                     &AttrVal.valLen,
                                     (WCHAR **)&AttrVal.pVal)) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;

            }

            memset(&ModArg, 0, sizeof(ModArg));
            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pServerReference;
            ModArg.count = 1;

            ModArg.FirstMod.choice = AT_CHOICE_ADD_VALUES;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AttrVal;

            ModArg.CommArg = CommArg;
            InitCommarg(&CommArg);
            memset( &CommRes, 0, sizeof(CommRes) );
            if (0 == DoNameRes(pTHS,
                               0,
                               ModArg.pObject,
                               &ModArg.CommArg,
                               &CommRes,
                               &ModArg.pResObj) ){

                // Do the modify!
                err = LocalModify(pTHS, &ModArg);

            } else {

                //
                // Couldn't find the server object?  Indicate this.
                //
                err = ERROR_NO_TRUST_SAM_ACCOUNT;
                SetSvcError(SV_PROBLEM_DIR_ERROR, err);

            }

            if (err) {
                __leave;
            }
        }

    } __finally {

        pTHS->fDSA = FALSE;

        // N.B. the calling routine handles the transactioning

        THFreeEx(pTHS, pParent);

        if (pszServerGuid) {
            RpcStringFreeW( &pszServerGuid );
        }

    }


    return pTHS->errCode;

}

ULONG AddNewDomainCrossRef(IN  THSTATE *pTHS,
                           IN  DRS_HANDLE hDrs,
                           IN  DWORD dwInVersion,
                           IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                           IN  ENTINF *pEntInf,
                           IN  DSNAME *pNCName,
                           IN  ULONG ulSysFlags,
                           IN  ADDCROSSREFINFO *pCRInfo,
                           OUT GUID* objGuid,
                           OUT NT4SID* objSid  )
/*++

  Routine Description:

    This routine creates a cross ref object for a new child domain.  The CR
    may already be in place in a disabled state, in which case we will
    enable it.  See childdom.doc for a full description.

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for the cross ref
    pNCName     - DN of the new child domain
    ulSysFlags  - flags that the caller wants placed on the CR
    pdwOutVersion - version of output message
    pmsgOut     - output message


  Return Values:

    embedded in output message

--*/
{
    COMMARG CommArg;
    MODIFYARG ModArg;
    ATTRVAL AVal;
    COMMRES CommRes;
    CROSS_REF *pCR;
    ULONG err;
    ATTR *   pAttr = NULL;
    ENTINF *pEI = NULL;

    // We're trying to add a cross-ref, but we may already have a CR
    // for the NC that we're adding a CR for.  Check with the in-memory
    // knowledge to see what we know.
    InitCommarg(&CommArg);
    CommArg.Svccntl.dontUseCopy = FALSE;
    pCR = FindExactCrossRef(pNCName, &CommArg);
    CommArg.Svccntl.dontUseCopy = TRUE;

    // As of about 10/25/98, clients should not be giving either GUID or
    // SID for the NC-Name value.  Error out accordingly.
    if ( !fNullUuid(&pNCName->Guid) || pNCName->SidLen ) {
        return(SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM, ERROR_DS_PARAM_ERROR));
    }

    // Add NC-Name value to GC verify cache else VerifyDSNameAtts will
    // claim this DN doesn't correspond to an existing object.
    pEI = THAllocEx(pTHS, sizeof(ENTINF));
    pEI->pName = pNCName;
    GCVerifyCacheAdd(NULL,pEI);

    if (NULL == pCR ||
        !(ulSysFlags & FLAG_CR_NTDS_DOMAIN) ) {

        // We don't already have a CR for this hunk-o-namespace, (or if
        // the CR we're trying to add is already a NDNC CR) so we can 
        // just try to create one, as requested.  We don't even have to
        // check for permissions, FSMO-hood, or anything else, as those 
        // checks are done in the add.  We do have to manually perform 
        // name resolution so that we can call LocalAdd and LocalModify,
        // so that we can wrap them up in one transaction. Doing so 
        // seemed simpler than trying to recover from errors after we 
        // had committed part of the update.  If this is a pre-existing
        // NDNC CR we will try to add it anyway, but this will generate
        // an error, but this is what the requester expects.  If it finds
        // that we've already got a CR, it just schedules a sync in
        // GetCrossRefForNDNC().

        ADDARG AddArg;
        DSNAME *pParent = NULL;

        __try {

            // First, add the object, using the user's credentials

            memset(&AddArg, 0, sizeof(AddArg));
            AddArg.pObject = pEntInf->pName;
            AddArg.AttrBlock = pEntInf->AttrBlock;
            AddArg.pCRInfo = pCRInfo;
            Assert(AddArg.pCRInfo);

            // BUGBUG This horrible hack brought to you by CheckAddSecurity(),
            // which assumes that the AttrBlock.pAttr array is THAlloc'd and  so
            // it can THReAlloc's the pAttr array to fit the security descriptor.
            // Should one fix this here, or fix CheckAddSecurity().
            pAttr = AddArg.AttrBlock.pAttr;
            AddArg.AttrBlock.pAttr = THAllocEx(pTHS,
                                               (AddArg.AttrBlock.attrCount *
                                                sizeof(ATTR)));
            memcpy(AddArg.AttrBlock.pAttr, pAttr, (AddArg.AttrBlock.attrCount *
                                                   sizeof(ATTR)));


            AddArg.CommArg = CommArg;

            pParent = THAllocEx(pTHS, AddArg.pObject->structLen);
            TrimDSNameBy(AddArg.pObject, 1, pParent);

            err = DoNameRes(pTHS,
                            0,
                            pParent,
                            &AddArg.CommArg,
                            &CommRes,
                            &AddArg.pResParent);
            if (err) {
                __leave;
            }

            //
            // Make the object replicate urgently
            //
            CommArg.Svccntl.fUrgentReplication = TRUE;

            err = LocalAdd(pTHS, &AddArg, FALSE);
            if (err) {
                __leave;
            }


            // Ok, now become the DSA and adjust the system flags
            // on the object we just created.

            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pEntInf->pName;
            ModArg.CommArg = CommArg;
            ModArg.count = 1;
            ModArg.FirstMod.pNextMod = NULL;
            ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
            AVal.valLen = sizeof(ulSysFlags);
            AVal.pVal = (PUCHAR)&ulSysFlags;
            Assert(ulSysFlags & FLAG_CR_NTDS_NC);
            if (!(ulSysFlags & FLAG_CR_NTDS_NC)) {
                // I am going to make the assertion that it is invalid to try
                // to create a non NT DS cross-ref object through the remote
                // add entry API.
                SetSvcError(SV_PROBLEM_WILL_NOT_PERFORM,
                            DIRERR_MISSING_EXPECTED_ATT);
                err = pTHS->errCode;
                Assert(err);
                __leave;
            }

            // We used to set the systemFlags here, but the system flags on the
            // cross-ref should be set by the client, so that we can change what
            // get's set.

            err = DoNameRes(pTHS,
                            0,
                            ModArg.pObject,
                            &ModArg.CommArg,
                            &CommRes,
                            &ModArg.pResObj);
            if (err) {
                __leave;
            }

            pTHS->fDSA = TRUE;
            err = LocalModify(pTHS,
                              &ModArg);
        } __finally {

            pTHS->fDSA = FALSE;

            // N.B. The calling function handles the transaction
            THFreeEx(pTHS, pParent);
        }

    } else {
#define MAXCRMODS 5
        // This is the case where a disabled version of the CR already
        // exists in the partitions container.  What we have to do now
        // is find the CR object, read the dns-root from it, and compare
        // the IP address it describes with the IP address of our caller.
        // If they match, we touch up the CR with whatever we need to.
        WCHAR *pwDNS = NULL;
        ULONG cb;
        struct hostent *pHostAllowed;
        RPC_BINDING_HANDLE hServerBinding;
        WCHAR *pStringBinding, *pAddressActual;
        int i;
        unsigned u;
        BOOLEAN fPermitted;
        ATTRMODLIST OtherMod[MAXCRMODS];
        BOOLEAN fGotDNSAddr;
        char b;
        ULONG enabled = FALSE;
        WCHAR pszIpAddress[IPADDRSTR_SIZE];

        // read dns-root from object

        // If we're adding a domain, then we need to patch up
        // the domain promotion to Enable the CR, and check
        // that the machine requesting this to instantiate this
        // Domain NC is the machine in the dNSRoot of this CR.

        __try {
            err = DBFindDSName(pTHS->pDB, pCR->pObj);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_OBJ_NOT_FOUND,
                              err);
                __leave;
            }
            err = DBGetSingleValue(pTHS->pDB,
                                   ATT_ENABLED,
                                   &enabled,
                                   sizeof(enabled),
                                   NULL);
            if (err || enabled) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DUP_DOMAINNAME,
                              err);
                __leave;
            }

            err = DBGetAttVal(pTHS->pDB,
                              1,
                              ATT_DNS_ROOT,
                              0,
                              0,
                              &cb,
                              (UCHAR **)&pwDNS);
            if (err) {
                SetSvcErrorEx(SV_PROBLEM_DIR_ERROR,
                              ERROR_DS_MISSING_REQUIRED_ATT,
                              err);
                __leave;
            }

            pwDNS = THReAllocEx(pTHS, pwDNS, cb+sizeof(WCHAR));
            Assert( 0 == (cb % sizeof(WCHAR)) );
            pwDNS[(cb/sizeof(WCHAR))] = L'\0';

            // BUGBUG this doesn't get more than 1 IP Address, so a multi-home 
            // target DC could fail ... I think. - BrettSh
            err = GetIpAddrByDnsNameW(pwDNS, pszIpAddress);
            if (err) {
                SetSecErrorEx(SE_PROBLEM_INAPPROPRIATE_AUTH,
                              ERROR_DS_DNS_LOOKUP_FAILURE,
                              err);
                __leave;
            }
            DPRINT2(1, "CR promotion allowed by %ws (%ws) only\n",
                    pwDNS, pszIpAddress);

            // compute actual ip address of caller via RpcXxx
            hServerBinding = 0;
            pStringBinding = NULL;
            if (RPC_S_OK != (err=RpcBindingServerFromClient(NULL,
                                                            &hServerBinding))) {
                Assert(!"RpcBindingServerFromClient Error!\n");
                SetSecErrorEx(SE_PROBLEM_INAPPROPRIATE_AUTH,
                              ERROR_DS_INTERNAL_FAILURE,
                              err);
                __leave;
            }
            __try { 
                if ((RPC_S_OK != (err =
                                  RpcBindingToStringBindingW(hServerBinding,
                                                             &pStringBinding))) || 
                    (RPC_S_OK != (err =
                                  RpcStringBindingParseW(pStringBinding,
                                                        NULL,         // ObjUuid
                                                        NULL,         // ProtSeq
                                                        &pAddressActual, // NetworkAddr
                                                        NULL,         // Endpoint
                                                        NULL)))) {
                    DPRINT3(0,
                            "Error %u from Rpc, hServer = 0x%x, pString = 0x%x\n",
                            err,
                            hServerBinding,
                            pStringBinding);
                    DebugBreak();
                    if (pStringBinding) {
                        RpcStringFreeW(&pStringBinding);
                        pStringBinding = NULL;
                    }
                    SetSecErrorEx(SE_PROBLEM_INAPPROPRIATE_AUTH,
                                  ERROR_DS_INTERNAL_FAILURE,
                                  err);
                    __leave;
                }
            }
            __finally {
                RpcBindingFree(&hServerBinding);
            }
            DPRINT1(1, "Caller is from address %ws\n", pAddressActual);

            // if not identical, reject and go to done
            fPermitted = TRUE;
            if (0 != _wcsicmp(pAddressActual, pszIpAddress)) {
                // Not the same address!
                fPermitted = FALSE;
            }

            if (pStringBinding) {
                RpcStringFreeW(&pStringBinding);
            }
            if (pAddressActual) {
                RpcStringFreeW(&pAddressActual);
            }

            if (!fPermitted) {
                SetSecError(SE_PROBLEM_INSUFF_ACCESS_RIGHTS,
                            ERROR_DS_INSUFF_ACCESS_RIGHTS);
                DPRINT(0,"Refusing child domain creation\n");
                __leave;
            }

            DPRINT(0,"Allowing child domain creation\n");

            // modify CR object: set sys flags, clear Enabled.
            if (DBGetSingleValue(pTHS->pDB,
                                 ATT_SYSTEM_FLAGS,
                                 &ulSysFlags,
                                 sizeof(ulSysFlags),
                                 NULL)) {
                ulSysFlags = 0;
            }

            memset(&ModArg, 0, sizeof(ModArg));
            ModArg.pObject = pCR->pObj;
            ModArg.CommArg = CommArg;

            ModArg.FirstMod.pNextMod = &OtherMod[0];
            ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;
            ModArg.FirstMod.AttrInf.attrTyp = ATT_SYSTEM_FLAGS;
            ModArg.FirstMod.AttrInf.AttrVal.valCount = 1;
            ModArg.FirstMod.AttrInf.AttrVal.pAVal = &AVal;
            AVal.valLen = sizeof(ulSysFlags);
            AVal.pVal = (PUCHAR)&ulSysFlags;
            ulSysFlags |= (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN);

            memset(OtherMod, 0, sizeof(OtherMod));
            OtherMod[0].choice = AT_CHOICE_REMOVE_ATT;
            OtherMod[0].AttrInf.attrTyp = ATT_ENABLED;
            OtherMod[0].AttrInf.AttrVal.valCount = 0;

            i = 1;
            fGotDNSAddr = FALSE;

            for (u=0; u<pEntInf->AttrBlock.attrCount; u++) {
                ATTR *pTempAttr = &(pEntInf->AttrBlock.pAttr[u]);
                switch (pTempAttr->attrTyp) {
                case ATT_DNS_ROOT:
                    fGotDNSAddr = TRUE;
                case ATT_TRUST_PARENT:
                case ATT_ROOT_TRUST:
                    Assert(i < MAXCRMODS);
                    OtherMod[i-1].pNextMod = &OtherMod[i];
                    OtherMod[i].choice = AT_CHOICE_REPLACE_ATT;
                    OtherMod[i].AttrInf.attrTyp = pTempAttr->attrTyp;
                    OtherMod[i].AttrInf.AttrVal = pTempAttr->AttrVal;
                    ++i;
                    break;

                default:
                    ;
                }
            }

            if (!fGotDNSAddr) {
                SetAttError(ModArg.pObject,
                            ATT_DNS_ROOT,
                            PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                            NULL,
                            DIRERR_MISSING_REQUIRED_ATT);
                __leave;
            }

            ModArg.count = i+1;


            err = DoNameRes(pTHS,
                            0,
                            ModArg.pObject,
                            &ModArg.CommArg,
                            &CommRes,
                            &ModArg.pResObj);
            if (err) {
                __leave;
            }

            pTHS->fDSA = TRUE;
            LocalModify(pTHS,
                        &ModArg);

            DPRINT1(1,
                    "Modify completed with error 0x%x\n",
                    pTHS->errCode);

        } __finally {
            pTHS->fDSA = FALSE;

            // N.B. The calling function handles the transaction
        }
#undef MAXCRMODS
    }

    // This is an NDNC, with a precreated cross-ref, we want to
    // return the GUID _AND_ an error.  The error is CR already 
    // exists.
    if (pCR &&
        !(ulSysFlags & FLAG_CR_NTDS_DOMAIN) &&
        pTHS->errCode == serviceError &&
        pTHS->pErrInfo->SvcErr.extendedErr == ERROR_DS_CROSS_REF_EXISTS) {

        *objGuid = pCR->pObj->Guid;
    }

    if (0 == pTHS->errCode) {
        *objGuid = ModArg.pResObj->pObj->Guid;
        *objSid = ModArg.pResObj->pObj->Sid;
    }

    return pTHS->errCode;
}


ULONG
ProcessSingleAddEntry(
    IN  THSTATE             *pTHS,
    IN  DRS_HANDLE           hDrs,
    IN  DWORD                dwInVersion,
    IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
    IN  ENTINF              *pEntInf,
    IN  ADDCROSSREFINFO     *pCRInfo,
    OUT GUID                *objGuid,
    OUT NT4SID              *objSid
    )
/*++

  Routine Description:

    This routine adds a single object (pEntInf) that came from the input args
    (pmsgIn).

  Parameters:

    pTHS        - THSTATE
    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pEntInf     - pointer to the EntInf structure for object to add
    objGuid:    - guid of the object created
    objSid:     - sid of the object created

  Return Values:

    0 = success

--*/
{
    ULONG err = 0;

    ULONG i, j;
    ULONG fNewHasMasterNCsPresent = FALSE;

    ULONG ulSysFlags = 0;
    ATTRBLOCK *pAttrBlock;
    ATTR      *pAttr;
    ATTRTYP class = CLASS_TOP;

    DSNAME *pNCName = NULL;
    DSNAME *pDomain = NULL;
    DSNAME *pSchema = NULL;
    DSNAME *pConfig = NULL;
    DSNAME *pServerReference = NULL;


    // Parameter check
    Assert( pEntInf );
    Assert( objGuid );
    Assert( objSid );

    pAttrBlock = &pEntInf->AttrBlock;

    // Look through the arguments to the add to see what it is we're
    // being asked to add.  Also note that we strip out the system flags
    // attribute, so that we can deal with it separately.
    for (i=0; i< pAttrBlock->attrCount; i++) {
        pAttr = &(pAttrBlock->pAttr[i]);
        switch (pAttr->attrTyp) {
        case ATT_SYSTEM_FLAGS:
            // We now throw this in the LocalAdd(), AND the LocalModify(),
            // the reason, being that we create this thing without an
            // Enabled attr equal to FALSE.  We need a way in VerifyNcName()
            // to differentiate between an external and internal crossRef.
            // In the LocalAdd() this attr will be set to 0, because it's
            // protected.
            ulSysFlags = *(ULONG *)(pAttr->AttrVal.pAVal[0].pVal);
            break;
        case ATT_NC_NAME:
            pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;

        case ATT_OBJECT_CLASS:
            class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
            break;

        case ATT_MS_DS_HAS_MASTER_NCS:
            fNewHasMasterNCsPresent = TRUE;
            // fall through
        case ATT_HAS_MASTER_NCS:
             // This is multi-valued property
            for (j=0;j<pAttr->AttrVal.valCount;j++) {
                if (  NameMatched( gAnchor.pDMD, (DSNAME*)pAttr->AttrVal.pAVal[j].pVal ) ) {
                    pSchema = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                } else if ( NameMatched( gAnchor.pConfigDN, (DSNAME*)pAttr->AttrVal.pAVal[j].pVal ) ) {
                    pConfig = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                } else {
                    pDomain = (DSNAME*)pAttr->AttrVal.pAVal[j].pVal;
                }
            }
            break;

        case ATT_SERVER_REFERENCE:
            pServerReference = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;

        default:
            ;
        }
    }

    //
    // Call a particular function based on the class type
    //
    switch ( class )
    {
        case CLASS_CROSS_REF:

            // Make sure the parameters look good
            if (pNCName == NULL) {
                DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );
            }

            AddNewDomainCrossRef(pTHS,
                                 hDrs,
                                 dwInVersion,
                                 pmsgIn,
                                 pEntInf,
                                 pNCName,
                                 ulSysFlags,
                                 pCRInfo,
                                 objGuid,
                                 objSid );

            break;

        case CLASS_NTDS_DSA:

            // Make sure the parameters look good
            if ((pDomain == NULL) || (pSchema == NULL) || (pConfig == NULL)) {
                DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );
            }
            
            Assert(fNewHasMasterNCsPresent || gAnchor.ForestBehaviorVersion == DS_BEHAVIOR_WIN2000);

            AddNewNtdsDsa(pTHS,
                          hDrs,
                          dwInVersion,
                          pmsgIn,
                          pEntInf,
                          pDomain,
                          pServerReference,
                          objGuid,
                          objSid );
            break;

        default:

            DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, class );

    }

    return pTHS->errCode;
}


ADDCROSSREFINFO *
PreTransGetCRInfo(
    THSTATE *     pTHS,
    ENTINF *      pEntInf
    )
{
    ULONG               i, j;
    ULONG               ulSysFlags = 0;
    ATTRBLOCK *         pAttrBlock;
    ATTR *              pAttr;
    ATTRTYP             class = CLASS_TOP;
    DSNAME *            pNCName = NULL;
    BOOL                bEnabled = TRUE;
    ADDCROSSREFINFO *   pCRInfo;

    // Parameter check
    Assert( pTHS && pEntInf );

    pAttrBlock = &pEntInf->AttrBlock;

    // Look through the arguments to the add to see what it is we're
    // being asked to add.  Also note that we strip out the system flags
    // attribute, so that we can deal with it separately.
    for (i=0; i< pAttrBlock->attrCount; i++) {
        pAttr = &(pAttrBlock->pAttr[i]);

        switch (pAttr->attrTyp) {
        case ATT_OBJECT_CLASS:
            class = *(ATTRTYP*)(pAttr->AttrVal.pAVal->pVal);
            if(class != CLASS_CROSS_REF){
                // We're not adding a crossRef bail early.
                return(NULL);
            }
            break;
        case ATT_NC_NAME:
            pNCName = (DSNAME*)(pAttr->AttrVal.pAVal->pVal);
            break;
        case ATT_SYSTEM_FLAGS:
            ulSysFlags = *(ULONG *)(pAttr->AttrVal.pAVal[0].pVal);
            break;
        case ATT_ENABLED:
            bEnabled = *((BOOL *)(pAttr->AttrVal.pAVal[0].pVal));
            break;
        default:
            ;
        }
    }

    // Verify params.

    if(class != CLASS_CROSS_REF){
        // This is some other object, so return NULL w/o setting an error.
        return(NULL);
    }

    if(pNCName == NULL){
        // We didn't get all the needed parameters, bail.
        SetAttError(pEntInf->pName,
                    (pNCName) ? ATT_OBJECT_CLASS : ATT_NC_NAME,
                    PR_PROBLEM_NO_ATTRIBUTE_OR_VAL,
                    NULL,
                    DIRERR_MISSING_REQUIRED_ATT);
        return(NULL);
    }

    //
    // OK, marshal the parameters, call the pre-transactional
    // nCName verification routine, and check for an error.
    //

    pCRInfo = THAllocEx(pTHS, sizeof(ADDCROSSREFINFO));
    pCRInfo->pdnNcName = pNCName;
    pCRInfo->bEnabled = bEnabled;
    pCRInfo->ulSysFlags = ulSysFlags;
    
    PreTransVerifyNcName(pTHS, pCRInfo);

    if(pTHS->errCode){
        THFreeEx(pTHS, pCRInfo);
        return(NULL);
    }

    return(pCRInfo);
}

void
DRS_AddEntry_SetErrorData(
             OUT DRS_MSG_ADDENTRYREPLY *    pmsgOut,   // Out Message
    OPTIONAL IN  PDSNAME                    pdsObject, // Object causing error
    OPTIONAL IN  THSTATE *                  pTHS,      // For Dir* error info
    OPTIONAL IN  DWORD                      ulRepErr,  // DRS error
             IN  DWORD                      dwVersion  // Version of out message
){

    if(dwVersion == 2){

        if (ulRepErr || (pTHS && pTHS->errCode)) {

            // Set the old version error.
            pmsgOut->V2.pErrorObject = pdsObject;

            Assert((pTHS == NULL) || (pTHS->errCode == 0 || pTHS->pErrInfo));
            if(pTHS && pTHS->errCode && pTHS->pErrInfo){

                // This is the old code, preserved, it makes me a little nervous
                // because it presumes everything is a SvcErr, though it could
                // not be then the structs are a little different.
                pmsgOut->V2.errCode = pTHS->errCode;
                pmsgOut->V2.dsid    = pTHS->pErrInfo->SvcErr.dsid;
                pmsgOut->V2.extendedErr = pTHS->pErrInfo->SvcErr.extendedErr;
                pmsgOut->V2.extendedData = pTHS->pErrInfo->SvcErr.extendedData;
                pmsgOut->V2.problem = pTHS->pErrInfo->SvcErr.problem;

            } else {

                // Previously we used to do nothing (except sometimes AV) here,
                // but this is obviously the wrong behaviour, we should setup 
                // some kind of error.  ulRepErr is probably set, so we'll use
                // it if set.
                Assert(ulRepErr);
                pmsgOut->V2.dsid = DSID(FILENO, __LINE__);
                pmsgOut->V2.extendedErr = (ulRepErr) ? ulRepErr : ERROR_DS_DRA_INTERNAL_ERROR;
                pmsgOut->V2.extendedData = 0;
                pmsgOut->V2.problem = SV_PROBLEM_BUSY;

            }

        } else {

            // Success do nothing.
            ;

        }
        
    } else if(dwVersion == 3){
        
        // Set the new version error reply, 

        if (ulRepErr || (pTHS && pTHS->errCode)) {
            // Set this only on an error.
            // Note: Not deep copied, not needed.
            pmsgOut->V3.pdsErrObject = pdsObject;
        }

        // Yeah! New advanced error returning capabilities.
        // Currently only version 1 of the error data is supported.
        draEncodeError( pTHS, ulRepErr,
                        & (pmsgOut->V3.dwErrVer),
                        & (pmsgOut->V3.pErrData) );
       
    } else {

        DPRINT1(0, "Version is %ul", dwVersion);
        Assert(!"What version were we passed?  Huh?  Confused!");

    }       

    DPRINT1(1, "AddEntry Reply Version = %ul\n", dwVersion);
}

ULONG
DRSAddEntry_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_ADDENTRYREQ *   pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_ADDENTRYREPLY * pmsgOut
    ) 
/*
    [notify]  ULONG IDL_DRSAddEntry( 
    [in]  DRS_HANDLE hDrs,
    [in]  DWORD dwInVersion,
    [switch_is][ref][in]  DRS_MSG_ADDENTRYREQ *pmsgIn,
    [ref][out]  DWORD *pdwOutVersion,
    [switch_is][ref][out]  DRS_MSG_ADDENTRYREPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if (ret==DRAERR_Success) {
   if (dwMsgInVersion==2) { 
       ret = DRS_MSG_ADDENTRYREQ_V2_InputValidate(&(pmsgIn->V2));
   } else if (dwMsgInVersion==3) {
       ret = DRS_MSG_ADDENTRYREQ_V3_InputValidate(&(pmsgIn->V3));
   } else { 
       DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, dwMsgInVersion);
   }
    }

    return ret;
}


ULONG
IDL_DRSAddEntry (
                 IN  DRS_HANDLE hDrs,
                 IN  DWORD dwInVersion,
                 IN  DRS_MSG_ADDENTRYREQ *pmsgIn,
                 OUT DWORD *pdwOutVersion,
                 OUT DRS_MSG_ADDENTRYREPLY *pmsgOut)
/*++

  Routine Description:

    Remoted AddEntry interface.  Examines the input argument to determine the
    objclass of the object being added, and calls an appropriate worker
    function (only one right now) to do the dirty work.

  Parameters:

    hDRS        - RPC context handle
    dwInVersion - message version
    pmsgIn      - input message
    pNCName     - DN of the new child domain
    ulSysFlags  - flags that the caller wants placed on the CR
    pdwOutVersion - version of output message
    pmsgOut     - output message

  Return Values:

    0 = success

--*/
{
    THSTATE *pTHS = pTHStls;
    DSNAME *pNCName = NULL;
    unsigned i;
    ULONG err;
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    ATTR *pAttr;

    ULONG  cObjects = 0;
    ADDENTRY_REPLY_INFO *infoList = NULL;
    GUID   *guidList = NULL;
    NT4SID *sidList  = NULL;
    ENTINFLIST *pNextEntInfList = NULL;
    ENTINF *pEntInf;
    ENTINFLIST *pEntInfList;
    DRS_SecBufferDesc *pClientCreds;
    ADDCROSSREFINFO **  paCRInfo = NULL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSADDENTRY);
    drsReferenceContext( hDrs );
    INC(pcThread);      // Perfmon hook

    __try {
   *pdwOutVersion = 2;
   memset(pmsgOut, 0, sizeof(*pmsgOut));

   // This (InitTHSTATE) must happen before we start throwing 
   // excpetions so the error state can be allocated.
   // Initialize thread state and open data base.
   if(!(pTHS = InitTHSTATE(CALLERTYPE_INTERNAL))) {
       // Failed to initialize a THSTATE.
       DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0);
   }

   if ((err = DRSAddEntry_InputValidate(dwInVersion, 
                    pmsgIn,
                    pdwOutVersion,
                    pmsgOut
                    ))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   // Set the out version, if DC understands new WinXP reply 
   // format use that.
   if( IS_DRS_EXT_SUPPORTED(&(((DRS_CLIENT_CONTEXT * )hDrs)->extRemote), 
             DRS_EXT_ADDENTRYREPLY_V3) ){
       // WinXP/Whistler
       *pdwOutVersion = 3;
   } else {
       // Legacy Win2k request
       *pdwOutVersion = 2;
   }

   switch (dwInVersion) {
   case 2:
       // Win2k-compatible request.
       pEntInfList = &pmsgIn->V2.EntInfList;
       pClientCreds = NULL;
       break;

   case 3:
       // >= Whistler request that supplies client credentials.
       pEntInfList = &pmsgIn->V3.EntInfList;
       pClientCreds = pmsgIn->V3.pClientCreds;
       break;

   default:
       DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, dwInVersion);
   }

   // How many objects are being passed in?
   pNextEntInfList = pEntInfList;
   while ( pNextEntInfList ) {
       cObjects++;
       pNextEntInfList = pNextEntInfList->pNextEntInf;
   }

   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_ADD_ENTRY_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsAddEntry,
          szInsertUL(cObjects),
          (cObjects > 0)
          ? szInsertDN(pEntInfList->Entinf.pName)
          : szInsertSz(""),
       (cObjects > 1) 
   ? szInsertDN(pEntInfList->pNextEntInf->Entinf.pName)
   : szInsertSz(""),
       NULL, NULL, NULL, NULL, NULL);

   // Allocate space for the return buffer
   infoList = THAllocEx( pTHS, (sizeof(ADDENTRY_REPLY_INFO) * cObjects) );

   // We walk and call PreTransGetCRInfo() for each object.
   paCRInfo = THAllocEx( pTHS, (sizeof(ADDCROSSREFINFO) * cObjects));
   for ( pNextEntInfList = pEntInfList, i = 0;
        NULL != pNextEntInfList;
        pNextEntInfList = pNextEntInfList->pNextEntInf, i++ ) {
       Assert(i <= cObjects);
       paCRInfo[i] = PreTransGetCRInfo(pTHS, &pNextEntInfList->Entinf);
       if(pTHS->errCode){
      // Uh oh, there was an error in the pre transactional 
      // crossRef processing.
      break;
       }
   }

   // Start a transaction that will embody the all object additions
   SYNC_TRANS_WRITE();
   __try {

       if(pTHS->errCode){
      // Set an error from PreTransGetCRInfo() so just __leave; to
      // the __finally, where we'll pack up the error to ship.
      Assert(pNextEntInfList != NULL); // Not critical, but we 
      // should have a pNextEntInf struct that broke 
      // PreTransGetCRInfo()
      __leave;
       }

       if (NULL != pClientCreds) {
      // Authenticate the credentials blob.  This saves state
      // information for future impersonation calls on our thread
      // state.  Must do this before acquiring SAM lock as SAM doesn't
      // expect/want locks held during authentication.
      Assert(pNextEntInfList == NULL); // Not really critical, but
      // we should completely PreTransGetCRInfo() on every object
      // before we check the Creds are OK.
      if (err = AuthenticateSecBufferDesc(pClientCreds)) {
          SetSecError(SE_PROBLEM_INVALID_CREDENTS, err);
          __leave;
      }
       }

       for ( pNextEntInfList = pEntInfList, cObjects = 0;
       NULL != pNextEntInfList;
       pNextEntInfList = pNextEntInfList->pNextEntInf, cObjects++ ) {

      pEntInf = &(pNextEntInfList->Entinf);

      // Add this one object
      err = ProcessSingleAddEntry(pTHS,
                   hDrs,
                   dwInVersion,
                   pmsgIn,
                   pEntInf,
                   paCRInfo[cObjects],
                   &infoList[cObjects].objGuid,
                   &infoList[cObjects].objSid );

      if ( err ) {
          // The thread state error should have been set
          Assert( 0 != pTHS->errCode );
          break;
      }
       }

       // If an error occurred during the addition of the objects, bail now
       if ( err )  {
      __leave;
       }

   } __finally {

       CLEAN_BEFORE_RETURN(pTHS->errCode);

       RtlZeroMemory( pmsgOut, sizeof( DRS_MSG_ADDENTRYREPLY ) );

       if(err || (pTHS && pTHS->errCode)){

      // Set the error out parameters
      DRS_AddEntry_SetErrorData(pmsgOut,
                 (pNextEntInfList) ? pNextEntInfList->Entinf.pName : NULL,
          pTHS, err,   // Error info
          *pdwOutVersion);

      // We need to return the GUID on error, but only for 
      // WhistlerXP.NET server, and only when we got the 
      // cross-ref exists error.
      if (*pdwOutVersion == 3 &&
          pTHS->errCode == serviceError &&
          pTHS->pErrInfo->SvcErr.extendedErr == ERROR_DS_CROSS_REF_EXISTS &&
          !fNullUuid(&(infoList[0].objGuid)) ) {
          Assert(cObjects == 0);
          pmsgOut->V3.cObjectsAdded = 1;
          pmsgOut->V3.infoList = infoList;
      } 

       } else {

      // Set the success out parameters
      if(*pdwOutVersion == 3){
          // WinXP/Whistler out, version 3
          Assert(pTHS->errCode == 0);
          pmsgOut->V3.cObjectsAdded  = cObjects;
          pmsgOut->V3.infoList = infoList;
          DRS_AddEntry_SetErrorData(pmsgOut,
                     NULL, pTHS, 0,
                     *pdwOutVersion);
          // Assert the return error data was set to success.
          Assert(pmsgOut->V3.pErrData && pmsgOut->V3.pErrData->V1.dwRepError == 0 && pmsgOut->V3.pErrData->V1.errCode == 0);

      } else {
          // Win2k out, version 2
          Assert(*pdwOutVersion == 2);
          pmsgOut->V2.cObjectsAdded  = cObjects;
          pmsgOut->V2.infoList = infoList;
      } // end if/else (version 3 reply) as oppoesed to version 2

       } // end if/else (error) 

       DPRINT5(1, "err = %u, errCode = %u, dsid = %x, exErr = %u, exData = %u\n",
          err,
          pTHS->errCode,
          GetTHErrorDSID(pTHS),
          Win32ErrorFromPTHS(pTHS),
          GetTHErrorExtData(pTHS));

   }

    }__except(GetExceptionData(GetExceptionInformation(), &dwException,
                                   &dwEA, &ulErrorCode, &dsid)) {
         HandleDirExceptions(dwException, ulErrorCode, dsid);

         // There should be some kind of error!
         Assert(ulErrorCode || (pTHS && pTHS->errCode)); 
         // Exception, set the error in the out message.
         DRS_AddEntry_SetErrorData(pmsgOut,
                                   (pNextEntInfList) ? pNextEntInfList->Entinf.pName : NULL,
                                   pTHS, ulErrorCode,  // Error Info.
                                   *pdwOutVersion);
    }


    DEC(pcThread);      // Perfmon hook
    drsDereferenceContext( hDrs );

    Assert( (*pdwOutVersion == 3) ? pmsgOut->V3.pErrData != NULL : 1 );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_ADD_ENTRY_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsAddEntry,
          szInsertUL( ((*pdwOutVersion == 2) ? pmsgOut->V2.cObjectsAdded : pmsgOut->V3.cObjectsAdded) ),
          szInsertUL(err),
          szInsertWin32Msg(err),
          NULL, NULL, NULL, NULL, NULL);
    }

    // We always return success, any error is in out message.
    return ERROR_SUCCESS;
}

ULONG
DRSExecuteKCC_InputValidate(
    DWORD                   dwMsgVersion,
    DRS_MSG_KCC_EXECUTE *   pMsg
    ) 
/*
    [notify] ULONG IDL_DRSExecuteKCC( 
    [in]  DRS_HANDLE hDrs,
    [in]  DWORD dwInVersion,
    [switch_is][ref][in]  DRS_MSG_KCC_EXECUTE *pmsgIn) 
*/
{
    ULONG ret = DRAERR_Success;

    if (dwMsgVersion!=1) {
   ret = DRAERR_InvalidParameter;
    }

    return ret;
}


ULONG
IDL_DRSExecuteKCC(
    IN  DRS_HANDLE              hDrs,
    IN  DWORD                   dwMsgVersion,
    IN  DRS_MSG_KCC_EXECUTE *   pMsg
    )
/*++

Routine Description:

    Poke the KCC and tell it to run a given task (e.g., update the replication
    topology).

Arguments:

    hDrs (IN) - DRS context handle returned by a prior call to IDL_DRSBind().

    dwMsgVersion (IN) - Version of the structure (union discriminator) embedded
        in pMsg.

    pMsg (IN) - Message containing the KCC parameters.

Return Values:

    0 on success or Win32 error code on failure.

--*/
{
    THSTATE *   pTHS = pTHStls;
    DWORD       ret;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSEXECUTEKCC);
    drsReferenceContext( hDrs );
    INC(pcThread);
    __try {

   if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
       // Failed to initialize a THSTATE.
       DRA_EXCEPT_NOLOG(DRAERR_OutOfMem, 0);
   }

   if ((ret = DRSExecuteKCC_InputValidate(dwMsgVersion, 
                      pMsg
                      ))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

   pTHS->fIsValidLongRunningTask = TRUE;

   Assert(1 == dwMsgVersion);
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_EXECUTE_KCC_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsExecuteKcc,
          szInsertUL(pMsg->V1.dwTaskID),
          szInsertUL(pMsg->V1.dwFlags),
          NULL, NULL, NULL, NULL, NULL, NULL);

   if (!IsDraAccessGranted(pTHS, gAnchor.pConfigDN,
            &RIGHT_DS_REPL_MANAGE_TOPOLOGY, &ret)) {
       // No right to perform this operation.
       DRA_EXCEPT_NOLOG(ret, 0);
   }

   ret = KccExecuteTask(dwMsgVersion, pMsg);
    }__except(GetDraException(GetExceptionInformation(), &ret)) {
    ;
    }
    
    DEC(pcThread);
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_EXECUTE_KCC_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsExecuteKcc,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }
    
    return ret;
}

LPWSTR
StrAllocConcat(
    IN  THSTATE*    pTHS,
    IN  LPCWSTR     str1,
    IN  LPCWSTR     str2,
    IN  LPCWSTR     str3 OPTIONAL
    )
/*++

Routine Description:

    Allocate memory and concatenate two or three strings
    result = str1 + str2 [ + str3 ]

Arguments:

    str1, str2, str3: Unicode strings to concatenate
    str3 may be NULL.

Return Values:

    The concatenation. An exception is raised on allocation failure.

--*/
{
    LPWSTR result;
    size_t len;
    
    // Validate input
    Assert( NULL!=pTHS );
    Assert( NULL!=str1 && NULL!=str2 );

    // Compute the length of the concatenation
    len = 1 + wcslen(str1) + wcslen(str2);
    if(str3) len += wcslen(str3);

    // Allocate memory for the result. Exception is raised on failure.
    result = THAllocEx(pTHS, len*sizeof(WCHAR));

    // Concatenate the strings
    wcscpy( result, str1 );
    wcscat( result, str2 );
    if(str3) wcscat( result, str3 );

    return result;
}


#define INSERTDESTSITE(x) \
    ( ( pmsgIn->V1.cToSites>(x) ) ? \
      ( szInsertWC(pmsgIn->V1.rgszToSites[x]) ) : \
      ( szInsertSz("") ) )

ULONG
DRSQuerySitesByCost_InputValidate(
    DWORD                    dwMsgInVersion,
    DRS_MSG_QUERYSITESREQ*   pmsgIn,
    DWORD*                   pdwOutVersion,
    DRS_MSG_QUERYSITESREPLY* pmsgOut
    ) 
/*
    [notify]  ULONG IDL_DRSQuerySitesByCost( 
    [ref][in]  DRS_HANDLE hDrs,
    [in]  DWORD dwInVersion,
    [switch_is][ref][in]  DRS_MSG_QUERYSITESREQ *pmsgIn,
    [ref][out]  DWORD *pdwOutVersion,
    [switch_is][ref][out]  DRS_MSG_QUERYSITESREPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if (dwMsgInVersion!=1) {
   ret = DRAERR_InvalidParameter;
    }

    if (ret==DRAERR_Success) {
   ret = DRS_MSG_QUERYSITESREQ_V1_InputValidate(&(pmsgIn->V1));
    }
    
    return ret;
}


ULONG
IDL_DRSQuerySitesByCost( 
    IN DRS_HANDLE                   hDrs,
    IN DWORD                        dwInVersion,
    IN DRS_MSG_QUERYSITESREQ*       pmsgIn,
    OUT DWORD*                      pdwOutVersion,
    OUT DRS_MSG_QUERYSITESREPLY*    pmsgOut
    )
/*++

Routine Description:

    This function is the server-side of the _IDL_DRSQuerySitesByCost() RPC call.
    It is exposed through the NTDSAPI function DsQuerySitesByCost().

    The current implementation is just a simple wrapper for the ISM function
    I_ISMQuerySitesByCost. This wrapper validates the input, logs trace-events
    and converts the input strings to distinguished names.

Arguments:

    hDrs (IN) - DRS context handle returned by a prior call to IDL_DRSBind().

    dwInVersion (IN) - Version of the structure (union discriminator) embedded
        in pMsg. Note: If the client tries to pass in an unsupported version
        number (i.e. anything except 1), the call will fail with error
        RPC_S_INVALID_TAG.

    pmsg (IN) - Message containing the actual parameters to this function.
        Note: If the client tries to pass in a NULL pointer for pmsg, the call
        will fail with error RPC_X_NULL_REF_POINTER.

    pdwOutVersion (OUT) - Version of the structure (union descriminator)
        embedded in pmsgOut. Currently always returns 1.
    
    pmsgOut - Message containing the output from this function.

Return Values:

    ERROR_SUCCESS: Function executed successfully. There may still be some
        error codes associated with the individual entries in the output array.

    Various error codes may be returned.
    
--*/
{
    THSTATE *                   pTHS=pTHStls;
    DWORD                       iSites, len, cToSites;
    CONST LPWSTR                pszConfig = gAnchor.pConfigDN->StringName;
    LPWSTR                      pszSites=NULL;
    LPWSTR                      pszIpTransport=NULL, pszFromSite=NULL;
    LPWSTR                      *rgszToSites=NULL;
    ISM_SITE_COST_INFO_ARRAY *  pIsmSiteInfo=NULL;
    DWORD                       ret;

    LPCWSTR                     CN = L"CN=";
    LPCWSTR                     SITES = L",CN=Sites,";
    LPCWSTR                     IP_TRANSPORT = L"CN=IP,CN=Inter-Site Transports";

    DRS_Prepare(&pTHS, hDrs, IDL_DRSQUERYSITESBYCOST);
    drsReferenceContext( hDrs );
    INC(pcThread);
    __try {
   // Initialize reply  
   *pdwOutVersion = 1;
   memset( pmsgOut, 0, sizeof(DRS_MSG_QUERYSITESREPLY) );

   // Initialize a THSTATE.
   if(!(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI))) {
       DRA_EXCEPT_NOLOG(DRAERR_OutOfMem, 0);
   }

   if ((ret = DRSQuerySitesByCost_InputValidate(dwInVersion, 
                       pmsgIn,
                       pdwOutVersion,
                       pmsgOut
                       ))!=DRAERR_Success) {
       Assert(!"RPC Server input validation error, contact Dsrepl");
       __leave;
   }

       

   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_QUERYSITESBYCOST_ENTRY,
          EVENT_TRACE_TYPE_START,
          DsGuidDrsQuerySitesByCost,
          szInsertWC(pmsgIn->V1.pwszFromSite),
          INSERTDESTSITE(0),
          INSERTDESTSITE(1),
          INSERTDESTSITE(2),
          INSERTDESTSITE(3),
          INSERTDESTSITE(4),
          INSERTDESTSITE(5),
          INSERTDESTSITE(6));

   cToSites = pmsgIn->V1.cToSites;
   // Debugging output
   DPRINT( 2, "IDL_DRSQuerySitesByCost() server-side call\n" );
   DPRINT1( 2, "From Site: %ls\n",
       pmsgIn->V1.pwszFromSite);
   for( iSites=0; iSites<pmsgIn->V1.cToSites; iSites++ ) {
       DPRINT2( 2, "To Site[ %d ]: %ls\n",
           iSites, pmsgIn->V1.rgszToSites[iSites] );
   }

   // Note: Permissions are not checked here. Any authenticated user is
   // allowed to call this API and only authenticated users can bind.

   // Construct DN of IP Transport
   pszSites = StrAllocConcat( pTHS, SITES, pszConfig, NULL );
   pszIpTransport = StrAllocConcat( pTHS, IP_TRANSPORT, pszSites, NULL );

   // Construct full DN for the RDNs given as input
   pszFromSite = StrAllocConcat( pTHS, CN, pmsgIn->V1.pwszFromSite, pszSites );
   rgszToSites = THAllocEx( pTHS, cToSites*sizeof(LPWSTR) );
   for( iSites=0; iSites<cToSites; iSites++ ) {
       rgszToSites[iSites] = StrAllocConcat( pTHS, CN,
                    pmsgIn->V1.rgszToSites[iSites], pszSites );
   }

   // Call ISM to compute answer to query
   ret = I_ISMQuerySitesByCost(
       pszIpTransport,
       pszFromSite,
       cToSites,
       rgszToSites,
       pmsgIn->V1.dwFlags,
       &pIsmSiteInfo );

   if( ERROR_SUCCESS!=ret ) {                
       DPRINT1( 0, "I_ISMQuerySitesByCost returned %d\n", ret );
       __leave;
   }

   // Build up our reply structure
   pmsgOut->V1.rgCostInfo = THAllocEx(pTHS,
                  pIsmSiteInfo->cToSites * sizeof(DRS_MSG_QUERYSITESREPLYELEMENT_V1) );
   memcpy( pmsgOut->V1.rgCostInfo, pIsmSiteInfo->rgCostInfo,
      pIsmSiteInfo->cToSites * sizeof(DRS_MSG_QUERYSITESREPLYELEMENT_V1) );
   pmsgOut->V1.cToSites = pIsmSiteInfo->cToSites;
   pmsgOut->V1.dwFlags = pIsmSiteInfo->dwFlags;

    }__except(GetDraException(GetExceptionInformation(), &ret)) {
    ;
    }

    DEC(pcThread);
    drsDereferenceContext( hDrs );
    
    if( NULL!=pIsmSiteInfo ) {
   I_ISMFree(pIsmSiteInfo);
    }

    if (NULL != pTHS) {
   LogAndTraceEvent(TRUE,
          DS_EVENT_CAT_RPC_SERVER,
          DS_EVENT_SEV_EXTENSIVE,
          DIRLOG_IDL_DRS_QUERYSITESBYCOST_EXIT,
          EVENT_TRACE_TYPE_END,
          DsGuidDrsQuerySitesByCost,
          szInsertUL(ret),
          szInsertWin32Msg(ret),
          NULL, NULL, NULL,
          NULL, NULL, NULL);
    }
    
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drasig.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drautil.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Miscellaneous replication support routines.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include "dsexcept.h"
#include <dsutil.h>

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRASIG:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drserr.h"
#include "drautil.h"
#include "drasig.h"
#include "draerror.h"
#include "drauptod.h"
#include "drameta.h"
#include "drauptod.h"

#include <fileno.h>
#define  FILENO FILENO_DRASIG

#include <dsjet.h>              /* for error codes */
#include <ntdsbsrv.h>
#include "dbintrnl.h"

void
APIENTRY
InitInvocationId(
    IN  THSTATE *   pTHS,
    IN  BOOL        fRetireOldID,
    IN  BOOL        fRestoring,
    OUT USN *       pusn    OPTIONAL
    )
/*++

Routine Description:

    Set up the invocation id for this DSA and save it as an attribute on the DSA
    object.

Arguments:

    pTHS (IN)

    fRetireOldID (IN) - If TRUE, then we save the current invocation ID in the
        retiredReplDsaSignatures list on the DSA object and generate a new
        invocation ID.
	
    fRestoring (IN) - If TRUE, then we are restoring from backup. 

    pusn (OUT, OPTIONAL) - If specified, the highest USN in the database
        we can safely return for the old invocation id.
	
	fRestoring and fRetireOldID, this value is the usnAtBackup value.
	fRetireOldID and !fRestoring, this is the usnAtRetire value (calculated here)
	!fRetireOldID, this is the current highest uncommitted usn.

Return Values:

    None.

--*/
{
    UCHAR     syntax;
    ULONG     len;
    DBPOS *   pDB;
    UUID      invocationId = {0};
    BOOL      fCommit = FALSE;
    DWORD     err;
    USN       usn;
    DBPOS *   pDBh;
    DITSTATE  eDitState = eMaxDit;

    // if we are restoring, we should also be retiring the invocation ID
    Assert(!(fRestoring && !fRetireOldID));

    // A lazy commit would be bad, because we're commiting knowledge of our highest
    // committed USN, which can rollback on a crash, if we've got a lazy commit.
    Assert(!pTHS->fLazyCommit); 

    DBOpen(&pDB);
    __try {

        pDBh = dbGrabHiddenDBPOS(pTHS); 

        if (gAnchor.pDSADN == NULL) {
            // ISSUE-2002/08/06-BrettSh - I believe that we have a NULL anchor,
            // because if RebuildAnchor() were to fail on boot, it would not set
            // the pDSADN, and Install() lets us continue past RebuildAnchor.
            Assert(!"InitInvocationId: Local DSA object not found");
            err = ERROR_INVALID_PARAMETER;
            LogUnhandledError(err);
            __leave;
        }

        // PREFIX: dereferencing NULL pointer 'pDB'
        //         DBOpen returns non-NULL pDB or throws an exception
        err = DBFindDSName(pDB, gAnchor.pDSADN);
        if (err) {
            Assert(!"InitInvocationId: Local DSA object not found");
            LogUnhandledError(err);
            __leave;
        }

        if (!fRetireOldID
            && !DsaIsInstalling()
            && !DBGetSingleValue(pDB, ATT_INVOCATION_ID, &invocationId,
                                 sizeof(invocationId), NULL)) {
            Assert(!"InitInvocationId: Invocation id already set\n");
            LogUnhandledError(0);
            __leave;
        }

        // Either the DB is restored or there is no invocation Id.
        // Set a new invocation id in either case

        if (fRestoring) { 
            // Get the backup USN.

            err = (*FnErrGetBackupUsn)(
                                      pDB->JetDBID,
                                      pDBh->JetSessID,
                                      HiddenTblid,
                                      &usn,
                                      NULL);

            Assert(0 == err);
            Assert(0 != usn);

        } else {

            // get the usnAtRetire value.  This is the value to use with 
            // the retired InvocationID.  
            usn = DBGetHighestCommittedUSN();

        }

        //
        // Create a UUID. This routine checks one have been stored
        // away by an authoritative restore operation. If so, use that
        // and delete the key since we're done with it. If not,
        // a new one is generated via UuidCreate.
        //

        if (0 == err) {
            err = FnErrGetNewInvocationId(NEW_INVOCID_CREATE_IF_NONE
                                          | NEW_INVOCID_DELETE,
                                          &invocationId);
            Assert(0 == err);
            Assert(0 != usn);
        }

        if (err != ERROR_SUCCESS) {
            DPRINT1(0,"ErrGetNewInvocationId or ErrGetBackupUsn failed, return 0x%x\n",err);

            LogAndAlertEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_GET_GUID_FAILED,
                             szInsertUL(err),0,0);
            __leave;
        }

        if ( !DsaIsInstallingFromMedia() ) {

            if (fRetireOldID) {
                // We were just restored.  Add the previous invocation id, time
                // stamp, and USN to the retired signature list.
                REPL_DSA_SIGNATURE_VECTOR * pSigVec = NULL;
                DWORD                       cb;
                
                // Get the current vector (NULL if none).
                pSigVec = DraReadRetiredDsaSignatureVector(pTHS, pDB);

                // Add previous identity to list
                DraGrowRetiredDsaSignatureVector( pTHS,
                                                  &pTHS->InvocationID,
                                                  &usn,
                                                  &pSigVec,
                                                  &cb );

                // Write the new DSA signature vector back to the DSA object.
                DBResetAtt(pDB, ATT_RETIRED_REPL_DSA_SIGNATURES, cb, pSigVec,
                           SYNTAX_OCTET_STRING_TYPE);

                THFreeEx(pTHS, pSigVec);

                // Force rebuild of anchor since SigVec is cached there
                pTHS->fAnchorInvalidated = TRUE;

                // The last thing we want to do in the DIT state to phase I
                // of restore complete.
                err = DBGetHiddenStateInt(pDBh, &eDitState);
                if (err) {
                    LogUnhandledError(err);
                    __leave;
                }
                Assert(eDitState != eMaxDit && 
                       eDitState != eErrorDit && 
                       eDitState != eRestoredPhaseI);
                if (eDitState == eBackedupDit) {
                    // This backup was a snapshot backup, move the DB
                    // DIT to the next phase of restore.
                    Assert(!DsaIsInstalling());
                    Assert(gfRestoring && fRestoring);
                    eDitState = eRestoredPhaseI;
                    err = DBSetHiddenDitStateAlt(pDB, eDitState);
                    if (err) {
                        LogUnhandledError(err);
                        __leave;
                    }

                } else {
                    Assert(eDitState == eRunningDit);
                }

            }

            DBResetAtt(pDB, ATT_INVOCATION_ID, sizeof(invocationId),
                       &invocationId, SYNTAX_OCTET_STRING_TYPE);

            // Remove the Retired NC signature list. It's purpose is to tell us to switch
            // invocation id's if we rehost an NC. Since we are changing our invocation id,
            // the current retired list is no longer needed.  It's ok if the attribute
            // doesn't exist.

            DBRemAtt( pDB, ATT_MS_DS_RETIRED_REPL_NC_SIGNATURES );

            // Begin using our newly adopted invocation ID.  I.e., the update below
            // will be attributed to our new invocation ID, not our old one.
            pTHS->InvocationID = invocationId;

            err = DBRepl(pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING);
            if (err) {
                LogUnhandledError(err);
                __leave;
            }

        } else {

            //
            // In the install from media case, just update the global value.
            // At this point our current DSA is the old backup DSA,
            // and we don't want to make any changes to it!
            //

            pTHS->InvocationID = invocationId;

            // The retired signature will be updated later.

        }
        LogEvent(DS_EVENT_CAT_REPLICATION,
                 DS_EVENT_SEV_EXTENSIVE,
                 DIRLOG_DRA_SET_UUID,
                 szInsertUUID(&pTHS->InvocationID),
                 NULL,
                 NULL);

        fCommit = TRUE;

    }
    __finally {

        dbReleaseHiddenDBPOS(pDBh);
        DBClose(pDB, fCommit );
    }

    if (!fCommit) {
        // An error occurred.
        DsaExcept(DSA_EXCEPTION, ERROR_DS_DATABASE_ERROR, 0);
    }

    UpdateAnchorWithInvocationID(pTHS);

    // Force rebuild of anchor since SigVec is cached there
    pTHS->fAnchorInvalidated = TRUE;

    if (NULL != pusn) {
        *pusn = usn;
    }
}




void
draRetireInvocationID(
    IN OUT  THSTATE *   pTHS,
    IN BOOL fRestoring,
    OUT UUID * pinvocationIdOld OPTIONAL,
    OUT USN * pusnAtBackup OPTIONAL
    )
/*++

Routine Description:

    Retire our current invocation ID and allocate a new one.

Arguments:

    pTHS (IN/OUT) - On return, pTHS->InvocationID holds the new invocation ID.
    fRestoring (IN) - TRUE if restoring from backup.
    pinvocationIdOld (OUT, OPTIONAL) - Receives previous invocation id. This is just
       the pTHS->InvocationID at the start of this function.
    pusnAtBackup (OUT, OPTIONAL) - Receives USN at backup

Return Values:

    None.  Throws exception on catastrophic failure.

--*/
{
    DWORD                   err;
    DBPOS *                 pDBTmp;
    NAMING_CONTEXT_LIST *   pNCL;
    UUID                    invocationIdOld = pTHS->InvocationID;
    USN                     usnAtBackup;
    SYNTAX_INTEGER          it;
#if DBG
    CHAR                    szUuid[40];
#endif
    NCL_ENUMERATOR          nclEnum;
    UPTODATE_VECTOR *       pUpToDateVec = NULL;

    // Reinitialize the REPL DSA Signature (i.e. the invocation id)
    InitInvocationId(pTHS, TRUE, fRestoring, &usnAtBackup);

    DPRINT1(0, "Retired previous invocation ID %s.\n",
            DsUuidToStructuredString(&invocationIdOld, szUuid));
    DPRINT1(0, "New invocation ID is %s.\n",
            DsUuidToStructuredString(&pTHS->InvocationID, szUuid));

    LogEvent(DS_EVENT_CAT_REPLICATION,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DRA_INVOCATION_ID_CHANGED,
             szInsertUUID(&invocationIdOld),
             szInsertUUID(&pTHS->InvocationID),
             szInsertUSN(usnAtBackup));

    // Update our UTD vectors to show that we're in sync with changes we
    // made using our old invocation ID up through our highest USN at the
    // time we were backed up.
    NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
#if DBG == 1
    Assert(NCLEnumeratorGetNext(&nclEnum));
    NCLEnumeratorReset(&nclEnum);
#endif

    // Build a dummy remote UTDVEC for use in improving our own UTDVEC
    // We use the time the DSA started so as not to fool latency checkers into
    // thinking we have had a recent sync.
    pUpToDateVec = THAllocEx( pTHS, UpToDateVecVNSizeFromLen(1) );
    pUpToDateVec->dwVersion = UPTODATE_VECTOR_NATIVE_VERSION;
    pUpToDateVec->V2.cNumCursors = 1;
    pUpToDateVec->V2.rgCursors[0].uuidDsa = invocationIdOld;
    pUpToDateVec->V2.rgCursors[0].usnHighPropUpdate = usnAtBackup;
    pUpToDateVec->V2.rgCursors[0].timeLastSyncSuccess = gtimeDSAStarted;

    DBOpen(&pDBTmp);
    __try {
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_MASTER_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                UpToDateVec_Improve(pDBTmp, pUpToDateVec);
            } else {
                DPRINT1( 0, "Warning: UTD for %ws was not improved with old invocation id because it was in transition.\n", pNCL->pNC->StringName );
            }
        }

        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_REPLICA_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                UpToDateVec_Improve(pDBTmp, pUpToDateVec);
            } else {
                DPRINT1( 0, "Warning: UTD for %ws was not improved with old invocation id because it was in transition.\n", pNCL->pNC->StringName );
            }
        }
    } __finally {
        DBClose(pDBTmp, !AbnormalTermination());
    }

#if DBG
// Be paranoid that old invocation id got in there
    DBOpen(&pDBTmp);
    __try {
        USN usn;
        REPL_DSA_SIGNATURE_VECTOR * pSigVec;
        REPL_DSA_SIGNATURE_V1 * pEntry = NULL;
        DWORD i;

        NCLEnumeratorInit(&nclEnum, CATALOG_MASTER_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_MASTER_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                Assert( UpToDateVec_GetCursorUSN(pUpToDateVec, &invocationIdOld, &usn) &&
                    (usn >= usnAtBackup) );
            }
        }

        NCLEnumeratorInit(&nclEnum, CATALOG_REPLICA_NC);
        while (pNCL = NCLEnumeratorGetNext(&nclEnum)) {
            err = FindNC(pDBTmp, pNCL->pNC, FIND_REPLICA_NC, &it);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            if (!((it & IT_NC_COMING) || (it & IT_NC_GOING))) {
                Assert( UpToDateVec_GetCursorUSN(pUpToDateVec, &invocationIdOld, &usn) &&
                    (usn >= usnAtBackup) );
            }
        }

        // Make sure that old invocation id was retired
        // Note that during IFM the signature is retired later
        if (!DsaIsInstallingFromMedia()) {
            // Read from database because not sure anchor has been rebuilt yet
            err = DBFindDSName(pDBTmp, gAnchor.pDSADN);
            if (err) {
                DRA_EXCEPT(DRAERR_InconsistentDIT, err);
            }

            pSigVec = DraReadRetiredDsaSignatureVector( pTHS, pDBTmp );
            Assert( pSigVec && (1 == pSigVec->dwVersion) );
            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                if (0 == memcmp(&pEntry->uuidDsaSignature,
                                &invocationIdOld,
                                sizeof(UUID))) {
                    break;
                }
            }
            Assert( (i < pSigVec->V1.cNumSignatures) && pEntry &&
                    (pEntry->usnRetired == usnAtBackup) );

        }
    } __finally {
        DBClose(pDBTmp, !AbnormalTermination());
    }

#endif

    // Copy out optional out params if necessary
    if (pinvocationIdOld) {
        *pinvocationIdOld = invocationIdOld;
    }
    if (pusnAtBackup) {
        *pusnAtBackup = usnAtBackup;
    }

    THFreeEx( pTHS, pUpToDateVec );
}

void
DraImproveCallersUsnVector(
    IN     THSTATE *          pTHS,
    IN     UUID *             puuidDsaObjDest,
    IN     UPTODATE_VECTOR *  putodvec,
    IN     UUID *             puuidInvocIdPresented,
    IN     ULONG              ulFlags,
    IN OUT USN_VECTOR *       pusnvecFrom
    )
/*++

Routine Description:

    Improve the USN vector presented by the destination DSA based upon his
    UTD vector, whether we've been restored since he last replicated, etc.

Arguments:

    pTHS (IN)

    puuidDsaObjDest (IN) - objectGuid of the destination DSA's ntdsDsa
        object.

    putodvec (IN) - UTD vector presented by dest DSA.

    puuidInvocIdPresented (IN) - invocationID dest DSA thinks we're running
        with.  May be fNullUuid() on first packet when destination does not have
        a pre-existing reps-from.

    ulFlags - incoming replication flag.

    pusnvecFrom (IN/OUT) - usn vector to massage.

Return Values:

    None.  Throws exceptions on critical failures.

--*/
{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec = gAnchor.pSigVec;
    REPL_DSA_SIGNATURE_V1 *     pEntry;
    DBPOS *                     pDB = pTHS->pDB;
    DWORD                       err;
#if DBG
    CHAR                        szTime[SZDSTIME_LEN];
#endif
    USN_VECTOR                  usnvecOrig = *pusnvecFrom;
    USN                         usnFromUtdVec;
    DWORD                       i;
    USN                         usnRetired = 0;

    Assert( (!pSigVec) || (1 == pSigVec->dwVersion));
    Assert( puuidInvocIdPresented );

    if ((0 != memcmp(&pTHS->InvocationID, puuidInvocIdPresented, sizeof(UUID)))
        && !fNullUuid(puuidInvocIdPresented)
        && (0 != memcmp(&gusnvecFromScratch,
                        pusnvecFrom,
                        sizeof(USN_VECTOR)))) {
        // Caller is performing incremental replication but did not present our
        // current invocation ID.  This means either he didn't get his
        // replication state from us or we've been restored from backup since he
        // last replicated from us.
        //
        // If the latter, we may need to update his USN vector.  Consider the
        // following:
        //
        // (1) Dest last synced up to USN X generated under our old ID.
        //     We were backed up at USN X+Y, generated changes up to
        //     X+Y+Z under our old ID, and later restored at USN X+Y.
        //     => Dest should sync starting at USN X.
        //
        // (2) We were backed up at USN X.  We generated further
        //     changes.  Dest last synced up to USN X+Y.  We were
        //     restored at USN X.  Changes generated under our new ID
        //     from X to X+Y are different from those generated under
        //     our old ID from X to X+Y.  However we know those at X
        //     and below are identical, which dest claims to have seen.
        //     => Dest should sync starting at USN X.
        //
        // I.e., dest should always sync starting from the lower of the
        // "backed up at" and "last synced at" USNs.

        if (NULL == pSigVec) {
            // Implies caller did not get his state from us to begin with.
            // The USN vector presented is useless.  This might occur if the
            // local DSA has been demoted and repromoted.
            DPRINT(0, "Dest DSA presented unrecognized invocation ID -- will sync from scratch.\n");
            *pusnvecFrom = gusnvecFromScratch;
        }
        else {
            // Try to find the invocation ID presented by the caller in our restored
            // signature list.
            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                usnRetired = pEntry->usnRetired;

                if (0 == memcmp(&pEntry->uuidDsaSignature,
                                puuidInvocIdPresented,
                                sizeof(UUID))) {
                    // The dest DSA presented an invocation ID we have since retired.
                    DPRINT1(0, "Dest DSA has not replicated from us since our restore on %s.\n",
                            DSTimeToDisplayString(pEntry->timeRetired, szTime));

                    if (pEntry->usnRetired < pusnvecFrom->usnHighPropUpdate) {
                        DPRINT2(0, "Rolling back usnHighPropUpdate from %I64d to %I64d.\n",
                                pusnvecFrom->usnHighPropUpdate, pEntry->usnRetired);
                        pusnvecFrom->usnHighPropUpdate = pEntry->usnRetired;
                    }

                    if (pEntry->usnRetired < pusnvecFrom->usnHighObjUpdate) {
                        DPRINT2(0, "Rolling back usnHighObjUpdate from %I64d to %I64d.\n",
                                pusnvecFrom->usnHighObjUpdate, pEntry->usnRetired);
                        pusnvecFrom->usnHighObjUpdate = pEntry->usnRetired;
                    }
                    break;
                }
            }

            if (i == pSigVec->V1.cNumSignatures) {
                // Implies caller did not get his state from us to begin with,
                // or that the invocationID he had for us was produced during
                // a restore that was later wiped out by a subsequent restore
                // of a backup preceding the original restore.  (Got that? :-))
                // The USN vector presented is useless.
                DPRINT(0, "Dest DSA presented unrecognized invocation ID -- will sync from scratch.\n");
                *pusnvecFrom = gusnvecFromScratch;
            }
        }

        LogEvent8(DS_EVENT_CAT_REPLICATION,
                  DS_EVENT_SEV_ALWAYS,
                  DIRLOG_DRA_ADJUSTED_DEST_BOOKMARKS_AFTER_RESTORE,
                  szInsertUUID(puuidDsaObjDest),
                  szInsertUSN(usnRetired),
                  szInsertUUID(puuidInvocIdPresented),
                  szInsertUSN(usnvecOrig.usnHighObjUpdate),
                  szInsertUSN(usnvecOrig.usnHighPropUpdate),
                  szInsertUUID(&pTHS->InvocationID),
                  szInsertUSN(pusnvecFrom->usnHighObjUpdate),
                  szInsertUSN(pusnvecFrom->usnHighPropUpdate));
    }

    if (UpToDateVec_GetCursorUSN(putodvec, &pTHS->InvocationID, &usnFromUtdVec)
        && (usnFromUtdVec > pusnvecFrom->usnHighPropUpdate)) {
        // The caller's UTD vector says he is transitively up-to-date with our
        // changes up to a higher USN than he is directly up-to-date.  Rather
        // than seeking to those objects with which he is transitively up-to-
        // date then throwing them out one-by-one after the UTD vector tells us
        // he's already seen the changes, skip those objects altogether.
        pusnvecFrom->usnHighPropUpdate = usnFromUtdVec;

        if (!(ulFlags & DRS_SYNC_PAS) &&
            usnFromUtdVec > pusnvecFrom->usnHighObjUpdate) {
            // improve obj usn unless we're in PAS mode in which case
            // we have to start from time 0 & can't optimize here.
            pusnvecFrom->usnHighObjUpdate = usnFromUtdVec;
        }
    }

    // PERF 99-05-23 JeffParh, bug 93068
    //
    // If we really wanted to get fancy we could handle the case where we've
    // been restored, the target DSA is adding us as a new replication partner,
    // and he is transitively up-to-date wrt one of our old invocation IDs but
    // not our current invocation ID.  I.e., we could use occurrences of our
    // retired DSA signatures that we found in the UTD vector he presnted in
    // order to improve his USN vector.  To do this we'd probably want to cache
    // the retired DSA signature list on gAnchor to avoid re-reading it so
    // often.  And we'd need some pretty sophisticated test cases.
    //
    // Note that this would also help the following sequence:
    // 1. Backup.
    // 2. Restore, producing new invocation ID.
    // 3. Partner syncs from us, optimizing his bookmarks and getting our new
    //    invocation ID.
    // 4. We're again restored from the same backup.
    // 5. Partner syncs from us, presenting the invocation ID he received
    //    following the first restore.  Since local knowledge of this invocation
    //    ID was wiped out in the second restore, we force the partner to sync
    //    from USN 0.
    //
    // If we recognized old invocation IDs in the UTD vector, we could avoid
    // the full sync in step 5.

    // wlees 01-09-28, what he said. :-)
    // This has the additional beneficial property of allowing a dest that is syncing
    // against an IFM'd source to be optimized based on the old invocation id.

    if (pSigVec) {
        USN usnBestRestoredCommon = 0;
        USN usnCommon;
        UUID uuidBestRestoredCommon;
        CHAR szUuid[ SZUUID_LEN ];

        // See if the caller's UTD vector says he's transitively up to date with
        // any of our restore-ancestors (ie old invocation ids).
        for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
            pEntry = &pSigVec->V1.rgSignature[i];

            if (UpToDateVec_GetCursorUSN(putodvec, &pEntry->uuidDsaSignature, &usnFromUtdVec))
            {
                usnCommon = min( pEntry->usnRetired, usnFromUtdVec );
                if (usnCommon > usnBestRestoredCommon) {
                    usnBestRestoredCommon = usnCommon;
                    uuidBestRestoredCommon = pEntry->uuidDsaSignature;
                }
            }
        }
        if (usnBestRestoredCommon > pusnvecFrom->usnHighPropUpdate) {

            pusnvecFrom->usnHighPropUpdate = usnBestRestoredCommon;

            if (!(ulFlags & DRS_SYNC_PAS) &&
                usnBestRestoredCommon > pusnvecFrom->usnHighObjUpdate) {
                // improve obj usn unless we're in PAS mode in which case
                // we have to start from time 0 & can't optimize here.
                pusnvecFrom->usnHighObjUpdate = usnBestRestoredCommon;
            }

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DRA_ADJUSTED_DEST_BOOKMARKS_COMMON_ANCESTOR,
                      szInsertUUID(puuidDsaObjDest),
                      szInsertUUID(&uuidBestRestoredCommon),
                      szInsertUSN(usnBestRestoredCommon),
                      szInsertUSN(usnvecOrig.usnHighObjUpdate),
                      szInsertUSN(usnvecOrig.usnHighPropUpdate),
                      szInsertUUID(&pTHS->InvocationID),
                      szInsertUSN(pusnvecFrom->usnHighObjUpdate),
                      szInsertUSN(pusnvecFrom->usnHighPropUpdate) );
        }
    }

#if DBG
    // Assert that the dest claims he is no more up-to-date wrt us than we are
    // with ourselves.
    {
        USN usnLowestC = 1 + DBGetHighestCommittedUSN();

        Assert(pusnvecFrom->usnHighPropUpdate < usnLowestC);
        Assert(pusnvecFrom->usnHighObjUpdate < usnLowestC);
    }
#endif
}


VOID
DraGrowRetiredDsaSignatureVector( 
    IN     THSTATE *   pTHS,
    IN     UUID *      pinvocationIdOld,
    IN     USN *       pusnAtBackup,
    IN OUT REPL_DSA_SIGNATURE_VECTOR ** ppSigVec,
    OUT    DWORD *     pcbSigVec
    )

/*++

Routine Description:

    Add a new entry to the signature vector. The old vector has already been
    read and is passed in. The new vector is allocated and returned.

Arguments:

      pTHS - thread state
      pinvocationIdOld - Retired invocation id to be added
      pusnAtBackup - Retired usn to be added
      ppSigVec - IN, old vector or null
                 OUT, new vector reallocated
      pcbSigVec - OUT, size of new vector

Return Value:

    None

--*/

{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec;
    REPL_DSA_SIGNATURE_V1 *     pEntry;
    DWORD                       cb;
    DWORD                       i;
    CHAR                        szUuid1[SZUUID_LEN];

    Assert( pinvocationIdOld );
    Assert( pusnAtBackup );
    Assert( ppSigVec );
    Assert( pcbSigVec );

    pSigVec = *ppSigVec;
    if (NULL == pSigVec) {
        // No signatures retired yet; synthesize a new vector.
        cb = ReplDsaSignatureVecV1SizeFromLen(1);
        pSigVec = (REPL_DSA_SIGNATURE_VECTOR *) THAllocEx(pTHS, cb);
        pSigVec->dwVersion = 1;
        pSigVec->V1.cNumSignatures = 1;
    }
    else {
#if DBG
        USN usnCurrent = DBGetHighestCommittedUSN();
        Assert(1 == pSigVec->dwVersion);
        for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
            pEntry = &pSigVec->V1.rgSignature[i];
            Assert(0 != memcmp(pinvocationIdOld,
                               &pEntry->uuidDsaSignature,
                               sizeof(UUID)));
            Assert(usnCurrent >= pEntry->usnRetired);
        }
#endif
        // Expand current vector to hold a new entry.
        pSigVec->V1.cNumSignatures++;
        cb = ReplDsaSignatureVecV1Size(pSigVec);
        pSigVec = (REPL_DSA_SIGNATURE_VECTOR *)
            THReAllocEx(pTHS, pSigVec, cb);
    }

    Assert(pSigVec->V1.cNumSignatures);
    Assert(cb == ReplDsaSignatureVecV1Size(pSigVec));

    pEntry = &pSigVec->V1.rgSignature[pSigVec->V1.cNumSignatures-1];

    Assert(fNullUuid(&pEntry->uuidDsaSignature));
    Assert(0 == pEntry->timeRetired);
    Assert(*pusnAtBackup <= DBGetHighestCommittedUSN());

    // Add the retired DSA signature details at the end of the vector.
    pEntry->uuidDsaSignature = *pinvocationIdOld;
    pEntry->timeRetired      = DBTime();
    pEntry->usnRetired       = *pusnAtBackup;

    DPRINT5( 1, "DraGrowRetiredSignatureVector: ver=%d, cNum=%d, pSigVec=%p, uuid=%s, usn=%I64d\n",
             pSigVec->dwVersion, pSigVec->V1.cNumSignatures, pSigVec,
             DsUuidToStructuredString(pinvocationIdOld, szUuid1), *pusnAtBackup);

    // Copy out out parameters
    *ppSigVec = pSigVec;
    *pcbSigVec = cb;
}

REPL_DSA_SIGNATURE_VECTOR *
DraReadRetiredDsaSignatureVector(
    IN  THSTATE *   pTHS,
    IN  DBPOS *     pDB
    )
/*++

Routine Description:

    Reads the retiredReplDsaSignatures attribute from the local ntdsDsa object,
    converting it into the most current structure format if necessary.

Arguments:

    pTHS (IN)

    pDB (IN) - Must be positioned on local ntdsDsa object.

Return Values:

    The current retired DSA signature list, or NULL if none.

    Throws DRA exception on catastrophic failures.

--*/
{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec = NULL;
    REPL_DSA_SIGNATURE_V1 *     pEntry;
    DWORD                       cb;
    DWORD                       i;
    DWORD                       err;

    // Should be positioned on our own ntdsDsa object.
    Assert(NameMatched(GetExtDSName(pDB), gAnchor.pDSADN));

    err = DBGetAttVal(pDB, 1, ATT_RETIRED_REPL_DSA_SIGNATURES,
                      0, 0, &cb, (BYTE **) &pSigVec);

    if (DB_ERR_NO_VALUE == err) {
        // No signatures retired yet.
        pSigVec = NULL;
    }
    else if (err) {
        // Read failed.
        Assert(!"Unable to read the retired DSA Signatures");
        LogUnhandledError(err);
        DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
    }
    else {

        Assert(pSigVec);

        // FUTURE-2002/05/20-BrettSh NOTE: If the version of the dsa signature 
        // is updated, please update the code for reading the retired signature 
        // in repadmin in GetBestReplDsaSignatureVec().  This is an ideal
        // function for inclusion in dsutil, so we don't maintain two pieces of 
        // code.

        if ((1 == pSigVec->dwVersion)
            && (cb == ReplDsaSignatureVecV1Size(pSigVec))) {
            // Current format -- no conversion required.
            ;
        }                          
        else {
            REPL_DSA_SIGNATURE_VECTOR_OLD * pOldVec;
                                   
            pOldVec = (REPL_DSA_SIGNATURE_VECTOR_OLD *) pSigVec;

            if (cb == ReplDsaSignatureVecOldSize(pOldVec)) {
                // Old (pre Win2k RTM RC1) format.  Convert it.
                cb = ReplDsaSignatureVecV1SizeFromLen(pOldVec->cNumSignatures);

                pSigVec = (REPL_DSA_SIGNATURE_VECTOR *) THAllocEx(pTHS, cb);
                pSigVec->dwVersion = 1;
                pSigVec->V1.cNumSignatures = pOldVec->cNumSignatures;

                for (i = 0; i < pOldVec->cNumSignatures; i++) {
                    pSigVec->V1.rgSignature[i].uuidDsaSignature
                        = pOldVec->rgSignature[i].uuidDsaSignature;
                    pSigVec->V1.rgSignature[i].timeRetired
                        = pOldVec->rgSignature[i].timeRetired;
                    Assert(0 == pSigVec->V1.rgSignature[i].usnRetired);
                }

                THFreeEx(pTHS, pOldVec);
            }
            else {
                Assert(!"Unknown retired DSA signature vector format!");
                LogUnhandledError(0);
                DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
            }
        }

#if DBG
        // Make sure the the current invocation id was not retired
        {
            USN usnCurrent = DBGetHighestCommittedUSN();
            GUID invocationId = {0};

            // There are race conditions where this thread pTHS->InvocationId is
            // not coherent with the database. Read from database.
            Assert(!DBGetSingleValue(pDB, ATT_INVOCATION_ID, &invocationId,
                                     sizeof(invocationId), NULL));
            Assert(pSigVec);
            Assert(1 == pSigVec->dwVersion);
            Assert(pSigVec->V1.cNumSignatures);
            Assert(cb == ReplDsaSignatureVecV1Size(pSigVec));

            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                Assert(0 != memcmp(&invocationId,
                                   &pEntry->uuidDsaSignature,
                                   sizeof(UUID)));
                Assert(usnCurrent >= pEntry->usnRetired);
            }
        }
#endif
    }

    if (pSigVec) {
        DPRINT3( 1, "DraReadRetiredSignatureVector: ver=%d, cNum=%d, pSigVec=%p\n",
                 pSigVec->dwVersion, pSigVec->V1.cNumSignatures, pSigVec );
    } else {
        DPRINT( 1, "DraReadRetiredSignatureVector: (null)\n" );
    }

    return pSigVec;
}


BOOL
DraIsInvocationIdOurs(
    IN THSTATE *pTHS,
    IN UUID *pUuidDsaOriginating,
    IN USN *pusnSince OPTIONAL
    )

/*++

Routine Description:

Checks if the given invocation id matches or current invocation id, or
one of our retired invocation ids.

If the pusnSince argument is given, it is used to control which retired invocation
ids are candidates for matching.  For example, if the usn from system start is used,
then only invocation ids that are retired since system start may be considered.

Arguments:

    pTHS
    pUuidDsaOriginating
    pusnSince

Return Value:

    None

--*/

{
    REPL_DSA_SIGNATURE_VECTOR * pSigVec = gAnchor.pSigVec;
    DWORD i;

    if (0 == memcmp(pUuidDsaOriginating, &pTHS->InvocationID, sizeof(UUID))) {
        return TRUE;
    }

    // See if change was originated by a prior instance of ourselves
    if (pSigVec) {
        REPL_DSA_SIGNATURE_V1 *pEntry;
        Assert( (1 == pSigVec->dwVersion) );

        for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
            pEntry = &pSigVec->V1.rgSignature[i];
            if ( pusnSince && (pEntry->usnRetired < *pusnSince) ) {
                continue;
            }
            if (0 == memcmp(&pEntry->uuidDsaSignature, pUuidDsaOriginating, sizeof(UUID))) {
                return TRUE;
            }
        }
    }

    return FALSE;
}



REPL_NC_SIGNATURE_VECTOR *
draReadRetiredNcSignatureVector(
    IN  THSTATE *   pTHS,
    IN  DBPOS *     pDB
    )
/*++

Routine Description:

    Reads the retiredReplNcSignatures attribute from the local ntdsDsa object,
    converting it into the most current structure format if necessary.

Arguments:

    pTHS (IN)

    pDB (IN) - Must be positioned on local ntdsDsa object.

Return Values:

    The current retired NC signature list, or NULL if none.
    The list is allocated in thread allocated memory.

    Throws DRA exception on catastrophic failures.

--*/
{
    REPL_NC_SIGNATURE_VECTOR * pSigVec = NULL;
    DWORD                       cb;
    DWORD                       i;
    DWORD                       err;

    // Should be positioned on our own ntdsDsa object.
    Assert(NameMatched(GetExtDSName(pDB), gAnchor.pDSADN));

    err = DBGetAttVal(pDB, 1, ATT_MS_DS_RETIRED_REPL_NC_SIGNATURES,
                      0, 0, &cb, (BYTE **) &pSigVec);

    if (DB_ERR_NO_VALUE == err) {
        // No signatures retired yet.
        pSigVec = NULL;
    }
    else if (err) {
        // Read failed.
        Assert(!"Unable to read the retired NC Signatures");
        LogUnhandledError(err);
        DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
    }
    else {
        Assert(pSigVec);

        if ((1 != pSigVec->dwVersion)
            || (cb != ReplNcSignatureVecV1Size(pSigVec))) {
            Assert(!"Unknown retired DSA signature vector format!");
            LogUnhandledError(0);
            DRA_EXCEPT(ERROR_DS_DRA_DB_ERROR, err);
        }
    }

#if DBG
    if (pSigVec) {

	    // The invocation id generation should match between the SigVec and the DSA
	    // There are race conditions where this thread pTHS->InvocationId is
	    // not coherent with the database. Read from database.
	    GUID invocationId = {0};

	    DPRINT3( 1, "draReadRetiredNcSignatureVector: ver=%d, cNum=%d, pSigVec=%p\n",
                 pSigVec->dwVersion, pSigVec->V1.cNumSignatures, pSigVec );

	    if (!DBGetSingleValue(pDB, ATT_INVOCATION_ID, &invocationId,
				     sizeof(invocationId), NULL)) {
		Assert( 0 == memcmp( &(pSigVec->V1.uuidInvocationId), &invocationId, sizeof( GUID ) ) );	
	    }
    } else {
        DPRINT( 1, "draReadRetiredNCSignatureVector: (null)\n" );
    }
#endif

    return pSigVec;
}


REPL_NC_SIGNATURE *
draFindRetiredNcSignature(
    IN  THSTATE *pTHS,
    IN  DSNAME *pNC
    )

/*++

Routine Description:

    Find and return a matching NC signature if there is one.

    Uses its own DBPOS and does not change currency.

Arguments:

    pTHS - Thread state
    pNC - Naming context to be searched. Must contain a guid.

Return Value:

    REPL_NC_SIGNATURE * - Signature entry for naming context, or
        NULL if not found

    Signature entry is part of a larger thread allocated block and cannot not
    be freed by caller.  The signature vector is leaked here, but it is in thread
    allocated memory so it will be freed soon.

    Exceptions raised on error

--*/

{
    ULONG     ret;
    DBPOS *   pDBTmp;
    REPL_NC_SIGNATURE_VECTOR * pSigVec = NULL;
    REPL_NC_SIGNATURE *pEntry, *pFound = NULL;
    DWORD i;

    if (fNullUuid(&(pNC->Guid))) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    DBOpen(&pDBTmp);
    __try {

        ret = DBFindDSName(pDBTmp, gAnchor.pDSADN);
        if (ret) {
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }

        pSigVec = draReadRetiredNcSignatureVector( pTHS, pDBTmp );
        if (NULL == pSigVec) {
            __leave;
        }

        for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
            pEntry = &pSigVec->V1.rgSignature[i];
            if (0 == memcmp(&pEntry->uuidNamingContext,
                            &pNC->Guid,
                            sizeof(UUID))) {
                pFound = pEntry;
                break;
            }
        }

    } __finally {
        DBClose(pDBTmp, TRUE);
    }

    return pFound;
}



VOID
DraRetireWriteableNc(
    IN  THSTATE *pTHS,
    IN  DSNAME *pNC
    )

/*++

Routine Description:

    Add a naming context to the retired nc signature list. A retired signature indicates
    that a naming context has been unhosted from this dsa in the past. The retired signature
    is retained when the nc is rehosted in the future.

    See the discussion in DraHostWriteableNc as to why we keep this list.

    The whole signature list is removed when the invocation id changes. See InitInvocationId.

Arguments:

    pTHS - thread state
    pNC - Naming context to retire

Return Value:

    None

--*/

{
    ULONG     ret;
    DBPOS *   pDBTmp;
    REPL_NC_SIGNATURE_VECTOR * pSigVec = NULL;
    REPL_NC_SIGNATURE *pEntry;
    DWORD i, cb;
    BOOL fCommit = FALSE;
    DSTIME dstimeNow = DBTime();
    CHAR szUuid1[SZUUID_LEN];
    USN usn;

    if (fNullUuid(&(pNC->Guid))) {
        DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    DPRINT2( 1, "Retiring NC %ws (%s)\n",
             pNC->StringName,
             DsUuidToStructuredString(&(pNC->Guid), szUuid1) );

/* Shouldn't this DBGetHighestCommittedUSN be retrieved before the transaction
is started?  [Will] It doesn't matter in this case. The usn is not
used for anything at this point. My thinking is that it would be useful to
save a usn for which we guarantee is larger than all the usn's in use in the
nc that just got retired. Since we are not using the usn inside this
transaction for any kind of comparsion or search, I don't think it really
matters whether the usn is taken before the transaction or during the
transaction. Anywhere inside this routine will be fine, since it is after the
nc head removal which just occurred before calling this function. */

    usn = DBGetHighestCommittedUSN();

    DBOpen(&pDBTmp);
    __try {

        ret = DBFindDSName(pDBTmp, gAnchor.pDSADN);
        if (ret) {
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }

        // Read the vector. May return NULL if does not exist yet.
        pSigVec = draReadRetiredNcSignatureVector( pTHS, pDBTmp );
        if (NULL == pSigVec) {
            // No signatures retired yet; synthesize a new vector.
            cb = ReplNcSignatureVecV1SizeFromLen(1);
            pSigVec = (REPL_NC_SIGNATURE_VECTOR *) THAllocEx(pTHS, cb);
            pSigVec->dwVersion = 1;
            pSigVec->V1.cNumSignatures = 1;
            memcpy( &(pSigVec->V1.uuidInvocationId), &(pTHS->InvocationID), sizeof( GUID ) );
        } else {
#if DBG
	    // The invocation id generation should match between the SigVec and the DSA
	    // There are race conditions where this thread pTHS->InvocationId is
	    // not coherent with the database. Read from database.
	    GUID invocationId = {0};
	    if (!DBGetSingleValue(pDBTmp, ATT_INVOCATION_ID, &invocationId,
				     sizeof(invocationId), NULL)) {
		Assert( 0 == memcmp( &(pSigVec->V1.uuidInvocationId), &invocationId, sizeof( GUID ) ) );	
	    }

            for (i = 0; i < pSigVec->V1.cNumSignatures; i++) {
                pEntry = &pSigVec->V1.rgSignature[i];
                Assert (0 != memcmp(&pEntry->uuidNamingContext,
                                    &pNC->Guid,
                                    sizeof(UUID)));
                Assert( usn >= pEntry->usnRetired );
            }
#endif
            pSigVec->V1.cNumSignatures++;
            cb = ReplNcSignatureVecV1Size(pSigVec);
            pSigVec = (REPL_NC_SIGNATURE_VECTOR *) THReAllocEx(pTHS, pSigVec, cb);
        }

        pEntry = &(pSigVec->V1.rgSignature[pSigVec->V1.cNumSignatures-1]);

        // Initialize the new entry
        memcpy( &(pEntry->uuidNamingContext), &(pNC->Guid), sizeof( GUID ) );
        pEntry->dstimeRetired = dstimeNow;
        pEntry->usnRetired = usn;

        // Write the new DSA signature vector back to the DSA object.
        DBResetAtt(pDBTmp, ATT_MS_DS_RETIRED_REPL_NC_SIGNATURES, cb, pSigVec,
                   SYNTAX_OCTET_STRING_TYPE);

        // It's not replicated, so do a simple update
        DBUpdateRec(pDBTmp);

        fCommit = TRUE;

    } __finally {
        DBClose(pDBTmp, fCommit);
        if (pSigVec) {
            THFreeEx( pTHS, pSigVec );
        }
    }
}


VOID
DraHostWriteableNc(
    THSTATE *pTHS,
    DSNAME *pNC
    )

/*++

Routine Description:

Perform actions on hosting a writeable naming context.

Only NDNCs fit this description today.

The rule is that we must change our invocation id if
1. We have held this NDNC before
2. Our invocation id has not changed since we held it last

    The whole signature list is removed when the invocation id changes. See InitInvocationId.

Jeffparh provides the following background:

// We are constructing this writeable NC via replication from
// scratch.  Either the NC has never been instantiated on this
// DSA or, if we did previously have a replica of this NC, we
// have since removed it.
//
// If we did previously have a writeable replica of this NC,
// we no longer have any of the updates we originated in the NC.
// Thus, we cannot claim to be "up to date" with respect to our
// invocation ID up to any USN.  While we can (and do) leave out
// our invocation ID from the UTD vector we present while
// re-populating this NC, that is not enough -- we may have
// generated changes that reached DC1 but not DC2 (yet), and
// have replicated from DC2 to reinstantiate our NC.  Thus, we
// could never assert we had seen all of our past changes.
//
// At some point, however, we *must* claim to be up-to-date with
// respect to our own changes -- otherwise, we would replicate
// back in any and all changes we originated in this NC
// following it's most recent re-instantiation.  That would
// potentially result in a *lot* of extra replication traffic.
//
// To solve this problem, we create a new invocation ID to use
// to replicate this NC (and others, since invocation IDs are
// not NC-specific).  We claim only to be up-to-date with
// respect to our new invocation ID -- not the invocation ID(s)
// with which we may have originated changes during the previous
// instantiation(s) of this NC.
//
// We perform the retirement here rather than, say, when we
// request the first packet so that we minimize the number of
// invocation IDs we retire.  E.g., we wouldn't want to retire
// an invcocation ID, send a request for the first packet, find
// the source is unreachable, fail, try again later, needlessly
// retire the new invcocation ID, etc.

Arguments:

    pTHS - thread state
    pNC - DSNAME of partition being hosted

Return Value:

    None

--*/

{
    REPL_NC_SIGNATURE *pSig;
    CHAR szUuid1[SZUUID_LEN], szUuid2[SZUUID_LEN];

    pSig = draFindRetiredNcSignature( pTHS, pNC );
    if (!pSig) {
        // Never hosted before, no action necessary
        DPRINT1( 0, "Nc %ws never hosted before, invocation id not changed.\n",
                 pNC->StringName );
        return;
    }

    draRetireInvocationID(pTHS, FALSE, NULL, NULL);
}

/* end drasig.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\draupdrr.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draupdrr.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAUPDRR:" /* define the subsystem for debugging */




// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drameta.h"

#include <fileno.h>
#define  FILENO FILENO_DRAUPDRR

DWORD AddDSARefToAtt(DBPOS *pDB, REPLICA_LINK *pRepsToRef)
//
// Note: This routine may fail to set 'fReplNotify' on the
// NAMING_CONTEXT_LIST entry if the NC List is not up-to-date.
//
{
    BOOL            fFound = FALSE;
    ATTCACHE *      pAC;
    DWORD           iExistingRef = 0;
    DWORD           cbExistingAlloced = 0;
    DWORD           cbExistingRet;
    REPLICA_LINK *  pExistingRef;
    BOOL            fRefHasUuid;
    DWORD           err;
    NAMING_CONTEXT_LIST *pncl;
    DWORD           ncdnt;

    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    //
    // PREFIX: PREFIX complains that pAC hasn't been checked to
    // make sure that it is not NULL.  This is not a bug.  Since
    // a predefined constant was passed to SCGetAttById, pAC will
    // never be NULL.
    //
    
    Assert(NULL != pAC);

    VALIDATE_REPLICA_LINK_VERSION(pRepsToRef);

    fRefHasUuid = !fNullUuid(&pRepsToRef->V1.uuidDsaObj);

    while (!DBGetAttVal_AC(pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        // If either the network addresses or UUIDs match...
        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsToRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsToRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fRefHasUuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsToRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) ) )
        {
            // Reference already exists!
            return DRAERR_RefAlreadyExists;
        }
    }

    err = DBAddAttVal_AC(pDB, pAC, pRepsToRef->V1.cb, pRepsToRef);

    switch (err) {
      case DB_success:
        err = DBGetSingleValue(pDB,
                               FIXED_ATT_DNT,
                               &ncdnt,
                               sizeof(ncdnt),
                               NULL);
        Assert(err == DB_success);

        // NC List is not always consistent with DIT so this might fail
        pncl = FindNCLFromNCDNT(ncdnt, FALSE);
        if( NULL!=pncl ) {
            pncl->fReplNotify = TRUE;
        } else {
            // Couldn't set the notify flag. Ignore this problem for now
            // and it will be repaired later, once the NC List is updated.
        }
        break;
        
      case DB_ERR_VALUE_EXISTS:
        err = DRAERR_RefAlreadyExists;
        break;

      default:
        RAISE_DRAERR_INCONSISTENT( err );
    }
    return err;
}

DWORD DelDSARefToAtt(DBPOS *pDB, REPLICA_LINK *pRepsToRef)
{
    BOOL            fFound = FALSE;
    ATTCACHE *      pAC;
    DWORD           iExistingRef = 0;
    DWORD           cbExistingAlloced = 0;
    DWORD           cbExistingRet;
    REPLICA_LINK *  pExistingRef;
    BOOL            fRefHasUuid;
    ULONG           err;
    NAMING_CONTEXT_LIST *pncl;
    DWORD           ncdnt;

    pAC = SCGetAttById(pDB->pTHS, ATT_REPS_TO);
    //
    // PREFIX: PREFIX complains that pAC hasn't been checked to
    // make sure that it is not NULL.  This is not a bug.  Since
    // a predefined constant was passed to SCGetAttById, pAC will
    // never be NULL.
    //

    Assert(NULL != pAC);

    VALIDATE_REPLICA_LINK_VERSION(pRepsToRef);

    fRefHasUuid = !fNullUuid(&pRepsToRef->V1.uuidDsaObj);

    while (!DBGetAttVal_AC(pDB, ++iExistingRef, pAC, DBGETATTVAL_fREALLOC,
                           cbExistingAlloced, &cbExistingRet,
                           (BYTE **) &pExistingRef) )
    {
        cbExistingAlloced = max(cbExistingAlloced, cbExistingRet);

        VALIDATE_REPLICA_LINK_VERSION(pExistingRef);

        // If either the network addresses or UUIDs match...
        if (    (    (    RL_POTHERDRA(pExistingRef)->mtx_namelen
                       == RL_POTHERDRA(pRepsToRef)->mtx_namelen )
                  && !_memicmp( RL_POTHERDRA(pExistingRef)->mtx_name,
                                RL_POTHERDRA(pRepsToRef)->mtx_name,
                                RL_POTHERDRA(pExistingRef)->mtx_namelen ) )
             || (    fRefHasUuid
                  && !memcmp( &pExistingRef->V1.uuidDsaObj,
                              &pRepsToRef->V1.uuidDsaObj,
                              sizeof(UUID ) ) ) )
        {
            // Found matching Reps-To; remove it.
            fFound = TRUE;

            err = DBRemAttVal_AC(pDB, pAC, cbExistingRet, pExistingRef);

            if (err)
            {
                // Attribute removal failed!
                DRA_EXCEPT(DRAERR_DBError, err);
            }
        }
    }

    if (   (iExistingRef == 1)
        && fFound
        && DBHasValues(pDB, ATT_REPS_TO)) {
        
        err = DBGetSingleValue(pDB,
                               FIXED_ATT_DNT,
                               &ncdnt,
                               sizeof(ncdnt),
                               NULL);
        pncl = FindNCLFromNCDNT(ncdnt, FALSE);
        pncl->fReplNotify = FALSE;
    }

    return fFound ? 0 : DRAERR_RefNotFound;
}

ULONG UpdateRefsHelper(
    THSTATE *pTHS,
    DSNAME *pNC,
    MTX_ADDR *pDSAMtx_addr,
    UUID * puuidDSA,
    ULONG ulOptions,
    ULONG cConsecutiveFailures,
    DSTIME timeLastSuccess,
    DSTIME timeLastAttempt,
    ULONG ulResultThisAttempt
    )
//
// Do the actual work of updating a repsTo.
//  - Find the NC that this repsTo lives in
//  - Build a REPLICA_LINK object
//  - Delete the existing matching REPLICA_LINK (optional)
//  - Add the REPLICA_LINK (optional)
//
// Note that this function does not use a transaction; callers must open a
// transaction themselves.
//
{
    DWORD ret = 0;
    REPLICA_LINK *pRepsToRef;
    ULONG cbRepsToRef;

    // We must have a valid thread state, valid dbpos, and a transaction is open
    Assert(pTHS->JetCache.transLevel > 0);
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));

    // Log parameters
    LogEvent(DS_EVENT_CAT_REPLICATION,
                        DS_EVENT_SEV_EXTENSIVE,
                        DIRLOG_DRA_UPDATEREFS_ENTRY,
                        szInsertWC(pNC->StringName),
                        szInsertSz(pDSAMtx_addr->mtx_name),
                        szInsertHex(ulOptions));

    if (!(ulOptions & (DRS_ADD_REF | DRS_DEL_REF))) {
        return DRAERR_InvalidParameter;
    }

    // Find the NC.  The setting of DRS_WRIT_REP reflects writeability of
    // the destination's NC. The source's NC writeability should be
    // compatible for sourcing the destination NC.
    //

    if (FindNC(pTHS->pDB,
               pNC,
               ((ulOptions & DRS_WRIT_REP)
                ? FIND_MASTER_NC
                : FIND_MASTER_NC | FIND_REPLICA_NC),
               NULL)) {
        return DRAERR_BadNC;
    }

    cbRepsToRef = (sizeof(REPLICA_LINK) + MTX_TSIZE(pDSAMtx_addr));
    pRepsToRef = (REPLICA_LINK*)THAllocEx(pTHS, cbRepsToRef);

    pRepsToRef->dwVersion           = VERSION_V1;
    pRepsToRef->V1.cb               = cbRepsToRef;
    pRepsToRef->V1.ulReplicaFlags   = ulOptions & DRS_WRIT_REP;
    pRepsToRef->V1.cbOtherDraOffset = (DWORD)(pRepsToRef->V1.rgb - (char *)pRepsToRef);
    pRepsToRef->V1.cbOtherDra       = MTX_TSIZE(pDSAMtx_addr);

    pRepsToRef->V1.cConsecutiveFailures = cConsecutiveFailures;
    pRepsToRef->V1.timeLastSuccess      = timeLastSuccess;
    pRepsToRef->V1.timeLastAttempt      = timeLastAttempt,
    pRepsToRef->V1.ulResultLastAttempt      = ulResultThisAttempt;
    
    if (puuidDSA) {
        pRepsToRef->V1.uuidDsaObj = *puuidDSA;
    }

    memcpy(RL_POTHERDRA(pRepsToRef), pDSAMtx_addr, MTX_TSIZE(pDSAMtx_addr));

    if (ulOptions & DRS_DEL_REF) {
        ret = DelDSARefToAtt (pTHS->pDB, pRepsToRef);
        // If we are doing a DEL and an ADD, the return value is lost by design.
    }

    if (ulOptions & DRS_ADD_REF) {
        ret = AddDSARefToAtt (pTHS->pDB, pRepsToRef);
    }

    if (!ret) {
        DBRepl(pTHS->pDB, pTHS->fDRA, 0, NULL, META_STANDARD_PROCESSING);
    }

    // DelDSARefToAtt can return RefNotFound.  If this is returned, it will be logged
    // by draasync.c:DispatchPao.  When this routine is called by GetNCChanges for a
    // reps-to verification (DRS_GETCHG_CHECK), we can ignore these errors.
    if ( (ulOptions & DRS_GETCHG_CHECK) &&
         ( (ret == DRAERR_RefNotFound) ||
           (ret == DRAERR_RefAlreadyExists) ) ) {
        ret = ERROR_SUCCESS;
    }

    return ret;
}

ULONG DRA_UpdateRefs(
    THSTATE *pTHS,
    DSNAME *pNC,
    MTX_ADDR *pDSAMtx_addr,
    UUID * puuidDSA,
    ULONG ulOptions)
{
    DWORD ret = 0;

    BeginDraTransaction(SYNC_WRITE);

    __try {
    
        ret = UpdateRefsHelper(
            pTHS,
            pNC,
            pDSAMtx_addr,
            puuidDSA,
            ulOptions,
            0,              // Count of consecutive failures
            0,              // Time of last success
            0,              // Time of last attempt
            0               // Result of last attempt
            );

    } __finally {

        // If we had success, commit, else rollback
        if (EndDraTransaction(!(ret || AbnormalTermination()))) {
            Assert( !"EndTransaction failed" );
            ret = DRAERR_InternalError;
        }
        
    }
    
    return ret;    
}

ULONG
UpdateRepsTo(
    THSTATE *               pTHS,
    DSNAME *                pNC,
    UUID *                  puuidDSA,
    MTX_ADDR                *pDSAMtx_addr,
    ULONG                   ulResultThisAttempt
    )
//
// Add or update a Reps-To attribute value with the given state information.
//
// This function assumes that the Reps-To value already exists. If it does not,
// DRAERR_NoReplica will be returned.
//
// A change to the reps-to is limited to an update period to reduce nc head contention.
//
{
    // Necessary local variables
    ULONG                   ret = 0;
    BOOL                    AttExists;
    ULONG                   len;
    REPLICA_LINK *          pRepsTo = NULL;
    DWORD                   cConsecutiveFailures;
    DSTIME                  timeLastAttempt;
    DSTIME                  timeLastSuccess;

    Assert( NULL==pTHS->pDB );
    DBOpen(&pTHS->pDB);

    __try {

        // Verify that the NC exists
        if (DBFindDSName(pTHS->pDB, pNC)) {
            return DRAERR_BadNC;
        }

        // Try to find this name in the repsTo attribute.
        // BUGBUG: PERF: Since repsTos are stored as binary blobs, they cannot
        // be found efficiently. The notification code sends a notify for each repsTo
        // and then calls this function to update it. Since FindDSAinRepAtt() does a
        // linear search, we will end up doing O( |RepsTos|^2 ) work.
        if ( !FindDSAinRepAtt( pTHS->pDB,
                               ATT_REPS_TO,
                               DRS_FIND_DSA_BY_UUID,
                               puuidDSA,
                               NULL,
                               &AttExists,
                               &pRepsTo,
                               &len ) )
        {
            // Existing att val for this DSA found
            VALIDATE_REPLICA_LINK_VERSION(pRepsTo);
            VALIDATE_REPLICA_LINK_SIZE(pRepsTo);
        } else {
            ret = DRAERR_NoReplica;
            __leave;
        }

        timeLastAttempt = DBTime();

        if (timeLastAttempt > pRepsTo->V1.timeLastAttempt) {
            DSTIME timeSinceLastAttempt =
                (timeLastAttempt - pRepsTo->V1.timeLastAttempt);
            if (timeSinceLastAttempt < DRA_REPSTO_UPDATE_PERIOD) {
                __leave;
            }
        }

        if( ERROR_SUCCESS==ulResultThisAttempt ) {
            // This attempt was successful.
            timeLastSuccess = timeLastAttempt;

            // No failures.
            cConsecutiveFailures = 0;
        } else {
            // We did not successfully notify the remote machine.
            
            // timeLastSuccess is not updated.
            timeLastSuccess = pRepsTo->V1.timeLastSuccess;

            // Consecutive failure count is incremented.
            cConsecutiveFailures = pRepsTo->V1.cConsecutiveFailures+1;
        }

        ret = UpdateRefsHelper(
            pTHS,
            pNC,
            pDSAMtx_addr,
            puuidDSA,
            (pRepsTo->V1.ulReplicaFlags | DRS_ADD_REF | DRS_DEL_REF),
            cConsecutiveFailures,
            timeLastSuccess,
            timeLastAttempt,
            ulResultThisAttempt
            );

    } __finally {

        // If we had success, commit, else rollback
        if (DBClose(pTHS->pDB, !(ret || AbnormalTermination()))) {
            Assert( !"DBClose failed" );
            ret = DRAERR_InternalError;
        }
        
    }
    
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drauptod.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000
//
//  File:       drauptod.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Manages the per-NC up-to-date vectors, which record the highest originating
    writes we've seen from a set of DSAs.  This vector, in turn, is used in
    GetNCChanges() calls to filter out redundant property changes before they
    hit the wire.

DETAILS:

CREATED:

    08/01/96    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"

#include "debug.h"                      /* standard debugging header */
#define DEBSUB     "DRAUPTOD:"          /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "dsexcept.h"
#include "usn.h"
#include "drauptod.h"
#include "drameta.h"   // META_STANDARD_PROCESSING

// Other headers
#include <dsutil.h>

#include <fileno.h>
#define  FILENO FILENO_DRAUPTOD

#ifndef MIN
#define MIN(a,b)    ( ( (a) < (b) ) ? (a) : (b) )
#endif

VOID l_VectorGrow(THSTATE *pTHS,
                     UPTODATE_VECTOR **,
                     DWORD );

VOID
l_CursorImprove(
    IN  DBPOS *                   pDB,
    IN  BOOL                      fReplace,
    IN  UPTODATE_CURSOR_NATIVE *  puptodcur,
    OUT UPTODATE_VECTOR **        pputodvec
    );

VOID
l_Write(
    IN  DBPOS *             pDB,
    IN  UPTODATE_VECTOR *   putodvec
    );

BOOL    l_CursorFind(       UPTODATE_VECTOR *, UUID *, DWORD * );
VOID    l_CursorInsert(THSTATE *pTHS,
                       UPTODATE_VECTOR **,
                       UPTODATE_CURSOR_NATIVE *);
VOID    l_CursorRemove(THSTATE *pTHS,
                       UPTODATE_VECTOR **pputodvec,
                       UUID *pUuid);


#if DBG
BOOL gfCheckForInvalidUSNs = TRUE;
#define IS_VALID_USN(x) (!gfCheckForInvalidUSNs || ((x) < 1024*1024*1024))

void
UpToDateVec_Validate(
    IN  UPTODATE_VECTOR * pvec
    )
{
    DWORD i;

    if (NULL != pvec) {
        Assert(IS_VALID_UPTODATE_VECTOR(pvec));
        if (UPTODATE_VECTOR_NATIVE_VERSION == pvec->dwVersion) {
            UPTODATE_VECTOR_NATIVE * pNativeUTD = &pvec->V2;

            for (i = 0; i < pNativeUTD->cNumCursors; i++) {
                if (!IS_VALID_USN(pNativeUTD->rgCursors[i].usnHighPropUpdate)) {
                    CHAR szMessage[512];
    
                    sprintf(szMessage,
                            "Cursor %d of UTDVEC @ %p has an invalid USN!"
                            "  Please notify JeffParh.\n", i, pvec);
                    OutputDebugString(szMessage);
    
                    DRA_EXCEPT(DRAERR_InternalError, 0);
                }
            }
        }
    }
}


void
UsnVec_Validate(
    IN  USN_VECTOR * pusnvec
    )
{
    if (NULL != pusnvec) {
        if (!IS_VALID_USN(pusnvec->usnHighObjUpdate)
            || !IS_VALID_USN(pusnvec->usnHighPropUpdate)) {
            CHAR szMessage[512];

            sprintf(szMessage,
                    "USNVEC @ %p has an invalid USN!"
                    "  Please notify JeffParh.\n", pusnvec);
            OutputDebugString(szMessage);

            DRA_EXCEPT(DRAERR_InternalError, 0);
        }
    }
}


BOOL
l_PositionedOnNC(IN DBPOS *pDB)
{
    SYNTAX_INTEGER it;
    
    return !DBGetSingleValue(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it), NULL)
           && FPrefixIt(it);
}

#endif


VOID
UpToDateVec_Read(
    IN  DBPOS *             pDB,
    IN  SYNTAX_INTEGER      InstanceType,
    IN  DWORD               dwFlags,
    IN  USN                 usnLocalDsa,
    OUT UPTODATE_VECTOR **  pputodvec
    )
//
//  Read the local up-to-date vector associated with the given NC, and
//  optionally add a cursor for the local DSA to show that we're up-to-date
//  with respect to ourselves.
//
//  Caller is repsonsible for freeing the allocated vector if
//  NULL != *pputodvec with THFree().
//
{
    THSTATE *pTHS = pDB->pTHS;
    DWORD cbUpToDateVecDest;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    Assert(!(IT_UNINSTANT & InstanceType));
    Assert(!(IT_NC_GOING & InstanceType));

    if (IT_NC_COMING & InstanceType) {
        // We can't really claim to be up-to-date with respect to any DSA's
        // changes (even our own, if we perhaps generated changes in the NC,
        // the NC was removed, and now it's being added back again).
        // Note that inbound replication depends on this behavior. It will not clear
        // the inbound nc's coming bit until the source returns a non-null UTDVEC.
        Assert(!DBHasValues(pDB, ATT_REPL_UPTODATE_VECTOR));
        
        *pputodvec = NULL;
    } else {
        if (DBGetAttVal(pDB,
                        1,
                        ATT_REPL_UPTODATE_VECTOR,
                        0,
                        0,
                        &cbUpToDateVecDest,
                        (BYTE **) pputodvec)) {
            // couldn't retrieve current uptodate vector; default to no filter
            *pputodvec = NULL;
        }
    
        Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(*pputodvec));

        // Validate up-to-dateness vector read from DS
        if( NULL!=*pputodvec ) {
            Assert( UpToDateVec_ValidateExternal(*pputodvec,cbUpToDateVecDest) );
        }

        if ((NULL != *pputodvec)
            && (UPTODATE_VECTOR_NATIVE_VERSION != (*pputodvec)->dwVersion)) {
            // Convert to native version.
            UPTODATE_VECTOR * pUTDTmp;

            pUTDTmp = UpToDateVec_Convert(pTHS,
                                          UPTODATE_VECTOR_NATIVE_VERSION,
                                          *pputodvec);
            THFreeEx(pTHS, *pputodvec);
            *pputodvec = pUTDTmp;
        }
    
        if ((UTODVEC_fUpdateLocalCursor & dwFlags)
            && !fNullUuid(&pTHS->InvocationID)) {
            UPTODATE_CURSOR_NATIVE cursorLocal;
    
            // update the cursor corresponding to the local DSA to indicate
            // we've seen all our own changes up 'til now
    
            cursorLocal.uuidDsa             = pTHS->InvocationID;
            cursorLocal.usnHighPropUpdate   = usnLocalDsa;
            cursorLocal.timeLastSyncSuccess = GetSecondsSince1601();
    
            l_CursorImprove(pDB, FALSE, &cursorLocal, pputodvec);
            UpToDateVec_Validate(*pputodvec);
        }
    }
    
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
}


VOID
UpToDateVec_Improve(
    IN      DBPOS *             pDB,
    IN      UPTODATE_VECTOR *   putodvecRemote
    )
//
//  Given the replication state and up-to-date vector from a remote DSA
//  and the NC to which it corresponds, improve the local up-to-date
//  vector to show that we've seen all the originating writes seen by
//  the remote DSA.
//
//  The UTD vector came from the source machine, where it was build using
//  UpToDateVec_Read using the LocalCursor option.  This UTD contains a cursor
//  for the source DSA (describing itself) formulated using the highest
//  committed USN at the start of the GetNC transaction (see dragtchg.c).
//
//  Note that the cursor for the remote DSA is improved during step 1 and
//  step 2 below.
//
// [Jeff Parham]  The only time we improve the UTD is when we have successfully
// finished a complete replication cycle -- i.e., no more changes are available
// from the source, and all the changes we have received have been successfully
// applied.  I expect the USN in the UTD vec to be higher than the USN in the
// USN vec.  The highest committed USN is not NC-specific, so, for example,
// even when no changes are being generated in the NC the USN in the UTD vector
// will steadily crawl upwards (as changes are made to other NCs).  This is
// intended (or was intended, when I wrote this code two years ago).
//
// puptodvecRemote should already contain an entry for the source DSA.
//        Assert(l_CursorFind(putodvecRemote, puuidDsaRemote, &iCursorRemote)
//               && (pNativeRemoteUTD->rgCursors[iCursorRemote].usnHighPropUpdate
//                   >= pusnvec->usnHighPropUpdate));
//
{
    THSTATE *           pTHS = pDB->pTHS;
    UPTODATE_VECTOR *   putodvecLocal;
    DWORD               iCursorRemote;
    SYNTAX_INTEGER      it;
    UPTODATE_VECTOR_NATIVE * pNativeRemoteUTD = &putodvecRemote->V2;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));

    Assert(putodvecRemote);
    UpToDateVec_Validate(putodvecRemote);

    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
    
    UpToDateVec_Read(pDB, it, 0, 0, &putodvecLocal);
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(putodvecLocal));
    UpToDateVec_Validate(putodvecLocal);

    // merge each remote cursor into the local vector
        
    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(putodvecRemote));
        
    for ( iCursorRemote = 0; iCursorRemote < pNativeRemoteUTD->cNumCursors; iCursorRemote++ )
    {
        // don't bother maintaining a cursor for ourselves
        if ( (0 != memcmp(&pNativeRemoteUTD->rgCursors[ iCursorRemote ].uuidDsa,
                          &pTHS->InvocationID,
                          sizeof( UUID ) )) )
        {
            l_CursorImprove(pDB,
                            FALSE,
                            &pNativeRemoteUTD->rgCursors[ iCursorRemote ],
                            &putodvecLocal);
        }
    }

    UpToDateVec_Validate(putodvecLocal);

    // save the uptodate vector back to disk
    // (if we have anything to save)
    if ( NULL != putodvecLocal )
    {
        l_Write(pDB, putodvecLocal);

        THFree( putodvecLocal );
    }
}

VOID
UpToDateVec_Replace(
    IN      DBPOS *             pDB,
    IN      UUID *              pRemoteDsa,
    IN      USN_VECTOR *        pUsnVec,
    IN OUT  UPTODATE_VECTOR *   pUTD
    )
/*++

Routine Description:

    Overwrites stored UTD w/ given remote one

Arguments:
    pTHS -- Thread state
    pRemoteDsa -- The remote dsa we'll from which we incorporate the new UTD
    pUsnVec -- the usn vec we'll have for that dsa entry
    pUTD -- the UTD to apply locally

Return Value:
    None.

Remark:
    Beware-- we don't preserve pUTD and it will be modified
    in place. Only then it will get written down.
--*/
{
    THSTATE * pTHS = pDB->pTHS;
#if DBG
    UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUTD->V2;
    DWORD iCursor;
#endif

    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUTD));
    UpToDateVec_Validate(pUTD);

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    // pUTD should already contain an entry for the source DSA.
    Assert(l_CursorFind(pUTD, pRemoteDsa, &iCursor)
           && (pNativeUTD->rgCursors[iCursor].usnHighPropUpdate
               >= pUsnVec->usnHighPropUpdate));
    
    //
    // remove ourselves from remote UTD
    //
    l_CursorRemove(pTHS, &pUTD, &pTHS->InvocationID);

    //
    // commit
    //
    l_Write(pDB, pUTD);
}

BOOL
UpToDateVec_IsChangeNeeded(
    IN  UPTODATE_VECTOR *   pUpToDateVec,
    IN  UUID *              puuidDsaOrig,
    IN  USN                 usnOrig
    )
//
//  Given a DSA's up-to-date vector, determine whether that DSA has already
//  seen a specific originating write.
//
{
    BOOL                fChangeNeeded;
    DWORD               iCursor;

    UpToDateVec_Validate(pUpToDateVec);

    if (NULL == pUpToDateVec) {
        fChangeNeeded = TRUE;
    } else {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUpToDateVec->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUpToDateVec));

        if (    fNullUuid( puuidDsaOrig )
                || !l_CursorFind( pUpToDateVec, puuidDsaOrig, &iCursor ) )
        {
            // the DSA signature has not been set, or the destination DSA has no
            // cursor for the originating DSA; ship the change
            fChangeNeeded = TRUE;
        }
        else
        {
            // ship change iff the change has not yet been seen by the source
            fChangeNeeded = ( usnOrig > pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate );
        }
    }

    return fChangeNeeded;
}


VOID
l_CursorImprove(
    IN  DBPOS *                   pDB,
    IN  BOOL                      fReplace,
    IN  UPTODATE_CURSOR_NATIVE *  puptodcur,
    OUT UPTODATE_VECTOR **        pputodvec
    )
/*++

Routine Description:

  Add a cursor to the given up-to-date vector, or, if a cursor for the
  corresponding DSA already exists, improve the existing cursor.

Arguments:

    pTHS-- thread state
    pputodvec-- UTD vector to improve
    puptodcur-- the cursor to improve to
    fReplace-- if TRUE a mandatory replace, rather then conditional improve

Return Value:

    none.

--*/
{
    THSTATE * pTHS = pDB->pTHS;
    DWORD     iCursor;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    UpToDateVec_Validate(*pputodvec);

    Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(*pputodvec));

    if ( !l_CursorFind( *pputodvec, &puptodcur->uuidDsa, &iCursor ) )
    {
        // cursor for the given DSA does not exist; add it
        l_CursorInsert(pTHS, pputodvec, puptodcur );
        UpToDateVec_Validate(*pputodvec);
    }
    else
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &(*pputodvec)->V2;
        
        // cursor for given DSA exists; improve it if necessary
        if ( pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate <= puptodcur->usnHighPropUpdate ||
             fReplace ) {
            Assert(0 != memcmp(&pTHS->InvocationID, &puptodcur->uuidDsa, sizeof(UUID)));

            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_IMPROVING_UPTODATE_VECTOR,
                      szInsertUUID(&puptodcur->uuidDsa),
                      szInsertUSN(pNativeUTD->rgCursors[iCursor].usnHighPropUpdate),
                      szInsertUSN(puptodcur->usnHighPropUpdate),
                      szInsertDN(GetExtDSName(pDB)),
                      NULL, NULL, NULL, NULL);

            if (pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate
                < puptodcur->usnHighPropUpdate) {
                // New cursor has higher USN -- copy the timestamp.
                
                // Note that the cursor with the higher USN is more recent, even
                // if the timestamp is smaller (as might happen if the time on
                // the DC were temporarily set into the future and set back, for
                // example).
                pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess
                    = puptodcur->timeLastSyncSuccess;
            } else {
                // new cursor has same USN -- keep higher of the two timestamps.
                pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess
                    = max(pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess,
                          puptodcur->timeLastSyncSuccess);
            }
            
            pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate = puptodcur->usnHighPropUpdate;
            UpToDateVec_Validate(*pputodvec);
        }
    }
}

VOID
l_Write(
    IN  DBPOS *             pDB,
    IN  UPTODATE_VECTOR *   putodvec
    )
//
//  Create/modify the up-to-date vector associated with a given NC.
//
{
    ULONG   replStatus;
    DWORD   cbUpToDateVecSize;

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));
    
    UpToDateVec_Validate(putodvec);
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(putodvec));

    cbUpToDateVecSize = UpToDateVecSize(putodvec);

    // Replace the attribute. DBReset succeeds or excepts.
    DBResetAtt(pDB,
               ATT_REPL_UPTODATE_VECTOR,
               cbUpToDateVecSize,
               putodvec,
               SYNTAX_OCTET_STRING_TYPE /* ignored */ );

    // Update the object
    replStatus = DBRepl(pDB,
                        TRUE,               // fDRA
                        DBREPL_fKEEP_WAIT,  // Don't notify
                        NULL,               // pMetaDataVecRemote
                        META_STANDARD_PROCESSING);
    if (replStatus) {
        DRA_EXCEPT(DRAERR_DBError, replStatus);
    }
}


BOOL
l_CursorFind(
    UPTODATE_VECTOR *   putodvec,
    UUID *              puuidDsa,
    DWORD *             piCursor )
//
//  Determine if a cursor for the given DSA is defined in the specified
//  up-to-date vector.  If so, return its index.  If not, return the
//  index at which the cursor should be inserted into the vector to
//  maintain proper sort order.
//
{
    BOOL                fFound;
    LONG                iCursorBegin;
    LONG                iCursorEnd;
    LONG                iCursorCurrent;
    RPC_STATUS          rpcStatus;
    int                 nDiff;

    UpToDateVec_Validate(putodvec);

    fFound = FALSE;
    iCursorCurrent = 0;

    if ( NULL != putodvec )
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &putodvec->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(putodvec));

        iCursorBegin = 0;
        iCursorEnd   = pNativeUTD->cNumCursors - 1;

        // find DSA up-to-date cursor corresponding to the given DSA
        while ( !fFound && ( iCursorEnd >= iCursorBegin ) )
        {
            iCursorCurrent = ( iCursorBegin + iCursorEnd ) / 2;

            nDiff = UuidCompare( puuidDsa,
                                 &pNativeUTD->rgCursors[ iCursorCurrent ].uuidDsa,
                                 &rpcStatus );
            Assert( RPC_S_OK == rpcStatus );

            if ( nDiff < 0 )
            {
                if ( iCursorEnd != iCursorBegin )
                {
                    // further narrow search
                    iCursorEnd = iCursorCurrent - 1;
                }
                else
                {
                    // cursor not found; it should be inserted before this cursor
                    break;
                }
            }
            else if ( nDiff > 0 )
            {
                if ( iCursorEnd != iCursorBegin )
                {
                    // further narrow search
                    iCursorBegin = iCursorCurrent + 1;
                }
                else
                {
                    // cursor not found; it should be inserted after this cursor
                    iCursorCurrent++;
                    break;
                }
            }
            else
            {
                // found it
                fFound = TRUE;
            }
        }
    }

    *piCursor = iCursorCurrent;

    return fFound;
}


VOID
l_CursorInsert(
    THSTATE *                 pTHS,
    UPTODATE_VECTOR **        pputodvec,
    UPTODATE_CURSOR_NATIVE *  puptodcur
    )
//
//  Insert a new cursor into the given up-to-date vector.
//
{
    BOOL                      fFound;
    DWORD                     iCursor;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;

    UpToDateVec_Validate(*pputodvec);

    l_VectorGrow(pTHS, pputodvec, 1 );

    fFound = l_CursorFind( *pputodvec, &puptodcur->uuidDsa, &iCursor );
    if ( fFound )
    {
        DRA_EXCEPT( DRAERR_InternalError, iCursor );
    }


    // insert new cursor at iCursor
    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
    pNativeUTD = &(*pputodvec)->V2;
    
    MoveMemory( &pNativeUTD->rgCursors[ iCursor+1 ],
                &pNativeUTD->rgCursors[ iCursor   ],
                (   sizeof( UPTODATE_CURSOR_NATIVE )
                  * ( pNativeUTD->cNumCursors - iCursor ) ) );

    pNativeUTD->rgCursors[ iCursor ] = *puptodcur;
    pNativeUTD->cNumCursors++;

    UpToDateVec_Validate(*pputodvec);
}

VOID
l_CursorRemove(
    THSTATE         *   pTHS,
    UPTODATE_VECTOR **  pputodvec,
    UUID            *pUuid )
/*++

Routine Description:

    Removes a dsa entry's cursor from a given UTD.
    Doesn't touch memory image taken (doesn't shrink / realloc mem);

Arguments:

    pTHS -- thread state
    pputodvec -- UTD to process
    pUuid -- cursor to remove from UTD

Return Value:
    None.

Remark:
    Raises DRA exception


--*/
{
    BOOL                      fFound;
    DWORD                     iCursor;
    UPTODATE_VECTOR_NATIVE *  pNativeUTD;

    UpToDateVec_Validate(*pputodvec);

    fFound = l_CursorFind( *pputodvec, pUuid, &iCursor );
    if ( fFound ) {

        // overwrites cursor at iCursor
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));
        pNativeUTD = &(*pputodvec)->V2;
        
        MoveMemory( &pNativeUTD->rgCursors[ iCursor ],
                    &pNativeUTD->rgCursors[ iCursor+1 ],
                    (   sizeof( UPTODATE_CURSOR_NATIVE )
                      * ( pNativeUTD->cNumCursors - iCursor - 1 ) ) );

        pNativeUTD->cNumCursors--;

        UpToDateVec_Validate(*pputodvec);
    }
}


BOOL
UpToDateVec_GetCursorUSN(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT USN *               pusnCursorUSN
    )
{
    DWORD iCursor;

    UpToDateVec_Validate(putodvec);
    Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(putodvec));

    if (l_CursorFind(putodvec, puuidDsaOrig, &iCursor))
    {
        // cursor found
        if (pusnCursorUSN) {
            UPTODATE_VECTOR_NATIVE * pNativeUTD = &putodvec->V2;
            *pusnCursorUSN = pNativeUTD->rgCursors[ iCursor ].usnHighPropUpdate;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
UpToDateVec_GetCursorTimestamp(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT DSTIME *            ptimeLastSyncSuccess
    )
{
    DWORD iCursor;

    UpToDateVec_Validate(putodvec);
    Assert(IS_NULL_OR_VALID_UPTODATE_VECTOR(putodvec));

    if (l_CursorFind(putodvec, puuidDsaOrig, &iCursor))
    {
        // cursor found
        if (ptimeLastSyncSuccess) {
            UPTODATE_VECTOR_NATIVE * pNativeUTD = &putodvec->V2;
            *ptimeLastSyncSuccess = pNativeUTD->rgCursors[ iCursor ].timeLastSyncSuccess;
        }

        return TRUE;
    }

    return FALSE;
}


VOID
l_VectorGrow(
    THSTATE         *   pTHS,
    UPTODATE_VECTOR **  pputodvec,
    DWORD               cNumCursorsToGrow )
//
//  Extend the memory allocation for the given up-to-date vector to hold
//  a specified number of additional cursors.
//
{
    DWORD   cbNewVecSize;

    UpToDateVec_Validate(*pputodvec);

    if ( NULL == *pputodvec )
    {
        cbNewVecSize = UpToDateVecVNSizeFromLen( cNumCursorsToGrow );

        *pputodvec = THAllocEx(pTHS, cbNewVecSize );

        (*pputodvec)->dwVersion = UPTODATE_VECTOR_NATIVE_VERSION;
    }
    else
    {
        UPTODATE_VECTOR_NATIVE * pNativeUTD = &(*pputodvec)->V2;
        
        Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(*pputodvec));

        cbNewVecSize = UpToDateVecVNSizeFromLen( pNativeUTD->cNumCursors + cNumCursorsToGrow );

        *pputodvec = THReAllocEx(pTHS, *pputodvec, cbNewVecSize );
    }
}


UPTODATE_VECTOR *
UpToDateVec_Convert(
    IN      THSTATE *                   pTHS,
    IN      DWORD                       dwOutVersion,
    IN      UPTODATE_VECTOR *           pIn             OPTIONAL
    )
{
    UPTODATE_VECTOR * pOut = NULL;
    DWORD iCursor;

    if (NULL != pIn) {
        Assert(IS_VALID_UPTODATE_VECTOR(pIn));
        
        if (pIn->dwVersion == dwOutVersion) {
            // In and out versions are the same -- no conversion required.
            pOut = pIn;
        } else if ((1 == pIn->dwVersion) && (2 == dwOutVersion)) {
            // Expand V1 vector to V2.
            pOut = THAllocEx(pTHS, UpToDateVecV2SizeFromLen(pIn->V1.cNumCursors));
            pOut->dwVersion = dwOutVersion;
            pOut->V2.cNumCursors = pIn->V1.cNumCursors;

            for (iCursor = 0; iCursor < pIn->V1.cNumCursors; iCursor++) {
                pOut->V2.rgCursors[iCursor].uuidDsa = pIn->V1.rgCursors[iCursor].uuidDsa;
                pOut->V2.rgCursors[iCursor].usnHighPropUpdate = pIn->V1.rgCursors[iCursor].usnHighPropUpdate;
            }
        } else if ((2 == pIn->dwVersion) && (1 == dwOutVersion)) {
            // Reduce V2 vector to V1.
            pOut = THAllocEx(pTHS, UpToDateVecV2SizeFromLen(pIn->V2.cNumCursors));
            pOut->dwVersion = dwOutVersion;
            pOut->V1.cNumCursors = pIn->V2.cNumCursors;

            for (iCursor = 0; iCursor < pIn->V2.cNumCursors; iCursor++) {
                pOut->V1.rgCursors[iCursor].uuidDsa = pIn->V2.rgCursors[iCursor].uuidDsa;
                pOut->V1.rgCursors[iCursor].usnHighPropUpdate = pIn->V2.rgCursors[iCursor].usnHighPropUpdate;
            }
        } else {
            DRA_EXCEPT(ERROR_UNKNOWN_REVISION, pIn->dwVersion);
        }
    }

    return pOut;
}


void
UpToDateVec_AddTimestamp(
    IN      UUID *                      puuidInvocId,
    IN      DSTIME                      timeToAdd,
    IN OUT  UPTODATE_VECTOR *           pUTD
    )
/*++

Routine Description:

    Fill in the timeLastSyncSuccess field for the specified cursor in the UTD
    vector with the given timestamp.
    
    The entry must already exist in the vector and the existing timestamp
    must be 0.

Arguments:

    puuidInvocId (IN) - Invocation ID of cursor to be updated.
    
    timeToAdd (IN) - Timestamp to associate with cursor.
    
    pUTD (IN/OUT) - Vector to be updated.

Return Values:

    None.

--*/
{
    UPTODATE_VECTOR_NATIVE * pNativeUTD = &pUTD->V2;
    DWORD iCursor;
    BOOL fFound;

    Assert(!fNullUuid(puuidInvocId));
    Assert(IS_VALID_NATIVE_UPTODATE_VECTOR(pUTD));
        
    fFound = l_CursorFind(pUTD, puuidInvocId, &iCursor);
    Assert(fFound);

    if (fFound) {
        Assert(0 == memcmp(&pNativeUTD->rgCursors[iCursor].uuidDsa,
                           puuidInvocId, sizeof(UUID)));
        Assert(0 == pNativeUTD->rgCursors[iCursor].timeLastSyncSuccess);

        pNativeUTD->rgCursors[iCursor].timeLastSyncSuccess = timeToAdd;
    }
}

void 
UpToDateVec_Merge(
    IN THSTATE *           pTHS,
    IN UPTODATE_VECTOR *   pUTD1,
    IN UPTODATE_VECTOR *   pUTD2,
    OUT UPTODATE_VECTOR ** ppUTDMerge
    )
/*++

Routine Description:

    Merge two DC's UTD vectors to build a "common" vector.  This common UTD
    is the minimum value of usn's in the two UTD for the intersection of
    DSA's.  For each DSA and USN pair in the common UTD vector, it represents
    the replication state of that BOTH DC's share with respect to that DSA and
    USN pair.  So the common UTD can state that for each DSA in it's vector, both
    DC's have replicated changes up to the corresponding USN.  

Arguments:

    pTHS - 
    
    pUTD1 - utd to merge
    pUTD2 - utd to merge
    
    ppUTDMerge - utd to merge into

Return Values:

    None.

--*/      
{

    ULONG iUTD1 = 0;
    ULONG iUTD2 = 0;
    RPC_STATUS rpcStatus = RPC_S_OK;
    int   nDiff = 0;

    if ((pUTD1==NULL) || (pUTD2==NULL) || (*ppUTDMerge!=NULL)) {
	DRA_EXCEPT(DRAERR_InvalidParameter,0);
    }

    for (iUTD1=0, iUTD2=0; (iUTD1<pUTD1->V2.cNumCursors) && (iUTD2<pUTD2->V2.cNumCursors); ) {
       	nDiff = UuidCompare(&(pUTD1->V2.rgCursors[iUTD1].uuidDsa), &(pUTD2->V2.rgCursors[iUTD2].uuidDsa), &rpcStatus);
	Assert( RPC_S_OK == rpcStatus );

	if (nDiff == 0) {
	    UPTODATE_CURSOR_NATIVE uptodInsert;
	    uptodInsert.uuidDsa = pUTD1->V2.rgCursors[iUTD1].uuidDsa;
	    uptodInsert.usnHighPropUpdate = MIN(pUTD1->V2.rgCursors[iUTD1].usnHighPropUpdate,pUTD2->V2.rgCursors[iUTD2].usnHighPropUpdate);  
	    uptodInsert.timeLastSyncSuccess = 0;
	    l_CursorInsert(pTHS, ppUTDMerge, &uptodInsert);
	    iUTD1++;
	    iUTD2++;
	}
	else if ( nDiff < 0 ) {
	    iUTD1++;
	}
	else {
	    iUTD2++;
	}
    } 
    UpToDateVec_Validate(*ppUTDMerge);
}


BOOL
UpToDateVec_ValidateExternal(
    IN  UPTODATE_VECTOR *    pIn,
    IN  size_t               cbIn
    )
/*++

Routine Description:

    Validate an up-to-dateness vector provided from external (eg. untrusted)
    sources. This function checks that:
     - The size of the blob is appropriate
     - The version number is known
     - The number of cursors is consistent with the size of the blob

Arguments:

    pIn - pointer to up-to-dateness vector. May not be null.
    cbIn - size of pIn

Return Values:

    True if it is valid, false otherwise

--*/
{
    size_t  cNumCursors, cMaxSize, cMaxCursors, cbTotalSize;
    cMaxSize = ((size_t)-1);

    // Verify using the preprocessor that this function knows about all
    // defined versions of up-to-dateness vectors
    #if UPTODATE_VECTOR_NATIVE_VERSION == 2
        // No problem
    #else
        #error UpToDateVec_Validate2 must be updated to deal with new structures
    #endif

    // Check that pIn is not null
    if( NULL==pIn ) {
        return FALSE;
    }

    // Check that pIn has at least enough space for the version
    if( cbIn<offsetof(UPTODATE_VECTOR,V1) ) {
        return FALSE;
    }

    // Check that the version number is known
    if( !IS_VALID_UPTODATE_VECTOR(pIn) ) {
        return FALSE;
    }

    // Individually check the various versions of an up-to-dateness vector
    switch( pIn->dwVersion ) {

        case 1:
            // Check that pIn has has at least enough space for the number of cursors
            if( cbIn<offsetof(UPTODATE_VECTOR,V1.rgCursors[0]) ) {
                return FALSE;
            }

            // Check that the number of cursors will not cause an overflow when
            // we compute the total size
            cNumCursors = pIn->V1.cNumCursors;
            cMaxCursors = (cMaxSize-offsetof(UPTODATE_VECTOR,V1.rgCursors[0]))
                / sizeof(UPTODATE_CURSOR_V1);
            
            if( cNumCursors > cMaxCursors ) {
                return FALSE;
            }
            break;

        case 2:
            // Check that pIn has has at least enough space for the number of cursors
            if( cbIn<offsetof(UPTODATE_VECTOR,V2.rgCursors[0]) ) {
                return FALSE;
            }

            // Check that the number of cursors will not cause an overflow when
            // we compute the total size
            cNumCursors = pIn->V2.cNumCursors;
            cMaxCursors = (cMaxSize-offsetof(UPTODATE_VECTOR,V2.rgCursors[0]))
                / sizeof(UPTODATE_CURSOR_V2);
            
            if( cNumCursors > cMaxCursors ) {
                return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    // Check that the given size of pIn is equal to our computed size
    cbTotalSize = UpToDateVecSize(pIn);
    if( cbTotalSize!=cbIn ) {
        return FALSE;
    }

    return TRUE;
}


BOOL
UpToDateVec_HasSunkSince(
    IN      DBPOS *             pDB,
    IN      SYNTAX_INTEGER      it,
    IN      DSTIME *            ptimeLastSyncSuccess
    )

/*++

Routine Description:

    Read the up to date vector and test whether it has been sunk
    successfully since the date provided

    It doesn't matter which uuid we find first, either a direct partner or a
    transitive partner. We assume all clocks closely synchronized, and that if we have
    a transitive partner at time x, we must have a direct partner at time >= x.

Arguments:

    pDB - DBPOS already positioned on a NC
    it  - instance type of NC
    ptimeLastSyncSuccess - time after which is considered successful

Return Value:

    BOOL - TRUE if sunk since the date, false otherwise

--*/

{
    THSTATE *           pTHS = pDB->pTHS;
    UPTODATE_VECTOR *   putodvecLocal;
    DWORD               iCursor;
    BOOL                fFound = FALSE;
    CHAR szTime1[SZDSTIME_LEN], szTime2[SZDSTIME_LEN];
    CHAR szUuid1[SZUUID_LEN], szUuid2[SZUUID_LEN];

    // We must be positioned on an instantiated NC head.
    Assert(l_PositionedOnNC(pDB));

    UpToDateVec_Read(pDB, it, 0, 0, &putodvecLocal);
    Assert(IS_NULL_OR_VALID_NATIVE_UPTODATE_VECTOR(putodvecLocal));
    UpToDateVec_Validate(putodvecLocal);

    if (putodvecLocal) {
        for( iCursor = 0; iCursor < putodvecLocal->V2.cNumCursors; iCursor++ ) {
            if (putodvecLocal->V2.rgCursors[ iCursor ].timeLastSyncSuccess >
                *ptimeLastSyncSuccess) {
                fFound = TRUE;
                // In the future we could consider returning the uuid
                // of the partner if we wanted

    DPRINT3( 1, "Partition has been sunk since time %s because we sunk with partner %s at time %s.\n",
    DSTimeToDisplayString(*ptimeLastSyncSuccess, szTime1),
    DsUuidToStructuredString(&(putodvecLocal->V2.rgCursors[iCursor].uuidDsa), szUuid1),
    DSTimeToDisplayString(putodvecLocal->V2.rgCursors[ iCursor ].timeLastSyncSuccess, szTime2) );
                break;
            }
        }
    }

    THFreeEx( pTHS, putodvecLocal );

    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\drautil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drautil.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Miscellaneous replication support routines.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

// SAM headers
#include <samsrvp.h>                    /* for SampInvalidateRidRange() */

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"
#include "dstaskq.h"
#include "dsconfig.h"
#include <dsutil.h>
#include <winsock.h>                    /* htonl, ntohl */
#include <filtypes.h>                   // For filter construction
#include <winldap.h>                    // for DN parsing
#include <windns.h>                     // DnsNameCompare_W()

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRAUTIL:" /* define the subsystem for debugging */

// DRA headers
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "drautil.h"
#include "drasig.h"          // DraInvocationIdIsOurs
#include "draerror.h"
#include "drancrep.h"
#include "dramail.h"
#include "dsaapi.h"
#include "usn.h"
#include "drauptod.h"
#include "draasync.h"
#include "drameta.h"
#include "drauptod.h"
#include "cracknam.h"
#include "dominfo.h"
#include "draaudit.h"

#include <fileno.h>
#define  FILENO FILENO_DRAUTIL

extern BOOL gfRestoring;
// Count of restores done on this DC so far
ULONG gulRestoreCount = 0;
BOOL gfJustRestored = FALSE;

void DbgPrintErrorInfo(); // mddebug.c


BOOL
draPartitionSynchronizedSinceBoot(
    THSTATE *pTHS,
    DSNAME *pNC
    )

/*++

Routine Description:

    Determine whether a partition has synchronized since boot. We use the replication
    latency timestamps. They will be updated if we have synchronized successfully with
    any of our partners, even if no changes were returned. Also a timestamp is generated
    for w2k partners, assuring us that they will be detected.

Arguments:

    pTHS - thread state
    pNC - Naming context to be checked. Must be held locally for this to work.

Return Value:

    BOOL - True, meaning have synced since boot. FALSE means not or can't tell

--*/

{
    BOOL fResult = FALSE;
    DBPOS *pDBTmp;
    SYNTAX_INTEGER it;

    // During install, we haven't even started to sync yet
    if ( DsaIsInstalling() || gResetAfterInstall ) {
        return FALSE;
    }

    // Make sure not called too soon
    if (!gtimeDSAStarted) {
        Assert( !"Called before DSA initialized!" );
        return FALSE;
    }

    // Set up the temporary pDB
    DBOpen (&pDBTmp);
    __try {
        if (FindNC(pDBTmp, pNC, FIND_MASTER_NC | FIND_REPLICA_NC, &it)) {
            Assert( !"Checking for a partition which is not held!" );
            __leave;
        }

        // NC not fully held
        if (it &(IT_NC_COMING | IT_NC_GOING)) {
            __leave;
        }

        fResult = UpToDateVec_HasSunkSince( pDBTmp, it, &gtimeDSAStarted );

    } __finally {

        // Close the temporary pDB
        DBClose (pDBTmp, !AbnormalTermination());

    }

    return fResult;
} /* draPartitionSynchronizedSinceBoot */

BOOL
IsFSMOSelfOwnershipValid(
    DSNAME *pFSMO
    )

/*++

Routine Description:

Determine whether we are ready to hold the given FSMO.
We require that the partition in which the FSMO resides be synchronized.

Arguments:

    pNC - FSMO object being checked

Return Value:

    BOOL -

--*/

{
    THSTATE * pTHS = pTHStls;
    CROSS_REF * pCR;
    COMMARG commArg;

    Assert( pFSMO );

    // If installing, ownership is valid
    if (DsaIsInstalling()) {
        return TRUE;
    }

    // If the FSMO was seized or transferred since we started, it is valid
    // regardless of other validity checks.  If the FSMO hasn't been seized, it
    // may still be valid. We just have to do the other checks to be sure.

    // We claim that we can measure ownership transfer by the attribute metadata
    // indicating the role attribute was recently written by us. We believe that a
    // role can only be claimed by its owner, and that a role cannot be claimed on
    // behalf of another.

    // Note that this check only validates that the attribute was written by
    // us recently. It does not check the contents of the attribute.
    if (DraIsRecentOriginatingChange( pTHS, pFSMO, ATT_FSMO_ROLE_OWNER )) {
        DPRINT1( 1, "FSMO %ws was recently seized.\n", pFSMO->StringName );
        return TRUE;
    }

    // We want the partition that holds this FSMO object. The object
    // may or may not be a NC head.  Find the NC head.

    memset( &commArg, 0, sizeof( COMMARG ) );  // not used
    pCR = FindBestCrossRef( pFSMO, &commArg );
    if (NULL == pCR) {
        DPRINT1(0, "Can't find cross ref for %ws.\n", pFSMO->StringName );
        DRA_EXCEPT(ERROR_DS_NO_CROSSREF_FOR_NC, DRAERR_InternalError);
    }

    if (draPartitionSynchronizedSinceBoot( pTHS, pCR->pNC )) {
        return TRUE;
    }

    // See if the holding partition is synchronized
    // In the sole-domain-owner scenario, this will always return true
    // which is an optimization

    return DraIsPartitionSynchronized( pCR->pNC );

} /* IsFSMOSelfOwnershipValid */

BOOL
MtxSame(
    UNALIGNED MTX_ADDR *pmtx1,
    UNALIGNED MTX_ADDR *pmtx2
    )

/*++

Routine Description:

// MtxSame. Returns TRUE if passed MTX are the
// same (case insensitive comparision)

Arguments:

    pmtx1 -
    pmtx2 -

Return Value:

    BOOL -

--*/

{
    if (   (pmtx1->mtx_namelen == pmtx2->mtx_namelen)
        && (!(_memicmp(pmtx1->mtx_name,
                       pmtx2->mtx_name,
                       pmtx1->mtx_namelen)))) {
        // Names are obviously the same
        return TRUE;
    }
    else if (   (pmtx1->mtx_namelen == pmtx2->mtx_namelen + 1)
             && ('.'  == pmtx1->mtx_name[pmtx2->mtx_namelen - 1])
             && ('\0' == pmtx1->mtx_name[pmtx2->mtx_namelen])
             && ('\0' == pmtx2->mtx_name[pmtx2->mtx_namelen - 1])
             && (!(_memicmp(pmtx1->mtx_name,
                            pmtx2->mtx_name,
                            pmtx2->mtx_namelen - 1)))) {
        // Names are the same, except pmtx1 is absolute (it ends in . NULL,
        // while pmtx2 ends in NULL)
        return TRUE;
    }
    else if (   (pmtx1->mtx_namelen + 1 == pmtx2->mtx_namelen)
             && ('.'  == pmtx2->mtx_name[pmtx1->mtx_namelen - 1])
             && ('\0' == pmtx2->mtx_name[pmtx1->mtx_namelen])
             && ('\0' == pmtx1->mtx_name[pmtx1->mtx_namelen - 1])
             && (!(_memicmp(pmtx1->mtx_name,
                            pmtx2->mtx_name,
                            pmtx1->mtx_namelen - 1)))) {
        // Names are the same, except pmtx2 is absolute (it ends in . NULL,
        // while pmtx1 ends in NULL)
        return TRUE;
    }
    return FALSE;

} /* MtxSame */


DWORD
InitDRA(
    THSTATE *pTHS
    )

/*++

Routine Description:

    Start the replication subsystem.

Arguments:

    None.

Return Values:

    0 (success) or Win32 error.

--*/

{
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;

    // Determine periodic, startup, and mail requirements for this DSA
    __try {
        ulErrorCode = InitDRATasks( pTHS );
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {

        DPRINT3(0, "Caught unexpected exception in InitDraTasks! dwException = 0x%x ulErrorCode = %d, dsid = 0x%x\n",
                dwException,
                ulErrorCode,
                dsid );
        DoLogUnhandledError( dsid, ulErrorCode, FALSE /* no username */ );
        Assert( FALSE );
    }

    return ulErrorCode;
}

USHORT
InitFreeDRAThread (
    THSTATE *pTHS,
    USHORT transType
    )

/*++

Routine Description:

// InitFreeDRAThread
//
// Sets up a DRA thread so that it has a thread state and a heap. This is
// called by threads in the DRA that do not come from RPC.

Arguments:

    pTHS -
    transType -

Return Value:

    USHORT -

--*/

{
    pTHS->fDRA = TRUE;
    BeginDraTransaction(transType);
    return 0;
} /* InitFreeDRAThread  */

void
CloseFreeDRAThread(
    THSTATE *pTHS,
    BOOL fCommit
    )

/*++

Routine Description:

// CloseFreeDRAThread
//
// This function undoes the actions of InitFreeDRAThread.
// Called by threads that do not come from RPC

Arguments:

    pTHS -
    fCommit -

Return Value:

    None

--*/

{
    EndDraTransaction(fCommit);

    DraReturn(pTHS, 0);
} /* CloseFreeDRAThread */

VOID
SetDRAAuditStatus(THSTATE * pTHS) 
/*++

Routine Description:

    Check if replication auditing is enabled.  If so, set flags on the 
    thread state.  
    
    This needs to be seperate from InitDraThreadEx because other thread
    types may want to set this - ntdsapi for example. 

Arguments:

    pTHS

Return Value:

    None

--*/
{
    pTHS->fDRAAuditEnabled = IsDraAuditLogEnabled();
    pTHS->fDRAAuditEnabledForAttr = IsDraAuditLogEnabledForAttr();
}

void
InitDraThreadEx(
    THSTATE **ppTHS,
    DWORD dsid
    )

/*++

Routine Description:

// InitDraThread - Initialize a thread for the replicator.
//
// Sets thread up for DB transactions, Calls DSAs InitTHSTATE for memory
// management and DB access
//
//  Returns: void
//
//  Notes: If a successful call to InitDraThread is made, then a call to
//  DraReturn should also be made before the thread is exited.

Arguments:

    ppTHS -
    dsid -

Return Value:

    None

--*/

{
    // InitTHSTATE gets or allocates a thread state and then sets up
    // for DB access via DBInitThread.

    // Pass NULL to InitTHSTATE so that it uses THSTATE's internal
    // ppoutBuf

    if ((*ppTHS = _InitTHSTATE_(CALLERTYPE_DRA, dsid)) == NULL) {
        DraErrOutOfMem();
    }
    (*ppTHS)->fDRA = TRUE;
    SetDRAAuditStatus(*ppTHS);
} /* InitDraThreadEx */

DWORD
DraReturn(
    THSTATE *pTHS,
    DWORD status
    )

/*++

Routine Description:

// DraReturn - Clean up THSTATE before exiting thread.
//
// Zero the pointer to the DBlayer structure DBPOS, although this
// should be zero if everything is working correctly.

Arguments:

    pTHS -
    status -

Return Value:

    DWORD -

--*/

{

    Assert( (pTHS->pDB == NULL) && "about to leak a dbpos" );
    pTHS->pDB = NULL;

    return status;
} /* DraReturn */

void
BeginDraTransactionEx(
    USHORT transType,
    BOOL fBypassUpdatesEnabledCheck
    )

/*++

Routine Description:

BeginDraTransaction - start a DRA transaction.

Arguments:

    transType -

Return Value:

    None

--*/

{
    if (pTHStls->fSyncSet) {
        DRA_EXCEPT (DRAERR_InternalError, 0);
    }

    if (transType == SYNC_WRITE) {
        // Inhibit update operations if the schema hasn't been loaded
        // yet or if we had a problem loading

        if (!fBypassUpdatesEnabledCheck && !gUpdatesEnabled) {
            DRA_EXCEPT_NOLOG (DRAERR_Busy, 0);
        }
    }

    SyncTransSet(transType);
} /* BeginDraTransactionEx */


USHORT
EndDraTransaction(
    BOOL fCommit
    )

/*++

Routine Description:

EndDraTransaction - End a DRA transaction. If fCommit is TRUE
      the transaction is committed to the database.

Arguments:

    None

Return Value:

    None

--*/

{
    SyncTransEnd(pTHStls, fCommit);

    return 0;
}

ULONG
EndDraTransactionSafe(
    BOOL fCommit
    )
/*++
Description:
    Safely end dra transaction (handle exceptions)
++*/
{
    ULONG ret = 0;
    __try {
        EndDraTransaction (fCommit);
    } 
    __except (GetDraException((GetExceptionInformation()), &ret)) {
          ;
    }  
    return ret;
}

BOOL
IsSameSite(
    THSTATE *         pTHS,
    DSNAME *          pServerName1,
    DSNAME *          pServerName2
    )
/*++

Routine Description:

IsSameSite - if pServerName1 and pServerName2 are in the same site then return TRUE, else FALSE

Arguments:

    pServerName1 -
    pServerName2 -
    pTHS -

Return Value:

    TRUE or FALSE;

--*/
{
    DSNAME *          pSiteName = NULL;
    DWORD             err = 0;
    BOOL              fIsSameSite = FALSE;

    if ((!pServerName1) || (!pServerName2)) {
    return FALSE; //either null means they aren't in the same site!
    }

    pSiteName = THAllocEx(pTHS,pServerName1->structLen); 
    err = TrimDSNameBy(pServerName1, 2, pSiteName);
    if (err) {
    if (pSiteName) {
        THFreeEx(pTHS,pSiteName);
    }
    return FALSE; //can't match sites
    }

    if (NamePrefix(pSiteName, pServerName2)) {
    fIsSameSite = TRUE;
    }
    
    THFreeEx(pTHS,pSiteName);
    return fIsSameSite;
}

ATTRTYP
GetRightHasMasterNCsAttr(
    DBPOS *  pDB
    )
/*++

Routine Description:

    This function checks for the "new" ATT_MS_DS_HAS_MASTER_NCS attribute
    on the current object (assumed to be a DSA), and returns this attr type
    if the attribute exists, otherwise it returns the ATT_HAS_MASTER_NCS
    attr type.  This is so the DC selects the autoritative list of NCs to 
    look at ether this DC is a win2k or a .NET RC1 or later DC.
    
    So if you don't know whether the DSA you're looking at is .NET or not,
    use this function to get the right attribute for the complete list of
    NCs the DSA is the master for.
    
Arguments:

    pDB - Currency should be set to the DSA you want to try.
    
Return Value:
    
    ATT_MS_DS_HAS_MASTER_NCS or ATT_HAS_MASTER_NCS

// NTRAID#NTBUG9-582921-2002/03/21-Brettsh - When we no longer require 
// Win2k compatibility, we can basically just always return 
// ATT_MS_DS_HAS_MASTER_NCS
        
--*/
{
    ATTCACHE *  pAC;
    UCHAR *     pTemp;
    ULONG       cbTemp;
    ULONG       ulErr;

    DPRINT(4, "GetRightHasMasterNCs() entered\n");
    Assert(VALID_DBPOS(pDB));

    pAC = SCGetAttById(pDB->pTHS, ATT_MS_DS_HAS_MASTER_NCS);
    if (pAC == NULL) {
        Assert(!"We should never hit this, unless schema is not up?");
        DsaExcept(DSA_EXCEPTION, DIRERR_ATT_NOT_DEF_IN_SCHEMA, ATT_MS_DS_HAS_MASTER_NCS);
    }
    
    ulErr = DBGetAttVal_AC(pDB,
                           1, // First value
                           pAC,
                           0,
                           0,
                           &cbTemp,
                           (UCHAR**)&pTemp);
    if (ulErr == ERROR_SUCCESS) {
        //
        // Yeah!  We have the "new" msDS-HasMasterNCs for this DSA
        //
        THFreeEx(pDB->pTHS, pTemp);
        return(ATT_MS_DS_HAS_MASTER_NCS);
    } else if (ulErr == DB_ERR_NO_VALUE){
        //
        // Hmmm, must be Win2k, use "old" deprecated hasMasterNCs
        //
        return(ATT_HAS_MASTER_NCS);
    } else {
        // Something went wrong, so for now, lets fail to something conservative.
        return(ATT_HAS_MASTER_NCS);
    }
}

BOOL
IsMasterForNC(
    DBPOS *           pDB,
    DSNAME *          pServer,
    DSNAME *          pNC
    )
/*++

Routine Description:

    IsMasterForNC - If pServer is a master for pNC, return TRUE, else FALSE

    NOTE: If pNC is NULL then this function will return FALSE.

Arguments:

    pServer - 
    pNC -

Return Value:

    TRUE or FALSE;

--*/
{
    DWORD err = 0;
    BOOL      fIsMasterForNC = FALSE; 
    void *    pVal;
    DSNAME *  pMasterNC = NULL;
    ULONG     cLenVal;
    ULONG     ulAttValNum = 1;
    ULONG     ulHasMasterNCsAttr;

    if (!pServer || !pNC){
        //Null is not a Master for any NC and
        //any server is not a master of a NULL NC
        return FALSE;  
    }

    err = DBFindDSName(pDB, pServer);

    ulHasMasterNCsAttr = GetRightHasMasterNCsAttr(pDB);

    while (err==ERROR_SUCCESS) { 
    	
        err = DBGetAttVal(pDB, ulAttValNum++, ulHasMasterNCsAttr, 0, 0, &cLenVal, (UCHAR **)&pVal); 
    
    	if (err==ERROR_SUCCESS) {
    	    if (NameMatched(pVal,pNC)) {
        		fIsMasterForNC=TRUE;
        		THFreeEx(pDB->pTHS,pVal);
        		break;
       	    }
    	    THFreeEx(pDB->pTHS,pVal);
    	}

    }

    return fIsMasterForNC;
}

DWORD
CheckReplicationLatencyForNC(
    DBPOS *           pDB,
    DSNAME *          pNC,
    DWORD             dwMinLatencyIntervalSec
    )

/*++

Routine Description:

CheckReplicationLatencyForNC - check's the UTD for pNC on this server and logs events if latency 
        exceeds limits.  

Arguments:

    pNC - NC for which to check latency
    pDB - 
    pTHS -

Return Value:

    Win32 Error Codes

--*/

{   
    DWORD                   dwNumRequested = 0xFFFFFFFF;
    ULONG                   dsThresholdTwoMonth = DAYS_IN_SECS*56; //these are coarse warnings and
    ULONG                   dsThresholdMonth = DAYS_IN_SECS*28; //do not need to be exactly a month for all months.
    ULONG                   dsThresholdWeek = DAYS_IN_SECS*7;
    ULONG                   cOverThresholdTombstoneLifetime = 0;
    ULONG                   cOverThresholdMonth = 0;
    ULONG                   cOverThresholdTwoMonth = 0;
    ULONG                   cOverThresholdWeek = 0;
    ULONG                   cOverThreshold = 0;
    ULONG                   cOverThresholdSameSite = 0;
    DWORD                   ret = 0;
    DS_REPL_CURSORS_3W *    pCursors3;
    DWORD                   iCursor;
    DWORD                   dbErr = 0;
    DSTIME                  dsTimeSync;
    DSTIME                  dsTimeNow;
    LONG                    dsElapsedSec;
    ULONG                   ulTombstoneLifetime;
    BOOL                    fLogAsError = FALSE;
    DSNAME *                pServerDN;
    void *                  pVal;
    ULONG                   cLenVal;
    BOOL                    fIsServerMasterForNC = FALSE;

    //get the tombstone lifetime so we can report how many
    //dc's haven't replicated with us in over that value.
    if (gAnchor.pDsSvcConfigDN) {
        ret = DBFindDSName(pDB, gAnchor.pDsSvcConfigDN);
        if (!ret) { 
            ret = DBGetAttVal(pDB, 1, ATT_TOMBSTONE_LIFETIME, 0, 0, &cLenVal,(UCHAR **) &pVal);
        }
    }
    else {
        ret = DIRERR_OBJ_NOT_FOUND;
    }
    
    if (ret || !pVal) {
        ulTombstoneLifetime = DEFAULT_TOMBSTONE_LIFETIME*DAYS_IN_SECS;
    }
    else
    {
        ulTombstoneLifetime = (*(ULONG *)pVal)*DAYS_IN_SECS;
    }
    
    ret = draGetCursors(pDB->pTHS,
            pDB,
            pNC,
            DS_REPL_INFO_CURSORS_3_FOR_NC,
            0,
            &dwNumRequested,
            &pCursors3);

    if (!ret) {
    for (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {    

        if ((pCursors3->rgCursor[iCursor].pszSourceDsaDN) && 
	    (!((pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess.dwLowDateTime==0) &&
	     (pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess.dwHighDateTime==0)))) {
        // calculate times to check latency
        FileTimeToDSTime(pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess, &dsTimeSync);
        dsTimeNow = GetSecondsSince1601();
        dsElapsedSec = (LONG) (dsTimeNow - dsTimeSync); 

        // check latency
        if (dsElapsedSec>(LONG)(dwMinLatencyIntervalSec)) {
            // this server is latent
            pServerDN = DSNameFromStringW(pDB->pTHS, pCursors3->rgCursor[iCursor].pszSourceDsaDN);      
	    fIsServerMasterForNC = IsMasterForNC(pDB, pServerDN, pNC);   
	    // note that IsMasterForNC returns FALSE if the DC has been deleted.

	    // we only care about writable/master servers.  The data for the other servers
	    // isn't guarenteed reliable anyway.
	    if ( fIsServerMasterForNC ) {

		//first checks (has to fail this because of above check for latency)
		cOverThreshold++;   
		if (IsSameSite(pDB->pTHS, gAnchor.pDSADN, pServerDN)) {
		    cOverThresholdSameSite++;
		    fLogAsError=TRUE;
		}

		//second checks (note, all units are seconds)
		if (dsElapsedSec>(LONG)dsThresholdWeek) {
		    cOverThresholdWeek++;
		    fLogAsError=TRUE;
		}

		//month checks
		if (dsElapsedSec>(LONG)dsThresholdMonth) {
		    cOverThresholdMonth++;
		}   

		//two month checks
		if (dsElapsedSec>(LONG)dsThresholdTwoMonth) { 
		    cOverThresholdTwoMonth++;
		}

		//tombstone lifetime checks
		if (dsElapsedSec>(LONG)ulTombstoneLifetime) {
		    cOverThresholdTombstoneLifetime++;   
		    fLogAsError=TRUE;
		}  
	    }
	    THFreeEx(pDB->pTHS, pServerDN);
	}
	}
	else {
	    // retired invocationID or Win2k DC (without LasySyncSuccess times), do not track
	}
    } //for  (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {    

    if (cOverThresholdTombstoneLifetime+
	cOverThresholdTwoMonth+
	cOverThresholdMonth+
	cOverThresholdWeek+
	cOverThreshold) {
	if (fLogAsError) {
	    if (cOverThresholdTombstoneLifetime+
		cOverThresholdTwoMonth+
		cOverThresholdMonth+
		cOverThresholdWeek) {
		// Serious latency problem, log as an error! 
		LogEvent8(DS_EVENT_CAT_REPLICATION,
			  DS_EVENT_SEV_ALWAYS,
			  DIRLOG_DRA_REPLICATION_LATENCY_ERRORS_FULL,
			  szInsertDN(pNC),
			  szInsertUL(cOverThreshold),
			  szInsertUL(cOverThresholdWeek),
			  szInsertUL(cOverThresholdMonth),
			  szInsertUL(cOverThresholdTwoMonth),
			  szInsertUL(cOverThresholdTombstoneLifetime),
			  szInsertUL((ULONG)ulTombstoneLifetime/(DAYS_IN_SECS)),
			  szInsertUL((ULONG)dwMinLatencyIntervalSec/HOURS_IN_SECS));
	    }
	    else {  
		// Serious latency problem, cOverThreshold in the same site.
		// log as error!
		LogEvent8(DS_EVENT_CAT_REPLICATION,
			  DS_EVENT_SEV_ALWAYS,
			  DIRLOG_DRA_REPLICATION_LATENCY_ERRORS,
			  szInsertDN(pNC),
			  szInsertUL(cOverThreshold),   
			  szInsertUL(cOverThresholdSameSite),
			  szInsertUL((ULONG)dwMinLatencyIntervalSec/HOURS_IN_SECS),
			  NULL,NULL,NULL,NULL);
	    }
	}
	else { 
	    // Warning		
	    LogEvent(DS_EVENT_CAT_REPLICATION,
		     DS_EVENT_SEV_ALWAYS,
		     DIRLOG_DRA_REPLICATION_LATENCY_WARNINGS,
		     szInsertDN(pNC),
		     szInsertUL(cOverThreshold),   
		     szInsertUL((ULONG)dwMinLatencyIntervalSec/HOURS_IN_SECS));
	}
    }
    draFreeCursors(pDB->pTHS,DS_REPL_INFO_CURSORS_3_FOR_NC,(void *)pCursors3);
    }
    return ret;
}

DWORD
CheckReplicationLatencyHelper() 
    /*++

Routine Description:

Check the latency for all naming contexts and log overlimit latencies (called by CheckREplicationLatency
which is a task queue function)

Arguments:

    None

Return Value:

    Win32 Error Codes

--*/
{
    DWORD                   ret = 0;
    DWORD                   ret2 = 0;
    DWORD                   dbErr = 0;
    DSNAME *                pNC;
    NCL_ENUMERATOR          nclMaster, nclReplica;
    NAMING_CONTEXT_LIST *   pNCL;
    THSTATE *               pTHS=pTHStls;
    DBPOS *                 pDB = NULL;  
    DWORD                   dwLatencyIntervalHrs = 0;

    InitDraThread(&pTHS);
    //for each NC, check the status of our replication with all masters.
    NCLEnumeratorInit(&nclMaster, CATALOG_MASTER_NC);
    NCLEnumeratorInit(&nclReplica, CATALOG_REPLICA_NC);
    
    DBOpen2(TRUE, &pDB);
    if (!pDB)
    {
        DPRINT(1, "Failed to create a new data base pointer \n"); 
        DRA_EXCEPT(DRAERR_InternalError, 0); 
    }
    __try {
      
	//get the minimum warning interval from the registry 
	if (GetConfigParam(DRA_REPL_LATENCY_ERROR_INTERVAL, &dwLatencyIntervalHrs, sizeof(DWORD))) {
	    dwLatencyIntervalHrs=DAYS_IN_HOURS; // default is 1 day.
	} else if ((dwLatencyIntervalHrs > WEEK_IN_HOURS) ||   // 1 week in hours
	    (dwLatencyIntervalHrs <= 0))  {// make it 1 week if they input something screwy.  
	    dwLatencyIntervalHrs = WEEK_IN_HOURS;
	}
	
	//check latencies for all NC's
	//master NC's
	while (pNCL = NCLEnumeratorGetNext(&nclMaster)) {
	    pNC = pNCL->pNC;
	    ret = CheckReplicationLatencyForNC(pDB, pNC, dwLatencyIntervalHrs*HOURS_IN_SECS); //convert Interval to seconds
	    ret2 = ret2 ? ret2 : ret;
	}
	//and replica NC's
	while (pNCL = NCLEnumeratorGetNext(&nclReplica)) {
	    pNC = pNCL->pNC; 
	    ret = CheckReplicationLatencyForNC(pDB, pNC, dwLatencyIntervalHrs*HOURS_IN_SECS);   
	    ret2 = ret2 ? ret2 : ret;
	}
	
    } __finally {
	DBClose(pDB, TRUE);
    }

    DraReturn(pTHS, 0);
    return ret2;

} /* CheckReplicationLatencyHelper */

void
CheckReplicationLatency(void *pv, void **ppvNext, DWORD *pcSecsUntilNextIteration) {
    DWORD err;
    ULONG ulReplLatencyCheckIntervalDays = 0;
    // if the latency check interval is set to 0, do not perform any check

    __try {
	err = GetConfigParam(DRA_REPL_LATENCY_CHECK_INTERVAL, &ulReplLatencyCheckIntervalDays, sizeof(DWORD)); 
	// if the reg key isn't set (or there is another error) or the key isn't set to 0, run the test 
	if ((err!=0) || (ulReplLatencyCheckIntervalDays!=0)) {
	    err = CheckReplicationLatencyHelper();
	    if (err) { 
		DPRINT1(1,"A replication status query failed with status %d!\n", err);
	    }
	}
    }
    __finally {
	/* Set task to run again */
	if(!eServiceShutdown) {
	    *ppvNext = NULL;
	    // even if they set the latency check interval to 0, we want to check again later
	    // to see if they unset it from 0.  so check 1 time per day.
	    ulReplLatencyCheckIntervalDays = (ulReplLatencyCheckIntervalDays<=0) ? 1 : ulReplLatencyCheckIntervalDays;
	    *pcSecsUntilNextIteration = ulReplLatencyCheckIntervalDays * DAYS_IN_SECS;
	}
    }
    (void) pv;   // unused
}

DWORD
FindNC(
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  ULONG               ulOptions,
    OUT SYNTAX_INTEGER *    pInstanceType   OPTIONAL
    )
/*++

Routine Description:

    Position on the given object and verify it is an NC of the correct type.

Arguments:

    pTHS (IN)

    pNC (IN) - Name of the NC.

    ulOptions (IN) - One or more of the following bits:
        FIND_MASTER_NC - Writeable NCs are acceptable.
        FIND_REPLICA_NC - Read-only NCs are acceptable.

Return Value:

    0 - success
    DRAERR_BadDN - object does not exist
    DRAERR_BadNC - Instance type does not match

--*/
{
    SYNTAX_INTEGER it;

    // Check that the object exists
    if (FindAliveDSName(pDB, pNC)) {
        return DRAERR_BadDN;
    }

    // See if it is the required instance type
    GetExpectedRepAtt(pDB, ATT_INSTANCE_TYPE, &it, sizeof(it));
    Assert(ISVALIDINSTANCETYPE(it));

    if (NULL != pInstanceType) {
        *pInstanceType = it;
    }

    if (FPrefixIt(it)
        && (((ulOptions & FIND_MASTER_NC) && (it & IT_WRITE))
            || ((ulOptions & FIND_REPLICA_NC) && !(it & IT_WRITE)))) {
        return 0;
    }

    return DRAERR_BadNC;
} /* FindNC */


void
GetExpectedRepAtt(
    IN  DBPOS * pDB,
    IN  ATTRTYP type,
    OUT VOID *  pOutBuf,
    IN  ULONG   size
    )

/*++

Routine Description:

 GetExpectedRepAtt - Get the external form of the value of the attribute
*       specified by 'type' in the current record. If it is a multi-valued
*       attribute we only get the first value. The value is stored at
*       'pOutBuf'. If the attribute is not present (or has no value) make
*       an error log entry and generate an exception.

Arguments:

    pDB -
    type -
    pOutBuf -
    size -

Return Value:

    None

--*/

{
    ULONG len;
    if (DBGetAttVal(pDB, 1, type,
                    DBGETATTVAL_fCONSTANT, size, &len,
                    (PUCHAR *)&pOutBuf)) {
        DraErrMissingAtt(GetExtDSName(pDB), type);
    }
} /* GetExpectedRepAtt */


REPLICA_LINK *
FixupRepsFrom(
    REPLICA_LINK *prl,
    PDWORD       pcbPrl
    )
/*++

Routine Description:

    Converts REPLICA_LINK structures as read from disk (in repsFrom attribute)
    to current version.

Arguments:

    prl-- In repsFrom as read from disk to convert
    pcbPrl -- IN: size of pre-allocated memory of prl
              OUT: if changed, new size

Return Value:
    Success: modified (& possible re-allocated) RL
    Error: Raises exception

Remarks:
    Must sync changes w/ KCC_LINK::Init.
      Todo-- make available to KCC as well.

--*/
{

    THSTATE *pTHS=pTHStls;
    DWORD dwCurrSize;

    if (prl->V1.cbOtherDraOffset < offsetof(REPLICA_LINK, V1.rgb)) {
        // The REPLICA_LINK structure has been extended since this value
        // was created.  Specifically, it's possible to add new fields to
        // the structure before the dynamically sized rgb field.  In this
        // case, we shift the contents of what was the rgb field to the
        // new offset of the rgb field, then zero out the intervening
        // elements.
        DWORD cbNewFieldsSize = offsetof(REPLICA_LINK, V1.rgb) - prl->V1.cbOtherDraOffset;

        // old formats:
        //  -  missing the uuidTransportObj field (realy old).
        //  -  w/out what used to be dwDrsExt (now dwReserved1)
        Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.uuidTransportObj) ||
               prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.dwReserved1) );

        DPRINT1(0, "Converting repsFrom %s from old REPLICA_LINK format.\n",
                RL_POTHERDRA(prl)->mtx_name);

        // Expand the structure and shift the contents of what was the
        // rgb field in the old format to where the rgb field is in the new
        // format.
        dwCurrSize = prl->V1.cb + cbNewFieldsSize;
        if (*pcbPrl < dwCurrSize) {
            //
            // re-alloc only if we don't have enough buffer space
            // already
            //
            prl = THReAllocEx(pTHS, prl, dwCurrSize);
            // changed current buffer size
            *pcbPrl = dwCurrSize;
        }
        MoveMemory(prl->V1.rgb, prl->V1.rgb - cbNewFieldsSize,
                   prl->V1.cb - prl->V1.cbOtherDraOffset);

        // Zero out the new fields.
        memset(((BYTE *)prl) + prl->V1.cbOtherDraOffset, 0, cbNewFieldsSize);

        // And reset the embedded offsets and structure size.
        prl->V1.cbOtherDraOffset = offsetof(REPLICA_LINK, V1.rgb);
        prl->V1.cb += cbNewFieldsSize;
        if ( 0 != prl->V1.cbPASDataOffset ) {
            // struct was extended while there's PAS data in it.
            Assert(COUNT_IS_ALIGNED(cbNewFieldsSize, ALIGN_DWORD));
            prl->V1.cbPASDataOffset += cbNewFieldsSize;
        }
    }
    else if ( prl->V1.cbOtherDraOffset != offsetof(REPLICA_LINK, V1.rgb) ) {
            Assert(prl->V1.cbOtherDraOffset == offsetof(REPLICA_LINK, V1.rgb));
            DRA_EXCEPT(DRAERR_InternalError, 0);
    }

    VALIDATE_REPLICA_LINK_VERSION(prl);
    VALIDATE_REPLICA_LINK_SIZE(prl);

    return prl;
}






ULONG
FindDSAinRepAtt(
    DBPOS *                 pDB,
    ATTRTYP                 attid,
    DWORD                   dwFindFlags,
    UUID *                  puuidDsaObj,
    UNALIGNED MTX_ADDR *    pmtxDRA,
    BOOL *                  pfAttExists,
    REPLICA_LINK **         pprl,
    DWORD *                 pcbRL
    )

/*++

Routine Description:

//
// Find the REPLICA_LINK corresponding to the given DRA in the specified
// attribute of the current object (presumably an NC head).
//

Arguments:

    pDB -
    attid -
    dwFindFlags -
    puuidDsaObj -
    pmtxDRA -
    pfAttExists -
    pprl -
    pcbRL -

Return Value:

    ULONG -

--*/

{
    THSTATE        *pTHS=pDB->pTHS;
    ULONG           draError;
    ULONG           dbError;
    DWORD           iVal;
    REPLICA_LINK *  prl;
    DWORD           cbRLSizeAllocated;
    DWORD           cbRLSizeUsed;
    BOOL            fFound;
    BOOL            fAttExists;
    BOOL            fFindByUUID = dwFindFlags & DRS_FIND_DSA_BY_UUID;

    // Does pmtxDRA really need to be UNALIGNED?
    Assert( 0 == ( (DWORD_PTR) pmtxDRA ) % 4 );

    // Validate parameters.
    if ((NULL == pprl)
        || (NULL == pcbRL)
        || (!fFindByUUID && (NULL == pmtxDRA))
        || (fFindByUUID && fNullUuid(puuidDsaObj))) {
        DRA_EXCEPT_NOLOG(DRAERR_InvalidParameter, 0);
    }

    // Find the matching REPLICA_LINK.
    iVal = 1;

    prl               = NULL;
    cbRLSizeUsed      = 0;
    cbRLSizeAllocated = 0;

    fAttExists = FALSE;

    fFound = FALSE;

    do
    {
        // Find the next candidate.
        dbError = DBGetAttVal(
                        pDB,
                        iVal++,
                        attid,
                        DBGETATTVAL_fREALLOC,
                        cbRLSizeAllocated,
                        &cbRLSizeUsed,
                        (BYTE **) &prl
                        );

        if ( 0 == dbError )
        {
            fAttExists = TRUE;

            VALIDATE_REPLICA_LINK_VERSION(prl);

            cbRLSizeAllocated = max( cbRLSizeAllocated, cbRLSizeUsed );

            Assert( prl->V1.cb == cbRLSizeUsed );
            Assert( prl->V1.cbOtherDra == MTX_TSIZE( RL_POTHERDRA( prl ) ) );

            // Does this link match?
            if ( fFindByUUID )
            {
                fFound = !memcmp(puuidDsaObj, &prl->V1.uuidDsaObj, sizeof(UUID));
            }
            else
            {
                fFound = MtxSame( pmtxDRA, RL_POTHERDRA( prl ) );
            }
        }
    } while ( ( 0 == dbError ) && !fFound );

    if (fFound) {
        if (DRS_FIND_AND_REMOVE & dwFindFlags) {
            // Remove this value.
            dbError = DBRemAttVal(pDB, attid, cbRLSizeUsed, prl);

            if (0 == dbError) {
                Assert(pTHS->fDRA);
                dbError = DBRepl(pDB, TRUE, DBREPL_fKEEP_WAIT, NULL,
                                 META_STANDARD_PROCESSING);
            }

            if (0 != dbError) {
                DRA_EXCEPT(DRAERR_DBError, dbError);
            }
        }

        prl = FixupRepsFrom(prl, &cbRLSizeAllocated);
        Assert(cbRLSizeAllocated >= prl->V1.cb);
    }
    else if (NULL != prl) {
        THFree( prl );
        prl = NULL;
        cbRLSizeUsed = 0;
    }

    *pprl  = prl;
    *pcbRL = cbRLSizeUsed;

    if ( NULL != pfAttExists )
    {
        *pfAttExists = fAttExists;
    }

    return fFound ? DRAERR_Success : DRAERR_NoReplica;
}     /* FindDSAinRepAtt */



ULONG
RepErrorFromPTHS(
    THSTATE *pTHS
    )

/*++

Routine Description:

RepErrorFromPTHS - Map a DSA error code into an appropriate DRA error code.
*       The error code is found in pTHS->errCode (which is left unchanged).
*       Note: Many DSA error codes should not occur when DSA routines are used
*       by the DRA, these all return DRAERR_InternalError.
*
*  Note:
*       No Alerts/Audit or Error Log entries are made as it is assumed this
*       has already been done by the appropriate DSA routine.

Arguments:

    pTHS -

Return Value:

    ULONG - The DRA error code.

--*/

{
    UCHAR *pString=NULL;
    DWORD cbString=0;

    // Log the full error details (the error string) in the log if requested
    // The goal is to capture which attribute failed
    // Internal errors are hard to debug so log the info all the time
    if (pTHS->errCode) {
        if(CreateErrorString(&pString, &cbString)) {
            LogEvent( DS_EVENT_CAT_INTERNAL_PROCESSING,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DSA_OBJECT_FAILURE,
                      szInsertSz(pString),
                      szInsertThStateErrCode(pTHS->errCode),
                      NULL );
            THFree(pString);
        }
        DbgPrintErrorInfo();
    }

    switch (pTHS->errCode)
    {
    case 0:
        return 0;

    case attributeError:
        /*  schemas between two dsa dont match. */
        return DRAERR_InconsistentDIT;

    case serviceError:

        switch (pTHS->pErrInfo->SvcErr.problem)
        {
            case SV_PROBLEM_ADMIN_LIMIT_EXCEEDED:
                return DRAERR_OutOfMem;

            case SV_PROBLEM_BUSY:
                switch (pTHS->pErrInfo->SvcErr.extendedErr) {
                case ERROR_DS_OBJECT_BEING_REMOVED:
                    return ERROR_DS_OBJECT_BEING_REMOVED;
                case DIRERR_DATABASE_ERROR:
                    return ERROR_DS_DATABASE_ERROR;
                case ERROR_DS_SCHEMA_NOT_LOADED:
                    return ERROR_DS_SCHEMA_NOT_LOADED;
                case ERROR_DS_CROSS_REF_BUSY:
                    return ERROR_DS_CROSS_REF_BUSY;
                default:
                    return DRAERR_Busy;
                };
                break;

            case SV_PROBLEM_WILL_NOT_PERFORM:
               // possible only if this is a schema NC sync and
               // a schema conflict is detected while validating
                switch (pTHS->pErrInfo->SvcErr.extendedErr) {
                   case ERROR_DS_DRA_SCHEMA_CONFLICT:
                       return DRAERR_SchemaConflict;
                   case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
                       return DRAERR_EarlierSchemaConflict;
                   default:
                       break;
               };
               break;

            default:
                break;
                /* fall through to DRAERR_InternalError */
        }

    }

    /* default */
    /* nameError */
    /* referalError */
    /* securityError */
    /* updError */
    /* None of these should happen to replicator */

    RAISE_DRAERR_INCONSISTENT( pTHS->errCode );

    return 0;
} /* RepErrorFromPTHS */

void ClearBackupState(void);

void
HandleRestore(
    IN PDS_INSTALL_PARAM   InstallInParams  OPTIONAL
    )

/*++

Routine Description:

    If DSA has been restored from backup we need to do some
    special processing, 
    
    There are two things that need to be done:
    
    1)  First we need to change it's replication identity.  This is 
        required so that the changes made by this DC since it was
        backedup will be replicated back.
        
    2)  Second we Invalidate this DCs Rid Range, so that we can avoid
        possible duplicate SIDs during account creation.
        
    One subtlty that may not be obvious, is that continously churning
    the invocation ID can result in our DSA signature growing.  This
    is undesireable, so we lock in Phase I with setting the DitState
    in the hidden table to eRestoredPhaseI if this was a snapshot backup,
    then we're free to attempt phase II, which can be repeated again 
    and again with no negative effects.  
    
//    FUTURE-2002/08/08-BrettSh - Would be desireable to move a legacy 
//    backup to eRestoredPhaseI as well.
    
Arguments:

    void -

Return Value:

    None

--*/

{

    LONG      lret;
    NTSTATUS  NtStatus;
    THSTATE * pTHS = pTHStls;
    DITSTATE  eDitState = eMaxDit;
    DSTIME llExpiration = 0;
    CHAR buf1[SZDSTIME_LEN + 1];
#if DBG
    CHAR      szUuid[SZUUID_LEN];
#endif

    // In all cases we initialize our restore count.
    if (GetConfigParam(DSA_RESTORE_COUNT_KEY, &gulRestoreCount, sizeof(gulRestoreCount)))
    {
        // registry entry for restore count doesn't exist
        // set it to 1
        gulRestoreCount = 0;
    }
    
    // Do the easy cases first
    if ( !DsaIsInstallingFromMedia() && DsaIsInstalling()  ||
         !gfRestoring ){
        // Nothing to do if not installed or not restoring a backup.
        // FUTURE-2002/08/09-BrettSh The first clause "!DsaIsInstallingFromMedia() && DsaIsInstalling()"
        // should never be true without gfRestoring being true, I don't have the guts to change it this
        // late in the product, but I'm 97% sure of it.
        gUpdatesEnabled = TRUE;
        return;
    }

    Assert(gfRestoring);
    
    //
    // Increment restore count to signify the current restore
    //
    gulRestoreCount++;

    // write the new restore count into the registry
    if (lret = SetConfigParam(DSA_RESTORE_COUNT_KEY, REG_DWORD, &gulRestoreCount, sizeof(gulRestoreCount)))
    {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }

    if (lret = DBGetHiddenState(&eDitState)) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }
    Assert(eDitState != eMaxDit);

    //            
    // We're (snapshot) backed up, or only got partially through restore on the 
    // last boot, check the backup expiration.
    //
    if (eDitState == eBackedupDit ||
        eDitState == eRestoredPhaseI) {

        lret = DBGetOrResetBackupExpiration(&llExpiration);
        if (lret) {
            DPRINT1(0, "Bad return %d from DBCheckOrResetackupExpiration()...exit\n", lret);
            LogAndAlertUnhandledError(lret);
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }
        if (GetSecondsSince1601() > llExpiration) {
            //
            // Uh-oh! Expired backup.
            //
            Assert(llExpiration != 0);
            LogEvent(DS_EVENT_CAT_BACKUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_BACKUP_SNAPSHOT_TOO_OLD,
                     szInsertDSTIME( llExpiration, buf1 ),
                     NULL, NULL );
            DRA_EXCEPT (DRAERR_InternalError, ERROR_INVALID_PARAMETER);
        }
    }

    if (eDitState != eRestoredPhaseI) {

        //
        // Phase I of Restore! 
        //
        Assert(eDitState == eBackedupDit || // snapshot restore
               eDitState == eRunningDit ||  // legacy restore
               eDitState == eIfmDit);       // IFM

        // Do the DRA retire invoc ID.
        // Retire invocation id

        if (DsaIsInstallingFromMedia()) {
            Assert(InstallInParams);

            // Note: In the case of DsaIsInstallingFromMedia() this function
            // is a bit of a misnomer, because in draRetireInvocationID() the
            // invocation  ID in the db WILL NOT be changed here, because the
            // Invocation ID and active DSA object right now, is that of the
            // original backed up DSA that may still exist and doesn't want 
            // to change his invocation ID. The invocation ID in memory WILL
            // be changed (pTHS->InvocationID and gAnchor->InvocationID).

            // FUTURE-2002/08/09-BrettSh - After investigating this code thoroughly
            // it turns out that very very little of the code in this function
            // path is used for IFM, and the code is grossly complicated by the
            // IFM clauses, it would be a good idea to decouple IFM from this
            // function.
            
            draRetireInvocationID(pTHS,
                  TRUE, // restoring from the backup of the media
                                  &(InstallInParams->InvocationIdOld),
                                  &(InstallInParams->UsnAtBackup) );
            DPRINT2(1, "Saving away previous invocation ID %s and USN %I64d.\n",
                    DsUuidToStructuredString(&(InstallInParams->InvocationIdOld), szUuid),
                    InstallInParams->UsnAtBackup );
            Assert( InstallInParams->UsnAtBackup < gusnDSAStarted );
        } else {
            USN usnAtBackup;

            draRetireInvocationID(pTHS, TRUE, NULL, &usnAtBackup );

            // Assert that in a retiring caused by a restore (as opposed to an NDNC hosting)
            // the usnAtBackup is guaranteed to be less than the initial USN in the
            // hidden record.
            Assert( usnAtBackup < gusnDSAStarted );
        }

        DPRINT(0, "DS has been restored from a backup.\n");

        // At this point we have loaded the schema successfully and have given the DS a new
        // replication identity. We can enable updates now
    } else {
        Assert(!fNullUuid(&(pTHS->InvocationID))); // Should've been set by gAnchor load.
    }

    // Restore Phase I is done, we can enable updates.  We can enable updates before
    // we invalidate the rid range, because Sam won't start taking updates until
    // DsInitialize() comes back which we're in.
    gUpdatesEnabled = TRUE;


    //
    // Phase II of Restore
    //

    if ( !DsaIsInstallingFromMedia() ) {

        // Invalidate the RID range that came from backup to avoid possible duplicate account
        // creation
        NtStatus = SampInvalidateRidRange(TRUE);
        if (!NT_SUCCESS(NtStatus))
        {
            DRA_EXCEPT (DRAERR_InternalError, NtStatus);
        }
    }

    // Note: rsraghav We don't treat restore any different from a system
    // being down and rebooted for FSMO handling. When rebooted, if we hold
    // the FSMO role ownership, we will refuse to assume role ownership until
    // gfIsSynchronized is set to true (i.e. we have had the chance
    // to sync with at least one neighbor for each writeable NC)
    // Only exception is FSMO role ownership for PDCness. As MurliS
    // pointed out, incorrect FSMO role ownership for PDCness is self-healing
    // when replication kicks-in and is not necessarily damaging. So, we
    // don't do anything special to avoid PDCness until gfIsSynchronized
    // is set to TRUE.

    //
    // Record completion of Phase I && II of restore in the registry
    // and the DitState of the hidden table as necessary.
    //
    ClearBackupState();

    // Finished handling restore
    gfRestoring = FALSE;
    gfJustRestored = TRUE;

} /* HandleRestore */

void
ClearBackupState(
    void
    )
/*++

Routine Description:

    This simply clears all the backup state.
    
    If we fail here, unfortunately we will retry the restore operation. In
    the case of a snapshot restore this is not a problem, because we'll skip
    the retiring of the invocation ID, re-invalidate our RID pool, and go on.
    In the case of a legacy restore, we'll retire our newer invocation ID 
    and DSA signature will have a unnecessary entry.  If errors are persistent
    this could cause a problem.

Return Value:

    excepts on errors...   

--*/
{
    LONG      lret;
    HKEY      hk;
    DITSTATE  eDitState = eMaxDit;
    
    if (lret = DBGetHiddenState(&eDitState)) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }                                           
    Assert(eDitState == eRunningDit ||   // legacy restore or IFM
           eDitState == eBackedupDit ||  // snapshot IFM (because InitInvocationID() didn't set to eRestoredPhaseI in IFM)
           eDitState == eRestoredPhaseI ||
           eDitState == eIfmDit); // snapshot regular restore
    
    if (eDitState == eBackedupDit || 
        eDitState == eRestoredPhaseI) {
                                   
        //
        // Finally commit the snapshot restore to the running state
        //
        lret = DBReplaceHiddenTableBackupCols(FALSE, FALSE, TRUE, 0, 0);
        if (lret) {
            DRA_EXCEPT (DRAERR_InternalError, lret);
        }

    }

    // Clear restore key value
    lret = RegCreateKey(HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        &hk);

    if (lret != ERROR_SUCCESS) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }
    // Clear key value

    lret = RegDeleteValue(hk, DSA_RESTORED_DB_KEY);
    if (lret != ERROR_SUCCESS &&
        // This clause means we are a pure (non-IFM) snapshot restore, and therefore
        // there was  no DSA_RESTORED_DB_KEY registry key to delete.
        !( lret == ERROR_FILE_NOT_FOUND &&
           (eDitState == eBackedupDit ||
            eDitState == eRestoredPhaseI) &&
           !DsaIsInstallingFromMedia() )
        ) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }

    lret = RegFlushKey (hk);
    if (lret != ERROR_SUCCESS) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }

    // Close key
    lret = RegCloseKey(hk);
    if (lret != ERROR_SUCCESS) {
        DRA_EXCEPT (DRAERR_InternalError, lret);
    }

}

DWORD
DirReplicaSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength
    )

/*++

Routine Description:

    Description

Arguments:

    ClientToken - the caller who presented the user/domain/password set
    User -
    Domain -
    Password -
    PasswordLength -

Return Value:

    DWORD -

--*/

{
    return DRSSetCredentials(ClientToken,
                             User, 
                             Domain, 
                             Password, 
                             PasswordLength);
} /* DirReplicaSetCredentials */

#if 0
void
DraDumpAcl (
            char *name,
            PACL input
            )
/*++
Description:

    Dump the contents of an acl (sacl or dacl) to the kernel debugger.
    This is a utility debug routine that might be of use in the future.

Arguments:

Return Values:

--*/
{
    ULONG i;
    ACL *acl = input;

    if (acl == NULL) {
        KdPrint(( "%s Acl is null\n", name ));
        return;
    } else {
        KdPrint(( "%s Acl:\n", name ));
    }

    KdPrint(( "\tRevision: %d\n", acl->AclRevision ));
    KdPrint(( "\tSbz1: %d\n", acl->Sbz1 ));
    KdPrint(( "\tSize: %d\n", acl->AclSize ));
    KdPrint(( "\tNo of Aces: %d\n", acl->AceCount ));
    KdPrint(( "\tSbz2: %d\n", acl->Sbz2 ));
    if (acl->AclSize == 0) {
        return;
    }
    if (acl->AceCount > 10) {
        KdPrint(("Ace Count illegal - returning\n"));
        return;
    }

    for( i = 0; i < acl->AceCount; i++ ) {
        ACE_HEADER *ace;
        KdPrint(( "\tAce %d:\n", i ));
        if (GetAce( input, i, &ace )) {
            KdPrint(( "\t\tType: %d\n", ace->AceType ));
            KdPrint(( "\t\tSize: %d\n", ace->AceSize ));
            KdPrint(( "\t\tFlags: %x\n", ace->AceFlags ));
            if (ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE) {
                ACCESS_ALLOWED_ACE *ace_to_dump = (ACCESS_ALLOWED_ACE *) ace;
                KdPrint(( "\t\tAccess Allowed Ace\n" ));
                KdPrint(( "\t\t\tMask: %x\n", ace_to_dump->Mask ));
                KdPrint(( "\t\t\tSid: %x\n", IsValidSid((PSID) &(ace_to_dump->SidStart)) ));
            } else {
                ACCESS_ALLOWED_OBJECT_ACE *ace_to_dump = (ACCESS_ALLOWED_OBJECT_ACE *) ace;
                PBYTE ptr = (PBYTE) &(ace_to_dump->ObjectType);
                KdPrint(( "\t\tAccess Allowed Object Ace\n" ));
                KdPrint(( "\t\t\tMask: %x\n", ace_to_dump->Mask ));
                KdPrint(( "\t\t\tFlags: %x\n", ace_to_dump->Flags ));

                if (ace_to_dump->Flags & ACE_OBJECT_TYPE_PRESENT)
                {
                    ptr += sizeof(GUID);
                }

                if (ace_to_dump->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
                {
                    ptr += sizeof(GUID);
                }
                KdPrint(( "\t\t\tSid: %x\n", IsValidSid( (PSID)ptr ) ));
            }
        }
    }
} /* DumpAcl */
#endif


MTX_ADDR *
MtxAddrFromTransportAddr(
    IN  LPWSTR    psz
    )
/*++

Routine Description:

    Convert Unicode string to an MTX_ADDR.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    psz (IN) - String to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR, or NULL on failure.

--*/
{
    THSTATE *  pTHS = pTHStls;
    MTX_ADDR * pmtx;

    Assert(NULL != pTHS);

    __try {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, psz);
    }
    __except(HandleMostExceptions(GetExceptionCode())) {
        pmtx = NULL;
    }

    return pmtx;
}


MTX_ADDR *
MtxAddrFromTransportAddrEx(
    IN  THSTATE * pTHS,
    IN  LPWSTR    psz
    )
/*++

Routine Description:

    Convert Unicode string to an MTX_ADDR.

Arguments:

    pTHS (IN)

    psz (IN) - String to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR.  Throws exception on failure.

--*/
{
    DWORD       cch;
    MTX_ADDR *  pmtx;

    Assert(NULL != psz);

    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, NULL, 0, NULL, NULL);
    if (0 == cch) {
        DRA_EXCEPT(DRAERR_InternalError, GetLastError());
    }

    // Note that cch includes the null terminator, whereas MTX_TSIZE_FROM_LEN
    // expects a count that does *not* include the null terminator.

    pmtx = (MTX_ADDR *) THAllocEx(pTHS, MTX_TSIZE_FROM_LEN(cch - 1));
    pmtx->mtx_namelen = cch;

    cch = WideCharToMultiByte(CP_UTF8, 0L, psz, -1, pmtx->mtx_name, cch, NULL,
                              NULL);
    if (0 == cch) {
        DRA_EXCEPT(DRAERR_InternalError, GetLastError());
    }

    Assert(cch == pmtx->mtx_namelen);
    Assert(L'\0' == pmtx->mtx_name[cch - 1]);

    return pmtx;
}


LPWSTR
TransportAddrFromMtxAddr(
    IN  MTX_ADDR *  pmtx
    )
/*++

Routine Description:

    Convert MTX_ADDR to a Unicode string.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    pmtx (IN) - MTX_ADDR to convert.

Return Values:

    A pointer to the equivalent MTX_ADDR, or NULL on failure.

--*/
{
    THSTATE * pTHS = pTHStls;
    LPWSTR    psz;

    Assert(NULL != pTHS);

    __try {
        psz = UnicodeStringFromString8(CP_UTF8, pmtx->mtx_name, -1);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        psz = NULL;
    }

    return psz;
}


LPWSTR
GuidBasedDNSNameFromDSName(
    IN  DSNAME *  pDN
    )
/*++

Routine Description:

    Convert DSNAME of ntdsDsa object to its GUID-based DNS name.

    EXPORTED TO IN-PROCESS, EX-MODULE CLIENTS (e.g., the KCC).

Arguments:

    pDN (IN) - DSNAME to convert.

Return Values:

    A pointer to the DNS name, or NULL on failure.

--*/
{
    LPWSTR psz;

    __try {
        psz = DSaddrFromName(pTHStls, pDN);
    }
    __except (HandleMostExceptions(GetExceptionCode())) {
        psz = NULL;
    }

    return psz;
}

DSNAME *
DSNameFromAddr(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszAddr
    )
/*++

Routine Description:

    (Analogous to DSaddrFromName() and GuidBasedDNSNameFromDSName())

    Create a DSName from a ds address.  Ds addresses are of the form:

    c330a94f-e814-11d0-8207-a69f0923a217._msdcs.CLIFFVDOM.NTDEV.MICROSOFT.COM

    where "CLIFFVDOM.NTDEV.MICROSOFT.COM" is the DNS name of the root domain of
    the DS enterprise (not necessarily the DNS name of the _local_ domain of the
    target server) and "c330a94f-e814-11d0-8207-a69f0923a217" is the stringized
    object guid of the server's NTDS-DSA object.  

Arguments:

    pszAddr - the guid base ds address

Return Values:

    The corresponding dsname (may not have a dn if unknown to the local config).

--*/
{

    GUID uuidTemp;
    DSNAME * pServer = NULL;
     
    Assert(pszAddr && wcschr(pszAddr, L'.'));

    if ( DSAGuidFromGuidDNSName(pszAddr, &uuidTemp, NULL, TRUE) ) {
        pServer = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, &uuidTemp);
    } else {
        Assert(!"This DNS name wasn't a GUID based DNS name, this code will need to be improved");
        // Code.Improvement ... it'd be cool if we got a real servername to 
        // basically go search the AD (CN=Sites,CN=Configuration,etc) for 
        // computer objects with a match dNSHostName attribute, and then see
        // if they have a valid NtdsNtdsa object below them.
    }

    return pServer;
}

#define wcsprefix(arg, target)  (0 == _wcsnicmp((arg), (target), wcslen(target)))


BOOL
DSAGuidFromGuidDNSName(
    LPWSTR  pszAddr,
    GUID *  pGuidOut OPTIONAL,
    LPWSTR  pszGuidOut OPTIONAL,
    BOOL    fSkipRootDomainCheck
    )
/*++

Routine Description:

    Given a random transport (DNS) name, see if it's a valid guid-based dns name.  

Arguments:

    pszAddr - the name in question
    pGuidOut - if there, put the binary form of the guid in this buffer - must be sizeof(GUID) or bigger
    pszGuidOut - if there, copy in the sting of the guid - must be SZGUIDLEN+1 or bigger
    fSkipRootDomainCheck - Always set to FALSE for new cases.
    
    // NTRAID#NTRAID-727455-2002/10/24-BrettSh
    // It's late in .NET's shipping time, this function is used in about 5 places, bugs
    // are really hard to get in, so we're going to be lame, and simply dis-allow the
    // additional checks that we should've been doing all along.  All new uses really 
    // should set this fSkipRootDomainCheck to FALSE.

Return Values:

    TRUE if guid base dns name, FALSE otherwise

--*/
{
    GUID uuidTemp;
    RPC_STATUS rpcStatus;
    WCHAR pszGuid[SZGUIDLEN + 1];
    LPWSTR pszDomainAddr = NULL;
    BOOL fHasGuid = FALSE;
    LPWSTR pszGuidUse = pszGuidOut ? pszGuidOut : pszGuid;
     
    Assert(gAnchor.pwszRootDomainDnsName);
    if (pszAddr==NULL) {
        return fHasGuid;
    }

    pszDomainAddr = wcschr(pszAddr, L'.');
    if (pszDomainAddr==NULL) {
        return fHasGuid;
    }

    // is this a guid based name?  try and get the guid off the front
    memcpy(pszGuidUse, pszAddr, (min(wcslen(pszAddr) - wcslen(pszDomainAddr), SZGUIDLEN))*sizeof(WCHAR));
    pszGuidUse[SZGUIDLEN] = L'\0';

    rpcStatus = UuidFromStringW(pszGuidUse, pGuidOut ? pGuidOut : &uuidTemp);
    
    if (rpcStatus==RPC_S_OK) {

        if( fSkipRootDomainCheck ||
            
            ( ( wcsprefix(pszDomainAddr, L"._msdcs.") ) &&
              ( NULL != (pszDomainAddr = wcschr(pszDomainAddr+1, L'.')) ) &&
              ( DnsNameCompare_W(pszDomainAddr+1, gAnchor.pwszRootDomainDnsName) )
              )

            ) {
            fHasGuid = TRUE;
        } else {
            Assert(!"Huh, not a full guid based DNS name");
        }

    } else {
        fHasGuid = FALSE;
    }

    return fHasGuid;
}

BOOL
IsEqualGuidAddr(
    WCHAR *     szAddr,
    GUID *      pGuid
    )
/*++

Routine Description:

    Checks if the GUID provided (pGuid) matches the guid in the Guid based DNS name (szAddr)

Arguments:

    szAddr - the name in question
    pGuid - the GUID we should look for in szAddr.

Return Values:

    TRUE if this GUID based DNS name is matching pGuid, FALSE otherwise

--*/
{
    GUID TheGuid;
    WCHAR * szPeriod;

    if ((szAddr == NULL) ||
        (szAddr[0] == L'\0') ||
        (pGuid == NULL)) {
        Assert(!"No no, always pass something, can't tell if NULL is our address or not?");
        return(FALSE);
    }

    if( DSAGuidFromGuidDNSName(szAddr, &TheGuid, NULL, FALSE) &&
        (0 == memcmp(&TheGuid, pGuid, sizeof(GUID))) ){
        return(TRUE);
    }

    return(FALSE);
}


DSNAME *
DSNameFromStringW(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszDN
    )
{
    DWORD     cch;
    DWORD     cb;
    DSNAME *  pDSName;

    Assert(NULL != pszDN);

    cch = wcslen(pszDN);
    cb = DSNameSizeFromLen(cch);

    pDSName = THAllocEx(pTHS, cb);
    pDSName->structLen = cb;
    pDSName->NameLen = cch;
    memcpy(pDSName->StringName, pszDN, cch * sizeof(WCHAR));

    return pDSName;
}


DSNAME *
DSNameFromStringA(
    IN  THSTATE *   pTHS,
    IN  LPSTR       pszDN
    )
{

    ULONG cchDN = 0;
    LPWSTR pszDNW = NULL;
    DSNAME * pReturnName = NULL;

    Assert(pszDN!=NULL);

    if (pszDN==NULL) {
	return NULL; 
    } else {

	cchDN = strlen(pszDN);

	// get enough space to cover the string and a trailing null
	pszDNW = THAllocEx(pTHS, (cchDN + 1) * sizeof(WCHAR));
	
	if (!MultiByteToWideChar(CP_ACP, 
				 0,
				 pszDN,
				 (cchDN+1)*sizeof(CHAR),
				 pszDNW,
				 cchDN+1
				 )) {
	    Assert(!"Cannot convert to wide characters!");
	    THFreeEx(pTHS, pszDNW); 
	    return NULL;
	}

	pReturnName = DSNameFromStringW(pTHS,pszDNW); 
	THFreeEx(pTHS, pszDNW);
    }
    return pReturnName;
}

DWORD
AddSchInfoToPrefixTable(
    IN THSTATE *pTHS,
    IN OUT SCHEMA_PREFIX_TABLE *pPrefixTable
    )
/*++
    Routine Description:
       Read the schemaInfo property on the schema container and add it
       to the end of the prefix table as an extra prefix

       NOTE: This is called from the rpc routines to piggyback the
             schema info on to the prefix table. However, the prefix table
             is passed to these routine from the dra code by value, and not
             by var (that is, the structure is passed itself, not a pointer
             to it). The structure is picked up from the thread state's
             schema pointer. So, when we add the new prefix, we have to
             make sure it affects only this routine, and doesn't mess up
             memory pointed to by global pointers accessed by this structure.
             In short, do not allocate the SCHEMA_PREFIX_TABLE structure
             itself (since the function has a copy of the global structure and
             not the global structure itself), but fresh-alloc and copy
             any other pointer in it

    Arguments:
       pTHS: pointer to thread state to get schema pointer (to get schema info
             from
       pPrefixTable: pointer the SCHEMA_PREFIX_TABLE to modify

   Return Value:
       0 on success, non-0 on error
--*/
{
    DWORD err=0, i;
    DBPOS *pDB;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    ULONG cLen, cBuffLen = SCHEMA_INFO_LENGTH;
    UCHAR *pBuf = THAllocEx(pTHS,SCHEMA_INFO_LENGTH);
    PrefixTableEntry *pNewEntry, *pSrcEntry;

    // Read the schema info property from the schema container
    // Since we are sending changes from the dit, send the schemaInfo
    // value from the dit even though we have a cached copy in schemaptr

    DBOpen2(TRUE, &pDB);

    __try  {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = ERROR_DS_MISSING_EXPECTED_ATT;
                __leave;
            }
            // Read the current version no., if any
            err = DBGetAttVal_AC(pDB, 1, ac, DBGETATTVAL_fCONSTANT,
                                 cBuffLen, &cLen, (UCHAR **) &pBuf);

            switch (err) {
                case DB_ERR_NO_VALUE:
                   // we will send a special string starting with
                   // value 0xFF, no valid schemainfo value can be
                   // this (since they start with 00)
                   memcpy(pBuf, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH);
                   cLen = SCHEMA_INFO_LENGTH;
                   err = 0;
                   break;
                case 0:
                   // success! we got the value in Buffer
                   Assert(cLen == SCHEMA_INFO_LENGTH);
                   //
                   // Compare DIT & cache schema info. Reject if no match
                   // schema mismatch (see bug Q452022)
                   //
                   if (memcmp(pBuf, ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo, SCHEMA_INFO_LENGTH)) {
                       // mismatch
                       err = DRAERR_SchemaInfoShip;
                       __leave;
                   }
                   break;
                default:
                   // Some other error!
                   __leave;
            } /* switch */
       }
    }
    __finally {
        if (err == 0) {
           fCommit = TRUE;
        }
        DBClose(pDB,fCommit);
    }

    if (err) {

       THFreeEx(pTHS,pBuf);
       return err;
    }

    // No error. Add the schemainfo as an extra prefix
    // First, save off the pointer to the existing prefixes so that it is
    // still accessible to copy from

    pSrcEntry = pPrefixTable->pPrefixEntry;


    // Now allocate space for new prefix entries, which is old ones plus 1
    pPrefixTable->pPrefixEntry =
         (PrefixTableEntry *) THAllocEx(pTHS, (pPrefixTable->PrefixCount + 1)*(sizeof(PrefixTableEntry)) );
    if (!pPrefixTable->pPrefixEntry) {
        MemoryPanic((pPrefixTable->PrefixCount + 1)*sizeof(PrefixTableEntry));
        return ERROR_OUTOFMEMORY;
    }

    pNewEntry = pPrefixTable->pPrefixEntry;

    // Copy the existing prefixes, if any
    if (pPrefixTable->PrefixCount > 0) {
        for (i=0; i<pPrefixTable->PrefixCount; i++) {
            pNewEntry->ndx = pSrcEntry->ndx;
            pNewEntry->prefix.length = pSrcEntry->prefix.length;
            pNewEntry->prefix.elements = THAllocEx(pTHS, pNewEntry->prefix.length);
            if (!pNewEntry->prefix.elements) {
                MemoryPanic(pNewEntry->prefix.length);
                return ERROR_OUTOFMEMORY;
            }
            memcpy(pNewEntry->prefix.elements, pSrcEntry->prefix.elements, pNewEntry->prefix.length);
            pNewEntry++;
            pSrcEntry++;
        }
    }

    // copy schema info as the extra prefix. ndx field is not important
    pNewEntry->prefix.length = SCHEMA_INFO_LENGTH;
    pNewEntry->prefix.elements = THAllocEx(pTHS, SCHEMA_INFO_LENGTH);
    if (!pNewEntry->prefix.elements) {
        MemoryPanic(SCHEMA_INFO_LENGTH);
        return ERROR_OUTOFMEMORY;
    }
    Assert(cLen == SCHEMA_INFO_LENGTH);
    memcpy(pNewEntry->prefix.elements, pBuf, SCHEMA_INFO_LENGTH);
    pPrefixTable->PrefixCount++;

    THFreeEx(pTHS,pBuf);
    return 0;
}

VOID
StripSchInfoFromPrefixTable(
    IN SCHEMA_PREFIX_TABLE *pPrefixTable,
    OUT PBYTE pSchemaInfo
    )
/*++
    Routine Description:
       Strip the last prefix from the prefix table and copy it to
       the schema info pointer

    Arguments:
       pPrefixTable: pointer the SCHEMA_PREFIX_TABLE to modify
       pSchemaInfo: Buffer to hold the schema info. Must be pre-allocated
                     for SCHEMA_INFO_LEN bytes

   Return Value:
       None
--*/
{

    // Must be at least one prefix (the schemaInfo itself)
    Assert(pPrefixTable && pPrefixTable->PrefixCount > 0);

    memcpy(pSchemaInfo, (pPrefixTable->pPrefixEntry)[pPrefixTable->PrefixCount-1].prefix.elements, SCHEMA_INFO_LENGTH);
    pPrefixTable->PrefixCount--;

    // no need to actually take the prefix out, the decrement in prefix count
    // will cause it to be ignored.
}

#define ZeroString "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"

// DO NOT CHANGE THE ORDER OF THE PARAMS TO memcmp!
#define NEW_SCHEMA_IS_BETTER(_newver, _curver, _newinfo, _curinfo) \
    (   (_newver > _curver) \
     || ((_newver == _curver) && (memcmp(_curinfo, _newinfo, SCHEMA_INFO_LENGTH) > 0)) )

BOOL
CompareSchemaInfo(
    IN THSTATE *pTHS,
    IN PBYTE pSchemaInfo,
    OUT BOOL *pNewSchemaIsBetter OPTIONAL
    )
/*++
    Routine Description:
       Compares the passed in schema info blob with the schema info on
       the schema container

    Arguments:
       pTHS: pointer to thread state to get schema pointer (to get schema info
             from
       pSchemaInfo: pointer the schema info blob of size SCHEMA_INFO_LENGTH
       pNewSchemaIsBetter - If not NULL, then if this function returns
           FALSE then *pNewSchemaIsBetter is set to
               TRUE  - New schema is "better" than current schema
               FALSE - New schema is not better than current schema
           If NULL, it is ignored.
           If this funtion returns TRUE, it is ignored.

    Return Value:
       TRUE if matches, FALSE if not

       If FALSE and pNewSchemaIsBetter is not NULL then *pNewSchemaIsBetter is set to
           TRUE  - New schema is "better" than current schema
           FALSE - New schema is not better than current schema
--*/
{
    DWORD err=0;
    DWORD currentVersion, newVersion;
    BOOL fNoVal = FALSE;

    DPRINT(1,"Comparing SchemaInfo values\n");

    // must have a schema info passed in
    Assert(pSchemaInfo);

    if ( memcmp(pSchemaInfo, ZeroString, SCHEMA_INFO_LENGTH) == 0 ) {
       // no schema info value. The other side probably doesn't support
       // sending the schemaInfo value
       return TRUE;
    }

    // Compare the schemaInfo with the schemaInfo cached in the schema pointer
    // Note that if schemaInfo attribute is not present on the schema container
    // the default invalid info is already cached.
    // It is probably more accurate to read the schemaInfo off the dit
    // and compare, but we save a database access here. The only bad effect
    // of using the one in the cache is that if schema changes are going
    // on, this may be stale, giving false failures. Since schema changes
    // are rare, most of the time this will be uptodate.

    if (memcmp(pSchemaInfo, ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo, SCHEMA_INFO_LENGTH)) {
        // mismatch

        // If requested, determine if new schema is better (greater
        // version or versions match but new guid is lesser) than the
        // current schema.
        if (pNewSchemaIsBetter) {
            // Must be DWORD aligned for ntohl
            memcpy(&newVersion, &pSchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(newVersion));
            newVersion = ntohl(newVersion);
            memcpy(&currentVersion, &((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(currentVersion));
            currentVersion = ntohl(currentVersion);
            *pNewSchemaIsBetter = NEW_SCHEMA_IS_BETTER(newVersion,
                                                       currentVersion,
                                                       pSchemaInfo,
                                                       ((SCHEMAPTR *)pTHS->CurrSchemaPtr)->SchemaInfo);
        }
        return FALSE;
    }

    // matches
    return TRUE;
}


DWORD
WriteSchInfoToSchema(
    IN PBYTE pSchemaInfo,
    OUT BOOL *fSchInfoChanged
    )
{
    DBPOS *pDB;
    DWORD err=0, cLen=0;
    ATTCACHE* ac;
    BOOL fCommit = FALSE;
    UCHAR *pBuf=NULL;
    DWORD currentVersion, newVersion;
    THSTATE *pTHS;
    BOOL fChanging = FALSE;

    // must have a schema info passed in
    Assert(pSchemaInfo);

    (*fSchInfoChanged) = FALSE;

    if ( (memcmp(pSchemaInfo, ZeroString, SCHEMA_INFO_LENGTH) == 0)
           || (memcmp(pSchemaInfo, INVALID_SCHEMA_INFO, SCHEMA_INFO_LENGTH) == 0) ) {
       // no schema info value, or invalid schema info value. The other side
       // probably doesn't support sending the schemaInfo value, or doesn't
       // have a schema info value
       return 0;
    }


    DBOpen2(TRUE, &pDB);
    pTHS=pDB->pTHS;

    __try  {
        // PREFIX: dereferencing uninitialized pointer 'pDB'
        //         DBOpen2 returns non-NULL pDB or throws an exception
        if ( (err = DBFindDSName(pDB, gAnchor.pDMD)) ==0) {

            ac = SCGetAttById(pTHS, ATT_SCHEMA_INFO);
            if (ac==NULL) {
                // messed up schema
                err = DB_ERR_ATTRIBUTE_DOESNT_EXIST;
                __leave;
            }

            // Get the current schema-info value

            currentVersion = 0;
            err = DBGetAttVal_AC(pDB, 1, ac, 0, 0, &cLen, (UCHAR **) &pBuf);

            switch (err) {
                case DB_ERR_NO_VALUE:
                   // no current version, nothing to do
                   break;
                case 0:
                   // success! we got the value in Buffer
                   Assert(cLen == SCHEMA_INFO_LENGTH);
                   // Read the version no. Remember that the version is stored
                   // in network data format (ntohl requires DWORD alignment)
                   memcpy(&currentVersion, &pBuf[SCHEMA_INFO_PREFIX_LEN], sizeof(currentVersion));
                   currentVersion = ntohl(currentVersion);
                   break;
                default:
                   // Some other error!
                   __leave;
            } /* switch */

            memcpy(&newVersion, &pSchemaInfo[SCHEMA_INFO_PREFIX_LEN], sizeof(newVersion));
            newVersion = ntohl(newVersion);
            DPRINT2(1, "WriteSchInfo: CurrVer %d, new ver %d\n", currentVersion, newVersion);

            if ( NEW_SCHEMA_IS_BETTER(newVersion,
                                      currentVersion,
                                      pSchemaInfo,
                                      pBuf) ) {
               // Either we are backdated, or the versions are the same, but
               // the whole value is defferent (this second case is possible
               // under bad FSMO whacking scenarios only). Write the value,
               // the higher guid being the tiebreaker

               fChanging = TRUE;

               if ((err= DBRemAtt_AC(pDB, ac)) != DB_ERR_SYSERROR) {
                   err = DBAddAttVal_AC(pDB, ac, SCHEMA_INFO_LENGTH, pSchemaInfo);
               }
               if (!err) {
                  err = DBRepl( pDB, FALSE, 0, NULL, META_STANDARD_PROCESSING );
               }
            }

       }
       if (0 == err) {
         fCommit = TRUE;
       }
    }
    __finally {
        DBClose(pDB,fCommit);
    }

    if (fChanging && !err) {
       // We attempted to change the schInfo value and succeeded
       (*fSchInfoChanged) = TRUE;
    }
    else {
       (*fSchInfoChanged) = FALSE;
    }

    return err;
}

VOID
draGetLostAndFoundGuid(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    OUT GUID *      pguidLostAndFound
    )
/*++

Routine Description:

    Retrieves the objectGuid of the LostAndFound container for the given NC.

Arguments:

    pTHS (IN)

    pNC (IN) - NC for which to retrieve LostAndFound container.

    pguidLostAndFound (OUT) - On return, holds the objectGuid of the
        appropriate LostAndFound container.  Caller allocated.

Return Values:

    None.  Throws DRA exception on catastrophic failure.

--*/
{
    ULONG     ret;
    DBPOS *   pDBTmp;
    BOOL      fFoundLostAndFound, fObject;
    DWORD     dntLostAndFound = 0;

    // First we try the most common/speedy case, which is
    // that the WellKnown attribute exists and has an entry
    // for the "Lost And Found" container.
    
    DBOpen(&pDBTmp);
    __try {

        // Set currency on the NC so we can pull off the GetWellKnownDNT.
        ret = DBFindDSName(pDBTmp, pNC);
        if (ret) {
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }

        fFoundLostAndFound = GetWellKnownDNT(pDBTmp,
                                             (GUID *)GUID_LOSTANDFOUND_CONTAINER_BYTE,
                                             &dntLostAndFound);

        if(fFoundLostAndFound){
            // Success!
            Assert(dntLostAndFound);

            ret =  DBFindDNT(pDBTmp, dntLostAndFound);
            if(ret == 0){
                // Success!

                // We've positioned on the DNT, now check to make
                // sure it's not a phantom!
                fObject = DBCheckObj(pDBTmp);
                if(fObject){
                    // Success!
                    // get the GUID of lost and found
                    ret = DBGetSingleValue(pDBTmp,
                                           ATT_OBJECT_GUID,
                                           pguidLostAndFound,
                                           sizeof(*pguidLostAndFound),
                                           NULL);
                    if(ret == 0){
                        // Finally, Success, leave.
                        __leave;
                    }
                } else {
                    ret = ERROR_DS_NOT_AN_OBJECT;
                }
            }
        } else {
            ret = ERROR_DS_NO_REQUESTED_ATTS_FOUND;
        }

        // If we got down here all our attempts failed, so except out.
        if(ret){
            DRA_EXCEPT(DRAERR_InternalError, ret);
        }

    } __finally {
        DBClose(pDBTmp, TRUE);
    }
    
}


DSNAME *
draGetServerDsNameFromGuid(
    IN THSTATE *pTHS,
    IN eIndexId idx,
    IN UUID *puuid
    )

/*++

Routine Description:

    Return the dsname of the object identified by the given invocation id
    or objectGuid.  The object is searched on the local configuration NC.
    It is possible that the invocation id or objectGuid refers to an
    unknown server, either because we haven't yet heard of it or the
    knowledge of the guid has since been lost.  In this case a guid-only
    dsname is returned.

    The DSNAME returned is suitable for use by szInsertDN(). If you're logging
    a DSNAME and the DSNAME has only a guid, szInsertDN() will insert the
    stringized guid.  

Arguments:

    pTHS - thread state
    idx - index on which to look for guid (Idx_InvocationId or Idx_ObjectGuid)
    puuid - invocation id or objectGuid

Return Value:

    Pointer to thread allocated storage containing a dsname.  On success,
    the dsname contains a guid and a string. On error, the dsname contains
    only the guid.
--*/

{
    DBPOS *pDBTmp = NULL;
    ULONG ret, cb;
    INDEX_VALUE IV;
    DSNAME *pDN = NULL;
    LPWSTR pszServerName;

    Assert(!fNullUuid(puuid));

    DBOpen(&pDBTmp);
    __try {
        ret = DBSetCurrentIndex(pDBTmp, idx, NULL, FALSE);
        if (ret) {
            __leave;
        }
        IV.pvData = puuid;
        IV.cbData = sizeof(UUID);
        
        ret = DBSeek(pDBTmp, &IV, 1, DB_SeekEQ);
        if (ret) {
            __leave;
        }
        ret = DBGetAttVal(pDBTmp, 1, ATT_OBJ_DIST_NAME,
                          0, 0,
                          &cb, (BYTE **) &pDN);
        if (ret) {
            __leave;
        }
    }
    __finally {
        DBClose(pDBTmp, TRUE);
    }

    if (!pDN) {
        DWORD cbGuidOnlyDN = DSNameSizeFromLen( 0 );
        pDN = THAllocEx( pTHS, cbGuidOnlyDN );
        pDN->Guid = *puuid;
        pDN->structLen = cbGuidOnlyDN;
    }

    return pDN;
}


void
DraSetRemoteDsaExtensionsOnThreadState(
    IN  THSTATE *           pTHS,
    IN  DRS_EXTENSIONS *    pextRemote
    )
{
    // Free prior extensions, if any.
    if (NULL != pTHS->pextRemote) {
        THFreeOrg(pTHS, pTHS->pextRemote);
        pTHS->pextRemote = NULL;
    }

    // Set the extensions on the thread state.
    if (pextRemote) {
        pTHS->pextRemote = THAllocOrgEx(pTHS, DrsExtSize(pextRemote));
        CopyExtensions(pextRemote, pTHS->pextRemote);
    }
}

LPWSTR
DraGUIDFromStringW(
    THSTATE *      pTHS,
    GUID *         pguid
    )
{
    LPWSTR pszName = NULL;
    LPWSTR pszGuid = NULL;
    RPC_STATUS rpcStatus = RPC_S_OK;
    rpcStatus = UuidToStringW(pguid, &pszName);
    if (rpcStatus!=RPC_S_OK) {
	Assert(rpcStatus);
	return NULL;
    }
    pszGuid = THAllocEx(pTHS, (wcslen(pszName) + 1) * sizeof(WCHAR));
    wcscpy(pszGuid, pszName);
    RpcStringFreeW(&pszName);
    return pszGuid;
}


LPWSTR
GetNtdsDsaDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidNtdsDsaObj
    )

/*++

Routine Description:

    Given a string DN of an NTDSDSA server object, return a
    user friendly display-able name 

Arguments:

    pTHS -
    pszDsaDN - DN string

Return Value:

    Display Name
   
--*/
{
    LPWSTR      pszDisplayName = NULL;
    LPWSTR      pszSite = NULL;
    LPWSTR      pszServer = NULL;
    LPWSTR *    ppszRDNs = NULL;
    DSNAME *    pDsa = NULL;
    LPWSTR      pszName = NULL;

    if (fNullUuid(pguidNtdsDsaObj)) {
	pszDisplayName = NULL;
    }
    else {
	pDsa = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, pguidNtdsDsaObj);
	if ((NULL == pDsa) || (pDsa->StringName == NULL)) {
	    // guid is better than nada
	    pszDisplayName = DraGUIDFromStringW(pTHS, pguidNtdsDsaObj);
	}
	else {
	    ppszRDNs = ldap_explode_dnW(pDsa->StringName, 1);
	    if ((NULL == ppszRDNs) || (2 > ldap_count_valuesW(ppszRDNs))) {
		// give them everything we have
		pszDisplayName = THAllocEx(pTHS, (wcslen(pDsa->StringName)+1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, pDsa->StringName);
	    }
	    else { 
		// return site\servername
		pszSite = ppszRDNs[3];
		pszServer = ppszRDNs[1];
		pszDisplayName = THAllocEx(pTHS, (wcslen(pszSite) + wcslen(pszServer) + 2) * sizeof(WCHAR)); 
		wcscpy(pszDisplayName, pszSite);
		wcscat(pszDisplayName, L"\\");
		wcscat(pszDisplayName, pszServer);
	    }  
	}
    }
    if (ppszRDNs) {
	ldap_value_freeW(ppszRDNs);
    }
    if (pDsa) {
	THFreeEx(pTHS, pDsa);
    }

    return pszDisplayName;
}

LPWSTR
GetTransportDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidTransportObj
    )
{
    LPWSTR        pszDisplayName = NULL;
    LPWSTR *      ppszRDNs = NULL;
    DSNAME *      pTransport = NULL;

    if (fNullUuid(pguidTransportObj)) {
	pszDisplayName = NULL;
    }
    else {
	pTransport = draGetServerDsNameFromGuid(pTHS, Idx_ObjectGuid, pguidTransportObj);
	if ((NULL == pTransport) || (pTransport->StringName == NULL)) {
	    pszDisplayName = DraGUIDFromStringW(pTHS, pguidTransportObj);
	}
	else {
	    ppszRDNs = ldap_explode_dnW(pTransport->StringName, 1);
	    if (NULL == ppszRDNs) {
		pszDisplayName = THAllocEx(pTHS, (wcslen(pTransport->StringName) + 1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, pTransport->StringName);
	    }
	    else { 
		pszDisplayName = THAllocEx(pTHS, (wcslen(ppszRDNs[0]) + 1) * sizeof(WCHAR));
		wcscpy(pszDisplayName, ppszRDNs[0]); 
	    }
	}
    }
    if (ppszRDNs) {
	ldap_value_freeW(ppszRDNs);
    }
    if (pTransport) {
	THFreeEx(pTHS, pTransport);
    }

    return pszDisplayName;
}

LPWSTR
GetDomainDnsHostnameFromNC(
    THSTATE * pTHS,
    DSNAME * pNC
    )
/*++

Routine Description:

    If the NC param is a domain NC, return the dns domain name, 
    otherwise return NULL (ex. config, schema, ndnc's)

Arguments:

    pTHS -
    pNC - NC to query for domain dns name.

Return Value:

    THAlloc'ed dns domain name.
   
--*/
{
    CROSS_REF   *pCR;
    COMMARG     CommArg;
    ULONG       cbAttr;
    ATTCACHE    *pAC;
    WCHAR       *pwszTmp;
    LPWSTR      pszDnsHostname = NULL;

    InitCommarg(&CommArg);

    pCR = FindExactCrossRef(pNC, &CommArg);

    if (    pCR 
         && (pCR->flags & FLAG_CR_NTDS_DOMAIN)
         && (pCR->DnsName )
	    )
    {
        pwszTmp = pCR->DnsName;
        if ( pwszTmp[0] )
        {
            cbAttr = sizeof(WCHAR) * (wcslen(pwszTmp) + 1);
            pszDnsHostname = (WCHAR *) THAllocEx(pTHS, cbAttr);
            memcpy(pszDnsHostname, pwszTmp, cbAttr);
	    NormalizeDnsName(pszDnsHostname);
        }
    }
   
    return pszDnsHostname;
}

BOOL
IsDomainNC(
    DSNAME * pNC
    )
/*++

Routine Description:

    If the NC param is a domain NC, return true, else false, 

Arguments:

    pNC - NC to query for domain dns name.

Return Value:

    TRUE - is a domain NC
    FALSE - is not (config, schema, ndnc)
   
--*/
{
    CROSS_REF   *pCR;
    COMMARG     CommArg;
    BOOL        fIsDomainNC = FALSE;

    InitCommarg(&CommArg);

    pCR = FindExactCrossRef(pNC, &CommArg);

    if (    pCR 
         && (pCR->flags & FLAG_CR_NTDS_DOMAIN)
	    )
    {
        fIsDomainNC = TRUE;
    }
   
    return fIsDomainNC;

}


int
DraFindAliveGuid(
    IN UUID * puuid
    )

/*++

Routine Description:

Wrapper around FindAliveDsname. It constructs a dsname from a guid. It uses its
own DBPOS.

Arguments:

    puuid - 

Return Value:

    int - 

--*/

{
    DBPOS *pDBTmp = NULL;
    ULONG ret, cb;
    int findAliveStatus = FIND_ALIVE_SYSERR;
    CHAR achBuffer[DSNameSizeFromLen(0)];
    DSNAME *pDN = (DSNAME *)achBuffer;

    Assert( puuid );
    Assert(!fNullUuid(puuid));

    memset( pDN, 0, DSNameSizeFromLen(0) );
    pDN->structLen = DSNameSizeFromLen(0);
    pDN->Guid = *puuid;

    DBOpen(&pDBTmp);
    __try {
        findAliveStatus = FindAliveDSName( pDBTmp, pDN );
    }
    __finally {
        DBClose(pDBTmp, TRUE);
    }

    return findAliveStatus;

} /* DraFindAliveGuid */


BOOL
DraIsRecentOriginatingChange(
    IN THSTATE *pTHS,
    IN DSNAME *pObjectDN,
    IN ATTRTYP AttrType
    )

/*++

Routine Description:

    Determine if an attribute was last modified by one of our invocation ids after the
    system started.

    At this level we do not validate the contents of the attribute. We do not distinguish
    between an attribute which has a value and one that does not, so long as it has
    metadata.

    Only works attributes which have metadata.  The attribute doesn't necessarily have to
    be replicated, only that it has metadata.

    This checks the object metadata as stored in the database. If you want to know if an
    attribute was touched in the current transaction, see dbIsModifiedInMetaData.

    Does not assume nor change the primary dbpos. Raises exceptions on fatal errors.

    This is a little more tricky than you first might think. Intuitively, we want to tell if
    the attribute metadata has been changed by us since system start. We would prefer not to
    use timestamps, since we must be immune to clock changes. If we use usns and invocation
    ids, we must be immune from recent changes to the invocation id (for example during NDNC
    hosting).  Also, we also must not accept a post-backup change which we made, which
    replicates back into a restored copy of ourselves.

    Case #0: Change was written under current invocation id and usns are comparable

    Case #1: System is restored and attribute write was part of restore.
        The attribute was written under the old retired invocation id, with a USN less than
        gusnDSAStarted. The old invocation id was retired with a usnRetired which is
        also less than gusnDSAStarted. We guarantee that all changes in the restored database
        under the retired invocation id will be less than gusnDSAStarted. This check will
        return FALSE.

    Case #2: Attribute written before restart, and NDNC hosting causes a change in invocation
    id prior to this check.
        The attribute was written under an old retired invocation id, with a USN less than
        gusnDSAStarted. The old retired invocation id was retired since start, so it will
        be accepted. But the usn of the change is less than start, so we will return FALSE.

    Case #3: System is restored, and post-backup-pre-restore write under old invocation id
    replicates in.
        The change was stamped with an old retired invocation id, but the USN may be greater
        than gusnDSAStarted.  The old invocation id was retired before start, so it will
        not be accepted.

Arguments:

    pTHS - Thread state
    pObjectDN - Object to check
    AttrType - Attribute to check

Return Value:

    BOOL - 

--*/

{
    DBPOS *pDBTmp;
    PROPERTY_META_DATA_VECTOR *pMetaDataVecLocal = NULL;
    PROPERTY_META_DATA *pMetaData;
    BOOL fResult = FALSE;
    DWORD err, cbReturned, iProp;

    Assert(VALID_THSTATE(pTHS));
    Assert( pObjectDN );

    DBOpen(&pDBTmp);
    __try {
        // Position on object
        // Read the local metadata
        // Validate the attribute has something in it
        // Lookup metadata for single attribute
        if ( (FindAliveDSName(pDBTmp, pObjectDN) != FIND_ALIVE_FOUND) ||
             (DBGetAttVal(pDBTmp, 1,  ATT_REPL_PROPERTY_META_DATA,
                          0, 0, &cbReturned, (LPBYTE *) &pMetaDataVecLocal)) ||
             (!DBHasValues( pDBTmp, AttrType )) ||
             (!(pMetaData = ReplLookupMetaData(AttrType, pMetaDataVecLocal, &iProp)))
            ) {
            DRA_EXCEPT (DRAERR_InternalError, 0);
        }
        // See if last change was originated by us
        // We only accept recent invocation ids, either our current one, or one retired
        // since the system was started.
        if (!DraIsInvocationIdOurs(pTHS, &(pMetaData->uuidDsaOriginating), &gusnDSAStarted)) {
            __leave;
        }
        // Check the sequence number of the change
        fResult = pMetaData->usnOriginating >= gusnDSAStarted;
#ifdef INCLUDE_UNIT_TESTS
        // Sanity check the result
        // Assuming the clock has not gone backwards, a winning change will have
        // been written after system start, and a losing change will not.
        Assert( fResult == (pMetaData->timeChanged > gtimeDSAStarted) );
#endif
    } __finally {
        DBClose(pDBTmp, !AbnormalTermination());

        // Be heap friendly
        if (NULL != pMetaDataVecLocal) {
            THFreeEx(pTHS, pMetaDataVecLocal);
            pMetaDataVecLocal = NULL;
        }
    }

    return fResult;
} /* DraWasAttrLastModByUsSinceStart */

USN DraGetCursorUsnForDsaHelper(
    THSTATE * pTHS,
    DBPOS *   pDB,
    DSNAME *  pDSA,
    UPTODATE_VECTOR * pUpToDateVec
    ) 
/*++

Routine Description:

    For the given DSA, get the usn from the up-to-dateness vector
    
Arguments:
                                        
    pTHS - 
    pDB - 
    pDSA - DSA to get cursor from 
    pUpToDateVec - up-to-date vector to get the usn from
        
Return Value:

    USN;

--*/
{
    USN usnFind = 0;
    DSNAME * pDsa = NULL;
    DB_ERR dbErr = DB_success;
    GUID guidInvocID;

    dbErr = DBFindDSName(pDB, pDSA);
    if (dbErr==DB_success) {
	if(!DBGetSingleValue(pDB, ATT_INVOCATION_ID, &guidInvocID,
			     sizeof(GUID), NULL)) {
	    // okay, get the usnFind
	    if (!UpToDateVec_GetCursorUSN(pUpToDateVec, &guidInvocID, &usnFind)) {
		usnFind = 0;
	    }
	}
    } 

    return usnFind;
}

USN DraGetCursorUsnForDsa(
    THSTATE * pTHS,
    DSNAME *  pDSA,
    DSNAME *  pNC
    ) 
/*++

Routine Description:

    For the given DSA, get the replication usn last sync'ed to
    
Arguments:
                                        
    pTHS - 
    pDSA - DSA to get cursor from
    pNC - NC
        
Return Value:

    USN;

--*/
{
    DBPOS * pDB = NULL;
    ULONG it;
    DWORD ret = ERROR_SUCCESS;
    UPTODATE_VECTOR * pUpToDateVec = NULL;
    USN usn = 0;
    BOOL fAttExists = TRUE;
    REPLICA_LINK * pRepsFromRef = NULL;
    DWORD dwLength = 0;

    if (pDSA==NULL) {
	// what?  Assume this is a new source, and return 0.
	return 0;
    }
	    	    
    DBOpen2(TRUE, &pDB);
    __try {

	if (ret = FindNC(pDB, pNC, FIND_MASTER_NC | FIND_REPLICA_NC,
			 &it)) {
	    __leave;
	}

	// Try and find this name in the repsfrom attribute.
	if ( !FindDSAinRepAtt( pDB,
			       ATT_REPS_FROM,
			       DRS_FIND_DSA_BY_UUID,
			       &(pDSA->Guid),
			       NULL,
			       &fAttExists,
			       &pRepsFromRef,
			       &dwLength ) ) {

	    // Existing att val for this DSA found
	    VALIDATE_REPLICA_LINK_VERSION(pRepsFromRef);
	    VALIDATE_REPLICA_LINK_SIZE(pRepsFromRef);

	    // read the pu value - this should be equal to the USN value in the UTD.
	    usn = pRepsFromRef->V1.usnvec.usnHighObjUpdate;
	} else {
	    // if there isn't a reps-from either:
	    //		a) all connections have been deleted from this DC
	    //		b) there are no other dc's in the forest.
	    //          c) the NC is being removed, is being added, or it's not instantiated

	    // if c), then we can safely return 0 for the USN.  
	    //     Reasoning:  If the NC is going, then Sync or Add is going to return ERROR_DS_DRA_NO_REPLICA
	    //                 If, between now and then, it manages to actually become totally gone,
	    //                 		Sync will fail (can't find the NC to sync), but Add will continue.  In
	    //                          that case, we are performing an initial sync and our usn for that dsa is 0.
	    //                 If the NC is coming - AND it doesn't have a repsfrom attribute, then this is the first
	    //                          attempt at a sync, so again, 0 is appropriate.

	    if ((it & IT_NC_GOING) || (it & IT_UNINSTANT) || (it & IT_NC_COMING)) {
		usn = 0;
	    } else { 

		// Get current UTD vector (or try to) - make sure to ask for the local cursor, because
		// sometimes the DC can get confused and ask for a UTD on itself (or someone can 
		// call repadmin /sync with itself).
		UpToDateVec_Read(pDB,
				 it,
				 UTODVEC_fUpdateLocalCursor,
				 DBGetHighestCommittedUSN(),
				 &pUpToDateVec);

		if (pUpToDateVec==NULL) {
		    // probably b) but it could be a) and b)
		    usn = 0;
		} else { 
		    // will return 0 if b)
		    usn = DraGetCursorUsnForDsaHelper(pTHS, 
						      pDB,
						      pDSA,
						      pUpToDateVec); 
		    THFreeEx(pTHS, pUpToDateVec);
		}
	    }
	}
    }
    __finally {
	DBClose(pDB, TRUE);
    }

    return usn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\ntdsapi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       ntdsapi.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements entry points for the NTDSAPI wire functions.

Author:

    Dave Straube    (DaveStr)   10/22/97

Revision History:
    Dave Straube    (DaveStr)   10/22/97
        Created - mostly copied from (now) obsolete msdsserv.c.
    Will Lees       (wlees)     28-Jan-98
        Added WriteSpn support
    Colin Brace     (ColinBr)   02-Feb-98
        Added remove server/domain support
    Dave Straube    (DaveStr)   02-Jun-98
        Added DomainControllerInfo support

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <cracknam.h>                   // name cracking prototypes
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>
#include <attids.h>
#include <filtypes.h>
#include <ldapagnt.h>

#include <ntdsa.h>
#include <dsconfig.h>                   // FILEPATHKEY
#include <ntdsctr.h>

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dstrace.h>

// Assorted DSA headers.
#include <dsexcept.h>

#include <windns.h>

#include "drarpc.h"

#include "debug.h"                      // standard debugging header
#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include "lmaccess.h"                   // UF_* flags

#include <fileno.h>
#define  FILENO FILENO_NTDSAPI

// External
DWORD
SpnOperation(
    DWORD Operation,
    DWORD Flags,
    LPCWSTR Account,
    DWORD cSpn,
    LPCWSTR *pSpn
    );

DWORD
RemoveDsServerWorker(
    IN  LPWSTR  ServerDN,
    IN  LPWSTR  DomainDN OPTIONAL,
    OUT BOOL   *fLastDcInDomain OPTIONAL,
    IN  BOOL    fCommit
    );

DWORD
RemoveDsDomainWorker(
    IN  LPWSTR  DomainDN
    );

DWORD
DcInfoHelperLdapObj(
    THSTATE *pTHS,
    VOID    *pmsgOut
    );

DWORD
DsaExceptionToWin32(
    DWORD   xCode
    )
{
    switch ( xCode )
    {
    case DSA_EXCEPTION:             return(DS_ERR_INTERNAL_FAILURE);
    case DRA_GEN_EXCEPTION:         return(DS_ERR_DRA_INTERNAL_ERROR);
    case DSA_MEM_EXCEPTION:         return(ERROR_NOT_ENOUGH_MEMORY);
    case DSA_DB_EXCEPTION:          return(ERROR_DS_BUSY);
    case DSA_BAD_ARG_EXCEPTION:     return(ERROR_INVALID_PARAMETER);
    }

    return(ERROR_DS_BUSY);
}

ULONG
DRS_MSG_CRACKREQ_V1_Validate(
    DRS_MSG_CRACKREQ_V1 * pmsg
    )
/*
    typedef struct _DRS_MSG_CRACKREQ_V1
    {
    ULONG CodePage;
    ULONG LocaleId;
    DWORD dwFlags;
    DWORD formatOffered;
    DWORD formatDesired;
    [range] DWORD cNames;
    [size_is][string] WCHAR **rpNames;
    } 	DRS_MSG_CRACKREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;
    ULONG i;

    if ((pmsg->cNames > 0) && (pmsg->rpNames==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    for (i=0; (i<pmsg->cNames) && (ret==ERROR_SUCCESS);i++) {
	ret = LPWSTR_Validate(pmsg->rpNames[i], FALSE); 
    }

    return ret;
}

ULONG
DRSCrackNames_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ *      pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY *    pmsgOut
    )
/*
    [notify] ULONG IDL_DRSCrackNames( 
    [in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_CRACKREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_CRACKREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER; 
    }

    if (ret==ERROR_SUCCESS) {
	ret = DRS_MSG_CRACKREQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

ULONG
IDL_DRSCrackNames(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_CRACKREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_CRACKREPLY *    pmsgOut
    )

/*++

Routine Description:

    Cracks a bunch of names from one format to another.  See external
    prototype and definitions in ntdsapi.h

Arguments:

    hContext - RPC context handle for the IDL_DRSNtdsapi* interface.

    dwFlags - flags as defined in ntdsapi.h

    pStat - pointer to STAT block which tells us about customer's LOCALE.
        In-process clients can pass NULL.

    formatOffered - identifies DS_NAME_FORMAT of input names.

    formatDesired - identifies DS_NAME_FORMAT of output names.

    cNames - input/output name count.

    rpNames - arry of input name WCHAR pointers.

    ppResult - pointer to pointer of DS_NAME_RESULTW block.

Return Value:

    // This routine is mostly called by ntdsapi.dll clients who typically
    // want something better than DRAERR_* return codes.  So we break with
    // tradition for IDL_DRS* implementations and return WIN32 error codes.

    NO_ERROR                        - success
    ERROR_INVALID_PARAMETER         - invalid parameter
    ERROR_NOT_ENOUGH_MEMORY         - allocation error

    Individual name mapping errors are reported in
    (*ppResult)->rItems[i].status.

--*/
{
    THSTATE    *pTHS = pTHStls;
    ULONG       err = RPC_S_OK;
    DWORD       cBytes;
    DWORD       i;
    CrackedName *rCrackedNames = NULL;
    GUID        guidNtdsapi = NtdsapiClientGuid;
    SID         ServerLogonSid = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_SERVER_LOGON_RID };
    HANDLE      ClientToken;
    DWORD       xCode;
    DWORD       cNamesOut = 0;
    DWORD       cNamesCracked = 0;
    DWORD       cNamesNotCracked = 0;
    DWORD       dwLastStatus = 0;
    DWORD       dwFlags;
    BOOL        fDbOpen = FALSE;
    BOOL fNtdsapiClient = FALSE;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSCRACKNAMES);
    drsReferenceContext( hDrs );
    __try { 
	*pdwOutVersion = 1;
	memset(pmsgOut, 0, sizeof(DRS_MSG_CRACKREPLY));

	// Initialize thread state and open data base.

	if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) )
	    {
	    err = ERROR_DS_INTERNAL_FAILURE;
	    __leave;
	}

	if ((err = DRSCrackNames_InputValidate(dwInVersion, 
					       pmsgIn, 
					       pdwOutVersion, 
					       pmsgOut))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (err==ERROR_DS_DRA_INVALID_PARAMETER) {
		err = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	Assert(1 == dwInVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_INTERNAL,
			 DIRLOG_IDL_DRS_CRACK_NAMES_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsCrackNames,
			 szInsertUL(pmsgIn->V1.cNames),
			 szInsertUL(pmsgIn->V1.CodePage),
			 szInsertUL(pmsgIn->V1.LocaleId),
			 szInsertUL(pmsgIn->V1.formatOffered),
			 szInsertUL(pmsgIn->V1.formatDesired),
			 szInsertUL(pmsgIn->V1.dwFlags),
			 NULL, NULL);

	// This DC is not a GC and the caller specifically requested a GC.
	// Probably a call out of CrackSingleName on another DC.
	if ((pmsgIn->V1.dwFlags & DS_NAME_FLAG_GCVERIFY) && !gAnchor.fAmVirtualGC) {
	    err = ERROR_DS_GCVERIFY_ERROR;
	    __leave;
	}


	if ( !memcmp(   &(((DRS_CLIENT_CONTEXT *) hDrs)->uuidDsa),
			&guidNtdsapi,
			sizeof(GUID)) )
	    {
	    fNtdsapiClient = TRUE; 
	}

	IADJUST((fNtdsapiClient ? pcDsClientNameTranslate : pcDsServerNameTranslate), pmsgIn->V1.cNames);

	DBOpen2(TRUE, &pTHS->pDB);
	fDbOpen = TRUE;

	//
	// check to see if the caller is a DC. If so, set fDSA
	//

	// this impersonate call is safe not to clear the possible clientToken
	// on the THREAD state
	if (RpcImpersonateClient( NULL ) == ERROR_SUCCESS)
	    {
	    BOOL Result = FALSE;
	    if (CheckTokenMembership(
		NULL,                       // already impersonating
		&ServerLogonSid,
		&Result
		))
		{
		if (Result)
		    {
		    pTHS->fDSA = TRUE;
		}
	    }
	    RpcRevertToSelf();
	}
	__try
	    {
	    // Do the real work by calling core.  

	    dwFlags = pmsgIn->V1.dwFlags;

	    if (fNtdsapiClient) {
		// ntdsapi.dll clients
		// always get FPO resolution so UI components look nice.
		// All other clients need to ask for it explicitly.
		dwFlags |= DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS;
	    }

	    CrackNames(
		dwFlags,
		pmsgIn->V1.CodePage,
		pmsgIn->V1.LocaleId,
		pmsgIn->V1.formatOffered,
		pmsgIn->V1.formatDesired,
		pmsgIn->V1.cNames,
		pmsgIn->V1.rpNames,
		&cNamesOut,
		&rCrackedNames);

	    // Close DB thereby ending any transactions in case we
	    // process FPOs which can cause calls to go off machine.
	    // Set flag so that _finally doesn't do it.

	    DBClose(pTHS->pDB, TRUE);
	    fDbOpen = FALSE;

	    if (    (dwFlags & DS_NAME_FLAG_PRIVATE_RESOLVE_FPOS)
		    && rCrackedNames )
		{
		ProcessFPOsExTransaction(pmsgIn->V1.formatDesired,
					 cNamesOut,
					 rCrackedNames);
	    }

	    pmsgOut->V1.pResult =
		(DS_NAME_RESULTW *) THAllocEx(pTHS, sizeof(DS_NAME_RESULTW));

	    if ( (cNamesOut > 0) && rCrackedNames )
		{
		// Server side MIDL_user_allocate is same as THAlloc which
		// also zeros memory by default.

		cBytes = cNamesOut * sizeof(DS_NAME_RESULT_ITEMW);
		pmsgOut->V1.pResult->rItems =
		    (DS_NAME_RESULT_ITEMW *) THAllocEx(pTHS, cBytes);

		for ( i = 0; i < cNamesOut; i++ )
		    {
		    // Remember the last status and the number of names
		    // successfully cracked for logging below. The last
		    // status is useful if only one name was cracked;
		    // which is 99% of the time.
		    if (!(  dwLastStatus
			    = pmsgOut->V1.pResult->rItems[i].status
			    = rCrackedNames[i].status)) {
			++cNamesCracked;
		    } else {
			++cNamesNotCracked;
		    }
		    pmsgOut->V1.pResult->rItems[i].pDomain =
			rCrackedNames[i].pDnsDomain;
		    pmsgOut->V1.pResult->rItems[i].pName =
			rCrackedNames[i].pFormattedName;
		}

		THFree(rCrackedNames);
		pmsgOut->V1.pResult->cItems = cNamesOut;

	    }
	}
	__finally
	    {
	    // End the transaction.  Faster to commit a read only
	    // transaction than abort it - so set commit to TRUE.

	    if ( fDbOpen )
		{
		DBClose(pTHS->pDB, TRUE);
	    }
	}
    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	err = DsaExceptionToWin32(xCode);
    }

    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_INTERNAL,
			 DIRLOG_IDL_DRS_CRACK_NAMES_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsCrackNames,
			 szInsertUL(err),
			 szInsertUL(cNamesOut),
			 szInsertUL(cNamesCracked),
			 szInsertUL(cNamesNotCracked),
			 szInsertUL(dwLastStatus),
			 szInsertWin32Msg(err),
			 szInsertWin32Msg(dwLastStatus),
			 NULL);
    }

    return(err);
}


ULONG
DRS_MSG_SPNREQ_V1_Validate(
    DRS_MSG_SPNREQ_V1 * pmsg
    )
/*
   typedef struct _DRS_MSG_SPNREQ_V1
    {
    DWORD operation;
    DWORD flags;
    [string] const WCHAR *pwszAccount;
    [range] DWORD cSPN;
    [size_is][string] const WCHAR **rpwszSPN;
    } 	DRS_MSG_SPNREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;
    ULONG i;

    ret = LPWSTR_Validate(pmsg->pwszAccount, FALSE);

    if ((pmsg->cSPN > 0) && (pmsg->rpwszSPN==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    for (i=0; (i<pmsg->cSPN) && (ret==ERROR_SUCCESS); i++) {
        ret = LPWSTR_Validate(pmsg->rpwszSPN[i],FALSE);
    }
    
    return ret;
}


ULONG
DRSWriteSPN_InputValidate(
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_SPNREQ *        pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_SPNREPLY *      pmsgOut
    )
/*
    [notify] ULONG IDL_DRSWriteSPN( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_SPNREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_SPNREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;
    GUID    guidNtdsapi = NtdsapiClientGuid;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
	ret = DRS_MSG_SPNREQ_V1_Validate(&(pmsgIn->V1));
    }

    if ( 0 != memcmp(
			&(((DRS_CLIENT_CONTEXT *) hDrs)->uuidDsa),
			&guidNtdsapi,
			sizeof(GUID))) {  
	ret = ERROR_INVALID_PARAMETER;
    }

    return ret;
}


ULONG
IDL_DRSWriteSPN(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_SPNREQ *        pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_SPNREPLY *      pmsgOut
    )

/*++

Routine Description:

    Description

Arguments:

    hDrs - Rpc handle
    dwInVersion - Version of input structure
    pmsgIn - Input arguments
    pdwOutVersion - Version of output structure
    pmsgOut - Output arguments

Return Value:

    // This routine is mostly called by ntdsapi.dll clients who typically
    // want something better than DRAERR_* return codes.  So we break with
    // tradition for IDL_DRS* implementations and return WIN32 error codes.

    ULONG - Win32 status of operation

--*/

{
    DWORD   status = RPC_S_OK;
    DWORD   xCode;
    THSTATE *pTHS = pTHStls;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSWRITESPN);
    drsReferenceContext( hDrs );
    __try {
	*pdwOutVersion = 1;  // you will get RPC_INVALID_TAG if this not set on return	
	memset(pmsgOut, 0, sizeof(*pmsgOut));

	// Initialize thread state

	if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) )
	    {
	    return(ERROR_DS_INTERNAL_FAILURE);
	}

	if ((status = DRSWriteSPN_InputValidate(hDrs, 
						dwInVersion, 
						pmsgIn, 
						pdwOutVersion, 
						pmsgOut))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (status==ERROR_DS_DRA_INVALID_PARAMETER) {
		status = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	Assert(1 == dwInVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_WRITE_SPN_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsWriteSPN,
			 pmsgIn->V1.pwszAccount
			 ? szInsertWC(pmsgIn->V1.pwszAccount)
			 : szInsertSz(""),
	    szInsertUL(pmsgIn->V1.operation),
	    szInsertUL(pmsgIn->V1.cSPN),
	    szInsertUL(pmsgIn->V1.flags),
	    NULL, NULL, NULL, NULL);

	// Do the real work here

	// This routine lives in dramain\src\spnop.c
	status = SpnOperation(
	    pmsgIn->V1.operation,
	    pmsgIn->V1.flags,
	    pmsgIn->V1.pwszAccount,
	    pmsgIn->V1.cSPN,
	    pmsgIn->V1.rpwszSPN );
    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	status = DsaExceptionToWin32(xCode);
    }
    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_WRITE_SPN_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsWriteSPN,
			 szInsertUL(status),
			 szInsertWin32Msg(status),
			 NULL, NULL, NULL,
			 NULL, NULL, NULL);
    }

    // This will always be executed
    pmsgOut->V1.retVal = status;

    return status;
} /* IDL_DRSWriteSPN */

ULONG
DRS_MSG_RMSVRREQ_V1_Validate(
    DRS_MSG_RMSVRREQ_V1 * pmsg
    )
/*
    typedef struct _DRS_MSG_RMSVRREQ_V1
    {
    [string] LPWSTR ServerDN;
    [string] LPWSTR DomainDN;
    BOOL fCommit;
    } 	DRS_MSG_RMSVRREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;

    ret = LPWSTR_Validate(pmsg->ServerDN, FALSE);
    if (ret==ERROR_SUCCESS) {
	ret = LPWSTR_Validate(pmsg->DomainDN, TRUE);
    }

    return ret;
}

ULONG
DRSRemoveDsServer_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_RMSVRREQ *      pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_RMSVRREPLY *    pmsgOut
    )
/*
    [notify] ULONG IDL_DRSRemoveDsServer( 
    [ref] [in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_RMSVRREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_RMSVRREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER; 
    }

    if (ret==ERROR_SUCCESS) {
	ret = DRS_MSG_RMSVRREQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}


ULONG
IDL_DRSRemoveDsServer(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_RMSVRREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_RMSVRREPLY *    pmsgOut
    )
/*++

Routine Description:

    This routine is the server side portion of DsRemoveDsServer.

Arguments:

    hDrs - Rpc handle

    dwInVersion - Version of input structure

    pmsgIn - Input arguments

    pdwOutVersion - Version of output structure

    pmsgOut - Output arguments

Return Values:

    A value from the win32 error space.

--*/
{
    ULONG     WinError;
    LPWSTR    ServerDN;
    LPWSTR    DomainDN;
    BOOL      fCommit;
    BOOL      fLastDcInDomain = FALSE;
    DWORD     xCode;
    THSTATE  *pTHS=pTHStls;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSREMOVEDSSERVER);
    drsReferenceContext(hDrs);
    __try {
	//
	// Set the out parameters
	//
	RtlZeroMemory( pmsgOut, sizeof( DRS_MSG_RMSVRREPLY ) );
	*pdwOutVersion = 1;

	if ((WinError = DRSRemoveDsServer_InputValidate(dwInVersion, 
							pmsgIn, 
							pdwOutVersion, 
							pmsgOut))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (WinError==ERROR_DS_DRA_INVALID_PARAMETER) {
		WinError = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	//
	// Dissect the in params
	//
	ServerDN = pmsgIn->V1.ServerDN;
	DomainDN = pmsgIn->V1.DomainDN;
	fCommit  = pmsgIn->V1.fCommit;

	//
	// Do the work
	//
	WinError = RemoveDsServerWorker( ServerDN,
					 DomainDN,
					 &fLastDcInDomain,
					 fCommit );
 

	if ( ERROR_SUCCESS == WinError )
	    {
	    pmsgOut->V1.fLastDcInDomain = fLastDcInDomain;
	}
    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	WinError = DsaExceptionToWin32(xCode);
    }

    drsDereferenceContext( hDrs );

    return( WinError );
}

ULONG
DRS_MSG_RMDMNREQ_V1_Validate(
    DRS_MSG_RMDMNREQ_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_RMDMNREQ_V1
{
    [string] LPWSTR  DomainDN;

} DRS_MSG_RMDMNREQ_V1; 
*/
{
    ULONG ret = ERROR_SUCCESS;

    ret = LPWSTR_Validate(pmsg->DomainDN, FALSE);

    return ret;
}

ULONG
DRSRemoveDsDomain_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_RMDMNREQ *      pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_RMDMNREPLY *    pmsgOut
    )
/*
    [notify] ULONG IDL_DRSRemoveDsDomain( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_RMDMNREQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_RMDMNREPLY *pmsgOut)
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER; 
    }

    if (ret==ERROR_SUCCESS) {
	ret = DRS_MSG_RMDMNREQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}


DWORD
IDL_DRSRemoveDsDomain(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_RMDMNREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_RMDMNREPLY *    pmsgOut
    )
/*++

Routine Description:

Arguments:

Return Values:

    An appropriate drs error.

--*/
{

    NTSTATUS   NtStatus;
    DWORD      DirError, WinError;

    LPWSTR     DomainDN;
    DSNAME    *Domain, *CrossRef, *HostedDomain;
    THSTATE   *pTHS = pTHStls;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSREMOVEDSDOMAIN);
    drsReferenceContext(hDrs);
    __try {
	*pdwOutVersion = 1;
	memset(pmsgOut, 0, sizeof(*pmsgOut));

	if ((WinError = DRSRemoveDsDomain_InputValidate(dwInVersion, 
							pmsgIn, 
							pdwOutVersion, 
							pmsgOut))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (WinError==ERROR_DS_DRA_INVALID_PARAMETER) {
		WinError = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	//
	// Prep the (unreferenced) out parameter
	// 
	pmsgOut->V1.Reserved = 0;

	DomainDN = pmsgIn->V1.DomainDN;

	WinError = RemoveDsDomainWorker( DomainDN );
    }
    __finally {
	drsDereferenceContext( hDrs );
    }
    return ( WinError );
}

//////////////////////////////////////////////////////////////////////
//                                                                  //
// IDL_DRSDomainControllerInfo implementation                       //
//                                                                  //
//////////////////////////////////////////////////////////////////////

// Forward reference ...

DWORD
DcInfoHelperV1orV2(
    THSTATE *pTHS,
    DSNAME  *pDomainDN,
    DWORD   InfoLevel,
    VOID    *pReply);

ULONG
DRS_MSG_DCINFOREQ_V1_Validate(
    DRS_MSG_DCINFOREQ_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_DCINFOREQ_V1
    {
    [string] WCHAR *Domain;
    DWORD InfoLevel;
    } 	DRS_MSG_DCINFOREQ_V1;
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ((pmsg->InfoLevel !=1) && (pmsg->InfoLevel!=2) && (pmsg->InfoLevel!=0xFFFFFFFF)) {
	ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
        ret = LPWSTR_Validate(pmsg->Domain, FALSE);
    }

    return ret;
}

ULONG
DRSDomainControllerInfo_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_DCINFOREQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_DCINFOREPLY *   pmsgOut
    )
/*

*/
{
    ULONG ret = ERROR_SUCCESS;

    if ( 1 != dwMsgInVersion ) {
	ret = ERROR_INVALID_PARAMETER; 
    }

    if (ret==ERROR_SUCCESS) {
	ret = DRS_MSG_DCINFOREQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

DWORD
IDL_DRSDomainControllerInfo(
    DRS_HANDLE              hDrs,
    DWORD                   dwInVersion,
    DRS_MSG_DCINFOREQ *     pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_DCINFOREPLY *   pmsgOut
    )
/*++

  Routine Description:

    Server side implementation for sdk\inc\ntdsapi.h - DsDomainControllerInfo.

  Parameters:

    hDrs - DRS interface binding handle.

    dwInVersion - Identifies in version - should be 1 forever more.  See
        comments on DRS_MSF_DCINFOREQ in ds\src\_idl\drs.idl.

    pmsgIn - Pointer to DRS_MSG_DCINFOREQ request.

    pdwOutVersion - Receives output version number which should be same as
        requested pmsgIn->V1.InfoLevel.  Se drs.idl comments for details.

    pmsgOut - Receives output DRS_MSG_DCINFOREPLY info.

  Return Values:

--*/
{
    DWORD       err = RPC_S_OK;
    DWORD       xCode;
    THSTATE     *pTHS = pTHStls;
    COMMARG     commArg;
    COMMRES     commRes;
    DSNAME      *pDN;
    DWORD       cBytes;
    DWORD       cNamesOut;
    CrackedName *pCrackedName;
    DWORD       pass;
    WCHAR       *pTmp = NULL;
    BOOL        foundSomething = FALSE;
    DWORD       infoLevel = 0;
    CROSS_REF_LIST *pCRL;

    DRS_Prepare(&pTHS, hDrs, IDL_DRSDOMAINCONTROLLERINFO);
    drsReferenceContext(hDrs);
    __try {
	// Initialize out parameters to safe value in case of early return. 	
	*pdwOutVersion = pmsgIn->V1.InfoLevel;
	memset(pmsgOut, 0, sizeof(DRS_MSG_DCINFOREPLY));

	// Initialize thread state and open data base.

	if ( !(pTHS = InitTHSTATE(CALLERTYPE_NTDSAPI)) ) {
	    return(ERROR_DS_INTERNAL_FAILURE);
	}

	if ((err = DRSDomainControllerInfo_InputValidate(dwInVersion, 
							 pmsgIn, 
							 pdwOutVersion, 
							 pmsgOut))!=ERROR_SUCCESS) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    // don't return DRAERR_* codes, translate
	    if (err==ERROR_DS_DRA_INVALID_PARAMETER) {
		err = ERROR_INVALID_PARAMETER;
	    }
	    __leave;
	}

	//
	// InfoLevel 0xFFFFFFFF is used to get ldap connection info.
	// Bypass the rest of this stuff
	//
	infoLevel = pmsgIn->V1.InfoLevel;
	if ( infoLevel == 0xFFFFFFFF ) {
	    err = DcInfoHelperLdapObj(pTHS,pmsgOut);
	    __leave;
	}

	Assert(1 == dwInVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_DC_INFO_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsDCInfo,
			 pmsgIn->V1.Domain
			 ? szInsertWC(pmsgIn->V1.Domain)
			 : szInsertSz(""),
			 szInsertUL(infoLevel),
			 NULL, NULL, NULL, NULL, NULL, NULL);

	DBOpen2(TRUE, &pTHS->pDB);

	__try
	    {
	    // Be kind and quickly locate a netbios or dns domain name

	    for (pCRL = gAnchor.pCRL; pCRL; pCRL = pCRL->pNextCR)
		{
		if (     (pCRL->CR.DnsName
			  && DnsNameCompare_W(pCRL->CR.DnsName, pmsgIn->V1.Domain))
			 ||
			 (pCRL->CR.NetbiosName
			  && !_wcsicmp(pCRL->CR.NetbiosName, pmsgIn->V1.Domain)) )
		    {
		    if (NameMatched(pCRL->CR.pNC, gAnchor.pDomainDN))
			{
			pDN = pCRL->CR.pNC;
			goto FOUNDIT;
		    }
		}
	    }

	    // Be kind and crack the name from various and sundry formats.

	    for ( pass = 1; pass <= 3; pass++ )
		{
		cNamesOut = 0;
		pCrackedName = NULL;

		if ( 1 == pass )
		    {
		    // Crack the name as-is.
		    pTmp = pmsgIn->V1.Domain;
		}
		else if ( 2 == pass )
		    {
		    // Assume it is DS_NT4_ACCOUNT_NAME w/o the trailing '\'.
		    cBytes = (wcslen(pmsgIn->V1.Domain) + 2) * sizeof(WCHAR);
		    pTmp = (WCHAR *) THAllocEx(pTHS, cBytes);
		    wcscpy(pTmp, pmsgIn->V1.Domain);
		    wcscat(pTmp, L"\\");
		}
		else if ( 3 == pass )
		    {
		    // Assume it is DS_CANONICAL_NAME w/o the trailing '/'.
		    wcscpy(pTmp, pmsgIn->V1.Domain);
		    wcscat(pTmp, L"/");
		}

		CrackNames(
		    DS_NAME_NO_FLAGS,
		    GetACP(),
		    GetUserDefaultLCID(),
		    DS_UNKNOWN_NAME,
		    DS_FQDN_1779_NAME,
		    1,
		    &pTmp,
		    &cNamesOut,
		    &pCrackedName);

		if (    (1 == cNamesOut)
			&& pCrackedName
			&& (DS_NAME_NO_ERROR == pCrackedName->status)
			&& (pCrackedName->pDSName) )
		    {
		    // Caller gave us a valid name
		    foundSomething = TRUE;

		    // Caller gave us a valid name and it's OUR domain name
		    if (NameMatched(pCrackedName->pDSName, gAnchor.pDomainDN) )
			{
			pDN = pCrackedName->pDSName;
			goto FOUNDIT;
		    }
		}
	    }

	    // Caller gave us a valid name but it's not OUR domain name or
	    // caller gave us an invalid name
	    err = ((foundSomething) ? ERROR_INVALID_PARAMETER : ERROR_DS_OBJ_NOT_FOUND);
        __leave;

	    FOUNDIT:
		if ( DBFindDSName(pTHS->pDB, pDN) )
		    {
		    err = ERROR_DS_INTERNAL_FAILURE;
            __leave;
		}

		// Domain is good - go do the grunt work.  DcInfoHelper*
		// should return a WIN32 error code.

		switch ( infoLevel )
		    {
		case 1:
		case 2:
		    err = DcInfoHelperV1orV2(pTHS,
					     pDN,
					     infoLevel,
					     pmsgOut);
    	    break;

		    // Add new cases here as new info levels are defined.

		default:
		    err = ERROR_DS_NOT_SUPPORTED;
		    break;
		}
	}
	__finally
	    {
	    DBClose(pTHS->pDB, TRUE);
	}
    }
    __except(HandleMostExceptions(xCode = GetExceptionCode()))
    {
	err = DsaExceptionToWin32(xCode);
    }

    drsDereferenceContext( hDrs );

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_DC_INFO_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsDCInfo,
			 szInsertUL(err),
			 NULL, NULL, NULL, NULL,
			 NULL, NULL, NULL);
    }

    return(err);
}

VOID
GetV2SiteAndDsaInfo(
    THSTATE                         *pTHS,
    DSNAME                          *pSiteDN,
    DSNAME                          *pServerDN,
    DS_DOMAIN_CONTROLLER_INFO_2W    *pItemV2
    )
/*++

  Routine Description:

  Arguments:

    pSiteDN - DSNAME of site object (missing GUID field as it was derived
        via TrimDsNameBy().

    pServerDN - DSNAME of Server object.

    pItemV2 = Address of V@ info struct whose fields are filled on success.

  Return Values:

    None.  On error we just leave that field blank.  Clients are supposed to
    check for NULL names and GUIDs.
--*/
{
    CLASSCACHE      *pCC;
    DSNAME          *pCategoryDN;
    ULONG           len;
    SEARCHARG       searchArg;
    SEARCHRES       searchRes;
    FILTER          categoryFilter;
    ENTINFSEL       selection;
    COMMARG         commArg;
    DSNAME          *pFullSiteDN = NULL;
    ENTINFLIST      *pEntInfList, *pEntInfTmp;
    ATTR            selAtts[1];
    ATTR            *pOption;

    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));
    Assert(fNullUuid(&pSiteDN->Guid));
    Assert(pSiteDN->structLen && pSiteDN->NameLen);
    Assert(!fNullUuid(&pServerDN->Guid));
    Assert(pServerDN->structLen && pServerDN->NameLen);
    Assert(!pItemV2->NtdsDsaObjectName)
    Assert(fNullUuid(&pItemV2->SiteObjectGuid));
    Assert(fNullUuid(&pItemV2->NtdsDsaObjectGuid));
    Assert(!pItemV2->fIsGc);

    if (    !(pCC = SCGetClassById(pTHS, CLASS_NTDS_DSA))
         || !(pCategoryDN = pCC->pDefaultObjCategory) )
    {
        return;
    }

    // Derive GUID of site object.

    if (    !DBFindDSName(pTHS->pDB, pSiteDN)
         && !DBGetAttVal(pTHS->pDB, 1, ATT_OBJ_DIST_NAME, 0,
                         0, &len, (UCHAR **) &pFullSiteDN) )
    {
        pItemV2->SiteObjectName = pFullSiteDN->StringName;
        pItemV2->SiteObjectGuid = pFullSiteDN->Guid;
    }

    // Find the NTDS-DSA object and get its options.

    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));
    memset(&categoryFilter, 0, sizeof (FILTER));
    searchArg.pObject = pServerDN;
    searchArg.choice = SE_CHOICE_IMMED_CHLDRN;
    searchArg.bOneNC = TRUE;
    categoryFilter.pNextFilter = NULL;
    categoryFilter.choice = FILTER_CHOICE_ITEM;
    categoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    pCategoryDN->structLen;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) pCategoryDN;
    searchArg.pFilter = &categoryFilter;
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 1;
    selection.AttrTypBlock.pAttr = selAtts;
    selection.AttrTypBlock.pAttr[0].attrTyp = ATT_OPTIONS;
    selection.AttrTypBlock.pAttr[0].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[0].AttrVal.pAVal = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection = &selection;
    InitCommarg(&searchArg.CommArg);
    SearchBody(pTHS, &searchArg, &searchRes, 0);

    if ( pTHS->errCode )
    {
        THClearErrors();
        return;
    }

    if ( 1 == searchRes.count )
    {
        pItemV2->NtdsDsaObjectName =
                        searchRes.FirstEntInf.Entinf.pName->StringName;
        pItemV2->NtdsDsaObjectGuid =
                        searchRes.FirstEntInf.Entinf.pName->Guid;

        if ( searchRes.FirstEntInf.Entinf.AttrBlock.attrCount )
        {
            pOption = searchRes.FirstEntInf.Entinf.AttrBlock.pAttr;
        }
        else
        {
            pOption = NULL;
        }

        if (    pOption
             && (ATT_OPTIONS == pOption->attrTyp)
             && (1 == pOption->AttrVal.valCount)
             && pOption->AttrVal.pAVal
             && (sizeof(DWORD) == pOption->AttrVal.pAVal->valLen)
             && pOption->AttrVal.pAVal->pVal
             && (NTDSDSA_OPT_IS_GC & (* (PDWORD) pOption->AttrVal.pAVal->pVal)))
        {
            pItemV2->fIsGc = TRUE;
            THFreeEx(pTHS, pOption->AttrVal.pAVal->pVal);
            THFreeEx(pTHS, pOption->AttrVal.pAVal);
            THFreeEx(pTHS, pOption);
        }
    }
    else if ( searchRes.count >= 2 )
    {
        // Free components of search result we don't need.

        pEntInfList = searchRes.FirstEntInf.pNextEntInf;
        while ( pEntInfList )
        {
            pEntInfTmp = pEntInfList;
            pEntInfList = pEntInfList->pNextEntInf;
            THFreeEx(pTHS, pEntInfTmp->Entinf.pName);
            pOption = pEntInfTmp->Entinf.AttrBlock.pAttr;
            if ( pOption ) {
                if ( pOption->AttrVal.pAVal ) {
                    if ( pOption->AttrVal.pAVal->pVal ) {
                        THFreeEx(pTHS, pOption->AttrVal.pAVal->pVal);
                    }
                    THFreeEx(pTHS, pOption->AttrVal.pAVal);
                }
                THFreeEx(pTHS, pOption);
            }
            THFreeEx(pTHS, pEntInfTmp);
        }
    }
}

DWORD
DcInfoHelperV1orV2(
    THSTATE *pTHS,
    DSNAME  *pDomainDN,
    DWORD   InfoLevel,
    VOID    *pmsgOut
    )
/*++

  Routine Description:

    Helper function which does most of the grunt work for
    IDL_DRSDomainControllerInfo.  General algorithm is as follows:

            read fsmo name off of domain object
            search for all DCs via account type in the domain
            for each DC (aka computer object)
                derive netbios name from sam account name
                read dns host name from search result
                fDsEnabled == (server-bl is populated and real object)
                if ( fDsEnabled )
                    reverse engineer site name from ntds dsa name
                    if ( pdc fsmo == server bl )
                        set fIsPdc TRUE
                    else
                        set fIsPdc FALSE

  Parameters:

    pTHS - Valid THSTATE pointer.

    pDomainDN - DSNAME of domain we're to get DC info for and on which
        our DBPOS is positioned.

    InfoLevel - Identifies return info level 1 or 2.

    pmsgOut - Empty DRS_MSG_DCINFOREPLY struct to be filled on return.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD           i, j, DNT, cBytes, cChars;
    ULONG           len;
    ATTRTYP         attrTyp;
    DSNAME          *pPdcDsaDN;
    DSNAME          *pPdcServerDN;
    DSNAME          *pCategoryDN;
    CLASSCACHE      *pCC;
    ATTR            selAtts[3];
    ENTINFSEL       selection;
    FILTER          andFilter, categoryFilter, flagsFilter, groupFilter;
    DWORD           serverTrustFlags;
    SEARCHARG       searchArg;
    SEARCHRES       searchRes;
    ENTINFLIST      *pEntInfList;
    ATTR            *pSamName, *pDnsName, *pRefBL;
    DSNAME          *pSiteDN = NULL;
    WCHAR           computerName[MAX_COMPUTERNAME_LENGTH+1] = { 0 };
    DWORD           cComputerName;
    DWORD           primaryGroupId;
    DWORD           *pcItems = NULL;
    VOID            **prItems = NULL;
    BOOL            *pfIsPdc;
    BOOL            *pfDsEnabled;
    WCHAR           **ppNetbiosName;
    WCHAR           **ppDnsHostName;
    WCHAR           **ppSiteName;
    WCHAR           **ppServerObjectName;
    DS_DOMAIN_CONTROLLER_INFO_1W    *pItemV1;
    DS_DOMAIN_CONTROLLER_INFO_2W    *pItemV2;

    Assert((1 == InfoLevel) || (2 == InfoLevel));
    Assert(VALID_THSTATE(pTHS));
    Assert(VALID_DBPOS(pTHS->pDB));

    // Verify we're positioned on the domain object.
    Assert(    (DNT = pTHS->pDB->DNT,
                !DBFindDSName(pTHS->pDB, pDomainDN))
            && (DNT == pTHS->pDB->DNT) );

    // See comments in drs.idl regarding how all versions of
    // DRS_MSG_DCINFOREPLY have the same layout.
    Assert(& ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.cItems ==
                            & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V2.cItems);
    Assert((PVOID) & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.rItems ==
                        (PVOID) & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V2.rItems);

    if ( (1 == InfoLevel) || (2 == InfoLevel) )
    {
        pcItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.cItems;
        prItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->V1.rItems;
    }
    else
    {
        return(DIRERR_INTERNAL_FAILURE);
    }

    Assert(!*pcItems && !*prItems);

    // Read PDC FSMO role owner.

    if (    DBGetAttVal(pTHS->pDB, 1, ATT_FSMO_ROLE_OWNER,
                        0, 0, &len, (UCHAR **) &pPdcDsaDN)
         || !(pPdcServerDN = (DSNAME *) THAllocEx(pTHS, pPdcDsaDN->structLen))
         || TrimDSNameBy(pPdcDsaDN, 1, pPdcServerDN)
         || !(pCC = SCGetClassById(pTHS, CLASS_COMPUTER))
         || !(pCategoryDN = pCC->pDefaultObjCategory) )
    {
        return(DIRERR_INTERNAL_FAILURE);
    }

    // Search for all computer account objects which are DCs.

    // set up search arguments ...
    memset(&searchArg, 0, sizeof(searchArg));
    memset(&searchRes, 0, sizeof(searchRes));

    memset(&andFilter, 0, sizeof (andFilter));
    memset(&categoryFilter, 0, sizeof (categoryFilter));
    memset(&flagsFilter, 0, sizeof (flagsFilter));
    memset(&groupFilter, 0, sizeof (groupFilter));

    searchArg.pObject = pDomainDN;
    searchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    searchArg.bOneNC = TRUE;
    // set up filter ...
    // This filter for correctness, not performance.
    serverTrustFlags = UF_SERVER_TRUST_ACCOUNT;
    flagsFilter.pNextFilter = NULL;
    flagsFilter.choice = FILTER_CHOICE_ITEM;
    flagsFilter.FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
    flagsFilter.FilterTypes.Item.FilTypes.ava.type = ATT_USER_ACCOUNT_CONTROL;
    flagsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    sizeof(serverTrustFlags);
    flagsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) &serverTrustFlags;
    // This filter for correctness, not performance.
    categoryFilter.pNextFilter = &flagsFilter;
    categoryFilter.choice = FILTER_CHOICE_ITEM;
    categoryFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    pCategoryDN->structLen;
    categoryFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) pCategoryDN;
    // This filter for performance.  SAM mandates that all domain controllers
    // have DOMAIN_GROUP_RID_CONTROLLERS as their primary group ID.  When the
    // first DC in a domain is upgraded, all downlevel DC computer objects
    // are patched.  Downlevel BDCs which are installed later are given the
    // right value too.
    primaryGroupId = DOMAIN_GROUP_RID_CONTROLLERS;
    groupFilter.pNextFilter = &categoryFilter;
    groupFilter.choice = FILTER_CHOICE_ITEM;
    groupFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    groupFilter.FilterTypes.Item.FilTypes.ava.type = ATT_PRIMARY_GROUP_ID;
    groupFilter.FilterTypes.Item.FilTypes.ava.Value.valLen =
                                                    sizeof(primaryGroupId);
    groupFilter.FilterTypes.Item.FilTypes.ava.Value.pVal =
                                                    (UCHAR *) &primaryGroupId;
    andFilter.pNextFilter = NULL;
    andFilter.choice = FILTER_CHOICE_AND;
    andFilter.FilterTypes.And.count = 3;
    andFilter.FilterTypes.And.pFirstFilter = &groupFilter;
    searchArg.pFilter = &andFilter;
    // set up selection ...
    selection.attSel = EN_ATTSET_LIST;
    selection.AttrTypBlock.attrCount = 3;
    selection.AttrTypBlock.pAttr = selAtts;
    selection.AttrTypBlock.pAttr[0].attrTyp = ATT_SERVER_REFERENCE_BL;
    selection.AttrTypBlock.pAttr[0].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[0].AttrVal.pAVal = NULL;
    selection.AttrTypBlock.pAttr[1].attrTyp = ATT_DNS_HOST_NAME;
    selection.AttrTypBlock.pAttr[1].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[1].AttrVal.pAVal = NULL;
    selection.AttrTypBlock.pAttr[2].attrTyp = ATT_SAM_ACCOUNT_NAME;
    selection.AttrTypBlock.pAttr[2].AttrVal.valCount = 0;
    selection.AttrTypBlock.pAttr[2].AttrVal.pAVal = NULL;
    selection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    searchArg.pSelection = &selection;
    // set up just a few more arguments ...
    InitCommarg(&searchArg.CommArg);

    SearchBody(pTHS, &searchArg, &searchRes, 0);

    if ( pTHS->errCode )
    {
        return(DirErrorToWinError(pTHS->errCode, &searchRes.CommRes));
    }

    if ( 0 == searchRes.count )
    {
        Assert(!*pcItems && !*prItems);
        return(ERROR_SUCCESS);
    }

    // Allocate memory for output.
    if ( 1 == InfoLevel )
    {
        i = searchRes.count * sizeof(DS_DOMAIN_CONTROLLER_INFO_1W);
        *prItems = THAllocEx(pTHS, i);
    }
    else
    {
        i = searchRes.count * sizeof(DS_DOMAIN_CONTROLLER_INFO_2W);
        *prItems = THAllocEx(pTHS, i);
    }

    // Iterate over the search result.

    for ( pEntInfList = &searchRes.FirstEntInf;
          pEntInfList;
          (*pcItems)++, pEntInfList = pEntInfList->pNextEntInf )
    {
        // Find attributes in the result.
        pSamName = pDnsName = pRefBL = NULL;
        for ( i = 0; i < pEntInfList->Entinf.AttrBlock.attrCount; i++ )
        {
            switch ( pEntInfList->Entinf.AttrBlock.pAttr[i].attrTyp )
            {
            case ATT_SERVER_REFERENCE_BL:
                pRefBL = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            case ATT_SAM_ACCOUNT_NAME :
                pSamName = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            case ATT_DNS_HOST_NAME:
                pDnsName = &pEntInfList->Entinf.AttrBlock.pAttr[i]; break;
            default:
                Assert(!"Core returned stuff we didn't ask for!"); break;
            }
        }

        // Now construct return data.

        j = *pcItems;
        if ( 1 == InfoLevel )
        {
            pItemV1 = & ((* ((DS_DOMAIN_CONTROLLER_INFO_1W **) prItems))[j]);
            pfIsPdc             = &pItemV1->fIsPdc;
            pfDsEnabled         = &pItemV1->fDsEnabled;
            ppNetbiosName       = &pItemV1->NetbiosName;
            ppDnsHostName       = &pItemV1->DnsHostName;
            ppSiteName          = &pItemV1->SiteName;
            ppServerObjectName  = &pItemV1->ServerObjectName;
            pItemV1->ComputerObjectName = pEntInfList->Entinf.pName->StringName;
        }
        else
        {
            pItemV2 = & ((* ((DS_DOMAIN_CONTROLLER_INFO_2W **) prItems))[j]);
            pfIsPdc             = &pItemV2->fIsPdc;
            pfDsEnabled         = &pItemV2->fDsEnabled;
            ppNetbiosName       = &pItemV2->NetbiosName;
            ppDnsHostName       = &pItemV2->DnsHostName;
            ppSiteName          = &pItemV2->SiteName;
            ppServerObjectName  = &pItemV2->ServerObjectName;
            pItemV2->ComputerObjectName = pEntInfList->Entinf.pName->StringName;
            pItemV2->ComputerObjectGuid = pEntInfList->Entinf.pName->Guid;
            pItemV2->fIsGc = FALSE;
        }

        *pfIsPdc = FALSE;
        *pfDsEnabled = FALSE;

        if (    pSamName
             && pSamName->AttrVal.valCount
             && pSamName->AttrVal.pAVal
                // expect at least one char followed by '$'
             && (pSamName->AttrVal.pAVal[0].valLen >= (2 * sizeof(WCHAR)))
             && pSamName->AttrVal.pAVal[0].pVal )
        {
            // The netbios name is the sam account name w/o the trailing $;
            // or just the sam account name if there is no trailing $. The
            // trailing $ may be missing because the object was built by
            // hand instead of being built with the SAM APIs.

            // Need to realloc to add L'\0';
            cBytes = pSamName->AttrVal.pAVal[0].valLen;
            *ppNetbiosName = (WCHAR *) THAllocEx(pTHS, cBytes + sizeof(WCHAR));
            memcpy(*ppNetbiosName,
                   pSamName->AttrVal.pAVal[0].pVal,
                   cBytes);
            cChars = (cBytes / sizeof(WCHAR)) - 1;
            if ((*ppNetbiosName)[cChars] == L'$') {
                (*ppNetbiosName)[cChars] = L'\0';
            }
        }

        if (    pDnsName
             && pDnsName->AttrVal.valCount
             && pDnsName->AttrVal.pAVal
             && pDnsName->AttrVal.pAVal[0].valLen
             && pDnsName->AttrVal.pAVal[0].pVal )
        {
            // Need to realloc to add L'\0';
            cBytes = pDnsName->AttrVal.pAVal[0].valLen;
            *ppDnsHostName = (WCHAR *) THAllocEx(pTHS, cBytes + sizeof(WCHAR));
            memcpy(*ppDnsHostName,
                   pDnsName->AttrVal.pAVal[0].pVal,
                   cBytes);
        }
        else
        {
            // No valid DNS_HOST_NAME property on the object.  This can
            // happen if the admin mistakenly overwrote it, or just after
            // install/boot when the WriteServerInfo daemon hasn't run
            // yet.  If the DS object represents ourself, then use our
            // own DNS host name from gAnchor.

            if ( (gAnchor.pwszHostDnsName != NULL)
                 && *ppNetbiosName
                 && (    (L'\0' != computerName[0])
                      || (cComputerName = MAX_COMPUTERNAME_LENGTH+1,
                          GetComputerNameW(computerName, &cComputerName)) )
                 && !_wcsicmp(*ppNetbiosName, computerName) )
            {
                cBytes = sizeof(WCHAR) * (wcslen(gAnchor.pwszHostDnsName) + 1);
                *ppDnsHostName = (WCHAR *) THAllocEx(pTHS, cBytes);
                wcscpy(*ppDnsHostName, gAnchor.pwszHostDnsName);
            }
        }

        // We know that the DS daemon keeps ATT_SERVER_REFERENCE correct for
        // Server objects, therefore ATT_SERVER_REFERENCE_BL is correct as
        // well.  Ignore windows where an admin may have temporarily written
        // a bad value.  Thus site name is derived by snipping two components
        // off ATT_SERVER_REFERENCE_BL and grabbing the RDN.

        if (    pRefBL
             && pRefBL->AttrVal.valCount
             && pRefBL->AttrVal.pAVal
             && pRefBL->AttrVal.pAVal[0].valLen
             && pRefBL->AttrVal.pAVal[0].pVal
                // While we're here, fill in the ServerObjectName field
                // and note the use of the comma operator ...
             && (*ppServerObjectName =
                        ((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal)->StringName,
                 (pSiteDN = (DSNAME *)
                            THAllocEx(pTHS, pRefBL->AttrVal.pAVal[0].valLen)))
             && !TrimDSNameBy((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal,
                              2, pSiteDN)
             && (*ppSiteName =
                    (WCHAR *) THAllocEx(pTHS, (MAX_RDN_SIZE+1) * sizeof(WCHAR)))
             && !GetRDNInfo(pTHS, pSiteDN, *ppSiteName, &len, &attrTyp) )
        {
            // len returned from GetRDNInfo can be up to (and including) MAX_RDN_SIZE
            (*ppSiteName)[len] = L'\0';
            *pfDsEnabled = TRUE;

            if ( 2 == InfoLevel )
            {
                pItemV2->ServerObjectGuid =
                            ((DSNAME *) pRefBL->AttrVal.pAVal[0].pVal)->Guid;
                GetV2SiteAndDsaInfo(pTHS, pSiteDN,
                                    (DSNAME *) pRefBL->AttrVal.pAVal[0].pVal,
                                    pItemV2);
            }

            THFree(pSiteDN);
            pSiteDN = NULL;

            if ( NameMatched(pPdcServerDN,
                             (DSNAME *) pRefBL->AttrVal.pAVal[0].pVal) )
            {
                *pfIsPdc = TRUE;
            }
        }
    }

    return(ERROR_SUCCESS);
}


DWORD
DcInfoHelperLdapObj(
    THSTATE *pTHS,
    VOID    *pmsgOut
    )
/*++

  Routine Description:

    Helper function which handles ldap related requests.

    currently we only support infor level FFFFFFFF which queries for
    active ldap connections.

  Parameters:

    pTHS - Valid THSTATE pointer.

    pmsgOut - Empty DRS_MSG_DCINFOREPLY struct to be filled on return.

  Return Values:

    WIN32 error code.

--*/
{
    DWORD   *pcItems = NULL;
    PVOID   *prItems = NULL;
    DWORD   xCode;
    DWORD   err = ERROR_SUCCESS;
    DWORD   DumpAccessCheck(IN LPCSTR pszCaller);

    Assert(VALID_THSTATE(pTHS));

    __try {

        // Check permissions
        err = DumpAccessCheck("ldapConnDump");
        if ( err != ERROR_SUCCESS ) {
            __leave;
        }

        pcItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->VFFFFFFFF.cItems;
        prItems = & ((DRS_MSG_DCINFOREPLY *) pmsgOut)->VFFFFFFFF.rItems;

        Assert(!*pcItems && !*prItems);

        //
        // See how many entries there are by passing a null buffer
        //

        err = LdapEnumConnections(pTHS,pcItems,prItems);

    } __except(HandleMostExceptions(xCode = GetExceptionCode())) {

        err = DsaExceptionToWin32(xCode);
    }

    return(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\remove.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       remove.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module implements the drs interface routines for decommissioning
    servers and domains

Author:

    Colin Brace     (ColinBr)   02-Feb-98

Revision History:

    Colin Brace     (ColinBr)   02-Feb-98
        Created by adding DsRemoveDsServer, DsRemoveDsDomain

--*/

#include <NTDSpch.h>
#pragma hdrstop

// Core headers.
#include <ntdsa.h>                      // Core data types 
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // SPN
#include <debug.h>                      // Assert()
#include <dsatools.h>                   // Memory, etc.
#include <cracknam.h>                   // name cracking prototypes
#include <drs.h>                        // prototypes and CONTEXT_HANDLE_TYPE_*
#include <drautil.h>                    // DRS_CLIENT_CONTEXT
#include <anchor.h>

#include <ntdsa.h>                      // Dir* Api
#include <filtypes.h>                   // For filter construction
#include <attids.h>                     // for filter construction
#include <dsconfig.h>                   // GetConfigParam

// Logging headers.
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <dsevent.h>                    // Only needed for LogUnhandledError

// Assorted DSA headers.
#include <dsexcept.h>
#include <servinfo.h>

#include <ntdsapi.h>

#include "debug.h"                      // standard debugging header 
#define DEBSUB "DRASERV:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_NTDSAPI


// Guard the strings that are passed into the Remove API's. There is no 
// technical maximum size to a DN Value so 8096 was chosen as a length that 
// won't cause damage if abused and shouldn't cause any reasonable limitations 
// in the future. This won't cause a reasonable limitations because the DN's for
// the interfaces in this file are only domain and Ntds Setting objects.  
// A domain DN is limited by the maximum size of a DNS name (256 characters) and
// the Ntds Setting object has a fixed position wrt the domain name.
// Both of these calculations come well below 8096 characters.
#define MAXIMUM_INTERFACE_DN_STRING_LENGTH  8096


//
// Local forwards
//
DWORD
IsLastDcInDomain(
    IN  DSNAME *Server,
    IN  DSNAME *Domain,
    OUT BOOL   *fLastDcInDomain
    );

DWORD
DoesServerExistLocally(
    IN  DSNAME *Server
    );

DWORD
FindCrossRefObject(
    IN  DSNAME *Domain,
    OUT DSNAME **CrossRef
    );


DWORD 
GiveDeleteTreePermission(
    IN  DSNAME     *Object
    );
    
DWORD 
RemoveRidSetObject(
    IN DSNAME* ComputerObject
    );

DWORD 
RemoveDSSPNs(
    IN DSNAME* ComputerObject
    );

DWORD 
GetComputerObject(
    IN DSNAME*   ServerObject,
    OUT DSNAME** ComputerObject
    );

DWORD
AddAceToSd(
    IN  PSECURITY_DESCRIPTOR pSd,
    IN  PSID                 pClientSid,
    IN  ULONG                AccessMask,
    OUT PSECURITY_DESCRIPTOR *ppNewSd,
    OUT PULONG               pcbNewSd
    );

DWORD
AddAceToAcl(
    IN  PACL  pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PACL *ppNewAcl
    );

DWORD
GetClientSid( 
    OUT PSID *pClientSid
    );

//
// Function definitions
//

ULONG
RemoveDsServerWorker(
    IN  LPWSTR  ServerDN,        
    IN  LPWSTR  DomainDN OPTIONAL,
    OUT BOOL   *fLastDcInDomain OPTIONAL,
    IN  BOOL    fCommit
    )
/*++

Routine Description:

    This routine is the server side portion of DsRemoveDsServer.

Arguments:

    ServerDN: null terminated string of the server to remove as a ds

    DomainDN: null terminated string of a domain

    fLastDcInDomain: set to TRUE on success if ServerDN is the last server
                     in DomainDN

    fCommit: if TRUE, ServerDN is deleted

Return Values:

    A value from the win32 error space.

--*/
{
    NTSTATUS  NtStatus;
    THSTATE   *pTHS;
    ULONG     DirError, WinError;
    LPWSTR    NtdsServerDN = NULL;
    LPWSTR    NtdsaPrefix = L"CN=Ntds Settings,";
    DSNAME    *Server=NULL, *Domain=NULL, *ServerObject=NULL;
    ULONG     Length, Size;
    SEARCHRES *SearchRes;
    DSNAME    *AccountObject = NULL;
    BOOL      fStatus;
    ULONG     RetryCount = 0;

    //
    // Parameter analysis
    //
    Assert( ServerDN );


    // Gaurd the string length for allocation
    if ( wcslen(ServerDN) > MAXIMUM_INTERFACE_DN_STRING_LENGTH 
     || (DomainDN && (wcslen(DomainDN) > MAXIMUM_INTERFACE_DN_STRING_LENGTH))) {
        return ERROR_INVALID_PARAMETER;
    }

    
    // Initialize thread state
    if ( !(pTHS=InitTHSTATE(CALLERTYPE_NTDSAPI)) )
    {
        WinError = ERROR_DS_INTERNAL_FAILURE;
        goto Cleanup;
    }
    
    //
    // Setup the dsname for the server's ntdsa object
    //
    Size = ( wcslen( NtdsaPrefix )
           + wcslen( ServerDN )
           + 1 ) * sizeof( WCHAR );  // good ol' NULL

    NtdsServerDN = (LPWSTR) THAlloc(Size);
    if (!NtdsServerDN) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    wcscpy( NtdsServerDN, NtdsaPrefix );
    wcscat( NtdsServerDN, ServerDN );

    Length = wcslen( NtdsServerDN );
    Size =  DSNameSizeFromLen( Length );
    Server = (DSNAME*) THAlloc(Size);
    if (!Server) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Server->structLen = Size;
    Server->NameLen = Length;
    wcscpy( Server->StringName, NtdsServerDN );

    ServerObject = (DSNAME*) THAlloc(Size);
    if (!ServerObject) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    ServerObject->structLen = Size;

    fStatus = TrimDSNameBy( Server, 1, ServerObject );


    //
    // We don't have to make sure the server in question is not the 
    // current server, because DirRemoveEntry does that automatically.
    //

    //
    // Get the dsname of the associated Account (computer) object
    //
    WinError = GetComputerObject( ServerObject, &AccountObject );
    if ( ERROR_SUCCESS != WinError )
    {
        //
        // Writable computer object not here? Continue on -- the SPN's and 
        // RID set objects won't be cleaned up.  The most common server 
        // removal scenario is a replica removal in which case the administrator
        // is guided by the UI to choose a replica in the domain.  When 
        // removing the last DC in a domain, this code path allowing the 
        // deletion to succeed is necessary to allow the removal to occur.
        //
        WinError = ERROR_SUCCESS;
    }

    //
    // Determine if this is the last dc in a domain
    //
    if ( DomainDN )
    {
        Length = wcslen( DomainDN );
        Size =  DSNameSizeFromLen( Length );
        Domain = (DSNAME*) THAlloc(Size );
        if (!Domain) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        Domain->structLen = Size;
        Domain->NameLen = Length;
        wcscpy( Domain->StringName, DomainDN );

        //
        // Search for servers containing the domain dn and
        // set fLastDcInDomain
        //
        WinError = GetDcsInNcTransacted(pTHStls,
                                        Domain,
                                        EN_INFOTYPES_TYPES_VALS,
                                        &SearchRes);

        if ( ERROR_SUCCESS != WinError )
        {
            THFreeEx(pTHS,Domain);
            goto Cleanup;
        }

        if (SearchRes->count == 0) {
            // No DC's in domain? Either there are really no DC's or
            // that caller didn't have access.  If there are no DC's in the
            // domain, the input parameter isn't good as the intent of the 
            // parameter is to indicate what domain the ServerDN is a 
            // member of.
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if (  SearchRes->count == 1 
           && NameMatched( Server, SearchRes->FirstEntInf.Entinf.pName ) )
        {
            if ( fLastDcInDomain )
            {
                *fLastDcInDomain = TRUE;
            }
        }

        THFreeEx(pTHS,Domain);

    }

    //
    // Remove the entries, if necessary
    //
    if ( fCommit )
    {
        BOOLEAN   fRemoveDomain = FALSE;
        REMOVEARG RemoveArg;
        REMOVERES *RemoveRes;

        //
        // Give ourselves delete tree permission since by default the enterprise
        // admins don't have delete tree access in the configuration container.
        // Note - if the caller doesn't have access to write to the DACL this
        // call will, properly, fail with ERROR_ACCESS_DENIED.
        //

        WinError = GiveDeleteTreePermission( Server );
        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // Delete the server object
        //
        RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

        RemoveArg.pObject = Server;
        RemoveArg.fPreserveRDN = FALSE;
        RemoveArg.fGarbCollectASAP = FALSE;
        RemoveArg.fTreeDelete = TRUE;  // remove connection objects
        RemoveArg.pMetaDataVecRemote = NULL;
        InitCommarg( &RemoveArg.CommArg );

        // We want configuration changes to travel fast
        RemoveArg.CommArg.Svccntl.fUrgentReplication = TRUE;

        do
        {
            if ( RetryCount > 0 )
            {
                // arbitrary amount of time
                Sleep( 100 );
            }
    
            DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );
            
            if (RemoveRes) {
                WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );
            } else {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
            }
    
            THClearErrors();

            RetryCount += 1;

        } while ( (ERROR_DS_BUSY == WinError) && (RetryCount < 5)  );

        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // If the ntdsa object was deleted try to delete the rid set object
        // If we are in the same domain
        //
        if ( AccountObject )
        {
            WinError = RemoveRidSetObject( AccountObject );
            if ( ERROR_SUCCESS != WinError )
            {
                //
                // This is not fatal.  Why not?  Because should this server
                // be made a replica again, then this rid pool will be re-used.
                // No other dc will have this rid pool since the rid master has 
                // not reclaimed these rids.
                //
                WinError = ERROR_SUCCESS;
            }

            //
            // Remove the REPL spn
            //
            WinError = RemoveDSSPNs( AccountObject );
            if ( ERROR_SUCCESS != WinError )
            {
                //
                // This is not fatal because it simply means an extra
                // SPN is left on the machine account.
                //
                WinError = ERROR_SUCCESS;
            }


        }

    }
    else
    {
        //
        // Search to make sure the object is here to be deleted
        //
        if ( !fLastDcInDomain )
        {
            WinError = DoesServerExistLocally( Server );
        }

    }

    //
    // That's it - fall through to cleanup
    //

Cleanup:
    if (NtdsServerDN) THFreeEx(pTHS,NtdsServerDN);
    if (Server) THFreeEx(pTHS,Server);
    if (ServerObject) THFreeEx(pTHS,ServerObject);
    
    if (  ERROR_FILE_NOT_FOUND   == WinError
       || ERROR_NOT_FOUND        == WinError
       || ERROR_DS_OBJ_NOT_FOUND == WinError
       || ERROR_OBJECT_NOT_FOUND == WinError
       || ERROR_PATH_NOT_FOUND   == WinError  )
    {
        WinError = DS_ERR_CANT_FIND_DSA_OBJ;
    }

    return( WinError );

}

DWORD
RemoveDsDomainWorker(
    IN LPWSTR  DomainDN
    )
/*++

Routine Description:

    This routine actually does the work of removing the crossref object
    for the specified domain.

Arguments:

    DomainDN  :  null terminated domain DN

Return Values:

    A value from the winerror space.

--*/
{

    THSTATE    *pTHS;
    NTSTATUS   NtStatus;
    DWORD      DirError, WinError;

    DSNAME    *Domain=NULL, *CrossRef, *HostedDomain=NULL;
    ULONG      Size, Length;
    SEARCHRES *SearchRes;

    //
    // Parameter analysis
    //
    Assert( DomainDN );

    // Gaurd the string length for allocation
    if (wcslen(DomainDN) > MAXIMUM_INTERFACE_DN_STRING_LENGTH) {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize thread state

    if ( !(pTHS=InitTHSTATE(CALLERTYPE_NTDSAPI)) )
    {
        WinError = ERROR_DS_INTERNAL_FAILURE;
        goto Cleanup;
    }


    //
    // Make a dsname for the domain
    //
    Length = wcslen( DomainDN );
    Size   = DSNameSizeFromLen( Length );
    Domain = (DSNAME*) THAlloc(Size);
    if (!Domain) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Domain->structLen = Size;
    Domain->NameLen = Length;
    wcscpy( Domain->StringName, DomainDN );

    //
    // Is this domain currently hosted on this DC
    //
    Size = 0;
    NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                     &Size,
                                     HostedDomain );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        HostedDomain = (DSNAME*) THAlloc(Size);

        if (!HostedDomain) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         HostedDomain );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = RtlNtStatusToDosError( NtStatus );
        goto Cleanup;
    }

    if ( NameMatched( HostedDomain, Domain ) )
    {
        WinError = DS_ERR_ILLEGAL_MOD_OPERATION;
        goto Cleanup;
    }


    //
    // Do any servers exist in this domain?
    // DaveStr - 5/26/99 - This is redundant as CrossRef deletion now checks
    // to see if the NC is mastered by anyone before and rejects if true.
    //
    WinError = GetDcsInNcTransacted(pTHStls,
                                    Domain,
                                    EN_INFOTYPES_TYPES_VALS,
                                    &SearchRes);

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    if ( SearchRes->count == 0 )
    {
        REMOVEARG RemoveArg;
        REMOVERES *RemoveRes;
        ULONG     RetryCount = 0;

        //
        // Get the name of the cross ref object
        //
        WinError = FindCrossRefObject( Domain,
                                       &CrossRef );

        if ( ERROR_SUCCESS != WinError )
        {
            goto Cleanup;
        }

        //
        // Delete that object
        //
        RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

        RemoveArg.pObject = CrossRef;
        RemoveArg.fPreserveRDN = FALSE;
        RemoveArg.fGarbCollectASAP = FALSE;
        RemoveArg.fTreeDelete = FALSE;    
        RemoveArg.pMetaDataVecRemote = NULL;
        InitCommarg( &RemoveArg.CommArg );

        // We want configuration changes to travel fast
        RemoveArg.CommArg.Svccntl.fUrgentReplication = TRUE;

        do
        {
            if ( RetryCount > 0 )
            {
                // arbitrary amount of time
                Sleep( 100 );
            }
    
            DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );
            
            WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );

            THClearErrors();

            RetryCount += 1;


        } while ( (ERROR_DS_BUSY == WinError) && (RetryCount < 5)  );

        // We should understand these cases
        Assert( WinError != ERROR_DS_BUSY );

        if (  ERROR_FILE_NOT_FOUND   == WinError
           || ERROR_NOT_FOUND        == WinError
           || ERROR_DS_OBJ_NOT_FOUND == WinError
           || ERROR_OBJECT_NOT_FOUND == WinError
           || ERROR_PATH_NOT_FOUND   == WinError  )
        {
            WinError = DS_ERR_NO_CROSSREF_FOR_NC;
        }

    }
    else
    {
        //
        // There still exist servers with that claim to hold this nc
        // we can't delete it
        //
        WinError = ERROR_DS_NC_STILL_HAS_DSAS;

    }

    //
    // That's it fall through to Cleanup
    //

Cleanup:
    if (Domain) THFreeEx(pTHS,Domain);
    if (HostedDomain) THFreeEx(pTHS,HostedDomain); 

    return ( WinError );
}

DWORD
FindCrossRefObject(
    IN  DSNAME *Domain,
    OUT DSNAME **CrossRef
    )
/*++

Routine Description:

   This routine finds the crossref object for a given domain

Arguments:

    Domain : a valid dsname

    CrossRef: a dsname allocated from the thread heap

Return Values:

    An appropriate winerror.

--*/
{
    THSTATE *pTHS = pTHStls;

    DWORD    WinError, DirError;
    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes;

    DWORD      dwCrossRefClass = CLASS_CROSS_REF;

    DSNAME     *PartitionsContainer;
    DWORD      Size;
    FILTER     ObjClassFilter, NcNameFilter, AndFilter;


    Assert( Domain );
    Assert( CrossRef );

    //
    // Default the out parameter
    //
    WinError = DS_ERR_NO_CROSSREF_FOR_NC; 
    *CrossRef = NULL;

    //
    //  Get the base dsname to search from
    //
    Size = 0;
    PartitionsContainer = NULL;
    NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                     &Size,
                                     PartitionsContainer );
    if ( NtStatus == STATUS_BUFFER_TOO_SMALL )
    {
        PartitionsContainer = (DSNAME*) THAlloc(Size);
        if (!PartitionsContainer) {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        NtStatus = GetConfigurationName( DSCONFIGNAME_PARTITIONS,
                                         &Size,
                                         PartitionsContainer );

    }

    if ( !NT_SUCCESS( NtStatus ) )
    {
        WinError = DS_ERR_NO_CROSSREF_FOR_NC;
        goto Cleanup;
    }

    //
    // Setup the filter
    //
    RtlZeroMemory( &AndFilter, sizeof( AndFilter ) );
    RtlZeroMemory( &ObjClassFilter, sizeof( NcNameFilter ) );
    RtlZeroMemory( &NcNameFilter, sizeof( NcNameFilter ) );

    NcNameFilter.choice = FILTER_CHOICE_ITEM;
    NcNameFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.type = ATT_NC_NAME;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = Domain->structLen;
    NcNameFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) Domain;

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwCrossRefClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwCrossRefClass;

    AndFilter.choice                    = FILTER_CHOICE_AND;
    AndFilter.FilterTypes.And.count     = 2;

    AndFilter.FilterTypes.And.pFirstFilter = &ObjClassFilter;
    ObjClassFilter.pNextFilter = &NcNameFilter;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = PartitionsContainer;
    SearchArg.choice  = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &AndFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( 0 == DirError )
    {
        ASSERT( SearchRes );
        if ( SearchRes->count == 1 )
        {
            *CrossRef = SearchRes->FirstEntInf.Entinf.pName;
            WinError = ERROR_SUCCESS;
        }
    }

    //
    // That's it - fall through to cleanup

Cleanup:
    if (PartitionsContainer) THFreeEx(pTHS,PartitionsContainer);
    return WinError;

}

DWORD
DoesServerExistLocally(
    IN  DSNAME *Server
    )
/*++

Routine Description:

   This routine determines if the local dc has a copy of Server.

Arguments:

    Server: a valid dsname

Return Values:

    ERROR_SUCCESS if the object exists; DS_ERR_CANT_FIND_DSA_OBJ otherwise

--*/
{

    DWORD    WinError, DirError;
    NTSTATUS NtStatus;

    SEARCHARG  SearchArg;
    SEARCHRES  *SearchRes;

    DWORD      dwNtdsDsaClass = CLASS_NTDS_DSA;

    DWORD      Size;
    FILTER     ObjClassFilter;

    Assert( Server );

    //
    // Default the return parameter
    //
    WinError = DS_ERR_CANT_FIND_DSA_OBJ; 

    //
    // Setup the filter
    //
    RtlZeroMemory( &ObjClassFilter, sizeof( ObjClassFilter ) );

    ObjClassFilter.choice = FILTER_CHOICE_ITEM;
    ObjClassFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CLASS;
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof( dwNtdsDsaClass );
    ObjClassFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (BYTE*) &dwNtdsDsaClass;
    ObjClassFilter.pNextFilter = NULL;

    RtlZeroMemory( &SearchArg, sizeof(SearchArg) );
    SearchArg.pObject = Server;
    SearchArg.choice  = SE_CHOICE_BASE_ONLY;
    SearchArg.bOneNC  = TRUE;
    SearchArg.pFilter = &ObjClassFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = NULL;  // don't need any attributes
    SearchArg.pSelectionRange = NULL;
    InitCommarg( &SearchArg.CommArg );

    DirError = DirSearch( &SearchArg, &SearchRes );

    if ( 0 == DirError )
    {
        Assert( SearchRes );
        if ( SearchRes->count == 1 )
        {
            WinError = ERROR_SUCCESS;
        }
    }

    return WinError;

}


DWORD 
GiveDeleteTreePermission(
    IN  DSNAME     *Object
    )
/*++

Routine Description:

    This object gives the built in admin's sid delete tree access to Object

Arguments:

    Object: a valid dsname

Return Values:
    
    ERROR_SUCCESS; ERROR_ACCESS_DENIED

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    READARG    ReadArg;
    READRES   *ReadResult;

    MODIFYARG  ModifyArg;
    MODIFYRES *ModifyRes;

    ENTINFSEL    EISelection; // Entry Information Selection
    ATTRBLOCK    AttrBlock;
    ATTRVALBLOCK AttrValBlock;
    ATTR         Attr;
    ATTRVAL     *pAttrVal = NULL;
    ATTRVAL      AttrVal;
    ULONG        ValCount = 0;
    ULONG        ValLength = 0;

    PSECURITY_DESCRIPTOR pSd = NULL, pNewSd = NULL;
    PSID        pClientSid = NULL;
    ULONG       SecurityFlags = DACL_SECURITY_INFORMATION;
    PACL        Dacl; 

    ULONG     Length;
    BOOL      fStatus;


    //
    // Parameter check
    //
    Assert( Object );

    RtlZeroMemory(&AttrBlock, sizeof(ATTRBLOCK));
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&ModifyArg, sizeof(MODIFYARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&AttrValBlock, sizeof(ATTRVALBLOCK));

    //
    // Read the security descriptor
    //
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    AttrBlock.attrCount = 1;
    AttrBlock.pAttr = &Attr;
    EISelection.AttrTypBlock = AttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    ReadArg.pSel = &EISelection;
    ReadArg.pObject = Object;
    InitCommarg( &ReadArg.CommArg );

    // Don't try to read the SACL
    ReadArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;

    DirError = DirRead( &ReadArg, &ReadResult );

    WinError = DirErrorToWinError(DirError, &ReadResult->CommRes);

    THClearErrors();

    if ( ERROR_SUCCESS != WinError )
    {
        if ( ERROR_DS_NO_REQUESTED_ATTS_FOUND == WinError )
        {
            // couldn't find the sd? probably wrong credentials
            WinError = ERROR_ACCESS_DENIED;
        }
        goto Cleanup;
    }

    //
    // Extract the value
    //

    ASSERT(NULL != ReadResult);
    AttrBlock = ReadResult->entry.AttrBlock;
    pAttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
    ValCount = AttrBlock.pAttr[0].AttrVal.valCount;
    Assert(1 == ValCount);

    pSd = (PDSNAME)(pAttrVal[0].pVal);
    Length = pAttrVal[0].valLen;

    if ( NULL == pSd )
    {
        // No SD? This is bad
        WinError = ERROR_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Get the caller's sid
    //
    WinError = GetClientSid( &pClientSid );
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    WinError = AddAceToSd( pSd,
                           pClientSid,
                           ACTRL_DS_DELETE_TREE,
                           &pNewSd,
                           &Length );

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Write the security descriptor
    //
    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.pObject = Object;

    ModifyArg.FirstMod.pNextMod = NULL;
    ModifyArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = Length;
    AttrVal.pVal = (PUCHAR)pNewSd;
    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;
    Attr.attrTyp = ATT_NT_SECURITY_DESCRIPTOR;
    Attr.AttrVal = AttrValBlock;

    ModifyArg.FirstMod.AttrInf = Attr;
    ModifyArg.count = 1;

    InitCommarg( &ModifyArg.CommArg );

    //
    // We only want to change the dacl
    //
    ModifyArg.CommArg.Svccntl.SecurityDescriptorFlags = SecurityFlags;


    DirError = DirModifyEntry( &ModifyArg, &ModifyRes );

    if (ModifyRes) {
        WinError = DirErrorToWinError( DirError, &ModifyRes->CommRes );
    } else {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
    }

    THClearErrors();

    //
    // We are done
    //

Cleanup:

    if ( pClientSid )
    {
        LocalFree( pClientSid );
    }

    if ( pNewSd )
    {
        LocalFree( pNewSd );
    }

    return WinError;

}


DWORD 
RemoveRidSetObject(
    IN DSNAME* ComputerObject
    )
/*++

Routine Description:

    This routine finds and delete the rid set object for ComputerObject.

Arguments:

    ComputerObject: the computer object whose ir dobject should be deleted.

Return Values:

    ERROR_SUCCESS if the object exists; 

--*/
{
    DWORD  WinError = ERROR_SUCCESS;
    ULONG  DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;

    REMOVEARG RemoveArg;
    REMOVERES *RemoveRes;

    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    ATTR      Attr;

    DSNAME    *RidObject = NULL;

    //
    // Parameter check
    //
    Assert( ComputerObject );

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_RID_SET_REFERENCES;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ComputerObject;

    InitCommarg( &ReadArg.CommArg );

    DirError = DirRead( &ReadArg, &ReadResult );

    WinError = DirErrorToWinError( DirError, &ReadResult->CommRes );

    THClearErrors();

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    {
        // Once the RID Set Reference object has been found and read, extract
        // the RID Set DN of interest (currently only one domain is handled)
        // and return that DN for subsequent usage.

        ATTRBLOCK AttrBlock;
        PDSNAME   pVal;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);
        RidObject = pVal;

    }

    //
    // Delete the rid set object
    //
    RtlZeroMemory( &RemoveArg, sizeof( RemoveArg ) );

    RemoveArg.pObject = RidObject;
    RemoveArg.fPreserveRDN = FALSE;
    RemoveArg.fGarbCollectASAP = FALSE;
    RemoveArg.fTreeDelete = FALSE;    
    RemoveArg.pMetaDataVecRemote = NULL;
    InitCommarg( &RemoveArg.CommArg );

    DirError = DirRemoveEntry( &RemoveArg, &RemoveRes );

    WinError = DirErrorToWinError( DirError, &RemoveRes->CommRes );

    THClearErrors();

    //
    // That's it
    // 

Cleanup:

    return WinError;
}

DWORD 
GetComputerObject(
    IN DSNAME*   ServerObject,
    OUT DSNAME** ComputerObject
    )
/*++

Routine Description:

    This routine obtains the computer object from given the server object.

Arguments:

    ServerObject: an ntdsa object
    
    ComputerObject: the corresponding SAM account object                                                                          

Return Values:

    ERROR_SUCCESS if the object exists; 
    
    ERROR_NO_TRUST_SAM_ACCOUNT otherwise
    
    

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG DirError = 0;

    READARG   ReadArg;
    READRES  *ReadResult;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    ATTR      Attr;
    PDSNAME   ServerDsName = NULL;

    Assert( ServerObject );
    Assert( ComputerObject );

    //
    // Read the rid set reference property
    //
    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_SERVER_REFERENCE;

    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;

    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;

    ReadArg.pSel = &EISelection;
    ReadArg.pObject = ServerObject;

    InitCommarg(&(ReadArg.CommArg));

    DirError = DirRead(&ReadArg, &ReadResult);

    WinError = DirErrorToWinError(DirError, &ReadResult->CommRes);

    THClearErrors();

    if ( ERROR_SUCCESS == WinError )
    {
        //
        // Extract the value
        //
        ATTRBLOCK AttrBlock;
        PDSNAME   pVal;
        ATTRVAL *AttrVal = NULL;
        ULONG ValCount = 0;
        ULONG ValLength = 0;
        ULONG Index = 0;

        CROSS_REF * pCR;
        COMMARG  CommArg;

        ASSERT(NULL != ReadResult);

        AttrBlock = ReadResult->entry.AttrBlock;
        AttrVal = AttrBlock.pAttr[0].AttrVal.pAVal;
        ValCount = AttrBlock.pAttr[0].AttrVal.valCount;

        for (Index = 0; Index < ValCount; Index++)
        {
            pVal = (PDSNAME)(AttrVal[Index].pVal);
            ValLength = AttrVal[Index].valLen;
            ASSERT(1 == ValCount);
        }
        ASSERT(NULL != pVal);

        // Make sure we are authoritative for this object
        InitCommarg(&CommArg);
        CommArg.Svccntl.dontUseCopy = FALSE;

        pCR = FindBestCrossRef(pVal, &CommArg);
        if (   pCR 
            && pCR->pNC
            && NameMatched( pCR->pNC, gAnchor.pDomainDN ) ) {

            // This is good
            *ComputerObject = pVal;
            
        } else {
            WinError = ERROR_NO_TRUST_SAM_ACCOUNT;
        }

    }
    else
    {
        //
        // We couldn't find it 
        //
        WinError = ERROR_NO_TRUST_SAM_ACCOUNT;

    }

    return WinError;
}



DWORD
AddAceToSd(
    IN  PSECURITY_DESCRIPTOR pOldSd,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PSECURITY_DESCRIPTOR *ppNewSd,
    OUT PULONG pcbNewSd
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{

    DWORD  WinError = ERROR_SUCCESS;
    BOOL   fStatus;

    PSECURITY_DESCRIPTOR pNewSelfRelativeSd = NULL;
    DWORD                NewSelfRelativeSdSize = 0;
    PACL                 pNewDacl  = NULL;

    SECURITY_DESCRIPTOR  AbsoluteSd;
    PACL                 pDacl  = NULL;
    PACL                 pSacl  = NULL;
    PSID                 pGroup = NULL;
    PSID                 pOwner = NULL;

    DWORD AbsoluteSdSize = sizeof( SECURITY_DESCRIPTOR );
    DWORD DaclSize = 0;
    DWORD SaclSize = 0;
    DWORD GroupSize = 0;
    DWORD OwnerSize = 0;


    // Parameter check
    Assert( pOldSd );
    Assert( pClientSid );
    Assert( ppNewSd );

    // Init the out parameters
    *ppNewSd = NULL;
    *pcbNewSd = 0;

    RtlZeroMemory( &AbsoluteSd, AbsoluteSdSize );

    //
    // Make sd absolute
    //
    fStatus = MakeAbsoluteSD( pOldSd,
                              &AbsoluteSd,
                              &AbsoluteSdSize,
                              pDacl,
                              &DaclSize,
                              pSacl,
                              &SaclSize,
                              pOwner,
                              &OwnerSize,
                              pGroup,
                              &GroupSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        if ( 0 == DaclSize )
        {
            // No Dacl? We can't write to the dacl, then
            WinError = ERROR_ACCESS_DENIED;
            goto Cleanup;
        }

        if (    (DaclSize > 0) && !(pDacl = LocalAlloc(0,DaclSize))
             || (SaclSize > 0) && !(pSacl = LocalAlloc(0,SaclSize))
             || (OwnerSize > 0) && !(pOwner = LocalAlloc(0,OwnerSize))
             || (GroupSize > 0) && !(pGroup = LocalAlloc(0,GroupSize)) )
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        if ( pDacl )
        {
            fStatus = MakeAbsoluteSD( pOldSd,
                                      &AbsoluteSd,
                                      &AbsoluteSdSize,
                                      pDacl,
                                      &DaclSize,
                                      pSacl,
                                      &SaclSize,
                                      pOwner,
                                      &OwnerSize,
                                      pGroup,
                                      &GroupSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Create a new dacl with the new ace
    //
    WinError = AddAceToAcl( pDacl,
                           pClientSid,
                           AccessMask,
                           &pNewDacl );

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // Set the dacl
    //
    fStatus = SetSecurityDescriptorDacl ( &AbsoluteSd,
                                         TRUE,     // dacl is present
                                         pNewDacl,
                                         FALSE );  //  facl is not defaulted

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Make the new sd self relative
    //
    fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                   pNewSelfRelativeSd,
                                   &NewSelfRelativeSdSize );

    if ( !fStatus && (ERROR_INSUFFICIENT_BUFFER == (WinError = GetLastError())))
    {
        WinError = ERROR_SUCCESS;

        pNewSelfRelativeSd = LocalAlloc( 0, NewSelfRelativeSdSize );

        if ( pNewSelfRelativeSd )
        {
            fStatus =  MakeSelfRelativeSD( &AbsoluteSd,
                                           pNewSelfRelativeSd,
                                           &NewSelfRelativeSdSize );
    
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // That's it fall through to cleanup
    //

Cleanup:
    if (pDacl) 
    {
        LocalFree(pDacl);
    }
    if (pSacl) 
    {
        LocalFree(pSacl);
    }
    if (pOwner) 
    {
        LocalFree(pOwner);
    }
    if (pGroup) 
    {
        LocalFree(pGroup);
    }
    if ( pNewDacl )
    {
        LocalFree( pNewDacl );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        Assert( pNewSelfRelativeSd );
        *ppNewSd = pNewSelfRelativeSd;
        *pcbNewSd = NewSelfRelativeSdSize;
    }
    else
    {
        if ( pNewSelfRelativeSd )
        {
            LocalFree( pNewSelfRelativeSd );
        }
    }

    return WinError;

}

DWORD
AddAceToAcl(
    IN  PACL pOldAcl,
    IN  PSID  pClientSid,
    IN  ULONG AccessMask,
    OUT PACL *ppNewAcl
    )
/*++

Routine Description:

    This routine creates a new sd with a new ace with pClientSid and AccessMask

Arguments:

    pOldAcl
    
    pClientSid
    
    AccessMask
    
    pNewAcl

Return Values:

    ERROR_SUCCESS if the ace was put in the sd
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    BOOL  fStatus;

    ACL_SIZE_INFORMATION     AclSizeInfo;
    ACL_REVISION_INFORMATION AclRevInfo;
    ACCESS_ALLOWED_ACE       Dummy;

    PVOID  FirstAce = 0;
    PACL   pNewAcl = 0;

    ULONG NewAclSize, NewAceCount, AceSize;

    // Parameter check
    Assert( pOldAcl );
    Assert( pClientSid );
    Assert( ppNewAcl );

    // Init the out parameter
    *ppNewAcl = NULL;

    memset( &AclSizeInfo, 0, sizeof( AclSizeInfo ) );
    memset( &AclRevInfo, 0, sizeof( AclRevInfo ) );

    //
    // Get the old sd's values
    //
    fStatus = GetAclInformation( pOldAcl,
                                 &AclSizeInfo,
                                 sizeof( AclSizeInfo ),
                                 AclSizeInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = GetAclInformation( pOldAcl,
                                 &AclRevInfo,
                                 sizeof( AclRevInfo ),
                                 AclRevisionInformation );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Calculate the new sd's values
    //
    AceSize = sizeof( ACCESS_ALLOWED_ACE ) - sizeof( Dummy.SidStart )
              + GetLengthSid( pClientSid );

    NewAclSize  = AceSize + AclSizeInfo.AclBytesInUse;
    NewAceCount = AclSizeInfo.AceCount + 1;

    //
    // Init the new acl
    //
    pNewAcl = LocalAlloc( 0, NewAclSize );
    if ( NULL == pNewAcl )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    fStatus = InitializeAcl( pNewAcl,
                             NewAclSize,
                             AclRevInfo.AclRevision );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Copy the old into the new
    //
    fStatus = GetAce( pOldAcl,
                      0,
                      &FirstAce );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    fStatus = AddAce( pNewAcl,
                      AclRevInfo.AclRevision,
                      0,
                      FirstAce,
                      AclSizeInfo.AclBytesInUse - sizeof( ACL ) );
    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    //
    // Finally, add the new ace
    //
    fStatus = AddAccessAllowedAce( pNewAcl,
                                   ACL_REVISION,
                                   AccessMask,
                                   pClientSid );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    // Assign the out parameter
    *ppNewAcl = pNewAcl;

    //
    // That's it fall through to cleanup
    //

Cleanup:

    if ( ERROR_SUCCESS != WinError )
    {
        if ( pNewAcl )
        {
            LocalFree( pNewAcl );
        }
    }

    return WinError;
}


DWORD
GetClientSid( 
    OUT PSID *pClientSid
    )
/*++

Routine Description:
    
    This routine returns the sid of the caller

Arguments:

    pClientSid

Return Values:

    ERROR_SUCCESS if we are are able to impersonate and grab the sid
    
--*/
{
    DWORD        WinError = ERROR_SUCCESS;
    BOOL         fImpersonate = FALSE;
    BOOL         fStatus;

    HANDLE       ThreadToken = 0;
    PTOKEN_USER  UserToken = NULL;
    DWORD        Size;


    WinError = ImpersonateAnyClient();
    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }
    fImpersonate = TRUE;

    fStatus = OpenThreadToken( GetCurrentThread(),
                               MAXIMUM_ALLOWED,
                               TRUE,
                               &ThreadToken );

    if ( !fStatus )
    {
        WinError = GetLastError();
        goto Cleanup;
    }

    Size = 0;
    fStatus = GetTokenInformation( ThreadToken,
                                   TokenUser,
                                   UserToken,
                                   Size,
                                   &Size );

    WinError = GetLastError();

    if ( ERROR_INSUFFICIENT_BUFFER == WinError )
    {
        WinError = ERROR_SUCCESS;

        UserToken = LocalAlloc( 0, Size );
        if ( UserToken )
        {
            fStatus = GetTokenInformation( ThreadToken,
                                           TokenUser,
                                           UserToken,
                                           Size,
                                           &Size );
            if ( !fStatus )
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = ERROR_NOT_ENOUGH_MEMORY;
        }


    }

    if ( ERROR_SUCCESS != WinError )
    {
        goto Cleanup;
    }

    //
    // sanity check
    //
    if ( NULL == UserToken->User.Sid )
    {
        WinError = ERROR_NO_IMPERSONATION_TOKEN;
        goto Cleanup;
    }

    //
    // Set the out parameter
    //
    Size = GetLengthSid( UserToken->User.Sid );
    *pClientSid = LocalAlloc( 0, Size );
    if ( NULL == *pClientSid )
    {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    CopySid( Size, *pClientSid, UserToken->User.Sid );

Cleanup:

    if ( UserToken )
    {
        LocalFree( UserToken );
    }

    if ( ThreadToken )
    {
        CloseHandle( ThreadToken );
    }

    if ( fImpersonate )
    {
        UnImpersonateAnyClient();
    }

    return WinError;
}


DWORD
ReadDsaSPNs(
    IN DSNAME *pObject,
    OUT ATTRVALBLOCK* pAttrValBlock
    )
// This routine reads the SPN values from pObject and puts the results,
// if any, into pAttrValBlock
{
    DWORD err;
    READARG   ReadArg;
    READRES  *ReadResult = NULL;
    ENTINFSEL EISelection; // Entry Information Selection
    ATTRBLOCK ReadAttrBlock;
    ATTR      Attr;

    RtlZeroMemory(&Attr, sizeof(ATTR));
    RtlZeroMemory(&ReadArg, sizeof(READARG));
    RtlZeroMemory(&EISelection, sizeof(ENTINFSEL));
    RtlZeroMemory(&ReadAttrBlock, sizeof(ATTRBLOCK));

    Attr.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
    ReadAttrBlock.attrCount = 1;
    ReadAttrBlock.pAttr = &Attr;
    EISelection.AttrTypBlock = ReadAttrBlock;
    EISelection.attSel = EN_ATTSET_LIST;
    EISelection.infoTypes = EN_INFOTYPES_TYPES_VALS;
    ReadArg.pSel = &EISelection;
    ReadArg.pObject = pObject;
    InitCommarg( &ReadArg.CommArg );

    // Issue the read
    err = DirRead( &ReadArg, &ReadResult );

    if (ReadResult) {
        err = DirErrorToWinError( err, &ReadResult->CommRes );
    } else {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    THClearErrors();

    if (!err) {
        // Return the results
        if ((ReadResult->entry.AttrBlock.attrCount == 1)
        &&  (ReadResult->entry.AttrBlock.pAttr[0].attrTyp == ATT_SERVICE_PRINCIPAL_NAME)) {
            *pAttrValBlock = ReadResult->entry.AttrBlock.pAttr[0].AttrVal;
        } else {
            memset(pAttrValBlock, 0, sizeof(*pAttrValBlock));
        }   
    }

    return err;
}

DWORD
WriteDsaSPNs(
    IN DSNAME*       pObject,
    IN UCHAR         choice,
    IN ATTRVALBLOCK* pAttrValBlock
    )
// This routine adds or remove the SPN's in pAttrValBlock on object
// pObject.
{
    DWORD        err = 0;
    MODIFYARG    ModifyArg;
    MODIFYRES   *ModifyRes;
    ATTR         Attr;

    // Prepare the arguments
    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.pObject = pObject;
    Attr.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
    Attr.AttrVal = *pAttrValBlock;
    ModifyArg.FirstMod.AttrInf = Attr;
    ModifyArg.FirstMod.pNextMod = NULL;
    ModifyArg.FirstMod.choice = choice;
    ModifyArg.count = 1;
    InitCommarg( &ModifyArg.CommArg );

    // Issue the modify
    err = DirModifyEntry( &ModifyArg, &ModifyRes );

    if (ModifyRes) {
        err = DirErrorToWinError( err, &ModifyRes->CommRes );
    } else {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    THClearErrors();

    return err;
}

DWORD 
RemoveDSSPNs(
    IN DSNAME* ComputerObject
    )
/*++

Routine Description:
    
    This routine removes the SPN's that the DS registered on itself

    First the routine reads all the SPN that are registered on the object,
    determine which are to be removed (based on a static table) and then
    removes said SPN's.
    
Arguments:

    ComputerObject -- DN of the machine account

Return Values:

    ERROR_SUCCESS if we are are able to impersonate and grab the sid
    
--*/
{

    DWORD err = 0;
    THSTATE * pTHS = pTHStls;
    ATTRVALBLOCK    SPNAttrValRead = {0};
    ATTRVALBLOCK    SPNAttrValWrite = {0};
    ULONG i, j;

    // The list of services to remove
    ServiceClassArray *pClasses = &ServicesToRemove;

    // Read all of the SPN's 
    err = ReadDsaSPNs(ComputerObject, &SPNAttrValRead);
    if (err) {
        goto Exit;
    }

    // Nothing to do
    if (SPNAttrValRead.valCount == 0) {
        goto Exit;
    }

    // Remove the SPN's we are responsible for by iterating through the 
    // SPN's currently on the object and noting which are for services
    // that we own.  Then, issue a "remove value" for all such SPN's
    SPNAttrValWrite.valCount = 0;
    SPNAttrValWrite.pAVal = THAllocEx(pTHS, SPNAttrValRead.valCount * sizeof(ATTRVAL));
    for (i = 0; i < SPNAttrValRead.valCount; i++) {

       WCHAR  ServiceClass[256];
       ULONG  ccServiceClass = RTL_NUMBER_OF(ServiceClass);
       USHORT InstancePort;
       BOOL fFound = FALSE;
       WCHAR  SpnBuffer[256];
       WCHAR *Spn;
       ULONG  valLen;

       valLen = SPNAttrValRead.pAVal[i].valLen;
       if (valLen + sizeof(WCHAR) > sizeof(SpnBuffer)) {
           Spn = THAllocEx(pTHS, valLen  + sizeof(WCHAR));
       } else {
           Spn = SpnBuffer;
       }
       memcpy(Spn, SPNAttrValRead.pAVal[i].pVal, valLen); 
       Spn[valLen/sizeof(WCHAR)] = L'\0';

       err = DsCrackSpnW(Spn,
                         &ccServiceClass, ServiceClass,
                         NULL, 0,
                         NULL, 0,
                        &InstancePort);

       if((!err)
       && (ccServiceClass < RTL_NUMBER_OF(ServiceClass))) { // None of our service classes are longer

           for(j=0; j<pClasses->count; j++) {
               if(2 == CompareStringW(
                       DS_DEFAULT_LOCALE,
                       DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                       ServiceClass,
                       ccServiceClass,
                       (WCHAR *)
                       pClasses->Vals[j],
                       wcslen(pClasses->Vals[j]))) {
                   fFound=TRUE;
                   break;
               }
           }
       }

       if (Spn != SpnBuffer) {
           THFreeEx(pTHS, Spn);
       }

       if (fFound) {
           // Put in the list to remove.
           ULONG count = SPNAttrValWrite.valCount;
           SPNAttrValWrite.pAVal[count].valLen = SPNAttrValRead.pAVal[i].valLen;
           SPNAttrValWrite.pAVal[count].pVal = SPNAttrValRead.pAVal[i].pVal;
           SPNAttrValWrite.valCount++;

       }
    }

    if (SPNAttrValWrite.valCount == 0) {
        // Nothing to do
        err = ERROR_SUCCESS;
        goto Exit;
    }

    // Issue the modification to remove these SPN's
    err = WriteDsaSPNs(ComputerObject, 
                       AT_CHOICE_REMOVE_VALUES, 
                      &SPNAttrValWrite);

Exit:

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\gclogon.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gclogon.c
//
//--------------------------------------------------------------------------

/*++

    This File Contains Services Pertaining to Reverse Membership Lookup
    in a G.C


    Author

        Murlis

    Revision History

        4/8/97 Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsctr.h>                   // PerfMon hook support

// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>                     // schema cache
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#include <dsatools.h>                   // needed for output allocation

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */
#include "dstrace.h"

// Assorted DSA headers.
#include "anchor.h"
#include "objids.h"                     /* Defines for selected classes and atts*/
#include <hiertab.h>
#include "dsexcept.h"
#include "permit.h"


#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "DRASERV:"           /* define the subsystem for debugging */


#include "dsaapi.h"
#include "drsuapi.h"
#include "drsdra.h"
#include "drserr.h"
#include "draasync.h"
#include "drautil.h"
#include "draerror.h"
#include "mappings.h"
#include "drarpc.h"

#include <fileno.h>
#define  FILENO FILENO_GCLOGON

ULONG
NtStatusToDraError(NTSTATUS NtStatus)
/*++

    This Routine Maps an NtStatus error code
    to an equivalent DRA error

    Parameters:

        NtStatus - NtStatus Code to Map

    Return Values:

        Dra Error Code
--*/
{
    //
    // DRA errors are win32 errors
    //
    return RtlNtStatusToDosError(NtStatus);
}

ULONG
DRS_MSG_REVMEMB_REQ_V1_Validate(
    DRS_MSG_REVMEMB_REQ_V1 * pmsg
    ) 
/*
typedef struct _DRS_MSG_REVMEMB_REQ_V1
    {
    [range] ULONG cDsNames;
    [size_is] DSNAME **ppDsNames;
    DWORD dwFlags;
    [range] REVERSE_MEMBERSHIP_OPERATION_TYPE OperationType;
    [unique] PDSNAME pLimitingDomain;
    } 	DRS_MSG_REVMEMB_REQ_V1;
*/
{
    ULONG ret = DRAERR_Success;
    ULONG i = 0;

    if ((pmsg->cDsNames > 0) && (pmsg->ppDsNames==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    for (i=0;(i<pmsg->cDsNames) && (ret==DRAERR_Success);i++) {
	ret = DSNAME_Validate(pmsg->ppDsNames[i], FALSE);
    }

    if (ret==DRAERR_Success) {
	ret = DSNAME_Validate(pmsg->pLimitingDomain, TRUE);
    }

    return ret;
}

ULONG
DRSGetMemberships_InputValidate(
    THSTATE *               pTHS,
    DRS_HANDLE              hDrs,
    DWORD                   dwMsgInVersion,
    DRS_MSG_REVMEMB_REQ *   pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_REVMEMB_REPLY * pmsgOut
    )
/*
    [notify] ULONG IDL_DRSGetMemberships( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_REVMEMB_REQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_REVMEMB_REPLY *pmsgOut)
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgInVersion ) {
	DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 ); 
    }

    if (ret==DRAERR_Success) {
	ret = DRS_MSG_REVMEMB_REQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

ULONG
IDL_DRSGetMemberships(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_REVMEMB_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_REVMEMB_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine Evaluates the Transitive Reverse Membership on any given
        domain controller, including a G.C

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        pdwOutVersion The server's version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0;
    THSTATE                 *pTHS = pTHStls;

    DRS_Prepare(&pTHS, rpc_handle, IDL_DRSGETMEMBERSHIPS);
    drsReferenceContext( rpc_handle );
    __try {
	*pdwOutVersion = 1;
	 memset(pmsgOut, 0, sizeof(*pmsgOut));

	// Initialize thread state and open data base.

	if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM))) {
	    DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0 );
	}

	if ((ret = DRSGetMemberships_InputValidate(pTHS, 
						   rpc_handle, 
						   dwInVersion, 
						   pmsgIn, 
						   pdwOutVersion, 
						   pmsgOut))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}

	//
	// PREFIX: PREFIX complains that there is the possibility
	// of pTHS->CurrSchemaPtr being NULL at this point.  However,
	// the only time that CurrSchemaPtr could be NULL is at the
	// system start up.  By the time that the RPC interfaces
	// of the DS are enabled and this function could be called,
	// CurrSchemaPtr will no longer be NULL.
	//
	Assert(NULL != pTHS->CurrSchemaPtr);

	Assert(1 == dwInVersion);
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_MEMBERSHIPS_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsGetMemberships,
			 szInsertUL(pmsgIn->V1.cDsNames),
			 szInsertUL(pmsgIn->V1.OperationType),
			 pmsgIn->V1.pLimitingDomain
			 ? szInsertDN(pmsgIn->V1.pLimitingDomain)
			 : szInsertSz(""),
	    szInsertUL(pmsgIn->V1.dwFlags),
	    NULL, NULL, NULL, NULL);

	if (!IsDraAccessGranted(pTHS,
				gAnchor.pDomainDN,
				&RIGHT_DS_REPL_GET_CHANGES, &ret)) {
	    DRA_EXCEPT_NOLOG(ret, 0);
	}

	pTHS->fDSA = TRUE;
	DBOpen2(TRUE, &pTHS->pDB);

	__try
	    {
	    // Initialize the optional Attributes return Value, in case
	    // they are not requested

	    pmsgOut->V1.pAttributes = NULL;

	    // Initialize the Sid History field for now, not to return
	    // any Sid History
	    pmsgOut->V1.cSidHistory = 0;
	    pmsgOut->V1.ppSidHistory = NULL;

	    if ((pmsgIn->V1.OperationType==RevMembGetUniversalGroups) &&
		(!SampAmIGC())) {

		// univ group evaluation can be performed only on a GC
		ret= ERROR_DS_GC_REQUIRED;
		// set errCode to 0, will trigger failover
		pmsgOut->V1.errCode = 0;
		__leave;
	    }

	    INC( pcMemberEvalAsGC );

	    // Obtain the reverse membership
	    NtStatus = SampGetMemberships(
		pmsgIn->V1.ppDsNames,
		pmsgIn->V1.cDsNames,
		pmsgIn->V1.pLimitingDomain,
		pmsgIn->V1.OperationType,
		&(pmsgOut->V1.cDsNames),
		&(pmsgOut->V1.ppDsNames),
		((pmsgIn->V1.dwFlags) & DRS_REVMEMB_FLAG_GET_ATTRIBUTES)?
		&(pmsgOut->V1.pAttributes):NULL,
		&(pmsgOut->V1.cSidHistory),
		&(pmsgOut->V1.ppSidHistory)
	    );

	    ret = NtStatusToDraError(NtStatus);
	    pmsgOut->V1.errCode = NtStatus;


	}
	__finally
	    {

	    // End the transaction.  Faster to commit a read only
	    // transaction than abort it - so set commit to TRUE.

	    DBClose(pTHS->pDB, TRUE);
	}

    }
    __except ( GetDraException( GetExceptionInformation(), &ret ) )
    {
	;
    }

    drsDereferenceContext( rpc_handle );

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_MEMBERSHIPS_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsGetMemberships,
			 szInsertUL(ret),
			 NULL, NULL, NULL, NULL,
			 NULL, NULL, NULL);
    }
    
    return ret;
}

ULONG
DRS_MSG_GETMEMBERSHIPS2_REQ_V1_Validate(
    DRS_MSG_GETMEMBERSHIPS2_REQ_V1 * pmsg
    )
/*
typedef struct _DRS_MSG_GETMEMBERSHIPS2_REQ_V1
    {
    [range] ULONG Count;
    [size_is] DRS_MSG_REVMEMB_REQ_V1 *Requests;
    } 	DRS_MSG_GETMEMBERSHIPS2_REQ_V1;
*/
{
    ULONG ret = DRAERR_Success;
    ULONG i;

    if ((pmsg->Count > 0) && (pmsg->Requests==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    for (i=0;(i<pmsg->Count) && (ret==DRAERR_Success);i++) {
	ret = DRS_MSG_REVMEMB_REQ_V1_Validate(&(pmsg->Requests[i]));
    }

    return ret;
}

ULONG
DRSGetMemberships2_InputValidate(
    DWORD                   dwMsgInVersion,
    DRS_MSG_GETMEMBERSHIPS2_REQ *     pmsgIn,
    DWORD *                 pdwMsgOutVersion,
    DRS_MSG_GETMEMBERSHIPS2_REPLY *   pmsgOut
    )
/*
    [notify] ULONG IDL_DRSGetMemberships2( 
    [ref][in] DRS_HANDLE hDrs,
    [in] DWORD dwInVersion,
    [switch_is][ref][in] DRS_MSG_GETMEMBERSHIPS2_REQ *pmsgIn,
    [ref][out] DWORD *pdwOutVersion,
    [switch_is][ref][out] DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut) 
*/
{
    ULONG ret = DRAERR_Success;

    if ( 1 != dwMsgInVersion ) {
	DRA_EXCEPT_NOLOG( DRAERR_InvalidParameter, 0 ); 
    }

    if (ret==DRAERR_Success) {
	ret = DRS_MSG_GETMEMBERSHIPS2_REQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

ULONG
IDL_DRSGetMemberships2(
   RPC_BINDING_HANDLE  rpc_handle,
   DWORD               dwInVersion,
   DRS_MSG_GETMEMBERSHIPS2_REQ *pmsgIn,
   DWORD               *pdwOutVersion,
   DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
   )
/*++

    Routine Description:

        This Routine Evaluates the Transitive Reverse Membership on any given
        domain controller, including a GC.

    Parameters:

        rpc_handle    The Rpc Handle which the client used for binding
        dwInVersion   The Clients version of the Request packet
        psmgIn        The Request Packet
        pdwOutVersion The server's version of the Reply packet
        pmsgOut       The Reply Packet

    Return Values

        Return Values are NTSTATUS values casted as a ULONG

--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   ret = 0;
    THSTATE                *pTHS = pTHStls;
    ULONG i;

    DRS_Prepare(&pTHS, rpc_handle, IDL_DRSGETMEMBERSHIPS2);
    drsReferenceContext( rpc_handle );
    __try {
	*pdwOutVersion = 1;
	memset(pmsgOut, 0, sizeof(*pmsgOut));

	// Initialize thread state and open data base.

	if(!(pTHS = InitTHSTATE(CALLERTYPE_SAM))) {
	    DRA_EXCEPT_NOLOG( DRAERR_OutOfMem, 0 );
	}

	if ((ret = DRSGetMemberships2_InputValidate(dwInVersion, 
						    pmsgIn, 
						    pdwOutVersion, 
						    pmsgOut))!=DRAERR_Success) {
	    Assert(!"RPC Server input validation error, contact Dsrepl");
	    __leave;
	}

	//
	// PREFIX: PREFIX complains that there is the possibility
	// of pTHS->CurrSchemaPtr being NULL at this point.  However,
	// the only time that CurrSchemaPtr could be NULL is at the
	// system start up.  By the time that the RPC interfaces
	// of the DS are enabled and this function could be called,
	// CurrSchemaPtr will no longer be NULL.
	//
	Assert(NULL != pTHS->CurrSchemaPtr);

	Assert(1 == dwInVersion);

	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_ENTRY,
			 EVENT_TRACE_TYPE_START,
			 DsGuidDrsGetMemberships2,
			 szInsertUL(pmsgIn->V1.Count),
			 NULL,NULL,NULL,NULL, NULL, NULL, NULL);
 
	if (!IsDraAccessGranted(pTHS,
				gAnchor.pDomainDN,
				&RIGHT_DS_REPL_GET_CHANGES, &ret)) {
	    DRA_EXCEPT_NOLOG(ret, 0);
	}

	pTHS->fDSA = TRUE;

	//
	// Allocate space for the return buffer
	//
	pmsgOut->V1.Count = pmsgIn->V1.Count;
	pmsgOut->V1.Replies = THAllocEx(pTHS, pmsgIn->V1.Count * sizeof(DRS_MSG_REVMEMB_REPLY_V1));

	// Initialize the optional Attributes return Value, in case
	// they are not requested
	for ( i = 0; i < pmsgIn->V1.Count; i++ ) {

	    DBOpen2(TRUE, &pTHS->pDB);
	    __try
		{
		pmsgOut->V1.Replies[i].pAttributes = NULL;

		// Initialize the Sid History field for now, not to return
		// any Sid History
		pmsgOut->V1.Replies[i].cSidHistory = 0;
		pmsgOut->V1.Replies[i].ppSidHistory = NULL;

		if ((pmsgIn->V1.Requests->OperationType==RevMembGetUniversalGroups) &&
		    (!SampAmIGC())) {   

		    // univ group evaluation can be performed only on a GC
		    ret= ERROR_DS_GC_REQUIRED;
		    // set errCode to 0, will trigger failover
		    pmsgOut->V1.Replies->errCode = 0;
		    __leave;
		}

		INC( pcMemberEvalAsGC );

		// Obtain the reverse membership
		NtStatus = SampGetMemberships(
		    pmsgIn->V1.Requests[i].ppDsNames,
		    pmsgIn->V1.Requests[i].cDsNames,
		    pmsgIn->V1.Requests[i].pLimitingDomain,
		    pmsgIn->V1.Requests[i].OperationType,
		    &(pmsgOut->V1.Replies[i].cDsNames),
		    &(pmsgOut->V1.Replies[i].ppDsNames),
		    ((pmsgIn->V1.Requests[i].dwFlags) & DRS_REVMEMB_FLAG_GET_ATTRIBUTES)?
		    &(pmsgOut->V1.Replies[i].pAttributes):NULL,
		    &(pmsgOut->V1.Replies[i].cSidHistory),
		    &(pmsgOut->V1.Replies[i].ppSidHistory)
		);

		Assert(0 == ret);
		pmsgOut->V1.Replies[i].errCode = NtStatus;
	    }
	    __finally
		{

		// End the transaction.  Faster to commit a read only
		// transaction than abort it - so set commit to TRUE.

		DBClose(pTHS->pDB, TRUE);
	    }
	}
    }
    __except ( GetDraException( GetExceptionInformation(), &ret ) )
    {
	;
    }

    drsDereferenceContext( rpc_handle );

    if (NULL != pTHS) {
	LogAndTraceEvent(TRUE,
			 DS_EVENT_CAT_RPC_SERVER,
			 DS_EVENT_SEV_EXTENSIVE,
			 DIRLOG_IDL_DRS_GET_MEMBERSHIPS2_EXIT,
			 EVENT_TRACE_TYPE_END,
			 DsGuidDrsGetMemberships2,
			 szInsertUL(ret),
			 szInsertWin32Msg(ret),
			 NULL, NULL, NULL, NULL, NULL, NULL);
    }
  
    return ret; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\drsserv\drs_server.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\script.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       script.cxx
//
//--------------------------------------------------------------------------

/*++

Abstract:

Server-side RPC entrypoints for the ExecuteScript function

Author:

    MariosZ

Environment:

Notes:

Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop


// Core DSA headers.
extern "C" {
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>                     // schema cache
#include <attids.h>
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mdlocal.h>                    // MD local definition header
#undef new
#undef delete

#include <objids.h>
#include <anchor.h>
#include <dsatools.h>                   // needed for output allocation
#include <Wincrypt.h>                   // encryption / hashing routines
#include <filtypes.h>
#include <dominfo.h>

#define SECURITY_WIN32
#include <sspi.h>
#include <ldap.h>
#include <windns.h>
#include <sddl.h>

#include <lmserver.h>   // needed for lmjoin.h
#include <lmjoin.h>     // needed for netsetup.h
#include <netsetup.h>   // needed for NetpSetDnsComputerNameAsRequired

// Logging headers.
#include "dsevent.h"                    /* header Audit\Alert logging */
#include "mdcodes.h"                    /* header for error codes */

#include "log.h"

// Assorted DSA headers.
#include "dsexcept.h"
#include "permit.h"

#include <base64.h>

#include   "debug.h"                    /* standard debugging header */
#define DEBSUB     "SCRIPT:"           /* define the subsystem for debugging */

#include <fileno.h>
#define  FILENO FILENO_NTDSCRIPT

extern ATTCACHE *getAttByNameW(IN THSTATE *pTHS, IN LPWSTR pszAttributeName);
extern int LocalCompare(THSTATE *pTHS, COMPAREARG *pCompareArg, COMPARERES *pCompareRes);


}

#include <NTDScript.h>
#include <NTDScriptUtil.h>
#include <NTDSContent.h>
#include <NTDScriptExec.h>

#include <SAXErrorHandlerImpl.h>


#define INTRUDER_DELAY (10 * 1000)

// guid used to sign the script stored in the database.
// this is used in addition to the user specified Key.
// {0916C8E3-3431-4586-AF77-44BD3B16F961}
static const GUID guidDomainRename = 
{ 0x916c8e3, 0x3431, 0x4586, { 0xaf, 0x77, 0x44, 0xbd, 0x3b, 0x16, 0xf9, 0x61 } };


extern "C" {
LONG  glRunningExecuteScriptOperations = 0;
ULONG gulScriptLoggerLogLevel = 1;
}
//
//  ScriptParseErrorGen
//
//  Description:
//
//      Generates an error related to parsing / executing of the NTDSA script
//
//  Arguments:
//
//      dsid - the DSID of the error
//      dwErr - the Error Code
//      data  - additional data needed for the error
//
//  Return Value:
//      the Error code
//      
DWORD ScriptErrorGen (PCHAR szError, DWORD dsid, DWORD dwErr, DWORD data, WCHAR *pMsg)
{
    THSTATE *pTHS = pTHStls;

    Assert (pTHS);

    ScriptLogPrint ( (DSLOG_ERROR, "%S(0x%x) DSID (0x%x) Data(0x%x)\r\n", szError, dwErr, dsid, data) );

    // save dsid, error in thstate

    LIST_OF_ERRORS *pErrList = (LIST_OF_ERRORS *)THAllocNoEx (pTHS, sizeof (LIST_OF_ERRORS));

    if (pErrList) {
        pErrList->data = data;
        pErrList->dsid = dsid;
        pErrList->dwErr = dwErr;
        pErrList->pMessage = pMsg;
        pErrList->pPrevError = pTHS->pErrList;

        pTHS->pErrList = pErrList;
    }

    if (dwErr) {
        return dwErr;
    }

    return ERROR_DS_NTDSCRIPT_PROCESS_ERROR;
}

DWORD ScriptProcessErrorFromTHSTATEError() {
    THSTATE* pTHS = pTHStls;
    LPSTR szErrStr;
    
    // Use a handy function to create an error string from THSTATE error info
    szErrStr = THGetErrorString();

    if (szErrStr) {
        ScriptLogPrint ( (DSLOG_ERROR, "Script process error(0x%x) %S\r\n", pTHS->errCode, szErrStr) );
        THFreeEx(pTHS, szErrStr);
    }
    else {
        // something wrong -- we could not create an error string, just log the errCode
        ScriptLogPrint ( (DSLOG_ERROR, "Script process error(0x%x)\r\n", pTHS->errCode) );
    }
    return pTHS->errCode;
}

//
//  ScriptAlloc
//
//  Description:
//
//      Allocated memory used for script parsing. This functions isolates the 
//      memory allocation needs of the script parsing code from the DS
//
//  Arguments:
//
//      size  - memory size needed
//
//  Return Value:
//      the allocated memory buffer on success.
//      NULL on failure
//
void *ScriptAlloc (size_t size)
{
    void * pMem;

    pMem = THAlloc(size);

    return(pMem);
}

//
//  ScriptFree
//
//  Description:
//
//      Free memory used for script parsing. This functions isolates the 
//      memory allocation needs of the script parsing code from the DS
//
//  Arguments:
//
//      ptr - the memory to free
//
//  Return Value:
//     None
//
void ScriptFree (void *ptr)
{
    THSTATE *pTHS = pTHStls;

    Assert (pTHS);

    THFreeEx(pTHS, ptr);
}

//
//  ScriptStringToDSFilter
//
//  Description:
//
//      Converts a WCHAR string that contains an LDAP filter into 
//      a DS FILTER datastructure.
//
//  Arguments:
//
//      search_filter - the LDAP like filter to convert
//      ppFilter - the output filter
//
//  Return Value:
//     0 on success
//     1 on failure
//
DWORD ScriptStringToDSFilter (WCHAR *search_filter, FILTER **ppFilter)
{
    THSTATE *pTHS = pTHStls;
    DWORD cLen = wcslen (search_filter);
    FILTER *pFilter = NULL;
    CLASSCACHE *pCC = NULL;
    
    *ppFilter = NULL;

    if (wcsncmp (L"COUNT_DOMAINS_FILTER", search_filter, cLen) == 0) {

        pFilter = (FILTER *)THAllocEx (pTHS, sizeof (FILTER));

        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice = FI_CHOICE_BIT_AND;
        pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_SYSTEM_FLAGS;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof (DWORD);
        pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)THAllocEx (pTHS, sizeof (DWORD));
        *(DWORD *)(pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal) = FLAG_CR_NTDS_DOMAIN;

        *ppFilter = pFilter;
    }
    else if (wcsncmp (L"COUNT_TRUSTS_FILTER", search_filter, cLen) == 0) {

        pCC = SCGetClassById(pTHS, CLASS_TRUSTED_DOMAIN);
        if (!pCC) {
            Assert (FALSE);
            return 1;
        }

        pFilter = (FILTER *)THAllocEx (pTHS, sizeof (FILTER));

        pFilter->choice = FILTER_CHOICE_ITEM;
        pFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        pFilter->FilterTypes.Item.FilTypes.ava.type = ATT_OBJECT_CATEGORY;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = pCC->pDefaultObjCategory->structLen;
        pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *) pCC->pDefaultObjCategory;

        *ppFilter = pFilter;
    }
    else {
        ScriptLogPrint ( (DSLOG_ERROR, "Cannot parse filter: %ws\r\n", search_filter) );

        Assert (!"Not Supported Filter");
        return 1;
    }

    return 0;
}

#define SCRIPT_VALUE_TRUE  L"TRUE"
#define SCRIPT_VALUE_TRUE_LEN ( sizeof(SCRIPT_VALUE_TRUE)/sizeof(WCHAR) -1 )
#define SCRIPT_VALUE_FALSE  L"FALSE"
#define SCRIPT_VALUE_FALSE_LEN ( sizeof(SCRIPT_VALUE_FALSE)/sizeof(WCHAR) -1 )

//
//  ConvertScriptValueToDirAttrVal
//
//  Description:
//
//     Convert a string to the corresponding AttrVal structure
//     This function is similar to a corresponding function in the LDAP head
//
//  Arguments:
//
//      pAC - the attribute used
//      pVal - the string value
//      pAttrVal - where to store the resulted AttrVal
//
//  Return Value:
//
//     0 on success
//     Win32 error on failure
// 
//
DWORD ConvertScriptValueToDirAttrVal (THSTATE *pTHS, 
                                      ATTCACHE *pAC, 
                                      WCHAR    *pVal, 
                                      ATTRVAL  *pAttrVal)
{
    DWORD cLen = 0;
    DWORD dwErr = 0;


    if (!pVal) {
        pAttrVal->valLen = 0;
        pAttrVal->pVal = NULL;
        return 0;
    }
    else {
        cLen = wcslen (pVal);
        pAttrVal->valLen = cLen * sizeof (WCHAR);
        pAttrVal->pVal = (PUCHAR)pVal;
    }

    // Based on the att, turn the string we were given into a value.
    switch (pAC->OMsyntax) {
    case OM_S_BOOLEAN:
        {
            int val=0;
            // Only two values are allowed.  Anything else is not-understood.
            // Case matters.
            if((cLen == SCRIPT_VALUE_TRUE_LEN) &&
               (wcsncmp(SCRIPT_VALUE_TRUE, pVal, cLen)== 0)) {
                    val = 1;
            }
            else if((cLen == SCRIPT_VALUE_FALSE_LEN) &&
               (wcsncmp(SCRIPT_VALUE_FALSE, pVal, cLen)== 0)) {
                    val = 2;
            }

            if(!val) {   
                dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }
            else {
                pAttrVal->valLen = sizeof( BOOL );
                pAttrVal->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof(BOOL));
                *( BOOL * )pAttrVal->pVal = (val==1);
            }
        }

        break;

    case OM_S_ENUMERATION:
    case OM_S_INTEGER:
        {
            SYNTAX_INTEGER *pInt, sign=1;
            ATTCACHE *pACLink;
            unsigned i;

            pInt = ( SYNTAX_INTEGER  *) THAllocEx(pTHS, sizeof(SYNTAX_INTEGER));
            *pInt = 0;
            i=0;
            if(pVal[i] == L'-') {
                sign = -1;
                i++;
            }
            if(i==cLen) {
                // No length or just a '-'
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            } else {
                for(;i<cLen;i++) {
                    // Parse the string one character at a time to detect any
                    // non-allowed characters.
                    if((pVal[i] < L'0') || (pVal[i] > L'9')) {
                        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                        break;
                    }
                    *pInt = (*pInt * 10) + pVal[i] - L'0';
                }
            }
                
            if (dwErr == 0) {
                *pInt *= sign;
            } else if (pAC->id != ATT_LINK_ID) {
                return dwErr;
            } else {
                // AutoLinkId
                Assert (FALSE);
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }

            // Ok, got the value, set it up.
            pAttrVal->valLen = sizeof( SYNTAX_INTEGER );
            pAttrVal->pVal = ( UCHAR * ) pInt;
        }
        break;

    case OM_S_OBJECT:
        switch(pAC->syntax) {
        case SYNTAX_DISTNAME_TYPE:
            
            if ( !(dwErr = ScriptNameToDSName (pVal, cLen, (DSNAME **) &pAttrVal->pVal)) ) {
                pAttrVal->valLen=((DSNAME*)pAttrVal->pVal)->structLen;
            }
            break;


        case SYNTAX_DISTNAME_STRING_TYPE:
        case SYNTAX_DISTNAME_BINARY_TYPE:
        case SYNTAX_ADDRESS_TYPE:
        case SYNTAX_OCTET_STRING_TYPE:
            DPRINT1 (0, "Not Implemented Syntax Conversion: %d\n", pAC->syntax);
            Assert (!"Not Implemented Syntax Conversion");
            
            // fall through
        default:
            dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            break;
        }
        break;


    case OM_S_IA5_STRING:
    case OM_S_NUMERIC_STRING:
    case OM_S_TELETEX_STRING:
    case OM_S_PRINTABLE_STRING:
        {
            AssertionValue assertionVal;
            extern _enum1 CheckStringSyntax(int syntax, AssertionValue *pLDAP_val);

            // Convert Unicode to Ascii
            assertionVal.value = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                          CP_UTF8, 
                                                          pVal, 
                                                          -1, 
                                                          (LPLONG)&assertionVal.length, 
                                                          NULL);

            

            if(!pAC->bExtendedChars) {
                if (CheckStringSyntax(pAC->OMsyntax, &assertionVal)) {
                    THFreeEx (pTHS, assertionVal.value);
                    dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                    return dwErr;
                }
            }
            pAttrVal->valLen = assertionVal.length;
            pAttrVal->pVal = assertionVal.value;
        }
        break;

    case OM_S_OCTET_STRING:

        if (SYNTAX_SID_TYPE == pAC->syntax) {
            PSID   pSid;
            
            //
            // Check to see if this is the userfriendly string representation.
            //
            if (cLen >= 2 && !_wcsnicmp(pVal, L"S-", 2)
                && ConvertStringSidToSidW(pVal, &pSid)) {

                __try {
                    // Now copy the converted SID into THAlloc'ed memory
                    pAttrVal->valLen = RtlLengthSid(pSid);
                    pAttrVal->pVal = (PUCHAR)THAllocEx(pTHS, pAttrVal->valLen);
                    CopyMemory(pAttrVal->pVal, pSid, pAttrVal->valLen);
                }
                __finally {
                    LocalFree(pSid);
                }

            }
            break;
        }
        //
        // deliberate fall through if this is not a SID.
        //

    case OM_S_GENERAL_STRING:
    case OM_S_GRAPHIC_STRING:
    case OM_S_OBJECT_DESCRIPTOR_STRING:
    case OM_S_VIDEOTEX_STRING:

        // Strings is strings, just use them.
        // Convert Unicode to Ascii

        pAttrVal->pVal = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                  CP_UTF8, 
                                                  pVal, 
                                                  -1, 
                                                  (LPLONG)&pAttrVal->valLen, 
                                                  NULL);
        break;

    case OM_S_UNICODE_STRING:
        pAttrVal->valLen = cLen * sizeof(WCHAR);
        pAttrVal->pVal = (UCHAR *)THAllocEx(pTHS, pAttrVal->valLen + sizeof(WCHAR));
        memcpy (pAttrVal->pVal, pVal, pAttrVal->valLen);
        break;

    case OM_S_I8:
        {
            SYNTAX_I8 *pInt;
            LONG sign=1;
            unsigned i;

            pInt = ( SYNTAX_I8  *) THAllocEx(pTHS, sizeof(SYNTAX_I8));
            pInt->QuadPart = 0;
            i=0;
            if(pVal[i] == L'-') {
                sign = -1;
                i++;
            }

            if(i==cLen) {
                // No length or just a '-'
                return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }

            for(;i<cLen;i++) {
                // Parse the string one character at a time to detect any
                // non-allowed characters.
                if((pVal[i] < L'0') || (pVal[i] > L'9')) {
                    return ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
                }

                pInt->QuadPart = ((pInt->QuadPart * 10) + pVal[i] - '0');
            }
            pInt->QuadPart *= sign;

            // Ok, got the value, set it up.
            pAttrVal->valLen = sizeof( SYNTAX_I8 );
            pAttrVal->pVal = (UCHAR *)pInt;
        }
        break;


    case OM_S_OBJECT_IDENTIFIER_STRING:
        {
    extern _enum1
    LDAP_AttrTypeToDirAttrTyp (
            IN THSTATE       *pTHS,
            IN ULONG         CodePage,
            IN SVCCNTL*      Svccntl OPTIONAL,
            IN AttributeType *LDAP_att,
            OUT ATTRTYP      *pAttrType,
            OUT ATTCACHE     **ppAC         // OPTIONAL
            );

    extern _enum1
    LDAP_AttrTypeToDirClassTyp (
            IN  THSTATE       *pTHS,
            IN  ULONG         CodePage,
            IN  AttributeType *LDAP_att,
            OUT ATTRTYP       *pAttrType,
            OUT CLASSCACHE    **ppCC        // OPTIONAL
            );


            _enum1 code=success;
            SVCCNTL Svccntl;
            ULONG   CodePage = CP_UTF8;
            ATTCACHE *pACVal;
            AssertionValue assertionVal;

            // allocate space for the oid
            pAttrVal->valLen = sizeof( ULONG );
            pAttrVal->pVal = ( UCHAR * ) THAllocEx(pTHS, sizeof (ULONG));

            // Convert Unicode to Ascii
            assertionVal.value = (UCHAR *)String8FromUnicodeString(TRUE, 
                                                          CP_UTF8, 
                                                          pVal, 
                                                          -1, 
                                                          (LPLONG)&assertionVal.length, 
                                                          NULL);

            // not interested in the trailing NULL.
            if (assertionVal.length) {
                assertionVal.length--;
            }

            // Call support routine to translate.
            code = LDAP_AttrTypeToDirAttrTyp (
                    pTHS,
                    CodePage,
                    &Svccntl,
                    (AttributeType *)&assertionVal,
                    (ATTRTYP *)pAttrVal->pVal,
                    &pACVal);

            // Need the tokenized OID (attributeId), not the internal id (msDS-IntId)
            if (code == success) {
                *((ATTRTYP *)pAttrVal->pVal) = pACVal->Extid;
            }

            if(code == noSuchAttribute) {
                // Ok, it's not an attribute, see if it is a class.
                code = LDAP_AttrTypeToDirClassTyp (
                        pTHS,
                        CodePage,
                        (AttributeType *)&assertionVal,
                        (ATTRTYP *)pAttrVal->pVal,
                        NULL);
            }

            if(code == noSuchAttribute) {
                // Not an object we know. Could be a new id.
                // Try to parse the string as an OID string,
                // (e.g.  "OID.1.2.814.500" or "1.2.814.500")
                // The call to StringToAttrType can handle
                // both strings starting with OID. and not

                if(StringToAttrTyp(pTHS, pVal, cLen, (ATTRTYP *)pAttrVal->pVal)== -1) {
                      // failed to convert.
                     code = noSuchAttribute;
                 }
                 else {
                     code = success;
                 }
            }

            if (assertionVal.value) {
                THFreeEx (pTHS, assertionVal.value);
            }

            if (code != success) {
                dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
            }
        }
        break;


    case OM_S_GENERALISED_TIME_STRING:
    case OM_S_UTC_TIME_STRING:
    case OM_S_OBJECT_SECURITY_DESCRIPTOR:
        
        ScriptLogPrint ( (DSLOG_ERROR, "Not Implemented OMSyntax Conversion: %d\r\n", pAC->OMsyntax) );        
        DPRINT1 (0, "Not Implemented OMSyntax Conversion: %d\n", pAC->OMsyntax);
        Assert (!"Not Implemented Syntax Conversion");

        // fall through

    case OM_S_NULL:
    case OM_S_ENCODING_STRING:
    default:
        // huh?
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
    }

    return dwErr;
}


//
//  ConvertScriptElementToDirAttr
//
//  Description:
//
//     Convert a ScriptAttribute to an ATTR
//
//  Arguments:
//
//      pElement - the ScriptAttribute to convert
//      pAttr - where to store the resulted Attr
//
//  Return Value:
//
//     0 on success
//     Win32 error on failure
// 
//
DWORD ConvertScriptElementToDirAttr (THSTATE *pTHS, 
                                     ScriptAttribute *pElement,  
                                     ATTR *pAttr)
{
    DWORD            dwErr=0;
    ATTCACHE        *pAC;

    do {
        
        pAC = getAttByNameW( pTHS, pElement->m_name);
        if (!pAC) {
            dwErr = ScriptProcessError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            break;
        }

        pAttr->attrTyp = pAC->id;
        pAttr->AttrVal.valCount = 1;
        pAttr->AttrVal.pAVal = (ATTRVAL *)THAllocEx(pTHS, sizeof(ATTRVAL));

        dwErr = ConvertScriptValueToDirAttrVal (pTHS, pAC, pElement->m_characters, &pAttr->AttrVal.pAVal[0]);

    } while ( 0 );

    return dwErr;
}



//
//  ScriptInstantiatedRequest
//
//  Description:
//
//     Implement the Instantiated request
//
//  Arguments:
//
//      pObjectDN - the object to be checked for instantiated
//      pfisInstantiated - where to store the result
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptInstantiatedRequest (
    DSNAME *pObjectDN, 
    ScriptPredicate::ScriptInstanciatedTestType testType, 
    BOOL *pfMatch)
{
    THSTATE     *pTHS = pTHStls;
    DWORD        dwErr=0;
    ULONG        it;
    PWCHAR       szOper;

    switch(testType) {
    case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_READ:
        szOper = L"READ";
        break;
    case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_WRITE:
        szOper = L"WRITE";
        break;
    case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_READONLY:
        szOper = L"READONLY";
        break;
    default:
        Assert(!"Unknown testType");
        szOper = L"???";
    }

    DPRINT2 (0, "Instantiated (%ws) on Object: %ws\n", szOper, pObjectDN->StringName);

    *pfMatch = FALSE;

    do {
        switch (dwErr = DBFindDSName(pTHS->pDB, pObjectDN)){

        case 0:
            // Get the instance type
            dwErr = DBGetSingleValue(pTHS->pDB,
                                   ATT_INSTANCE_TYPE,
                                   &it,
                                   sizeof(it),
                                   NULL);

            switch(dwErr) {
            case DB_ERR_NO_VALUE:
                // No instance type is an uninstantiated object
                it = IT_UNINSTANT;
                dwErr = 0;
                break;

            case 0:
                // No action.
                break;

            case DB_ERR_VALUE_TRUNCATED:
            default:
                // Something unexpected and bad happened.  Bail out.
                LogUnhandledErrorAnonymous(dwErr);
                dwErr = ScriptProcessError(dwErr);
            }

            if (dwErr) {
                break;
            }

            if (it & IT_UNINSTANT) {
                // object is not instanciated
                break;
            }

            switch(testType) {
            case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_WRITE:
                *pfMatch = (it & IT_WRITE);
                break;

            case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_READ:
                *pfMatch = TRUE;
                break;

            case ScriptPredicate::SCRIPT_INSTANCIATED_TEST_TYPE_READONLY:
                *pfMatch = !(it & IT_WRITE);
                break;
            }

            break;

        case DIRERR_OBJ_NOT_FOUND:
        case DIRERR_NOT_AN_OBJECT:

            // object is not instantiated
            dwErr = 0;
            break;

        default:
            dwErr = ScriptProcessError (dwErr);

        }  /*switch*/

    } while ( 0 );

    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "InstanceType Check. ObjectGUID:", &pObjectDN->Guid );
    }
    ScriptLogPrint ( (DSLOG_TRACE, "InstanceType Check %ws (%ws)=%ws  Result: %d(0x%x)\r\n",
                                szOper,
                                pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                                *pfMatch ? L"TRUE" : L"FALSE", 
                                dwErr, dwErr) );        

    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_SCRIPT_OPERATION_INSTANTIATED,
              szInsertWC(szOper),
              szInsertDN(pObjectDN),
              szInsertHex(*pfMatch),
              szInsertWin32ErrCode(dwErr), 
              szInsertWin32Msg(dwErr), 
              NULL, NULL, NULL );

    return dwErr;
}


//
//  ScriptCardinalityRequest
//
//  Description:
//
//     Implement the Cardinality request
//
//  Arguments:
//
//      pObjectDN - the object to base the search request for cardinality
//      searchType - base, onelevel, subtree
//      pFilter - the filter to use
//      dwCardinality (OUT) - the number of objects found
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCardinalityRequest (DSNAME *pObjectDN, DWORD searchType, FILTER *pFilter, DWORD *pCardinality)
{
    THSTATE     *pTHS = pTHStls;
    SEARCHARG    SearchArg;
    SEARCHRES    SearchRes;
    ENTINFSEL    EntInfSel;
    ATTR         attrObjectGuid;
    DWORD        dwErr=0;
    BOOL         fMoreData;
    PRESTART     pRestart;
    DWORD        i = 0;

    *pCardinality = 0;

    do {
        //
        // Setup the Attribute Select parameter
        //
        attrObjectGuid.attrTyp = ATT_OBJECT_GUID;
        attrObjectGuid.AttrVal.valCount = 0;
        attrObjectGuid.AttrVal.pAVal = NULL;

        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
        EntInfSel.AttrTypBlock.attrCount = 1;
        EntInfSel.AttrTypBlock.pAttr = &attrObjectGuid;

        // Initialize 

        memset(&SearchArg, 0, sizeof(SEARCHARG));
        
        InitCommarg(&SearchArg.CommArg);

        SearchArg.pObject = pObjectDN;

        SearchArg.choice = searchType;
        SearchArg.bOneNC = TRUE;
        SearchArg.pFilter = pFilter;
        SearchArg.pSelection = &EntInfSel;
        SearchArg.pSelectionRange = NULL;

        fMoreData = TRUE;
        pRestart = NULL;

        while (fMoreData) {

            SearchArg.CommArg.PagedResult.fPresent = TRUE;
            SearchArg.CommArg.PagedResult.pRestart = pRestart;
#ifdef DBG
            SearchArg.CommArg.ulSizeLimit = 4;
#else
            SearchArg.CommArg.ulSizeLimit = 200;
#endif
            
            if (eServiceShutdown) {
                break;
            }

            memset(&SearchRes, 0, sizeof (SEARCHRES));

            SearchBody(pTHS, &SearchArg, &SearchRes, 0);
            dwErr = pTHS->errCode;

            if (dwErr) {
                break;
            }

            // Set fMoreData for next iteration
            if ( !( (SearchRes.PagedResult.pRestart != NULL)
                        && (SearchRes.PagedResult.fPresent)
                  ) ) {
                // No more data needs to be read. So no iterarions needed after this
                fMoreData = FALSE;
            }
            else {
                // more data. save off the restart to use in the next iteration.
                pRestart = SearchRes.PagedResult.pRestart;
            }

            *pCardinality += SearchRes.count;

            DBFreeSearhRes (pTHS, &SearchRes, FALSE);

            DPRINT2 (0, "Cardinality (iteration: %d) = %d\n", ++i, *pCardinality);
        }

    } while ( 0 );


    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Cardinality Check. ObjectGUID:", &pObjectDN->Guid );
    }
    ScriptLogPrint ( (DSLOG_TRACE, "Cardinality Check (%ws). Found=(%d) Type=(%d) Result: %d(0x%x)\r\n", 
                                pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                                *pCardinality, 
                                searchType,
                                dwErr, dwErr) );        

    LogEvent8(DS_EVENT_CAT_INTERNAL_PROCESSING,
              DS_EVENT_SEV_MINIMAL,
              DIRLOG_SCRIPT_OPERATION_CARDINALITY,
              szInsertDN(pObjectDN), 
              szInsertUL(*pCardinality), 
              szInsertWin32ErrCode(dwErr),
              szInsertWin32Msg(dwErr),
              NULL, NULL, NULL, NULL);

    return dwErr;
}


//
//  ScriptCompareRequest
//
//  Description:
//
//     Implement the Compare request
//
//  Arguments:
//
//      pObjectDN - the object we are checking values of
//      pAttribute - the name of the attribute we are interested in
//      pAttrVal - the expected value of the attribute
//      pDefaultVal - the default value we should compare against if the
//                    attribute is not present on the object
//      pfMatch (OUT) - the compare result (TRUE = the same)
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCompareRequest (DSNAME *pObjectDN, WCHAR *pAttribute, WCHAR *pAttrVal, WCHAR *pDefaultVal, BOOL *pfMatch)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    LPSTR            szErrStr;
    COMPAREARG       CompareArg;
    COMPARERES       CompareRes;
    ATTCACHE        *pAC;

    // Initialize 

    memset(&CompareArg, 0, sizeof(COMPAREARG));
    memset (&CompareRes, 0, sizeof (COMPARERES));
    InitCommarg(&CompareArg.CommArg);

    *pfMatch = FALSE;

    do {

        pAC = getAttByNameW( pTHS, pAttribute);
        if (!pAC) {
            ScriptLogLevel (0, ScriptLogPrint ( (DSLOG_ERROR, "Unknown Attribute: %ws\r\n", pAttribute) ) );
            dwErr = ScriptProcessError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
            SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
            break;
        }

        CompareArg.pObject = pObjectDN;
        CompareArg.Assertion.type = pAC->id;

        if (dwErr = ConvertScriptValueToDirAttrVal (pTHS, pAC, pAttrVal, &CompareArg.Assertion.Value)) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
            break;
        }

        if (DoNameRes(pTHS, 0, CompareArg.pObject, &CompareArg.CommArg,
                                   &CompareRes.CommRes, &CompareArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        dwErr = LocalCompare(pTHS, &CompareArg, &CompareRes);
        DPRINT2 (0, "Compare result %d. Matched=%d\n", dwErr, CompareRes.matched);
        if (CompareRes.matched) {
            *pfMatch = TRUE;
        }
        else if (dwErr == attributeError && pDefaultVal) {
            if (wcscmp (pAttrVal, pDefaultVal) == 0) {
                *pfMatch = TRUE;
            }
            pTHS->errCode = dwErr = 0;
            THClearErrors();
            DPRINT2 (0, "Compare is using default value: %ws. Matched=%d\n", pDefaultVal, *pfMatch);
        }

    } while ( 0 );

    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Compare Check. ObjectGUID:", &pObjectDN->Guid );
    }
    
    szErrStr = THGetErrorString();
    ScriptLogPrint ( (DSLOG_TRACE, "Compare Check (%ws)  Attr(%ws)?=(%ws) = (%ws) Error: %S\r\n", 
                        pObjectDN->NameLen ? pObjectDN->StringName : L"NULL",
                        pAttribute,
                        pAttrVal,
                        *pfMatch ? L"TRUE" : L"FALSE", 
                        szErrStr) );

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_COMPARE,
             szInsertDN(pObjectDN), 
             szInsertHex(*pfMatch), 
             szInsertSz(szErrStr));
    
    THFreeEx(pTHS, szErrStr);
    
    return dwErr;
}

//
//  ScriptUpdateRequest
//
//  Description:
//
//     Implement the Update request
//
//  Arguments:
//
//      pObjectDN - the object we are updating values of
//      attributesList - the list of attributes we are updating
//      metadataUpdate - whether to update metadata or not
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptUpdateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributesList, BOOL metadataUpdate)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    MODIFYARG        modifyArg;
    MODIFYRES        modRes;
    ATTRMODLIST      *pMod, *pModTemp;
    DWORD            cModCount=0;
    DWORD            cbLen;
    DWORD            i,j;
    LPSTR            szErrStr;

    ATTCACHE        *pAC;
    BOOL            fOldMetaDataUpdate;
    
    ScriptAttributeList::iterator it = attributesList.begin();
    ScriptAttribute *pAttrEl;


    DPRINT1 (0, "Updating Object: %ws\n", pObjectDN->StringName);


    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Update. ObjectGUID:", &pObjectDN->Guid );
    }
    if (pObjectDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Update (%ws)\r\n", pObjectDN->StringName) );        
    }


    it = attributesList.begin();
    while (it != attributesList.end()) {

        pAttrEl = *it;

        ScriptLogPrint ( (DSLOG_TRACE, "Update Attr(%ws)=%ws  Type(%d)\r\n", 
                                pAttrEl->m_name, 
                                pAttrEl->m_characters,
                                pAttrEl->m_operation_type) );      

        it++;
    }

    // Initialize 
    
    memset(&modifyArg, 0, sizeof(modifyArg));
    memset(&modRes, 0, sizeof(modRes));
    InitCommarg(&modifyArg.CommArg);

    // we don't care if the value was not there by default when we modify the object
    modifyArg.CommArg.Svccntl.fPermissiveModify = TRUE;

    // do we really want to update metadata ?
    fOldMetaDataUpdate = pTHS->pDB->fSkipMetadataUpdate;
    pTHS->pDB->fSkipMetadataUpdate = !metadataUpdate;

    do {
        modifyArg.pObject = pObjectDN;

        // Perform name resolution to locate object.  If it fails, just
        // return an error, which may be a referral.  
        // We need a writable copy of the object
        if (DoNameRes(pTHS, 0, modifyArg.pObject, &modifyArg.CommArg,
                                   &modRes.CommRes, &modifyArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        pMod = &modifyArg.FirstMod;

        it = attributesList.begin();
        while (it != attributesList.end()) {

            pMod->pNextMod = NULL;
            
            pAttrEl = *it;

            pAC = getAttByNameW( pTHS, pAttrEl->m_name);
            if (!pAC) {
                DPRINT1 (0, "Attribute Not Found In Schema: %ws\n", pAttrEl->m_name);
                dwErr = ScriptProcessError(ERROR_DS_ATT_NOT_DEF_IN_SCHEMA);
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                break;
            }

            // if the attribute is not a member of partial Attribute Set
            // and the object is not writable, 
            if (!pAC->bMemberOfPartialSet && 
                !(modifyArg.pResObj->InstanceType & IT_WRITE)) {
                
                DPRINT1 (0, "Skipping update of attribute %ws because not in GC set\n", pAttrEl->m_name);

                it++;
                continue;
            }

            DPRINT2 (0, "Update Attribute %s=%ws\n", pAC->name, pAttrEl->m_characters);

            switch (pAttrEl->m_operation_type) {
            case ScriptAttribute::SCRIPT_OPERATION_APPEND:
                pMod->choice = AT_CHOICE_ADD_ATT;
                break;
            case ScriptAttribute::SCRIPT_OPERATION_REPLACE:
                pMod->choice = AT_CHOICE_REPLACE_ATT;
                break;
            case ScriptAttribute::SCRIPT_OPERATION_DELETE:
                pMod->choice = AT_CHOICE_REMOVE_ATT;
                break;
            }

            if (dwErr = ConvertScriptElementToDirAttr (pTHS, pAttrEl, &pMod->AttrInf)) {
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                break;
            }

            it++;
            cModCount++;

            if (it != attributesList.end()) {
                pMod->pNextMod = (ATTRMODLIST *) THAllocEx (pTHS, sizeof (ATTRMODLIST));
                pMod = pMod->pNextMod;
            }
        }

        if (dwErr) {
            break;
        }

        modifyArg.count = cModCount;

        // do the modify call
        //
        LocalModify(pTHS, &modifyArg);
        dwErr =  pTHS->errCode;

        DPRINT1 (0, "Update result %d\n", dwErr);

    } while ( 0 );

    // free MODIFYARG
    pMod = &modifyArg.FirstMod;
    while (pMod) {
        if (pMod->AttrInf.AttrVal.pAVal) {
            if (pMod->AttrInf.AttrVal.pAVal->pVal) {
                THFreeEx (pTHS, pMod->AttrInf.AttrVal.pAVal->pVal);
            }
            THFreeEx (pTHS, pMod->AttrInf.AttrVal.pAVal);
        }

        pModTemp = pMod;
        pMod = pMod->pNextMod;
        
        // the first one is not allocated
        if ( pModTemp != &modifyArg.FirstMod ) {
            THFreeEx (pTHS, pModTemp);
        }
    }

    pTHS->pDB->fSkipMetadataUpdate = fOldMetaDataUpdate;

    szErrStr = THGetErrorString();

    ScriptLogPrint ( (DSLOG_TRACE, "Update Result = %d(%S)\r\n", dwErr, szErrStr) );      

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_UPDATE,
             szInsertDN(pObjectDN), 
             szInsertSz(szErrStr), NULL );
    
    THFreeEx(pTHS, szErrStr);

    return dwErr;
}

//
//  ScriptMoveRequest
//
//  Description:
//
//     Implement the Move request
//
//  Arguments:
//
//      pObjectDN - the source object 
//      pDestDN - the destination object (not the destination parent)
//      metadataUpdate - whether to update metadata or not (1 or 0)
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptMoveRequest (DSNAME *pObjectDN, DSNAME *pDestDN, BOOL metadataUpdate)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    MODIFYDNARG      modifyDNArg;
    MODIFYDNRES      modifyDNRes;
    DSNAME          *pNewParentDN = NULL;
    ATTRBLOCK       *pDestBlockName = NULL;
    RESOBJ          *pParentResObj = NULL;
    COMMRES          commRes;
    LPSTR            szErrStr;

    // Initialize 
    
    memset(&modifyDNArg, 0, sizeof(modifyDNArg));
    memset(&modifyDNRes, 0, sizeof(modifyDNRes));
    memset (&commRes, 0, sizeof (COMMRES));
    InitCommarg(&modifyDNArg.CommArg);

    // do we really want to update metadata ?
    pTHS->pDB->fSkipMetadataUpdate = !metadataUpdate;

    DPRINT2 (0, "Moving Object: %ws ===> %ws\n", pObjectDN->StringName, pDestDN->StringName);
        
    if (!fNullUuid(&pObjectDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Move Source. ObjectGUID:", &pObjectDN->Guid );
    }
    if (pObjectDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Move Source (%ws)\r\n", pObjectDN->StringName) );        
    }

    if (!fNullUuid(&pDestDN->Guid)) {
        ScriptLogGuid ( DSLOG_TRACE, "Move Dest. ObjectGUID:", &pDestDN->Guid );
    }
    if (pDestDN->NameLen) {
        ScriptLogPrint ( (DSLOG_TRACE, "Move Dest (%ws)\r\n", pDestDN->StringName) );        
    }


    do {
        // break the dsname in parts
        if (dwErr = DSNameToBlockName (pTHS, pDestDN, &pDestBlockName, FALSE)) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
            break;
        }
        Assert (pDestBlockName->attrCount);

        // get the new parent
        pNewParentDN = (DSNAME *) THAllocEx(pTHS, pDestDN->structLen);

        if (TrimDSNameBy ( pDestDN, 1, pNewParentDN)) {
            dwErr = ScriptParseError(ERROR_DS_INVALID_DN_SYNTAX);
            SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
            break;
        }
        modifyDNArg.pObject = pObjectDN;
        modifyDNArg.pNewParent = pNewParentDN;
        
        // get the newRDN
        modifyDNArg.pNewRDN = &pDestBlockName->pAttr[pDestBlockName->attrCount-1];

        // we don't need a writable copy of the object
        modifyDNArg.CommArg.Svccntl.dontUseCopy = FALSE;

        // check to see that the new parent exists
        // if it does not exist, create a phantom
        if (DoNameRes(pTHS,
                      0,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)){

            modifyDNArg.fAllowPhantomParent = TRUE;

            THClearErrors();

            if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)) {
                
                DPRINT1 (0, "ScriptMoveRequest: New Parent does not exist: %ws\n", pNewParentDN->StringName);
            }
            else {
                DPRINT1 (0, "ScriptMoveRequest: New Parent exists as a phantom: %ws\n", pNewParentDN->StringName);
            }

            THClearErrors();

#if DBG
            dwErr = DBFindDSName( pTHS->pDB, pNewParentDN );
            DPRINT1 (0, "ScriptMoveRequest: FindParent: %d\n", dwErr);
#endif
            
            dwErr = DBFindDSName( pTHS->pDB, modifyDNArg.pObject );
            DPRINT1 (0, "ScriptMoveRequest: FindObject: %d\n", dwErr);

            // we can use a phantom as the object
            if (dwErr && dwErr != ERROR_DS_NOT_AN_OBJECT) {
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                pTHS->errCode = dwErr;
                break;
            }

            // do the trick so as to write the new phantom parent
            dwErr = DBAddAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                              pNewParentDN->structLen,
                              pNewParentDN);

            if (dwErr) {
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                break;
            }

            // and remove the value since it is not needed
            dwErr = DBRemAttVal(pTHS->pDB, ATT_DN_REFERENCE_UPDATE,
                              pNewParentDN->structLen,
                              pNewParentDN);

            dwErr = DBRepl( pTHS->pDB, FALSE, 0, NULL, 0 );
            if (dwErr) {
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                break;
            }

            if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      pNewParentDN,
                      &modifyDNArg.CommArg,
                      &commRes,
                      &pParentResObj)) {

                DPRINT1 (0, "ScriptMoveRequest: New Parent STILL does not exist: %ws\n", pNewParentDN->StringName);
                Assert (!"New Parent STILL does not exist");
                dwErr =  pTHS->errCode;
                break;
            }
        }
        
        // fill in the pResObj
        if (DoNameRes(pTHS,
                      NAME_RES_PHANTOMS_ALLOWED | NAME_RES_VACANCY_ALLOWED,
                      modifyDNArg.pObject,
                      &modifyDNArg.CommArg,
                      &modifyDNRes.CommRes,
                      &modifyDNArg.pResObj)){
            dwErr = pTHS->errCode;
            break;
        }

        ScriptLogGuid ( DSLOG_TRACE, "Move Source. ObjectGUID:",
                        &modifyDNArg.pResObj->pObj->Guid );

        // Local Modify operation

        LocalModifyDN(pTHS,
                      &modifyDNArg,
                      &modifyDNRes,
                      FALSE);

        dwErr =  pTHS->errCode;

    } while ( 0 );

    szErrStr = THGetErrorString();
    
    ScriptLogPrint ( (DSLOG_TRACE, "Move Result %d(%S)\r\n", dwErr, szErrStr) );

    pTHS->pDB->fSkipMetadataUpdate = 0;

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_MOVE,
             szInsertDN(pObjectDN), 
             szInsertDN(pDestDN),
             szInsertSz(szErrStr));

    THFreeEx(pTHS, szErrStr);
    
    return dwErr;
}

//
//  ScriptCreateRequest
//
//  Description:
//
//     Implement the Create request
//
//  Arguments:
//
//      pObjectDN - the object we are adding
//      attributesList - the list of attributes on the object
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCreateRequest (DSNAME *pObjectDN, ScriptAttributeList &attributesList)
{
    THSTATE         *pTHS = pTHStls;
    DWORD            dwErr=0;
    ADDARG           addArg;
    ADDRES           addRes;
    ATTRMODLIST      *pMod;
    DWORD            cAttrCount=0;
    ATTRBLOCK       *pAttrBlock;
    ATTR            *pAttr;
    DSNAME          *pParentDN = NULL;
    LPSTR            szErrStr;

    ScriptAttributeList::iterator it = attributesList.begin();
    ScriptAttribute *pAttrEl;

    // Initialize 
    
    memset(&addArg, 0, sizeof(addArg));
    InitCommarg(&addArg.CommArg);

    do {

        addArg.pObject = pObjectDN;

        // get the parent
        pParentDN = (DSNAME *) THAllocEx(pTHS, pObjectDN->structLen);

        if (TrimDSNameBy ( pObjectDN, 1, pParentDN)) {
            dwErr = ScriptParseError(ERROR_DS_INVALID_DN_SYNTAX);
            SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
            break;
        }

        if (DoNameRes(pTHS, 0, pParentDN, &addArg.CommArg,
                                   &addRes.CommRes, &addArg.pResParent)){
            dwErr = pTHS->errCode;
            break;
        }                                                             

        pAttrBlock = &addArg.AttrBlock;

        pAttrBlock->pAttr = (ATTR *)THAllocEx (pTHS, sizeof (ATTR) );

        while (it != attributesList.end()) {

            pAttrEl = *it;

            pAttr = &pAttrBlock->pAttr[cAttrCount];
            
            if (dwErr = ConvertScriptElementToDirAttr (pTHS, pAttrEl, pAttr)) {
                SetSvcError(SV_PROBLEM_DIR_ERROR, dwErr);
                break;
            }

            DPRINT2 (0, "Add Attr %ws=%ws\n", pAttrEl->m_name, pAttrEl->m_characters);

            it++;
            cAttrCount++;

            if (it != attributesList.end()) {
                pAttrBlock->pAttr = (ATTR *)THReAllocEx(pTHS, pAttrBlock->pAttr, sizeof (ATTR) * (cAttrCount+1));
            }
        }

        if (dwErr) {
            break;
        }

        pAttrBlock->attrCount = cAttrCount;

        // do the call
        //
        LocalAdd(pTHS, &addArg, FALSE);
        dwErr = pTHS->errCode;

    } while ( 0 );

    szErrStr = THGetErrorString();
    
    ScriptLogPrint ( (DSLOG_TRACE, "Add Result %d(%S)\r\n", dwErr, szErrStr) );
    
    // free ADDARG

    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
             DS_EVENT_SEV_MINIMAL,
             DIRLOG_SCRIPT_OPERATION_CREATE,
             szInsertDN(pObjectDN), 
             szInsertSz(szErrStr), NULL);

    THFreeEx(pTHS, szErrStr);
    
    return dwErr;
}

//
//  ScriptComputeHashAndSignature
//
//  Description:
//
//     Calculate hash keys for the script
//
//  Arguments:
//
//      pStream - the script
//      cchStream - the lenght of the script
//      ppComputedSignature - the signature H (body + key)
//      pcbComputedSignature - the lenght of the signature
//      ppHashBody - the hash of the body H (body)
//      pcbHashBody - the lenght of the hash body
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptComputeHashAndSignature (THSTATE *pTHS,
                                     WCHAR   *pStream,
                                     DWORD    cchStream,
                                     BYTE   **ppSignature,
                                     DWORD   *pcbSignature,
                                     BYTE   **ppHashBody,
                                     DWORD   *pcbHashBody)
{
    DWORD      dwErr = 0;
    HCRYPTPROV hCryptProv = NULL; 
    HCRYPTHASH hHash = NULL;
    HCRYPTHASH hDupHash = NULL;


    *ppHashBody =  (BYTE *)THAllocEx (pTHS,  20);
    *ppSignature = (BYTE *)THAllocEx (pTHS,  20);
    *pcbSignature = *pcbHashBody = 20;

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT | CRYPT_MACHINE_KEYSET)) {

            dwErr = GetLastError();

            if (dwErr == NTE_BAD_KEYSET) {

                dwErr = 0;

                if(!CryptAcquireContext(&hCryptProv, 
                                        NULL, 
                                        NULL, 
                                        PROV_RSA_FULL, 
                                        CRYPT_SILENT | CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)) {

                    dwErr = GetLastError();

                    __leave;
                }
            }
            else {
                __leave;
            }
        }

        // Create the hash object.

        if(!CryptCreateHash(hCryptProv, 
                            CALG_SHA1, 
                            0, 
                            0, 
                            &hHash)) {
            dwErr = GetLastError();
            __leave;
        }


        // Compute the cryptographic hash of the buffer.

        if(!CryptHashData(hHash, 
                         (BYTE *)pStream,
                         cchStream * sizeof (WCHAR),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }

        // we have the common part of the hash ready (H(buf), now duplicate it
        // so as to calc the H (buf + guid)

        if (!CryptDuplicateHash(hHash, 
                               NULL, 
                               0, 
                               &hDupHash)) {
            dwErr = GetLastError();
            __leave;
        }


        if (!CryptGetHashParam(hHash,    
                               HP_HASHVAL,
                               *ppHashBody,
                               pcbHashBody,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        Assert (*pcbHashBody == 20);

        
        if(!CryptHashData(hDupHash, 
                         (BYTE *)&guidDomainRename,
                         sizeof (GUID),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }
        
        if (!CryptGetHashParam(hDupHash,    
                               HP_HASHVAL,
                               *ppSignature,
                               pcbSignature,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        Assert (*pcbSignature == 20);

    }
    __finally {

        if (hDupHash)
            CryptDestroyHash(hDupHash);

        if(hHash) 
            CryptDestroyHash(hHash);

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);
    }

    return dwErr;
}


//
//  ScriptCalculateAndCheckHashKeys
//
//  Description:
//
//     Calculate hash keys for the script
//     Checks to see whether hash keys match the one on the script
//
//  Arguments:
//
//      pwScript - the script
//      cchScriptLen - the lenght of the script
//      ppComputedSignature - the signature H (body + key)
//      pcbComputedSignature - the lenght of the signature
//      ppHashBody - the hash of the body H (body)
//      pcbHashBody - the lenght of the hash body
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptCalculateAndCheckHashKeys (THSTATE *pTHS, 
                                       IN WCHAR   *pwScript,
                                       IN DWORD    cchScriptLen,
                                       OUT BYTE    **ppComputedSignature,
                                       OUT DWORD   *pcbComputedSignature,
                                       OUT BYTE    **ppHashBody,
                                       OUT DWORD   *pcbHashBody
                                       )
{
    DWORD dwErr = 0;
    WCHAR *pwSignature = NULL;
    
    CHAR  *pSignatureText = NULL;
    DWORD  cbSignature;
    
    BYTE   Signature[20];

    #if DBG
    CHAR   dbgSig[100];
    DWORD  dwSig;
    #endif
    
    // get the signature out of the string
    // 20 bytes as base64 encoded as 28 bytes
    //
    if (cchScriptLen <= 28) {
        dwErr = ERROR_DS_INVALID_SCRIPT;
        goto exit;
    }

    cchScriptLen -= 28;
    pwSignature = pwScript + cchScriptLen;
    
    pSignatureText = (CHAR *)String8FromUnicodeString(TRUE, 
                                                      CP_UTF8, 
                                                      pwSignature, 
                                                      -1, 
                                                      (LPLONG)&cbSignature, 
                                                      NULL);

    dwErr = base64decode(pSignatureText, 
                         Signature,
                         sizeof (Signature),
                         &cbSignature);

    if (FAILED(dwErr)) {
        dwErr = ERROR_DS_INVALID_SCRIPT;
        goto exit;
    }


    // remove the signature from the script
    *pwSignature = 0;

    if (dwErr = ScriptComputeHashAndSignature (pTHS, 
                                               pwScript,
                                               cchScriptLen,
                                               ppComputedSignature,
                                               pcbComputedSignature,
                                               ppHashBody,
                                               pcbHashBody)) {
        goto exit;
    }

    #if DBG
    if (dwErr = base64encode(*ppComputedSignature, 
                             *pcbComputedSignature, 
                             dbgSig,
                             sizeof(dbgSig),
                             &dwSig)) {

        DPRINT (0, "Error encoding signature\n");
        goto exit;
    }
    //DPRINT1 (0, "Script: %ws\n", pwScript);
    DPRINT3 (0, "ScriptLen: %d  %d (%d)\n", cchScriptLen, wcslen (pwScript), cchScriptLen*2);
    DPRINT1 (0, "Stored Signature:%s|\n", pSignatureText);
    DPRINT1 (0, "Computed Signature:%s|\n", dbgSig);
    #endif


    if ((cbSignature != *pcbComputedSignature) || 
        memcmp (Signature, *ppComputedSignature, *pcbComputedSignature)!=0) {
        dwErr = ERROR_DS_INVALID_SCRIPT;
        goto exit;
    }
    
    DPRINT (0, "Script is SIGNED\n ");

exit:
    if (pSignatureText) {
        THFreeEx(pTHS, pSignatureText);
    }

    return dwErr;
}


//
//  ScriptReadFromDatabase
//
//  Description:
//
//     Read the script from the database
//     Checks to see whether the script is signed using the provided key
//
//  Arguments:
//
//      ppScript - where to store the script
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptReadFromDatabase (DBPOS *pDB, WCHAR **ppScript, DWORD *pcchLen)
{
    DWORD dwErr;
    DWORD cbActual;
    
    dwErr = DBFindDSName(pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:
        dwErr = DBGetAttVal (pDB, 
                             1, 
                             ATT_MS_DS_UPDATESCRIPT,
                             0,
                             0,
                             &cbActual,
                             (UCHAR **)ppScript);

        if (dwErr) {
            DPRINT1 (1, "ScriptReadFromDatabase: Error reading value: %d\n", dwErr);
            if (dwErr == DB_ERR_NO_VALUE) {
                dwErr = DIRERR_MISSING_EXPECTED_ATT;
            }
            else {
                dwErr = DIRERR_DATABASE_ERROR;
            }
        }
        else {
            *ppScript = (WCHAR *)THReAllocEx (pDB->pTHS, *ppScript, cbActual+sizeof(WCHAR));
            *pcchLen = cbActual/sizeof(WCHAR);
            (*ppScript)[*pcchLen]=0;

            DPRINT1 (1, "ScriptReadFromDatabase: XML script %d bytes\n", cbActual); 
        }
        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    return dwErr;
}


//
//  ScriptGenerateAndStorePassword
//
//  Description:
//
//     Generate a password and store it in the database
//
//  Arguments:
//
//      ppPassword - the password returned to the user
//      pcbPassword - the lenght of the password generated
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptGenerateAndStorePassword (THSTATE *pTHS, 
                                      BYTE **ppPassword, 
                                      DWORD *pcbPassword)
{
    DWORD dwErr = 0;
    HCRYPTPROV hCryptProv = NULL; 

    *pcbPassword = 8;
    *ppPassword = (BYTE *)THAllocEx (pTHS, *pcbPassword);

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT | CRYPT_MACHINE_KEYSET)) {
            dwErr = GetLastError();
            __leave;
        }

        if (!CryptGenRandom(hCryptProv,
                            *pcbPassword, 
                            *ppPassword)) {

            dwErr = GetLastError();
            __leave;
        }
    }
    __finally {

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);
    }

    if (dwErr) {
        return dwErr;
    }


    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:

        if (dwErr = DBReplaceAttVal (pTHS->pDB, 
                                     1, 
                                     ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                                     *pcbPassword,
                                     *ppPassword)) {

            DPRINT1 (0, "ScriptGenerateAndStorePassword: Error writing value: %d\n", dwErr);
        }
        else {
            DBUpdateRec(pTHS->pDB);
        }

        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    return dwErr;
}



DWORD ScriptPrepareForParsing (THSTATE    *pTHS, 
                               IN WCHAR  **ppScript,
                               BSTR      *pBstrScript)
{

    // create a variant for the value passed to the Parser
    *pBstrScript = SysAllocString(  *ppScript );
    if (!*pBstrScript) {
        return ERROR_OUTOFMEMORY;
    }

    // we don't need the value anymore since we converted it
    THFreeEx (pTHS, *ppScript); *ppScript = NULL;

    return 0;
}

// exception-safe script executer
DWORD handlerScriptExecute(
    NTDSContent* handler, 
    ScriptProcessMode fMode, 
    DWORD &returnCode, 
    const WCHAR **ppErrorMessage)
{
    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    DWORD err;

    __try {
        err = handler->Process(fMode, returnCode, ppErrorMessage);
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        DPRINT3 (0, "Got an exception %x (err %x) while executing script: dsid: %x\n", dwException, ulErrorCode, dsid);
        ScriptException(dwException, ulErrorCode, dsid);
        err = ERROR_EXCEPTION_IN_SERVICE;
        SetSvcError(SV_PROBLEM_DIR_ERROR, err);
    }
    return err;
}

typedef enum {
    SCRIPT_OPERATION_GET_OPTYPE,
    SCRIPT_OPERATION_PREPROCESS,
    SCRIPT_OPERATION_EXECUTE
} SCRIPT_OPERATION;

//
//  ScriptExecute
//
//  Description:
//
//     Read the script from the database
//     Checks to see whether the script is signed using the provided key
//
//  Arguments:
//
//      scriptOperation - what needs to be done
//      pBstrScript - the script to execute. This string should have been prepared with 
//                    ScriptPrepareForParsing
//      pScriptOptype - when scriptOperation==SCRIPT_GET_OPTYPE, then the script optype is returned here
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD ScriptExecute (
    THSTATE *pTHS, 
    SCRIPT_OPERATION scriptOperation, 
    BSTR pBstrScript, 
    WCHAR ** ppErrMessage,
    ScriptOperationType* pScriptOptype
    )
{
    HRESULT             hr = S_OK;
    DWORD               err = 0;
    DWORD               retCode;
    ISAXXMLReader *     pReader = NULL;
    NTDSContent*        pHandler = NULL; 
    IClassFactory *     pFactory = NULL;

    VARIANT             varScript;
    const WCHAR         *pErrMessage = NULL;

    //::CoInitialize(NULL);
    
    try {
        // create a variant for the value passed to the Parser
        VariantInit(&varScript);
        varScript.vt = VT_BYREF|VT_BSTR;
        varScript.pbstrVal = &pBstrScript; 
        
        // do the COM creation of the SAMXMLReader manually
        GetClassFactory( CLSID_SAXXMLReader, &pFactory);

        hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

        if(FAILED(hr)) {
            err = ScriptParseError(hr);
            ScriptLogPrint ( (DSLOG_ERROR,  "Error from CreateInstance: 0x%08x\r\n",hr) );
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, hr);
            goto ExitTry;
        }

        pHandler = new NTDSContent();
        hr = pReader->putContentHandler(pHandler);

        SAXErrorHandlerImpl * pEc = new SAXErrorHandlerImpl();
        hr = pReader->putErrorHandler(pEc);

        hr = pReader->parse(varScript);
        ScriptLogPrint ( (DSLOG_TRACE,  "XML Parse result code: 0x%08x\r\n",hr) );

        if(FAILED(hr)) {
            err = ScriptParseError(hr);
            ScriptLogPrint ( (DSLOG_ERROR,  "Error Parsing XML: 0x%08x\r\n",hr) );
            SetSvcError(SV_PROBLEM_UNABLE_TO_PROCEED, err);
            goto ExitTry;
        }
            
        err = handlerScriptExecute(pHandler, SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS, retCode, &pErrMessage);
        ScriptLogPrint ( (DSLOG_TRACE,  "Syntax Validate Processing: 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\r\n", err, retCode, retCode, pErrMessage) );

        if (!err && !retCode) {
            switch (scriptOperation) {
            case SCRIPT_OPERATION_GET_OPTYPE:
                *pScriptOptype = pHandler->GetScriptOptype();
                break;

            case SCRIPT_OPERATION_PREPROCESS:
                err = handlerScriptExecute(pHandler, SCRIPT_PROCESS_PREPROCESS_PASS, retCode, &pErrMessage);
                ScriptLogPrint ( (DSLOG_TRACE,  "Execute Preprocessing(RO): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws) \r\n", err, retCode, retCode, pErrMessage) );
                break;

            case SCRIPT_OPERATION_EXECUTE:
                err = handlerScriptExecute(pHandler, SCRIPT_PROCESS_EXECUTE_PASS, retCode, &pErrMessage);
                ScriptLogPrint ( (DSLOG_TRACE,  "Execute Processing(RW): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\r\n", err, retCode, retCode, pErrMessage) );
                break;
            }
        }

        // retcode means that something was not as expected in the data
        // stored in the DS
        if (err == 0 && retCode != 0) {
            err = retCode;
        }
        // set error accordingly to fail transaction
        if (err != 0 && pTHS->errCode == 0) {
            SetSvcError(SV_PROBLEM_DIR_ERROR, err);
        }

ExitTry: ;
    }
    catch (...) {
        err = ScriptParseError(ERROR_EXCEPTION_IN_SERVICE);
        SetSvcError(SV_PROBLEM_DIR_ERROR, err);
    }

    if (pErrMessage && ppErrMessage) {
        *ppErrMessage = (WCHAR *)THAllocEx (pTHS, wcslen (pErrMessage) * sizeof (WCHAR) + sizeof (WCHAR));

        wcscpy (*ppErrMessage, pErrMessage);
    }

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    //::CoUninitialize();

    return err;
}

//
//  ScriptAsyncDsShutdown
//
//  Description:
//
//     Asyncronously Unitialize the DS
//     This function should be the entry point of a new thread
//
//  Arguments:
//
//
//  Return Value:
//
//     0 on success
// 
//
unsigned int ScriptAsyncDsShutdown ( void * StartupParam )
{
    HMODULE    ResourceDll;
    WCHAR     *ErrorMessage = NULL;
    BOOLEAN    WasEnabled;
    DWORD      dwErr = 0;

    
    // Get Message String from NTSTATUS code
    //
    ResourceDll = (HMODULE) GetModuleHandleW( L"ntdll.dll" );

    if (NULL != ResourceDll)
    {
        FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |    // find message from ntdll.dll
                       FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       ResourceDll,                     // source dll
                       STATUS_DS_SHUTTING_DOWN,          // message ID
                       0,                               // language ID 
                       (LPWSTR)&ErrorMessage,           // address of return Message String
                       0,                               // maximum buffer size if not 0
                       NULL                             // can not insert arguments, so set to NULL
                       );

        FreeLibrary(ResourceDll);
    }

    LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
             DS_EVENT_SEV_ALWAYS,
             DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME,
             NULL, NULL, NULL );
    
    DPRINT (0, "Partially Shutting Down System\n");
    
    DsUninitialize (TRUE);

    if (gfRunningInsideLsa) {

        // adjust privilege level, issue shutdown request.
        //
        dwErr = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE,
                            TRUE,       // enable shutdown privilege.
                            FALSE,
                            &WasEnabled
                           );

        ASSERT( NT_SUCCESS( dwErr ) );

        DPRINT (0, "Initiating shutdown of system\n");

        dwErr = InitiateSystemShutdownExW( NULL,       // computer name
                                         ErrorMessage, // message to display
                                         60,           // length of time to display
                                         TRUE,         // force closed option
                                         TRUE,          // reboot option
                                         ERROR_DS_SHUTTING_DOWN | SHTDN_REASON_FLAG_PLANNED 
                                        );

        if (!dwErr) {
            dwErr = GetLastError ();

            LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME_FORCE,
                     szInsertWin32ErrCode(dwErr),
                     szInsertWin32Msg(dwErr),
                     NULL);

            DPRINT1 (0, "Error %d performing shutdown. Forcing Shutdown of DS\n", dwErr);
        }
        else {
            dwErr=0;
        }

    }

    DPRINT (0, "Shutting Down System\n");
    
    ScriptLogPrint ( (DSLOG_TRACE, "Shutting Down System\n") );        

    DsUninitialize (FALSE);

    if (!gfRunningInsideLsa) {
        return 0;
    }

    // force shutdown if we failed
    if (dwErr) {
        ScriptLogPrint ( (DSLOG_TRACE, "Forcing Shut Down System: 0x%x\r\n", dwErr) );        
        ScriptLogFlush();
        NtShutdownSystem(ShutdownReboot);
    }

    if (ErrorMessage != NULL) {
        LocalFree(ErrorMessage);
    }

    // wait for shutdown to happen
    Sleep (120 * 1000);

    return 0;
}

//
//  ScriptExecuteDSShutdown
//
//  Description:
//
//     Shutdown the DS after the completion of the script execution
//
//  Arguments:
//
//
//  Return Value:
//
//     0 on success
// 
//
void ScriptExecuteDSShutdown()
{
    unsigned   ulThreadId;
    DWORD      dwShutDown;

    if(!_beginthreadex(NULL,
                       0,
                       ScriptAsyncDsShutdown,
                       NULL,
                       0,
                       &ulThreadId)) {

        dwShutDown = GetLastError ();

        // failed, so will do the shutdown asyncronously.
        DPRINT (0, "Failed to Asyncrounously Unitialize DS. Forcing Shutdown of DS\n");

        ScriptLogPrint ( (DSLOG_TRACE, "Failed to Asyncrounously Unitialize DS. Forcing Shutdown of DS: 0x%x\r\n", dwShutDown) );        

        LogEvent(DS_EVENT_CAT_SERVICE_CONTROL,
                 DS_EVENT_SEV_ALWAYS,
                 DIRLOG_DS_SHUTDOWN_DOMAIN_RENAME_FORCE,
                 szInsertWin32ErrCode(dwShutDown),
                 szInsertWin32Msg(dwShutDown),
                 NULL);

        DsUninitialize (FALSE);

        if (gfRunningInsideLsa) {
            NtShutdownSystem(ShutdownReboot);
            ScriptLogFlush();
        }
    }
}

//
//  ScriptGetNewDomainName
//
//  Description:
//
//     Retrieve the possible new domain name
//
//  Arguments:
//
//      pbDnsDomainNameWasChanged - set to TRUE is domain name changed
//      ppLocalDnsDomainName - set to new value of LocalDomainName
//                             the memory is malloced
//
//  Return Value:
//
//     0 on success, Error otherwise
// 
//
DWORD ScriptGetNewDomainName(THSTATE *pTHS, 
                             BOOL *pbDnsDomainNameWasChanged, 
                             LPWSTR *ppLocalDnsDomainName)
{
    WCHAR NameBuffer[DNS_MAX_NAME_LENGTH + 1];
    DWORD NameBufferSize = DNS_MAX_NAME_LENGTH + 1;
    DWORD dwErr = 0;

    *ppLocalDnsDomainName = NULL;
    *pbDnsDomainNameWasChanged = FALSE;

    dwErr = ReadCrossRefPropertySecure(gAnchor.pDomainDN, 
                                       ATT_DNS_ROOT,
                                       (FLAG_CR_NTDS_NC | FLAG_CR_NTDS_DOMAIN),
                                       ppLocalDnsDomainName);

    if (dwErr) {
        DPRINT (0, "Error getting the DnsRoot of the CrossRef object\n");
        return dwErr;
    }

    // get the current DomainName

    if ( ! GetComputerNameExW(
                      ComputerNameDnsDomain,
                      NameBuffer,
                      &NameBufferSize )) {

        dwErr = GetLastError();
        DPRINT1(0,"Cannot get host name. error %x\n", dwErr);
        return dwErr;
    }


    if (!DnsNameCompare_W( NameBuffer, *ppLocalDnsDomainName)) {
        *pbDnsDomainNameWasChanged = TRUE;
        DPRINT1 (0, "Domain Name Changed. Need to set computer name to new value: %ws\n", *ppLocalDnsDomainName);
    
        ScriptLogPrint ( (DSLOG_TRACE, "Domain Name Changed. Need to set computer name to new value: %ws\r\n", *ppLocalDnsDomainName) );        
    }

    return 0;
}

//
//  SetNewDomainName
//
//  Description:
//
//     Set the new computer name in registry as required.
//
//  Arguments:
//
//      pLocalDnsDomainName - the new DNS name of the machine
//
//  Return Value:
//
//     0 on success, Error otherwise
// 
//
DWORD SetNewDomainName (LPWSTR pLocalDnsDomainName) 
{
    DWORD NetStatus = 0;

    //
    // Change the computer name as required. The new name will take effect next time
    // the computer reboots. An error here is not fatal.
    //

    if ( pLocalDnsDomainName != NULL ) {
        if ( NetStatus = NetpSetDnsComputerNameAsRequired( pLocalDnsDomainName ) ) {
            DPRINT1 (0, "Can't NetpSetDnsComputerNameAsRequired %d\n", NetStatus );

            ScriptLogPrint ( (DSLOG_ERROR, "Cannot Set New Domain Name: %ws\r\n", pLocalDnsDomainName) );        

            LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DOMAIN_RENAME_CANNOT_SET_NEW_DOMAIN_NAME,
                     szInsertWC (pLocalDnsDomainName),
                     szInsertWin32ErrCode(NetStatus), 
                     szInsertWin32Msg(NetStatus) );

        } else {
            DPRINT1 (0, "Successfully set computer name with suffix %ws\n", pLocalDnsDomainName );
            ScriptLogPrint ( (DSLOG_TRACE, "Successfully set computer name with suffix %ws\r\n", pLocalDnsDomainName) );        
        }
    }

    return NetStatus;
}

//
//  ScriptHasDomainRenameExecuteScriptPassword
//
//  Description:
//
//     Checks to see if the user has the correct password to execute the script
//
//  Arguments:
//      cbPassword - Lenght of password
//      pbPassword - Pointer to password
//      pbHasAccess - result
//
//  Return Value:
//
//     0 on success
//     pbHasAccess set to TRUE if user has access, otheriwse FALSE
//
DWORD ScriptHasDomainRenameExecuteScriptPassword(THSTATE *pTHS, 
                                                 DWORD   cbPassword,
                                                 BYTE    *pbPassword,
                                                 BOOL    *pbHasAccess)
{
    DWORD       dwErr;
    ULONG       ulLen;
    BYTE        *pbStoredPassword;

    *pbHasAccess = FALSE;

    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    switch (dwErr) {
    case 0:

        if (dwErr = DBGetAttVal(pTHS->pDB, 1, ATT_MS_DS_EXECUTESCRIPTPASSWORD,
                        0, 0, &ulLen, (PUCHAR *)&pbStoredPassword)) {
            
            DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptPassword: Error reading password: %d\n", dwErr);

            return dwErr;
        }
        break;

    case DIRERR_OBJ_NOT_FOUND:
    case DIRERR_NOT_AN_OBJECT:

    default:
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
        break;
    }

    if ((ulLen == cbPassword) &&
        memcmp (pbPassword, pbStoredPassword, cbPassword) == 0 ) {
        *pbHasAccess = TRUE;
    }

    return 0;
}

//
//  ScriptHasDomainRenameExecuteScriptRight
//
//  Description:
//
//     Checks to see if the user has the right to execute the script
//     This is the same as beeing able to write the script on the partitions 
//     container
//
//  Arguments:
//      fAuditCARUseOnly -- only do an audit of control-access-right use (used on execute step)
//      pbHasAccess - result
//
//  Return Value:
//
//     0 on success
//     pbHasAccess set to TRUE if user has access, otheriwse FALSE
//
DWORD ScriptHasDomainRenameExecuteScriptRight(THSTATE *pTHS, BOOL fAuditCARUseOnly, BOOL *pbHasAccess)
{
    DWORD                dwErr;
    PSECURITY_DESCRIPTOR pNTSD = NULL;
    ULONG                ulLen;
    ATTCACHE            *pAC;
    CLASSCACHE          *pCC;
    BOOL                 fSDIsGlobalSDRef;

    *pbHasAccess = FALSE;

    dwErr = DBFindDSName(pTHS->pDB, gAnchor.pPartitionsDN);
    if (dwErr) {
        DPRINT1 (0, "Partitions container not found: %d\n", dwErr);
        return dwErr;
    }

    dwErr = DBGetObjectSecurityInfo(
                pTHS->pDB,
                pTHS->pDB->DNT,
                &ulLen,
                &pNTSD,
                &pCC,
                NULL,
                NULL,
                DBGETOBJECTSECURITYINFO_fUSE_OBJECT_TABLE,
                &fSDIsGlobalSDRef);
    if (dwErr) {
        DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptRight: Error reading SD: %d\n", dwErr);
        return dwErr;
    }

    if (fAuditCARUseOnly) {
        *pbHasAccess = TRUE;
    }
    else {
        pAC = SCGetAttById (pTHS, ATT_MS_DS_UPDATESCRIPT);
        if (!pCC || !pAC) {
            return ERROR_DS_MISSING_EXPECTED_ATT;
        }

        *pbHasAccess = IsAccessGrantedAttribute(pTHS,
                                         pNTSD,
                                         gAnchor.pPartitionsDN,
                                         1,
                                         pCC,
                                         &pAC,
                                         RIGHT_DS_WRITE_PROPERTY,
                                         TRUE);
    }

    if (*pbHasAccess) {
        // audit/check the control access right
        *pbHasAccess = IsControlAccessGrantedEx(
                            pNTSD, 
                            gAnchor.pPartitionsDN, 
                            pCC, 
                            RIGHT_DS_EXECUTE_SCRIPT, 
                            fAuditCARUseOnly ? CHECK_PERMISSIONS_AUDIT_ONLY : 0,
                            TRUE);
    }

    DPRINT1 (0, "ScriptHasDomainRenameExecuteScriptRight: Has Access %d\n", *pbHasAccess);

    if (pNTSD && !fSDIsGlobalSDRef) {
        THFreeEx(pTHS, pNTSD);
    }

    return 0;
}


#define DOMAIN_RENAME_KEYSIZE 128

//  ScriptDomainRenameVerifyCallIsSecure
//
//  Description:
//
//  This routine verifies that is using >= 128bit encryption. 
//  Domain Rename Requires a secure connection when we prepare the script
//  for execution.
//
// The keysize is extracted from the security context of the caller. 
// If the extracted keysize is less than 128, an error is returned.
//
//  Return Value:
//
//  0 on suceess, 
//  ERROR_DS_STRONG_AUTH_REQUIRED on error
//  other Win32 error
//
DWORD ScriptDomainRenameVerifyCallIsSecure(THSTATE *pTHS)
{
    DWORD                   dwErr;
    DWORD                   i;
    ULONG                   KeySize;
    PCtxtHandle             pSecurityContext;
    SecPkgContext_KeyInfo   KeyInfo;


    // clear client context on the thread state since we are going to change context
    AssignAuthzClientContext(&pTHS->pAuthzCC, NULL);
    if ( dwErr = RpcImpersonateClient(NULL) ) {
        DPRINT1 (0, "RpcImpersonateClient: Error 0x%x\n", dwErr);

        if (RPC_S_CANNOT_SUPPORT == dwErr) {
            dwErr = ERROR_DS_STRONG_AUTH_REQUIRED;
        }

        return ScriptProcessError(dwErr);
    }
    RpcRevertToSelf();

    // Get the security context from the RPC handle
    dwErr = I_RpcBindingInqSecurityContext(I_RpcGetCurrentCallHandle(),
                                           (void **)&pSecurityContext);
    if (dwErr) {
        DPRINT1 (0, "RpcBindingInqSecurityContext: Error 0x%x\n", dwErr);
        return ScriptProcessError(dwErr);
    }

    // get the keysize
    dwErr = QueryContextAttributesW(pSecurityContext,
                                    SECPKG_ATTR_KEY_INFO,
                                    &KeyInfo);
    if (dwErr) {
        // treat "not supported" as "not secure"
        if (dwErr != SEC_E_UNSUPPORTED_FUNCTION) {
            DPRINT1 (0, "QueryContextAttributesW: Error 0x%x\n", dwErr);
            return ScriptProcessError(dwErr);
        }
        KeySize = 0;
    } else {
        KeySize = KeyInfo.KeySize;
        FreeContextBuffer(KeyInfo.sSignatureAlgorithmName);
        FreeContextBuffer(KeyInfo.sEncryptAlgorithmName);
    }

    // is the key size large enough?
    if (KeySize < DOMAIN_RENAME_KEYSIZE) {
        DPRINT2(0, "Domain Rename: keysize is %d (minimum is %d)\n",
                KeySize, DOMAIN_RENAME_KEYSIZE);
        return ERROR_DS_STRONG_AUTH_REQUIRED;
    }

    DPRINT (0, "DomainRename Verified secure call \n");

    return ERROR_SUCCESS;
}


//
//  IDL_DSAPrepareScript
//
//  Description:
//
//     RPC Entry popint to prepare the script
//
//  Arguments:
//     dwInVersion - requested version of RPC call
//     pmsgIn - input message
//     pdwOutVersion - output version of RPC call
//     pmsgOut - out message
//
//  Return Value:
//
//     0 on success
//
//     ERROR_DS_INVALID_SCRIPT                   when the script does not have the right form (body + hashSig)
//                                       or when the signature is not right
//     ERROR_DS_NTDSCRIPT_PROCESS_ERROR  failed to read from database, execute, set new domain name
//     ERROR_DS_AUTHORIZATION_FAILED     when you are not authorized to modify the script on the 
//                                       partitions contaner (so we don't generate hash/passwd) 
//                                       or when you specified an invalid password         
//     ERROR_ACCESS_DENIED                           when there is an outstanding call in progress (10sec delay)
//     ERROR_INVALID_PARAMETER                   when a needed param is missing
//     ERROR_DS_INTERNAL_FAILURE                 if we failed for some internel reason (thread create fail, etc)
//
ULONG IDL_DSAPrepareScript( 
    IN  RPC_BINDING_HANDLE hRpc,
    IN  DWORD dwInVersion,
    IN  DSA_MSG_PREPARE_SCRIPT_REQ *pmsgIn,
    OUT DWORD *pdwOutVersion,
    OUT DSA_MSG_PREPARE_SCRIPT_REPLY *pmsgOut)
{
    THSTATE          *pTHS;
    DWORD             ret = 0, dwErr;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    BOOL              bHasAccess;
    
    WCHAR            *pScript = NULL;
    DWORD             cchScriptLen;

    BYTE             *pbHashBody = NULL, *pbHashSignature = NULL, *pbPassword = NULL;
    DWORD            cbHashBody = 0, cbHashSignature = 0, cbPassword = 0;
    BSTR             bstrScript = NULL;
    WCHAR           *pErrMessage = NULL;

    ScriptLogPrint ( (DSLOG_TRACE, "PrepareScript: Entering\r\n") );

    Sleep (INTRUDER_DELAY);
    
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
        
        ScriptLogPrint ( (DSLOG_ERROR, "Wrong Forest Version: %d. Required Version: %d\r\n", gAnchor.ForestBehaviorVersion, DS_BEHAVIOR_WIN_DOT_NET) );
        
        return ERROR_DS_NOT_SUPPORTED;
    }

    if (InterlockedExchange(&glRunningExecuteScriptOperations, 1) != 0) {
        return ERROR_ACCESS_DENIED;
    }

    __try {
        // Sanity check arguments.

        if (    ( NULL == hRpc )
                || ( NULL == pmsgIn )
                || ( NULL == pmsgOut )
                || ( NULL == pdwOutVersion )
                || ( 1 != dwInVersion ) ) {

            ret = ERROR_INVALID_PARAMETER;
            __leave;
        }
        
        *pdwOutVersion = 1;
        memset(pmsgOut, 0, sizeof(*pmsgOut));
        pmsgOut->V1.dwOperationStatus = ERROR_DS_INTERNAL_FAILURE;

        __try {
            if ( !(pTHS = InitTHSTATE(CALLERTYPE_DRA)) ) {
                ret = dwErr = ERROR_DS_INTERNAL_FAILURE;
                __leave;
            }

            Assert(pTHS);
            Assert(VALID_THSTATE(pTHS));

            dwErr = ScriptDomainRenameVerifyCallIsSecure(pTHS);
            if (dwErr) {
                ScriptLogPrint ( (DSLOG_ERROR, "Caller is not in a secure context: 0x%x.\r\n", dwErr) );
                __leave;
            }

            SYNC_TRANS_READ();   // Identify a reader transaction

            __try {

                // check for the right priviledges
                //
                if (dwErr = ScriptHasDomainRenameExecuteScriptRight(pTHS, FALSE, &bHasAccess)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Cannot verify that caller has execute rights: 0x%x\r\n", dwErr) );
                    bHasAccess = FALSE;
                }

                if (!bHasAccess) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Caller does not have execute rights\r\n") );

                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             NULL);

                    dwErr = ScriptProcessErrorExt(ERROR_DS_AUTHORIZATION_FAILED, dwErr);

                    __leave;
                }

                if (dwErr = ScriptReadFromDatabase (pTHS->pDB, &pScript, &cchScriptLen)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Error reading script: 0x%x\r\n", dwErr) );

                    DPRINT1 (0, "Error 0x%x reading script\n", dwErr);

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_READ_SCRIPT_FAILED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             NULL);

                    dwErr = ScriptProcessErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }

                if (dwErr = ScriptCalculateAndCheckHashKeys (pTHS,
                                                             pScript,
                                                             cchScriptLen,
                                                             &pbHashSignature,
                                                             &cbHashSignature,
                                                             &pbHashBody,
                                                             &cbHashBody
                                                             )) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error calculating hash: 0x%x\r\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_INVALID_SIGNATURE,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             NULL );

                    dwErr = ScriptProcessError(dwErr);

                    __leave;
                }

                if (dwErr = ScriptPrepareForParsing (pTHS, &pScript, &bstrScript)) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error preparing for parsing: 0x%x\r\n", dwErr) );
                    
                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr),
                             szInsertHex (DSID(FILENO, __LINE__)));

                    dwErr = ScriptProcessErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }
                
                // we are the DSA
                pTHS->fDSA = TRUE;

                if (dwErr = ScriptExecute (pTHS, SCRIPT_OPERATION_PREPROCESS, bstrScript, &pErrMessage, NULL)) {
                    LPSTR szErrStr;
                    szErrStr = THGetErrorString();
                    ScriptLogPrint ( (DSLOG_ERROR, "Error %S preprocessing script\r\n", szErrStr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertSz(szErrStr), 
                             szInsertHex (DSID(FILENO, __LINE__)), NULL);
                    THFreeEx(pTHS, szErrStr);

                    ScriptProcessError(dwErr);
                    __leave;
                }

            } __finally {

                if (bstrScript) {
                    SysFreeString(bstrScript);   
                }

                CLEAN_BEFORE_RETURN( pTHS->errCode );
            }
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
            ret = dwErr = ScriptException(dwException, ulErrorCode, dsid);
        }

        if (dwErr) {
            __leave;
        }

        __try {

            SYNC_TRANS_WRITE();   // Identify a writer transaction

            __try {

                if (dwErr = ScriptGenerateAndStorePassword (pTHS, 
                                                            &pbPassword, 
                                                            &cbPassword)) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error generating password: 0x%x\r\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             szInsertHex (DSID(FILENO, __LINE__)));

                    dwErr = ScriptProcessError(dwErr);

                    __leave;
                }

            } __finally {
                CLEAN_BEFORE_RETURN( pTHS->errCode );
            }

        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                          &dwEA, &ulErrorCode, &dsid)) {
                HandleDirExceptions(dwException, ulErrorCode, dsid);
                DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
                ret = dwErr = ScriptException(dwException, ulErrorCode, dsid);
        }

        if (!dwErr) {
            pmsgOut->V1.cbHashBody = cbHashBody;
            pmsgOut->V1.pbHashBody = pbHashBody;
            pmsgOut->V1.cbHashSignature = cbHashSignature;
            pmsgOut->V1.pbHashSignature = pbHashSignature;
            pmsgOut->V1.pbPassword = pbPassword;
            pmsgOut->V1.cbPassword = cbPassword;
            pmsgOut->V1.pwErrMessage = NULL;
            pErrMessage = NULL;
        }

    }
    __finally {
        Assert (glRunningExecuteScriptOperations == 1);
        glRunningExecuteScriptOperations = 0;
    }

    if (pmsgOut) {
        pmsgOut->V1.dwOperationStatus = dwErr;
        pmsgOut->V1.pwErrMessage = (WCHAR *)pErrMessage;
    }

    ScriptLogPrint ( (DSLOG_TRACE, "PrepareScript: Exiting: 0x%x\r\n", dwErr) );
    
    ScriptLogFlush();
    ScriptLogClose();

    return ret;
}

ULONG
DSA_MSG_EXECUTE_SCRIPT_REQ_V1_Validate(
    DSA_MSG_EXECUTE_SCRIPT_REQ_V1 * pmsg
    )
/*
                                        DWORD   Flags;
    [range(1,MAX_CB_OF_PASSWORD_IN_EXECUTE_SCPT_REQ_V1)]
                                        DWORD   cbPassword;
    [size_is(cbPassword)]               BYTE   *pbPassword;
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ((pmsg->cbPassword > 0) && (pmsg->pbPassword==NULL)) {
        ret = ERROR_INVALID_PARAMETER;
    }

    return ret;
}

ULONG
DSAExecuteScript_InputValidate(
    IN RPC_BINDING_HANDLE hRpc,
    IN DWORD dwInVersion,
    IN DSA_MSG_EXECUTE_SCRIPT_REQ *pmsgIn,
    OUT DWORD *pdwOutVersion,
    OUT DSA_MSG_EXECUTE_SCRIPT_REPLY *pmsgOut
    )
/*
    [in]		        handle_t	                     hRpc,
    [in]            DWORD                          dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DSA_MSG_EXECUTE_SCRIPT_REQ *   pmsgIn,
    [out] [ref]     DWORD *                        pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DSA_MSG_EXECUTE_SCRIPT_REPLY * pmsgOut
*/
{
    ULONG ret = ERROR_SUCCESS;

    if ( 1 != dwInVersion ) {
	ret = ERROR_INVALID_PARAMETER;
    }

    if (ret==ERROR_SUCCESS) {
	ret = DSA_MSG_EXECUTE_SCRIPT_REQ_V1_Validate(&(pmsgIn->V1));
    }

    return ret;
}

//
//  IDL_DSAExecuteScript
//
//  Description:
//
//     RPC Entry popint to execute the script
//
//  Arguments:
//     dwInVersion - requested version of RPC call
//     pmsgIn - input message
//     pdwOutVersion - output version of RPC call
//     pmsgOut - out message
//
//  Return Value:
//
//     0 on success
//
//     ERROR_DS_INVALID_SCRIPT                   when the script does not have the right form (body + hashSig)
//                                       or when the signature is not right
//     ERROR_DS_NTDSCRIPT_PROCESS_ERROR  failed to read from database, execute, set new domain name
//     ERROR_DS_AUTHORIZATION_FAILED     when you are not authorized to modify the script on the 
//                                       partitions contaner (so we don't generate hash/passwd) 
//                                       or when you specified an invalid password         
//     ERROR_ACCESS_DENIED                           when there is an outstanding call in progress (10sec delay)
//     ERROR_INVALID_PARAMETER                   when a needed param is missing
//     ERROR_DS_INTERNAL_FAILURE                 if we failed for some internel reason (thread create fail, etc)
//
ULONG IDL_DSAExecuteScript( 
    IN RPC_BINDING_HANDLE hRpc,
    IN DWORD dwInVersion,
    IN DSA_MSG_EXECUTE_SCRIPT_REQ *pmsgIn,
    OUT DWORD *pdwOutVersion,
    OUT DSA_MSG_EXECUTE_SCRIPT_REPLY *pmsgOut)
{
    THSTATE          *pTHS;
    DWORD             dwErr=0, ret=0;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    WCHAR            *pScript = NULL;
    DWORD             cchScript;
    BOOL              bIsDomainAdmin = FALSE;
    BOOL              bHasAccess;

    BYTE             *pbHashBody = NULL, *pbHashSignature = NULL;
    DWORD            cbHashBody = 0, cbHashSignature = 0;
    BSTR             bstrScript = NULL;
    WCHAR           *pErrMessage = NULL;

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScript: Entering\r\n") );

    Sleep (INTRUDER_DELAY);
    
    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
        
        ScriptLogPrint ( (DSLOG_ERROR, "Wrong Forest Version: %d. Required Version: %d\r\n", gAnchor.ForestBehaviorVersion, DS_BEHAVIOR_WIN_DOT_NET) );
        
        return ERROR_DS_NOT_SUPPORTED;
    }
    
    if (InterlockedExchange(&glRunningExecuteScriptOperations, 1) != 0) {
        return ERROR_ACCESS_DENIED;
    }

    __try {

        // Sanity check arguments.

        if (    ( NULL == hRpc )
                || ( NULL == pmsgIn )
                || ( NULL == pmsgOut )
                || ( NULL == pdwOutVersion )
                || ( 1 != dwInVersion ) ) {

            ret = ERROR_INVALID_PARAMETER;
            __leave;
        }
        *pdwOutVersion = 1;
        memset(pmsgOut, 0, sizeof(*pmsgOut));
        pmsgOut->V1.dwOperationStatus = ERROR_DS_INTERNAL_FAILURE;

        
        __try {
            if ( !(pTHS = InitTHSTATE(CALLERTYPE_DRA)) ) {
                ret = ERROR_DS_INTERNAL_FAILURE;
                __leave;
            }

            Assert(pTHS);
            Assert(VALID_THSTATE(pTHS));

            if ((ret = DSAExecuteScript_InputValidate(hRpc, 
						dwInVersion, 
						pmsgIn, 
						pdwOutVersion, 
						pmsgOut))!=ERROR_SUCCESS) {
                Assert(!"RPC Server input validation error, contact Dsrepl");
                __leave;
            }

            SYNC_TRANS_READ();  // identify a reader transaction

            __try {
                // check for the right priviledges
                //
                if (dwErr = ScriptHasDomainRenameExecuteScriptPassword(pTHS, 
                                                                 pmsgIn->V1.cbPassword,
                                                                 pmsgIn->V1.pbPassword, 
                                                                 &bHasAccess)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Cannot verify caller's password: 0x%x\r\n", dwErr) );

                    bHasAccess = FALSE;
                }
                else if (!bHasAccess) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Caller does not have the right password\r\n") );
                    dwErr = ERROR_DS_AUTHORIZATION_FAILED;
                }

                if (bHasAccess) {
                    // do the AUDIT_ONLY access check to generate (a sort of) audit of the execute
                    // operation. Note that we will not have the userID recorded since this is an
                    // unauthenticated RPC call.
                    if (dwErr = ScriptHasDomainRenameExecuteScriptRight(pTHS, TRUE, &bHasAccess)) {
                        ScriptLogPrint ( (DSLOG_ERROR, "Cannot audit execute operation: 0x%x\r\n", dwErr) );
                        bHasAccess = FALSE;
                    }
                }
                
                if (!bHasAccess) {
                    LogEvent(DS_EVENT_CAT_SECURITY,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_ACCESS_DENIED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             NULL);

                    dwErr = ERROR_DS_AUTHORIZATION_FAILED;

                    __leave;
                } 
            
                // read script
                if (dwErr = ScriptReadFromDatabase (pTHS->pDB, &pScript, &cchScript)) {
                    ScriptLogPrint ( (DSLOG_ERROR, "Error reading script: 0x%x\r\n", dwErr) );
                    
                    DPRINT1 (0, "Error 0x%x reading script\n", dwErr);
                    
                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_READ_SCRIPT_FAILED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             NULL);

                    dwErr = ERROR_DS_NTDSCRIPT_PROCESS_ERROR;
                    __leave;
                }

                // calculate hash keys
                if (dwErr = ScriptCalculateAndCheckHashKeys (pTHS,
                                                             pScript,
                                                             cchScript,
                                                             &pbHashSignature,
                                                             &cbHashSignature,
                                                             &pbHashBody,
                                                             &cbHashBody
                                                             )) {

                    ScriptLogPrint ( (DSLOG_ERROR, "Error calculating hash: 0x%x\r\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_INVALID_SIGNATURE,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr),
                             NULL);

                    dwErr = ScriptProcessError(dwErr);

                    __leave;
                }

                if (dwErr = ScriptPrepareForParsing (pTHS, &pScript, &bstrScript)) {
                    
                    ScriptLogPrint ( (DSLOG_ERROR, "Error preparing for parsing: 0x%x\r\n", dwErr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr),
                             szInsertHex (DSID(FILENO, __LINE__)));

                    dwErr = ScriptParseErrorExt(ERROR_DS_NTDSCRIPT_PROCESS_ERROR, dwErr);
                    __leave;
                }
                
                // we are the DSA
                pTHS->fDSA = TRUE;

                // execute the preprocessing part of the script
                if (dwErr = ScriptExecute (pTHS, SCRIPT_OPERATION_PREPROCESS, bstrScript, &pErrMessage, NULL)) {
                    LPSTR szErrStr;
                    szErrStr = THGetErrorString();
                    ScriptLogPrint ( (DSLOG_ERROR, "Error %S preprocessing script\r\n", szErrStr) );

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertSz(szErrStr), 
                             szInsertHex (DSID(FILENO, __LINE__)), NULL);
                    THFreeEx(pTHS, szErrStr);

                    ScriptProcessError(dwErr);
                    __leave;
                }


            } __finally {
                CLEAN_BEFORE_RETURN( pTHS->errCode || dwErr);
            }

            if (dwErr || pTHS->errCode ) {
                __leave;
            }


            SYNC_TRANS_WRITE();  // identify a writer transaction

            __try {

                // continue with execution of the script.


                // we are executing the script, so go into single user mode
                //
                if (!DsaSetSingleUserMode()) {
                    DPRINT (0, "Failed to go into single user mode\n");
                    dwErr = ERROR_DS_SINGLE_USER_MODE_FAILED;

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_CANNOT_PROCEED,
                             szInsertWin32ErrCode(dwErr), 
                             szInsertWin32Msg(dwErr), 
                             szInsertHex (DSID(FILENO, __LINE__)));

                    _leave;
                }


                if (dwErr = ScriptExecute (pTHS, SCRIPT_OPERATION_EXECUTE, bstrScript, &pErrMessage, NULL)) {
                    LPSTR szErrStr;
                    szErrStr = THGetErrorString();
                    ScriptLogPrint ( (DSLOG_ERROR, "Error %S execuring script\r\n", szErrStr) );
                    DPRINT1 (0, "Error %s executing script\n", szErrStr);

                    LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                             DS_EVENT_SEV_ALWAYS,
                             DIRLOG_DOMAIN_RENAME_EXECUTE_SCRIPT_FAILED,
                             szInsertSz(szErrStr), 
                             szInsertHex (DSID(FILENO, __LINE__)), NULL);
                    THFreeEx(pTHS, szErrStr);

                    ScriptProcessError(dwErr);
                    __leave;
                }

            } __finally {
                CLEAN_BEFORE_RETURN( dwErr || pTHS->errCode );
            }

            // get the error if we missed it
            if ((dwErr == 0) && (pTHS->errCode!=0)) {
                dwErr = pTHS->errCode;
            }
        }
        __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) {
            HandleDirExceptions(dwException, ulErrorCode, dsid);
            DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
            ret = dwErr = ScriptException(dwException, ulErrorCode, dsid);
        }

        if (bstrScript) {
            SysFreeString(bstrScript);   
        }
        
        // log an event regarding the status of the script execution 
        //
        LogEvent(DS_EVENT_CAT_INTERNAL_PROCESSING,
                 DS_EVENT_SEV_MINIMAL,
                 DIRLOG_SCRIPT_EXECUTE_STATUS,
                 szInsertWin32ErrCode(dwErr), 
                 szInsertWin32Msg(dwErr),
                 NULL);

        // shutdown computer
        // if we executed the script and we had no error or we are in singleuser mode
        //
        if (dwErr==0 || DsaIsSingleUserMode()) {
            ScriptExecuteDSShutdown ();
        }

        if (!dwErr) {
            pErrMessage = NULL;
        }

    }
    __finally {
        Assert (glRunningExecuteScriptOperations == 1);
        glRunningExecuteScriptOperations = 0;
    }

    if (pmsgOut) {
        pmsgOut->V1.dwOperationStatus = dwErr;
        pmsgOut->V1.pwErrMessage = (WCHAR *)pErrMessage;
    }

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScript: Exiting: 0x%x\r\n", dwErr) );
    ScriptLogFlush();
    ScriptLogClose();

    return ret;
}

//
//  GeneralScriptExecute
//
//  Description:
//
//     Execute the given XML script
//
//  Arguments:
//
//      Script - the script to execute. 
//
//  Return Value:
//
//     0 on success
//     error on failure
// 
//
DWORD GeneralScriptExecute (THSTATE *pTHS, WCHAR * Script )
{
    HRESULT             hr = S_OK;
    DWORD               err = 0;
    DWORD               retCode;
    ISAXXMLReader *     pReader = NULL;
    NTDSContent*        pHandler = NULL; 
    IClassFactory *     pFactory = NULL;
    BSTR                pBstrScript = NULL;

    VARIANT             varScript;
    const WCHAR         *pErrMessage = NULL;

    pBstrScript = SysAllocString( Script );
    if (!pBstrScript) {
        pTHS->errCode = ERROR_OUTOFMEMORY;
        return pTHS->errCode;
    }

    try {

        // create a variant for the value passed to the Parser
        VariantInit(&varScript);
        varScript.vt = VT_BYREF|VT_BSTR;
        varScript.pbstrVal = &pBstrScript; 
        
        // do the COM creation of the SAMXMLReader manually
        GetClassFactory( CLSID_SAXXMLReader, &pFactory);

        hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

        if(!FAILED(hr)) 
        {
            pHandler = new NTDSContent();
            hr = pReader->putContentHandler(pHandler);

            SAXErrorHandlerImpl * pEc = new SAXErrorHandlerImpl();
            hr = pReader->putErrorHandler(pEc);

            hr = pReader->parse(varScript);
            ScriptLogPrint ( (DSLOG_TRACE,  "XML Parse result code: 0x%08x\r\n",hr) );

            if(FAILED(hr)) {
                err = ScriptParseError(hr);
            }
            else {
                err = handlerScriptExecute(pHandler, SCRIPT_PROCESS_VALIDATE_SYNTAX_PASS, retCode, &pErrMessage);

                ScriptLogPrint ( (DSLOG_TRACE,  "Syntax Validate Processing: 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\r\n", err, retCode, retCode, pErrMessage) );

                if (!err && !retCode) {
                     err = handlerScriptExecute(pHandler, SCRIPT_PROCESS_EXECUTE_PASS, retCode, &pErrMessage);
                    ScriptLogPrint ( (DSLOG_TRACE,  "Execute Processing(RW): 0x%08X retCode:%d(0x%x) ErrorMessage(%ws)\r\n", err, retCode, retCode, pErrMessage) );
                }

                // set error accordingly to fail transaction
                // err means that we had an error parsing / executing
                if (err) {
                    pTHS->errCode = err;
                }
                // retcode means that something was not as expected in the data
                // stored in the DS
                else if (retCode) {
                    err = pTHS->errCode = retCode;
                }
            }
        }
        else 
        {
            err = ScriptParseError(hr);
            ScriptLogPrint ( (DSLOG_ERROR,  "Error Parsing XML: 0x%08x\r\n",hr) );
        }
    }
    catch (...) {
        err = ScriptParseError(ERROR_EXCEPTION_IN_SERVICE);
    }

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    SysFreeString(pBstrScript);
     
    return err;
}


#ifdef DBG

ULONG
ExecuteScriptLDAP (
        OPARG *pOpArg,
        OPRES *pOpRes
        )
{
    THSTATE          *pTHS = pTHStls;
    DWORD             dwErr;
    ULONG             dwException, ulErrorCode, dsid;
    PVOID             dwEA;
    WCHAR            *pwScript;
    BOOL              fPrivilegeHeld = FALSE;

    // debug privilege is required to run arbitrary scripts using DBG binaries
    if ((dwErr = CheckPrivilegeAnyClient(SE_DEBUG_PRIVILEGE, &fPrivilegeHeld)) != 0 || !fPrivilegeHeld) {
        SetSecErrorEx(SE_PROBLEM_INSUFF_ACCESS_RIGHTS, ERROR_PRIVILEGE_NOT_HELD, dwErr);
        return ERROR_PRIVILEGE_NOT_HELD;
    }

    ScriptLogPrint ( (DSLOG_TRACE, "ExecuteScriptLDAP: Entering\r\n") );

    __try {
        Assert(pTHS);
        Assert(VALID_THSTATE(pTHS));

        SYNC_TRANS_WRITE();  // identify a writer transaction

        __try {

            ScriptLogPrint ( (DSLOG_TRACE, "Script: %s\r\n", pOpArg->pBuf) );

            pwScript = UnicodeStringFromString8 (CP_UTF8, pOpArg->pBuf, pOpArg->cbBuf);

            dwErr = GeneralScriptExecute (pTHS, pwScript);

        } __finally {
            CLEAN_BEFORE_RETURN( dwErr || pTHS->errCode );
        }

        // get the error if we missed it
        if ((dwErr == 0) && (pTHS->errCode!=0)) {
            dwErr = pTHS->errCode;
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                              &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
        dwErr = ScriptException(dwException, ulErrorCode, dsid);
    }

    pOpRes->ulExtendedRet = dwErr;

    return dwErr;
}

#endif

LONG gScriptOptype = SCRIPT_OPTYPE_NOT_CACHED;

DWORD
ScriptGetOptype(THSTATE* pTHS, ScriptOperationType* pScriptOptype, BOOL fDontUseCache)
{
    DBPOS *pDB;
    DWORD dwErr = 0;
    WCHAR *pScript = NULL;
    DWORD cchScriptLen;

    BYTE  *pbHashBody = NULL, *pbHashSignature = NULL, *pbPassword = NULL;
    DWORD cbHashBody = 0, cbHashSignature = 0, cbPassword = 0;
    BSTR  bstrScript = NULL;
    WCHAR *pErrMessage = NULL;

    ULONG dwException, ulErrorCode, dsid;
    PVOID dwEA;
    
    NESTED_TRANSACTIONAL_DATA* pData;
    
    Assert(pScriptOptype);

    // figure out if we changed script optype somewhere in this transaction
    for (pData = pTHS->JetCache.dataPtr; pData != NULL; pData = pData->pOuter) {
        if (pData->objCachingInfo.fUpdateScriptChanged) {
            fDontUseCache = TRUE;
            break;
        }
    }
    if (!fDontUseCache) {
        // We did not change the script in this transaction, so we can use
        // the cached value.
        *pScriptOptype = (ScriptOperationType)gScriptOptype;
        if (*pScriptOptype != SCRIPT_OPTYPE_NOT_CACHED && *pScriptOptype != SCRIPT_OPTYPE_UNDEFINED) {
            // We had a valid value cached. Return it.
            // Note: the cached value MAY be inconsistent with our transactional DB view! 
            // This will occur if we started our transaction long ago, and since then, the script 
            // has changed, and the async task has recomputed the value. However, this cached value 
            // reflects the most recent value commited to the DB, and this is what is important to us.
            return 0;
        }
    }

    // OK, we need to compute the value
    __try {
        DBOpen(&pDB);
        __try {
            // assume by default there is no script.
            // This will be the return value if we
            *pScriptOptype = SCRIPT_OPTYPE_NOSCRIPT;

            if (ScriptReadFromDatabase (pDB, &pScript, &cchScriptLen) ||        // 1. Read script. May return an error if the
                                                                                //    script is not present.
                ScriptCalculateAndCheckHashKeys (pTHS,                          // 2. Check signature. If error is returned,
                                                 pScript,                       //    i.e. signature does not match, then
                                                 cchScriptLen,                  //    we assume there is no (valid) script.
                                                 &pbHashSignature,
                                                 &cbHashSignature,
                                                 &pbHashBody,
                                                 &cbHashBody
                                                 ) ||
                (dwErr = ScriptPrepareForParsing (pTHS, &pScript, &bstrScript)) ||  // 3. Prepare for parsing, can return out_of_memory
                ScriptExecute (pTHS,                                            // 4. Get the optype. If the error is returned,
                               SCRIPT_OPERATION_GET_OPTYPE,                     //    then the script is invalid, which means
                               bstrScript,                                      //    we will keep the value as NO_SCRIPT.
                               &pErrMessage, 
                               pScriptOptype)) 
            {
                __leave;
            }
        }
        __finally {
            if (pScript) {
                THFreeEx(pTHS, pScript);
            }
            if (pbHashSignature) {
                THFreeEx(pTHS, pbHashSignature);
            }
            if (pbHashBody) {
                THFreeEx(pTHS, pbHashBody);
            }

            if (bstrScript) {
                SysFreeString(bstrScript);   
            }
            DBClose(pDB, !AbnormalTermination() && !dwErr);
        }
    }
    __except(GetExceptionData(GetExceptionInformation(), &dwException,
                                  &dwEA, &ulErrorCode, &dsid)) {
        HandleDirExceptions(dwException, ulErrorCode, dsid);
        DPRINT2 (0, "Got an exception while executing script: 0x%x dsid: %x\n", ulErrorCode, dsid);
        dwErr = ScriptException(dwException, ulErrorCode, dsid);
    }

    if (dwErr == 0 && !fDontUseCache) {
        // Ok, we determined script optype without throwing an exception. Thus, we can trust 
        // the computed value (even if it is SCRIPT_OPTYPE_NO_SCRIPT). If the cached value 
        // is still SCRIPT_OPTYPE_NOT_CACHED, then we should cache the value we read.
        // Note: if the value is SCRIPT_OPTYPE_UNDEFINED, then there was a script-modifying 
        // operation recently, and we can not be sure our value is the correct one. Leave
        // the task of updating the cached value to TQ_CacheScriptOptype.
        InterlockedCompareExchange(&gScriptOptype, *pScriptOptype, SCRIPT_OPTYPE_NOT_CACHED);
        // If the value was not SCRIPT_OPTYPE_UNDEFINED, then some other thread might have beat 
        // us here and already written the value. It is possible that this value differs from 
        // the one we just computed, because we were using our own transactional DB view, which 
        // might be quite old. This is just fine, we will use the value we computed.
    }

    return dwErr;
}

extern "C"
void
CacheScriptOptype(void * pv,
                  void ** ppvNext,
                  DWORD * pcSecsUntilNextIteration )
{
    // This routine is invoked whenever script has changed. The current value
    // of gScriptOptype was set to SCRIPT_OPTYPE_UNDEFINED to reflect that
    // the current cached value is unsafe to use.
    ScriptOperationType scriptOptype;
    DWORD dwErr;
    THSTATE* pTHS = pTHStls;

    // Get the current script optype. Don't use the cached value, make sure we go to the
    // database to compute a fresh one.
    dwErr = ScriptGetOptype(pTHS, &scriptOptype, TRUE);
    if (dwErr == 0) {
        // success! We got something. Update the cached value.
        gScriptOptype = scriptOptype;

        StartOrStopDsaOpRPC(scriptOptype != SCRIPT_OPTYPE_NOSCRIPT);
    }
    else {
        // there was an exception computing script optype. Retry the operation in 1 minute.
        *pcSecsUntilNextIteration = 60;
    }
}

extern "C"
DWORD 
VerifyDomainRenameNotInProgress(THSTATE* pTHS)
/*++
Description:
    Checks whether a domain rename operation is in progress.
    
Arguments:
    pTHS -- (IN) THSTATE. pTHS->pDB currency is not disturbed.
    
Return value:
    0 if rename domain is not in progress
    ERROR_DS_DOMAIN_RENAME_IN_PROGRESS if it is.
    Other misc errors may be returned
    
++*/
{
    DWORD  dwErr;
    ScriptOperationType scriptOptype;

    Assert(pTHS);
    // This check should not be invoked in DRA context, or in SingleUserMode context
    Assert(!pTHS->fDRA && !pTHS->fSingleUserModeThread);

    if (gAnchor.ForestBehaviorVersion < DS_BEHAVIOR_WIN_DOT_NET) {
        // FBV must be >= 2 in order to do domain renames
        return 0;
    }

    if (DsaIsInstalling()) {
        // no check for DCPROMO operation
        return 0;
    }

    dwErr = ScriptGetOptype(pTHS, &scriptOptype, FALSE);
    if (dwErr == 0 && scriptOptype == SCRIPT_OPTYPE_DOMAINRENAME) {
        dwErr = ERROR_DS_DOMAIN_RENAME_IN_PROGRESS;
    }

    return dwErr;
}

VOID ScriptResetOptype() {
    gScriptOptype = SCRIPT_OPTYPE_UNDEFINED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\drsserv\drs_wclient.c ===
#include <NTDSpch.h>
#pragma  hdrstop
#include <drs_w.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\drsserv\drsuapi.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drsuapi.c
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Wrappers for DRS interface RPC client functions.  Historically the DRS
    interface was used only for installation and replication, though for NT
    its responsibilities have grown to cover other DS-to-DS and arbitrary
    client-to-DS communication.

DETAILS:

CREATED:

REVISION HISTORY:

    Greg Johnson (gregjohn) 2/28/01
        RPC cancel functions added.  In order to use the RPC cancel call
        functions each thread wishing to set a specific time to cancel must
        have it's own copy of the context handle.  This is simply a copy of
        the handle however, so only when all copies are no longer in use
        may the handle be freed.
        
        To reduce contention and network serialization instead of freeing a 
        handle when it is no longer used, it is placed on a queue.  Later, 
        a dedicated thread frees the handles on the queue.

    Will Lees (wlees) 11/18/02
        The binding cache does not have a negative cache. Part of the reason for this
        is the multiple levels of retry that may occur. Binding disconnects and rebinds
        are a normal part of the negotiation process. FBindSzDrs() is called multiple
        times in a loop depending on the call completion logic in drsIsCallComplete.
        Even after exhausting all attempts at rebind, it may not be safe to conclude that
        all binds on all NCs will fail. For example, we use a different SPN depending on
        whether we are binding to a domain or not. Also, we must be extremely careful
        not to block a sync on another NC that might correct the reason we cannot bind.
        We felt it safest to put binding suppression at the replication queue layer, and
        this layer only returns an indicator whether a binding coudl be obtained
        (see pfBindSuccess).

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntdsa.h>
#include <drs.h>
#include "dsevent.h"
#include "mdcodes.h"
#include "dsexcept.h"
#include "drserr.h"
#include <heurist.h>
#include "bhcache.h"
#include "mdglobal.h"   // for eServiceShutdown
#include "anchor.h"     // for gAnchor
#include "scache.h"     // reqd. for mdlocal.h
#include "dbglobal.h"   // reqd. for mdlocal.h
#include "mdlocal.h"    // for DsaIsInstalling()
#include <drautil.h>
#include <dramail.h>
#include <dsatools.h>
#include "objids.h"     // Defines for selected classes and atts
#include <dsconfig.h>   // GetConfigParam
#include <mdcodes.h>    // Event codes
#include <winsock2.h>   // inet_addr
#include <pek.h>
#include <dsutil.h>     // MAP_SECURITY_PACKAGE_ERROR
#include <ntdsctr.h>    // perf counters
#include <dstaskq.h>
#include <dnsresl.h>    // for GetIpAddrByDnsNameW
#include <drarpc.h>
#include <kerberos.h>   // for purging kerberos cache
#include "gcverify.h"   // for FindDC/InvalidateGC

#include   "debug.h"         /* standard debugging header */
#define DEBSUB     "DRSUAPI:" /* define the subsystem for debugging */

#include "drsuapi.h"
extern RPC_IF_HANDLE _drsuapi_ClientIfHandle;

#include <fileno.h>
#define  FILENO FILENO_DRSUAPI

#define GCSpnType       L"GC"

// Does the SPN specify the domain name that the target account is in (by
// appending @domain.com)?
#define IS_DOMAIN_QUALIFIED_SPN(pszSpn) (NULL != wcschr((pszSpn), L'@'))
#define GET_DOMAIN_FROM_QUALIFIED_SPN(pszSpn) (wcschr((pszSpn), L'@')+1)

void
DRSExpireContextHandles(
    IN  VOID *  pvArg,
    OUT VOID ** ppvNextArg,
    OUT DWORD * pcSecsUntilNextRun
    );

// Time limit (in minutes) of various RPC operations.
ULONG gulDrsRpcBindTimeoutInMins;
ULONG gulDrsRpcReplicationTimeoutInMins;
ULONG gulDrsRpcGcLookupTimeoutInMins;
ULONG gulDrsRpcMoveObjectTimeoutInMins;
ULONG gulDrsRpcNT4ChangeLogTimeoutInMins;
ULONG gulDrsRpcObjectExistenceTimeoutInMins;
ULONG gulDrsRpcGetReplInfoTimeoutInMins;

// How long do we keep DRS context handles in the cache?  (in sec)
ULONG gulDrsCtxHandleLifetimeIntrasite;
ULONG gulDrsCtxHandleLifetimeIntersite;

// How often do we check to see if context handles have expired? (in sec)
ULONG gulDrsCtxHandleExpiryCheckInterval;

// Do we want a different RPC association than the default?
BOOL gfUseUniqueAssoc = FALSE;

// FBindSzDRS flags

#define FBINDSZDRS_NO_CACHED_HANDLES (1)
#define FBINDSZDRS_LOCK_HANDLE       (2)
#define FBINDSZDRS_CRYPTO_BIND       (4)

// Tracks DRS context handle state.  Returned by FBindSzDRS() and freed by
// DRSFreeContextInfo().

typedef struct _DRS_CONTEXT_INFO {
    LPWSTR     pszServerName;          // Net name of the server.
    DRS_HANDLE hDrs;                   // The DRS context handle.
    unsigned   fIsHandleFromCache : 1; // Did we reuse an already cached handle?
    unsigned   fIsHandleInCache   : 1; // Is this handle currently in the cache
                                       //   (i.e., was already there or we got a
                                       //   new one and added it to the cache)?
    union {                            // The server's extensions set.
        BYTE            rgbExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS  ext;
    };
    ULONG      ulFlags;                // flags used to get this context
    HANDLE *   phThread;               // thread handle of thread using this context handle
    DWORD      dwThreadId;             // thread id
    DWORD      dwBindingTimeoutMins;   // Cancellation time, if set
    DSTIME     dstimeCreated;          // Time created
    DRS_CONTEXT_CALL_TYPE eCallType;   // Call type
    LIST_ENTRY ListEntry;
} DRS_CONTEXT_INFO;

typedef struct _DRS_HANDLE_LIST_ELEM {
    LPWSTR     pszServerName;          // Net name of the server
    DRS_HANDLE hDrs;                   // The DRS context handle.
    LIST_ENTRY ListEntry;
} DRS_HANDLE_LIST_ELEM;


// Has this library been initialized?
BOOL gfIsDrsClientLibInitialized = FALSE;

// List of outstanding async RPC calls.
LIST_ENTRY gDrsAsyncRpcList;
RTL_CRITICAL_SECTION gcsDrsAsyncRpcListLock;

// List of outstanding sync RPC handles - uses DRS_CONTEXT_INFO
// This list's sole purpose is to enable the cancelation of 
// all sync RPC calls if a shutdown is intiated.
LIST_ENTRY gDrsRpcServerCtxList;
CRITICAL_SECTION gcsDrsRpcServerCtxList;
BOOL gfDrsRpcServerCtxListInitialized = FALSE;
DWORD gcNumDrsRpcServerCtxListEntries = 0;

// List of sync RPC handles to free - uses DRS_HANDLE_LIST_ELEM
// In order to decrease contention between threads, RPC handles
// to be freed are placed on this list to be freed later by
// a thread dedicated to the task.
LIST_ENTRY gDrsRpcFreeHandleList;
CRITICAL_SECTION gcsDrsRpcFreeHandleList;
BOOL gfDrsRpcFreeHandleListInitialized = FALSE;
DWORD gcNumDrsRpcFreeHandleListEntries = 0;

// Table of timeout information for async rpc calls
struct {
    DRS_CALL_TYPE   CallType;
    DWORD           dwMsgID;
    ULONG *         pcNumMinutesUntilRpcTimeout;
} rgCallTypeTable[] = {
    {DRS_ASYNC_CALL_NONE,        0,                      NULL},   // placeholder
    {DRS_ASYNC_CALL_GET_CHANGES, DIRLOG_RPC_CALL_GETCHG, &gulDrsRpcReplicationTimeoutInMins},
};

BOOL
getContextBindingHelper(
    IN      THSTATE *           pTHS,
    IN      LPWSTR              szServer,
    IN      LPWSTR              pszDomainName,  OPTIONAL
    IN      ULONG               ulFlags,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo,
    IN OUT  DWORD *             pdwStatus
    );

void
DRSFreeContextInfo(
    IN      THSTATE           * pTHS,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo
    );

//
// Credential manangement routines
//
//
CRITICAL_SECTION            csCredentials;
PSEC_WINNT_AUTH_IDENTITY_W  gCredentials = NULL;
UCHAR                       gCredentialSeed = 0;
HANDLE                      gInstallClientToken = 0;

VOID
DrspFreeCredentials(
    PSEC_WINNT_AUTH_IDENTITY_W pCred
    )
{
    Assert(pCred);

    free(pCred->User);
    free(pCred->Domain);
    free(pCred->Password);
    free(pCred);
}

DWORD
DRSSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength
    )
//
// This function translates the parameters into a RPC_AUTH_IDENTITY_HANDLE
// that can be used when establishing an RPC connection
//
{

    ULONG                      ret;
    PSEC_WINNT_AUTH_IDENTITY_W pNewCred = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pOldCred = NULL;
    ULONG                      Length;
    WCHAR                      *wsUser = NULL, *wsDomain = NULL, *wsPassword = NULL;
    BOOL                       fInCriticalSection = FALSE;
    UNICODE_STRING             EPassword;

    if ( !gfIsDrsClientLibInitialized )
    {
        DRSClientCacheInit();
    }

    __try
    {

        if (!User && !Domain && !Password) {
            //
            // Set the credentials to NULL
            //
            EnterCriticalSection( &csCredentials );
            fInCriticalSection = TRUE;

            pOldCred =  gCredentials;
            gCredentials = NULL;

            ret = DRAERR_Success;

            __leave;

        }

        if (!User || !Domain || !Password) {
            ret = DRAERR_InvalidParameter;
            __leave;
        }

        //
        // At this point we have a new set of acceptable credentials
        //
        pNewCred = (PSEC_WINNT_AUTH_IDENTITY_W) malloc(sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        if (!pNewCred) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(pNewCred, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

        Length = wcslen(User);
        wsUser = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsUser) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsUser, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsUser, User);
        pNewCred->UserLength = Length;
        pNewCred->User       = wsUser;

        Length = wcslen(Domain);
        wsDomain = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsDomain) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsDomain, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsDomain, Domain);
        pNewCred->DomainLength = Length;
        pNewCred->Domain       = wsDomain;

        Length = PasswordLength;
        wsPassword = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsPassword) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsPassword, 0, (Length+1)*sizeof(WCHAR));
        memcpy(wsPassword, Password, (Length)*sizeof(WCHAR));
        pNewCred->PasswordLength = Length;
        pNewCred->Password       = wsPassword;

        pNewCred->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        //
        // Set the global Credentials
        //
        EnterCriticalSection( &csCredentials );
        fInCriticalSection  = TRUE;

        //
        // Encrypt the password
        //
        RtlInitUnicodeString( &EPassword, pNewCred->Password );
        RtlRunEncodeUnicodeString( &gCredentialSeed, &EPassword );

        pOldCred =  gCredentials;
        gCredentials = pNewCred;
        gInstallClientToken = ClientToken;

        ret = DRAERR_Success;

    }
    __finally
    {
        if (fInCriticalSection) {
            LeaveCriticalSection( &csCredentials );
        }

        if (ret != DRAERR_Success) {

            if (pNewCred) {
                free(pNewCred);
            }
            if (wsUser) {
                free(wsUser);
            }
            if (wsDomain) {
                free(wsDomain);
            }
            if (wsPassword) {
                free(wsPassword);
            }
        }

        if (pOldCred) {
            DrspFreeCredentials(pOldCred);
        }

    }

    return ret;
}

DWORD
DRSImpersonateInstallClient(
    OUT BOOL *pfImpersonate
    )
//
// This routine impersonates the global client token if one
// is present.  This is only necessary during install.
//
// gInstallClientToken will be set during installation.
//
{
    *pfImpersonate = FALSE;
    if (gInstallClientToken) {
        *pfImpersonate = ImpersonateLoggedOnUser(gInstallClientToken);
        if (!(*pfImpersonate)) {
            return GetLastError();
        }
    }
    return ERROR_SUCCESS;
}

ULONG
DrspGetCredentials(
    OUT PSEC_WINNT_AUTH_IDENTITY_W *ppCred
    )
//
// This routine returns the globally stored credentials to
// perform a DsBind with.  This is only necessary during install.
//
{

    ULONG                      ret;
    PSEC_WINNT_AUTH_IDENTITY_W pNewCred = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W pOldCred;
    ULONG                      Length;
    WCHAR                      *wsUser = NULL, *wsDomain = NULL, *wsPassword = NULL;
    UNICODE_STRING             EPassword;

    EnterCriticalSection( &csCredentials );
    __try
    {
        //
        // If there are no credentials, bail out now
        //
        if (!gCredentials) {
            *ppCred = NULL;
            ret = DRAERR_Success;
            __leave;
        }

        pNewCred = (PSEC_WINNT_AUTH_IDENTITY_W) malloc(sizeof(SEC_WINNT_AUTH_IDENTITY_W));
        if (!pNewCred) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(pNewCred, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

        Length = wcslen(gCredentials->User);
        wsUser = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsUser) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsUser, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsUser, gCredentials->User);
        pNewCred->UserLength = Length;
        pNewCred->User       = wsUser;

        Length = wcslen(gCredentials->Domain);
        wsDomain = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsDomain) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsDomain, 0, (Length+1)*sizeof(WCHAR));
        wcscpy(wsDomain, gCredentials->Domain);
        pNewCred->DomainLength = Length;
        pNewCred->Domain       = wsDomain;

        Length = gCredentials->PasswordLength;
        wsPassword = (WCHAR*) malloc((Length+1)*sizeof(WCHAR));
        if (!wsPassword) {
            ret = DRAERR_OutOfMem;
            __leave;
        }
        memset(wsPassword, 0, (Length+1)*sizeof(WCHAR));
        memcpy(wsPassword, gCredentials->Password, (Length)*sizeof(WCHAR));
        pNewCred->PasswordLength = Length;
        pNewCred->Password       = wsPassword;

        //
        // Unencrypt the password
        //
        RtlInitUnicodeString( &EPassword, pNewCred->Password );
        RtlRunDecodeUnicodeString( gCredentialSeed, &EPassword );

        pNewCred->Flags = gCredentials->Flags;

        //
        // Return the copy of the credentials
        //
        *ppCred =  pNewCred;

        ret = DRAERR_Success;

    }
    __finally
    {
        if (ret != DRAERR_Success) {

            if (pNewCred) {
                free(pNewCred);
            }
            if (wsUser) {
                free(wsUser);
            }
            if (wsDomain) {
                free(wsDomain);
            }
            if (wsPassword) {
                free(wsPassword);
            }
        }

        LeaveCriticalSection( &csCredentials );

    }

    return ret;

}

VOID
DRSSetRpcCancelTime(
    IN      ULONG               MinutesTillCancel,
    IN OUT  DRS_HANDLE *        phDrs
    )
{
    RPC_BINDING_HANDLE hRpc;
    ULONG rpcstatus = RPC_S_OK;

    // get the binding handle.  (RPC says not to free this handle)
    rpcstatus = RpcSsGetContextBinding(*phDrs, &hRpc);
    if (rpcstatus!=RPC_S_OK) {
        DRA_EXCEPT(rpcstatus,0); 
    }

    // set the cancel time in milliseconds
    rpcstatus = RpcBindingSetOption(hRpc, RPC_C_OPT_CALL_TIMEOUT, MinutesTillCancel*60*1000); 
    if (rpcstatus!=RPC_S_OK) {
        DRA_EXCEPT(rpcstatus,0); 
    }
}

VOID
DRSSetContextCancelTime(
    IN      DRS_CONTEXT_CALL_TYPE eCallType,
    IN      ULONG               MinutesTillCancel,
    IN      DRS_CONTEXT_INFO   *pContextInfo
    )
{
    DRSSetRpcCancelTime(MinutesTillCancel, &pContextInfo->hDrs );  
    pContextInfo->eCallType = eCallType;
    pContextInfo->dwBindingTimeoutMins = MinutesTillCancel;
}

void
InitRpcSessionEncryption(
    THSTATE             *pTHS,
    ULONG               ulBindFlags,
    DRS_CONTEXT_INFO    *pContextInfo,
    RPC_BINDING_HANDLE  ExistingBindingHandle
    )
{
    RPC_STATUS          RpcStatus;
    RPC_BINDING_HANDLE  RpcBindingHandle;

    // Caller should have either binding handle or context, but not both.
    Assert(    ( pContextInfo && !ExistingBindingHandle)
            || (!pContextInfo &&  ExistingBindingHandle) );

    // Callers like GetNCChanges use "one shot" session encryption which
    // is not tied to the context handle.  Many GetNCChanges calls can use
    // the same cached handle and each gets a new session key on each call.
    // Callers like InterDomainMove are associating a session key with
    // the context handle and will use the same key on one or more subsequent
    // RPC calls.  Although I don't see any obvious conflict with the two
    // modes, for now we assert that context handle based session keys
    // require an exclusively owned handle.

    Assert(FBINDSZDRS_CRYPTO_BIND & ulBindFlags
                ? FBINDSZDRS_LOCK_HANDLE & ulBindFlags
                : TRUE);

    // Clear any existing key on the thread state.

    PEKClearSessionKeys(pTHS);

    // Register a notification call back with RPC.  This will call a call
    // back function telling us the security context used.  This security
    // context is then used to query the session key and that session key
    // is then set on the thread state. When the DRA subsequently reads
    // the database all "secret" data are then re-encrypted using the
    // session key.

    if ( ExistingBindingHandle )
    {
        RpcBindingHandle = ExistingBindingHandle;
        RpcStatus = RPC_S_OK;
    }
    else
    {
        RpcStatus = RpcSsGetContextBinding(
                                        pContextInfo->hDrs,
                                        &RpcBindingHandle);
    }

    if ( RPC_S_OK == RpcStatus )
    {
        RpcStatus = RpcBindingSetOption(
                                        RpcBindingHandle,
                                        RPC_C_OPT_SECURITY_CALLBACK,
                                        (ULONG_PTR) PEKSecurityCallback);

        // After checking with RPC folks should not free
        // the binding handle returned by this function
    }

    if ( RPC_S_OK != RpcStatus )
    {
        // Could not establish session key - raise exception

        RaiseDsaExcept( DSA_CRYPTO_EXCEPTION,
                        RpcStatus,
                        0,
                        DSID(FILENO,__LINE__),
                        DS_EVENT_SEV_MINIMAL);
    }
}

CRITICAL_SECTION csBHCache;

// Uninitialized elements are default initialized to zero.
static BHCacheElement NullBHCacheElement = { 0 };

BHCacheElement rgBHCache[BHCacheSize];

void DRSClientCacheInit(void)
{
    static BOOL fAreCritSecsInitialized = FALSE;

    if (!fAreCritSecsInitialized)
    {
        //
        // This has nothing to do with the client cache, but is put in this
        // in this function to be initialized when starting up
        //
        __try {
            InitializeCriticalSection( &csCredentials );

            InitializeCriticalSection( &csBHCache );

            fAreCritSecsInitialized = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            fAreCritSecsInitialized = FALSE;
        }

        if(!fAreCritSecsInitialized) {
            DsaExcept(DSA_MEM_EXCEPTION, 0, 0);
        }
    }

    memset(rgBHCache, 0, sizeof(rgBHCache));

    if (gfTaskSchedulerInitialized          // not so in DCPROMO
        && !gfDisableBackgroundTasks) {     // not doing performance testing
        InsertInTaskQueue(TQ_DRSExpireContextHandles,
                          NULL,
                          gulDrsCtxHandleExpiryCheckInterval);
    }

    gfIsDrsClientLibInitialized = TRUE;
}


ULONG
DRSHandleRpcClientException(
    IN  EXCEPTION_POINTERS *  pExceptPtrs,
    IN  LPWSTR                pszServerName,
    IN  DRS_CONTEXT_INFO *    pContextInfo      OPTIONAL,
    IN  ULONG                 ulRpcCallTimeoutMins,
    OUT ULONG *               pulErrorCode
    )
/*++

Routine Description:

    Handle RPC exceptions generated while making DRS client calls using an
    already bound DRS context handle acquired via a prior call to FBindSzDRS().
    Called as part of an __except wrapping an _IDL_DRS* call.

Arguments:

    pExceptPtrs (IN) - Exception data returned by GetExceptionInformation(),
        as retrieved in the __except.

    pszServerName (IN) - Server to which we're making the RPC call.
    
    pContextInfo (IN, OPTIONAL) - Context info associated with current binding
        to pszServerName.

    pulErrorCode (OUT) - Exception code for caller to use

Return Values:

    EXCEPTION_EXECUTE_HANDLER - Exception handled.
    EXCEPTION_CONTINUE_SEARCH - Exception not handled.

--*/
{
    ULONG   ulResult;
    ULONG   ulExceptCode;
    VOID *  pExceptAddr;
    ULONG   ulExtErrorCode;
    DWORD   dwWin32Error;
    THSTATE * pTHS = pTHStls;

    Assert( pulErrorCode );

    *pulErrorCode = ERROR_SUCCESS; // GetExceptData does not always set this

    ulResult = GetExceptionData(pExceptPtrs, &ulExceptCode, &pExceptAddr,
                                pulErrorCode, &ulExtErrorCode);

    // If there was not an error data parameter associated with the exception,
    // turn the exception code itself into something meaningful.  If the
    // exception looks like a NTSTATUS, convert to Win32.

    if (*pulErrorCode == ERROR_SUCCESS) {
        if ( (ulExceptCode & 0xf0000000) == 0xc0000000 ) {
            *pulErrorCode = RtlNtStatusToDosError( ulExceptCode );
        } else {
            *pulErrorCode = ulExceptCode;
        }
    }

    Assert( *pulErrorCode != RPC_S_OK );

    if (EXCEPTION_EXECUTE_HANDLER == ulResult) {
        // Derive Win32 error from exception data.
        switch (ulExceptCode) {
        case DRA_GEN_EXCEPTION:
            // DRA exceptions always have an acompanying Win32 error code.
            dwWin32Error = *pulErrorCode;
            break;

        case DSA_EXCEPTION:
        case DSA_MEM_EXCEPTION:
        case DSA_DB_EXCEPTION:
        case DSA_BAD_ARG_EXCEPTION:
        case DSA_CRYPTO_EXCEPTION:
            // These NTDSA exceptions don't specify Win32 counterparts.
            // Fall through and consider the Win32 error code to be the
            // exception code for purposes of determining which event to log.
        
        default:
            // System-generated exceptions (such as those generated by RPC)
            // use a Win32 error code as the exception code.
            dwWin32Error = ulExceptCode;
            break;
        }

        // Log the exception code (if logging is cranked high enough).
        switch (dwWin32Error) {
        case RPC_S_CALL_CANCELLED:
            if (!eServiceShutdown) { 
                LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_DISPATCHER_CANCELED,
                          szInsertHex(GetCurrentThreadId()),
                          szInsertWC(pszServerName),    
                          szInsertUL(ulRpcCallTimeoutMins),
                          szInsertHex((ULONG)(pExceptPtrs->ExceptionRecord->ExceptionInformation)[2]),
                          NULL,NULL,NULL,NULL); 
            } else {
                LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_DRA_DISPATCHER_CANCELED_SHUTDOWN,
                          szInsertHex(GetCurrentThreadId()),
                          szInsertWC(pszServerName),
                          szInsertHex((ULONG)(pExceptPtrs->ExceptionRecord->ExceptionInformation)[2])); 
            }
            
            break;

        case ERROR_DS_DIFFERENT_REPL_EPOCHS:
            // Only NULL on binds, and this error is not generated on binds.
            Assert(NULL != pContextInfo);

            DPRINT3(0, "RPC to %ls denied - replication epoch mismatch (remote %d, local %d).\n",
                    pszServerName,
                    REPL_EPOCH_FROM_DRS_EXT(&pContextInfo->ext),
                    gAnchor.pLocalDRSExtensions->dwReplEpoch);
            
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_REPL_EPOCH_MISMATCH_COMMUNICATION_REJECTED,
                     szInsertWC(pszServerName),
                     pContextInfo
                        ? szInsertUL(REPL_EPOCH_FROM_DRS_EXT(&pContextInfo->ext))
                        : szInsertSz(""),
                     szInsertUL(gAnchor.pLocalDRSExtensions->dwReplEpoch));
            break;
        
        default:
            // uncaught rpc error, let the default logging suffice here 
            break;
        }

        LogRpcExtendedErrorInfo(pTHS, dwWin32Error, pszServerName, (ULONG)(pExceptPtrs->ExceptionRecord->ExceptionInformation)[2]);
    }

    return ulResult;
}

void
DRSFreeContextHandle(
    IN      LPWSTR          pszServerName,
    IN OUT  DRS_HANDLE *    phDrs
    )
/*++

Routine Description:

    Free a given DRS_HANDLE (a context handle for the DRS interface).

    During normal operation we call the server to unbind, which frees both its
    associated resources and our own resources.  During shutdown, we must avoid
    going off-machine, so we free only our own resources and rely on the
    server's context handle rundown routine to free its resources.  

Arguments:

    pszServerName (IN) - The server to which the context handle corresponds.
        Used for logging if there are any complications.

    phDrs (IN/OUT) - on input, holds the client handle to free.  Reset to
        NULL on success.

Return Values:

    None.

--*/
{
    ULONG ulErrorCode;

    if (NULL != *phDrs) {
        BOOL fFreed = FALSE; 

        if (!eServiceShutdown) {
            __try {
                ULONG ret = RPC_S_OK; 
                DRSSetRpcCancelTime(gulDrsRpcBindTimeoutInMins, phDrs);
                _IDL_DRSUnbind(phDrs);   
                fFreed = TRUE;
            }
            __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                                  pszServerName,
                                                  NULL,
                                                  gulDrsRpcBindTimeoutInMins,
                                                  &ulErrorCode)) {
                ;
            }
        }

        if (!fFreed) {
            // We're either shutting down or the unbind attempt failed;  the
            // remote resources will have to be freed by the context handle
            // rundown routine.  Free our local resources.
            RpcSsDestroyClientContext(phDrs);
        }
    }
}

void
DRSInsertFreeHandleQueue(
    IN      LPWSTR          pszServerName,
    IN      DRS_HANDLE      hDrs
    )
/*++

Routine Description:

    The purpose of this routine is to reduce contention between threads.  Using this
    queue of handles to be freed, only a single thread attempts to free handles, and only
    while not holding any crit. sec.  
    

Arguments:

    pszServerName - the name of the server which to free the handle from
    hDrs - the handle to free

Return Values:

    None.

--*/
{
    if (NULL != hDrs) {
        DRS_HANDLE_LIST_ELEM * pInsHandle;
        ULONG                   cbServerName;

        // allocate element and Server string name (accessable outside of this
        // threads lifetime
        pInsHandle = (DRS_HANDLE_LIST_ELEM *)malloc(sizeof(DRS_HANDLE_LIST_ELEM)); 
        if (pInsHandle==NULL) {
            // we don't have the resources to unbind this handle.  free our resources 
            RpcSsDestroyClientContext(&hDrs);
            DRA_EXCEPT(ERROR_NOT_ENOUGH_MEMORY,0);
        }

        cbServerName = (wcslen(pszServerName)+1)*sizeof(WCHAR);
        pInsHandle->pszServerName = malloc(cbServerName);
        if (pInsHandle->pszServerName==NULL) {
            // we don't have the resources to unbind this handle.  free our resources   
            RpcSsDestroyClientContext(&hDrs);
            free(pInsHandle);
            DRA_EXCEPT(ERROR_NOT_ENOUGH_MEMORY,0);
        }

        wcscpy(pInsHandle->pszServerName, pszServerName);
        pInsHandle->hDrs = hDrs;

        // insert into queue     
        EnterCriticalSection(&gcsDrsRpcFreeHandleList);
        __try {
            if (!gfDrsRpcFreeHandleListInitialized) {
                InitializeListHead(&gDrsRpcFreeHandleList);  
                Assert(0 == gcNumDrsRpcFreeHandleListEntries);
                gfDrsRpcFreeHandleListInitialized = TRUE;
            }
            InsertTailList(&gDrsRpcFreeHandleList, &pInsHandle->ListEntry);
            ++gcNumDrsRpcFreeHandleListEntries; 
        }
        __finally {
            LeaveCriticalSection(&gcsDrsRpcFreeHandleList);
        } 
    }

}

void
DRSExpireClientCtxHandles(
    void
    ) 
{
    if (gfDrsRpcFreeHandleListInitialized) { 
        
        // this is the only deletion task on the queue, so we
        // don't need to hold the critsec to check IsListEmpty 
        while (!IsListEmpty(&gDrsRpcFreeHandleList)) {
            PLIST_ENTRY listEntry = NULL;
            DRS_HANDLE_LIST_ELEM * phFreeHandle = NULL;
            ULONG rpcstatus = 0; 

	    // release the critsec before going off machine
	    EnterCriticalSection(&gcsDrsRpcFreeHandleList);
	    __try {
		listEntry = RemoveHeadList(&gDrsRpcFreeHandleList);
		gcNumDrsRpcFreeHandleListEntries--;
		phFreeHandle = CONTAINING_RECORD(listEntry,DRS_HANDLE_LIST_ELEM,ListEntry); 
	    }
	    __finally {
		LeaveCriticalSection(&gcsDrsRpcFreeHandleList);
	    }

            // free the context handle (do the rpc call to unbind)
            DRSFreeContextHandle(phFreeHandle->pszServerName, &phFreeHandle->hDrs);
            free(phFreeHandle->pszServerName);
            free(phFreeHandle); 
        }
    }
}

void DRSClientCacheUninit(
    void
    )
{
    ULONG i;

    if (gfIsDrsClientLibInitialized) {

        // Reject any new callers.
        gfIsDrsClientLibInitialized = FALSE;

        // Release references to all cached binding handles.  Free each of them
        // if no one else claims a reference.
        EnterCriticalSection(&csBHCache);
        __try
        {
            for (i=0; i < BHCacheSize; i++)
            {
                VALIDATE_BH_ENTRY(i);

                if (    ( NULL != rgBHCache[i].hDrs )
    		     && ( rgBHCache[i].fDontUse == FALSE ) // make sure it's not already expired
                     && ( 0 == --rgBHCache[i].cRefs )
                   )
                {    
                    Assert(eServiceShutdown || DsaIsSingleUserMode());
                    // DRSFreeContextHandles does not go off machine while
                    // eServiceShutdown is true.
                    DRSFreeContextHandle(rgBHCache[i].pszServer,
                                         &rgBHCache[i].hDrs);
              
                    free(rgBHCache[i].pszServer);
                    if (rgBHCache[i].pszServerPrincName) {
                        free(rgBHCache[i].pszServerPrincName);
                    }
                    memset(&rgBHCache[i], 0, sizeof(rgBHCache[i]));
                }
            }
        }
        __finally
        {
            LeaveCriticalSection(&csBHCache);
        }
    }
}


ULONG
UlBHCacheHash(
    IN  LPWSTR  szServer
    )
{
    ULONG ulHashVal = 0;
    ULONG key = 0x0a1;

    while (*szServer)
    {
        ULONG hash1 = ((ulHashVal << 4) ^ *szServer);
        ULONG hash2 = ((ulHashVal & 0x80) ? key : 0);
        ULONG hash3 = ((ulHashVal & 0x40) ? key << 1 : 0);
        ULONG hash4 = ((ulHashVal & 0x20) ? key << 2 : 0);
        ULONG hash5 = ((ulHashVal & 0x10) ? key << 3 : 0);
        ulHashVal = hash1 ^ hash2 ^ hash3 ^ hash4 ^ hash5;
        szServer++;
    }

    ulHashVal %= BHCacheSize;
    return ulHashVal;
}


void
BHCacheDecRef(
    IN OUT  BHCacheElement *  pEntry
    )
/*++

Routine Description:

    Decrease the refcount of an entry in the handle cache.  If the refcount
    drops to zero, free the entry.

Arguments:

    pEntry (IN/OUT) - Entry for which to decrement the refcount.

Return Values:

    None.

--*/
{
    Assert(OWN_CRIT_SEC(csBHCache));
    Assert((BYTE *)pEntry >= (BYTE *)rgBHCache);
    Assert((BYTE *)pEntry < (BYTE *)rgBHCache + sizeof(rgBHCache));

    pEntry->cRefs -= 1;

    if (0 == pEntry->cRefs) {
        DRSInsertFreeHandleQueue(pEntry->pszServer, pEntry->hDrs);
        free(pEntry->pszServer);
        if (pEntry->pszServerPrincName) {
            free(pEntry->pszServerPrincName);
        }
        memset(pEntry, 0, sizeof(*pEntry));
    }
    else {
        // Update "last used" timestamp.
        pEntry->cTickLastUsed = GetTickCount(); 
    }
}

void
BHCacheFreeContext(
    IN      LPWSTR       szServer,
    IN OUT  DRS_HANDLE * pHandle
    )
{
    ULONG i;

    i = UlBHCacheHash(szServer);

    EnterCriticalSection(&csBHCache);
    __try
    {
        VALIDATE_BH_ENTRY(i);

        // The server name should match.
        Assert(    ( NULL != rgBHCache[i].pszServer )
                && !_wcsicmp( rgBHCache[i].pszServer, szServer )
              );

        // And the pointer to the context handle passed in by the caller must
        // not point to the handle in the cache -- otherwise we'll zero it
        // out below (in RpcSsDestroyClientContext), even if it still has a positive refcount.
        Assert(&rgBHCache[i].hDrs != pHandle);


        // Make sure it's our server.
        if (    ( NULL != rgBHCache[i].pszServer )
             && !_wcsicmp( rgBHCache[i].pszServer, szServer )
           )
        {
            // unlock the handle ( if it was locked )
            rgBHCache[i].fLocked = FALSE; 
            BHCacheDecRef(&rgBHCache[i]);
        } 

	Assert(pHandle);
	if (pHandle!=NULL) {
	    RpcSsDestroyClientContext(pHandle);	
	}
    }
    __finally
    {
        LeaveCriticalSection(&csBHCache);
    }
}

void BHCacheVoidServer(
    IN  LPWSTR      szServer
    )
{
    ULONG i;

    i = UlBHCacheHash(szServer);

    EnterCriticalSection(&csBHCache);
    __try
    {
        VALIDATE_BH_ENTRY(i);
        if (    ( NULL != rgBHCache[i].pszServer )
             && !_wcsicmp(rgBHCache[i].pszServer, szServer)
             && !rgBHCache[i].fDontUse )
        {
            // Set fDontUse flag.  This will stop entry from being handed
            // out and insure that it is nuked after the last deref.
            rgBHCache[i].fDontUse = TRUE;

            // Deref the entry's self-reference.
            BHCacheDecRef(&rgBHCache[i]);
        }
    }
    __finally
    {
        LeaveCriticalSection(&csBHCache);
    }
}

// Helper to copy (possibly NULL) source extensions to
// destination extensions.

VOID
CopyExtensions(
    DRS_EXTENSIONS *pextSrc,
    DRS_EXTENSIONS *pextDst)
{
    // We assume destination extensions are allocated to hold at least
    // CURR_MAX_DRS_EXT_FIELD_LEN bytes in their rgb field (i.e., that the
    // extensions *structure* is at least CURR_MAX_DRS_EXT_STRUCT_SIZE bytes).

    DWORD cb;

    if ( NULL == pextSrc )
    {
        pextDst->cb = 0;
    }
    else
    {
        // If we've never heard of an extension, we're not going
        // to ask about it, so cut the stream to fit our buffer
        // size (eliminating the need to dynamically allocate
        // extension buffers).

        pextDst->cb = min(pextSrc->cb, CURR_MAX_DRS_EXT_FIELD_LEN);
        memcpy(pextDst->rgb, pextSrc->rgb, pextDst->cb);
    }
}

//
// Flags for BHCacheGetDrsContext
//

#define BHCACHE_FLAGS_LOCK_HANDLE (1)

BOOL
BHCacheGetDrsContext(
    IN  THSTATE *         pTHS,
    IN  DRS_EXTENSIONS *  pextCurrentLocal,
    IN  LPWSTR            pszServer,
    IN  LPWSTR            pszDomain,
    IN  ULONG             flags,
    OUT DRS_HANDLE *      phDrs,
    OUT DRS_EXTENSIONS *  pextRemote
    )
/*++

Routine Description:

    Retrieve the DRS context handle and extensions associated with a given
    server from the cache, if an appropriate cache entry is available.

Arguments:

    pTHS -
    pextCurrentLocal - the local server extensions
    pszServer (IN) - name of the server for which to retrieve handle/extensions.
    pszDomain - the domain name of the server/spn which to retrieve handle/extensions.
    flags (IN) Controls operation of the routine. Defined flags are as follows

                  BHCACHE_FLAGS_LOCK_HANDLE -- Indicates that the handle be locked
                                               before returning. If this flag is
                                               specified then this routine will
                                               only return handles with a ref count
                                               of 1 after setting the locked flags

    phDrs (OUT) - on successful return, holds the associated context handle.
    pextRemote (OUT) - on successful return, holds the associated server extensions.

Return Values:

    TRUE - success.
    FALSE - no cache entry exists for this server.

--*/
{
    BOOL fSuccess = FALSE;
    int  i;
    ULONG rpcstatus = RPC_S_OK;
    LPWSTR pszCachedDomain = NULL;

    Assert((NULL != pszServer) && (NULL != phDrs) && (NULL != pextRemote));

    i = UlBHCacheHash(pszServer);

    EnterCriticalSection(&csBHCache);
    __try {
        VALIDATE_BH_ENTRY(i);

        // Do we have a cached handle to *this* server which
        // can be returned - i.e. is not flagged for expiry?

        if (    (NULL != rgBHCache[i].pszServer)
             && !_wcsicmp(pszServer, rgBHCache[i].pszServer)
             && (!rgBHCache[i].fDontUse)
             && (!rgBHCache[i].fLocked)
             && ((1==rgBHCache[i].cRefs) || (!(flags & BHCACHE_FLAGS_LOCK_HANDLE)))){
            if ((pextCurrentLocal->cb != rgBHCache[i].extLocal.cb)
                  || (0 != memcmp(pextCurrentLocal->rgb,
                                  rgBHCache[i].extLocal.rgb,
                                  pextCurrentLocal->cb))) {
                // Our DRS extensions have changed since we bound to this remote
                // DSA.  Unbind and rebind so we can inform the remote DSA of
                // our latest extensions.
                
                DPRINT1(0, "Forcing rebind to %ls because our DRS_EXTENSIONS have changed.\n",
                        rgBHCache[i].pszServer);
            
                // Set fDontUse flag.  This will stop entry from being handed
                // out and ensure that it is nuked after the last deref.
                rgBHCache[i].fDontUse = TRUE;
    
                // Deref the entry's self-reference.
                BHCacheDecRef(&rgBHCache[i]);

                Assert(!fSuccess);
            
            } else if (
                       (pszDomain!=NULL) &&
                       ((!IS_DOMAIN_QUALIFIED_SPN(rgBHCache[i].pszServerPrincName)) || 
                        ((IS_DOMAIN_QUALIFIED_SPN(rgBHCache[i].pszServerPrincName)) &&
                         (pszCachedDomain = GET_DOMAIN_FROM_QUALIFIED_SPN(rgBHCache[i].pszServerPrincName)) &&
                         (_wcsicmp(pszCachedDomain, pszDomain))))
                       )
                {  
                // We have been requested to bind with an SPN which has pszDomain as the domain
                // suffix but the cached info has a different suffix.  Since there exists cached info
                // it succeeded in binding with the cached domain - which implies that the domain
                // of the source server is the cached domain.  This would seem to be a security risk
                // as the source server is in domain A but we are requesting a server who's SPN 
                // assumes that the server is in domain B.  Either the DC has two writable domains, or
                // the user is calling ReplicateSingleObject on an object in a different domain.  Either 
                // way, the resolution should be failed.  In case of error, since this shouldn't be a
                // commonly occuring code path, rebind the handle.
            
                LogEvent(DS_EVENT_CAT_REPLICATION,
                         DS_EVENT_SEV_ALWAYS,
                         DIRLOG_DRA_UNAUTHORIZED_NC,
                         szInsertWC(rgBHCache[i].pszServer),
                         szInsertWC(pszDomain),
                         NULL );        

                // Set fDontUse flag.  This will stop entry from being handed
                // out and ensure that it is nuked after the last deref.
                rgBHCache[i].fDontUse = TRUE;
    
                // Deref the entry's self-reference.
                BHCacheDecRef(&rgBHCache[i]);

                Assert(!fSuccess);
            } else {

                // Return a copy of the cached handle.  We don't return
                // a pointer to the handle itself so that we can set
                // per handle variables, such as time to cancel.  IE
                // if we returned a pointer to the cached handle, all
                // calls using this handle, no matter with what purpose
                // would have the same time to cancel.  This function
                // has been overloaded to copy context handles, but 
                // RpcBindingFree has not been, so this is freed with
                // RpcSsDestroyClientContext
                rpcstatus = RpcBindingCopy(rgBHCache[i].hDrs, phDrs);  
                if (rpcstatus != RPC_S_OK) {
                    fSuccess = FALSE; 
                    __leave;
                }
                CopyExtensions(&rgBHCache[i].extRemote, pextRemote);
                rgBHCache[i].cRefs += 1;
                if (flags & BHCACHE_FLAGS_LOCK_HANDLE) {
                    rgBHCache[i].fLocked = TRUE;
                }

                fSuccess = TRUE;
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csBHCache);
    }

    return fSuccess;
}


BOOL
findDomainNcFast(
    THSTATE *pTHS,
    DBPOS *pDBTmp,
    LPWSTR *ppszDomainNcName
    )

/*++

Routine Description:

Helper routine to extract the domain guid.  This routine uses two methods to
obtain the name of the domain associated with the current NTDSA object.
1. First we try to read the msds-hasdomainncs attribute. This will not be set on
w2k dcs and dc's upgraded from .net betas.
2. It tries to obtain the domain from the masterNC list.  This may not always work
if the list does not have the expected contents.

We expect the "old" hasMasterNcs list to have three items: schema nc, config nc
and the domain nc.  Match the schema and config nc's by guid to eliminate them,
and we are left with the domain nc.  This could legitimately fail if:
1. "old" hasMasterNCs not populated during install scenarios for some reason
2. Due to exchange compatibility requirements, the "old" hasMasterNCs will only
   ever have 3 NCs.

Expect we are positioned on a NTDSA object

Arguments:

    pDBTmp -
    puuidDomain -

Return Value:

    BOOL - Whether the masterNC list was in expected form.  It may not be
    and this is not an error.
    Exceptions raised for errors.

--*/

{
    BOOL fFound = FALSE, fSeenSchema = FALSE, fSeenConfig = FALSE;
    ULONG NthValIndex = 0;
    ULONG len, nameLength;
    DSNAME *pNC = NULL;

    Assert(pTHS->JetCache.transLevel > 0);

    // See if we have a domain nc link we can take advantage of
    if (!(DBGetAttVal(pDBTmp,
                      1,
                      ATT_MS_DS_HAS_DOMAIN_NCS,
                      0,
                      0, &len, (PUCHAR *)&pNC))) {
        // FUTURE-2002/03/21-BrettSh - Why doesn't this code just return the DSNAME?
        nameLength = wcslen( pNC->StringName ) + 1;
        *ppszDomainNcName = THAllocEx( pTHS, nameLength * sizeof(WCHAR) );
        wcscpy( *ppszDomainNcName, pNC->StringName );
        DPRINT1( 2, "Using msds-hasdomainncs to calculate domain %ws\n", pNC->StringName );
        THFree( pNC );
        return TRUE;
    }

    // Loop through the hasMasterNCs list
    while (!(DBGetAttVal(pDBTmp,
                         ++NthValIndex,
                         GetRightHasMasterNCsAttr(pDBTmp),
                         0,
                         0, &len, (PUCHAR *)&pNC))) {

        // Config NC
        if ( 0 == memcmp( &(pNC->Guid), &(gAnchor.pConfigDN->Guid), sizeof( UUID ) ) ) {
            Assert( !fSeenConfig );
            fSeenConfig = TRUE;
            DPRINT1( 2, "dnConfig = %ws\n", pNC->StringName );
            THFree( pNC );
            continue;
        }

        // Schema NC
        if ( 0 == memcmp( &(pNC->Guid), &(gAnchor.pDMD->Guid), sizeof( UUID ) ) ) {
            Assert( !fSeenSchema );
            fSeenSchema = TRUE;
            DPRINT1( 2, "dnSchema = %ws\n", pNC->StringName );
            THFree( pNC );
            continue;
        }

        // Its a domain NC.  In the future, may be more than one
        // ISSUE-2001/01/19-JeffParh - Should bail early (and free string) if
        // we've already seen one non-config/schema NC.
        nameLength = wcslen( pNC->StringName ) + 1;
        *ppszDomainNcName = THAllocEx( pTHS, nameLength * sizeof(WCHAR) );
        wcscpy( *ppszDomainNcName, pNC->StringName );
        DPRINT1( 2, "dnDomain = %ws\n", pNC->StringName );
        THFree( pNC );
    }

    // Must only be three NCs in the list, and have a schema and config nc
    if ( (4 == NthValIndex) && fSeenSchema && fSeenConfig ) {
        fFound = TRUE;
    }

    // This may not be true if the server has its domain nc removed, for example
    // by deleting its cross-ref object, or if the ntdsDsa object itself has been
    // deleted (in which case it has no ATT_HAS_MASTER_NCS or ATT_MS_DS_HAS_MASTER_NCS).

    return fFound;
} /* findDomainNcFast */


VOID
findDomainNcGeneral(
    THSTATE *pTHS,
    DBPOS *pDBTmp,
    LPWSTR *ppszDomainNcName
    )

/*++

Routine Description:

Helper routine to extract the domain NC name.  This algorithm will work
regardless of the number of master NC's a server may host.

Assumed pDBTmp is positioned on the server object, which is valid and
present.

Arguments:

    pDBTmp -
    puuidDomain -

Return Value:

   None.
   Exceptions raised on error

--*/

{
    DWORD dbErr;
    DSNAME *pdnComputer = NULL;
    COMMARG commArg;
    CROSS_REF * pCR;
    DWORD cb, nameLength;

    __try {

        // Get the computer dn
        dbErr = DBGetAttVal(pDBTmp, 1, ATT_SERVER_REFERENCE,
                         0, 0, &cb, (BYTE **) &pdnComputer);
        if (dbErr) {
            DPRINT1(0, "Can't find server reference, db error %d.\n", dbErr);
            
            // Server object (parent of NTDS Settings) lacks a server reference
            // attribute.  This might occur if the server object had been
            // deleted, for example, or if the server reference has not yet been
            // written,
            DRA_EXCEPT(ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF, dbErr);
        }

        DPRINT1( 2, "dnComputer = %ws\n", pdnComputer->StringName );

        // If the server reference contains mangled components, it is not a useful
        // or valid input to FindBestCrossRef. Don't even try.
        // This check is to help diagnose cases where the server reference is mangled.
        // If we did not make this check, FindBestCrossRef might return a parent
        // cross-ref, resulting in an valid but wrong SPN being generated.  The user
        // would see this as wrong account name when A calls B, and not know to check
        // the server reference attribute for B on A.

        if (IsMangledDSNAME(pdnComputer, NULL)) {
            DRA_EXCEPT(ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN, dbErr);
        }

        // Find the naming context of the computer
        // This could be a phantom on this machine if we don't hold nc
        memset( &commArg, 0, sizeof( COMMARG ) );  // not used
        pCR = FindBestCrossRef( pdnComputer, &commArg );
        if (NULL == pCR) {
            DPRINT1(0, "Can't find cross ref for %ws.\n",
                    pdnComputer->StringName );
            DRA_EXCEPT(ERROR_DS_NO_CROSSREF_FOR_NC, DRAERR_InternalError);
        }

        nameLength = wcslen( pCR->pNC->StringName ) + 1;
        *ppszDomainNcName = THAllocEx( pTHS, nameLength * sizeof(WCHAR) );
        wcscpy( *ppszDomainNcName, pCR->pNC->StringName );

        DPRINT1( 2, "NC = %ws\n", pCR->pNC->StringName );

    } _finally {

        if (NULL != pdnComputer) {
            THFree(pdnComputer);
        }
    }

} /* findDomainNcGeneral */


VOID
findDnsHostDomainNames(
    THSTATE *pTHS,
    UUID *pguidNtdsaObject,
    LPWSTR *ppszDnsDomainName
    )

/*++

Routine Description:

Given the guid of an NTDS DSA object, calculate the dns hostname and the
dns domain name.

The hostname comes from the ATT_DNS_HOST_NAME attribute on the parent object, which
is the server object.

The dns domain name comes by
1. Determining the domain nc that the server is in
2. Converting the domain nc to a dns domain name

Arguments:

    pTHS -
    pguidNtdsaObject - guid of ntdsa object
    ppszDnsDomainName - pointer to pointer to receive dns domain name

Return Value:

    VOID - raises exceptions

--*/

{
    DWORD cb, dbErr, status, length;
    DBPOS *pDBTmp = NULL;
    DSNAME dnNtdsaByGuid = {0};
    BOOL fDomainFound;
    LPWSTR pszDomainNC = NULL;
    PDS_NAME_RESULTW pResult = NULL;

#ifdef INCLUDE_UNIT_TESTS
    Assert( !pTHS->pDB && "should not have a primary dbpos open across an rpc call" );
#endif

    Assert( pguidNtdsaObject );

    // Create a dsname with just the server's guid in it
    dnNtdsaByGuid.structLen = sizeof(dnNtdsaByGuid);
    dnNtdsaByGuid.Guid = *pguidNtdsaObject;

    // Use another DBPOS so not as to disturb callers thread db state
    DBOpen (&pDBTmp);
    __try {
        // Look up the server's NTDSA object
        dbErr = DBFindDSName(pDBTmp, &dnNtdsaByGuid);
        if (dbErr)
        {
            DPRINT1( 0, "DbFindDsName(guid) failed with db err %d\n", dbErr );
            DRA_EXCEPT(ERROR_DS_CANT_FIND_DSA_OBJ, dbErr);
        }

        //
        // Find the domain name
        //

        fDomainFound = findDomainNcFast( pTHS, pDBTmp, &pszDomainNC );
        if (!fDomainFound) {
            // If we failed to find the fast way, try the general way
            // Reposition to parent (server obj) if needed
            DBFindDNT( pDBTmp, pDBTmp->PDNT );
            findDomainNcGeneral( pTHS, pDBTmp, &pszDomainNC );
        }

        // Convert the NC to a DNS name

        status = DsCrackNamesW (
            NULL,
            DS_NAME_FLAG_SYNTACTICAL_ONLY,
            DS_FQDN_1779_NAME,
            DS_CANONICAL_NAME_EX,
            1,
            &pszDomainNC,
            &pResult);
        if (status != ERROR_SUCCESS) {
            DPRINT1( 0, "DsCrackNamesW failed, error %d\n", status );
            DRA_EXCEPT(ERROR_DS_BAD_NAME_SYNTAX, status);
        }
        if ( (pResult->cItems != 1) ||
             ( (pResult->rItems[0].status != DS_NAME_NO_ERROR) &&
               (pResult->rItems[0].status != DS_NAME_ERROR_DOMAIN_ONLY) ) ) {
            DPRINT1( 0, "DsCrackNamesW returned unexpected results %d\n",
                     pResult->rItems[0].status );
            // ERROR: domain is in wrong form, can't crack
            DRA_EXCEPT(ERROR_DS_BAD_NAME_SYNTAX, status);
        }

        // Copy out the domain name
        length = wcslen( pResult->rItems[0].pDomain ) + 1;
        *ppszDnsDomainName = THAllocEx( pTHS, length * sizeof(WCHAR) );
        wcscpy( *ppszDnsDomainName, pResult->rItems[0].pDomain );
        DPRINT1( 2, "dnsDomain = %ws\n", *ppszDnsDomainName );

    } _finally {
        if (pDBTmp) {
            DBClose (pDBTmp, !AbnormalTermination());
        }
        if (pszDomainNC) {
            THFreeEx(pTHS, pszDomainNC);
        }
        if (pResult) {
            DsFreeNameResultW( pResult );
        }
    }
} /* findDnsHostDomainNames */


BOOL
DRSMakeFQDnsName(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    OUT LPWSTR *    ppszFQDnsName
    )
/*++

Routine Description:

    Converts a non-qualified DNS name (e.g., L"172.31.238.167") to a fully
    qualified DNS name (e.g., L"ntdsdc0.ntdev.microsoft.com").

Arguments:

    pszServerName (IN) - server name to convert.

    ppszFQDnsName (OUT) - On successful return, holds the fully qualified
        DNS name of the server.  Optional.

Return Values:

    TRUE - success.
    FALSE - failure.

--*/
{
    BOOL              fSuccess = FALSE;
    LPSTR             paszServerName;
    struct hostent *  pHostEntry = NULL;

    paszServerName = String8FromUnicodeString(TRUE, CP_ACP, pszServerName, -1,
                                              NULL, NULL);
    Assert(NULL != paszServerName);
    Assert('\0' != *paszServerName);

    pHostEntry = gethostbyname(paszServerName);
    if (pHostEntry) {
        if (ppszFQDnsName) {
            *ppszFQDnsName = UnicodeStringFromString8(CP_ACP,
                                                      pHostEntry->h_name, -1);
            Assert(NULL != *ppszFQDnsName);
            Assert(L'\0' != **ppszFQDnsName);
        }

        fSuccess = TRUE;
    }

    THFreeEx(pTHS, paszServerName);

    return fSuccess;
}


DWORD
DRSMakeOneWaySpn(
    IN  THSTATE *           pTHS,
    IN  LPWSTR              pszTargetServerName,
    IN  RPC_BINDING_HANDLE  hServer,
    OUT LPWSTR *            ppszSpn
    )

/*++

Routine Description:

Create a one-way authentication SPN.  This is done by asking the server what name
he would like us to use.  Not very secure this way.

Arguments:

    pTHS - Thread state
    pszTargetServerName - Name of target server
    hServer - RPC binding handle to target server
    ppszSpn - pointer to pointer, to receive pointer to allocated string

Return Value:

    DWORD -

--*/

{
    DWORD status, length;
    LPWSTR pszRpcSpn = NULL, pszSpnTemp;

    DPRINT1( 0, "Rpc Handle to %ls is using one-way authentication.\n",
             pszTargetServerName );

    status = RpcMgmtInqServerPrincNameW(hServer,
                                        RPC_C_AUTHN_GSS_KERBEROS,
                                        &pszRpcSpn);

    Assert((status != RPC_S_BINDING_INCOMPLETE)
           && "Contact RPC dev -- this shouldn't be returned by"
           "RpcMgmtInqServerPrincName().");

    if (RPC_S_OK != status) {
        DPRINT1(0, "RpcMgmtInqServerPrincName failed with %d\n", status);
        return status;
    }

    Assert( pszRpcSpn && wcslen(pszRpcSpn) );

    // Spn is expected to returned from malloc heap - reallocate
    length = wcslen( pszRpcSpn ) + 1;
    pszSpnTemp = malloc(length * sizeof(WCHAR));
    if (NULL == pszSpnTemp) {
        status = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        wcscpy(pszSpnTemp, pszRpcSpn);
        *ppszSpn = pszSpnTemp;
    }

    RpcStringFreeW(&pszRpcSpn);

    return status;
} /* DRSMakeOneWaySpn */


DWORD
DRSMakeMutualAuthSpn(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszTargetServerName,
    IN  LPWSTR      pszTargetDomainName,    OPTIONAL
    OUT LPWSTR *    ppszSpn
    )
/*++

Routine Description:

   Construct a SPN for use in communicating with the desired server.

   The SPN's which the server is expecting are written in
   dsamain\src\servinfo.c

   According to the SPN specification by Paulle, client side replication spns
   are as follows:

   DCGUID = guid of the host server DC
   DDNS = fully qualified DNS name of domain of the host server DC

   Form the SPN "E3514235-4B06-11D1-AB04-00C04FC2DCD2/DCGUID/DDNS". (The GUID
   is that of the replication RPC interface.) This is what is written to the
   servicePrincipalName attribute of the DCs account object

   A replication client adds "@DDNS" to the above SPN to pass in to the
   pszTargetName parameter of InitializeSecurityContext or the ServerPrincName
   parameter of RpcBndingSetAuthInfo. The reason for the "@DDNS" is so that
   the KDC does not try and look the SPN up in the GC, which we don't want to
   do because the GC depends on replication, so we'd have a circular
   dependency.  The "@DDNS" does not get written to the servicePrincipalName
   attribute.

Arguments:

    pTHS (IN)
    pszTargetServerName (IN) - dns name of server to be called
    pszTargetDomainName (IN, OPTIONAL) - dns name of domain for which the target
        server is a DC
    ppszSpn (OUT) - receives pointer to buffer to new spn

    A note on variable usage:

    pszTargetServerName - incoming server name, never modified
    pszServiceName - The domain name part of the spn. This is a pointer to
           whatever storage we decide to use. Never freed itself.
    pszInstanceName - The host name part of the spn. This is a pointer to
           whatever storage we decide to use. Never freed itself.
    pszSpn - actual spn to be returned to the user. Only freed on error.
    pszTemp, pszDnsHostName, pszDnsDomainName - temporary internal allocations
            Always freed on exit.

Return Value:

    DWORD - win32 status

--*/
{
    DWORD status, length, nameLength;
    LPWSTR pszServiceName, pszInstanceName, pszClassName;
    WCHAR szServerUuid[SZGUIDLEN + 1];
    UUID uuidServer, uuidDomain;
    BOOL fGuidBasedName = FALSE;
    LPWSTR pszSpn = NULL, pszTemp = NULL;
    LPWSTR pszDnsHostName = NULL, pszDnsDomainName = NULL;

    DPRINT1( 1, "DRSMakeSpn: server = %ls\n", pszTargetServerName );

    Assert( pszTargetServerName );
    Assert( ppszSpn );

    // Start with the name we are given
    pszInstanceName = pszTargetServerName;

    // Name transformations

    // Treat netbios names like dns names, remove \\ prefix
    if (*pszInstanceName == L'\\') {
        pszInstanceName++;
        if (*pszInstanceName == L'\\') {
            pszInstanceName++;
        }
    }

    // If server name has trailing '.', make a copy and remove it
    nameLength = wcslen( pszInstanceName );
    Assert( nameLength );
    if (pszInstanceName[nameLength - 1] == L'.') {
        pszTemp = THAllocEx(pTHS, nameLength * sizeof(WCHAR));
        nameLength--;
        wcsncpy(pszTemp, pszInstanceName, nameLength);
        pszTemp[nameLength] = L'\0';
        pszInstanceName = pszTemp;
    }

    // Determine what kind of name this.

    fGuidBasedName = DSAGuidFromGuidDNSName(pszInstanceName, NULL, szServerUuid, TRUE);

    if (fGuidBasedName) {
        // GUID-based DNS name.
        //
        // SPN = drs idl guid / ntdsa-guid / domain @ domain
        //

        // If caller supplied GUID-based DNS name and target domain name, then
        // use the target domain name in the SPN to ensure the resolution of the
        // SPN is done in the given domain.  Else do the resolution in the 
        // domain of the server who's spn we are creating.
        if (pszTargetDomainName!=NULL) {
            pszClassName = DRS_IDL_UUID_W;
            pszInstanceName = szServerUuid;
            pszServiceName = pszTargetDomainName; 
        } else {
            DWORD rpcErr = RPC_S_OK;
            rpcErr = UuidFromStringW(szServerUuid, &uuidServer);
            // since IsGuidBasedName returned true, this function will succeed.
            Assert(rpcErr==RPC_S_OK);

            __try {
                findDnsHostDomainNames( pTHS,
                                        &uuidServer,
                                        &pszDnsDomainName );
                status = ERROR_SUCCESS;
            } __except (GetDraException((GetExceptionInformation()), &status)) {
                ;
            }
            if (status != ERROR_SUCCESS) {
                goto cleanup;
            }

            pszClassName = DRS_IDL_UUID_W;
            pszInstanceName = szServerUuid;
            pszServiceName = pszDnsDomainName;
            pszTargetDomainName = pszDnsDomainName; 
        }
    } else {
        // HOST-based DNS name
        //
        // SPN = GC / Hostname / forest (aka Root DNS name )
        //
        pszClassName = GCSpnType;
        // pszInstanceName already set to incoming target host name
        pszServiceName = gAnchor.pwszRootDomainDnsName;
        // pszTargetDomainName is set if present
    }

    // Construct host-based replication SPN
    // Note, malloc is used to allocate the principal name because it is stored
    // in the binding cache and must outlast the current thread.

    Assert( pszInstanceName );
    Assert( pszServiceName );

    length = SZGUIDLEN + 1 +
        wcslen( pszInstanceName ) + 1 +
        wcslen( pszServiceName ) + 1 +
        (pszTargetDomainName ? wcslen( pszTargetDomainName ) : 0) + 1;

    pszSpn = (LPWSTR) malloc(length * sizeof(WCHAR));
    if (NULL == pszSpn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    status = DsMakeSpnW( pszClassName,
                         pszServiceName,
                         pszInstanceName,
                         0,
                         NULL,
                         &length,
                         pszSpn );
    if (status != ERROR_SUCCESS) {
        DPRINT1( 0, "DsMakeSpn failed with status %d\n", status );
        goto cleanup;
    }

    // If we have a target domain name, use it
    // The @ form is needed when making a call to the GC
    if (pszTargetDomainName) {
        wcscat( pszSpn, L"@" );
        wcscat( pszSpn, pszTargetDomainName );
    }


    DPRINT2( 1, "DRSMakeSpn: server=%ws, new SPN = %ls\n",
             pszTargetServerName, pszSpn );

    *ppszSpn = pszSpn;
    pszSpn = NULL; // don't clean up

    // fall through for cleanup of temporaries

cleanup:
    if (pszSpn) {
        free( pszSpn );
    }
    if (pszTemp) {
        THFreeEx(pTHS, pszTemp);
    }
    if (pszDnsHostName) {
        THFreeEx(pTHS, pszDnsHostName);
    }
    if (pszDnsDomainName) {
        THFreeEx(pTHS, pszDnsDomainName);
    }

    return status;
} /* DRSMakeSpn */

RPC_STATUS
DRSGetRpcBinding(
    IN  THSTATE *             pTHS,
    IN  LPWSTR                pszServer,
    IN  LPWSTR                pszDomain,            OPTIONAL
    IN  BOOL                  fUseMutualAuthSpn,
    IN  BOOL                  fUseUniqueAssoc,
    OUT RPC_BINDING_HANDLE *  prpc_handle,
    OUT LPWSTR *              ppszServerPrincName
    )
/*++

Description:

    Generate a new RPC_BINDING_HANDLE for the given server.

Arguments:

    pTHS (IN)

    pszServer (IN) - server of interest.

    pszDomain (IN, OPTIONAL) - DNS domain name of server.
    
    fUseMutualAuthSpn - Sort of what it sounds like, but the actual Mutual Auth 
        protocol is used irrespective of this input, but if FALSE, then we
        query the remote machine for what SPN should be used and then the protocol
        validates that.
        
    fUseUniqueAssoc - Whether or not to use a unique RPC Association for the binding.
        Used to ensure refreshed security context information.  
        see drsIsCallComplete for details.   

    prpc_handle (OUT) - on success, holds a pointer to RPC_BINDING_HANDLE for
        szServer.

    ppszServerPrincName (IN/OUT) on success, holds a pointer to the server
        principal name as returned by RpcMgmtInqServerPrincName.  Should be
        freed via RpcStringFree.

Return value:

    RPC_STATUS - Win32 error code

--*/
{
    RPC_IF_HANDLE               IfHandle = _drsuapi_ClientIfHandle;
    RPC_STATUS                  status;
    ULONG                       DrsError;
    PSEC_WINNT_AUTH_IDENTITY_W  Credentials = NULL;
    LPWSTR                      pszStringBinding = NULL;
    LPWSTR                      pszAddress;
    WCHAR                       pszIpAddress[IPADDRSTR_SIZE];
    BOOL                        fFallback = FALSE;
    RPC_SECURITY_QOS            RpcSecQOS;

    Assert(NULL != pszServer);
    Assert(NULL != prpc_handle);
    Assert(NULL != ppszServerPrincName);

    *ppszServerPrincName = NULL;
    *prpc_handle = NULL;

    __try {
        status = DrspGetCredentials(&Credentials);
        if (0 != status) {
            // This function should only fail on resource allocation failures.
            DPRINT1(0, "DRSGetRpcBinding: DrspGetCredentials failed (%d)\n", status);
            __leave;
        }

        // Strip leading backslashes.
        for (pszAddress = pszServer; L'\\' == *pszAddress; pszAddress++) {
            ;
        }

        if (IsOurGuidAddr(pszAddress)) {
            status = GetIpAddrByDnsNameW(L"localhost", pszIpAddress);
            Assert(status == 0); // Can we fail when we lookup localhost?
        } else {
            status = GetIpAddrByDnsNameW(pszAddress, pszIpAddress);
        }

        if(status){
            LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
                      DS_EVENT_SEV_MINIMAL,
                      DIRLOG_DS_DNS_HOST_RESOLUTION_FAILED,
                      szInsertWC(pszAddress),
                      szInsertWin32Msg(status),
                      szInsertWin32ErrCode(status),
                      NULL, NULL, NULL, NULL, NULL );

            DPRINT2(1, "DRSGetRpcBinding: GetIpAddrByDnsNameW() failed to resolve hostname %ws Winsock failed with %d\n",
                    pszAddress, status);
            
            status = ERROR_DS_DNS_LOOKUP_FAILURE;
            __leave;
        }

        status = RpcStringBindingComposeW(0,
                                          L"ncacn_ip_tcp",
                                          pszIpAddress,
                                          NULL,
                                          0,
                                          &pszStringBinding);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcStringBindingComposeW failed (%d)\n",
                    status);
            __leave;
        }

        status = RpcBindingFromStringBindingW(pszStringBinding, prpc_handle);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcBindingFromStringBindingW failed (%d)\n",
                    status);
            __leave;
        }

        Assert(NULL != *prpc_handle);

        // if we want a unique association, we have to call it now, before we fully bind
        // the handle.
        if (fUseUniqueAssoc) {
            status = RpcBindingSetOption(*prpc_handle, RPC_C_OPT_UNIQUE_BINDING, 1);  
            if (status!=RPC_S_OK) {
                Assert(!"Unable to set option RPC_C_OPT_UNIQUE_BINDING");
                LogUnhandledError(status);
                __leave;
            }
        }

        // Binding handle created successfully.  Resolve the partially bound
        // handle into a fully bound handle.
        status = RpcEpResolveBinding(*prpc_handle, IfHandle);
        if (RPC_S_OK != status) {
            DPRINT1(1, "DRSGetRpcBinding: RpcEpResolveBinding failed (%d)\n",
                    status);
            __leave;
        }

        // Make mutual auth spn if requested.
        // There are two types of fallback here: construction time and bind time.
        // If we fail to construct the spn for an expected reason, construct a one-
        // way spn.  If we construct ok, but fail to bind, this routine gets called
        // again with the fUseMutual flag false, at which we build a one-way spn.
        if (fUseMutualAuthSpn) {
            //
            // Caller wants a mutual authenticated binding
            //
            status = DRSMakeMutualAuthSpn(pTHS, pszAddress, pszDomain,
                                          ppszServerPrincName);
            if (status) {
                if ((0 == GetConfigParam(DRA_SPN_FALLBACK, &fFallback, sizeof(BOOL)))
                    && fFallback) {
                    // We've been configured to allow fallback to one-way auth
                    // if we fail to construct a mutual-auth SPN.
                    DPRINT2(0, "Handling error %d by falling back to one-way auth for %ws.\n",
                            status, pszAddress);
                    status = DRSMakeOneWaySpn( pTHS,pszAddress,*prpc_handle,ppszServerPrincName );  
                } else {
                    LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
                              DS_EVENT_SEV_ALWAYS,
                              DIRLOG_BUILD_SPN_FAILURE,
                              szInsertWC(pszAddress),
                              szInsertWin32Msg(status),
                              szInsertWin32ErrCode(status),
                              NULL, NULL, NULL, NULL, NULL );
                    DPRINT2( 0, "Error %d creating mutual auth SPN for %ws.\n",
                             status, pszAddress);
                }
            }
        } else {
            //
            // Caller wants a one-way authenticated binding
            //
            status = DRSMakeOneWaySpn( pTHS,pszAddress,*prpc_handle,ppszServerPrincName ); 
        }
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: DRSMakeSpn failed (%d)\n", status);
            __leave;
        }

        Assert(L'\0' != *ppszServerPrincName);

        RpcSecQOS.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        RpcSecQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        RpcSecQOS.Version = RPC_C_SECURITY_QOS_VERSION;
        RpcSecQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH; 

        status = RpcBindingSetAuthInfoExW(*prpc_handle,
                                          *ppszServerPrincName,
                                          RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                          RPC_C_AUTHN_GSS_KERBEROS,
                                          Credentials,
                                          RPC_C_AUTHZ_NONE,
                                          &RpcSecQOS);
        if (RPC_S_OK != status) {
            DPRINT1(0, "DRSGetRpcBinding: RpcBindingSetAuthInfo failed (%d)\n",
                    status);
            __leave;
        }

        // Success!
        Assert(RPC_S_OK == status);
        Assert(NULL != *prpc_handle);
        Assert(NULL != *ppszServerPrincName);
    }
    __finally {
        if (NULL != pszStringBinding) {
            RpcStringFreeW(&pszStringBinding);
        }

        if ((RPC_S_OK != status) || AbnormalTermination()) {
            if (NULL != *prpc_handle) {
                RpcBindingFree(prpc_handle);
                Assert(NULL == *prpc_handle)
            }

            if (NULL != *ppszServerPrincName) {
                free(*ppszServerPrincName);
                *ppszServerPrincName = NULL;
            }
        }

        if (NULL != Credentials) {
            DrspFreeCredentials(Credentials);
        }
    }

    // We should return a binding handle if and only if we we return success.
    if (RPC_S_OK == status) {
        Assert(NULL != *prpc_handle);
        Assert(NULL != *ppszServerPrincName);
    }
    else {
        Assert(NULL == *prpc_handle);
        Assert(NULL == *ppszServerPrincName);
    }

    return status;
}

VOID
RpcCancelAll()
{
    ULONG i;
    PLIST_ENTRY listEntry = &gDrsRpcServerCtxList;

    EnterCriticalSection(&gcsDrsRpcServerCtxList);
    __try {
        if (!gfDrsRpcServerCtxListInitialized) {
           __leave;
        }

        while (listEntry->Flink!=&gDrsRpcServerCtxList) {
            
            DRS_CONTEXT_INFO *pContextInfo = NULL;
            ULONG rpcstatus = 0; 
            ULONG ulCancelWait = 1; //ms
            // note: there is no reason to wait long - the cancel time is the time the server code
            // has to notice a cancel has been called - and we rarely check (RpcTestCancel) in any
            // server stubs.  We'd prefer our client threads to leave ASAP and try to 
            // free the server memory.  The server is protected (see draserv.c) in the case that
            // it has two threads running from us, one doing some work, and one trying to unbind since
            // we are exiting.
 
            listEntry = listEntry->Flink;
            // Check list sanity
            Assert((listEntry->Flink->Blink)==listEntry);
            Assert((listEntry->Blink->Flink)==listEntry);

            pContextInfo = CONTAINING_RECORD(listEntry,DRS_CONTEXT_INFO,ListEntry); 
            if ((pContextInfo->phThread!=NULL) && (*(pContextInfo->phThread)!=INVALID_HANDLE_VALUE)) { 
                rpcstatus = RpcCancelThreadEx(*(pContextInfo->phThread), ulCancelWait);  
                // don't remove these entries from the list!  The RpcCancelThreadEx will return 
                // control to the threads themselves and they will clean up and take themselves off 
                // the ServerCtxList.
            }
            else {
                Assert(!"Trying to cancel invalid thread!");
            }
        }
    }
    __finally {
        LeaveCriticalSection(&gcsDrsRpcServerCtxList);
    }

}

BOOL
FBindSzDRS(
    IN      THSTATE *           pTHS,
    IN      LPWSTR              szServer,
    IN      LPWSTR              pszDomainName,  OPTIONAL
    IN      ULONG               ulFlags,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo,
    IN OUT  DWORD *             pdwStatus
    )
/*++

Routine Description:

    Retrieve a DRS context handle and extension set for the given server.

    Optionally searches the cache for a pre-existing handle.  Otherwise or
    if no appropriate entry is found in the cache, contacts the server for a
    new context handle.

    If a cache search is requested but none is found, and a new context
    handle is succesfully generated, this function adds the handle to the
    cache if a free entry is available.  If a cached handle exists (either
    pre-existing or created) then a copy of the handle is returned.
    
    A context handle has 2 parts, a client component (binding handle) and a 
    pointer to a component on the server.  A copy of a context handle 
    creates a new client component with a pointer to the component 
    on the server.  The elements of the client component of
    the handle cannot be shared between threads/calls (specifically for our 
    implemenation the cancellation time we don't want to share) so we 
    return a copy of cached handles.  Because the server component is shared
    we reference count the copies.  We free the resources of the client copies
    by calling RpcSsDestroyClientContext, and call IDL_DRSUnbind on the original
    handle to free the server component, and it's client component.

Arguments:

    szServer (IN) - Server for which a context handle is desired.  This string
        buffer must be valid for the lifetime of the DRS_CONTEXT_INFO structure.

    pszDomainName (IN, OPTIONAL) - Domain name of the server; used to construct
        the SPN.  If the server name supplied is not a GUID-based DNS name and
        the pszDomainName is absent, one-way (not mutual) authentication will be
        performed.

    ulFlags (IN) - Zero or more of the following bits:
        FBINDSZDRS_NO_CACHED_HANDLES - Do not return cached context handles, and do
            not cache the fresh context handle returned from this function to
            be used by other threads.
        FBINDSZDRS_LOCK_HANDLE - Allows the use of cached handles which reduces the
            number of binds needed. But also ensures that this handle is exclusively
            owned by this thread till a DeReferenceHandle is called.

    eCallType (IN) - type of call being made on the context

    ppContextInfo (IN/OUT) - Should hold NULL before the first call.  On
        successful return, hold a valid context handle and extension set for the
        given server (amongst other state info).

    pdwStatus (IN OUT) - Detailed error code indicating why function failed
        If the error of this function is "no more bindings to try", we leave
        a non-success value of this error alone
        There is an assumption that if we run out of bindings, there must have
        been a previous error.

Return Values:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL                fSuccess = FALSE;
    ULONG               bhflags=0;
    DRS_EXTENSIONS *    pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    Assert( pdwStatus );

    if (!gfIsDrsClientLibInitialized || eServiceShutdown) {
        // Either we've been stopped or we were never started.
        *pdwStatus = ERROR_DS_DRA_SHUTDOWN;
        return FALSE;
    }

    //
    // Get the correct binding handle cache flags
    //

    if (ulFlags & FBINDSZDRS_LOCK_HANDLE)
    {
        bhflags|=BHCACHE_FLAGS_LOCK_HANDLE;
    }

    __try {
        if (NULL == *ppContextInfo) {
            // This is our first request for a context handle.

            // Put it on the list first because the free routine expects it to there
	    //    more specifically, if *ppContextInfo is not null,
	    //    then the free routine expects it to be there.
            // Note that if somehow this thread exits without the context free routine
            // being called, this list will contain dangling thread memory 

            EnterCriticalSection(&gcsDrsRpcServerCtxList); 
	    __try {  
		if (eServiceShutdown) {
		    // uh oh, we shouldn't add ourselves now, because on shutdown this
		    // list is used to cancell all rpc threads, and that cancel routine
		    // might have already run.  So we'll have to leave now.  Since we 
		    // won't allocate *ppContextInfo, we'll bail right after leaving
		    // the critsec.
		    *pdwStatus = ERROR_DS_DRA_SHUTDOWN;
		} else {    
		    if (!gfDrsRpcServerCtxListInitialized) {
			InitializeListHead(&gDrsRpcServerCtxList);  
			Assert(0 == gcNumDrsRpcServerCtxListEntries);
			gfDrsRpcServerCtxListInitialized = TRUE;
		    }

		    // Check list sanity
		    Assert((gDrsRpcServerCtxList.Flink->Blink)==&gDrsRpcServerCtxList);
		    Assert((gDrsRpcServerCtxList.Blink->Flink)==&gDrsRpcServerCtxList);
		    
		    *ppContextInfo = THAllocOrgEx(pTHS, sizeof(DRS_CONTEXT_INFO));
		    (*ppContextInfo)->dstimeCreated = DBTime();
		    (*ppContextInfo)->dwThreadId = GetCurrentThreadId();
		    (*ppContextInfo)->eCallType = DRS_CALL_NO_CALL;
		    
		    InsertTailList(&gDrsRpcServerCtxList, &(*ppContextInfo)->ListEntry);
		    ++gcNumDrsRpcServerCtxListEntries;
		}
            }
            __finally {
		// if we allocated a ppContextInfo, we'd better be on the list.
		Assert((*ppContextInfo==NULL) || ((*ppContextInfo)->ListEntry.Flink != NULL));
		Assert((*ppContextInfo==NULL) || ((*ppContextInfo)->ListEntry.Blink != NULL));
		Assert((*ppContextInfo==NULL) || (((*ppContextInfo)->ListEntry.Flink->Blink)==&((*ppContextInfo)->ListEntry)));
		Assert((*ppContextInfo==NULL) || (((*ppContextInfo)->ListEntry.Blink->Flink)==&((*ppContextInfo)->ListEntry)));
		
		LeaveCriticalSection(&gcsDrsRpcServerCtxList);
            } 

	    if (*ppContextInfo==NULL) {
		Assert(*pdwStatus!=0);
		__leave;
	    }

            if ((NULL == &(pTHS->hThread)) || (INVALID_HANDLE_VALUE == pTHS->hThread)) {
                if (!DuplicateHandle(GetCurrentProcess(),
                                     GetCurrentThread(),
                                     GetCurrentProcess(),
                                     &(pTHS->hThread),
                                     0,
                                     FALSE,
                                     DUPLICATE_SAME_ACCESS)) {
                    *pdwStatus = GetLastError();
                    __leave;
                }
            } 
            (*ppContextInfo)->phThread = &(pTHS->hThread);

            // Note that we don't copy the server name; we assume the string
            // we were given is valid for the lifetime of the structure.
            (*ppContextInfo)->pszServerName = szServer;  

            if (!(ulFlags & FBINDSZDRS_NO_CACHED_HANDLES)
                && BHCacheGetDrsContext(pTHS,
                                        pextLocal,
                                        szServer,
                                        pszDomainName,
                                        bhflags,
                                        &(*ppContextInfo)->hDrs,
                                        &(*ppContextInfo)->ext)) {
                // Found a context handle in the cache -- we're done!
                Assert(NULL != (*ppContextInfo)->hDrs);
                (*ppContextInfo)->ulFlags = ulFlags;
                (*ppContextInfo)->fIsHandleFromCache = TRUE;
                (*ppContextInfo)->fIsHandleInCache = TRUE;
                *pdwStatus = ERROR_SUCCESS; 
                fSuccess = TRUE;
                __leave;
            }
        }
        else {
            // We've tried (and failed) to use a context handle already.
            Assert((*ppContextInfo)->pszServerName == szServer);
            Assert(NULL != (*ppContextInfo)->hDrs);
            (*ppContextInfo)->eCallType = DRS_CALL_NO_CALL;
            (*ppContextInfo)->dwBindingTimeoutMins = 0;

            if (*pdwStatus == RPC_S_CALL_CANCELLED) {
                if ((*ppContextInfo)->fIsHandleInCache) {  
                    // void the handle in cache (so nobody else uses it after
                    // all current calls are through)
                    BHCacheVoidServer(szServer);
                } 

                // leave the previous failure intact
                __leave;
            }

            if (!(*ppContextInfo)->fIsHandleFromCache) {
                // Whatever RPC exception occurred did so while using a handle that
                // was not retrieved from the cache.  Fail the call.

                // Leave the previous failure status intact in *pdwStatus
                if (*pdwStatus == ERROR_SUCCESS) {
                    Assert( !"A previous non-success rpc exception should have occurred" );
                    *pdwStatus = RPC_S_NO_MORE_BINDINGS;
                }  
                __leave;
            } 

            // We're going to try to acquire a new context handle, but before we do
            // we need to free the reference to the cached handle we already have. 
            Assert((*ppContextInfo)->fIsHandleInCache);
	    
	    // Reset state.  Do this before we remove it from the cache, just in case
	    // it excepts after we remove it, but before these flags get set.  We'd
	    // rather have it leak memory in the cache (at worst case) then AV from
	    // a double free.
            (*ppContextInfo)->fIsHandleFromCache = FALSE;
            (*ppContextInfo)->fIsHandleInCache   = FALSE;
            
	    BHCacheFreeContext(szServer, &((*ppContextInfo)->hDrs));
            Assert((*ppContextInfo)->hDrs == NULL);
            BHCacheVoidServer(szServer);
        }

        Assert(NULL != *ppContextInfo);
        Assert(NULL == (*ppContextInfo)->hDrs);
        Assert(!(*ppContextInfo)->fIsHandleFromCache);
        Assert(!(*ppContextInfo)->fIsHandleInCache);

        fSuccess = getContextBindingHelper( pTHS,szServer,pszDomainName,
                                            ulFlags,ppContextInfo,pdwStatus);
    } __finally {
        // If an exception is raised, guarantee that context is cleaned up
        // Note that callers of this function must also guarantee that the context
        // is cleaned up in all cases before the thread terminates
        if (AbnormalTermination()) {
            DRSFreeContextInfo(pTHS, ppContextInfo);
        }
    }
    return(fSuccess);
}


BOOL
getContextBindingHelper(
    IN      THSTATE *           pTHS,
    IN      LPWSTR              szServer,
    IN      LPWSTR              pszDomainName,  OPTIONAL
    IN      ULONG               ulFlags,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo,
    IN OUT  DWORD *             pdwStatus
    )

/*++

Routine Description:

    Description

Arguments:

    pTHS - thread state
    szServer - server name
    pszDomainName - domain name, optional
    ulFlags - binding flags
    ppContextInfo - context structure, updated
    pdwStatus - status code returned

Return Value:

    None

--*/

{
    ULONG               draErr;
    ULONG               rpcStatus;
    ULONG               i;
    BOOL                fSuccess = FALSE;
    RPC_BINDING_HANDLE  hRpc = NULL;
    DRS_HANDLE          hDrs = NULL;
    DRS_EXTENSIONS *    pextRemote = NULL;
    DWORD               cchServer;
    UUID *              puuidDsa;
    LPWSTR              pszServerPrincName = NULL;
    VOID *              pvAddr;
    ULONG               ul1, ul2;
    BOOL                fUseMutualAuthSpn = TRUE;
    BOOL                fImpersonate = FALSE;
    DRS_EXTENSIONS *    pextLocal = (DRS_EXTENSIONS *) gAnchor.pLocalDRSExtensions;

    puuidDsa = (NULL == gAnchor.pDSADN) ? NULL : &gAnchor.pDSADN->Guid;

getbindingretry:

    if (!gfIsDrsClientLibInitialized || eServiceShutdown) {
        // Either we've been stopped or we were never started.
        *pdwStatus = ERROR_DS_DRA_SHUTDOWN;
        return FALSE;
    }

    draErr = DRSImpersonateInstallClient(&fImpersonate);
    if (ERROR_SUCCESS != draErr) {
        *pdwStatus = draErr;
        return FALSE;
    }

    // Attempt to create a binding handle, and, if successful, use it to acquire
    // a DRS context handle.
    _try {
        rpcStatus = DRSGetRpcBinding(pTHS,
                                     szServer,
                                     pszDomainName,
                                     fUseMutualAuthSpn,
                                     gfUseUniqueAssoc,
                                     &hRpc,
                                     &pszServerPrincName);
        if (RPC_S_OK == rpcStatus) {
            // set the time to cancel this rpc call 
            rpcStatus = RpcBindingSetOption(hRpc, RPC_C_OPT_CALL_TIMEOUT, gulDrsRpcBindTimeoutInMins*60*1000);
            if (RPC_S_OK != rpcStatus) {
                DRA_EXCEPT(rpcStatus,0); 
            }
            (*ppContextInfo)->eCallType = DRS_CALL_BIND;
            (*ppContextInfo)->dwBindingTimeoutMins = gulDrsRpcBindTimeoutInMins;

            if ( FBINDSZDRS_CRYPTO_BIND & ulFlags )
                {
                // Register the callback with RPC which will ultimately
                // set the SESSION_KEY in our thread state on return
                // from _IDL_DRSBind.
                InitRpcSessionEncryption(pTHS, ulFlags, NULL, hRpc);
            }

            __try { 
                draErr = _IDL_DRSBind(hRpc,
                                      puuidDsa,
                                      pextLocal,
                                      &pextRemote,
                                      &hDrs);
                MAP_SECURITY_PACKAGE_ERROR( draErr );

                if ( !draErr && (FBINDSZDRS_CRYPTO_BIND & ulFlags) )
                    {
                    if ( !IS_DRS_EXT_SUPPORTED(pextRemote,
                                               DRS_EXT_CRYPTO_BIND) ) {
                        draErr = DRAERR_NotSupported;
                    } else {
                        // Should have SESSION_KEY in thread state now.
                        Assert(    pTHS->SessionKey.SessionKey
                                   && pTHS->SessionKey.SessionKeyLength);
                    }
                }
            } __except(GetExceptionData(GetExceptionInformation(),
                                        &rpcStatus, &pvAddr, &ul1, &ul2)) {
                  MAP_SECURITY_PACKAGE_ERROR( rpcStatus );
                  // uncaught rpc error, log extended info if possible
                  LogRpcExtendedErrorInfo(pTHS, rpcStatus, szServer, DSID(FILENO, __LINE__));
                  Assert( rpcStatus != RPC_S_OK );
            } // end try/except
            
        // Error code used to be here.

        } // if (RPC_S_OK)

    } __finally {
        if (fImpersonate) {
            RevertToSelf();
        }
    }

    // Service Principal Name cannot be found on the target
    if ( (rpcStatus == ERROR_WRONG_TARGET_NAME) && (fUseMutualAuthSpn) ) {
        BOOL fFallback = 0;
        GetConfigParam(DRA_SPN_FALLBACK, &fFallback, sizeof(BOOL));
        if (fFallback) {
            fUseMutualAuthSpn = FALSE;
            if (NULL != hRpc) {
                RpcBindingFree(&hRpc);
            }
            if (NULL != pszServerPrincName) {
                free(pszServerPrincName);
                pszServerPrincName = NULL;
            }
            goto getbindingretry;
        } else {
            DPRINT3( 0, "Got error %d binding to %ws using spn %ws;\n"
                     "target server does not have or support mutual auth spn;\n"
                     "Check if server and domain specified correctly;\n"
                     "Verify that SPN is present on source or call Chandans;\n"
                     "set registry key to allow falling back to one way authentication.\n",
                     rpcStatus, szServer, pszServerPrincName );
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_DRA_SPN_WRONG_TARGET_NAME,
                     szInsertWC(szServer),
                     szInsertWC(pszServerPrincName),
                     NULL );
        }
    }

    if (RPC_S_OK != rpcStatus) {
        // This is a first-leg error
        *pdwStatus = rpcStatus;

        // Failed to acquire new DRS context handle.
        // there is no extended rpc info here, if an
        // expception warranted error occured (which 
        // have eeinfo) it was thrown out of this function
        if (DsaIsInstalling()) {
            // Log install failure.
            LogEvent(DS_EVENT_CAT_SETUP,
                     DS_EVENT_SEV_ALWAYS,
                     DIRLOG_RPC_CONNECTION_FAILED,
                     szInsertWC(szServer),
                     szInsertUL(rpcStatus),
                     szInsertWin32Msg(rpcStatus));
        }
        else if (RPC_S_CALL_CANCELLED == rpcStatus) {
            if (!eServiceShutdown) { 
                // Log non-install RPC cancellation.
                LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
                          DS_EVENT_SEV_ALWAYS,
                          DIRLOG_DRA_DISPATCHER_CANCELED,
                          szInsertHex(GetCurrentThreadId()),
                          szInsertWC(szServer),
                          szInsertUL(gulDrsRpcBindTimeoutInMins),
                          szInsertHex(DSID(FILENO,__LINE__)),  
                          NULL,NULL,NULL,NULL); 
            } else {
                LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                          DS_EVENT_SEV_MINIMAL,
                          DIRLOG_DRA_DISPATCHER_CANCELED_SHUTDOWN,
                          szInsertHex(GetCurrentThreadId()),
                          szInsertWC(szServer),
                          szInsertHex(DSID(FILENO,__LINE__))); 
            }
        }
        else {
            // Log other non-install failure.
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_EXTENSIVE,
                     DIRLOG_DRA_GET_RPC_HANDLE_FAILURE,
                     szInsertWC(szServer),
                     szInsertUL(rpcStatus),
                     szInsertWin32Msg(rpcStatus));
        }
    }
    else if (DRAERR_Success == draErr) {
        // Acquired new DRS context handle.
        Assert(NULL != hDrs);
 
        if (!(ulFlags & FBINDSZDRS_NO_CACHED_HANDLES)
            && (NULL != pszServerPrincName)
            && IS_DOMAIN_QUALIFIED_SPN(pszServerPrincName)) {
            // Cache our context handle.
            
            // Note that we do not cache non-domain-qualified SPNs -- i.e.,
            // those without @domain.com tacked on the end.  This is to protect
            // against having code paths that require DQSPNs (like GC lookup,
            // to avoid infinite recursion) from re-using contexts based on
            // NDQSPNs (which may require a re-bind under the covers using the
            // NDQSPN -- e.g., if the Kerberos ticket has expired).
            //
            // In the ideal world we would cache (and look up) contexts based on
            // server name / domain name / SPN triples, which would guarantee
            // the right behavior yet allow caching of any SPN form.  This would
            // be a performance hit today, though, as we have not yet calculated
            // the SPN when we perform the context cache lookup and deriving the
            // SPN is potentially expensive (requiring a transaction and
            // several database reads).

            i = UlBHCacheHash(szServer);
            EnterCriticalSection(&csBHCache);
            __try {
                VALIDATE_BH_ENTRY(i);
    
                cchServer = 1 + wcslen(szServer);
    
                // Update cache if caching is desired and entry is available.
                if ((NULL == rgBHCache[i].pszServer)
                    && (NULL != (rgBHCache[i].pszServer
                                 = malloc(cchServer * sizeof(WCHAR)))) ) {
                    RPC_STATUS rpcStatusTemp = RPC_S_OK; 
                    // we want to save away the handle in the cache, 
                    // and return only a copy of the handle to the caller.
                    // The handle in cache is not directly used by any
                    // client - they all use copies of the handle.  This
                    // handle still needs to be referenced counted.  If 
                    // any client unbinds any copy or the original, all copies
                    // and the original become invalid handles.  All handles
                    // need to be freed explicitly, except 
                    // the handle which unbinds on the server (calls _IDL_UNBIND).
                    // in this case, only the handle in cache is used to unbind
                    // the server (from BHCacheDecRef when there are no more users).

                    // RpcBindingCopy has been overloaded to use context handles, but
                    // RpcBindingFree hasn't been overloaded to free these copies, 
                    // instead we use RpcSsDestroyClientContext.
                    rgBHCache[i].hDrs = hDrs;
                    hDrs = 0;
                    rpcStatusTemp = RpcBindingCopy(rgBHCache[i].hDrs, &hDrs);
                    // if we aren't able to copy the handle for some reason, it's not fatal
                    // we just won't cash this at all.  We need to remember to free the malloc'ed
                    // memory above if we do.
                    if (rpcStatusTemp!=RPC_S_OK) {
                        hDrs = rgBHCache[i].hDrs;
                        rgBHCache[i].hDrs = 0;
                        free(rgBHCache[i].pszServer);
                        rgBHCache[i].pszServer = NULL;
                        // don't cache.
                    } else {  
                        // cache.
                        rgBHCache[i].cchServer = cchServer;
                        memcpy(rgBHCache[i].pszServer,
                               szServer,
                               rgBHCache[i].cchServer * sizeof(WCHAR));
                        CopyExtensions(pextRemote, &rgBHCache[i].extRemote);
                        CopyExtensions(pextLocal, &rgBHCache[i].extLocal);
                        
                        // put copy of handle in cache.   
                        rgBHCache[i].pszServerPrincName = pszServerPrincName;
                        // One ref to keep the cache entry alive.
                        // One ref for the current caller.
                        rgBHCache[i].cRefs = 2; 
                        rgBHCache[i].fDontUse = FALSE;
                        // Lock the handle if required
                        if (ulFlags & FBINDSZDRS_LOCK_HANDLE)
                            {
                            rgBHCache[i].fLocked = TRUE;
                        }
                        (*ppContextInfo)->fIsHandleInCache = TRUE;  
                    }
                }
            }
            __finally {
                VALIDATE_BH_ENTRY(i);
                LeaveCriticalSection(&csBHCache);
            }
        } 

        // Update caller.
        (*ppContextInfo)->hDrs = hDrs; 
        (*ppContextInfo)->ulFlags = ulFlags;
        CopyExtensions(pextRemote, &(*ppContextInfo)->ext);
        if (NULL != pextRemote) {
            MIDL_user_free(pextRemote);
        }

        fSuccess = TRUE;
        *pdwStatus = ERROR_SUCCESS;
    } else {
        // This is a second-leg error
        // This is a rare occurance since IDL_BIND does not ususally fail
        *pdwStatus = draErr; 
        if (hDrs) { 
            DRSInsertFreeHandleQueue(szServer, hDrs);
            hDrs = NULL;
        }
        if (pextRemote!=NULL) {
            MIDL_user_free(pextRemote);
        } 
        Assert( !fSuccess );
    }

    if ((!(*ppContextInfo)->fIsHandleInCache) && (pszServerPrincName!=NULL)) {
        // free the principle name since we are not caching it
        free(pszServerPrincName);
        pszServerPrincName=NULL;
    }

    if (NULL != hRpc) {
        // Free the RPC binding handle whether we successfully retrieved a
        // context handle or not -- it's no longer needed.
        RpcBindingFree(&hRpc);
    }

    Assert(NULL == hRpc);
    Assert(fSuccess || (NULL == hDrs));
    Assert( (*ppContextInfo)->fIsHandleInCache || (pszServerPrincName==NULL) );

    return fSuccess;
}

void
DRSExpireServerCtxHandles(
    void
    )
/*
 Routine Description:
    Scan the context handle cache and expire any handles that haven't been used
    recently.  This is particularly important for the intersite demand-dial case
    since closing the handle prevents RPC keep alives from being sent, which in
    turn allows the dial-up line to go idle and be automcatically disconnected.
*/
{
    DWORD     i;
    GUID *    pLocalSiteGuid;
    GUID *    pRemoteSiteGuid;
    BOOL      fSameSite;
    DWORD     cMaxTicksSinceLastUse;
    DWORD     cTicksDiff;
    DWORD     cTickNow = GetTickCount();

    pLocalSiteGuid = gAnchor.pSiteDN ? &gAnchor.pSiteDN->Guid : NULL;

    EnterCriticalSection(&csBHCache);
    __try {
        for (i = 0; i < BHCacheSize; i++) {
            VALIDATE_BH_ENTRY(i);

            if ((NULL == rgBHCache[i].pszServer)    // empty
                || rgBHCache[i].fDontUse            // already expired
                || (1 != rgBHCache[i].cRefs)) {     // in use
                continue;
            }

            pRemoteSiteGuid = SITE_GUID_FROM_DRS_EXT(&rgBHCache[i].extRemote);

                    // Note that we err on the side of "not same site" if
                // w    e can't tell for sure.
            fSameSite = (NULL != pLocalSiteGuid)
            && (NULL != pRemoteSiteGuid)
            && (0 == memcmp(pLocalSiteGuid,
                            pRemoteSiteGuid,
                            sizeof(GUID)));

            cMaxTicksSinceLastUse = fSameSite ? gulDrsCtxHandleLifetimeIntrasite
                : gulDrsCtxHandleLifetimeIntersite;
            cMaxTicksSinceLastUse *= 1000; // secs to msecs

            cTicksDiff = cTickNow - rgBHCache[i].cTickLastUsed;

            if ((cMaxTicksSinceLastUse > 0)
                && (cTicksDiff >= cMaxTicksSinceLastUse)) {
                // Stick a fork in it -- it's done.
                DPRINT3(2, "Expiring DRS context handle to %ls after %d min, %d sec.\n",
                        rgBHCache[i].pszServer,
                        cTicksDiff / (60 * 1000),
                        (cTicksDiff / 1000) % 60);
                BHCacheDecRef(&rgBHCache[i]);
                Assert(NULL == rgBHCache[i].pszServer);
            }
        }
    }
    __finally {
        LeaveCriticalSection(&csBHCache);
    }
}

void
DRSExpireContextHandles(
    IN  VOID *  pvArg,
    OUT VOID ** ppvNextArg,
    OUT DWORD * pcSecsUntilNextRun
    )
/*++

Routine Description:

   
Arguments/Return Values:

    Typical task queue function signature.

--*/
{
    __try {
            // call client and server expire
        DRSExpireServerCtxHandles();
        DRSExpireClientCtxHandles();
    }
    __finally{
        *pcSecsUntilNextRun = gulDrsCtxHandleExpiryCheckInterval;
    }
}

void
DRSFreeContextInfo(
    IN      THSTATE           * pTHS,
    IN OUT  DRS_CONTEXT_INFO ** ppContextInfo
    )
/*++

Routine Description:

    Free context handle data returned by a prior call to FBindSzDRS().

Arguments:

    ppContextInfo (IN/OUT) - The context handle data to free.

Return Values:

    None.

--*/
{
    if (NULL == *ppContextInfo) {
        return;
    }

    Assert( (*ppContextInfo)->dwThreadId == GetCurrentThreadId() );

    EnterCriticalSection(&gcsDrsRpcServerCtxList);
    __try {
        // Assert that we are still on the list!
        Assert((*ppContextInfo)->ListEntry.Flink != NULL);
        Assert((*ppContextInfo)->ListEntry.Blink != NULL);
        Assert(((*ppContextInfo)->ListEntry.Flink->Blink)==&((*ppContextInfo)->ListEntry));
        Assert(((*ppContextInfo)->ListEntry.Blink->Flink)==&((*ppContextInfo)->ListEntry));

        RemoveEntryList(&(*ppContextInfo)->ListEntry);
        (*ppContextInfo)->ListEntry.Flink = NULL;
        (*ppContextInfo)->ListEntry.Blink = NULL;

        gcNumDrsRpcServerCtxListEntries--;
    }
    __finally {
        LeaveCriticalSection(&gcsDrsRpcServerCtxList);
    }

    __try {
        if ((*ppContextInfo)->fIsHandleInCache) {
            // Context handle is in the cache; decrement its refcount.
            BHCacheFreeContext((*ppContextInfo)->pszServerName,
                               &(*ppContextInfo)->hDrs);
            Assert((*ppContextInfo)->hDrs == NULL);
        }
        else { 
            // Context handle is not cached; free it outright.

            DRSInsertFreeHandleQueue((*ppContextInfo)->pszServerName,
                                     (*ppContextInfo)->hDrs);
        } 
    } __finally {
        // Under low memory conditions, it is possible for BHCacheFreeContext or
        // DRSInsertFreeHandleQueue to raise exceptions. Higher layers use *ppContextInfo
        // as an indicator to call this routine again.  To prevent this routine from
        // running again on a partially freed structure, we guarantee to mark the
        // structure as released in all conditions.
        memset( *ppContextInfo, 0, sizeof( DRS_CONTEXT_INFO ) );
        THFreeOrg(pTHS, *ppContextInfo);
        *ppContextInfo = NULL;
    }
}

DWORD
DRSFlushKerberosTicketCache()
/*++

Routine Description:

    Flush the kerberos ticket cache of all tickets. 
    Stolen from \ds\security\protocols\kerberos\ssp\ssptest.c

Arguments:

    pTHS -

Return Value:

    win32 error codes

--*/

{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;
    HANDLE LogonHandle = NULL;
    ULONG PackageId;
    PKERB_QUERY_TKT_CACHE_RESPONSE Response;
    ULONG ResponseSize;
    NTSTATUS SubStatus;

    PKERB_PURGE_TKT_CACHE_REQUEST CacheRequest = NULL;
    USHORT Index;

    THSTATE * pTHS=pTHStls;

    //
    // Turn on the TCB privilege
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Assert(!"RtlAdjustPrivilege Failed!\n");
        return RtlNtStatusToDosError(Status);
    }
    __try {

        RtlInitString(
            &Name,
            "DS Replication"
            );

        Status = LsaRegisterLogonProcess(
            &Name,
            &LogonHandle,
            &Dummy
            );

        if (!NT_SUCCESS(Status))
            {
            Assert(!"Failed to register as a logon process!\n");
            __leave;
        }
        __try {

            RtlInitString(
                &Name,
                MICROSOFT_KERBEROS_NAME_A
                );

            Status = LsaLookupAuthenticationPackage(
                LogonHandle,
                &Name,
                &PackageId
                );

            if (!NT_SUCCESS(Status)) {
                DPRINT2(1,"Failed to lookup package %Z: 0x%x\n",&Name, Status);
                Assert(!"LsaLookupAuthenticationPackage failed!\n");
            } else { 

                CacheRequest = (PKERB_PURGE_TKT_CACHE_REQUEST)THAllocEx(pTHS, sizeof(KERB_PURGE_TKT_CACHE_REQUEST)); 

                CacheRequest->MessageType = KerbPurgeTicketCacheMessage;

                DPRINT(0, "Deleting all Kerberos Tickets!\n");

                Status = LsaCallAuthenticationPackage(
                    LogonHandle,
                    PackageId,
                    CacheRequest,
                    sizeof(KERB_PURGE_TKT_CACHE_REQUEST),
                    &Response,
                    &ResponseSize,
                    &SubStatus
                    );

                Assert(Response==NULL);
                Assert(ResponseSize==0);

                if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus)) {
                    DPRINT2(0,"token failed: 0x%x, 0x %x\n",Status, SubStatus);
                    DPRINT2(0,"token failed: %d, %d\n", RtlNtStatusToDosError(Status), RtlNtStatusToDosError(SubStatus));
                    Status= NT_SUCCESS(Status) ? SubStatus : Status;
                }    
            }
        }
        __finally {
            SubStatus = LsaDeregisterLogonProcess(LogonHandle);
            if (!NT_SUCCESS(SubStatus)) {
                Assert(!"Unable to deregister logon process!\n");
                // don't return this since it's the success of the LsaCallAuthenticaitonPackage that
                // we're really concerned with.
            }
            if (CacheRequest) {
                THFreeEx(pTHS, CacheRequest);
            }
        }
    }
    __finally {
        if (!WasEnabled) {
            SubStatus = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, FALSE, FALSE, &WasEnabled);
            if (!NT_SUCCESS(SubStatus)) {
                Assert(!"RtlAdjustPrivilege Failed!\n");
                // again, don't return this since the success of the LsaCallAuthPackage is 
                // the main concern.
            }
        } 
    }

    return RtlNtStatusToDosError(Status);
}



BOOL
drsIsCallComplete(
    IN  RPC_STATUS          rpcStatus,
    IN  ULONG               ulError,
    IN  DRS_CONTEXT_INFO *  pContextInfo
    )

/*++

Routine Description:

    Determine whether the result of an RPC call merits a retry with a fresh
    binding handle.

Arguments:

    rpcStatus - Status from RPC run-time, where applicable
    ulError - Status returned from server manager routine
    pContextInfo - Client-side context

Return Value:

    BOOL - TRUE - call should NOT be retried
           FALSE - call should be retried

--*/

{
    if (rpcStatus) {
        // RPC call was not completed.  If the last attempt was using a cached
        // handle, try again with a fresh handle, since the failure may have
        // been due to the cached handle no longer being valid.
        return !(pContextInfo->fIsHandleFromCache);
    }
    else if ((ERROR_ACCESS_DENIED == ulError)
             || (ERROR_REVISION_MISMATCH == ulError)) {
        // RPC call completed but the server side denied us access.
        // In this scenario, authentication wasn't successful.  If we
        // used a cached binding handle, try again with a fresh handle.
        
        // [wlees 12 Apr 00] Could also be that server has changed extensions
        // since we last bound.
        return !(pContextInfo->fIsHandleFromCache);
    } 
    else if (ERROR_DS_DRA_ACCESS_DENIED == ulError) {
        BOOL fUseUniqueAssoc = gfUseUniqueAssoc;
        DWORD err = ERROR_SUCCESS;
        // In this scenario, the authentication was successful -- i.e., the
        // IDL_DRSBind call succeeded, ergo the machine account for the local
        // DC (or whatever account was used for authentication) is present on
        // the remote DC.  However, the token derived for this account by the
        // remote DC from the Kerberos ticket does not have sufficient
        // privileges to perfrom the requested operation, possibly because the
        // Kerberos ticket does not yet include the latest group memberships
        // for this account, or this account is having some of it's group memberships
        // filtered in the trust path.
        //
        // If we assume that the authorization failure was based upon some missing
        // information, when the server aquires that information (which puts us in
        // a different group, or gives that group different rights) we need to 
        // update the security context we are using.  In order to update this,
        // we need to purge our kerberos ticket cache to that server, and 
        // use a unique rpc association to bind to the server.  Unforetunately, we
        // can never be sure that the default rpc association EVER has refreshed
        // security information since it depends upon being closed and reopened to 
        // refresh and ANY other tcp rpc calls from this process to the same
        // server process could keep the association open indefinately.
 

        // if we are beginning to use unique associations here, log a message
        if (!gfUseUniqueAssoc) {
            DPRINT(0,"Switching to use unique RPC associations for the life of this process!\n");
            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_BEGIN_UNIQUE_RPC_ASSOC,
                      NULL,NULL,NULL);
        }

        gfUseUniqueAssoc = TRUE;  

        err = DRSFlushKerberosTicketCache(); 

        if (err != ERROR_SUCCESS) {
            // This is a bad place to fail.  Log that we can't flush the
            // cache and return TRUE.  If we can't flush the cache then there is
            // no reason to try again, we will get the same result.  In (default) 8
            // hours the cache will expire and we'll get through then.   

            LogEvent(DS_EVENT_CAT_RPC_CLIENT,
                     DS_EVENT_SEV_MINIMAL,
                     DIRLOG_DRA_KERB_CACHE_PURGE_FAILURE,
                     szInsertWin32Msg(err),
                     szInsertUL(err),NULL);

            return TRUE;
        } 

        return (fUseUniqueAssoc && !(pContextInfo->fIsHandleFromCache));
    }
    else {
        // RPC call completed with success or a non-retriable error.
        return TRUE;
    }
} /* drsIsCallComplete */

BOOL
DRSIsRegisteredAsyncRpcState(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Scans the list of registered async state structures to determine if the
    given async state is present.

Arguments:

    pAsyncState (IN) - Async RPC state to look for.

Return Values:

    TRUE - pAsyncState is registered.
    FALSE - pAsyncState is not registered.

--*/
{
    LIST_ENTRY * pListEntry;
    LIST_ENTRY * pTargetListEntry = &pAsyncState->ListEntry;
    BOOL fFound = FALSE;

    // Note that pAsyncState must not be dereferenced -- assume it can be a
    // random pointer.
    RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
    __try {
        for (pListEntry = gDrsAsyncRpcList.Flink;
             pListEntry != &gDrsAsyncRpcList;
             pListEntry = pListEntry->Flink) {
            if (pListEntry == pTargetListEntry) {
                fFound = TRUE;
                break;
            }
        }
    } __finally {
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    return fFound;
}

void
drsZeroAsyncOutParameters(
    IN  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Zero-fill OUT parameters associated with the given async RPC call.  This
    forces RPC to allocate new buffers for returned data, rather than
    attempting to re-use previous buffers (which we have likely invalidated
    via TH_free_to_mark or never initialized in the first place).

Arguments:

    pAsyncState (IN) - Async RPC call info.

Return Values:

    None.

--*/
{
    switch (pAsyncState->CallType) {
    case DRS_ASYNC_CALL_GET_CHANGES:
        memset(pAsyncState->CallArgs.GetChg.pmsgOut,
               0,
               sizeof(*pAsyncState->CallArgs.GetChg.pmsgOut));
        break;

    default:
        Assert(!"Unknown CallType!");
        DRA_EXCEPT(DRAERR_InternalError, pAsyncState->CallType);
    }
}

void
drsCancelAsyncRpc(
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Cancel an async RPC call that's currently in progress.

Arguments:

    pAsyncState (IN/OUT) - Async RPC call to cancel.

Return Values:

    None.

--*/
{
    DWORD waitStatus;
    DWORD err;
    RPC_STATUS rpcStatus = RPC_S_OK;

    Assert(pAsyncState->fIsCallInProgress);

    __try {
        // Tell RPC to abort the call.
        err = RpcAsyncCancelCall(&pAsyncState->RpcState, TRUE);
        Assert(RPC_S_OK == err);

        // We never seed RPC with pre-allocated buffers for out parameters.
        drsZeroAsyncOutParameters(pAsyncState);

        // Wait for aborted call to terminate.
        waitStatus = WaitForSingleObject(pAsyncState->RpcState.u.hEvent,
                                         INFINITE);
        if (WAIT_OBJECT_0 != waitStatus) {
            err = GetLastError();
            LogUnhandledError(waitStatus);
            LogUnhandledError(err);
            DPRINT2(0, "Wait for async RPC completion failed (%d, GLE %d)",
                    waitStatus, err);
            Assert(!"Wait for async RPC completion failed -- contact DsRepl");
        }

        // Call completed.  Retrieve exit code and out parameters.
        // Note that this is required even though we cancelled the call.
	rpcStatus = RpcAsyncCompleteCall(&pAsyncState->RpcState, &err);
	// Yes, we are ignoring the output.  Cancelling a distributed call is tricky business.
	// There is no guarentee that we'll get there in time to stop it from completing 
	// successfully.  What about other errors?  Sucess or failure, there isn't anything
	// more we can do.  Esentially, the call is the server's problem now - we tried.
    } __except (DRSHandleRpcClientException(
                    GetExceptionInformation(),
                    pAsyncState->pContextInfo ?
                    pAsyncState->pContextInfo->pszServerName : L"",
                    pAsyncState->pContextInfo,
                    *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout,
                    &rpcStatus)) {
        DPRINT1(0, "Exception 0x%x caught in drsCancelAsyncRpc!\n", rpcStatus);
        // Nothing to do. Ignore the exception.
    }

    pAsyncState->fIsCallInProgress = FALSE;
}

void
DRSDestroyAsyncRpcState(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Free all the resources associated with a DRS_ASYNC_RPC_STATE structure.

    This function is designed to gracefully handle being called on a empty/freed
    DRS_ASYNC_RPC_STATE structures, so no need to worry too much about e.g.
    calling DRSDestroyAsyncRpcState twice.  (Just make sure you call it at least
    once!)

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Async RPC state to destroy.

Return Values:

    None.

--*/
{
    RPC_STATUS  rpcStatus;
    SESSION_KEY SessionKeyAtStart;

    // Save session key so we can restore it when we're done.
    PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtStart);

    if (pAsyncState->fIsCallInProgress) {
        drsCancelAsyncRpc(pAsyncState);
        Assert(!pAsyncState->fIsCallInProgress);
    }

    if (NULL != pAsyncState->RpcState.u.hEvent) {
        CloseHandle(pAsyncState->RpcState.u.hEvent);
        pAsyncState->RpcState.u.hEvent = NULL;
    }

    if (NULL != pAsyncState->pContextInfo) {
        DRSFreeContextInfo(pTHS, &pAsyncState->pContextInfo);
        Assert(NULL == pAsyncState->pContextInfo);
    }

    if (NULL != pAsyncState->SessionKey.SessionKey) {
        Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
        PEKDestroySessionKeySavedByDiffThread(&pAsyncState->SessionKey);
    }

    RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
    __try {
        if (NULL != pAsyncState->ListEntry.Flink) {
            Assert(NULL != pAsyncState->ListEntry.Blink);
            RemoveEntryList(&pAsyncState->ListEntry);
            pAsyncState->ListEntry.Flink = NULL;
            pAsyncState->ListEntry.Blink = NULL;
        }
    } __finally {
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    // Erase the structure.
    memset(pAsyncState, 0, sizeof(*pAsyncState));

    DPRINT1(1, "Destroyed async RPC state %p.\n", pAsyncState);

    // Exit with the same session key we entered with.
    PEKRestoreSessionKeySavedByMyThread(pTHS, &SessionKeyAtStart);
}

void
drsPrepareAsyncRpcState(
    IN  THSTATE *               pTHS,
    IN  LPWSTR                  pszServerName,
    IN  LPWSTR                  pszDomainName   OPTIONAL,
    IN  DRS_CALL_TYPE           CallType,
    OUT DRS_ASYNC_RPC_STATE *   pAsyncState
    )
/*++

Routine Description:

    Initializes async RPC state for a forthcoming async RPC call.

    This routine may be invoked multiple times on a given async state structure
    without an intervening DRSDestroyAsyncRpcState.  Doing so cancels the async
    RPC call in progress (if any) and prepares for a new async RPC call.

    The caller must eventually call DRSDestroyAsyncRpcState to free the
    resources associated with this structure.

Arguments:

    pTHS (IN)

    pszServerName (IN) - Name of the RPC server (e.g., replication source for a
        GetChanges call).  The buffer for this string must remain valid until
        DRSDestroyAsyncRpcState is invoked -- i.e., it is saved by reference,
        not copied.

    pszDomainName (IN, OPTIONAL) - DNS name of the domain to which pszServerName
        belongs.  Should be NULL if pszServerName is a GUID-based DNS name, may
        be NULL or non-NULL for other names.  The buffer for this string must 
        remain valid until DRSDestroyAsyncRpcState is invoked -- i.e., it is
        saved by reference, not copied.

    CallType (IN) - Identifies the forthcoming async RPC call (e.g.,
        GetChanges).

    pAsyncState (OUT) - Async RPC state to prepare.

Return Values:

    None.  Throws exception on error.

--*/
{
    ULONG   ret;
    HANDLE  hEvent;
    BOOL    fResetEvent = FALSE;

    Assert(DRS_ASYNC_CALL_NONE != CallType);

    if (0 == pAsyncState->timeInitialized) {
        // First time initializing this DRS_ASYNC_RPC_STATE.  The structure
        // should be zeroed out, with the possible exception of pContextInfo.
        Assert(0 == pAsyncState->dwCallerTID);
        Assert(0 == pAsyncState->CallType);
        Assert(NULL == pAsyncState->CallArgs.pszServerName);
        Assert(NULL == pAsyncState->CallArgs.pszDomainName);
        Assert(NULL == pAsyncState->ListEntry.Flink);
        Assert(NULL == pAsyncState->ListEntry.Blink);
        Assert(NULL == pAsyncState->RpcState.u.hEvent);
        Assert(!pAsyncState->fIsCallInProgress);

        DPRINT1(1, "Preparing new async RPC state %p.\n", pAsyncState);
    }
    else {
        // Not the first time initializing this DRS_ASYNC_RPC_STATE.
        Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
        Assert(CallType == pAsyncState->CallType);
        Assert(pszServerName == pAsyncState->CallArgs.pszServerName);
        Assert(pszDomainName == pAsyncState->CallArgs.pszDomainName);
        Assert(NULL != pAsyncState->ListEntry.Flink);
        Assert(NULL != pAsyncState->ListEntry.Blink);
        Assert(NULL != pAsyncState->RpcState.u.hEvent);
        Assert(!pAsyncState->fIsCallInProgress);

        if (NULL != pAsyncState->SessionKey.SessionKey) {
            Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
            PEKDestroySessionKeySavedByDiffThread(&pAsyncState->SessionKey);
        }

        DPRINT1(1, "Re-preparing existing async RPC state %p.\n", pAsyncState);
    }

    __try {
        hEvent = pAsyncState->RpcState.u.hEvent;
        if (NULL == hEvent) {
            // Create event for RPC to signal when the response has been
            // received.
            hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            if (NULL == hEvent) {
                ret = GetLastError();
                DRA_EXCEPT(ret, 0);
            }
        }
        else {
            // Already have an event -- make sure it's reset later.
            // Can't reset now, as e.g. cancelling a call in progress may set
            // the event.
            fResetEvent = TRUE;
        }

        // Init RPC portion.
        if (pAsyncState->fIsCallInProgress) {
            drsCancelAsyncRpc(pAsyncState);
            Assert(!pAsyncState->fIsCallInProgress);
        }
        ret = RpcAsyncInitializeHandle(&pAsyncState->RpcState,
                                       sizeof(RPC_ASYNC_STATE));
        if (ret) {
            DRA_EXCEPT(ret, 0);
        }

        if (fResetEvent && !ResetEvent(hEvent)) {
            ret = GetLastError();
            DRA_EXCEPT(ret, 0);
        }

        pAsyncState->RpcState.NotificationType = RpcNotificationTypeEvent;
        pAsyncState->RpcState.u.hEvent = hEvent;
        hEvent = NULL;
    }
    __finally {
        if (AbnormalTermination()) {
            // Encountered exception while trying to initialize -- tear down
            // whatever portion we did manage to init.
            DRSDestroyAsyncRpcState(pTHS, pAsyncState);

            if (NULL != hEvent) {
                CloseHandle(hEvent);
            }
        }
    }

    if (0 == pAsyncState->timeInitialized) {
        // First time initializing this DRS_ASYNC_RPC_STATE.
        pAsyncState->timeInitialized = GetSecondsSince1601();
        pAsyncState->dwCallerTID = GetCurrentThreadId();
        pAsyncState->CallType = CallType;
        pAsyncState->CallArgs.pszServerName = pszServerName;
        pAsyncState->CallArgs.pszDomainName = pszDomainName;

        // Save async state on global linked list.
        RtlEnterCriticalSection(&gcsDrsAsyncRpcListLock);
        InsertTailList(&gDrsAsyncRpcList, &pAsyncState->ListEntry);
        RtlLeaveCriticalSection(&gcsDrsAsyncRpcListLock);
    }

    Assert(!pAsyncState->fIsCallInProgress);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);
    Assert(RpcNotificationTypeEvent == pAsyncState->RpcState.NotificationType);
    Assert(0 == pAsyncState->SessionKey.SessionKeyLength);
    Assert(NULL == pAsyncState->SessionKey.SessionKey);
    Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
    Assert(pszServerName == pAsyncState->CallArgs.pszServerName);
    Assert(pszDomainName == pAsyncState->CallArgs.pszDomainName);
    Assert(NULL != pAsyncState->ListEntry.Flink);
    Assert(NULL != pAsyncState->ListEntry.Blink);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);

    // Assert(IsListEmpty(&gDrsAsyncRpcList)) on shutdown?
}

ULONG
drsWaitForAsyncRpc(
    IN      THSTATE *               pTHS,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState,
    OUT     ULONG *                 pRet
    )
/*++

Routine Description:

    Waits for completion of a prior, outstanding async RPC call.

    The async RPC must have been posted by this same thread -- this is required
    by (RPC's) RpcAsyncCancelCall.

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Async RPC state associated with oustanding async RPC
        call.

    pRet (OUT) - When this function returns, either there was no RPC error
        (indicating our function was invoked on the remote DSA), or there was
        an RPC error (in which case our function may or may not have executed on
        the remote DSA).  In the former case, this output parameter holds the
        return code of the server-side function we invoked on the remote DSA.
        In the latter case, this output parameter holds the RPC error code.

Return Values:

    0 or RPC error.  If the server-side function on the remote DSA was executed
    and the results returned to the local DSA, the return value is 0.  If there
    was any sort of error in reaching the remote DSA or transferring the data,
    the return value is non-0.

    Note that a return code of 0 *DOES NOT* indicate that the function we
    invoked on the remote DSA returned 0 -- that information is held in *pRet.
    The return code of drsWaitForAsyncRpc solely indicates whether there was
    an RPC communications error.

--*/
{
#if DBG
    static DWORD s_cNumTicksWaitedForReply = 0;
    static DWORD s_cNumReplies = 0;
    DWORD       tickStart;
    DWORD       cNumTicks;
#endif

    RPC_STATUS  rpcStatus;
    DWORD       waitStatus;
    ULONG       ret = 0;
    DWORD       cNumMSecToTimeout;
    HANDLE      rghWaitHandles[2];

    Assert(pAsyncState->fIsCallInProgress);
    Assert(GetCurrentThreadId() == pAsyncState->dwCallerTID);
    Assert(RpcNotificationTypeEvent == pAsyncState->RpcState.NotificationType);
    Assert(NULL != pAsyncState->RpcState.u.hEvent);

    // Sanity check CallType argument / table.
    Assert(DRS_ASYNC_CALL_NONE != pAsyncState->CallType);
    Assert(pAsyncState->CallType < DRS_ASYNC_CALL_MAX);
    Assert(pAsyncState->CallType < ARRAY_SIZE(rgCallTypeTable));
    Assert(pAsyncState->CallType
           == rgCallTypeTable[pAsyncState->CallType].CallType);

    __try {
        // We never seed RPC with pre-allocated buffers for out parameters.
        drsZeroAsyncOutParameters(pAsyncState);

        DPRINT1(1, "Waiting for completion of RPC call with state %p.\n", pAsyncState);
#if DBG
        tickStart = GetTickCount();
#endif
        // Asynchronous call has been initiated.  Wait for it to complete.
        cNumMSecToTimeout
            = *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout
              * 60 * 1000;

        rghWaitHandles[0] = hServDoneEvent; // shutdown
        rghWaitHandles[1] = pAsyncState->RpcState.u.hEvent; // RPC completed

        waitStatus = WaitForMultipleObjects(ARRAY_SIZE(rghWaitHandles),
                                            rghWaitHandles,
                                            FALSE,
                                            cNumMSecToTimeout);
#if DBG
        cNumTicks = GetTickCount() - tickStart;
        s_cNumTicksWaitedForReply += cNumTicks;
        s_cNumReplies++;

        DPRINT3(1, "Async RPC call %p terminated; waited %d msec (%d msec avg).\n",
                pAsyncState,
                cNumTicks,
                s_cNumTicksWaitedForReply / s_cNumReplies);
#endif

        switch (waitStatus) {
        case WAIT_OBJECT_0:
            // DS is shutting down.
            DPRINT1(0, "Aborting async RPC call to %ls due to DS shutdown.\n",
                    pAsyncState->CallArgs.pszServerName);

            rpcStatus = ERROR_DS_SHUTTING_DOWN;
            break;

        case WAIT_OBJECT_0 + 1:
            // Call completed.  Retrieve exit code and out parameters.
            rpcStatus = RpcAsyncCompleteCall(&pAsyncState->RpcState, &ret);
            pAsyncState->fIsCallInProgress = FALSE;
            break;

        case WAIT_TIMEOUT:
            // RPC call timed out.
            DPRINT2(0, "Async RPC call to %ls timed out after %d minutes!\n",
                    pAsyncState->CallArgs.pszServerName,
                    *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout);

            LogEvent8(DS_EVENT_CAT_RPC_CLIENT,
                      DS_EVENT_SEV_ALWAYS,
                      DIRLOG_DRA_DISPATCHER_VILLIAN,
                      szInsertWC(pAsyncState->CallArgs.pszServerName),
                      szInsertHex(pAsyncState->dwCallerTID),
                      szInsertDsMsg(rgCallTypeTable[pAsyncState->CallType].dwMsgID),
                      szInsertUL( *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout),
                      NULL, NULL, NULL, NULL
                      );

            rpcStatus = RPC_S_CALL_CANCELLED;
            break;

        case WAIT_ABANDONED_0:
        case WAIT_ABANDONED_0 + 1:
        default:
            // An unexpected error occurred.
            ret = GetLastError();
            LogUnhandledError(waitStatus);
            LogUnhandledError(ret);
            DPRINT2(0, "Wait for async RPC completion failed (%d, GLE %d)",
                    waitStatus, ret);
            Assert(!"Wait for async RPC completion failed -- contact JeffParh");

            rpcStatus = ERROR_DS_INTERNAL_FAILURE;
            break;
        }

        if (rpcStatus) {
            DRA_EXCEPT(rpcStatus, 0);
        }

        if (ret) {
            // RPC call succeeded, but the server-side function returned an
            // error.
            __leave;
        }

        // Update THSTATE so pek code can match destination's capabilities.
        DraSetRemoteDsaExtensionsOnThreadState(pTHS,
                                               &pAsyncState->pContextInfo->ext);

        // Restore session key associated with this RPC call.
        Assert(0 != pAsyncState->SessionKey.SessionKeyLength);
        Assert(NULL != pAsyncState->SessionKey.SessionKey);
        PEKRestoreSessionKeySavedByDiffThread(pTHS, &pAsyncState->SessionKey);
    }
    __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                          pAsyncState->pContextInfo->pszServerName,
                                          pAsyncState->pContextInfo,
                                          *rgCallTypeTable[pAsyncState->CallType].pcNumMinutesUntilRpcTimeout,
                                          &rpcStatus)) {
        ret = rpcStatus;
    }

    if (pAsyncState->fIsCallInProgress) {
	drsCancelAsyncRpc(pAsyncState);
	Assert(!pAsyncState->fIsCallInProgress);
    }	
     

    MAP_SECURITY_PACKAGE_ERROR(ret);

    *pRet = ret;

    DPRINT2(1, "Async RPC call %p returned status %d.\n", pAsyncState, ret);

    // If an RPC failure occurred, *pRet must indicate an error.
    Assert(!rpcStatus || *pRet);

    return rpcStatus;
}

ULONG
I_DRSReplicaSync(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    DSNAME *    pNC,
    LPWSTR      pszFromServerName,
    UUID *      pInvocationId,
    ULONG       ulOptions
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPSYNC     msgSync;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgSync, 0, sizeof(msgSync));

    msgSync.V1.pNC       = pNC;
    msgSync.V1.ulOptions = ulOptions;

    if (NULL != pszFromServerName) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszFromServerName);
        msgSync.V1.pszDsaSrc = pmtx->mtx_name;
    }

    if (NULL != pInvocationId) {
        msgSync.V1.uuidDsaSrc = *pInvocationId;
    }
    
    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {  
            DRSSetContextCancelTime(DRS_CALL_REPLICA_SYNC, gulDrsRpcReplicationTimeoutInMins, pContextInfo );

            ret = _IDL_DRSReplicaSync(pContextInfo->hDrs, 1, &msgSync); 

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        } 
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcReplicationTimeoutInMins,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}

ULONG
I_DRSGetNCChanges(
                 IN  THSTATE *                     pTHS,
                 IN  LPWSTR                        pszServerName,
                 IN  LPWSTR                        pszServerDnsDomainName,     OPTIONAL
                 IN  DSNAME *                      pNC,
                 IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgInNative,
                 OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOutNative,
                 OUT PBYTE                         pSchemaInfo,
                 OUT DRS_ASYNC_RPC_STATE *         pAsyncState,                OPTIONAL
                 OUT BOOL *                        pfBindSuccess               OPTIONAL
                 )
/*++

Routine Description:

    Request replication changes from a source server over RPC.

Arguments:

    pTHS (IN)

    pszServerName (IN) - DNS name (GUID-based or other) of the source server.

    pszServerDnsDomainName (IN, OPTIONAL) - DNS name of the domain of the
        source server.

    pmsgInNative (IN) - The replication request.

    pmsgOut (OUT) - Holds the replication response after the source server
        has completed processing the request.

    pSchemaInfo (OUT) - Holds the schema signature of the source server after
        the source server has completed processing the request.

    pAsyncState (OUT, OPTIONAL) - If NULL, the traditional GetNCChanges
        behavior is observed -- i.e., if this function returns successfully,
        pmsgOutV1 holds the source server's response and pSchemaInfo holds the
        source server's schema signature.

        If non-NULL, this function returns immediately after posting the
        replication request to the source server -- i.e., it does not wait for
        the server to process the request and send the response.  Rather, the
        caller can perform other operations in the interim and later come back
        to retrieve the response via I_DRSGetNCChangesComplete, at which point
        pmsgOutV1 and pSchemaInfo will hold the returned data.  (Alternatively
        the caller can cancel via DRSDestroyAsyncRpcState.)  Note that the
        buffers pmsgOutV1, pSchemaInfo, and pAsyncState must remain valid until
        the caller invokes I_DRSGetNCChangesComplete or DRSDestroyAsyncRpcState.

        Note that in the non-NULL case the MIDL_user_allocate calls to allocate
        buffers for the unmarshalled data are not invoked until
        I_DRSGetNCChangesComplete is called -- these MIDL_user_allocates are
        *not* invoked by other threads asynchronously.  This is an important
        detail here, given the DS thread-based allocation model and
        ReplicateNC()'s alternating of heaps for GetChanges responses (i.e.,
        the TH_mark, TH_free_to_mark functionality).

        If non-NULL and this function returns successfully the caller MUST
        later call I_DRSGetNCChangesComplete or DRSDestroyAsyncRpcState.
        (Either will do but both are okay, too, as long as
        DRSDestroyAsyncRpcState is called last.)

     pfBindSuccess (OUT, OPTIONAL) - Allows the caller to know if a successful
        bind was made to the server. If this routine has to retry, the status
        of the last bind is returned

Return Values:

    0 or Win32 error code.

--*/
{
    ULONG                   ret = ERROR_SUCCESS;
    BOOL                    fCallCompleted = FALSE;
    DRS_MSG_GETCHGREPLY *   pmsgOut;
    DRS_MSG_GETCHGREQ       MsgIn;
    ULONG                   BindFlags=0;
    DWORD                   dwInVersion;
    BOOL                    fWaitForCompletion = (NULL == pAsyncState);
    SESSION_KEY             SessionKeyAtStart;
    BOOL                    fConstructedMsgIn = FALSE;
    LPWSTR                  pszDnsDomainName = NULL;
    LPWSTR                  pszUseDnsDomainName = pszServerDnsDomainName;
    DRS_ASYNC_RPC_STATE *   pTempAsyncState = NULL;

    // Allocate async RPC state if it was not supplied by the caller.
    if (NULL == pAsyncState) {
        pTempAsyncState = THAllocEx(pTHS, sizeof(*pTempAsyncState));
        pAsyncState = pTempAsyncState;
    }

    UpToDateVec_Validate(pmsgInNative->pUpToDateVecDest);
    UsnVec_Validate(&pmsgInNative->usnvecFrom);

    // Cast the V1 pointer as a VX pointer.  We abuse the fact that the V1
    // struct is the biggest struct in the VX union to avoid putting the VX on
    // the stack and having to perform the copy (or changing the signature of
    // this function).
    Assert(sizeof(DRS_MSG_GETCHGREPLY_NATIVE) == sizeof(DRS_MSG_GETCHGREPLY));
    pmsgOut = (DRS_MSG_GETCHGREPLY *) pmsgOutNative;

    // We need to prevent multi threaded use of the same handle in order to use
    // the security callback feature of RPC to retrieve the session key.
    BindFlags |= FBINDSZDRS_LOCK_HANDLE;

    if (!fWaitForCompletion) {
        // We're not getting the reply packet on this call, therefore we should
        // return from this call with the session key we were called with.
        PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtStart);
    }

    __try {

        DBPOS * pDB = NULL;

        if (pNC == NULL ||
            (fNullUuid(&(pNC->Guid)) &&
             pNC->NameLen == 0)) {
            Assert(!"No one should call with without a completely valid (str and guid) NC");
            ret = ERROR_INVALID_PARAMETER;
            __leave;
        }

        // first, if this is a writable domain NC, use the dns domain name of that
        // nc in the SPN to ensure that the source server can be authenticated as
        // a member of that domain.

        DBOpen2(TRUE, &pDB);
        __try {

            // Note that extended operations send the object name in the "pNC"
            // field, which is not necessarily the name of the NC.  Get the correct
            // name of the NC which is being requested.  We must check the cross refs
            // since it might be the first request for this NC, we won't yet have it in
            // our list of master or replica nc's.

            if (IsMasterForNC(pDB, gAnchor.pDSADN, pNC)) {
                pszDnsDomainName = GetDomainDnsHostnameFromNC(pTHS, pNC); 
                // pszDnsDomainName will be null if pmsgInNative->pNC is not a domain partition
                // (ie Config, Schema, ndnc's) from the GetDomainDnsHostnameFromNC function
                if (pszDnsDomainName) {
                    pszUseDnsDomainName = pszDnsDomainName;
                } else {
                    pszUseDnsDomainName = pszServerDnsDomainName;  
                }
            }
        }
        __finally {
            DBClose(pDB, TRUE);
        }

        // we use the context info block and rpc call return stored in pAsyncState in case of failure
        // if I_DRSGetNCChangesComplete decides to run this call again, FBindSzDRS needs to know both
        // whether this is a second try (ie pContextInfo is not null) and what error caused us to try
        // again.  Immediately outside of this call, reset ret so that this function returns correct
        // values if it errors and cannot retry, or if it fails the retry also.
        while (!fCallCompleted
               && FBindSzDRS(pTHS, pszServerName, pszUseDnsDomainName,
                             BindFlags, &pAsyncState->pContextInfo,
                             &(pAsyncState->RpcCallReturn))) {
            __try {
                if (!fConstructedMsgIn) {
                    // First pass -- construct message.  We can't do this before
                    // we FBindSzDRS() because we need bind-time extensions info
                    // from the source DC to determine which message version to
                    // send.

                    if ((0 == pmsgInNative->cMaxObjects)
                        || (0 == pmsgInNative->cMaxBytes)) {
                        // Use appropriate default packet size based on whether
                        // the source is in the same site or in a different site.
                        if (IS_REMOTE_DSA_IN_SITE(&pAsyncState->pContextInfo->ext,
                                                  gAnchor.pSiteDN)) {
                            // Same site.  (Note that we err on the side of
                            // "same site" if we can't tell for sure.)
                            pmsgInNative->cMaxObjects = gcMaxIntraSiteObjects;
                            pmsgInNative->cMaxBytes   = gcMaxIntraSiteBytes;
                        } else {
                            // Different sites.
                            pmsgInNative->cMaxObjects = gcMaxInterSiteObjects;
                            pmsgInNative->cMaxBytes   = gcMaxInterSiteBytes;
                        }
                    }

                    if (IS_DRS_GETCHGREQ_V8_SUPPORTED(&pAsyncState->pContextInfo->ext)) {
                        // Target DSA is running post whistler review bits
                        dwInVersion = 8;
                    } else if (IS_DRS_GETCHGREQ_V5_SUPPORTED(&pAsyncState->pContextInfo->ext)) {
                        // Target DSA is running post Win2k RTM RC1 bits.
                        dwInVersion = 5;
                    } else {
                        // Target DSA is a pre-Win2k RTM RC2 DC.  We no longer
                        // support those.
                        DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
                    }

                    if (!IS_DRS_EXT_SUPPORTED(&pAsyncState->pContextInfo->ext,
                                              DRS_EXT_RESTORE_USN_OPTIMIZATION)) {
                        // Pre-Win2k RC3 DC -- we don't support those.
                        DRA_EXCEPT(ERROR_REVISION_MISMATCH, 0);
                    }

                    draXlateNativeRequestToOutboundRequest(pTHS,
                                                           pmsgInNative,
                                                           NULL,
                                                           NULL,
                                                           dwInVersion,
                                                           &MsgIn);
                    fConstructedMsgIn = TRUE;
                }

                // Inform RPC to issue a call back on the security context used
                // for this call, so that we can copy the session key for
                // stronger encryption of secrets/passwords.
                InitRpcSessionEncryption(pTHS,
                                         BindFlags,
                                         pAsyncState->pContextInfo,
                                         NULL);

                // Construct state for asynchronous RPC call.
                drsPrepareAsyncRpcState(pTHS,
                                        pszServerName,
                                        pszServerDnsDomainName,
                                        DRS_ASYNC_CALL_GET_CHANGES,
                                        pAsyncState);
                pAsyncState->CallArgs.GetChg.pmsgIn      = pmsgInNative;
                pAsyncState->CallArgs.GetChg.pmsgOut     = pmsgOutNative;
                pAsyncState->CallArgs.GetChg.pSchemaInfo = pSchemaInfo;

                DRSSetContextCancelTime(DRS_CALL_GET_NC_CHANGES, gulDrsRpcReplicationTimeoutInMins, pAsyncState->pContextInfo);

                // Initiate the async call.  When control returns to us, RPC
                // has marshalled the input parameters and has enqueued the
                // send (but the response/out parameters have not yet been
                // received).
                _IDL_DRSGetNCChanges(&pAsyncState->RpcState,
                                     pAsyncState->pContextInfo->hDrs,
                                     dwInVersion,
                                     &MsgIn,
                                     &pAsyncState->CallArgs.GetChg.dwOutVersion,
                                     pmsgOut);
                pAsyncState->fIsCallInProgress = TRUE;

                DPRINT3(1, "Posted async GetChg call %p from USN 0x%I64x with flags 0x%x.\n",
                        pAsyncState,
                        pAsyncState->CallArgs.GetChg.pmsgIn->usnvecFrom.usnHighObjUpdate,
                        pAsyncState->CallArgs.GetChg.pmsgIn->ulFlags);

                fCallCompleted = TRUE;
            }
            __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                                  pszServerName,
                                                  pAsyncState->pContextInfo,
                                                  gulDrsRpcReplicationTimeoutInMins,
                                                  &(pAsyncState->RpcCallReturn))) {

                // Exception intercepted.  We may decide to try contacting the
                // source machine again.
                Assert(!fCallCompleted);
            }
        }

        ret = pAsyncState->RpcCallReturn;
        MAP_SECURITY_PACKAGE_ERROR(ret); 

        if (pfBindSuccess) {
            // Was a handle obtained during this call? May or may not be cached.
            *pfBindSuccess = pAsyncState->pContextInfo &&
                (pAsyncState->pContextInfo->hDrs != NULL);
            DPRINT2( 1, "Sync from %ws, bind %d\n", pszServerName, *pfBindSuccess );
        }

        if (!ret && fWaitForCompletion) {
            ret = I_DRSGetNCChangesComplete(pTHS, pNC, pAsyncState, pfBindSuccess);
        }

        if (pszDnsDomainName) {
            THFreeEx(pTHS, pszDnsDomainName);
        }
    }
    __finally { 
        if (AbnormalTermination() || ret) {
            DRSDestroyAsyncRpcState(pTHS, pAsyncState);
        }

        if (!fWaitForCompletion) {
            PEKRestoreSessionKeySavedByMyThread(pTHS, &SessionKeyAtStart);
        }

        if (pTempAsyncState!=NULL) {
            THFreeEx(pTHS,pTempAsyncState);
        }
    }

    return ret;
}

ULONG
I_DRSGetNCChangesComplete(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN OUT  DRS_ASYNC_RPC_STATE *   pAsyncState,
    OUT     BOOL *                  pfBindSuccess OPTIONAL
    )
/*++

Routine Description:

    Complete a replication get changes request begun during a previous call
    to I_DRSGetNCChanges.

Arguments:

    pTHS (IN)

    pAsyncState (IN/OUT) - Pointer to async state constructed via a previous
        call to I_DRSGetNCChanges.

Return Values:

    0 or Win32 error code.

--*/
{
    RPC_STATUS                    rpcStatus;
    ULONG                         ret;
    SESSION_KEY                   SessionKeyAtRpcCompletion;
    BOOL                          fSessionKeySaved = FALSE;

    // We abuse the fact that the native struct is the biggest struct in the
    // union to avoid putting the union on the stack and having to perform the
    // copy.
    Assert(sizeof(DRS_MSG_GETCHGREPLY_NATIVE) == sizeof(DRS_MSG_GETCHGREPLY));

    Assert(DRS_ASYNC_CALL_GET_CHANGES == pAsyncState->CallType);
    Assert(NULL != pAsyncState->pContextInfo);

    __try {
        do {
            // use RpcCallReturn in the AsyncState block to hold the error value so that 
            // I_DRSGetNCChanges can know why we failed if we end up trying again below.
            rpcStatus = drsWaitForAsyncRpc(pTHS, pAsyncState, &(pAsyncState->RpcCallReturn));
 
            if (drsIsCallComplete(rpcStatus, pAsyncState->RpcCallReturn, pAsyncState->pContextInfo)) {
                // Success or non-retriable error.
                ret = pAsyncState->RpcCallReturn;
                break;
            }

            // Call failed in a way that dictates we must try again.
            ret = I_DRSGetNCChanges(pTHS,
                                    pAsyncState->CallArgs.pszServerName,
                                    pAsyncState->CallArgs.pszDomainName,
                                    pNC,
                                    pAsyncState->CallArgs.GetChg.pmsgIn,
                                    pAsyncState->CallArgs.GetChg.pmsgOut,
                                    pAsyncState->CallArgs.GetChg.pSchemaInfo,
                                    pAsyncState,
                                    pfBindSuccess);
        } while (!ret);

        if (ret) {
            __leave;
        }

        PEKSaveSessionKeyForMyThread(pTHS, &SessionKeyAtRpcCompletion);
        fSessionKeySaved = TRUE;

        draXlateInboundReplyToNativeReply(pTHS,
                                          pAsyncState->CallArgs.GetChg.dwOutVersion,
                                          (DRS_MSG_GETCHGREPLY *) pAsyncState->CallArgs.GetChg.pmsgOut,
                                          pAsyncState->CallArgs.GetChg.pmsgIn->ulExtendedOp
                                            ? DRA_XLATE_FSMO_REPLY
                                            : 0,
                                          pAsyncState->CallArgs.GetChg.pmsgOut);

        UpToDateVec_Validate(pAsyncState->CallArgs.GetChg.pmsgOut->pUpToDateVecSrc);
        UsnVec_Validate(&pAsyncState->CallArgs.GetChg.pmsgOut->usnvecTo);

        __try {
            if (IS_DRS_SCHEMA_INFO_SUPPORTED(pTHS->pextRemote)) {
                // Schema info piggybacked on the prefix table, Strip it
                StripSchInfoFromPrefixTable(&pAsyncState->CallArgs.GetChg.pmsgOut->PrefixTableSrc,
                                            pAsyncState->CallArgs.GetChg.pSchemaInfo);
            }
        }
        __except (GetDraException((GetExceptionInformation()), &ret)) {
            DPRINT1(1,"I_DRSGetNCChanges: Exception %d while trying to strip schema info\n", ret);
        }
    }
    __finally {
        if (ret && pAsyncState && pAsyncState->CallArgs.GetChg.pmsgIn) {
            LogEvent8(DS_EVENT_CAT_REPLICATION,
                      DS_EVENT_SEV_BASIC,
                      DIRLOG_DRA_GETNCCHANGES_COMPLETE,
                      szInsertWC(pAsyncState->CallArgs.pszServerName),
                      szInsertDN(pAsyncState->CallArgs.GetChg.pmsgIn->pNC),
                      szInsertUSN(pAsyncState->CallArgs.GetChg.pmsgIn->usnvecFrom.usnHighObjUpdate),
                      szInsertUSN(pAsyncState->CallArgs.GetChg.pmsgIn->usnvecFrom.usnHighPropUpdate),
                      szInsertUL(pAsyncState->CallArgs.GetChg.pmsgIn->ulFlags),
                      szInsertUL(pAsyncState->CallArgs.GetChg.pmsgIn->ulExtendedOp),
                      szInsertUL(ret),
                      szInsertWin32Msg(ret) );
        }
        DRSDestroyAsyncRpcState(pTHS, pAsyncState);

        if (fSessionKeySaved) {
            PEKRestoreSessionKeySavedByMyThread(pTHS,
                                                &SessionKeyAtRpcCompletion);
        }
    }

    Assert(ret || (NULL != pTHS->SessionKey.SessionKey));
    Assert(ret || (NULL != pTHS->pextRemote));

    return ret;
}

ULONG
I_DRSUpdateRefsEx(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    DSNAME *    pNC,
    LPWSTR      pszDsaDest,
    UUID *      puuidDsaDest,
    ULONG       ulOptions,
    PULONG      pfCallCompleted
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_UPDREFS     msgUpdRefs;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgUpdRefs, 0, sizeof(msgUpdRefs));

    msgUpdRefs.V1.pNC        = pNC;
    msgUpdRefs.V1.ulOptions  = ulOptions;

    if (NULL != pszDsaDest) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszDsaDest);
        msgUpdRefs.V1.pszDsaDest = pmtx->mtx_name;
    }

    if (NULL != puuidDsaDest) {
        msgUpdRefs.V1.uuidDsaObjDest = *puuidDsaDest;
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_UPDATE_REFS,gulDrsRpcReplicationTimeoutInMins,pContextInfo );   

            ret = _IDL_DRSUpdateRefs(pContextInfo->hDrs, 1, &msgUpdRefs);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcReplicationTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    if (pfCallCompleted) {
        *pfCallCompleted = fCallCompleted;
    }

    return ret;
}

ULONG
I_DRSReplicaAddEx(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  DSNAME *    pNCName,
    IN  DSNAME *    pSourceDsaDN,
    IN  DSNAME *    pTransportDN,
    IN  LPWSTR      pszSourceDsaAddress,
    IN  REPLTIMES * pSyncSchedule,
    IN  ULONG       ulOptions,
    OUT PULONG      pfCallCompleted
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPADD      msgAdd;
    DWORD               dwMsgVersion;
    MTX_ADDR *          pmtx = NULL;

    Assert(NULL != pszSourceDsaAddress);

    memset(&msgAdd, 0, sizeof(msgAdd));

    pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDsaAddress);

    if ((NULL == pSourceDsaDN) && (NULL == pTransportDN)) {
        dwMsgVersion = 1;

        msgAdd.V1.pNC       = pNCName;
        msgAdd.V1.pszDsaSrc = pmtx->mtx_name;
        msgAdd.V1.ulOptions = ulOptions;

        if (NULL != pSyncSchedule) {
            msgAdd.V1.rtSchedule = *pSyncSchedule;
        }
    }
    else {
        dwMsgVersion = 2;

        msgAdd.V2.pNC                 = pNCName;
        msgAdd.V2.pSourceDsaDN        = pSourceDsaDN;
        msgAdd.V2.pTransportDN        = pTransportDN;
        msgAdd.V2.pszSourceDsaAddress = pmtx->mtx_name;
        msgAdd.V2.ulOptions           = ulOptions;

        if (NULL != pSyncSchedule) {
            msgAdd.V2.rtSchedule = *pSyncSchedule;
        }
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        if ((2 == dwMsgVersion)
            && !IS_DRS_REPADD_V2_SUPPORTED(&pContextInfo->ext)) {
            ret = DRAERR_NotSupported;
            break;
        }
        __try {
            DRSSetContextCancelTime(DRS_CALL_REPLICA_ADD,gulDrsRpcReplicationTimeoutInMins,pContextInfo );   

            ret =  _IDL_DRSReplicaAdd(pContextInfo->hDrs, dwMsgVersion, &msgAdd);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcReplicationTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    THFreeEx(pTHS, pmtx);

    if (pfCallCompleted) {
        *pfCallCompleted = fCallCompleted;
    }

    return ret;
}


ULONG
I_DRSReplicaDel(
    IN  THSTATE * pTHS,
    IN  LPWSTR    pszServerName,
    IN  DSNAME *  pNCName,
    IN  LPWSTR    pszSourceDSA,
    IN  ULONG     ulOptions
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    DRS_MSG_REPDEL      msgDel;
    MTX_ADDR *          pmtx = NULL;

    memset(&msgDel, 0, sizeof(msgDel));

    msgDel.V1.pNC       = pNCName;
    msgDel.V1.ulOptions = ulOptions;

    if (NULL != pszSourceDSA) {
        pmtx = MtxAddrFromTransportAddrEx(pTHS, pszSourceDSA);
        msgDel.V1.pszDsaSrc = pmtx->mtx_name;
    }

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_REPLICA_DEL, gulDrsRpcReplicationTimeoutInMins,pContextInfo );   

            ret =  _IDL_DRSReplicaDel(pContextInfo->hDrs, 1, &msgDel);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcReplicationTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    if (NULL != pmtx) {
        THFreeEx(pTHS, pmtx);
    }

    return ret;
}


ULONG
I_DRSVerifyNames(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    LPWSTR                  pszDnsDomainName,
    DWORD                   dwInVersion,
    DRS_MSG_VERIFYREQ *     pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_VERIFYREPLY *   pmsgOut
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_VERIFY_NAMES,gulDrsRpcGcLookupTimeoutInMins,pContextInfo );  

            ret = _IDL_DRSVerifyNames(pContextInfo->hDrs,
                                      dwInVersion,
                                      pmsgIn,
                                      pdwOutVersion,
                                      pmsgOut);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcGcLookupTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSGetMemberships(
    THSTATE *   pTHS,
    LPWSTR      pszServerName,
    LPWSTR      pszServerDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      pErrCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory
    )
{
    ULONG                   ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *      pContextInfo = NULL;
    BOOL                    fCallCompleted = FALSE;
    DRS_MSG_REVMEMB_REQ     msgIn;
    DRS_MSG_REVMEMB_REPLY   msgOut;
    DWORD                   dwOutVersion;

    msgIn.V1.ppDsNames       = ppObjects;
    msgIn.V1.cDsNames        = cObjects;
    msgIn.V1.dwFlags         = 0;
    msgIn.V1.pLimitingDomain = pLimitingDomain;
    msgIn.V1.OperationType   = OperationType;

    RtlZeroMemory(&msgOut, sizeof(msgOut));

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszServerDnsDomainName, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_GET_MEMBERSHIPS,gulDrsRpcGcLookupTimeoutInMins,pContextInfo );   

            ret = _IDL_DRSGetMemberships(
                pContextInfo->hDrs,
                1,
                &msgIn,
                &dwOutVersion,
                &msgOut
                );

            *prpDsNames = msgOut.V1.ppDsNames;
            *pcDsNames  = msgOut.V1.cDsNames;

            if (ARGUMENT_PRESENT(pAttributes)) {
                *pAttributes = msgOut.V1.pAttributes;
            }

            if ((ARGUMENT_PRESENT(pcSidHistory))
                && (ARGUMENT_PRESENT(rgSidHistory))) {
                *pcSidHistory = msgOut.V1.cSidHistory;
                *rgSidHistory = msgOut.V1.ppSidHistory;
            }
          
            *pErrCode = msgOut.V1.errCode;

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcGcLookupTimeoutInMins,
                                              &ret)) {
            ;
        }
    }
    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSInterDomainMove(
    IN  THSTATE *           pTHS,
    IN  LPWSTR              pszServerName,
    IN  DWORD               dwInVersion,
    IN  DRS_MSG_MOVEREQ *   pmsgIn,
    IN  DWORD *             pdwOutVersion,
    OUT DRS_MSG_MOVEREPLY * pmsgOut
    )
{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    ULONG               BindFlags;
    extern ULONG        EncryptSecretData(THSTATE *, ENTINF *);

    if (    (NULL == pszServerName)
         || (NULL == pmsgIn)
         || (NULL == pmsgOut)
         || (2 != dwInVersion) ) {
        return(DRAERR_InvalidParameter);
    }

    BindFlags = FBINDSZDRS_LOCK_HANDLE |            // required by encryption
                FBINDSZDRS_NO_CACHED_HANDLES |      // for user impersonation
                FBINDSZDRS_CRYPTO_BIND;             // RPC session encryption

    while (    !fCallCompleted
               && FBindSzDRS(  pTHS,
                               pszServerName,
                               NULL,
                               BindFlags,
                               &pContextInfo, &ret)) {

        // Security error check.
        MAP_SECURITY_PACKAGE_ERROR(ret);
        if ( ret ) {
            break;
        }

        // Versioning check.
        if (    (2 == dwInVersion)
                && !IS_DRS_MOVEREQ_V2_SUPPORTED(&pContextInfo->ext) ) {
            ret = DRAERR_NotSupported;
            break;
        }

        // FBINDSZDRS_CRYPTO_BIND sanity check.
        Assert(    pTHS->SessionKey.SessionKey
                   && pTHS->SessionKey.SessionKeyLength);

        // Update THSTATE so pek code can match destination's capabilities.
        DraSetRemoteDsaExtensionsOnThreadState(pTHS, &pContextInfo->ext);

        // At this point we know that:
        //
        //      1) The destination has the session keys stashed in the
        //         DRS_CLIENT_CONTEXT for this client session and will
        //         presumably use them when decrypting DBIsSecretData()
        //         in the ENTINF we are about to send.
        //      3) We have the corresponding session keys stashed in our
        //         thread state such that we will encrypt DBIsSecretData()
        //         with those keys for any items read while fDRA is set.
        //
        // So now invoke the callback to encrypt those things which need it.
        //
        // N.B. The PEK code (pek.c) figures out for itself which version/level
        // of encryption is supported in common between source and destination
        // based on the extensions.


        if ( ret = EncryptSecretData(pTHS, pmsgIn->V2.pSrcObject) ) {
            break;
        }

        if (IS_DRS_SCHEMA_INFO_SUPPORTED(&pContextInfo->ext)) {
            // need to ship the schema info piggybacked on the prefix table
            // Note: the client doesn't ship the table unless it also
            // send some atts (like partial atts). We send the schema
            // info anyway. Right now it will not be used on the
            // server side.

            if (AddSchInfoToPrefixTable(pTHS, &pmsgIn->V2.PrefixTable)){
                ret = DRAERR_SchemaInfoShip;
                break;
            }
        }

        __try {
            DRSSetContextCancelTime(DRS_CALL_INTER_DOMAIN_MOVE, gulDrsRpcMoveObjectTimeoutInMins,pContextInfo );   

            ret = _IDL_DRSInterDomainMove(pContextInfo->hDrs,
                                          dwInVersion,
                                          pmsgIn,
                                          pdwOutVersion,
                                          pmsgOut);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcMoveObjectTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    PEKClearSessionKeys(pTHS);

    return ret;
}


ULONG
I_DRSGetNT4ChangeLog(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    DWORD                   dwFlags,
    ULONG                   PreferredMaximumLength,
    PVOID *                 ppRestart,
    PULONG                  pcbRestart,
    PVOID *                 ppLog,
    PULONG                  pcbLog,
    NT4_REPLICATION_STATE * ReplicationState,
    NTSTATUS *              ActualNtStatus
    )
{
    ULONG                     ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *        pContextInfo = NULL;
    BOOL                      fCallCompleted = FALSE;
    DRS_MSG_NT4_CHGLOG_REQ    msgIn;
    DRS_MSG_NT4_CHGLOG_REPLY  msgOut;
    DWORD                     dwOutVersion;

    msgIn.V1.dwFlags                = dwFlags;
    msgIn.V1.PreferredMaximumLength = PreferredMaximumLength;
    msgIn.V1.cbRestart              = *pcbRestart;
    msgIn.V1.pRestart               = *ppRestart;

    RtlZeroMemory(&msgOut,sizeof(msgOut));

    //
    // For getting the change log, we do not try hard, but try
    // weakly. Remember it is a best effort process, and if we
    // encounter any errors we will end up dropping the idea, of
    // getting the change log and rescheduling it later.
    //

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_GET_NT4_CHANGE_LOG,gulDrsRpcNT4ChangeLogTimeoutInMins,pContextInfo );    

            ret =  _IDL_DRSGetNT4ChangeLog(
                pContextInfo->hDrs,
                1,
                &msgIn,
                &dwOutVersion,
                &msgOut
                );
            Assert(1 == dwOutVersion);

            *ppRestart = msgOut.V1.pRestart;
            *pcbRestart = msgOut.V1.cbRestart;
            *ppLog = msgOut.V1.pLog;
            *pcbLog = msgOut.V1.cbLog;

            *ReplicationState = msgOut.V1.ReplicationState;
            *ActualNtStatus = msgOut.V1.ActualNtStatus;

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcNT4ChangeLogTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}


ULONG
I_DRSCrackNames(
    THSTATE *               pTHS,
    LPWSTR                  pszServerName,
    LPWSTR                  pszDnsDomainName,
    DWORD                   dwInVersion,
    DRS_MSG_CRACKREQ *      pmsgIn,
    DWORD *                 pdwOutVersion,
    DRS_MSG_CRACKREPLY *    pmsgOut
    )
{
    ULONG               win32Err = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    // N.B. - For various reasons, _IDL_DRSCrackNames returns WIN32
    // error codes, not DRAERR* values.  See dsamain\dra\ntdsapi.c.
    // Therefore this routine does too.  The only known internal client
    // at this time is CrackSingleName in dsamain\src\cracknam.c.

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &win32Err)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_CRACK_NAMES,gulDrsRpcGcLookupTimeoutInMins,pContextInfo );    

            win32Err = _IDL_DRSCrackNames(pContextInfo->hDrs,
                                          dwInVersion,
                                          pmsgIn,
                                          pdwOutVersion,
                                          pmsgOut);
            fCallCompleted = drsIsCallComplete(0, win32Err, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcGcLookupTimeoutInMins,
                                              &win32Err)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( win32Err );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return win32Err;
}

#ifdef INCLUDE_UNIT_TESTS

/*++

    This is a Unit test that excercises the binding handle cache
    and also usage of cached as well as locked handles. Just make
    sure that the machine to which you want to get binding handle is
    running and is reachable. The test will assert on failure. Typically
    on an idle machine the test will succeed. There can be spurious failures
    on a busy machine. Agreed it is primitive that the we have to declare the
    server name statically like below, and it will be a later excercise to
    improve this such that this can be taken as a parameter to BHCacheTest.

--*/
LPWSTR szTestServer = L"murli06.murlitest.nttest.microsoft.com";

VOID BHCacheTest(VOID)
{
    DRS_CONTEXT_INFO *pContextInfo1=NULL;
    DRS_CONTEXT_INFO *pContextInfo2=NULL;

    DWORD            dwStatus=0;
    BOOL             Success;
    DRS_HANDLE       hDrs;

    //
    // Void the cache for this server
    //

    BHCacheVoidServer(szTestServer);

    //
    // First try a simple binding
    //

    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);

    //
    // Try a simple binding again. Should get back the
    // same handle.
    //

     Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo2,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo2->fIsHandleInCache);
    // The handle should be the same
    Assert(pContextInfo1->hDrs==pContextInfo2->hDrs);

    //
    // Save the handle. Will be used below
    //

    hDrs = pContextInfo1->hDrs;
    //
    // Free the handles. The handles should be returned to
    // the cache
    //


    DRSFreeContextInfo(pTHStls, &pContextInfo1);
    DRSFreeContextInfo(pTHStls, &pContextInfo2);


    //
    // Try a case of a locked handle. The handle should now
    // come from the cache
    //

    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                FBINDSZDRS_LOCK_HANDLE,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);
    // Should have the same handle back.
    Assert(hDrs==pContextInfo1->hDrs);

    //
    // Try to obtain one other handle. This handle should
    // not come from the cache ( the one in the cache is locked )
    //

     Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo2,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(!(pContextInfo2->fIsHandleInCache));
    // The handle should be the same
    Assert(hDrs!=pContextInfo2->hDrs);

    //
    // Free Handles
    //

    DRSFreeContextInfo(pTHStls, &pContextInfo2);
    DRSFreeContextInfo(pTHStls, &pContextInfo1);

    //
    // Get one more handle, and this should be
    // from the cache and the same as the first 3
    // handles
    //


    Success = FBindSzDRS(
                pTHStls,
                szTestServer,
                NULL,
                0,
                &pContextInfo1,
                &dwStatus
                );

    Assert(Success);
    Assert(0==dwStatus);
    // The handle should be cached.
    Assert(pContextInfo1->fIsHandleInCache);
    // Should have the same handle back.
    Assert(hDrs==pContextInfo1->hDrs);

    //
    // Free the handle
    //

    DRSFreeContextInfo(pTHStls, &pContextInfo1);

 }


#endif

ULONG
I_DRSAddEntry(
    IN  THSTATE *                   pTHS,
    IN  LPWSTR                      pszServerName,
    IN  DRS_SecBufferDesc *         pClientCreds,   OPTIONAL
    IN  DRS_MSG_ADDENTRYREQ_V2 *    pReq,
    OUT DWORD *                     pdwReplyVer,
    OUT DRS_MSG_ADDENTRYREPLY *     pReply
    )

/*++

  Routine Description:

    Calls the DSA on server pszServerName to add the object described in
    pReq, with the results of the operation being returned in pReply.

  Parameters:

    pszServerName - Name of server where the add should take place

    pClientCreds (OPTIONAL) - Credentials to use to add the object, if other
        than the default credentials (gCredentials)

    pReq - mostly an addarg in a bag

    pReply - add results

  Return Values:

    ERROR_SUCCESS on success

--*/

{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;
    ULONG               ReqVer;
    DRS_MSG_ADDENTRYREQ uReq;
    DRS_MSG_ADDENTRYREPLY uReply;

    if (NULL == pClientCreds) {
        ReqVer = 2;
        uReq.V2 = *pReq;
    } else {
        ReqVer = 3;
        uReq.V3.EntInfList = pReq->EntInfList;
        uReq.V3.pClientCreds = pClientCreds;
    }

    RtlZeroMemory( &uReply, sizeof( uReply ) );

    while (!fCallCompleted && FBindSzDRS(pTHS,
                                         pszServerName,
                                         NULL,
                                         0,
                                         &pContextInfo,
                                         &ret)) {
        Assert(!ret)
            switch (ReqVer) {
            case 2:
                if (!IS_DRS_ADDENTRY_V2_SUPPORTED(&pContextInfo->ext)) {
                    ret = DRAERR_NotSupported;
                }
                break;

            case 3:
                if (!IS_DRS_ADDENTRY_V3_SUPPORTED(&pContextInfo->ext)) {
                    ret = DRAERR_NotSupported;
                }
                break;

            default:
                Assert(!"Logic Error");
                ret = DRAERR_NotSupported;
                break;
            }

        if (ret) {
            break;
        }

        __try {
            DRSSetContextCancelTime(DRS_CALL_ADD_ENTRY,gulDrsRpcReplicationTimeoutInMins,pContextInfo );     

            ret =  _IDL_DRSAddEntry(pContextInfo->hDrs,
                                    ReqVer,
                                    &uReq,
                                    pdwReplyVer,
                                    &uReply);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcReplicationTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    *pReply = uReply;

    return ret;
}

ULONG
I_DRSIsExtSupported(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName,
    IN  ULONG       Ext
    )
/*++

  Routine Description:

    This routine determines if pszServerName supports Ext

  Parameters:

    pszServerName - Name of server where the add should take place

    Ext -- the extension of the DRS interface the caller is interested in


  Return Values:

    ERROR_SUCCESS or DRAERR_NotSupported, or network error

--*/

{
    ULONG               ret = DRAERR_Success;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;

    if ( FBindSzDRS(
             pTHS,
             pszServerName,
             NULL, 0,
             &pContextInfo,
             &ret) && !ret ){
        // bind succeeded w/ no errors.
        // see if exts are supported.
        if ( !IS_DRS_EXT_SUPPORTED(&pContextInfo->ext, Ext) ) {
            ret = DRAERR_NotSupported;
        }
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}

ULONG
I_DRSGetMemberships2(
    THSTATE                       *pTHS,
    LPWSTR                         pszServerName,
    LPWSTR                         pszDnsDomainName,
    DWORD                          dwInVersion,
    DRS_MSG_GETMEMBERSHIPS2_REQ   *pmsgIn,
    DWORD                         *pdwOutVersion,
    DRS_MSG_GETMEMBERSHIPS2_REPLY *pmsgOut
    )
/*++

Routine Description:

    This routine is a batchable form of I_DRSGetMemberships

Parameters:

    pTHS -- thread state

    pszServerName -- target server

    pszServerDnsDomainDomain -- domain of pszServerName, needed for SPN

    dwMsgInVersion -- version of in blob

    psgIn -- in blob, see drs.idl for details

    pdwMsgOutVersion -- version of returned blob

    psgOut -- returned blob, see drs.idl for details

  Return Values:

    ERROR_SUCCESS on success

--*/
{

    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, pszDnsDomainName, 0, &pContextInfo, &ret)) {
        __try {
            DRSSetContextCancelTime(DRS_CALL_GET_MEMBERSHIPS2,gulDrsRpcGcLookupTimeoutInMins,pContextInfo );       

            ret = _IDL_DRSGetMemberships2(pContextInfo->hDrs,
                                          dwInVersion,
                                          pmsgIn,
                                          pdwOutVersion,
                                          pmsgOut);

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);

        }
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcGcLookupTimeoutInMins,
                                              &ret)) {
            ;
        }
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;

}



BOOL
I_DRSIsIntraSiteServer(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszServerName
    )
/*++

  Routine Description:

    This routine determines if pszServerName is intra-site relative
    to this server (as given by gAnchor).

  Parameters:

    pTHS - Thread context
    pszServerName - Name of server where the add should take place

  Return Values:

    TRUE: Target server is intra-site
    FALSE: Target server is NOT intra-site
    (or some other failure, i.e. default is inter-site)

--*/

{
    ULONG               ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *  pContextInfo = NULL;
    BOOL                fIntra = FALSE;

    if ( FBindSzDRS(
             pTHS,
             pszServerName,
             NULL,0,
             &pContextInfo,
             &ret)           &&
         IS_REMOTE_DSA_IN_SITE(&pContextInfo->ext, gAnchor.pSiteDN) )
    {
        fIntra = TRUE;
    }

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return fIntra;
}

ULONG
I_DRSGetObjectExistence(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DRS_MSG_EXISTREQ *            pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_EXISTREPLY *          pmsgOut
    )
/*++

  Routine Description:

    This routine determines if a set of objects on the source server
    match the set of objects on the destination (this) server.  If not,
    the set of object guids is returned.

  Parameters:

    pTHS - Thread context
    pszServerName - Source server (transport address)
    pmsgIn
    pdwOutVersion
    pmsgOut

  Return Values:

    0 or Errors

--*/
{
    ULONG                ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *   pContextInfo = NULL;
    BOOL                 fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {  
            DRSSetContextCancelTime(DRS_CALL_GET_OBJECT_EXISTENCE, gulDrsRpcObjectExistenceTimeoutInMins,pContextInfo );  

            ret = _IDL_DRSGetObjectExistence(pContextInfo->hDrs, 
                                             1, 
                                             pmsgIn,
                                             pdwOutVersion,
                                             pmsgOut); 
            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        } 
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcObjectExistenceTimeoutInMins,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );

    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;

}

ULONG
I_DRSGetReplInfo(
    IN      THSTATE *                     pTHS,
    IN      LPWSTR                        pszServerName,
    IN      DWORD                         dwInVersion,
    IN      DRS_MSG_GETREPLINFO_REQ *     pmsgIn,
    OUT     DWORD *                       pdwOutVersion,
    OUT     DRS_MSG_GETREPLINFO_REPLY *   pmsgOut
    )
/*++

  Routine Description:

    This routine allows access to RepInfo from DC to DC.

  Parameters:

    pTHS - Thread context
    pszServerName - Server to access
    dwInVersion -
    pmsgIn -
    pdwOutVersion -
    pmsgOut -

  Return Values:

    0 or Errors

--*/
{
    ULONG                ret = ERROR_SUCCESS;
    DRS_CONTEXT_INFO *   pContextInfo = NULL;
    BOOL                 fCallCompleted = FALSE;

    while (!fCallCompleted
           && FBindSzDRS(pTHS, pszServerName, NULL, 0, &pContextInfo, &ret)) {
        __try {  
            DRSSetContextCancelTime(DRS_CALL_GET_REPL_INFO,gulDrsRpcGetReplInfoTimeoutInMins,pContextInfo );   

            ret = _IDL_DRSGetReplInfo(pContextInfo->hDrs, 
                                      1, 
                                      pmsgIn,
                                      pdwOutVersion,
                                      pmsgOut); 

            fCallCompleted = drsIsCallComplete(0, ret, pContextInfo);
        } 
        __except (DRSHandleRpcClientException(GetExceptionInformation(),
                                              pszServerName,
                                              pContextInfo,
                                              gulDrsRpcGetReplInfoTimeoutInMins,
                                              &ret)) {
            ;
        }       
    }

    MAP_SECURITY_PACKAGE_ERROR( ret );
    DRSFreeContextInfo(pTHS, &pContextInfo);

    return ret;
}

// Max FindGC attempts to do in I_DRSxxxFindGC functions.
// This will prevent us from going into an infinite loop
// trying to find an appropriate GC when the GC invalidation
// time is too short and GCs start coming back from the 
// invalidated cache before we get a chance to find a working GC.
#define MAX_FIND_GC_ATTEMPTS 10
#define FIND_GC_TIMEOUT 5*60*1000   // in ticks

ULONG
I_DRSCrackNamesFindGC(
    THSTATE *               pTHS,
    LPWSTR                  pszPreferredDestGC,
    LPWSTR                  pszPreferredDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_CRACKREQ        *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_CRACKREPLY      *pmsgOut,
    DWORD                   dwFindGCFlags
    )
// FindDC version of I_DRSCrackNames
// pszPreferredDestGC and pszPreferredDestDnsDomainName are optional parameters
// If the preferred GC is not available, or was not specified, then FindGC is
// invoked to find a GC. 
{
    FIND_DC_INFO *pGCInfo = NULL;
    ULONG        err = 0;           
    DWORD        dwStartTick = GetTickCount();
    DWORD        cAttempts = 0;

    do {
        if (pszPreferredDestGC == NULL) {
            // preferred destination GC was not specified, 
            // or it was found to be bad on the last iteration.
            if (err = FindGC(dwFindGCFlags, &pGCInfo) ) {
                // no more GCs left
                break;
            }
            pszPreferredDestGC = pGCInfo->addr;
            pszPreferredDestDnsDomainName = FIND_DC_INFO_DOMAIN_NAME(pGCInfo);
        }

        err = I_DRSCrackNames(
            pTHS,
            pszPreferredDestGC,
            pszPreferredDestDnsDomainName,
            dwMsgInVersion,
            pmsgIn,
            pdwMsgOutVersion,
            pmsgOut);

        Assert((ERROR_SUCCESS != err) || (1 == *pdwMsgOutVersion));

        if (err == ERROR_SUCCESS || (*pdwMsgOutVersion == 1 && err != ERROR_DS_GCVERIFY_ERROR)) {
            // Either we got success, or the GC at least set the out version value.
            // Also, the DC did not say that it is not a GC.
            // In either case, we should not fail over.
            if (pGCInfo) {
                THFreeEx(pTHS, pGCInfo);
            }
            break;
        }

        // Either connection to GC is bad, or this GC isn't
        // playing by the rules and is returning a version
        // I didn't ask for. Or, it said it is not a GC.
        pszPreferredDestGC = NULL;
        pszPreferredDestDnsDomainName = NULL;
        if (pGCInfo) {
            InvalidateGC(pGCInfo, err);
            THFreeEx(pTHS, pGCInfo);
        }

        // Check if we have timed out or made too many FindGC attempts
        // The subtraction takes care of DWORD wrap-around
        if (GetTickCount() - dwStartTick >= FIND_GC_TIMEOUT || ++cAttempts >= MAX_FIND_GC_ATTEMPTS) {
            err = ERROR_TIMEOUT;
            break;
        }
        // OK, we did not time out yet. Let's check another GC
        
        // We are going to repeat the RPC call. We need to clear
        // the pmsgOut structure in case the previous call has left
        // something in it. Otherwise, RPC will think we pre-allocated
        // memory when it unmarshalls the reply and will likely AV.
        // Note: we might leak some THS heap memory that RPC could have
        // possibly allocated, but it's ok since we never free it
        // in normal runs either. And we don't expect to go through
        // this loop too many times anyway.
        memset(pmsgOut, 0, sizeof(DRS_MSG_CRACKREPLY));
    } while (TRUE);

    return err;
}

ULONG
I_DRSVerifyNamesFindGC(
    THSTATE                 *pTHS,
    LPWSTR                  pszPreferredDestGC,
    LPWSTR                  pszPreferredDestDnsDomainName,
    DWORD                   dwMsgInVersion,
    DRS_MSG_VERIFYREQ       *pmsgIn,
    DWORD                   *pdwMsgOutVersion,
    DRS_MSG_VERIFYREPLY     *pmsgOut,
    DWORD                   dwFindGCFlags
    )
// FindGC version of I_DRSVerifyNames
{
    FIND_DC_INFO *pGCInfo = NULL;
    ULONG        err = 0;           
    DWORD        dwStartTick = GetTickCount();
    DWORD        cAttempts = 0;

    do {
        if (pszPreferredDestGC == NULL) {
            // preferred destination GC was not specified, 
            // or it was found to be bad on the last iteration.
            if (err = FindGC(dwFindGCFlags, &pGCInfo) ) {
                // no more GCs left
                break;
            }
            pszPreferredDestGC = pGCInfo->addr;
            pszPreferredDestDnsDomainName = FIND_DC_INFO_DOMAIN_NAME(pGCInfo);
        }

        err = I_DRSVerifyNames(
            pTHS,
            pszPreferredDestGC,
            pszPreferredDestDnsDomainName,
            dwMsgInVersion,
            pmsgIn,
            pdwMsgOutVersion,
            pmsgOut);

        Assert((ERROR_SUCCESS != err) || (1 == *pdwMsgOutVersion));

        if (err == ERROR_SUCCESS || (pmsgOut->V1.error != 0 && pmsgOut->V1.error != ERROR_DS_GC_REQUIRED)) {
            // Either we got success, or the GC set the error value.
            // Also, the DC did not say that it is not a GC.
            // In either case, we should not fail over.
            if (pGCInfo) {
                THFreeEx(pTHS, pGCInfo);
            }
            break;
        }

        // Either connection to GC is bad, or this GC isn't
        // playing by the rules and is returning a version
        // I didn't ask for.
        // Or it thinks it's not a GC.
        pszPreferredDestGC = NULL;
        pszPreferredDestDnsDomainName = NULL;
        if (pGCInfo) {
            InvalidateGC(pGCInfo, err);
            THFreeEx(pTHS, pGCInfo);
        }

        // Check if we have timed out or made too many FindGC attempts
        // The subtraction takes care of DWORD wrap-around
        if (GetTickCount() - dwStartTick >= FIND_GC_TIMEOUT || ++cAttempts >= MAX_FIND_GC_ATTEMPTS) {
            err = ERROR_TIMEOUT;
            break;
        }
        // OK, we did not time out yet. Let's check another GC
        
        // We are going to repeat the RPC call. We need to clear
        // the pmsgOut structure in case the previous call has left
        // something in it. Otherwise, RPC will think we pre-allocated
        // memory when it unmarshalls the reply and will likely AV.
        // Note: we might leak some THS heap memory that RPC could have
        // possibly allocated, but it's ok since we never free it
        // in normal runs either. And we don't expect to go through
        // this loop too many times anyway.
        memset(pmsgOut, 0, sizeof(DRS_MSG_VERIFYREPLY));
    } while (TRUE);

    return err;
}

ULONG
I_DRSGetMembershipsFindGC(
    THSTATE *   pTHS,
    LPWSTR      pszPreferredDestGC,
    LPWSTR      pszPreferredDestDnsDomainName,
    DWORD       dwFlags,
    DSNAME      **ppObjects,
    ULONG       cObjects,
    PDSNAME     pLimitingDomain,
    REVERSE_MEMBERSHIP_OPERATION_TYPE
                OperationType,
    PULONG      pErrCode,
    PULONG      pcDsNames,
    PDSNAME     ** prpDsNames,
    PULONG      *pAttributes,
    PULONG      pcSidHistory,
    PSID        **rgSidHistory,
    DWORD       dwFindGCFlags
    )
// FindGC version of I_DRSGetMemberships
{
    FIND_DC_INFO *pGCInfo = NULL;
    ULONG        err = 0;           
    DWORD        dwStartTick = GetTickCount();
    DWORD        cAttempts = 0;

    do {
        if (pszPreferredDestGC == NULL) {
            // preferred destination dsa was not specified, or it was bad.
            if (err = FindGC(dwFindGCFlags, &pGCInfo) ) {
                // no more GCs left
                break;
            }
            pszPreferredDestGC = pGCInfo->addr;
            pszPreferredDestDnsDomainName = FIND_DC_INFO_DOMAIN_NAME(pGCInfo);
        }
        // reset status
        *pErrCode = STATUS_SUCCESS;

        err = I_DRSGetMemberships(
            pTHS,
            pszPreferredDestGC,
            pszPreferredDestDnsDomainName,
            dwFlags,
            ppObjects,
            cObjects,
            pLimitingDomain,
            OperationType,
            pErrCode,
            pcDsNames,
            prpDsNames,
            pAttributes,
            pcSidHistory,
            rgSidHistory
            );

        if (err == ERROR_SUCCESS || *pErrCode != STATUS_SUCCESS) {
            // Either the call was successful, or GC set the 
            // errCode, which means we got through to the GC.
            // In this case we should not fail over.
            if (pGCInfo) {
                THFreeEx(pTHS, pGCInfo);
            }
            break;
        }

        // Either connection to GC is bad, or this GC isn't
        // playing by the rules and is returning a version
        // I didn't ask for.
        pszPreferredDestGC = NULL;
        pszPreferredDestDnsDomainName = NULL;
        if (pGCInfo) {
            InvalidateGC(pGCInfo, err);
            THFreeEx(pTHS, pGCInfo);
        }

        // Check if we have timed out or made too many FindDC attempts
        // The subtraction takes care of DWORD wrap-around
        if (GetTickCount() - dwStartTick >= FIND_GC_TIMEOUT || ++cAttempts >= MAX_FIND_GC_ATTEMPTS) {
            err = ERROR_TIMEOUT;
            break;
        }
        // OK, we did not time out yet. Let's check another GC
    } while (TRUE);

    return err;
}

ULONG
draGetServerOutgoingCalls(
    IN  THSTATE *                   pTHS,
    OUT DS_REPL_SERVER_OUTGOING_CALLS **  ppCalls
    )
/*++

Routine Description:

    Returns a list of all outstanding server call contexts

Arguments:

    pTHS (IN)

    ppContexts (OUT) - On successful return, holds the client context list.

Return Values:

    Win32 error code.

--*/
{
    DS_REPL_SERVER_OUTGOING_CALLS *   pCalls;
    DS_REPL_SERVER_OUTGOING_CALL  *   pCall;
    DRS_CONTEXT_INFO *        pContextInfo;
    DWORD                       cb;
    DWORD                       iCtx;
    LIST_ENTRY *pListEntry;

    EnterCriticalSection(&gcsDrsRpcServerCtxList);
    __try {
        if (!gfDrsRpcServerCtxListInitialized) {
            InitializeListHead(&gDrsRpcServerCtxList);  
            Assert(0 == gcNumDrsRpcServerCtxListEntries);
            gfDrsRpcServerCtxListInitialized = TRUE;
        }

        cb = offsetof(DS_REPL_SERVER_OUTGOING_CALLS, rgCall)
             + sizeof(DS_REPL_SERVER_OUTGOING_CALL) * gcNumDrsRpcServerCtxListEntries;

        pCalls = THAllocEx(pTHS, cb);

        pListEntry = gDrsRpcServerCtxList.Flink;
        for (iCtx = 0; iCtx < gcNumDrsRpcServerCtxListEntries; iCtx++) {
            pCall = &pCalls->rgCall[iCtx];
            // Check list sanity
            Assert( pListEntry );
            Assert((pListEntry->Flink->Blink)==pListEntry);
            Assert((pListEntry->Blink->Flink)==pListEntry);

            pContextInfo = CONTAINING_RECORD(pListEntry,DRS_CONTEXT_INFO,ListEntry); 

            if (pContextInfo->pszServerName) {
                pCall->pszServerName =
                 THAllocEx( pTHS, (wcslen(pContextInfo->pszServerName) + 1)*sizeof(WCHAR) );
                wcscpy( pCall->pszServerName, pContextInfo->pszServerName );
            }
            pCall->fIsHandleBound = (pContextInfo->hDrs != NULL);
            pCall->fIsHandleFromCache = pContextInfo->fIsHandleFromCache;
            pCall->fIsHandleInCache = pContextInfo->fIsHandleInCache;
            pCall->dwThreadId = pContextInfo->dwThreadId;
            pCall->dwBindingTimeoutMins = pContextInfo->dwBindingTimeoutMins;
            pCall->dstimeCreated = pContextInfo->dstimeCreated;
            pCall->dwCallType = (DWORD) pContextInfo->eCallType;

            pListEntry = pContextInfo->ListEntry.Flink;
        }

        Assert(pListEntry == &gDrsRpcServerCtxList);
        pCalls->cNumCalls = gcNumDrsRpcServerCtxListEntries;
    }
    __finally {
        LeaveCriticalSection(&gcsDrsRpcServerCtxList);
    }

    *ppCalls = pCalls;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\drsserv\idlnotif.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       idlnotif.c
//
//--------------------------------------------------------------------------


/*

Description:
    Contains the RPC notification routines.

*/

#include <NTDSpch.h>
#pragma hdrstop

#include "drs.h"
#include <fileno.h>
#define  FILENO FILENO_DSNOTIF

void dsa_notify( void );

void IDL_DRSBind_notify (void)
{
        dsa_notify();
}

void IDL_DRSUnbind_notify (void)
{
        dsa_notify();
}

void IDL_DRSReplicaSync_notify (void)
{
        dsa_notify();
}

void IDL_DRSGetNCChanges_notify (void)
{
        dsa_notify();
}

void IDL_DRSUpdateRefs_notify (void)
{
        dsa_notify();
}

void IDL_DRSReplicaAdd_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaDel_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaModify_notify (void)
{
    dsa_notify();
}

void IDL_DRSVerifyNames_notify (void)
{
        dsa_notify();
}

void IDL_DRSGetMemberships_notify(void)
{
    dsa_notify();
}

void IDL_DRSInterDomainMove_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetNT4ChangeLog_notify (void)
{
    dsa_notify();
}

void IDL_DRSCrackNames_notify (void)
{
    dsa_notify();
}

void IDL_DRSWriteSPN_notify (void)
{
    dsa_notify();
}

void IDL_DRSRemoveDsServer_notify (void)
{
    dsa_notify();
}
void IDL_DRSRemoveDsDomain_notify (void)
{
    dsa_notify();
}

void IDL_DRSDomainControllerInfo_notify (void)
{
    dsa_notify();
}

void IDL_DRSAddEntry_notify (void)
{
    dsa_notify();
}

void IDL_DRSExecuteKCC_notify (void)
{
    dsa_notify();
}

void IDL_DRSAddSidHistory_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetMemberships2_notify (void)
{
    dsa_notify();
}

void IDL_DSAPrepareScript_notify (void)
{
    dsa_notify();
}

void IDL_DSAExecuteScript_notify (void)
{
    dsa_notify();
}

void IDL_DRSReplicaVerifyObjects_notify (void)
{
    dsa_notify();
}

void IDL_DRSGetObjectExistence_notify (void)
{
    dsa_notify();
}

void IDL_DRSQuerySitesByCost_notify (void)
{
    dsa_notify();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\dra\spnop.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       spnop.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module contains the core internal helper routines which implement
    the SPN apis.

    This is called from the ntdsapi stub functions in dsamain\dra\ntdsapi.c

    Callers are expected to have a valid thread state

Author:

    Will Lees (wlees) 26-Jan-97

Revision History:

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <mdlocal.h>                    // DSNAME manipulation routines
#include <dsatools.h>                   // Memory, etc.
#include <objids.h>                     // ATT_* definitions
#include <mdcodes.h>                    // Only needed for dsevent.h
#include <filtypes.h>                   // filter types
#include <dsevent.h>                    // Only needed for LogUnhandledError
#include <dsexcept.h>                   // exception handlers
#include <debug.h>                      // Assert()
#include <drs.h>                        // defines the drs wire interface
#include <drserr.h>                     // DRAERR_*
#include <drsuapi.h>                    // I_DRSCrackNames
#include <cracknam.h>                   // name cracking prototypes
#include <dominfo.h>                    // domain information prototypes
#include <anchor.h>                     // DSA_ANCHOR and gAnchor
#include <dsgetdc.h>                    // DsGetDcName
#include <lmcons.h>                     // MAPI constants req'd for lmapibuf.h
#include <lmapibuf.h>                   // NetApiBufferFree()

#define DEBSUB "DRASPN:"               // define the subsystem for debugging

#include <fileno.h>
#define  FILENO FILENO_SPNOP

// Static

// Forward

DWORD
modifySpn(
    IN DSNAME *pDn,
    IN USHORT Choice,
    IN DWORD cSpn,
    LPCWSTR *pSpn
    );

DWORD
mapApiErrorToWin32(
    THSTATE *pTHS,
    DWORD ApiError
    );

// End Forward




DWORD
SpnOperation(
    IN DWORD Operation,
    IN DWORD Flags,
    IN LPCWSTR Account,
    IN DWORD cSpn,
    IN LPCWSTR *pSpn
    )

/*++

Routine Description:

This routine executes the core part of a SPN operation.  It is called from
dsamain\dra\ntdsapi.c.

There should already be a thread state.

We should also be impersonating the client.

If initial validations fail, we return without doing anything.  Otherwise, we use
DirModifyEntry and it does what it wants.  I suspect if any complete successfully, it will
return success.

IMPROVEMENT: return a status for each SPN to distinguish individual success/failures

Arguments:

    Operation - 
        DS_SPN_ADD_SPN_OP - Adds cSpns to the SPN attr for Account. cSpn must be gt 1.
        DS_SPN_REPLACE_SPN_OP - If cSpn == 0, then this op deletes all SPNs from
            the account.  (i.e. replace with empty list).  If cSpn is gt 1, then
            we replace the existing SPNs with our new list.
        DS_SPN_DELETE_SPN_OP - Delete only the SPNs listed in cSpn/pSpn from the Account.
    Flags - (unused)
    Account - String DN of the account to modify the SPN attribute on.
    cSpn - Number of string SPNs in pSpn.
    pSpn - Actual SPNs

Return Value:

    Win32 error
    We convert from other internal forms if necessary

--*/

{
    DWORD status, length, i;
    THSTATE *     pTHS = pTHStls;
    USHORT choice;
    DSNAME *pDn = NULL;
    DWORD l1, l2;
    LPWSTR *pList;
    DWORD ret;

    DPRINT5( 2, "SpnOperation, Op=%d, Flags=0x%x, Account=%ws, cSpn=%d, Spn[0]=%ws\n",
             Operation, Flags, Account, cSpn,
             pSpn ? pSpn[0] : L"NULL" );

    // Validation routine called by the core during the update

    // Construct a DSNAME for the AccountDn
    l1 = wcslen( Account );
    l2 = DSNameSizeFromLen( l1 );

    pDn = (DSNAME *) THAllocEx(pTHS, l2 ); // thread allocd
    ZeroMemory( pDn, l2 );
    pDn->NameLen = l1;
    pDn->structLen = l2;
    wcscpy( pDn->StringName, Account );

    // Select the appropriate type of modify operation
    switch (Operation) {
    case DS_SPN_ADD_SPN_OP:
        // Must be non-zero number of SPNs to add
        if ( (cSpn == 0) || (pSpn == NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        // What if attribute doesn't exist?
        choice = AT_CHOICE_ADD_VALUES;
        break;
    case DS_SPN_REPLACE_SPN_OP:
        // Replacing with an empty list means remove the whole thing
        if ( (cSpn != 0) && (pSpn != NULL) ) {
            choice = AT_CHOICE_REPLACE_ATT;
        } else {
            choice = AT_CHOICE_REMOVE_ATT;
        }
        break;
    case DS_SPN_DELETE_SPN_OP:
        // Must be non-zero number of SPNs to delete
        if ( (cSpn == 0) || (pSpn == NULL) ) {
            return ERROR_INVALID_PARAMETER;
        }
        choice = AT_CHOICE_REMOVE_VALUES;
        break;
    default:
        return ERROR_INVALID_FUNCTION;
    }

    ret = modifySpn( pDn, choice, cSpn, pSpn );

    if(pDn != NULL) THFreeEx(pTHS, pDn);

    return ret;
} /* SpnOperation */


DWORD
modifySpn(
    IN DSNAME *pDn,
    IN USHORT Choice,
    IN DWORD cSpn,
    IN LPCWSTR *pSpn
    )

/*++

Routine Description:

Helper routine to form the DirModifyEntry call.  We issue one modification entry of
one attribute, with a varying number of values.

Arguments:

    pDn - DSNAME of object.  The object must have the ATT_SERVICE_PRINCIPAL_NAME attribute,
          currently a computer or user object.
    Choice - AT_CHOICE_xxx function for DirModifyEntry
    cSpn - Count of spns
    pSpn - Unicode string of spn values

Return Value:

    DWORD - Win32 Error Code

--*/

{
    THSTATE *pTHS=pTHStls;
    DWORD apiError, status, i;
    MODIFYARG ModArg;
    MODIFYRES *pModRes = NULL;
    COMMARG *pCommArg = NULL;
    ATTR Attr;
    ATTRVALBLOCK AttrValBlock;
    ATTRVAL *pAttrVal = NULL;

    // Allocate array of values
    if (cSpn) {
        pAttrVal = (ATTRVAL *) THAllocEx(pTHS, cSpn * sizeof( ATTRVAL ) );
        // This will raise exception on error
    }

    // Construct arguments to DirModifyEntry call

    RtlZeroMemory(&ModArg, sizeof(ModArg));

    ModArg.pObject = pDn;
    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = Choice;

    // Attribute value array contains list of values
    for( i = 0; i < cSpn; i++ ) {
        pAttrVal[i].valLen = wcslen( pSpn[i] ) * sizeof( WCHAR ); // no terminator!
        pAttrVal[i].pVal = (PUCHAR) pSpn[i];
    }

    AttrValBlock.valCount = cSpn;
    AttrValBlock.pAVal = pAttrVal;

    Attr.attrTyp = ATT_SERVICE_PRINCIPAL_NAME;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    InitCommarg(pCommArg);

    // No errors if attribute not there to begin with on REPLACE w/cSpn == 0
    // No errors if attribure already exists on ADD
    pCommArg->Svccntl.fPermissiveModify = TRUE;

    apiError = DirModifyEntry(&ModArg, &pModRes);

    status = mapApiErrorToWin32( pTHS, apiError );

    THFree( pModRes );

    DPRINT2( 3, "DirModifyEntry, apiError = %d, status = %x\n", apiError, status );

    if ( (cSpn) && (pAttrVal) ) {
        THFree( pAttrVal );
    }

    return status;
} /* modifySpn */


DWORD
mapApiErrorToWin32(
    THSTATE *pTHS,
    DWORD ApiError
    )

/*++

Routine Description:

    This clearly takes a Thread Dir Error, and maps it to the win32
    error.
    
    Code.Improvement, why not just use the existing function for this?

Arguments:

    pTHS - Thread State.
    ApiError - Should be equal to pTHS->errCode.

Return Value:

    Win32 Error Code.

--*/

{
    DWORD status;

    if (ApiError == 0) {
        return ERROR_SUCCESS;
    }

    Assert(pTHS->errCode == ApiError);

    switch (ApiError) {
    case attributeError:
    {
        ATRERR *pAtrErr = (ATRERR *) pTHS->pErrInfo;

        if (pAtrErr) {
            status = pAtrErr->FirstProblem.intprob.extendedErr;
        } else {
            status = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        }
        break;
    }
    case nameError:
    {
        NAMERR *pNamErr = (NAMERR *) pTHS->pErrInfo;

        if (pNamErr) {
            status = pNamErr->extendedErr;
        } else {
            status = DS_ERR_BAD_NAME_SYNTAX;
        }
        break;
    }
    case referralError:
    {
        REFERR *pRefErr = (REFERR *) pTHS->pErrInfo;

        if (pRefErr) {
            status = pRefErr->extendedErr;
        } else {
            status = DS_ERR_REFERRAL;
        }
        break;
    }
    case securityError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SecErr.extendedErr;
        } else {
            status = ERROR_ACCESS_DENIED;
        }
        break;
    case serviceError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SvcErr.extendedErr;
            // Special case variants of object not found
            if (status == ERROR_DS_MISSING_SUPREF) {
                status = ERROR_DS_OBJ_NOT_FOUND;
            }
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    case updError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->UpdErr.extendedErr;
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    case systemError:
        if (pTHS->pErrInfo) {
            status = pTHS->pErrInfo->SysErr.extendedErr;
        } else {
            status = DS_ERR_UNKNOWN_ERROR;
        }
        break;
    default:
        Assert( FALSE && "unknown error class code" );
        status = DS_ERR_UNKNOWN_ERROR;
        break;
    }

    return status;
}
/* end of spnop.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\anchor.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       anchor.h
//
//--------------------------------------------------------------------------

#ifndef _ANCHOR_
#define _ANCHOR_

/*-------------------------------------------------------------------------*/
/* These structures hold a cache of Knowledge used by the DSA */

/*The Cross reference points to an NC in another DSA (pCR).  The actual
  reference is stored as a child of this DSA with an arbitrary name Obj.
  Obj is variable length and extends contiguously below this structure.
  Elements in this linked-list are ordered by descending name size.
*/

typedef struct CROSS_REF_LIST{
   struct CROSS_REF_LIST *pPrevCR;           /* Prev Cross-Reference      */
   struct CROSS_REF_LIST *pNextCR;           /* Next Cross-Reference      */
   CROSS_REF CR;                             /* This Cross-Reference      */
}CROSS_REF_LIST;

/*Avoid the read of the NC head by caching the ATT_SUB_REFS attribute
  from the NC heads. Used in dsamain\src\mdsearch.c
*/
typedef struct _SUBREF_LIST SUBREF_LIST, *PSUBREF_LIST;
struct _SUBREF_LIST{
   PSUBREF_LIST pNextSubref;    /* Next entry on list         */
   PDSNAME      pDSName;        /* DSName struct              */
   DWORD        cAncestors;     /* entries in pAncestors      */
   DWORD        *pAncestors;    /* DNTs of DSName's ancestors */
};

typedef struct _COUNTED_LIST {
    ULONG          cNCs;        /* Number of NC DNTs in the pList */
    DWORD *        pList;       /* array of DNTs */
} COUNTED_LIST;


/* This structure contains Knowledge information used by this DSA */

typedef struct{
   CRITICAL_SECTION    CSUpdate;       /*To serialize updates to gAnchor*/
   // Try not to use the catalog pointers directly! 
   // They must be accessed using helper functions: see NCLEnumerator* in mddit.c
   // This ensures that global lists are visible through the filter of
   // transactional changes (i.e. added and deleted entries are visible)
   NAMING_CONTEXT_LIST *pMasterNC;     /*Master  NC list                 */
   NAMING_CONTEXT_LIST *pReplicaNC;    /*Replica NC list                 */
   CROSS_REF_LIST      *pCRL;          /*Cross Reference List           */
   DSNAME              *pDMD;          /*The name of DMD Object aka Schema NC DN */
   ULONG               ulDNTDMD;       /*DNT of the DMD Object          */
   DSNAME              *pLDAPDMD;      /*The name of LDAP DMD Object    */
   ULONG               ulDntLdapDmd;   /*The DNT of LDAP DMD Object     */
   SYNTAX_DISTNAME_STRING
                       *pDSA;          /*The name/address of this DSA   */
   DSNAME              *pDSADN;        /*The name of this DSA           */
   DSNAME              *pSiteDN;       /*The site name for this DSA     */
   DSNAME              *pDomainDN;     /*The name of this Domain for    */
                                       /* this DSA                      */
   ULONG               ulDNTDomain;    /* DNT of the Domain For this DSA*/
   DSNAME              *pRootDomainDN; /* Root Domain DN                */
   ULONG               ulDNTQuotas;    /* DNT of Quotas container */
   DSNAME              *pQuotasDN;     /* Quotas container DN */
   DSNAME              *pConfigDN;     /* Configuration container DN    */
   DSNAME              *pExchangeDN;   /* Exchange Config container DN  */
   ULONG               ulDNTConfig;    /*DNT of the Config container    */
   DSNAME              *pPartitionsDN; /* Partitions container DN       */
   DSNAME              *pDsSvcConfigDN;/* enterprise-wide DS config DN  */
   MTX_ADDR *pmtxDSA;                  /*MS tx addr for this DSA. RPC   */
                                       /* name format                   */
   unsigned            uDomainsInForest;/* count of domains in forest   */
   BOOL  fAmGC;                        /* is this DSA a global catalog? */
   BOOL  fAmVirtualGC;                 /* only one domain in enterprise */
   BOOL  fDisableInboundRepl;          /* is inbound repl disabled?     */
   BOOL  fDisableOutboundRepl;         /* is outbound repl disabled?    */
   ULONG *pAncestors;                  /*DNTs of local DSA's ancestors +*/
                                       /* local DSA                     */
   ULONG AncestorsNum;                 /* Number of DNTs in above array */
   ULONG *pUnDeletableDNTs;            /* Array of DNTs whose deletion  */
                                       /* the DSA should refuse         */
   unsigned UnDeletableNum;            /* Number of DNTs in above array */

/* Array of DNT ancestors of undeletable objects. The DSA will also refuse
   the deletion of these ancestors. Kept separate so we can rebuild the list
   of ancestors when objects in the undeletable list are reparented */

   ULONG *pUnDelAncDNTs;               /* Undeletable ancestors DNTs    */
   unsigned UnDelAncNum;               /* Number of DNTs in above array */
   ULONG ulDefaultLanguage;            /*Default locale for random      */
                                       /* localized index (see jetnsp.c)*/
   ULONG ulNumLangs;                   /* The number of locales this ds */
                                       /* supports.                     */
   ULONG *pulLangs;                    /* buffer of DWORDS holding lang */
                                       /* ids supported by this DSA. 1st*/
                                       /* dword is size of buffer in    */
                                       /* dwords.  Note that the buffer */
                                       /* is allocated and filled       */
                                       /* dynamically, so ulNumLangs is */
                                       /* always <= pulLangs[0]         */
   GLOBALDNREADCACHE *MainGlobal_DNReadCache;   // The DNReadCache.
   WCHAR * pwszRootDomainDnsName;      /*DNS name of the root of the    */
                                       /*  enterprise DNS tree          */
   PWCHAR  pwszHostDnsName;            /*DNS Name of the machine        */
   PDSNAME pInfraStructureDN;          /* DN of the domain              */
                                       /*         infrastructure object */
   DRS_EXTENSIONS_INT *                /*DRS extensions info for the    */
       pLocalDRSExtensions;            /* local DSA                     */
   
   PSECURITY_DESCRIPTOR pDomainSD;     /* The Security Descriptor on our*/
                                       /* domain head.                  */

/*Avoid the read of the NC head by caching the ATT_SUB_REFS attribute
  from the NC heads. Used in dsamain\src\mdsearch.c.
*/
   BOOL         fDomainSubrefList; /* pDomainSubrefList is valid    */
   ULONG        cDomainSubrefList; /* #entries on pDomainSubrefList */
   PSUBREF_LIST pDomainSubrefList; /* cached ATT_SUB_REFS           */
   BOOL         fAmRootDomainDC;   /* true if this DSA is in root domain */

   ULONG        SiteOptions;       /* value of the options on the ntds */
                                   /* site settings object */
/*
   Keep the domain policy regarding max password age and LockoutDuration
   in order to speed up the computation of the attribute msDsUserAccount-
   ControlComputed
*/
   LARGE_INTEGER MaxPasswordAge;   /* Maximum password age in the domain */
   LARGE_INTEGER LockoutDuration;  /* Lockout duration in the domain     */

   LONG    ForestBehaviorVersion;  /*the behavior version of the forest*/
   LONG    DomainBehaviorVersion;  /*the behavior version of the domain*/

   UUID *  pCurrInvocationID;      /* the invocation ID to be used by new */
                                   /* threads; don't ref directly, use    */
                                   /* pTHS->InvocationID                  */
   BOOL     fSchemaUpgradeInProgress;       /* schupgr is running */
   COUNTED_LIST * pNoGCSearchList;  /* This is the list of NCs that     */
                                    /* should not be searched on a GC   */
                                    /* based search.  This data structure*/
                                    /* consists of two parts, an array  */
                                    /* of elements and an count. This   */
                                    /* is done so the updates to both   */
                                    /* count and array, can be done     */
                                    /* simultaneously.  This pointer    */
                                    /* however maybe NULL if there is   */
                                    /* no NC that should not be searched*/
                                    /* , which is actually the expected */
                                    /* case */
   /* NULL-terminated array of allowed DNS suffixes */
   /* see mdupdate:DNSHostNameValueCheck */
   PWCHAR   *allowedDNSSuffixes;
   PWCHAR   additionalRootDomainName;  // the previous root domain name (before the rename of the domain)

   struct _REPL_DSA_SIGNATURE_VECTOR * pSigVec;    // Cached copy of old invocation id's
   DSNAME              *pComputerDN; /* Computer Object DN       */

   ULONG   ulDNTSystem;            /* DNT of the system container*/

   BOOL    fQuotaTableReady;		//	set to FALSE while Quota table is being asynchronously rebuilt
   ULONG   ulQuotaRebuildDNTLast;	//	last DNT that Quota rebuild task has processed (only valid if fQuotaTableReady is FALSE)
   ULONG   ulQuotaRebuildDNTMax;	//	highest DNT that the Quota rebuild task will process (only valid if fQuotaTableReady is FALSE)
}DSA_ANCHOR;


extern DSA_ANCHOR gAnchor;

#endif /* _ANCHOR_ */

/* end anchor.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\exe\dsatest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dsatest.c
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file implements a suite of tests to exercise the DSA with the
    intent of flushing out core, dblayer and Jet concurrency and loading
    problems.  It is derived from the original OFS (Object File System)
    propq DRT on \\savik\win40\src\drt\propq.

    NOTE how we want to be as external an in-process client as
    we can be so as not to leverage internals.

Author:

    DaveStr     06-May-97

Environment:

    User Mode - Win32

Revision History:

--*/

#include <ntdspch.h>
#pragma hdrstop

// Core DSA headers.
#include <ntdsa.h>
#include <attids.h>                     // ATT_*
#include <mappings.h>                   // SampSetDsa()
#include <sddl.h>                       // ConvertStringSecurityDescriptor...()

typedef enum _Operation {
    OP_ADD              = 0,
    OP_DELETE           = 1,
    OP_SEARCH           = 2,
    OP_DELAY            = 3
} Operation;

typedef enum _QueryOption {
    QOPT_DONTCARE       = 0,        // don't care how many objects are found
    QOPT_ASCENDING      = 1,        // successive queries should find more objs
    QOPT_DESCENDING     = 2,        // successive queries should find less objs
    QOPT_EXACTMATCH     = 3         // Assert(cFound == cExpected)
} QueryOption;

// Globals

CHAR *rpszOperation[] = { "OP_ADD",
                          "OP_DELETE",
                          "OP_SEARCH",
                          "OP_DELAY" };

CHAR *rpszQueryOption[] = { "DON'T CARE",
                            "ASCENDING",
                            "DESCENDING",
                            "EXACT MATCH" };

BOOL                gfVerbose = FALSE;
DWORD               gcObjects = 100000;
DWORD               gcThreads = 50;
DWORD               gcDelaySec = 0;

CHAR                TestRootBuffer[1000];
DSNAME              *gTestRoot = (DSNAME *) TestRootBuffer;

#define             ATT_OBJECT_NUM ATT_FLAGS
SYNTAX_INTEGER      DefaultObjectNum = 0;
ATTRVAL             DefaultObjectNumVal = {sizeof(SYNTAX_INTEGER),
                                           (UCHAR *) &DefaultObjectNum};
SYNTAX_OBJECT_ID    DefaultObjectClass = CLASS_CONTAINER;
ATTRVAL             DefaultObjectClassVal = {sizeof(SYNTAX_OBJECT_ID),
                                             (UCHAR *) &DefaultObjectClass};
CHAR                DefaultSDBuffer[1000];
ATTRVAL             DefaultSDVal = {0, (UCHAR *) DefaultSDBuffer};
ATTR                DefaultAttrs[3] = {{ATT_OBJECT_NUM,
                                       {1, &DefaultObjectNumVal}},
                                       {ATT_OBJECT_CLASS,
                                       {1, &DefaultObjectClassVal}},
                                       {ATT_NT_SECURITY_DESCRIPTOR,
                                       {1, &DefaultSDVal}}};
ATTRBLOCK           DefaultAttrBlock = { 3, DefaultAttrs };
COMMARG             DefaultCommArg;

void _Abort(
    DWORD   err,
    CHAR    *psz,
    int     line)
{
    fprintf(stderr,
            "Abort - line(%d) err(%08lx) %s %s\n",
            line,
            err,
            (psz ? "" : "==>"),
            (psz ? "" : psz));

    DebugBreak();
}

#define Abort(err, psz) _Abort(err, psz, __LINE__)

DSNAME * DSNameFromNum(
    DWORD objectNum)
{
    DSNAME  *pDSName;
    WCHAR   buf[1000];
    DWORD   cChar;
    DWORD   cBytes;

    swprintf(buf, L"CN=DsaTest_%08d,", objectNum);
    wcscat(buf, gTestRoot->StringName);
    cChar = wcslen(buf);
    cBytes = DSNameSizeFromLen(cChar);
    pDSName = (DSNAME *) THAlloc(cBytes);
    pDSName->structLen = cBytes;
    pDSName->NameLen = cChar;
    wcscpy(pDSName->StringName, buf);

    return(pDSName);
}

VOID DoObject(
    Operation   op,
    DWORD       objectNum)
{
    DWORD   err;
    DWORD   i;

    // Create thread state.

    if ( THCreate( CALLERTYPE_INTERNAL ) )
        Abort(1, "THCreate");

    // Avoid security issues.

    SampSetDsa(TRUE);

    switch ( op )
    {
    case OP_ADD:
    {
        ADDARG              addArg;
        ADDRES              *pAddRes = NULL;
        SYNTAX_INTEGER      ThisObjectNum = objectNum;
        ATTRVAL             ThisObjectNumVal = {sizeof(SYNTAX_INTEGER),
                                                (UCHAR *) &ThisObjectNum};
        SYNTAX_OBJECT_ID    ThisObjectClass = CLASS_CONTAINER;
        ATTRVAL             ThisObjectClassVal = {sizeof(SYNTAX_OBJECT_ID),
                                                  (UCHAR *) &ThisObjectClass};
        ATTRVAL             ThisSDVal = {0, (UCHAR *) NULL};
        ATTR                ThisAttrs[3] = {{ATT_OBJECT_NUM,
                                            {1, &ThisObjectNumVal}},
                                            {ATT_OBJECT_CLASS,
                                            {1, &ThisObjectClassVal}},
                                            {ATT_NT_SECURITY_DESCRIPTOR,
                                            {1, &ThisSDVal}}};
        ATTRBLOCK           ThisAttrBlock = { 3, ThisAttrs };
        

        // Construct add arguments.

        memset(&addArg, 0, sizeof(ADDARG));
        addArg.pObject = DSNameFromNum(objectNum);
        addArg.AttrBlock = ThisAttrBlock;
        addArg.CommArg = DefaultCommArg;

        // Core mangles/replaces some properties on us, eg: security desc.,
        // so we allocate new values where appropriate.

        ThisSDVal.valLen = DefaultSDVal.valLen;
        ThisSDVal.pVal = (UCHAR *) THAlloc(ThisSDVal.valLen);
        memcpy(ThisSDVal.pVal, DefaultSDVal.pVal, ThisSDVal.valLen);

        // Do the add.

        err = DirAddEntry(&addArg, &pAddRes);

        if ( err )
            Abort(err, "DirAddEntry");

        break;
    }

    case OP_DELETE:
    {
        REMOVEARG   removeArg;
        REMOVERES   *pRemoveRes = NULL;

        // Construct remove arguments.

        memset(&removeArg, 0, sizeof(REMOVEARG));
        removeArg.pObject = DSNameFromNum(objectNum);
        removeArg.fPreserveRDN = FALSE;
        removeArg.fGarbCollectASAP = FALSE;
        removeArg.CommArg = DefaultCommArg;

        // Do the remove.

        err = DirRemoveEntry(&removeArg, &pRemoveRes);

        if ( err )
            Abort(err, "DirRemoveEntry");

        break;
    }

    case OP_DELAY:
    {
        READARG     readArg;
        READRES     *pReadRes;

        // Construct read arguments.

        memset(&readArg, 0, sizeof(READARG));
        readArg.pObject = gTestRoot;
        readArg.pSel = NULL;
        readArg.CommArg = DefaultCommArg;

        // Do a read to open the transaction.

        DirTransactControl(TRANSACT_BEGIN_DONT_END);
        err = DirRead(&readArg, &pReadRes);

        if ( err )
            Abort(err, "DirReadEntry - begin delay");

        // Delay - interpret objectNum as second count.

        Sleep(objectNum * 1000);

        // Do a read to close the transaction.

        DirTransactControl(TRANSACT_DONT_BEGIN_END);
        err = DirRead(&readArg, &pReadRes);

        if ( err )
            Abort(err, "DirReadEntry - end delay");

        break;
    }

    default:

        Abort(1, "Unknown test operation");
    }

    // Clean up thread state.

    if ( THDestroy() )
        Abort(1, "THDestroy");
}

VOID DoObjectsSingleThreaded(
    Operation   op,
    DWORD       objectNumLow,
    DWORD       objectNumHigh)
{
    DWORD   i;
    DWORD   start = GetTickCount();

    if ( gfVerbose )
        fprintf(stderr,
                "DoObjectsSingleThreaded(%s, [%d..%d]) ...\n",
                rpszOperation[op],
                objectNumLow,
                objectNumHigh);

    for ( i = objectNumLow; i <= objectNumHigh; i++ )
        DoObject(op, i);

    if ( gfVerbose )
        fprintf(stderr,
                "Sequential %s of [%d..%d] ==> %d/sec\n",
                rpszOperation[op],
                objectNumLow,
                objectNumHigh,
                ((objectNumHigh - objectNumLow) * 1000) /
                                        (GetTickCount() - start));
}

typedef struct _DoArgs {
    Operation   op;
    DWORD       objectNumLow;
    DWORD       objectNumHigh;
} DoArgs;

ULONG __stdcall _DoObjects(
    VOID *arg)
{
    DoArgs *p = (DoArgs *) arg;

    DoObjectsSingleThreaded(p->op,
                            p->objectNumLow,
                            p->objectNumHigh);
    return(0);
}

VOID DoObjectsMultiThreaded(
    Operation   op,
    DWORD       backgroundTransactionDuration)
{
    DWORD   i, err, numLow;
    DWORD   start = GetTickCount();
    DWORD   cObjectsPerThread = gcObjects / gcThreads;
    HANDLE  *rh = (HANDLE *) alloca(gcThreads * sizeof(HANDLE));
    DWORD   *rid = (DWORD *) alloca(gcThreads * sizeof(DWORD));
    DoArgs  *rargs = (DoArgs *) alloca(gcThreads * sizeof(DoArgs));

    if ( gfVerbose )
        fprintf(stderr,
                "DoObjectsMultiThreaded(%s) ...\n",
                rpszOperation[op]);

    // Spawn a DoObjects() for each cObjectsPerThread.

    numLow = 0;

    for ( i = 0; i < gcThreads; i++ )
    {
        rargs[i].op = op;
        rargs[i].objectNumLow = numLow;
        rargs[i].objectNumHigh = numLow + cObjectsPerThread - 1;

        rh[i] = CreateThread(NULL,                      // security attrs
                             0,                         // default stack size
                             _DoObjects,                // start routine
                             (VOID *) &rargs[i],        // start argument
                             0,                         // creation flags
                             &rid[i]);                  // thread id

        if ( NULL == rh[i] )
            Abort(GetLastError(), "CreateThread");

        numLow += cObjectsPerThread;
    }

    if ( !backgroundTransactionDuration )
    {
        // Wait for all the threads to complete.

        err = WaitForMultipleObjects(gcThreads,
                                     rh,
                                     TRUE,              // wait for all
                                     INFINITE);

        if ( WAIT_FAILED == err )
            Abort(GetLastError(), "WaitForMultipleObjects");
    }
    else
    {
        // Loop performing background delay and wait for all
        // threads to complete.

#pragma warning(disable:4296)
        while ( TRUE )
        {
            DoObject(OP_DELAY, backgroundTransactionDuration);

            err = WaitForMultipleObjects(gcThreads,
                                         rh,
                                         TRUE,              // wait for all
                                         0);

            if ( WAIT_TIMEOUT == err )
            {
                continue;
            }
            // The following test generates an error 4296, because it turns
            // out that WAIT_OBJECT_0 is 0, and unsigned err can never be neg.
            else if (    (WAIT_OBJECT_0 <= err)
                      && ((WAIT_OBJECT_0 + gcThreads - 1) >= err) )
            {
                break;
            }
            else
            {
                Abort(GetLastError(), "WaitForMultipleObjects");
            }
        }
#pragma warning(default:4296)
    }

    for ( i = 0; i < gcThreads; i++ )
        CloseHandle(rh[i]);

    if ( gfVerbose )
        fprintf(stderr,
                "Concurrent %s of [%d..%d] ==> %d/sec\n",
                rpszOperation[op],
                0,
                gcObjects - 1,
                (gcObjects * 1000) / (GetTickCount() - start));
}

VOID CheckQueryResult(
    QueryOption opt,
    int         iteration,
    int         cExpected,
    int         cFound,
    int         *pcPrevFound)
{
    char buf[256];

    switch ( opt )
    {
    case QOPT_DONTCARE:

        break;

    case QOPT_ASCENDING:

        if ( 0 != iteration )
        {
            if ( cFound < *pcPrevFound )
            {
                sprintf(
                    buf,
                    "Query(%s), Restriction(%d), cFound(%d), cPrevFound(%d)",
                    rpszQueryOption[opt],
                    iteration,
                    cFound,
                    *pcPrevFound);

                Abort(1, buf);
            }
        }

        break;

    case QOPT_DESCENDING:

        if ( 0 != iteration )
        {
            if ( *pcPrevFound < cFound )
            {
                sprintf(
                    buf,
                    "Query(%s), Restriction(%d), cFound(%d), cPrevFound(%d)",
                    rpszQueryOption[opt],
                    iteration,
                    cFound,
                    *pcPrevFound);

                Abort(1, buf);
            }
        }

        break;

    case QOPT_EXACTMATCH:

        if ( cExpected != cFound )
        {
            sprintf(
                buf,
                "Query(%s), Restriction(%d), cFound(%d), cExpected(%d)",
                rpszQueryOption[opt],
                iteration,
                cFound,
                cExpected);

            Abort(1, buf);
        }

        break;

    default:

        Abort(1, "Invalid case value");
        break;

    }

    *pcPrevFound = cFound;
}

/*
    // Check or modify the results depending on what the query options
    // are.  Due to a lack of knowledge about how parallel queries run,
    // we can't assert much about the return count if ASCENDING or DESCENDING
    // was specified.  In those cases, we do a worst case analysis and
    // return the min or max respectively.  I.e. in the ASCENDING case,
    // return cFound value from the query which found the least objects.
    // Thus a caller who makes successive QueryObjectsMultiThreaded calls
    // can call CheckQueryResult(ASCENDING) on each returned *pcFound value
    // and expect the check to succeed as long as in each pass, one of
    // the parallel queries found equal or more objects than on the previous
    // pass.  Ditto, but inversed, for DESCENDING.

    switch ( opt )
    {
        case QOPT_DONTCARE:
        case QOPT_ASCENDING:

            *pcFound = rargs[0].cFound;

            for ( i = 1; i < cRest; i++ )
                if ( rargs[i].cFound < *pcFound )
                    *pcFound = rargs[i].cFound;

            break;

        case QOPT_DESCENDING:

            *pcFound = rargs[0].cFound;

            for ( i = 1; i < cRest; i++ )
                if ( rargs[i].cFound > *pcFound )
                    *pcFound = rargs[i].cFound;

            break;

        case QOPT_EXACTMATCH:

            for ( i = 0; i < cRest; i++ )
            {
                if ( cExpected != rargs[i].cFound )
                {
                    sprintf(buf,
                            "Restriction(%d) - expected(%d) != found(%d)",
                            i, cExpected, rargs[i].cFound);

                    int j = 0;
                    int k = 0;

                    if ( 0 != awid )
                    {
                        while ( j < cExpected && k < rargs[i].cFound )
                        {
                            if ( awid[j] < rargs[i].awid[k] )
                            {
                                if ( fVerbose )
                                    printf( "Restriction(%d) - missing wid %u\n", i, awid[j] );

                                while ( awid[j] < rargs[i].awid[k] && j < cExpected )
                                    j++;
                            }

                            else if ( awid[j] > rargs[i].awid[k] )
                            {
                                if ( fVerbose )
                                    printf( "Restriction(%d) - extra wid %u\n", i, rargs[i].awid[k] );

                                while ( awid[j] > rargs[i].awid[k] && k < rargs[i].cFound )
                                    k++;
                            }

                            else
                            {
                                j++;
                                k++;
                            }
                        }

                    }

                    Abort(E_FAIL, buf);
                }
            }

            *pcFound = rargs[0].cFound;
            break;

        default:

            Abort(E_FAIL, "Invalid case value");
            break;
    }

    for ( i = 0; i < cRest; i++ )
        delete [] rargs[i].awid;

    if ( fVerbose )
    {
        printf("Concurrent queries(%d) of %d objects ==> %d seconds\n",
               cRest,
               *pcFound,
               (GetTickCount() - start) / 1000);
        fflush(stdout);
    }
*/

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

ULONG __stdcall _DsaTest(
    VOID *pUnused)
{
    NTSTATUS            status;
    DWORD               cb;
    SECURITY_DESCRIPTOR *pSD;
    DWORD               arg;
    int                 scan;
    CHAR                ch;

    fprintf(stderr,
            "DsaTest waiting for delayed startup to complete ...\n");

    // DsWaitUntilDelayedStartupIsDone() only works once
    // hevDelyedStartupDone is initialized somewhere in the
    // DsaExeStartRoutine() path.  We can't spin/wait till this
    // event is initialized so we just wait 5 seconds assuming
    // that all of ntdsa's events get initialized early on.

    Sleep(5000);

    status = DsWaitUntilDelayedStartupIsDone();

    if ( !NT_SUCCESS(status) )
        Abort(status, "DsWaitUntilDelayedStartupIsDone");

    fprintf(stderr,
            "DsaTest starting ...\n");

    // Initialize miscellaneous globals.

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
            L"O:AOG:DAD:(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-0-0)",
            SDDL_REVISION_1,
            &pSD,
            &cb)) {
        status = GetLastError();
        Abort(status, "ConvertStringSecurityDescriptorToSecurityDescriptorW");
    }

    if ( cb > sizeof(DefaultSDBuffer) )
        Abort(1, "DefaultSDBuffer overflow");

    DefaultSDVal.valLen = cb;
    memcpy(DefaultSDBuffer, pSD, cb);
    LocalFree(pSD);

    cb = sizeof(TestRootBuffer);

    status = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                  &cb,
                                  gTestRoot);

    if ( !NT_SUCCESS(status) )
        Abort(status, "GetConfigurationName");

    InitCommarg(&DefaultCommArg);

    // See if caller likes the setup.

    fprintf(stdout, "*********************************\n");
    fprintf(stdout, "*                               *\n");
    fprintf(stdout, "* In-process DSA/JET Excerciser *\n");
    fprintf(stdout, "*                               *\n");
    fprintf(stdout, "*********************************\n\n");


    while ( TRUE )
    {
        fprintf(stdout, "All input is numeric decimal\n");

        // gfVerbose

        fprintf(stdout, "Verbose[%d] ", gfVerbose);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gfVerbose = arg;

        // gcObjects

        fprintf(stdout, "Objects[%d] ", gcObjects);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gcObjects = arg;

        // gcThreads

        fprintf(stdout, "Threads[%d] ", gcThreads);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
            gcThreads = arg;

        // gcDelaySec

        fprintf(stdout,
                "Background transaction duration (secs) [%d] ",
                gcDelaySec);
        fflush(stdout);
        scan = fscanf(stdin, "%d", &arg);

        if ( (0 != scan) && (EOF != scan) )
        gcDelaySec = arg;

        fprintf(stdout,
                "Testing with: verbose(%d) objects(%d) threads(%d) delay(%d)\n",
                gfVerbose,
                gcObjects,
                gcThreads,
                gcDelaySec);

        fprintf(stdout, "Are these parameters OK [y/n] ? ");
        fflush(stdout);
        ch = (CHAR)getchar();

        while ( ('y' != ch) && ('Y' != ch) && ('n' != ch) && ('N' != ch) )
            ch = (CHAR)getchar();

        if ( ('y' == ch) || ('Y' == ch) )
            break;
    }

    // Run the test.

    DoObjectsMultiThreaded(OP_ADD, gcDelaySec);
    DoObjectsMultiThreaded(OP_DELETE, gcDelaySec);

    fprintf(stderr,
            "DsaTest passed!\n");

    return(0);
}

void DsaTest(void)
{
    HANDLE  h;
    DWORD   id;

    // Start async thread so we don't block DSA startup.

    h = CreateThread(NULL,                  // security attrs
                     0,                     // default stack size
                     _DsaTest,              // start routine
                     NULL,                  // start argument
                     0,                     // creation flags
                     &id);                  // thread id

    if ( h )
    {
        CloseHandle(h);
        return;
    }

    Abort(GetLastError(), "CreateThread");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\checkacl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       checkacl.h
//
//--------------------------------------------------------------------------

typedef enum AclError
{
    AclErrorNone = 0,
    AclErrorGetSecurityDescriptorDacl,
    AclErrorGetAce,
    AclErrorParentAceNotFoundInChild,
    AclErrorAlgorithmError,
    AclErrorInheritedAceOnChildNotOnParent
} AclError;

typedef ULONG (*AclPrintFunc)(char *, ...);

typedef void (*LookupGuidFunc)(GUID *pg, CHAR **ppName, CHAR **ppLabel, BOOL *pfIsClass);

typedef CHAR * (*LookupSidFunc)(PSID pSID);

DWORD
CheckAclInheritance(
    PSECURITY_DESCRIPTOR pParentSD,             // IN
    PSECURITY_DESCRIPTOR pChildSD,              // IN
    GUID                **pChildClassGuids,     // IN
    DWORD               cChildClassGuids,       // IN
    AclPrintFunc        pfn,                    // IN
    BOOL                fContinueOnError,       // IN
    BOOL                fVerbose,               // IN
    DWORD               *pdwLastError);         // OUT

void
DumpAcl(
    PACL    pAcl,           // IN
    AclPrintFunc pfn,       // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid   // IN
    );

void
DumpAclHeader(
    PACL    pAcl,           // IN
    AclPrintFunc pfn);      // IN

void
DumpSD(
    SECURITY_DESCRIPTOR *pSD,        // IN
    AclPrintFunc        pfn,         // IN 
    LookupGuidFunc      pfnguid,     // IN
    LookupSidFunc       pfnsid);     // IN

void DumpSDHeader (SECURITY_DESCRIPTOR *pSD,        // IN
                   AclPrintFunc        pfn);        // IN


void DumpGUID (GUID *Guid,           // IN
               AclPrintFunc pfn);    // IN

void DumpSID (PSID pSID,             // IN
              AclPrintFunc pfn);     // IN

void
DumpAce(
    ACE_HEADER     *pAce,   // IN
    AclPrintFunc   pfn,     // IN
    LookupGuidFunc pfnguid, // IN
    LookupSidFunc  pfnsid); // IN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\bhcache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bhcache.h
//
//--------------------------------------------------------------------------

#ifndef __BHCACHE_H__
#define __BHCACHE_H__

// DaveStr - 3/21/97
// Changed the cache to handle multiple concurrent users,
// the option to not cache a handle, and to provide credentials.
// See comments on FGetRpcHandle for the general algorithm.

typedef struct _BHCacheElement  {
    DRS_HANDLE hDrs;
    union {
        BYTE rgbRemoteExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS extRemote;
    };
    LPWSTR  pszServer;
    DWORD   cchServer; // includes null terminator
    LPWSTR  pszServerPrincName;
    DWORD   cRefs;
    BOOL    fDontUse;
    BOOL    fLocked;
    DWORD   cTickLastUsed;
    
    union {
        BYTE rgbLocalExt[CURR_MAX_DRS_EXT_STRUCT_SIZE];
        DRS_EXTENSIONS extLocal;
    };
} BHCacheElement;

#define BHCacheSize 256

// Following validation check insures that the hash is good and that
// all fields are set/cleared in unison.

#define VALIDATE_BH_ENTRY(i)                                        \
    Assert(   (i < BHCacheSize)                                     \
           && (   (    rgBHCache[i].pszServer                       \
                    && rgBHCache[i].cchServer                       \
                    && rgBHCache[i].hDrs                            \
                    && rgBHCache[i].cRefs)                          \
               || !memcmp(&rgBHCache[i],                            \
                          &NullBHCacheElement,                      \
                          sizeof(NullBHCacheElement))))

extern BHCacheElement rgBHCache[BHCacheSize];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\cracknam.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       cracknam.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines various name cracking APIs.

Author:

    Dave Straube (davestr) 8/17/96

Revision History:

    Dave Straube (davestr) 10/20/97
        Removed friendly names and added UPN format.

--*/

#ifndef __CRACKNAM_H__
#define __CRACKNAM_H__

#include <ntdsapip.h>           // #defines for CrackNamesEx

typedef struct 
{
    DWORD   dwFlags;
    ULONG   CodePage;
    ULONG   LocaleId;
    DWORD   formatOffered;
    DWORD   status;
    DSNAME  *pDSName;
    WCHAR   *pDnsDomain;
    WCHAR   *pFormattedName;

} CrackedName;

extern
BOOL
CrackNameStatusSuccess(
    DWORD       status);

extern 
WCHAR *
Tokenize(
    WCHAR       *pString,
    WCHAR       *separators,
    BOOL        *pfSeparatorFound,
    WCHAR       **ppNext);

extern
BOOL
Is_DS_FQDN_1779_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_NT4_ACCOUNT_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_DISPLAY_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_NT4_ACCOUNT_NAME_SANS_DOMAIN(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_DS_ALT_SECURITY_IDENTITIES_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_UNIQUE_ID_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL 
Is_DS_CANONICAL_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_UNIVERSAL_PRINCIPAL_NAME(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
BOOL
Is_DS_CANONICAL_NAME_EX(
    WCHAR       *pName,
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_FQDN_1779_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_NT4_ACCOUNT_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_DISPLAY_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_UNIQUE_ID_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_CANONICAL(
    THSTATE     *pTHS,
    CrackedName *pCrackedName, 
    WCHAR       **ppLastSlash);

//extern
//VOID
//DSNAME_To_DS_CANONICAL_NAME(
//    CrackedName *pCrackedName);

#define DSNAME_To_DS_CANONICAL_NAME(p) DSNAME_To_CANONICAL(pTHS, p, NULL)

extern
VOID
DSNAME_To_DS_UNIVERSAL_PRINCIPAL_NAME(
    CrackedName *pCrackedName);

extern
VOID
DSNAME_To_DS_CANONICAL_NAME_EX(
    THSTATE     *pTHS,
    CrackedName *pCrackedName);

extern
VOID
CrackNames(
    DWORD       dwFlags,
    ULONG       codePage,
    ULONG       localeId,
    DWORD       formatOffered,
    DWORD       formatDesired,
    DWORD       cNames,
    WCHAR       **rpNames,
    DWORD       *pcNamesOut,
    CrackedName **prCrackedNames);

NTSTATUS
CrackSingleNameEx(
    THSTATE     *pTHS,
    DWORD       formatOffered,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       dwFlags,                // DS_NAME_FLAG mask
    WCHAR       *pNameIn,               // name to crack
    DWORD       formatDesired,          // one of DS_NAME_FORMAT in ntdsapi.h
    DWORD       *pccDnsDomain,          // char count of following argument
    PWCHAR      *ppDnsDomain,           // buffer for DNS domain name
    DWORD       *pccNameOut,            // char count of following argument
    PWCHAR      *ppNameOut,             // buffer for formatted name
    DWORD       *pErr);                 // one of DS_NAME_ERROR in ntdsapi.h


extern
VOID
ProcessFPOsExTransaction(
    DWORD       formatDesired,
    DWORD       cNames,
    CrackedName *rNames);

extern DWORD LdapMaxQueryDuration;

#define SetCrackSearchLimits(pCommArg)                          \
    (pCommArg)->StartTick = GetTickCount();                     \
    (pCommArg)->DeltaTick = 1000 * LdapMaxQueryDuration;        \
    (pCommArg)->Svccntl.localScope = TRUE;


#endif // __CRACKNAM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\direrr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       direrr.h
//
//--------------------------------------------------------------------------

/***********************************************
 *
 * This file is a relic.
 *
 * !!! DO NOT ADD ANY NEW LINES TO THIS FILE !!!
 *
 * DIRERRs are now #defined to be errors out of winerror.h.  If you
 * need a new error, define it in %_NTROOT%\windows\nlsmsg\winerror.w in the
 * windows project and rebuild winerror.h. (build from %_NTROOT%\windows)
 * (a faster way is to "nmake -f makefil0" from windows)
 *
 * Over time, we should find users of DIRERRs and change them to use the DS_ERRs
 * defined in winerror.h.  When a DIRERR is no longer used, it should be removed
 * from this file.  Eventually, this file should become empty.
 *
 * Part of this process is to look in winerror.w to see if the explanatory text
 * for the error matches what you are really trying to report.  If it does,
 * change the use of DIRERR_foo to DS_ERR_foo.  If the text doesn't match,
 * create a new DS_ERR_bar, or find one already in the file that is appropriate.
 * When you remove the last use of DIRERR_foo, remove the definition from this
 * file. 
 *
 * Explicitly, this file could be removed, but for now it is used to keep track
 * of which errors we've looked at to make sure we are setting an appropriate
 * error.
 *
 * Once again, do not add lines to this file, and avoid using DIRERRs at all.
 * Use DS_ERRs
 *
 * April 17, 1998
 *   DS_ERR_* were renamed to ERROR_DS_* in winerror.h
 *
 */
#define DIRERR_ADD_REPLICA_INHIBITED      ERROR_DS_ADD_REPLICA_INHIBITED      
#define DIRERR_ALIASED_OBJ_MISSING        ERROR_DS_ALIASED_OBJ_MISSING        
#define DIRERR_ALIAS_POINTS_TO_ALIAS      ERROR_DS_ALIAS_POINTS_TO_ALIAS      
#define DIRERR_ATTRIBUTE_OWNED_BY_SAM     ERROR_DS_ATTRIBUTE_OWNED_BY_SAM     
#define DIRERR_ATT_ALREADY_EXISTS         ERROR_DS_ATT_ALREADY_EXISTS         
#define DIRERR_ATT_IS_NOT_ON_OBJ          ERROR_DS_ATT_IS_NOT_ON_OBJ          
#define DIRERR_ATT_NOT_DEF_IN_SCHEMA      ERROR_DS_ATT_NOT_DEF_IN_SCHEMA      
#define DIRERR_ATT_SCHEMA_REQ_ID          ERROR_DS_ATT_SCHEMA_REQ_ID          
#define DIRERR_ATT_SCHEMA_REQ_SYNTAX      ERROR_DS_ATT_SCHEMA_REQ_SYNTAX      
#define DIRERR_ATT_VAL_ALREADY_EXISTS     ERROR_DS_ATT_VAL_ALREADY_EXISTS     
#define DIRERR_AUX_CLS_TEST_FAIL          ERROR_DS_AUX_CLS_TEST_FAIL          
#define DIRERR_BAD_ATT_SCHEMA_SYNTAX      ERROR_DS_BAD_ATT_SCHEMA_SYNTAX      
#define DIRERR_BAD_ATT_SYNTAX             ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
#define DIRERR_BAD_HIERARCHY_FILE         ERROR_DS_BAD_HIERARCHY_FILE         
#define DIRERR_BAD_INSTANCE_TYPE          ERROR_DS_BAD_INSTANCE_TYPE          
#define DIRERR_BAD_NAME_SYNTAX            ERROR_DS_BAD_NAME_SYNTAX            
#define DIRERR_BAD_RDN_ATT_ID_SYNTAX      ERROR_DS_BAD_RDN_ATT_ID_SYNTAX      
#define DIRERR_BUILD_HIERARCHY_TABLE_FAILED ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED 
#define DIRERR_CANT_ADD_ATT_VALUES        ERROR_DS_CANT_ADD_ATT_VALUES        
#define DIRERR_CANT_ADD_SYSTEM_ONLY       ERROR_DS_CANT_ADD_SYSTEM_ONLY       
#define DIRERR_CANT_CACHE_ATT             ERROR_DS_CANT_CACHE_ATT             
#define DIRERR_CANT_CACHE_CLASS           ERROR_DS_CANT_CACHE_CLASS           
#define DIRERR_CANT_DELETE                ERROR_DS_CANT_DELETE                
#define DIRERR_CANT_DELETE_DSA_OBJ        ERROR_DS_CANT_DELETE_DSA_OBJ        
#define DIRERR_CANT_DEL_MASTER_CROSSREF   ERROR_DS_CANT_DEL_MASTER_CROSSREF   
#define DIRERR_CANT_DEREF_ALIAS           ERROR_DS_CANT_DEREF_ALIAS           
#define DIRERR_CANT_FIND_DSA_OBJ          ERROR_DS_CANT_FIND_DSA_OBJ          
#define DIRERR_CANT_FIND_EXPECTED_NC      ERROR_DS_CANT_FIND_EXPECTED_NC      
#define DIRERR_CANT_FIND_NC_IN_CACHE      ERROR_DS_CANT_FIND_NC_IN_CACHE      
#define DIRERR_CANT_MIX_MASTER_AND_REPS   ERROR_DS_CANT_MIX_MASTER_AND_REPS   
#define DIRERR_CANT_MOD_SYSTEM_ONLY       ERROR_DS_CANT_MOD_SYSTEM_ONLY       
#define DIRERR_CANT_REMOVE_ATT_CACHE      ERROR_DS_CANT_REMOVE_ATT_CACHE      
#define DIRERR_CANT_REMOVE_CLASS_CACHE    ERROR_DS_CANT_REMOVE_CLASS_CACHE    
#define DIRERR_CANT_REM_MISSING_ATT       ERROR_DS_CANT_REM_MISSING_ATT       
#define DIRERR_CANT_REM_MISSING_ATT_VAL   ERROR_DS_CANT_REM_MISSING_ATT_VAL   
#define DIRERR_CANT_REPLACE_HIDDEN_REC    ERROR_DS_CANT_REPLACE_HIDDEN_REC    
#define DIRERR_CANT_RETRIEVE_CHILD        ERROR_DS_CANT_RETRIEVE_CHILD        
#define DIRERR_CANT_RETRIEVE_DN           ERROR_DS_CANT_RETRIEVE_DN           
#define DIRERR_CANT_RETRIEVE_INSTANCE     ERROR_DS_CANT_RETRIEVE_INSTANCE     
#define DIRERR_CHILDREN_EXIST             ERROR_DS_CHILDREN_EXIST             
#define DIRERR_CLASS_MUST_BE_CONCRETE     ERROR_DS_CLASS_MUST_BE_CONCRETE     
#define DIRERR_CLASS_NOT_DSA              ERROR_DS_CLASS_NOT_DSA              
#define DIRERR_CODE_INCONSISTENCY         ERROR_DS_CODE_INCONSISTENCY         
#define DIRERR_CONFIG_PARAM_MISSING       ERROR_DS_CONFIG_PARAM_MISSING       
#define DIRERR_COULDNT_CONTACT_FSMO       ERROR_DS_COULDNT_CONTACT_FSMO       
#define DIRERR_COUNTING_AB_INDICES_FAILED ERROR_DS_COUNTING_AB_INDICES_FAILED 
#define DIRERR_CROSS_NC_DN_RENAME         ERROR_DS_CROSS_NC_DN_RENAME         
#define DIRERR_CROSS_REF_EXISTS           ERROR_DS_CROSS_REF_EXISTS
#define DIRERR_DATABASE_ERROR             ERROR_DS_DATABASE_ERROR             
#define DIRERR_DRA_SCHEMA_MISMATCH        ERROR_DS_DRA_SCHEMA_MISMATCH        
#define DIRERR_DSA_MUST_BE_INT_MASTER     ERROR_DS_DSA_MUST_BE_INT_MASTER     
#define DIRERR_DUP_LDAP_DISPLAY_NAME      ERROR_DS_DUP_LDAP_DISPLAY_NAME      
#define DIRERR_DUP_MAPI_ID                ERROR_DS_DUP_MAPI_ID                
#define DIRERR_DUP_OID                    ERROR_DS_DUP_OID                    
#define DIRERR_DUP_RDN                    ERROR_DS_DUP_RDN                    
#define DIRERR_DUP_SCHEMA_ID_GUID         ERROR_DS_DUP_SCHEMA_ID_GUID         
#define DIRERR_EXISTS_IN_AUX_CLS          ERROR_DS_EXISTS_IN_AUX_CLS          
#define DIRERR_EXISTS_IN_MAY_HAVE         ERROR_DS_EXISTS_IN_MAY_HAVE         
#define DIRERR_EXISTS_IN_MUST_HAVE        ERROR_DS_EXISTS_IN_MUST_HAVE        
#define DIRERR_EXISTS_IN_POSS_SUP         ERROR_DS_EXISTS_IN_POSS_SUP         
#define DIRERR_EXISTS_IN_SUB_CLS          ERROR_DS_EXISTS_IN_SUB_CLS          
#define DIRERR_GCVERIFY_ERROR             ERROR_DS_GCVERIFY_ERROR             
#define DIRERR_GENERIC_ERROR              ERROR_DS_GENERIC_ERROR              
#define DIRERR_GOVERNSID_MISSING          ERROR_DS_GOVERNSID_MISSING          
#define DIRERR_HIERARCHY_TABLE_MALLOC_FAILED ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED 
#define DIRERR_ILLEGAL_MOD_OPERATION      ERROR_DS_ILLEGAL_MOD_OPERATION      
#define DIRERR_ILLEGAL_SUPERIOR           ERROR_DS_ILLEGAL_SUPERIOR           
#define DIRERR_INSUFF_ACCESS_RIGHTS       ERROR_DS_INSUFF_ACCESS_RIGHTS       
#define DIRERR_INTERNAL_FAILURE           ERROR_DS_INTERNAL_FAILURE           
#define DIRERR_INVALID_DMD                ERROR_DS_INVALID_DMD                
#define DIRERR_INVALID_ROLE_OWNER         ERROR_DS_INVALID_ROLE_OWNER         
#define DIRERR_MASTERDSA_REQUIRED         ERROR_DS_MASTERDSA_REQUIRED         
#define DIRERR_MAX_OBJ_SIZE_EXCEEDED      ERROR_DS_MAX_OBJ_SIZE_EXCEEDED      
#define DIRERR_MISSING_EXPECTED_ATT       ERROR_DS_MISSING_EXPECTED_ATT       
#define DIRERR_MISSING_REQUIRED_ATT       ERROR_DS_MISSING_REQUIRED_ATT       
#define DIRERR_MISSING_SUPREF             ERROR_DS_MISSING_SUPREF             
#define DIRERR_NAME_REFERENCE_INVALID     ERROR_DS_NAME_REFERENCE_INVALID     
#define DIRERR_NAME_TOO_LONG              ERROR_DS_NAME_TOO_LONG              
#define DIRERR_NAME_TOO_MANY_PARTS        ERROR_DS_NAME_TOO_MANY_PARTS        
#define DIRERR_NAME_TYPE_UNKNOWN          ERROR_DS_NAME_TYPE_UNKNOWN          
#define DIRERR_NAME_UNPARSEABLE           ERROR_DS_NAME_UNPARSEABLE           
#define DIRERR_NAME_VALUE_TOO_LONG        ERROR_DS_NAME_VALUE_TOO_LONG        
#define DIRERR_NCNAME_MISSING_CR_REF      ERROR_DS_NCNAME_MISSING_CR_REF      
#define DIRERR_NCNAME_MUST_BE_NC          ERROR_DS_NCNAME_MUST_BE_NC          
#define DIRERR_NONEXISTENT_MAY_HAVE       ERROR_DS_NONEXISTENT_MAY_HAVE       
#define DIRERR_NONEXISTENT_MUST_HAVE      ERROR_DS_NONEXISTENT_MUST_HAVE      
#define DIRERR_NONEXISTENT_POSS_SUP       ERROR_DS_NONEXISTENT_POSS_SUP       
#define DIRERR_NOTIFY_FILTER_TOO_COMPLEX  ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX  
#define DIRERR_NOT_AN_OBJECT              ERROR_DS_NOT_AN_OBJECT              
#define DIRERR_NOT_ON_BACKLINK            ERROR_DS_NOT_ON_BACKLINK            
#define DIRERR_NO_CHAINED_EVAL            ERROR_DS_NO_CHAINED_EVAL            
#define DIRERR_NO_CHAINING 	          ERROR_DS_NO_CHAINING 	          
#define DIRERR_NO_CROSSREF_FOR_NC         ERROR_DS_NO_CROSSREF_FOR_NC         
#define DIRERR_NO_DELETED_NAME            ERROR_DS_NO_DELETED_NAME            
#define DIRERR_NO_PARENT_OBJECT           ERROR_DS_NO_PARENT_OBJECT           
#define DIRERR_NO_RDN_DEFINED_IN_SCHEMA   ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA   
#define DIRERR_NO_REQUESTED_ATTS_FOUND    ERROR_DS_NO_REQUESTED_ATTS_FOUND    
#define DIRERR_OBJECT_CLASS_REQUIRED      ERROR_DS_OBJECT_CLASS_REQUIRED      
#define DIRERR_OBJ_CLASS_NOT_DEFINED      ERROR_DS_OBJ_CLASS_NOT_DEFINED      
#define DIRERR_OBJ_CLASS_NOT_SUBCLASS     ERROR_DS_OBJ_CLASS_NOT_SUBCLASS     
#define DIRERR_OBJ_GUID_EXISTS            ERROR_DS_OBJ_GUID_EXISTS            
#define DIRERR_OBJ_NOT_FOUND              ERROR_DS_OBJ_NOT_FOUND              
#define DIRERR_OBJ_STRING_NAME_EXISTS     ERROR_DS_OBJ_STRING_NAME_EXISTS     
#define DIRERR_OBJ_TOO_LARGE              ERROR_DS_OBJ_TOO_LARGE              
#define DIRERR_OUT_OF_SCOPE               ERROR_DS_OUT_OF_SCOPE               
#define DIRERR_PARENT_IS_AN_ALIAS         ERROR_DS_PARENT_IS_AN_ALIAS         
#define DIRERR_RANGE_CONSTRAINT           ERROR_DS_RANGE_CONSTRAINT           
#define DIRERR_RDN_DOESNT_MATCH_SCHEMA    ERROR_DS_RDN_DOESNT_MATCH_SCHEMA    
#define DIRERR_RECALCSCHEMA_FAILED        ERROR_DS_RECALCSCHEMA_FAILED        
#define DIRERR_REFERRAL                   ERROR_DS_REFERRAL                   
#define DIRERR_REPLICATOR_ONLY            ERROR_DS_REPLICATOR_ONLY            
#define DIRERR_ROOT_CANT_BE_SUBREF        ERROR_DS_ROOT_CANT_BE_SUBREF        
#define DIRERR_ROOT_MUST_BE_NC            ERROR_DS_ROOT_MUST_BE_NC            
#define DIRERR_ROOT_REQUIRES_CLASS_TOP    ERROR_DS_ROOT_REQUIRES_CLASS_TOP    
#define DIRERR_SCHEMA_ALLOC_FAILED        ERROR_DS_SCHEMA_ALLOC_FAILED        
#define DIRERR_SCHEMA_NOT_LOADED          ERROR_DS_SCHEMA_NOT_LOADED          
#define DIRERR_SECURITY_CHECKING_ERROR    ERROR_DS_SECURITY_CHECKING_ERROR    
#define DIRERR_SECURITY_ILLEGAL_MODIFY    ERROR_DS_SECURITY_ILLEGAL_MODIFY    
#define DIRERR_SEC_DESC_INVALID           ERROR_DS_SEC_DESC_INVALID
#define DIRERR_SEC_DESC_TOO_SHORT         ERROR_DS_SEC_DESC_TOO_SHORT         
#define DIRERR_SEMANTIC_ATT_TEST          ERROR_DS_SEMANTIC_ATT_TEST          
#define DIRERR_SHUTTING_DOWN              ERROR_DS_SHUTTING_DOWN
#define DIRERR_SINGLE_VALUE_CONSTRAINT    ERROR_DS_SINGLE_VALUE_CONSTRAINT    
#define DIRERR_SUBREF_MUST_HAVE_PARENT    ERROR_DS_SUBREF_MUST_HAVE_PARENT    
#define DIRERR_SUBTREE_NOTIFY_NOT_NC_HEAD ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD 
#define DIRERR_SUB_CLS_TEST_FAIL          ERROR_DS_SUB_CLS_TEST_FAIL          
#define DIRERR_SYNTAX_MISMATCH            ERROR_DS_SYNTAX_MISMATCH
#define DIRERR_TREE_DELETE_NOT_FINISHED   ERROR_DS_TREE_DELETE_NOT_FINISHED   
#define DIRERR_UNKNOWN_ERROR              ERROR_DS_UNKNOWN_ERROR              
#define DIRERR_UNKNOWN_OPERATION          ERROR_DS_UNKNOWN_OPERATION          
#define DIRERR_USER_BUFFER_TO_SMALL       ERROR_DS_USER_BUFFER_TO_SMALL       
#define DIRERR_EPOCH_MISMATCH             ERROR_DS_EPOCH_MISMATCH
#define DIRERR_SRC_NAME_MISMATCH          ERROR_DS_SRC_NAME_MISMATCH
#define DIRERR_SRC_AND_DST_NC_IDENTICAL   ERROR_DS_SRC_AND_DST_NC_IDENTICAL
#define DIRERR_DST_NC_MISMATCH            ERROR_DS_DST_NC_MISMATCH
#define DIRERR_NOT_AUTHORITIVE_FOR_DST_NC ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC
#define DIRERR_SRC_GUID_MISMATCH          ERROR_DS_SRC_GUID_MISMATCH
#define DIRERR_CANT_MOVE_DELETED_OBJECT   ERROR_DS_CANT_MOVE_DELETED_OBJECT
#define DIRERR_PDC_OPERATION_IN_PROGRESS  ERROR_DS_PDC_OPERATION_IN_PROGRESS
#define DIRERR_CROSS_DOMAIN_CLEANUP_REQD  ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD

// These translations take care of old DS_ERR_ references

#define DS_ERR_NO_PARENT_OBJECT           ERROR_DS_NO_PARENT_OBJECT
#define DS_ERR_INTERNAL_FAILURE           ERROR_DS_INTERNAL_FAILURE
#define DS_ERR_DRA_INTERNAL_ERROR         ERROR_DS_DRA_INTERNAL_ERROR
#define DS_ERR_BAD_NAME_SYNTAX            ERROR_DS_BAD_NAME_SYNTAX
#define DS_ERR_REFERRAL                   ERROR_DS_REFERRAL
#define DS_ERR_UNKNOWN_ERROR              ERROR_DS_UNKNOWN_ERROR
#define DS_ERR_UNKNOWN_OPERATION          ERROR_DS_UNKNOWN_OPERATION
#define DS_ERR_CANT_DELETE_DSA_OBJ        ERROR_DS_CANT_DELETE_DSA_OBJ
#define DS_ERR_CANT_FIND_DSA_OBJ          ERROR_DS_CANT_FIND_DSA_OBJ
#define DS_ERR_ILLEGAL_MOD_OPERATION      ERROR_DS_ILLEGAL_MOD_OPERATION
#define DS_ERR_NO_CROSSREF_FOR_NC         ERROR_DS_NO_CROSSREF_FOR_NC
#define DS_ERR_CANT_DELETE                ERROR_DS_CANT_DELETE
#define DS_ERR_DRA_CONNECTION_FAILED      ERROR_DS_DRA_CONNECTION_FAILED
#define DS_ERR_DRA_EXTN_CONNECTION_FAILED ERROR_DS_DRA_EXTN_CONNECTION_FAILED
#define DS_ERR_ATT_NOT_DEF_IN_SCHEMA      ERROR_DS_ATT_NOT_DEF_IN_SCHEMA
#define DS_ERR_ATT_NOT_DEF_FOR_CLASS      ERROR_DS_ATT_NOT_DEF_FOR_CLASS
#define DS_ERR_ADMIN_LIMIT_EXCEEDED       ERROR_DS_ADMIN_LIMIT_EXCEEDED
#define DS_ERR_OBJ_NOT_FOUND              ERROR_DS_OBJ_NOT_FOUND
#define DS_ERR_DUP_LINK_ID                ERROR_DS_DUP_LINK_ID
#define DS_ERR_REFUSING_FSMO_ROLES        ERROR_DS_REFUSING_FSMO_ROLES
#define DS_ERR_INVALID_ROLE_OWNER         ERROR_DS_INVALID_ROLE_OWNER
#define DS_ERR_MISSING_FSMO_SETTINGS      ERROR_DS_MISSING_FSMO_SETTINGS
#define DS_ERR_NOT_AN_OBJECT              ERROR_DS_NOT_AN_OBJECT

/* Don't add anything here.  See note at top. */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\exe\main.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       main.c
//
//--------------------------------------------------------------------------

/*++

    main.c

    This contains the main routine which starts up the directory service
    when the DS is run as either a sepeate service or as a command line appli-
    cation

    Revision History

    5/14/96 Murlis Created
    6/10/96 Moved from dsamain\src

--*/

#include <NTDSpch.h>
#pragma  hdrstop

#include <ntdsa.h>

void
Usage(char *name)
{
    fprintf(stderr, "Usage: %s <-d> <-e> <-i> <-noconsole> <-nosec>\nThis exe starts ntdsa.dll.\n", name);
    fprintf(stderr, "-d has some effect in the internals of the DS\n");
    fprintf(stderr, "-e makes this executable print out the status of the initialization\n");
    fprintf(stderr, "-t puts this exe in an endless init'ing and uninit'ing the ds based on user input\n");
    fprintf(stderr, "-x runs DsaTest\n");
    fprintf(stderr, "-noconsole stops double printing when run in ntsd.exe\n");
    fprintf(stderr, "-nosec disables most security checks\n");
    fprintf(stderr, "\n$%s$%d$\n", name, !0);
}

// Declare the prototype for DsaExeStartRoutine
int __cdecl DsaExeStartRoutine(int argc, char *argv[]);

// Declare DsaTest
void DsaTest(void);

NTSTATUS DsInitialize(ULONG,PDS_INSTALL_PARAM,PDS_INSTALL_RESULT);
NTSTATUS DsUninitialize(BOOL);

/*++

    Main function for running the DS as a 
    seperate executable

--*/
int __cdecl main(int argc, char *argv[])
{
    DWORD WinError = ERROR_BAD_ENVIRONMENT;
    NTSTATUS NtStatus;
    BOOL PrintStatus = FALSE;
    int err;
    int arg = 1;

    // Parse command-line arguments.
    while(arg < argc)
    {

        if (0 == _stricmp(argv[arg], "-e"))
        {
            PrintStatus = TRUE;
        } else if (0 == _stricmp(argv[arg], "-noconsole"))
        {
            ;
        } else if (0 == _stricmp(argv[arg], "-nosec"))
        {
            ;
        }
        else if (0 == _stricmp(argv[arg], "-d"))
        {
            ;
        }
        else if (0 == _stricmp(argv[arg], "-t"))
        {

            BOOLEAN fExit=FALSE;

            while (!fExit) {

                char ch;

                printf("Press return to do first time initialization\n");
                printf("Make sure the correct files are in place\n");
                printf("Or press q to quit:\n");

                ch = (CHAR)getchar();
                while ( ch != '\n' && ch != 'q') 
                    ch = (CHAR)getchar();
                
                if (ch == 'q') {
                    fExit = TRUE;
                    continue;
                }

            
                NtStatus = DsInitialize(FALSE,NULL,NULL);
                if (!NT_SUCCESS(NtStatus)) {
                    fprintf(stderr, "DsInitialize returned 0x%x\n", NtStatus);
                    exit(-1);
                }
    
                printf("Press any key to uninitialize:\n");
    
                ch = (CHAR)getchar();
                if (ch != '\n') printf("\n");
    
                NtStatus = DsUninitialize(FALSE);
                if (!NT_SUCCESS(NtStatus)) {
                    fprintf(stderr, "DsUninitialize returned 0x%x\n", NtStatus);
                    exit(-1);
                }

            }

            exit(0);
            
        }
        else if (0 == _stricmp(argv[arg], "-x"))
        {
            // Test runs asynchronously.
            DsaTest();
        }
        else {
            Usage(argv[0]);
            exit(0);
        }

        arg++;
    }

        err = DsaExeStartRoutine(argc, argv);

    if ( !err ) {
        WinError = ERROR_SUCCESS;
    }
    
    //
    //  This fprintf is for processes who might have
    //  created this executable and want to see the return
    //  value.
    //
    if ( PrintStatus ) {
        fprintf(stderr, "\n$%s$%d$\n", argv[0], WinError);
    }
 
    return err;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\dominfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       domainfo.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Headers for the domain information routines used in cracking names.

Author:

    Dave Straube (davestr) 8/26/96

Revision History:

--*/

#ifndef __DOMINFO_H__
#define __DOMINFO_H__

DWORD
InitializeDomainInformation(void);

DWORD
ExtractDnsReferral(
    IN  WCHAR   **ppDnsDomain);

VOID
NormalizeDnsName(
    IN  WCHAR   *pDnsName);

DWORD
DnsDomainFromFqdnObject(
    IN  WCHAR   *pFqdnObject,
    OUT ULONG   *pDNT,
    OUT WCHAR   **ppDnsDomain);

DWORD
DnsDomainFromDSName(
    IN  DSNAME  *pDSName,
    OUT WCHAR   **ppDnsDomain);

// Secure versions of routines which read the database and perform
// all security checks against the SDs of the objects read.

DWORD
FqdnDomainFromDnsDomainSecure(
    IN  WCHAR   *pDnsDomain,
    OUT DSNAME  **ppFqdnDomain);

DWORD
DownlevelDomainFromDnsDomainSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain);

DWORD
DnsDomainFromDownlevelDomainSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain);

DWORD
ReadCrossRefPropertySecure(
    IN  DSNAME  *pNC,
    IN  ATTRTYP attr,
    IN  DWORD   dwRequiredFlags,
    OUT WCHAR   **ppAttrVal);

// Non-secure versions of routines which read the cross ref list and
// do not perform any SD validation.

DWORD
FqdnNcFromDnsNcNonSecure(
    IN  WCHAR   *pDnsDomain,
    IN  ULONG   crFlags,
    OUT DSNAME  **ppFqdnDomain);

DWORD
FqdnNcFromDnsNcOrAliasNonSecure(
    IN  WCHAR   *pDnsDomain,
    IN  ULONG   crFlags,
    OUT DSNAME  **ppFqdnDomain);

DWORD
DownlevelDomainFromDnsDomainNonSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain);

DWORD
DownlevelDomainFromDnsDomainOrAliasNonSecure(
    IN  THSTATE *pTHS,
    IN  WCHAR   *pDnsDomain,
    OUT WCHAR   **ppDownlevelDomain);

DWORD
DnsDomainFromDownlevelDomainNonSecure(
    IN  WCHAR   *pDownlevelDomain,
    OUT WCHAR   **ppDnsDomain);

DWORD
ReadCrossRefPropertyNonSecure(
    IN  DSNAME  *pNC,
    IN  ATTRTYP attr,
    IN  DWORD   dwRequiredFlags,
    OUT WCHAR   **ppAttrVal);

/*
Defines to the non-secure versions of various routines.  Here's the reasoning.

-----Original Message-----
From:       Dave Straube 
Sent:       Wednesday, December 16, 1998 8:53 AM
To:         Praerit Garg; Peter Brundrett
Subject:    security correctness question

The name cracking implementation evaluates security everywhere - even in 
places you might not think.  For example, if you crack ntdev\davestr or 
ntdev.microsoft.com/foo/bar/itg/davestr, then we (securely) query the 
Partitions container to find a cross-ref for a domain whose domain name 
is either ntdev or ntdev.microsoft.com.

It turns out we have all the domains and their alternate names cached in 
memory.  So I could eliminate one search by matching against the cache - 
which is clearly much faster than N reads in Jet.  The problem is that 
this bypasses security in that you may not have rights to see the cross-ref 
for the domain, but I would end up cracking the name anyway.  Here's the 
options as I see them:

1) Do nothing.  Pro is that we have 100% access control on all aspects of 
name cracking.  Con is that we do lots of extra searches and performance 
suffers.  (We actually see this in the perf group's traces which is what 
brought about this line of thinking in the first place.)

2) Use the cache as is.  Pro is that we optimize performance big time.  
Con is that there is no access control with respect to cracking the domain 
component of downlevel or canonical names.  In the case of downlevel names, 
one could argue that there wasn't any security on the visibility/existence 
of a domain name anyway, so why have it now.  And if that's OK for downlevel 
domain names, why not for DNS domain names too?  So the real issue here is 
whether we feel that domain names are something which need to be guarded or 
whether they are just public knowledge.  Note that if you decide they are 
public knowledge then that does not imply we should ACL the Partitions 
container weakly.  ACLs on the Partitions container implement administrative 
control which is distinct from what's public knowledge or not.

3) Improve the cache to hold not only the netbios and DNS domain name values, 
but also have it hold those values' SDs, and check the SD when we have a match.
Pro is that this should get us back to 100% access control as in the original 
case.  Con 1 is that this runs marginally slower due to the access check - but 
at least the disk accesses are elminiated.  Con 2 is that this is more work to 
code and at present I can only detect originating SD writes.  I'd have to 
invent a totally new mechanism to flush the cache when the SDs on the cross 
refs change due to SD propagation.  This is non-trivial and I would most likely
not recommend it even for RTM.

*** Reply from PraeritG ***

I think assuming domain names to be public knowledge is reasonable given that 
they are published in DNS database anyway -- which are considered public 
information stores...  aren't we recommending that enterprises name their 
domains based on alloted DNS names anyway?

So I like option 2 -- least work, better performance.  I don't think it 
compromises security because the stores are still acl'd.
*/

// Uncomment following line to return to secure domain name implementation.
// #define SECURE_DOMAIN_NAMES

#ifdef SECURE_DOMAIN_NAMES

#define FqdnDomainFromDnsDomain(pDnsDomain, ppFqdnDomain) \
    FqdnDomainFromDnsDomainSecure(pDnsDomain, ppFqdnDomain)

#define DownlevelDomainFromDnsDomain(pTHS, pDnsDomain, ppDownlevelDomain) \
    DownlevelDomainFromDnsDomainSecure(pTHS, pDnsDomain, ppDownlevelDomain)

#define DnsDomainFromDownlevelDomain(pDownlevelDomain, ppDnsDomain) \
    DnsDomainFromDownlevelDomainSecure(pDownlevelDomain, ppDnsDomain)

#define ReadCrossRefProperty(pNC, attr, dwRequiredFlags, ppAttrVal) \
    ReadCrossRefPropertySecure(pNC, attr, dwRequiredFlags, ppAttrVal)

#else

#define FqdnNcFromDnsNc(pDnsDomain, crFlags, ppFqdnDomain) \
    FqdnNcFromDnsNcNonSecure(pDnsDomain, crFlags, ppFqdnDomain)
    
#define FqdnNcFromDnsNcOrAlias(pDnsDomain, crFlags, ppFqdnDomain) \
    FqdnNcFromDnsNcOrAliasNonSecure(pDnsDomain, crFlags, ppFqdnDomain)

#define DownlevelDomainFromDnsDomain(pTHS, pDnsDomain, ppDownlevelDomain) \
    DownlevelDomainFromDnsDomainNonSecure(pTHS, pDnsDomain, ppDownlevelDomain)
    
#define DownlevelDomainFromDnsDomainOrAlias(pTHS, pDnsDomain, ppDownlevelDomain) \
    DownlevelDomainFromDnsDomainOrAliasNonSecure(pTHS, pDnsDomain, ppDownlevelDomain)

#define DnsDomainFromDownlevelDomain(pDownlevelDomain, ppDnsDomain) \
    DnsDomainFromDownlevelDomainNonSecure(pDownlevelDomain, ppDnsDomain)
    
#define ReadCrossRefProperty(pNC, attr, dwRequiredFlags, ppAttrVal) \
    ReadCrossRefPropertyNonSecure(pNC, attr, dwRequiredFlags, ppAttrVal)

#endif

#endif // __DOMINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\draconstr.h ===
#ifndef _DRACONSTR_H_
#define _DRACONSTR_H_

DWORD
draGetLdapReplInfo(IN THSTATE * pTHS,
                   IN ATTRTYP attrId, 
                   IN DSNAME * pObjDSName,
                   IN DWORD dwBaseIndex,     
                   IN PDWORD pdwNumRequested, OPTIONAL
                   IN BOOL fXML,
                   OUT ATTR * pAttr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\draaudit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       draaudit.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Security Audit Routines

Author:

    Greg Johnson (gregjohn) 

Revision History:

    Created     <10/1/2001>  gregjohn

--*/

#define Dra_Audit_Enabled(pTHS) ((pTHS!=NULL) && (pTHS->fDRAAuditEnabled))
#define Dra_Audit_Enabled_Attr(pTHS) ((pTHS!=NULL) && (pTHS->fDRAAuditEnabledForAttr))

extern ULONG gulSyncSessionID;

ULONG
DRA_AuditLog_ReplicaAdd_Begin( 
    THSTATE *pTHS,
    DSNAME * pSource,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions
    );

#define DRA_AUDITLOG_REPLICAADD_BEGIN(pTHS, pSource, pmtx_addrSource, pNC, ulOptions) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaAdd_Begin(pTHS, \
	pSource, \
	pmtx_addrSource, \
	pNC, \
	ulOptions)) { \
	Assert(!"DRA_AuditLog_ReplicaAdd_Begin:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_ReplicaAdd_End(
    THSTATE *pTHS,
    DSNAME * pSource,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    UUID     uuidDsaObjSrc,
    ULONG    ulError);


#define DRA_AUDITLOG_REPLICAADD_END(pTHS, pSource, pmtx_addrSource, pNC, ulOptions, uuidDsaObjSrc, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaAdd_End(pTHS, \
	pSource, \
	pmtx_addrSource, \
	pNC, \
	ulOptions, \
	uuidDsaObjSrc, \
	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaAdd:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG 
DRA_AuditLog_ReplicaDel(
    THSTATE *pTHS,
    MTX_ADDR * pmtx_addrSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError);

#define DRA_AUDITLOG_REPLICADEL(pTHS, pmtx_addrSource, pNC, ulOptions, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaDel(pTHS, \
	pmtx_addrSource, \
	pNC, \
	ulOptions, \
	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaDel:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_ReplicaModify(
    THSTATE *pTHS,
    MTX_ADDR * pmtx_addrSource,
    GUID * pGuidSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError);

#define DRA_AUDITLOG_REPLICAMODIFY(pTHS, pmtx_addrSource, pGuidSource, pNC, ulOptions, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaModify(pTHS, \
	pmtx_addrSource, \
	pGuidSource, \
	pNC, \
	ulOptions, \
	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaModify:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG 
DRA_AuditLog_UpdateRefs(
    THSTATE *pTHS,
    MTX_ADDR * pmtxDestination,
    GUID * pGuidDestination,
    DSNAME * pNC,
    ULONG    ulOptions,
    ULONG    ulError);

#define DRA_AUDITLOG_UPDATEREFS(pTHS, pmtxDestination, pGuidDestination, pNC, ulOptions, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_UpdateRefs(pTHS, \
	pmtxDestination, \
	pGuidDestination, \
	pNC, \
	ulOptions, \
	ulError)) { \
	Assert(!"DRA_AuditLog_UpdateRefs:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_ReplicaSync_Begin( 
    THSTATE *pTHS,
    LPWSTR   pszSourceDRA,
    UUID *   puuidSource,
    DSNAME * pNC,
    ULONG    ulOptions
    );

#define DRA_AUDITLOG_REPLICASYNC_BEGIN(pTHS, pszSourceDRA, puuidSource, pNC, ulOptions) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaSync_Begin(pTHS, \
	pszSourceDRA, \
	puuidSource, \
	pNC, \
	ulOptions)) { \
	Assert(!"DRA_AuditLog_ReplicaSync_Begin:  Unable to perform replication security audit logging!"); \
    } \
}

#define DRA_AUDITLOG_REPLICASYNC_MAIL_BEGIN(pTHS, pszSourceDRA, puuidSource, pNC, ulOptions) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaSync_Begin(pTHS, \
	pszSourceDRA, \
	puuidSource, \
	pNC, \
	ulOptions)) { \
	Assert(!"DRA_AuditLog_ReplicaSync_Begin:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_ReplicaSync_End( 
    THSTATE *pTHS,
    LPWSTR   pszSourceDRA,
    UUID *   puuidSource,
    DSNAME * pNC,
    ULONG    ulOptions,
    USN_VECTOR *pusnTo,
    ULONG    ulError
    );

#define DRA_AUDITLOG_REPLICASYNC_END(pTHS, pszSourceDRA, puuidSource, pNC, ulOptions, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaSync_End(pTHS, \
	pszSourceDRA, \
	puuidSource, \
	pNC, \
	ulOptions, \
	NULL, \
       	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaSync_End:  Unable to perform replication security audit logging!"); \
    } \
}

#define DRA_AUDITLOG_REPLICASYNC_MAIL_END(pTHS, pszSourceDRA, puuidSource, pNC, ulOptions, pusn, ulError) \
if (Dra_Audit_Enabled(pTHS)) { \
    if (0!=DRA_AuditLog_ReplicaSync_End(pTHS, \
	pszSourceDRA, \
	puuidSource, \
	pNC, \
	ulOptions, \
	pusn, \
       	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaSync_End:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_UpdateRepObj(
    THSTATE * pTHS,
    ULONG     ulSessionID,
    DSNAME *  pObj,
    ATTRBLOCK attrBlock,
    USN       usn,
    ULONG     ulUpdateStatus,
    ULONG     ulError);

#define DRA_AUDITLOG_UPDATEREPOBJ(pTHS, ulSessionID, pObj, attrBlock, usn, ulUpdateStatus, ulError) \
if (Dra_Audit_Enabled(pTHS) && Dra_Audit_Enabled_Attr(pTHS)) { \
    if (0!=DRA_AuditLog_UpdateRepObj(pTHS, \
	ulSessionID, \
	pObj, \
	attrBlock, \
	usn, \
	ulUpdateStatus, \
	ulError)) { \
	Assert(!"DRA_AuditLog_UpdateRepObj:  Unable to perform replication security audit logging!"); \
    } \
}

ULONG
DRA_AuditLog_UpdateRepValue(
    THSTATE * pTHS,
    ULONG ulSessionID,
    REPLVALINF * pReplValInf,
    USN usn,
    ULONG ulUpdateValueStatus,
    ULONG ulError);

#define DRA_AUDITLOG_UPDATEREPVALUE(pTHS, ulSessionID, pReplValInf, usn, ulUpdateValueStatus, ulError) \
if (Dra_Audit_Enabled(pTHS) && Dra_Audit_Enabled_Attr(pTHS)) { \
    if (0!=DRA_AuditLog_UpdateRepValue(pTHS, \
	ulSessionID, \
	pReplValInf, \
	usn, \
	ulUpdateValueStatus, \
	ulError)) { \
	Assert(!"DRA_AuditLog_UpdateRepValue:  Unable to perform replication security audit logging!"); \
    } \
}
 
ULONG
DRA_AuditLog_LingeringObj_Removal( 
    THSTATE *pTHS,
    LPWSTR   pszSource,
    DSNAME * pDN,
    ULONG    ulOptions,
    ULONG    ulError
    );

#define DRA_AUDITLOG_LINGERINGOBJ_REMOVAL(pTHS, pszSource, pDN, ulOptions, ulError) \
if (Dra_Audit_Enabled(pTHS) && Dra_Audit_Enabled_Attr(pTHS)) { \
    if (0!=DRA_AuditLog_LingeringObj_Removal(pTHS, \
	pszSource, \
	pDN, \
	ulOptions, \
       	ulError)) { \
	Assert(!"DRA_AuditLog_ReplicaSync_End:  Unable to perform replication security audit logging!"); \
    } \
}

BOOL
IsDraAuditLogEnabled();

BOOL
IsDraAuditLogEnabledForAttr();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\draerror.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       draerror.h
//
//--------------------------------------------------------------------------

ULONG RepErrorFromPTHS(THSTATE *pTHS);

void DraErrOutOfMem(void);

#define RAISE_DRAERR_INCONSISTENT( Arg ) \
DraErrInconsistent( Arg, ((FILENO << 16) | __LINE__) )

void DraErrInconsistent( DWORD Arg, DWORD Id );

void DraErrBusy(void);

void DraErrMissingAtt(DSNAME *pDN, ATTRTYP type);

void DraErrCannotFindNC(DSNAME *pNC);

void DraErrInappropriateInstanceType(DSNAME *pDN, ATTRTYP type);

void DraErrMissingObject(THSTATE *pTHS, ENTINF *pEnt);

void
DraLogGetChangesFailure(
    IN DSNAME *pNC,
    IN LPWSTR pszDsaAddr,
    IN DWORD ret,
    IN DWORD ulExtendedOp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\dramail.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dramail.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Declarations for asynchronous replication.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

// Message types (enumeration).
#define MRM_REQUPDATE            1
#define MRM_UPDATEREPLICA        2

// Message attributes (bit flags).
#define MRM_MSG_SIGNED              (0x20000000)
#define MRM_MSG_SEALED              (0x40000000)
#define MRM_MSG_COMPRESSED          (0x80000000)

// This is the bogus buffer that we pass to MEsEncodeFixedBufferHandleCreate,
// The buffer is bogus in that we only pass this pointer when we create the
// handle, but we reset the buffer pointer in the handle before use.
#define BOGUS_BUFFER_SIZE 16
extern char grgbBogusBuffer[BOGUS_BUFFER_SIZE];

// These are the mail message version numbers. If we get a request in that
// has a protocol version number different than ours, the request is
// incompatible and must be discarded.

// Change the ProtocolVersionCaller field when the MAIL_REP_MSG changes or
// when the semantics of replication change in an incompatible way between
// destination and source.
// Change the dwMsgVersion field when the structure version changes.

#define CURRENT_PROTOCOL_VERSION 11

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

// MAIL_REP_MSG structures contain a message blob (an RPC-marchalled buffer),
// which currently is optionally compressed, always signed, and sometimes
// sealed.
typedef struct _MAIL_REP_MSG {
    ULONG CompressionVersionCaller; // COMP_ZIP or COMP_NONE
    ULONG ProtocolVersionCaller;    // Must be CURRENT_PROTOCOL_VERSION or
                                    //   message is thrown out

    ULONG cbDataOffset;             // Offset (from beginning of MAIL_REP_MSG)
                                    //   of data field.  Present to allow
                                    //   additional fields to be added later
                                    //   (at the current data offset) without
                                    //   breaking backward compatibility.
                                    //   0 if data field not present.
    ULONG cbDataSize;               // Size of message data
    ULONG cbUncompressedDataSize;   // Size of message data before compression
    ULONG cbUnsignedDataSize;       // Size of message data before encryption

    DWORD dwMsgType;                // MRM_UPDATEREPLICA or MRM_REQUPDATE,
                                    //   possibly ORed with MRM_MSG_COMPRESSED,
                                    //   MRM_MSG_SIGNED, and/or MRM_MSG_SEALED
    DWORD dwMsgVersion;             // Version of above message structure

    ///////////////////////////////////////////////////////////////////////////
    //
    // Fields between here and message data added after Win2k.
    //

    DWORD dwExtFlags;               // Extension flags.  Consumed by Whistler
                                    //   Beta 1 and Beta 2 DCs.  Superseded by
                                    //   the full DRS_EXTENSIONS structure on
                                    //   >= Whistler Beta 3 DCs.
                                    //   0 if extensions not present.
    DWORD cbExtOffset;              // Offset (from beginning of MAIL_REP_MSG)
                                    //   of DRS_EXTENSIONS structure field.
                                    //   Set only by >= Whistler Beta 3 DCs.  If
                                    //   zero, use dwExtFlags (a subset of the
                                    //   DRS_EXTENSIONS structure) instead.

    char  rgbDontRefDirectly[];     // DON'T REFERENCE THIS FIELD DIRECTLY --
                                    // USE THE MACROS BELOW!
                                    //
                                    // Variable length data, including:
                                    //
                                    // DRS_EXTENSIONS (optional, at offset
                                    //   cbExtOffset from beginning of message)
                                    //
                                    // Message Data (which may be compressed
                                    //   and/or encrypted, depending on high
                                    //   bits of dwMsgType, at offset
                                    //   cbDataOffset from beginning of message)
                                    //
                                    //   WARNING! This field must be 8 byte
                                    //   aligned in order for
                                    //   MesDecodeBufferCreate to work!
                                    //
                                    //   MESSAGE DATA MUST BE THE LAST
                                    //   VARIABLE-LENGTH FIELD!
} MAIL_REP_MSG;

#if DBG
#define ASSERTION_FAILURE(x, y, z)  DoAssert((x), (y), (z))
#else
#define ASSERTION_FAILURE(x, y, z)  0
#endif

// Get the size of the message header (i.e., the fixed fields preceding the
// variable-length portion of the message).  Not valid for messages that
// don't contain message data.
#define MAIL_REP_MSG_HEADER_SIZE(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset > offsetof(MAIL_REP_MSG, cbExtOffset) + sizeof((x)->cbExtOffset) \
        ? (x)->cbExtOffset \
        : (x)->cbDataOffset) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", DSID(FILENO, __LINE__), __FILE__), (DWORD) -1))

// Known header sizes.
#define MAIL_REP_MSG_CURRENT_HEADER_SIZE offsetof(MAIL_REP_MSG, rgbDontRefDirectly)
#define MAIL_REP_MSG_W2K_HEADER_SIZE     offsetof(MAIL_REP_MSG, dwExtFlags)

// Get the byte offset of the DRS_EXTENSIONS structure in the message, or 0 if
// none.
#define MAIL_REP_MSG_DRS_EXT_OFFSET(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset > offsetof(MAIL_REP_MSG, cbExtOffset) + sizeof(DWORD) \
        ? (x)->cbExtOffset \
        : 0) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", DSID(FILENO, __LINE__), __FILE__), (DWORD) 0))

// Get a pointer to the DRS_EXTENSIONS structure in the message, or NULL if
// none.
#define MAIL_REP_MSG_DRS_EXT(x) \
    (MAIL_REP_MSG_DRS_EXT_OFFSET(x) \
        ? (DRS_EXTENSIONS *) ((BYTE *) (x) + MAIL_REP_MSG_DRS_EXT_OFFSET(x)) \
        : NULL)

// Get a pointer to the message data in the message, or NULL if none.
#define MAIL_REP_MSG_DATA(x) \
    ((x)->cbDataOffset \
        ? ((BYTE *) (x) + (x)->cbDataOffset) \
        : NULL)

// Get the total size of the message (header and all variable-length data).
// Not valid for messages that don't contain message data.
#define MAIL_REP_MSG_SIZE(x) \
    ((x)->cbDataOffset \
     ? ((x)->cbDataOffset + (x)->cbDataSize) \
     : (ASSERTION_FAILURE("cbDataOffset != 0", DSID(FILENO, __LINE__), __FILE__), (DWORD) -1))

// Is the message a native header only (no variable-length fields)?
#define MAIL_REP_MSG_IS_NATIVE_HEADER_ONLY(x) \
    ((0 == (x)->cbDataOffset) && (0 == (x)->cbExtOffset))

// Is the message a native message?  Must contain at least one variable-length
// field.
#define MAIL_REP_MSG_IS_NATIVE(x) \
    ((x)->cbExtOffset \
     ? ((MAIL_REP_MSG_CURRENT_HEADER_SIZE == (x)->cbExtOffset) \
        && (ROUND_UP_COUNT(MAIL_REP_MSG_CURRENT_HEADER_SIZE \
                           + DrsExtSize(MAIL_REP_MSG_DRS_EXT(x)), \
                           MAIL_REP_MSG_DATA_ALIGN) \
            == (x)->cbDataOffset)) \
     : (MAIL_REP_MSG_CURRENT_HEADER_SIZE == (x)->cbDataOffset))

// Variable length fields should be at 8-byte offsets from the beginning of the
// message.
#define MAIL_REP_MSG_EXT_ALIGN  sizeof(LONGLONG)
#define MAIL_REP_MSG_DATA_ALIGN sizeof(LONGLONG)

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

typedef HANDLE DRA_CERT_HANDLE;

typedef enum {
    DRA_KEY_SIZE_UNKNOWN = 0,
    DRA_KEY_SIZE_56,
    DRA_KEY_SIZE_128
} DRA_KEY_SIZE;

ULONG
DRAEnsureMailRunning();

void
draSendMailRequest(
    IN  THSTATE *               pTHS,
    IN  DSNAME *                pNC,
    IN  DWORD                   ulOptions,
    IN  REPLICA_LINK *          pRepLink,
    IN  UPTODATE_VECTOR *       pUpToDateVec,
    IN  PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN  PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx
    );

ULONG __stdcall
MailReceiveThread(
    IN  void *  pvIgnored
    );

void
draSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsignedMailRepMsg,
    OUT MAIL_REP_MSG ** ppSignedMailRepMsg
    );

PDSNAME
draVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSignedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsignedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    );

void
draEncryptAndSignMessage(
    IN  THSTATE      *  pTHS,
    IN  MAIL_REP_MSG *  pUnsealedMailRepMsg,
    IN  DRA_CERT_HANDLE hRecipientCert,
    IN  DRA_KEY_SIZE    eKeySize,
    OUT MAIL_REP_MSG ** ppSealedMailRepMsg
    );

PDSNAME
draDecryptAndVerifyMessageSignature(
    IN  THSTATE      *      pTHS,
    IN  MAIL_REP_MSG *      pSealedMailRepMsg,
    IN  CHAR         *      pbData,
    OUT MAIL_REP_MSG **     ppUnsealedMailRepMsg,
    OUT DRA_CERT_HANDLE *   phSignerCert         OPTIONAL
    );

MTX_ADDR *
draGetTransportAddress(
    IN OUT  DBPOS *   pDB,
    IN      DSNAME *  pDSADN,
    IN      ATTRTYP   attAddress
    );

void
draFreeCertHandle(
    IN  DRA_CERT_HANDLE     hCert
    );

ULONG
draCompressBlobDispatch(
    OUT BYTE               *pCompBuff,
    IN  ULONG               CompSize,
    IN  DRS_EXTENSIONS     *pExt,          OPTIONAL
    IN  BYTE               *pUncompBuff,
    IN  ULONG               UncompSize,
    OUT DRS_COMP_ALG_TYPE  *CompressionAlg
    );

ULONG
draUncompressBlobDispatch(
    IN  THSTATE *   pTHS,
    IN  DRS_COMP_ALG_TYPE CompressionAlg,
    OUT BYTE *      pUncompBuff,
    IN  ULONG       cbUncomp,
    IN  BYTE *      pCompBuff,
    IN  ULONG       cbCompBuff
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drameta.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drameta.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines all per-property meta-data parsing,
    and updating functions.

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#ifndef _DRAMETA_H_
#define _DRAMETA_H_

#include <prefix.h>

// Value assigned to the usnProperty field of a PROPERTY_META_DATA structure to
// signify that the property has been touched/removed on a gc.  The "real" meta data is
// filled-in/removed for all such properties just before the object is committed.
#define USN_PROPERTY_TOUCHED    ( -1 )
#define USN_PROPERTY_GCREMOVED    ( -2 )

//
// Following bit flags define any special processing
// requested for the property meta data. More than
// one can be bitwise-OR'ed to specify more than
// one special processing of meta data.
//
#define META_STANDARD_PROCESSING    (0)
#define META_AUTHORITATIVE_MODIFY   (0x00000001)

// Object update states

#define UPDATE_NOT_UPDATED 0
#define UPDATE_INSTANCE_TYPE 1
#define UPDATE_OBJECT_UPDATE 2
#define UPDATE_OBJECT_CREATION 3

// Value update status
#define UPDATE_VALUE_UPDATE 2
#define UPDATE_VALUE_CREATION 3

BOOL
ReplValueIsChangeNeeded(
    IN USN usnPropWaterMark,
    IN UPTODATE_VECTOR *pUpTodateVecDest,
    VALUE_META_DATA *pValueMetaData
    );

PROPERTY_META_DATA *
ReplLookupMetaData(
    IN      ATTRTYP                         attrtyp,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVec,
    OUT     DWORD *                         piProp                  OPTIONAL
    );

PROPERTY_META_DATA *
ReplInsertMetaData(
    IN      THSTATE                       * pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced,
    OUT     BOOL *                          pfIsNewElement          OPTIONAL
    );

void
ReplOverrideMetaData(
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR *     pMetaDataVec
    );

void
ReplUnderrideMetaData(
    IN      THSTATE *                       pTHS,
    IN      ATTRTYP                         attrtyp,
    IN OUT  PROPERTY_META_DATA_VECTOR **    ppMetaDataVec,
    IN OUT  DWORD *                         pcbMetaDataVecAlloced   OPTIONAL
    );

void
ReplPrepareDataToShip(
    IN      THSTATE                       * pTHS,
    IN      ENTINFSEL *                     pSel,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVec,
    IN OUT  REPLENTINFLIST *                pList
    );

DWORD
ReplReconcileRemoteMetaDataVec(
    IN      THSTATE *                       pTHS,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecLocal,      OPTIONAL
    IN      BOOL                            fIsAncestorOfLocalDsa,
    IN      BOOL                            fLocalObjDeleted,
    IN      BOOL                            fDeleteLocalObj,
    IN      BOOL                            fBadDelete,
    IN      USHORT                          RemoteObjDeletion,
    IN      ENTINF *                        pent,
    IN      PROPERTY_META_DATA_VECTOR *     pMetaDataVecRemote,
    IN OUT  GUID **                         ppParentGuid,
    OUT     ATTRBLOCK *                     pAttrBlockOut,
    OUT     PROPERTY_META_DATA_VECTOR **    ppMetaDataVecOut
    );

void
ReplMorphRDN(
    IN      THSTATE *   pTHS,
    IN OUT  ATTR *      pAttrRDN,
    IN      GUID *      pGuid
    );

int
ReplCompareMetaData(
    IN      PROPERTY_META_DATA *    pMetaData1,
    IN      PROPERTY_META_DATA *    pMetaData2  OPTIONAL
    );

int
__inline
ReplCompareVersions(
    IN DWORD Version1,
    IN DWORD Version2
    );

int
ReplCompareValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2,
    BOOL *pfConflict OPTIONAL
    );

int
ReplCompareDifferentValueMetaData(
    VALUE_META_DATA *pValueMetaData1,
    VALUE_META_DATA *pValueMetaData2
    );

BOOL
ReplPruneOverrideAttrForSize(
    THSTATE *                   pTHS,
    DSNAME *                    pName,
    DSTIME *                    pTimeNow,
    USN *                       pusnLocal,
    ATTRBLOCK *                 pAttrBlock,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

VOID
ReplOverrideLinks(
    IN THSTATE *pTHS
    );

void
ReplCheckMetadataWasApplied(
    IN      THSTATE *                   pTHS,
    IN OUT  PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

#endif // _DRAMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drancrep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drancrep.h
//
//--------------------------------------------------------------------------

// TEMP
// Fix after build 3630 comes out
#ifndef ERROR_DS_REPL_LIFETIME_EXCEEDED
#define ERROR_DS_REPL_LIFETIME_EXCEEDED ERROR_DS_TIMELIMIT_EXCEEDED
#endif
// TEMP

extern CRITICAL_SECTION csSyncLock;


// This is purely for debugging purposes, and (if set) is the address of the
// last other server we attempted a ReplicaSync call to.

extern UNALIGNED MTX_ADDR * pLastReplicaMTX;


// LostAndFound RDNs DO NOT USE THESE!!! You should always use the WellKnownAtt,
// and the GUID for the container you're looking for.  See draGetLostAndFoundGuid()
#define LOST_AND_FOUND_CONFIG L"LostAndFoundConfig"
#define LOST_AND_FOUND_CONFIG_LEN ((sizeof(LOST_AND_FOUND_CONFIG) / sizeof(WCHAR)) - 1)


// The following constants are returns fromm the AttrValFromAttrBlock function.
// They are single constants, not bitfields
// The return values are chosen so that the function returns TRUE if
// no values are returned.

#define ATTR_PRESENT_VALUE_RETURNED 0
#define ATTR_PRESENT_NO_VALUES 1
#define ATTR_NOT_PRESENT 2

USHORT AttrValFromAttrBlock(ATTRBLOCK *pAttrBlock,ATTRTYP atype,VOID *pVal, ATTR **ppAttr);

#define OBJECT_DELETION_NOT_CHANGED 0
#define OBJECT_BEING_DELETED 1
#define OBJECT_DELETION_REVERSED 2

USHORT
AttrDeletionStatusFromPentinf (
        ENTINF *pent
    );

ULONG
ReplicateNC(
    IN      THSTATE *               pTHS,
    IN      DSNAME *                pNC,
    IN      MTX_ADDR *              pmtx_addr,
    IN      LPWSTR                  pszSourceDsaDnsDomainName,
    IN      USN_VECTOR *            pusnvecLast,
    IN      ULONG                   RepFlags,
    IN      REPLTIMES *             prtSchedule,
    IN OUT  UUID *                  puuidDsaObjSrc,
    IN      UUID *                  puuidInvocIdSrc,
    IN      ULONG *                 pulSyncFailure,
    IN      BOOL                    fNewReplica,
    IN      UPTODATE_VECTOR *       pUpToDateVec,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSet,
    IN      PARTIAL_ATTR_VECTOR *   pPartialAttrSetEx,
    IN      ULONG                   ulOptions,
    OUT     BOOL *                  pfBindSuccess
    );

ULONG
DeleteRepTree(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    );

USHORT GetNextDelObj( THSTATE *pTHS, BOOL fFirstCall, USHORT *plevel, BOOL fNCLimit,
        DSNAME *pDN);

ULONG
DeleteLocalObj(
    THSTATE *                   pTHS,
    DSNAME *                    pDN,
    BOOL                        fPreserveRDN,
    BOOL                        fGarbCollectASAP,
    PROPERTY_META_DATA_VECTOR * pMetaDataVecRemote
    );

ULONG
UpdateNC(
    THSTATE *                     pTHS,
    DSNAME *                      pNC,
    DRS_MSG_GETCHGREPLY_NATIVE *  pmsgReply,
    LPWSTR                        pszSourceServer,
    ULONG *                       pulSyncFailure,
    ULONG                         RepFlags,
    DWORD *                       pdwNCModified,
    DWORD *                       pdwObjectCreationCount,
    DWORD *                       pdwValueCreationCount,
    BYTE  *                       pSchemaInfo,
    ULONG                         UpdNCFlags
    );

// The following are flags passed to UpdateNC.
#define UPDNC_IS_PREEMTABLE (1) // is this operation preemtable?
#define UPDNC_EXISTING_NC   (2) // must this operation happen on an existing NC?

// Following constants are used to return the modification
// status through UpdateNC()
// These are constants - not bit fields. Caller
// of UpdateNC() is expected to use the returned value as a
// whole - not analyze it bitwise.
#define MODIFIED_NOTHING            (0)
#define MODIFIED_NCHEAD_ONLY        (1)
#define MODIFIED_NCTREE_INTERIOR    (2)

ULONG
UpdateRepsTo(
    THSTATE *               pTHS,
    DSNAME *                pNC,
    UUID *                  puuidDSA,
    MTX_ADDR                *pDSAMtx_addr,
    ULONG                   ulResultThisAttempt
    );

DWORD
UpdateRepsFromRef(
    THSTATE *               pTHS,
    ULONG                   ulModifyFields,
    DSNAME *                pNC,
    DWORD                   dwFindFlags,
    BOOL                    fMustAlreadyExist,
    UUID *                  puuidDsaObj,
    UUID *                  puuidInvocId,
    USN_VECTOR *            pusnvecTo,
    UUID *                  puuidTransportObj,
    UNALIGNED MTX_ADDR *    pmtx_addr,
    ULONG                   RepFlags,
    REPLTIMES *             prtSchedule,
    ULONG                   ulResultThisAttempt,
    PPAS_DATA               pPasData
    );
#define URFR_NEED_NOT_ALREADY_EXIST ( FALSE )
#define URFR_MUST_ALREADY_EXIST     ( TRUE )

int IsNCUpdateable (THSTATE *pTHS, ENTINF *pent, USN usnLastSync,
                                                        BOOL writeable);

// Return codes from IsNCUpdateable
#define UPDATE_OK       1
#define UPDATE_INCOMPAT 2
#define UPDATE_LOST_WRTS  3
#define UPDATE_LOST_NWTS  4


// Convert the DSNAME of an NTDS-DSA object into a network address.
LPWSTR
DSaddrFromName(
    IN  THSTATE   * pTHS,
    IN  DSNAME *    pdnServer
    );

// Change the instance type of the given object to the specified value.
ULONG
ChangeInstanceType(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pName,
    IN  SYNTAX_INTEGER  it,
    IN  DWORD           dsid
    );

DWORD
ReplicateObjectsFromSingleNc(
    DSNAME *                 pdnNtdsa,
    ULONG                    cObjects,
    DSNAME **                ppdnObjects,
    DSNAME *                 pNC
    );

ULONG
RenameLocalObj(
    THSTATE                     *pTHS,
    ULONG                       dntNC,
    ATTR                        *pAttrRdn,
    GUID                        *pObjectGuid,
    GUID                        *pParentGuid,
    PROPERTY_META_DATA_VECTOR   *pMetaDataVecRemote,
    BOOL                        fMoveToLostAndFound,
    BOOL                        fDeleteLocalObj
    );

DWORD
DraReplicateSingleObject(
    THSTATE * pTHS,
    DSNAME * pSource,
    DSNAME * pDN,
    DSNAME * pNC,
    DWORD * pExOpError
    );

BOOL
draCheckReplicationLifetime(
    IN      THSTATE *pTHS,
    IN      UPTODATE_VECTOR *       pUpToDateVecDest,
    IN      UUID *                  puuidInvocIdSrc,
    IN      UUID *                  puuidDsaObjSrc,
    IN      LPWSTR                  pszSourceServer
    );

// From dramderr.c
void 
draEncodeError(
    THSTATE *                  pTHS,     
    DWORD                      ulRepErr,
    DWORD *                    pdwErrVer,
    DRS_ERROR_DATA **          ppErrData
    );

void
draDecodeDraErrorDataAndSetThError(
    DWORD                 dwVer,
    DRS_ERROR_DATA *      pErrData,
    DWORD                 dwOptionalError,
    THSTATE *             pTHS
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drarpc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drarpc.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Contains all structures and prototypes for ds rpc, rpctests, and test hooks.

Author:

    Greg Johnson (gregjohn)   

Revision History:

    Created     <03/03/01>  gregjohn

--*/

#ifndef _DRARPC_H_
#define _DRARPC_H_

#if DBG
#define RPC_TEST(x,y) RpcTest((x), (y)) 
#else 
#define RPC_TEST(x,y)  
#endif 

typedef enum _RPCCALL {
    MIN_RPCCALL = 0,
    IDL_DRSBIND,
    IDL_DRSADDENTRY,
    IDL_DRSADDSIDHISTORY,
    IDL_DRSCRACKNAMES,
    IDL_DRSDOMAINCONTROLLERINFO,
    IDL_DRSEXECUTEKCC,
    IDL_DRSGETMEMBERSHIPS,
    IDL_DRSGETMEMBERSHIPS2,
    IDL_DRSGETNCCHANGES,
    IDL_DRSGETNT4CHANGELOG,
    IDL_DRSGETREPLINFO,
    IDL_DRSINHERITSECURITYIDENTITY,
    IDL_DRSINTERDOMAINMOVE,
    IDL_DRSREMOVEDSDOMAIN,
    IDL_DRSREMOVEDSSERVER,
    IDL_DRSREPLICAADD,
    IDL_DRSREPLICADEL,
    IDL_DRSREPLICAMODIFY,
    IDL_DRSREPLICASYNC,
    IDL_DRSUPDATEREFS,
    IDL_DRSVERIFYNAMES,
    IDL_DRSWRITESPN,
    IDL_DRSUNBIND,
    IDL_DRSREPLICAVERIFYOBJECTS,
    IDL_DRSGETOBJECTEXISTENCE,
    IDL_DRSQUERYSITESBYCOST,
    // add new calls here
    // IDL_DRSExecuteScript ??	
    MAX_RPCCALL
} RPCCALL;

VOID drsReferenceContext(
    IN DRS_HANDLE hDrs
    );

VOID
drsDereferenceContext(
    IN DRS_HANDLE hDrs
    );

// RPC Server Side validation functions
ULONG
LPSTR_Validate(
    LPCSTR         pszInput,
    BOOL           fNullOkay
    );

ULONG
LPWSTR_Validate(
    LPCWSTR         pszInput,
    BOOL            fNullOkay
    );

ULONG 
DSNAME_Validate(
    DSNAME * pDN,
    BOOL     fNullOkay
    );

ULONG
ENTINF_Validate(
    ENTINF * pEnt
    );

ULONG
ENTINFLIST_Validate(
    ENTINFLIST * pEntInf
    );

VOID
DRS_Prepare(
    THSTATE ** ppTHS,
    DRS_HANDLE hDrs,
    RPCCALL rpcCall
    );

#if DBG
typedef struct _BARRIER {
    BOOL fBarrierInit;
    HANDLE heBarrierInUse;
    BOOL fBarrierInUse;
    HANDLE heBarrier;
    CRITICAL_SECTION csBarrier; 
    ULONG  ulTimeout;
    ULONG  ulThreads;
    ULONG  ulCount;
} BARRIER;

typedef struct _RPCTIME_INFO {
    BOOL  fEnabled;
    ULONG ulRunTimeSecs;
} RPCTIME_INFO;

typedef struct _RPCSYNC_INFO {
    BOOL  fEnabled;
    ULONG ulNumThreads;
} RPCSYNC_INFO;

void
BarrierInit(
    IN BARRIER * pbarUse,
    IN ULONG    ulThreads,
    IN ULONG    ulTimeout
    );

void
BarrierSync(
    IN BARRIER * pbarUse
    );

void
RpcTimeSet(
    IN ULONG IPAddr, 
    IN RPCCALL rpcCall, 
    IN ULONG ulRunTimeSecs
    );

void
RpcTimeReset(
    void
    );

void
RpcSyncSet(
    IN ULONG IPAddr, 
    IN RPCCALL rpcCall
    ); 

void
RpcSyncReset(
    void
    );

void RpcTest(
    ULONG IPAddr, 
    RPCCALL rpcCall
    ); 

RPCCALL 
GetRpcCallA(
    LPSTR pszDsa
    );

ULONG
GetIPAddrA(
    LPSTR pszDSA
    );

#endif /* DBG */

VOID					 
LogRpcExtendedErrorInfo(
    THSTATE * pTHS,
    RPC_STATUS status,
    LPWSTR pszServer,
    ULONG dsid
    );

#if DBG

VOID
DebugPrintRpcExtendedErrorInfo(
    USHORT level,
    LPWSTR pszComputerName,
    ULONG dsid,
    RPC_EXTENDED_ERROR_INFO * pErrorInfo
    );

#define DPRINT_RPC_EXTENDED_ERROR_INFO(w,x,y,z) DebugPrintRpcExtendedErrorInfo(w,x,y,z)
#else
#define DPRINT_RPC_EXTENDED_ERROR_INFO(w,x,y,z) 
#endif

#endif /* _DRARPC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drametap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drametap.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines PRIVATE per-property meta-data parsing,
    and updating functions. Some drameta.c functions cannot be
    exported outside dra, thus (for instance due to REQ_MSG_UPDATE
    declaration incompatibilities) we would define them here for
    exclusive dra usage
    Implementation is still defined in drameta.c

Author:

     eyals

Revision History:

    when            who             what
    3/28/00         eyals           created


--*/

#ifndef _DRAMETAP_H_
#define _DRAMETAP_H_

//
// Note: REQ_UPDATE_MSG is unavailable for ntdsa/src sources,
// thus the prototype cannot be declared in drameta.h
//
void
ReplFilterPropsToShip(
    THSTATE                     *pTHS,
    DSNAME                      *pDSName,
    ATTRTYP                     rdnType,
    BOOL                        fIsSubRef,
    USN                         usnPropWaterMark,
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,
    PROPERTY_META_DATA_VECTOR   *pMetaData,
    ATTRBLOCK                   *pAttrBlock,
    BOOL                        fFilterGroupMember,
    DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn
    );

BOOL
ReplFilterGCAttr(
    ATTRTYP                     attid,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,    // [in]
    DRS_MSG_GETCHGREQ_NATIVE *  pMsgIn,              // [in]
    BOOL                        fFilterGroupMember,  // [in]
    BOOL*                       pfIgnoreWatermarks   // [out]
    );




#endif // _DRAMETAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drasch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       drasch.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This module defines the structures and
    functions to manipulate partial attribute set

Author:

    R.S. Raghavan (rsraghav)	

Revision History:

    Created     <mm/dd/yy>  rsraghav

--*/

#ifndef _DRASCH_H_
#define _DRASCH_H_

#include <drs.h>

// Structure that represents a GC partial replica deletion list stored in the NC Head
typedef struct _GCDeletionList
{
    USN     usnUnused;               	    // unused, but potentially contains a non-zero value
					    // if upgraded from Win2K - formerly usnHighestToBeProcessed
    USN     usnLastProcessed;               // represents the last processed changed USN in the background deletion
    PARTIAL_ATTR_VECTOR PartialAttrVecDel;  // partial attr vecs that are to be deleted

} GCDeletionList;

#define GCDeletionListSizeFromLen(cAttrs) (offsetof(GCDeletionList, PartialAttrVecDel) + PartialAttrVecV1SizeFromLen(cAttrs))
#define GCDeletionListSize(pDList) (offsetof(GCDeletionList, PartialAttrVecDel) + PartialAttrVecV1Size(&pDList->PartialAttrVecDel))

// Structure that represents the currently processed partial replica deletion list
typedef struct _GCDeletionListProcessed
{
    DSNAME          *pNC;                   // pointer to the dsname of the NC
    GCDeletionList  *pGCDList;              // pointer to the corresponding deletion list
    ULONG           purgeCount;             // count of objects that are already purged in this NC
    BOOL            fReload;                // flag that tells if DeletionList for this NC has to be reloaded
    BOOL            fNCHeadPurged;          // tells if the NCHead is already purged

} GCDeletionListProcessed;

// Interval for checking if partial replicas need to be purged (5 mins)
#define PARTIAL_REPLICA_PURGE_CHECK_INTERVAL_SECS (300)

//
// PAS states
//
#define PAS_RESET                0          // Resets to no-PAS entries in repsFrom, & identifies No-PAS state.
#define PAS_ACTIVE               1          // PAS cycle's on the task queue. PAS cycle is pending (or running) &
                                            // repsFrom entry is marked w/ it.
                                            // Also: Activate PAS cycle

#define PAS_IS_VALID(flag)      ( (flag) == PAS_ACTIVE )

BOOL
GC_IsMemberOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in]
    ATTRTYP                     attid,              // [in]
    OUT DWORD                   *pdwAttidPosition); // [out, optional]

BOOL
GC_AddAttributeToPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,   // [in, out]
    ATTRTYP                     attid);             // [in]

BOOL
GC_IsSamePartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec1,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec2);       // [in]

BOOL
GC_GetDiffOfPartialSets(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecOld,        // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecNew,        // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecAdded,    // [out]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVecDeleted); // [out]

BOOL
GC_IsSubsetOfPartialSet(
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec,           // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVecSuper);     // [in]

BOOL
GC_ReadPartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         **ppPartialAttrVec);// [out]

void
GC_GetPartialAttrSets(
    THSTATE                     *pTHS,              // [in]
    DSNAME                      *pNC,               // [in]
    REPLICA_LINK                *pRepLink,          // [in]
    PARTIAL_ATTR_VECTOR         **ppPas,            // [out]
    PARTIAL_ATTR_VECTOR         **ppPasEx           // [out, optional]
    );


VOID
GC_WritePartialAttributeSet(
    DSNAME                      *pNC,               // [in]
    PARTIAL_ATTR_VECTOR         *pPartialAttrVec);  // [in]

VOID
GC_TriggerSyncFromScratchOnAllLinks(
    DSNAME                      *pNC);              // [in]

BOOL
GC_ReadGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              **ppGCDList);       // [out]

VOID
GC_WriteGCDeletionList(
    DSNAME                      *pNC,               // [in]
    GCDeletionList              *pGCDList);         // [in]

BOOL
GC_GetGCDListToProcess(
    DSNAME **ppNC,                  // [out]
    GCDeletionList **ppGCDList);    // [out]

BOOL
GC_ReinitializeGCDListProcessed(
    BOOL fCompletedPrevious,        // [in]
    BOOL *pfMorePurging);           // [out]

BOOL
GC_UpdateLastUsnProcessedAndPurgeCount(
    USN     usnLastProcessed,       // [in]
    ULONG   cPurged);               // [in]

PARTIAL_ATTR_VECTOR     *
GC_RemoveOverlappedAttrs(
    PARTIAL_ATTR_VECTOR     *pAttrVec1,              // [in, out]
    PARTIAL_ATTR_VECTOR     *pAttrVec2,              // [in]
    BOOL                    *pfRemovedOverlaps);     // [out]

GCDeletionList *
GC_AddMoreAttrs(
    GCDeletionList           *pGCDList,             // [in]
    PARTIAL_ATTR_VECTOR     *pAttrVec);             // [in]

PARTIAL_ATTR_VECTOR*
GC_ExtendPartialAttributeSet(
    THSTATE                     *pTHS,              // [in]
    PARTIAL_ATTR_VECTOR         *poldPAS,           // [in, out]
    PARTIAL_ATTR_VECTOR         *paddedPAS);        // [in]

PARTIAL_ATTR_VECTOR*
GC_CombinePartialAttributeSet(
    THSTATE                     *pTHS,              // [in]
    PARTIAL_ATTR_VECTOR         *pPAS1,             // [in]
    PARTIAL_ATTR_VECTOR         *pPAS2 );           // [in]


VOID
GC_ProcessPartialAttributeSetChanges(
    THSTATE     *pTHS,                              // [in]
    DSNAME      *pNC,                               // [in]
    UUID*        pActiveSource);                    // [optional, in]

//
// Partial Attribute Set (PAS) functions
//
void
GC_LaunchSyncPAS (
    THSTATE      *pTHS,               // [in]
    DSNAME*      pNC,                 // [in]
    UUID*                   pActiveSource,       // [optional, in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS);

ULONG
GC_FindValidPASSource(
    THSTATE*     pTHS,                // [in]
    DSNAME*      pNC,                 // [in]
    UUID*        pUuidDsa             // [optional, out]
    );

BOOL
GC_ValidatePASLink(
    REPLICA_LINK *pPASLink          // [in]
    );

VOID
GC_TriggerFullSync (
    THSTATE*                pTHS,                // [in]
    DSNAME*                 pNC,                 // [in]
    PARTIAL_ATTR_VECTOR     *pAddedPAS);         // [in]

ULONG
GC_GetPreferredSource(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    UUID        **ppPrefUuid         // [ptr in, out]
    );

#define DSA_PREF_RW                 0x1         // Preferred RW source
#define DSA_PREF_INTRA              0x2         // Preferred intra-site source
#define DSA_PREF_IP                 0x4         // Preferred over ip xport
#define DSA_PREF_VER                0x8         // Preferred DSA version (post w2k)
VOID
GC_GetDsaPreferenceCriteria(
    THSTATE*    pTHS,                // [in]
    DSNAME*     pNC,                 // [in]
    REPLICA_LINK *pRepsFrom,         // [in]
    PDWORD      pdwFlag);            // [out]

ULONG
GC_RegisterPAS(
    THSTATE     *pTHS,              // [in]
    DSNAME      *pNC,               // [in]
    UUID        *pUuidDsa,          // [optional, in]
    PARTIAL_ATTR_VECTOR   *pPAS,    // [optional, in]
    DWORD       dwOp,               // [in]
    BOOL        fResetUsn           // [in]
    );

ULONG
GC_CompletePASReplication(
    THSTATE               *pTHS,                    // [in]
    DSNAME                *pNC,                     // [in]
    UUID                  *pUuidDsa,                // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSet,           // [in]
    PARTIAL_ATTR_VECTOR* pPartialAttrSetEx          // [in]
    );

BOOL
GC_StaleLink(
    REPLICA_LINK *prl                   // [in]
    );

// end of PAS functions


#endif // _DRASCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drasig.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       drasig.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

This header contains defintions and functions for replication signatures.  Signatures
are a history of replication entities. This history is stored in blob attributes.

Author:

    DS Team

Environment:

Notes:

Revision History:

This file split off from drautil.c on Apr 23, 2002

--*/

#ifndef _DRASIG_
#define _DRASIG_

void
APIENTRY
InitInvocationId(
    IN  THSTATE *   pTHS,
    IN  BOOL        fRetireOldID,
    IN  BOOL        fRestoring,
    OUT USN *       pusnAtBackup    OPTIONAL
    );



// This structure defines a retired DSA Signature
// Obsolete format used prior to Win2k RTM RC1.
typedef struct _REPL_DSA_SIGNATURE_OLD
{
    UUID uuidDsaSignature;      // uuid representing the DSA signature that has
                                //   been retired
    SYNTAX_TIME timeRetired;    // time when the signature was retired
} REPL_DSA_SIGNATURE_OLD;

// This structure defines retired DSA Signature vector that is stored on an
// ntdsDSA object.
// Obsolete format used in Win2k beta 3.
typedef struct _REPL_DSA_SIGNATURE_VECTOR_OLD
{
    DWORD cNumSignatures;
    REPL_DSA_SIGNATURE_OLD rgSignature[1];
} REPL_DSA_SIGNATURE_VECTOR_OLD;

// useful macros
#define ReplDsaSignatureVecOldSizeFromLen(cNumSignatures)       \
    (offsetof(REPL_DSA_SIGNATURE_VECTOR_OLD, rgSignature[0])    \
     + (cNumSignatures) * sizeof(REPL_DSA_SIGNATURE_OLD))

#define ReplDsaSignatureVecOldSize(pSignatureVec) \
    ReplDsaSignatureVecOldSizeFromLen((pSignatureVec)->cNumSignatures)



typedef struct _REPL_DSA_SIGNATURE_V1 {
    UUID        uuidDsaSignature;   // uuid representing the DSA signature that
                                    //   has been retired
    SYNTAX_TIME timeRetired;        // time when the signature was retired
    USN         usnRetired;         // local usn at which sig was retired
} REPL_DSA_SIGNATURE_V1;

#define REPL_DSA_SIGNATURE_ENTRY_NATIVE REPL_DSA_SIGNATURE_V1

typedef struct _REPL_DSA_SIGNATURE_VECTOR_V1 {
    DWORD                   cNumSignatures;
    REPL_DSA_SIGNATURE_V1   rgSignature[1];
} REPL_DSA_SIGNATURE_VECTOR_V1;

#define REPL_DSA_SIGNATURE_VECTOR_NATIVE REPL_DSA_SIGNATURE_VECTOR_V1

typedef struct _REPL_DSA_SIGNATURE_VECTOR {
    DWORD   dwVersion;
    union {
        REPL_DSA_SIGNATURE_VECTOR_V1    V1;
    };
} REPL_DSA_SIGNATURE_VECTOR;

#define ReplDsaSignatureVecV1SizeFromLen(cNumSignatures)       \
    (offsetof(REPL_DSA_SIGNATURE_VECTOR, V1)                   \
     + offsetof(REPL_DSA_SIGNATURE_VECTOR_V1, rgSignature[0])  \
     + (cNumSignatures) * sizeof(REPL_DSA_SIGNATURE_V1))

#define ReplDsaSignatureVecV1Size(pSignatureVec) \
    ReplDsaSignatureVecV1SizeFromLen((pSignatureVec)->V1.cNumSignatures)


REPL_DSA_SIGNATURE_VECTOR *
DraReadRetiredDsaSignatureVector(
    IN  THSTATE *   pTHS,
    IN  DBPOS *     pDB
    );

VOID
DraGrowRetiredDsaSignatureVector( 
    IN     THSTATE *   pTHS,
    IN     UUID *      pinvocationIdOld,
    IN     USN *       pusnAtBackup,
    IN OUT REPL_DSA_SIGNATURE_VECTOR ** ppSigVec,
    OUT    DWORD *     pcbSigVec
    );

BOOL
DraIsInvocationIdOurs(
    IN THSTATE *pTHS,
    UUID *pUuidDsaOriginating,
    USN *pusnSince
    );

void
DraImproveCallersUsnVector(
    IN     THSTATE *          pTHS,
    IN     UUID *             puuidDsaObjDest,
    IN     UPTODATE_VECTOR *  putodvec,
    IN     UUID *             puuidInvocIdPresented,
    IN     ULONG              ulFlags,
    IN OUT USN_VECTOR *       pusnvecFrom
    );




// Signature when a naming context is "unhosted" from this DSA
// A record that we used to hold this writeable naming context but
// no longer do.

typedef struct _REPL_NC_SIGNATURE_V1 {
    UUID        uuidNamingContext;  // Which naming context
    SYNTAX_TIME dstimeRetired;      // time when the signature was retired
    USN         usnRetired;         // local usn at which sig was retired
} REPL_NC_SIGNATURE_V1;

// Define native version
typedef REPL_NC_SIGNATURE_V1 REPL_NC_SIGNATURE;

typedef struct _REPL_NC_SIGNATURE_VECTOR_V1 {
    DWORD                   cNumSignatures;
    UUID                    uuidInvocationId;   // Invocation id of all signatures
    REPL_NC_SIGNATURE_V1    rgSignature[1];
} REPL_NC_SIGNATURE_VECTOR_V1;

typedef struct _REPL_NC_SIGNATURE_VECTOR {
    DWORD   dwVersion;
    union {
        REPL_NC_SIGNATURE_VECTOR_V1    V1;
    };
} REPL_NC_SIGNATURE_VECTOR;

#define ReplNcSignatureVecV1SizeFromLen(cNumSignatures)       \
    (offsetof(REPL_NC_SIGNATURE_VECTOR, V1)                   \
     + offsetof(REPL_NC_SIGNATURE_VECTOR_V1, rgSignature[0])  \
     + (cNumSignatures) * sizeof(REPL_NC_SIGNATURE_V1))

#define ReplNcSignatureVecV1Size(pSignatureVec) \
    ReplNcSignatureVecV1SizeFromLen((pSignatureVec)->V1.cNumSignatures)


VOID
DraRetireWriteableNc(
    IN  THSTATE *pTHS,
    IN  DSNAME *pNC
    );

VOID
DraHostWriteableNc(
    THSTATE *pTHS,
    DSNAME *pNC
    );

#endif /* _DRASIG_ */

/* end drasig.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drauptod.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drauptod.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Manages the per-NC up-to-date vectors, which record the highest originating
    writes we've seen from a set of DSAs.  This vector, in turn, is used in
    GetNCChanges() calls to filter out redundant property changes before they
    hit the wire.

DETAILS:

CREATED:

    08/27/96   Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#ifndef DRAUPTOD_H_INCLUDED
#define DRAUPTOD_H_INCLUDED

#define UTODVEC_fUpdateLocalCursor  ( 1 )

VOID
UpToDateVec_Read(
    IN  DBPOS *             pDB,
    IN  SYNTAX_INTEGER      InstanceType,
    IN  DWORD               dwFlags,
    IN  USN                 usnLocalDsa,
    OUT UPTODATE_VECTOR **  pputodvec
    );

VOID
UpToDateVec_Improve(
    IN      DBPOS *             pDB,
    IN      UPTODATE_VECTOR *   putodvecRemote
    );

VOID
UpToDateVec_Replace(
    IN      DBPOS *             pDB,
    IN      UUID *              pRemoteDsa,
    IN      USN_VECTOR *        pUsnVec,
    IN OUT  UPTODATE_VECTOR *   pUTD
    );

BOOL
UpToDateVec_IsChangeNeeded(
    IN  UPTODATE_VECTOR *   pUpToDateVec,
    IN  UUID *              puuidDsaOrig,
    IN  USN                 usnOrig
    );

BOOL
UpToDateVec_GetCursorUSN(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT USN *               pusnCursorUSN
    );

BOOL
UpToDateVec_GetCursorTimestamp(
    IN  UPTODATE_VECTOR *   putodvec,
    IN  UUID *              puuidDsaOrig,
    OUT DSTIME *            ptimeLastSyncSuccess
    );

UPTODATE_VECTOR *
UpToDateVec_Convert(
    IN  THSTATE *           pTHS,
    IN  DWORD               dwOutVersion,
    IN  UPTODATE_VECTOR *   pIn             OPTIONAL
    );

void
UpToDateVec_AddTimestamp(
    IN      UUID *                      puuidInvocId,
    IN      DSTIME                      timeToAdd,
    IN OUT  UPTODATE_VECTOR *           pUTD
    );

VOID
UpToDateVec_Merge(
    IN THSTATE *           pTHS,
    IN UPTODATE_VECTOR *   pUTD1,
    IN UPTODATE_VECTOR *   pUTD2,
    OUT UPTODATE_VECTOR ** ppUTDMerge
    );

BOOL
UpToDateVec_ValidateExternal(
    IN  UPTODATE_VECTOR *    pIn,
    IN  size_t               cbIn
    );

BOOL
UpToDateVec_HasSunkSince(
    IN      DBPOS *             pDB,
    IN      SYNTAX_INTEGER      it,
    IN      DSTIME *            ptimeLastSyncSuccess
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drautil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drautil.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#include <minmax.h>

struct _MAIL_REP_MSG;
struct _DRS_MSG_GETCHGREQ_V8;
struct _DRS_MSG_GETCHGREPLY_V6;
union _DRS_MSG_GETCHGREQ;
union _DRS_MSG_GETCHGREPLY;

// Critical section for NC sync data.

extern CRITICAL_SECTION csNCSyncData;

extern BOOL gfInitSyncsFinished;

// The following data is private to drautil.c, but is exposed for the
// benefit of the debugging extensions.

// Structure for sources for initial sync.
// Variable length structure, always null terminated

typedef struct _NCSYNCSOURCE {
    struct _NCSYNCSOURCE *pNextSource;
    BOOL fCompletedSrc;
    ULONG ulResult;
    ULONG cchDSA; // Count, in chars, of name, not incl term
    WCHAR szDSA[1]; // always terminated
} NCSYNCSOURCE;

// Structure for initial sync accounting.

typedef struct _NCSYNCDATA {
    ULONG ulUntriedSrcs;        // Unattempted sync sources
    ULONG ulTriedSrcs;          // Attempted sources
    ULONG ulLastTriedSrcs;      // Previous number attempted sources
    ULONG ulReplicaFlags;       // Writable?
    BOOL fSyncedFromOneSrc;           // Set when full synced from one source
    BOOL fNCComplete;           // NC is synced or we've tried all sources.
    struct _NCSYNCDATA *pNCSDNext;
    NCSYNCSOURCE *pFirstSource;
    DSNAME NC;
} NCSYNCDATA;

extern NCSYNCDATA *gpNCSDFirst; // Head of NC sync data list

extern ULONG gulNCUnsynced; // Count of NCs that have not been synced since startup
extern ULONG gulNCUnsyncedWrite; // Count of unsynced writable
extern ULONG gulNCUnsyncedReadOnly; // Count of unsynced readonly

// The way we know if we got through the promotion process once
extern BOOL gfWasPreviouslyPromotedGC;

// To track GC promotion progress
extern CRITICAL_SECTION csGCState;

extern ULONG gulRestoreCount; // Count of restores done on this DC so far

extern BOOL gfJustRestored;

// This is the reference to the global setting which indicates whether
// this feature is enabled. Code that checks this flag should be synchonized
// for the thread's lifetime. We check the global once when a thread
// state is created. Feature code should check the cached view of this
// flag in the thread state and not use this one.
extern BOOL gfLinkedValueReplication;

// Strict replication consistency mode
extern BOOL gfStrictReplicationConsistency;
extern BOOL gfStrictScheduleWindow;

// Pause after we determine we have no unsynced NCs before we recheck.

#define ADMIN_UPDATE_CHECK_PAUSE_SECS   180

// These are the states of the GC Partition Occupancy Variable
// values
#define GC_OCCUPANCY_MIN                            0
#define GC_OCCUPANCY_NO_REQUIREMENT                 0
#define GC_OCCUPANCY_ATLEAST_ONE_ADDED              1
#define GC_OCCUPANCY_ATLEAST_ONE_SYNCED             2
#define GC_OCCUPANCY_ALL_IN_SITE_ADDED              3
#define GC_OCCUPANCY_ALL_IN_SITE_SYNCED             4
#define GC_OCCUPANCY_ALL_IN_FOREST_ADDED            5
#define GC_OCCUPANCY_ALL_IN_FOREST_SYNCED           6
#define GC_OCCUPANCY_MAX                            6
#define GC_OCCUPANCY_DEFAULT                        GC_OCCUPANCY_MAX

// First delay after GC promotion (if enabled)
// This should be enough for the KCC to run, and for all the GCs
// in the Enterprise to replicate in
#define GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS (5)
#define GC_PROMOTION_INITIAL_CHECK_PERIOD_SECS \
(GC_PROMOTION_INITIAL_CHECK_PERIOD_MINS*60)

// Period of checking that initial syncing is making progress
#if DBG
#define SYNC_CHECK_PERIOD_SECS  (10*60)         // 5 minutes
#else
#define SYNC_CHECK_PERIOD_SECS  (30*60)         // 30 minutes
#endif

// Period for check instantiated ncs task
#define CHECK_INSTANTIATED_NCS_PERIOD_SECS  (5*60)         // 5 minutes

// Client context structure.  Is allocated and initialized on bind, a pointer
// to which is passed in on subsequent calls, and is freed on unbind.
typedef struct _DRS_CLIENT_CONTEXT
{
    LIST_ENTRY          ListEntry;
    LONG                lReferenceCount;  // number of users of this struct		
    UUID                uuidDsa;          // objectGuid of client's ntdsDSA obj
    SESSION_KEY         sessionKey;       // keys for RPC session encryption
    union {
        BYTE            rgbExtRemote[ CURR_MAX_DRS_EXT_STRUCT_SIZE ];
        DRS_EXTENSIONS  extRemote;
    };
    DSTIME              timeLastUsed;     // time client last used this ctx
    ULONG               IPAddr;           // IP address of client machine
    
    union {
        BYTE            rgbExtLocal[ CURR_MAX_DRS_EXT_STRUCT_SIZE ];
        DRS_EXTENSIONS  extLocal;
    };

    BOOL                fLPC:1;
} DRS_CLIENT_CONTEXT;

extern LIST_ENTRY gDrsuapiClientCtxList;
extern CRITICAL_SECTION gcsDrsuapiClientCtxList;
extern BOOL gfDrsuapiClientCtxListInitialized;
extern DWORD gcNumDrsuapiClientCtxEntries;

// Structure for keeping track of the replicas we're periodically synching
typedef struct{
    void * pvQEntry;
    DSNAME * pDNRepNC;
} PERREP_ENTRY ;

// Function prototypes

DWORD GetExceptData (EXCEPTION_POINTERS* pExceptPtrs, USHORT *pret);

BOOL MtxSame(UNALIGNED MTX_ADDR *pmtx1, UNALIGNED MTX_ADDR *pmtx2);

DWORD InitDRA(
    THSTATE *pTHS
    );

USHORT InitFreeDRAThread (THSTATE *pTHS, USHORT transType);

void CloseFreeDRAThread (THSTATE *pTHS, BOOL fCommit);

REPLICA_LINK *
FixupRepsFrom(
    REPLICA_LINK *prl,
    PDWORD       pcbPrl
    );


ULONG
FindDSAinRepAtt(
    DBPOS *                 pDB,
    ATTRTYP                 attid,
    DWORD                   dwFindFlags,
    UUID *                  puuidDsaObj,
    UNALIGNED MTX_ADDR *    pmtxDRA,
    BOOL *                  pfAttExists,
    REPLICA_LINK **         pprl,
    DWORD *                 pcbRL
    );
#define DRS_FIND_DSA_BY_ADDRESS ( 0 )
#define DRS_FIND_DSA_BY_UUID    ( 1 )   /* Bit field */
#define DRS_FIND_AND_REMOVE     ( 2 )   /* Bit field */

#define SZGUIDLEN (36)

void InitDraThreadEx(THSTATE **ppTHS, DWORD dsid);
#define InitDraThread(ppTHS) InitDraThreadEx((ppTHS), DSID(FILENO,__LINE__))

void BeginDraTransactionEx(USHORT transType, BOOL fBypassUpdatesEnabledCheck);
#define BeginDraTransaction(t) BeginDraTransactionEx((t), FALSE)

USHORT EndDraTransaction(BOOL fCommit);
ULONG  EndDraTransactionSafe(BOOL fCommit);

DWORD  DraReturn(THSTATE *pTHS, DWORD status);

VOID
SetDRAAuditStatus(THSTATE * pTHS);

DWORD
FindNC(
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  ULONG               ulOptions,
    OUT SYNTAX_INTEGER *    pInstanceType   OPTIONAL
    );
#define FIND_MASTER_NC  1       /* Bit field */
#define FIND_REPLICA_NC 2       /* Bit field */

VOID GetObjDN(DBPOS *pDB, DSNAME *pDN);

void
GetExpectedRepAtt(
    IN  DBPOS * pDB,
    IN  ATTRTYP type,
    OUT VOID *  pOutBuf,
    IN  ULONG   size
    );

ULONG InitDRATasks(
    THSTATE *pTHS
    );

void HandleRestore(
    IN PDS_INSTALL_PARAM   InstallInParams  OPTIONAL
    );

void
draRetireInvocationID(
    IN OUT  THSTATE *   pTHS,
    IN BOOL fRestoring,
    OUT UUID * pinvocationIdOld OPTIONAL,
    OUT USN * pusnAtBackup OPTIONAL
    );

BOOL IsFSMOSelfOwnershipValid( DSNAME *pNC );

void FindNCParentDorA (DBPOS *pDB, DSNAME * pDN, ULONG * pNCDNT);

UCHAR * MakeMtxPrintable (THSTATE *pTHS, UNALIGNED MTX_ADDR *pmtx_addr);

BOOL fNCFullSync (DSNAME *pNC);

void AddInitSyncList (DSNAME *pNC, ULONG ulReplicaFlags, LPWSTR source);

void InitSyncAttemptComplete(DSNAME *pNC, ULONG ulOptions, ULONG ulResult, LPWSTR source );

void
CheckInitSyncsFinished(
    void
    );

void
CheckGCPromotionProgress(
    IN  void *  pvParam,
    OUT void ** ppvNext,
    OUT DWORD * pcSecsUntilNextIteration
    );

BOOL
DraIsPartitionSynchronized(
    DSNAME *pNC
    );

BOOL fIsBetweenTime(REPLTIMES *, DSTIME, DSTIME);

BOOL
IsDraAccessGranted(
    IN  THSTATE *       pTHS,
    IN  DSNAME *        pNC,
    IN  const GUID *    pControlAccessRequired,
    OUT DWORD *         pdwError
    );

// Get the number of elements in an array.
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

#if DBG
void
UpToDateVec_Validate(
    IN  UPTODATE_VECTOR *   putodvec
    );

void
UsnVec_Validate(
    IN  USN_VECTOR *        pusnvec
    );
#else
#define UpToDateVec_Validate(x) /* nada */
#define UsnVec_Validate(x) /* nada */
#endif

void
DupAttr(
    IN  THSTATE * pTHS,
    IN  ATTR *    pInAttr,
    OUT ATTR *    pOutAttr
    );

VOID
CopyExtensions(
    DRS_EXTENSIONS *pextSrc,
    DRS_EXTENSIONS *pextDst
    );

// Convert an MTX_ADDR (such as that embedded in a REPLICA_LINK structure) into
// a Unicode server name.  Returned string is allocated off the thread heap.
#define TransportAddrFromMtxAddrEx(pmtx) \
    UnicodeStringFromString8(CP_UTF8, (pmtx)->mtx_name, -1)

MTX_ADDR *
MtxAddrFromTransportAddrEx(
    IN  THSTATE * pTHS,
    IN  LPWSTR    psz
    );

DSNAME *
DSNameFromStringW(
    IN  THSTATE *   pTHS,
    IN  LPWSTR      pszDN
    );

DSNAME *
DSNameFromStringA(
    IN  THSTATE *   pTHS,
    IN  LPSTR       pszDN
    );

DWORD
AddSchInfoToPrefixTable(
    IN THSTATE *pTHS,
    IN OUT SCHEMA_PREFIX_TABLE *pPrefixTable
    );


VOID
StripSchInfoFromPrefixTable(
    IN SCHEMA_PREFIX_TABLE *pPrefixTable,
    OUT PBYTE pSchemaInfo
    );

BOOL
CompareSchemaInfo(
    IN THSTATE *pTHS,
    IN PBYTE pSchemaInfo,
    OUT BOOL *pNewSchemaIsBetter OPTIONAL
    );

DWORD
WriteSchInfoToSchema(
    IN PBYTE pSchemaInfo,
    OUT BOOL *pfSchInfoChanged
    );

VOID
draGetLostAndFoundGuid(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    OUT GUID *      pguidLostAndFound
    );


//
// Dns Fully qualified (dns)domain name validation macros
// Notes:
//   - All other possible return codes (from DnsValidate_Name) are valid.
//   - Files using these macros must include <dnsapi.h> & ensure the
//     corresponding lib dnsapi.lib is linked.
//   - DnsNameHostnameFull ensures that a) name cannot be numeric, b) allows
//     single labeled non-dotted host name (thus the extra dot check)
//   - NULL names are skipped.
//


#define VALIDATE_RAISE_FQ_DOT_DNS_NAME_W( pwszName )             \
{                                                                \
    if ( pwszName &&                                             \
         ( ERROR_INVALID_NAME ==                                 \
          DnsValidateName_W( pwszName, DnsNameHostnameFull ) ||  \
          NULL == wcschr( pwszName, L'.' ) )) {                  \
        DRA_EXCEPT(DNS_ERROR_INVALID_NAME, 0);                  \
    }                                                            \
}


#define VALIDATE_RAISE_FQ_DOT_DNS_NAME_UTF8( pszName )           \
{                                                                \
    if ( pszName &&                                              \
         ( ERROR_INVALID_NAME ==                                 \
            DnsValidateName_UTF8( pszName, DnsNameHostnameFull ) || \
            NULL == strchr( pszName, '.') )) {                   \
        DRA_EXCEPT(DNS_ERROR_INVALID_NAME, 0);                  \
    }                                                            \
}

BOOL
draIsCompletionOfDemoteFsmoTransfer(
    IN  struct _DRS_MSG_GETCHGREQ_V8 *  pMsgIn  OPTIONAL
    );

DWORD
DraUpgrade(
    THSTATE     *pTHS,
    LONG        lOldDsaVer,
    LONG        lNewDsaVer
    );

void
DraSetRemoteDsaExtensionsOnThreadState(
    IN  THSTATE *           pTHS,
    IN  DRS_EXTENSIONS *    pextRemote
    );

LPWSTR
GetNtdsDsaDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidNtdsDsaObj
    );

LPWSTR
GetTransportDisplayName(
    IN  THSTATE * pTHS,
    IN  GUID *    pguidTransportObj
    );

DWORD
DraGetNcSize(
    IN  THSTATE *                     pTHS,
    IN  BOOL                          fCriticalOnly,
    IN  ULONG                         dntNC
);


///////////////////////////////////////////////////////////////////////////////
//
//  from dramsg.c
//

#define DRA_XLATE_COMPRESS      (1)
#define DRA_XLATE_FSMO_REPLY    (2)

void
draXlateNativeRequestToOutboundRequest(
    IN  THSTATE *                       pTHS,
    IN  struct _DRS_MSG_GETCHGREQ_V8 *  pNativeReq,
    IN  MTX_ADDR *                      pmtxLocalDSA        OPTIONAL,
    IN  UUID *                          puuidTransportDN    OPTIONAL,
    IN  DWORD                           dwMsgVersionToSend,
    OUT union _DRS_MSG_GETCHGREQ *      pOutboundReq
    );

void
draXlateInboundRequestToNativeRequest(
    IN  THSTATE *                       pTHS,
    IN  DWORD                           dwInboundReqVersion,
    IN  union _DRS_MSG_GETCHGREQ *      pInboundReq,
    IN  DRS_EXTENSIONS *                pExt,
    OUT struct _DRS_MSG_GETCHGREQ_V8 *  pNativeReq,
    OUT DWORD *                         pdwReplyVersion,
    OUT MTX_ADDR **                     ppmtxReturnAddress,
    OUT UUID *                          puuidTransportObj
    );

DWORD
draXlateNativeReplyToOutboundReply(
    IN      THSTATE *                         pTHS,
    IN      struct _DRS_MSG_GETCHGREPLY_V6 *  pNativeReply,
    IN      DWORD                             dwXlateFlags,
    IN      DRS_EXTENSIONS *                  pExt,
    IN OUT  DWORD *                           pdwMsgOutVersion,
    OUT     union _DRS_MSG_GETCHGREPLY *      pOutboundReply
    );

void
draXlateInboundReplyToNativeReply(
    IN  THSTATE *                           pTHS,
    IN  DWORD                               dwOutVersion,
    IN  union _DRS_MSG_GETCHGREPLY *        pInboundReply,
    IN  DWORD                               dwXlateFlags,
    OUT struct _DRS_MSG_GETCHGREPLY_V6 *    pNativeReply
    );

DWORD
draEncodeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwMsgVersion,
    IN  union _DRS_MSG_GETCHGREQ *  pReq,
    IN  DWORD                       cbHeaderSize,
    OUT BYTE **                     ppbEncodedMsg,
    OUT DWORD *                     pcbEncodedMsg
    );

ULONG
draDecodeRequest(
    IN  THSTATE *                   pTHS,
    IN  DWORD                       dwMsgVersion,
    IN  BYTE *                      pbEncodedMsg,
    IN  DWORD                       cbEncodedMsg,
    OUT union _DRS_MSG_GETCHGREQ *  pReq
    );

ULONG
draEncodeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwMsgVersion,
    IN  union _DRS_MSG_GETCHGREPLY *  pmsgUpdReplica,
    IN  DWORD                         cbHeaderSize,
    OUT BYTE **                       ppbEncodedMsg,
    OUT DWORD *                       pcbEncodedMsg
    );

ULONG
draDecodeReply(
    IN  THSTATE *                     pTHS,
    IN  DWORD                         dwMsgVersion,
    IN  BYTE *                        pbEncodedMsg,
    IN  DWORD                         cbEncodedMsg,
    OUT union _DRS_MSG_GETCHGREPLY *  pmsgUpdReplica
    );

DSNAME *
draGetServerDsNameFromGuid(
    IN THSTATE *pTHS,
    IN eIndexId idx,
    IN UUID *puuid
    );

ULONG
draGetCursors(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pNC,
    IN  DS_REPL_INFO_TYPE   InfoType,
    IN  DWORD               dwBaseIndex,
    IN  PDWORD              pdwNumRequested,
    OUT void **             ppCursors
    );

void
draFreeCursors(
    IN THSTATE *            pTHS,
    IN DS_REPL_INFO_TYPE    InfoType,
    IN void *               pCursors
    );

BOOL
IsMasterForNC(
    DBPOS *           pDB,
    DSNAME *          pServer,
    DSNAME *          pNC
    );

LPWSTR
GetDomainDnsHostnameFromNC(
    THSTATE * pTHS,
    DSNAME * pNC
    );

BOOL
IsDomainNC(
    DSNAME * pNC
    );

int
DraFindAliveGuid(
    IN UUID * puuid
    );

BOOL
DraIsRecentOriginatingChange(
    IN THSTATE *pTHS,
    IN DSNAME *pObjectDn,
    IN ATTRTYP AttrType
    );

DWORD
DraRemoveSingleLingeringObject(
    THSTATE *pTHS,
    DBPOS *  pDB,
    DSNAME * pSource,
    DSNAME * pDN
    );

USN DraGetCursorUsnForDsa(
    THSTATE * pTHS,
    DSNAME *  pDSA,
    DSNAME *  pNC
    );

#define IsGuidBasedDNSName(szAddr)  DSAGuidFromGuidDNSName(szAddr, NULL, NULL, TRUE)
#define IsOurGuidAddr(sz)           (IsEqualGuidAddr(sz, &(gAnchor.pDSADN->Guid)))

BOOL
DSAGuidFromGuidDNSName(
    LPWSTR pszAddr,
    GUID * pGuidOut OPTIONAL,
    LPWSTR pszGuidOut OPTIONAL,
    BOOL   fSkipRootDomainCheck
    );

BOOL
IsEqualGuidAddr(
    WCHAR *     szAddr,
    GUID *      pGuid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\dsaapi.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       dsaapi.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    In-process replication API.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

#ifndef _dsaapi_h_
#define _dsaapi_h_

ULONG
DirReplicaAdd(
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  LPWSTR      pszSourceDsaAddress,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions
    );

ULONG
DirReplicaModify(
    DSNAME *    pNC,
    UUID *      puuidSourceDRA,
    UUID *      puuidTransportObj,
    LPWSTR      pszSourceDRA,
    REPLTIMES * prtSchedule,
    ULONG       ulReplicaFlags,
    ULONG       ulModifyFields,
    ULONG       ulOptions
    );
#define DRS_UPDATE_ALL        ( 0 )         // 0x00
#define DRS_UPDATE_FLAGS      ( 1 << 0 )    // 0x01
#define DRS_UPDATE_ADDRESS    ( 1 << 1 )    // 0x02
#define DRS_UPDATE_SCHEDULE   ( 1 << 2 )    // 0x04
#define DRS_UPDATE_RESULT     ( 1 << 3 )    // 0x08
#define DRS_UPDATE_TRANSPORT  ( 1 << 4 )    // 0x10
#define DRS_UPDATE_PAS        ( 1 << 5 )    // 0x20
#define DRS_UPDATE_USN        ( 1 << 6 )    // 0x40
// The difference between UPDATE_FLAGS and UPDATE_SYSTEM_FLAGS is
// that UPDATE_FLAGS is not allowed to change the state of system
// reserved flags.
#define DRS_UPDATE_SYSTEM_FLAGS (1 << 7 )   // 0x80

#define DRS_UPDATE_MASK       (   DRS_UPDATE_FLAGS    \
                                | DRS_UPDATE_ADDRESS  \
                                | DRS_UPDATE_SCHEDULE \
                                | DRS_UPDATE_RESULT   \
                                | DRS_UPDATE_TRANSPORT\
                                | DRS_UPDATE_PAS      \
                                | DRS_UPDATE_USN      \
                                | DRS_UPDATE_SYSTEM_FLAGS \
                              )

ULONG
DirReplicaDelete(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        ULONG ulOptions
);

ULONG
DirReplicaSynchronize(
        DSNAME *pNC,
        LPWSTR pszSourceDRA,
        UUID * puuidSourceDRA,
        ULONG ulOptions
);

ULONG
DirReplicaReferenceUpdate(
        DSNAME *pNC,
        LPWSTR pszReferencedDRA,
        UUID * puuidReferencedDRA,
        ULONG ulOptions
);

typedef struct _DRS_DEMOTE_TARGET_SEARCH_INFO {
    DWORD cNumAttemptsSoFar;
    GUID  guidLastDSA;
} DRS_DEMOTE_TARGET_SEARCH_INFO;
                        
ULONG
DirReplicaGetDemoteTarget(
    IN      DSNAME *                        pNC,
    IN OUT  DRS_DEMOTE_TARGET_SEARCH_INFO * pDTSInfo,
    OUT     LPWSTR *                        ppszDemoteTargetDNSName,
    OUT     DSNAME **                       ppDemoteTargetDSADN
    );

ULONG
DirReplicaDemote(
    IN  DSNAME *    pNC,
    IN  LPWSTR      pszOtherDSADNSName,
    IN  DSNAME *    pOtherDSADN,
    IN  ULONG       ulOptions
    );

DWORD
DirReplicaSetCredentials(
    IN HANDLE ClientToken,
    IN WCHAR *User,
    IN WCHAR *Domain,
    IN WCHAR *Password,
    IN ULONG  PasswordLength   // number of characters NOT including terminating
                               // NULL
    );

#endif /* _dsaapi_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\dstaskq.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dstaskq.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

DETAILS:

CREATED:

REVISION HISTORY:

    01/10/97    Jeff Parham (jeffparh)
                Extracted task queue functions to taskq.h (with some
                modifications) such that the task queue code can be moved to a
                more abstract, general-purpose library.

--*/

#include <taskq.h>

extern void TQ_BuildHierarchyTable(     void *, void **, DWORD * );
extern void TQ_DelayedFreeMemory(       void *, void **, DWORD * );
extern void TQ_SynchronizeReplica(      void *, void **, DWORD * );
extern void TQ_GarbageCollection(       void *, void **, DWORD * );
extern void TQ_CheckSyncProgress(       void *, void **, DWORD * );
extern void TQ_CheckAsyncQueue(         void *, void **, DWORD * );
extern void TQ_CheckReplLatency(        void *, void **, DWORD * );
extern void TQ_DelayedMailStart(        void *, void **, DWORD * );
extern void TQ_DelayedFreeSchema(       void *, void **, DWORD * );
extern void TQ_ReloadDNReadCache(       void *, void **, DWORD * );
extern void TQ_NT4ReplicationCheckpoint(void *, void **, DWORD * );
extern void TQ_PurgePartialReplica(     void *, void **, DWORD * );
extern void TQ_GroupTypeCacheMgr(       void *, void **, DWORD * );
extern void TQ_FPOCleanup(              void *, void **, DWORD * );
extern void TQ_RebuildAnchor(           void *, void **, DWORD * );
extern void TQ_WriteServerInfo(         void *, void **, DWORD * );
extern void TQ_StalePhantomCleanup(     void *, void **, DWORD * );
extern void TQ_DRSExpireContextHandles( void *, void **, DWORD * );
extern void TQ_DelayedSDPropEnqueue(    void *, void **, DWORD * );
extern void TQ_ProtectAdminGroups(      void *, void **, DWORD * );
extern void TQ_CheckFullSyncProgress(   void *, void **, DWORD * );
extern void TQ_CheckGCPromotionProgress(void *, void **, DWORD * );
extern void TQ_CountAncestorsIndexSize (void *, void **, DWORD * );
extern void TQ_RefreshUserMemberships  (void *, void **, DWORD * );
extern void TQ_LinkCleanup(             void *, void **, DWORD * );
extern void TQ_DeleteExpiredEntryTTLMain(void *,void **, DWORD * );
extern void TQ_RebuildCatalog(          void *, void **, DWORD * );
extern void TQ_FailbackOffsiteGC(       void *, void **, DWORD * );
extern void TQ_BehaviorVersionUpdate(   void *, void **, DWORD * );
extern void TQ_RebuildRefCache(         void *, void **, DWORD * );
extern void TQ_CacheScriptOptype(       void *, void **, DWORD * );
extern void TQ_ValidateDsaDomain(       void *, void **, DWORD * );
extern void TQ_DelayLogOutofConnections(void *, void **, DWORD * );
extern void TQ_DelayLogOutofSendQueue(  void *, void **, DWORD * );
extern void TQ_CheckInstantiatedNCs(    void *, void **, DWORD * );
extern void TQ_RebuildQuotaTable(       void *, void **, DWORD * );
extern void TQ_MoveOrphanedObject(      void *, void **, DWORD * );
extern void TQ_DelayedEnqueueInitSyncs( void *, void **, DWORD * );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\dsatools.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dsatools.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Directory utility definitions

Author:

    DS team

Environment:

Notes:

Revision History:

--*/

#ifndef _DSATOOLS_
#define _DSATOOLS_

#include "direrr.h"        /* header for error codes */


// Global NULL UUID

extern UUID gNullUuid;

// Global NULL NT4SID

extern NT4SID gNullNT4SID;

// Global usn vector indicating the NC should be synced from scratch.

extern USN_VECTOR gusnvecFromScratch;

// Global usn vector indicating the NC should be synced from max USNs
// (i.e., don't send any objects).

extern USN_VECTOR gusnvecFromMax;

// Time that DSA was started

extern DSTIME gtimeDSAStarted;

/*-------------------------------------------------------------------------*/

/* Start the transaction by setting a database sync point and initializing
   some resource flags.  Every transaction must start with a call to this
   function after a transaction handle has been obtained (pTHS).  There are
   three types of transactions,  read transactions, write transactions which
   require exclusive access (the usual case), and write transactions that
   allow readers.
*/

extern int APIENTRY SyncTransSet(USHORT tranType);

extern VOID APIENTRY SyncTransEnd(THSTATE * pTHS, BOOL fCommit);

/* Ends the transaction by commiting and cleaning up all resources
   and returns. This function may be called multiple times with no ill
   effect.
*/

extern int APIENTRY  CleanReturn(THSTATE *pTHS, DWORD dwError, BOOL fAbnormalTerm);

/* N.B. This define must be manually kept in sync with the function
 *      IsSpecial() in dsamain\src\parsedn.c.
 */
#define DN_SPECIAL_CHARS L",=\r\n+<>#;\"\\"

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/

/* A transaction always begins by setting either a read or write sync point.
   This will set the appropriate locks and initialize thread global vars.

*/

#define SYNC_READ_ONLY         0
#define SYNC_WRITE             1

// Transaction entry/exit prototypes for Dir* APIs.

extern void
SYNC_TRANS_READ(void);

extern void
SYNC_TRANS_WRITE(void);

extern void
_CLEAN_BEFORE_RETURN(
    DWORD   err,
    BOOL    fAbnormalTermination);

#define CLEAN_BEFORE_RETURN(err) _CLEAN_BEFORE_RETURN(err, AbnormalTermination())

/*
SRALLOC macro

New version is simplified some.

The macro should be simplified more:
It may not be necessary to treat SRALLOCDontRestSize cases
specially here.  Also, CleanReturn's return value is always the
same value as passed in, unless SRALLOC_SIZE_ERROR.   This
trick in CleanReturn() should be thought out -- is it necessary, the
right place, and what interaction with this macro is there?

Actually, the whole thing should be gutted.

*/


#define SRALLOC( pTHS, size, ppLoc )                                    \
        if (!(*(ppLoc) = THAlloc((DWORD) size)))                        \
        {                                                               \
            return SetSvcError(SV_PROBLEM_ADMIN_LIMIT_EXCEEDED,         \
                        DIRERR_USER_BUFFER_TO_SMALL );                  \
        }                                                               \

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* Initialize the primary thread data structure. This must be the first
   call in every transaction API handler.
*/

THSTATE* _InitTHSTATE_(DWORD CallerType, DWORD dsid);
#define InitTHSTATE(CallerType) \
    _InitTHSTATE_(CallerType, ((FILENO << 16) | __LINE__))

THSTATE * create_thread_state( void );

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This macro can be used to compare two DN's for equality */

#define IS_DN_EQUAL(pDN1, pDN2)                          \
  (   ((pDN1)->AVACount        == (pDN2)->AVACount)      \
   && (NameMatched(pDN1, pDN2) == (pDN1)->AVACount)      \
  )

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* These functions are used to dynamically allocate memory on a transaction
   basis.  In other words, to allocate memory that belongs to a single
   thread and a single invocation of an API.  The model is that
   THAlloc is called to allocate some transaction memory.  It allocates
   memory and stores the address in the pMem array.  pMem is dynamically
   allocated and will grow to hold all transaction memory addresses.

   THAllocEx takes it's size as a DWORD, and throws an exception if
   something goes wrong.

   THFree is used to release all transaction allocations.

   The non-excepting versions are now exported, and hence live in ntdsa.h

*/

void * APIENTRY THAllocException(THSTATE *pTHS,
                                 DWORD size,
                                 BOOL fUseHeapOrg,
                                 DWORD ulId);

#define THAllocEx(pTHS, size) \
    THAllocException(pTHS, (size), FALSE, ((FILENO << 16) | __LINE__))

#define THAllocOrgEx(pTHS, size) \
    THAllocException(pTHS, size, TRUE, ((FILENO << 16) | __LINE__))

#ifndef USE_THALLOC_TRACE
    void * APIENTRY THAllocOrg(THSTATE* pTHS, 
                               DWORD size);
#else
    void * APIENTRY THAllocOrgDbg(THSTATE *pTHS, DWORD size, DWORD dsid);
    #define THAllocOrg(pTHS, size) \
        THAllocOrgDbg((pTHS), (size), ((FILENO << 16) | __LINE__))
#endif

void * APIENTRY THReAllocException(THSTATE *pTHS,
                                   void * memory,
                                   DWORD size,
                                   BOOL fUseHeapOrg,
                                   DWORD ulId);

#define THReAllocEx(pTHS, memory, size) THReAllocException(pTHS, memory, size, FALSE, \
                          ((FILENO << 16) | __LINE__))

#define THReAllocOrgEx(pTHS, memory, size) \
    THReAllocException(pTHS, memory, size, TRUE, ((FILENO << 16) | __LINE__))



#ifdef USE_THALLOC_TRACE
VOID THFreeEx_(THSTATE *pTHS, VOID *buff, DWORD dsid);
#define THFreeEx(pTHS, buff) THFreeEx_(pTHS, buff, ((FILENO << 16) | __LINE__))
VOID THFreeOrg_(THSTATE *pTHS, VOID *buff, DWORD dsid);
#define THFreeOrg(pTHS, buff) THFreeOrg_(pTHS, buff, ((FILENO << 16) | __LINE__))
#else
VOID THFreeEx(THSTATE *pTHS, VOID *buff);

VOID THFreeOrg(THSTATE *pTHS, VOID *buff);
#endif


//  versions of THAlloc et al that take a pTHS but do NOT throw an exception
#ifdef USE_THALLOC_TRACE
void* THAllocNoEx_(THSTATE* pTHS, DWORD size, DWORD ulId);
#define THAllocNoEx(pTHS, size) THAllocNoEx_(pTHS, size, ((FILENO << 16) | __LINE__))
void* THReAllocNoEx_(THSTATE* pTHS, void* memory, DWORD size, DWORD ulId);
#define THReAllocNoEx(pTHS, memory, size) THReAllocNoEx_(pTHS, memory, size, ((FILENO << 16) | __LINE__))
void THFreeNoEx_(THSTATE* pTHS, void* buff, DWORD ulId);
#define THFreeNoEx(pTHS, buff) THFreeNoEx_(pTHS, buff, ((FILENO << 16) | __LINE__))
void* THReAllocOrg_(THSTATE* pTHS, void* buff, DWORD size, DWORD ulId);
#define THReAllocOrg(pTHS, buff, size) THReAllocOrg_(pTHS, buff, size, ((FILENO << 16) | __LINE__))
#else
void* THAllocNoEx(THSTATE* pTHS, DWORD size);
void* THReAllocNoEx(THSTATE* pTHS, void* memory, DWORD size);
void THFreeNoEx(THSTATE* pTHS, void* buff);
void* THReAllocOrg(THSTATE* pTHS, void* memory, DWORD size);
#endif

#ifdef USE_THALLOC_TRACE
// Overload THAlloc, THReAlloc and THFree so that internal callers are traced
// These are still defined as functions for external callers in the end of dsatools.c
#define THAlloc(size) THAllocEx(pTHStls, size)
#define THReAlloc(memory, size) THReAllocEx(pTHStls, memory, size)
#define THFree(buff) THFreeEx(pTHStls, buff)
#endif


VOID free_thread_state( VOID );

//number of slots in each CPU heap cache
#define HEAP_CACHE_SIZE_PER_CPU   8

//data structure for thread memory allocation
typedef struct _HMEM
{
    HANDLE    hHeap;
    THSTATE * pTHS;
    PUCHAR    pZone;
} HMEM;

//data structure for heap cache of each CPU
typedef struct _HEAPCACHE
{
    HMEM slots[HEAP_CACHE_SIZE_PER_CPU];
    DWORD  index;
    CRITICAL_SECTION csLock;
#if DBG
    DWORD cGrabHeap;
#endif
} HEAPCACHE;


// Processor Local Storage
//
// This space is used for very hot data that is accessed in a manner that is
// partitioned per ideal processor.  Place any data here that is frequently
// modified and can be partitioned.  Note that cache line alignment within PLS
// is not really important because the data will stay on one proc 99% of the
// time.

#include "sync.h"

typedef struct _PLS {

    // Core

    HEAPCACHE       heapcache;                      // Heap/THSTATE cache
    ULONG           cRegisterHotListSkip;           // number of hot list registrations to skip
    ULONG           cRegisterHotListSkipped;        // number of skipped hot list registrations
    SYNC_RW_LOCK    rwlGlobalDNReadCache;           // Lock protecting the global DN Read cache
                                                    //   to get R lock, R lock ideal proc
                                                    //   to get W lock, W lock ALL procs!
    SYNC_RW_LOCK    rwlSchemaPtrUpdate;             // Lock protecting the schema
    
    ULONG           cTotalSearchesInLastPeriod;     // DirSearch count

    // LDAP

    CRITICAL_SECTION    LdapConnCacheLock;          // connection cache lock
    LIST_ENTRY          LdapConnCacheList;          // connection cache
    CRITICAL_SECTION    LdapRequestCacheLock;       // request cache lock
    LIST_ENTRY          LdapRequestCacheList;       // request cache
    ULONG               LdapClientID;               // client ID (for WMI)
                                                    //   lower bits always equal proc number
                                                    //   incremented by MAXIMUM_PROCESSORS

} PLS, *PPLS;

extern PPLS grgPLS[MAXIMUM_PROCESSORS];
extern size_t gcProcessor;

// Returns the current processor number
__inline size_t
GetProcessor()
{
    return NtCurrentTeb()->IdealProcessor;
}

// Returns the number of processors
__inline size_t
GetProcessorCount()
{
    return gcProcessor;
}

// Returns PLS for the current ideal proc
__inline PPLS
GetPLS()
{
    return grgPLS[GetProcessor()];
}

// Returns PLS for a specific proc or NULL if that proc doesn't exist
__inline PPLS
GetSpecificPLS(
    IN      const size_t    iProc
    )
{
    return iProc < MAXIMUM_PROCESSORS ? grgPLS[iProc] : NULL;
}


/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This function determines if the current object is an alias by looking
   for the alias class in the object's class hierarchy
*/

extern BOOL APIENTRY IsAlias(DBPOS *pDB);


#if DBG
#define CACHE_UUID 1
#endif

#ifdef CACHE_UUID
void CacheUuid (UUID *pUuid, char * pDSAName);
#endif

// The string returned by UuidToStr() with uuid caching is an ascii
// version of the uuid, the string server name, a space and a zero.
// Without caching, the string is ommitted.  The size of the array
// should be based on whether caching is enabled.
#define MAX_SERVER_NAME_LEN MAX_PATH
#ifdef CACHE_UUID
#define SZUUID_LEN ((2*sizeof(UUID)) + MAX_SERVER_NAME_LEN +2)
#else
#define SZUUID_LEN ((2*sizeof(UUID))+1)
#endif

/*--------------------------------------------------------------------*/
/*--------------------------------------------------------------------*/
/* This function produces a printable string name for an object.  The string
   is assumed to be large enough to hold the output!  It returns a pointer
   to the output string parameter.
*/

extern UCHAR * GetExtDN(THSTATE *pTHS, DBPOS *pDB);

extern DSNAME * GetExtDSName(DBPOS *pDB);

extern UCHAR * MakeDNPrintable(DSNAME *pDN);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* This function retrieves only living objects from the database.  It performs
   a  DBFind  and checks that the found  object has  not been logically
   deleted.
*/

#define FIND_ALIVE_FOUND 0
#define FIND_ALIVE_NOTFOUND 1
#define FIND_ALIVE_SYSERR   2
#define FIND_ALIVE_BADNAME  3
#define FIND_ALIVE_OBJ_DELETED  4

extern int APIENTRY  FindAliveDSName(DBPOS FAR *pDB, DSNAME *pDN);

extern VOID TH_mark(THSTATE *pTHS);

extern VOID TH_free_to_mark(THSTATE *pTHS);

#define CP_TELETEX  20261
#define CP_NON_UNICODE_FOR_JET 1252
#ifndef CP_WINUNICODE
#define CP_WINUNICODE 1200
#endif

/* This function takes a string in the clients code page and converts it
   to a unicode string.
*/
extern wchar_t  *UnicodeStringFromString8(UINT CodePage, char *szA, LONG cbA);

/* This function takes a unicode string allocates memory and converts it to
   the client's code page
*/
extern char *
String8FromUnicodeString (
        BOOL bThrowExcept,
        UINT CodePage,
        wchar_t *szU,
        LONG cbU,
        LPLONG pCb,
        LPBOOL pfUsedDefChar);

//
// helper function which takes a DSNAME and returns its hashkey
//
extern DWORD DSNAMEToHashKey(THSTATE *pTHS, const DSNAME *pDN);

//
// helper function which takes a DSNAME and returns its LCMapped version
// this can be used in string comparisons using strcmp
//
extern CHAR* DSNAMEToMappedStr(THSTATE *pTHS, const DSNAME *pDN);

//
// helper function which takes a WCHAR and returns its hashkey
//
extern DWORD DSStrToHashKey(THSTATE *pTHS, const WCHAR *pStr, int cchLen);

//
// helper function that takes a WCHAR string and returns the LCMapped version
// cchMaxStr is the maximum expected size of the passed in string
//
extern CHAR * DSStrToMappedStr (THSTATE *pTHS, const WCHAR *pStr, int cchMaxStr);


//------------------------------------------------------------------------------
// the following is taken from hashfn.h (LKRHash) by prepending DS in al functions

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

__inline DWORD
DSHashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}

// Faster scrambling function

__inline DWORD
DSHashRandomizeBits(DWORD dw)
{
        return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
#define DS_HASH_MULTIPLIER 101

#undef DS_HASH_SHIFT_MULTIPLY

#ifdef DS_HASH_SHIFT_MULTIPLY
# define DS_HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define DS_HASH_MULTIPLY(dw)   ((dw) * DS_HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.

__inline DWORD
DSHashString(
    const char* psz,
    DWORD       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = DS_HASH_MULTIPLY(dwHash)  +  *upsz;

    return DSHashScramble (dwHash);
}


// Unicode version of above

__inline DWORD
DSHashStringW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = DS_HASH_MULTIPLY(dwHash)  +  *pwsz;

    return DSHashScramble (dwHash);
}

//------------------------------------------------------------------------------

/* This function takes a buffer of DWORDS, the first DWORD being a count
   of the rest of the DWORDS, and the rest of the DWORDS are pointers to
   free.  It frees them, then frees the buffer.
*/
extern void
DelayedFreeMemoryEx (
        DWORD_PTR *buffer,
        DWORD timeDelay
        );


extern void
DelayedFreeMemory(
        void * buffer,
        void ** ppvNext,
        DWORD * pcSecsUntilNext
        );

#define DELAYED_FREE( pv )                                          \
    if ( DsaIsInstalling() )                                        \
    {                                                               \
        free( pv );                                                 \
    }                                                               \
    else                                                            \
    {                                                               \
        DWORD_PTR * pdw;                                            \
                                                                    \
        pdw = malloc( 2 * sizeof( DWORD_PTR ) );                    \
                                                                    \
        if ( NULL == pdw )                                          \
        {                                                           \
            LogUnhandledError( 0 );                                 \
        }                                                           \
        else                                                        \
        {                                                           \
            pdw[ 0 ] = 1;                                           \
            pdw[ 1 ] = (DWORD_PTR) (pv);                            \
            InsertInTaskQueue( TQ_DelayedFreeMemory, pdw, 3600 );   \
        }                                                           \
    }

extern DWORD dwTSindex;
#define MACROTHSTATE 1
#ifdef  MACROTHSTATE
#define pTHStls ((THSTATE*)TlsGetValue(dwTSindex))
#else
/* This is the thread specific, globally accessible, thread state variable. */
extern __declspec(thread) THSTATE *pTHStls;
#endif

BOOL fNullUuid (const UUID *pUuid);
BOOL fNullNT4SID (NT4SID *pSid);

// Returns TRUE if the attribute is one that we don't allow people to set and
// that we simply skip if it is specified in an add entry call.
BOOL SysAddReservedAtt(ATTCACHE *pAC);


// returns TRUE if pDN is a descedent of pPrefix.  Only uses the string portion
// of the DSNAMEs
extern unsigned
NamePrefix(const DSNAME *pPrefix,
           const DSNAME *pDN);

// Converts a string into a distname, allocating memory.  Returns 0 on success
DWORD StringDNtoDSName(char *szDN, DSNAME **pDistname);


// Convert from a UTC or Generalised Time string to a SYNTAX_TIME
BOOL
fTimeFromTimeStr (
        SYNTAX_TIME *psyntax_time,
        OM_syntax syntax,
        char *pb,
        ULONG len,
        BOOL *pLocalTimeSpecified
        );

// Get a unique dword, used to identify a client connection by a head.
// Currently only used by LDAP head and the SDProp enqueuer to keep track of
// which sessions started which SD prop events.
DWORD
dsGetClientID(
        void
        );


#define ACTIVE_CONTAINER_SCHEMA      1
#define ACTIVE_CONTAINER_SITES       2
#define ACTIVE_CONTAINER_SUBNETS     3
#define ACTIVE_CONTAINER_PARTITIONS  4
#define ACTIVE_CONTAINER_OUR_SITE    5

#define ACTIVE_CONTAINER_LIST_ID_MAX 5


DWORD
RegisterActiveContainerByDNT(
        ULONG DNT,
        DWORD ID
        );

DWORD
RegisterActiveContainer(
        DSNAME *pDN,
        DWORD   ID
        );
void
CheckActiveContainer(
        DWORD PDNT,
        DWORD *pID
        );

// Values from call type
#define ACTIVE_CONTAINER_FROM_ADD    0
#define ACTIVE_CONTAINER_FROM_MOD    1
#define ACTIVE_CONTAINER_FROM_MODDN  2
#define ACTIVE_CONTAINER_FROM_DEL    3

DWORD
PreProcessActiveContainer (
        THSTATE    *pTHS,
        DWORD      dwCallType,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        DWORD      ID
        );

DWORD
PostProcessActiveContainer (
        THSTATE    *pTHS,
        DWORD      dwCallType,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        DWORD      ID
        );

ULONG CheckRoleOwnership(THSTATE *pTHS,
                         DSNAME  *pRoleObject,
                         DSNAME  *pOperationTarget);

typedef struct _DirWaitItem {
    struct _DirWaitItem * pNextItem;

    DWORD      hServer;
    DWORD      hClient;
    PF_PFI     pfPrepareForImpersonate;
    PF_TD      pfTransmitData;
    PF_SI      pfStopImpersonating;
    ULONG      DNT;
    UCHAR      choice;
    BOOL       bOneNC;
    ENTINFSEL *pSel;
    SVCCNTL    Svccntl;
} DirWaitItem;

typedef struct _DirWaitKey {
    DWORD           DNT;
    UCHAR           choice;
} DirWaitKey;

typedef struct _DirWaitEntry {
    DirWaitKey      key;
    DirWaitItem*    pList;
} DirWaitEntry;

typedef struct _DirNotifyItem {
    DWORD                  DNT;
    DirWaitItem           *pWaitItem;
    struct _DirNotifyItem *pNext;
} DirNotifyItem;

ULONG DirNotifyThread(void * parm);
BOOL
DirPrepareForImpersonate (
        DWORD hClient,
        DWORD hServer,
        void ** ppImpersonateData
        );
VOID
DirStopImpersonating (
        DWORD hClient,
        DWORD hServer,
        void * pImpersonateData
        );
void
NotifyWaitersPostProcessTransactionalData(
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

// Find a Naming Context corresponding to the Sid
BOOLEAN
FindNcForSid(
    IN PSID pSid,
    OUT PDSNAME * NcName
    );


VOID
SetInstallStatusMessage (
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4, OPTIONAL
    IN  WCHAR *Insert5  OPTIONAL
    );

VOID
SetInstallErrorMessage (
    IN  DWORD  WinError,
    IN  DWORD  MessageId,
    IN  WCHAR *Insert1, OPTIONAL
    IN  WCHAR *Insert2, OPTIONAL
    IN  WCHAR *Insert3, OPTIONAL
    IN  WCHAR *Insert4  OPTIONAL
    );

//
// This global variable is used to keep track of what operations
// are done during InstallBaseNTDS, so that they may be undone if the operation
// fails.
//
extern ULONG gInstallOperationsDone;

#define SET_INSTALL_ERROR_MESSAGE0( err, msgid ) \
    SetInstallErrorMessage( (err), (msgid), NULL, NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE1( err, msgid, a ) \
    SetInstallErrorMessage( (err), (msgid), (a), NULL, NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE2( err, msgid, a, b ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), NULL, NULL )

#define SET_INSTALL_ERROR_MESSAGE3( err, msgid, a, b, c ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), (c), NULL )

#define SET_INSTALL_ERROR_MESSAGE4( err, msgid, a , b, c, d ) \
    SetInstallErrorMessage( (err), (msgid), (a), (b), (c), (d) )

extern ULONG Win32ErrorFromPTHS(THSTATE *pTHS);

extern void __fastcall INC_READS_BY_CALLERTYPE(CALLERTYPE type);
extern void __fastcall INC_WRITES_BY_CALLERTYPE(CALLERTYPE type);
extern void __fastcall INC_SEARCHES_BY_CALLERTYPE(CALLERTYPE type);

void CleanUpThreadStateLeakage(void);

// Define hash table for use by Get-Changes to determine whether a given object
// has already been added to the output buffer (as keyed by its DNT).

typedef struct _DNT_HASH_ENTRY
{
    ULONG dnt;
    struct _DNT_HASH_ENTRY * pNext;
    DWORD dwData;
} DNT_HASH_ENTRY;

DNT_HASH_ENTRY *
dntHashTableAllocate(
    THSTATE *pTHS
    );

BOOL
dntHashTablePresent(
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    LPDWORD dwData OPTIONAL
    );

VOID
dntHashTableInsert(
    THSTATE *pTHS,
    DNT_HASH_ENTRY *pDntHashTable,
    DWORD dnt,
    DWORD dwData
    );

VOID
DsUuidCreate(
    GUID *pGUID
    );

VOID
DsUuidToStringW(
    IN  GUID   *pGuid,
    OUT PWCHAR *ppszGuid
    );

DWORD
GetBehaviorVersion(
    IN OUT  DBPOS       *pDB,
    IN      DSNAME      *dsObj,
    OUT     PDWORD      pdwBehavior);


PDSNAME
GetConfigDsName(
    IN  PWCHAR  wszParam
    );



#endif /* _DSATOOLS_ */

/* end dsatools.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\drsdra.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  File:       drsdra.h
//
//--------------------------------------------------------------------------

/*++

ABSTRACT:

    Internal replication API.  Should be called only by other replication APIs
    -- other callers should use the DirReplica* family of functions.

DETAILS:

CREATED:

REVISION HISTORY:

--*/

typedef struct _DRA_REPL_SESSION_STATISTICS {
    DWORD ObjectsReceived;
    DWORD ObjectsCreated;
    DWORD ValuesReceived;
    DWORD ValuesCreated;
    DWORD SourceNCSizeObjects;
    DWORD SourceNCSizeValues;
    DWORD ulTotalObjectsReceived;
    DWORD ulTotalObjectsCreated;
    DWORD ulTotalValuesReceived;
    DWORD ulTotalValuesCreated;
} DRA_REPL_SESSION_STATISTICS, *PDRA_REPL_SESSION_STATISTICS;

ULONG
DRA_ReplicaSync(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  UUID *      pinvocationid,
    IN  LPWSTR      pszDSA,
    IN  ULONG       ulOptions
    );

ULONG
DRA_ReplicaAdd(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  DSNAME *    pSourceDsaDN,               OPTIONAL
    IN  DSNAME *    pTransportDN,               OPTIONAL
    IN  MTX_ADDR *  pmtx_addr,
    IN  LPWSTR      pszSourceDsaDnsDomainName,  OPTIONAL
    IN  REPLTIMES * preptimesSync,              OPTIONAL
    IN  ULONG       ulOptions,
    OUT GUID *      puuidDsaObjSrc              OPTIONAL
    );

ULONG
DRA_ReplicaDel(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pSDSAMtx_addr,
    IN  ULONG       ulOptions
    );

ULONG DRA_UpdateRefs(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  MTX_ADDR *  pDSAMtx_addr,
    IN  UUID *      puuidDSA,
    IN  ULONG       ulOptions
    );

ULONG
DRA_GetNCChanges(
    IN  THSTATE *                     pTHS,
    IN  FILTER *                      pFilter,
    IN  DWORD                         dwDirSyncControlFlags,
    IN  DRS_MSG_GETCHGREQ_NATIVE *    pmsgIn,
    OUT DRS_MSG_GETCHGREPLY_NATIVE *  pmsgOut
    );

ULONG
DRA_ReplicaModify(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC,
    IN  UUID *      puuidSourceDRA,
    IN  UUID *      puuidTransportObj,
    IN  MTX_ADDR *  pmtxSourceDRA,
    IN  REPLTIMES * prtSchedule,
    IN  ULONG       ulReplicaFlags,
    IN  ULONG       ulModifyFields,
    IN  ULONG       ulOptions
    );

void
draConstructGetChgReq(
    IN  THSTATE *                   pTHS,
    IN  DSNAME *                    pNC,
    IN  REPLICA_LINK *              pRepsFrom,
    IN  UPTODATE_VECTOR *           pUtdVec             OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSet     OPTIONAL,
    IN  PARTIAL_ATTR_VECTOR *       pPartialAttrSetEx   OPTIONAL,
    IN  ULONG                       ulOptions,
    OUT DRS_MSG_GETCHGREQ_NATIVE *  pMsgReq
    );

void
draReportSyncProgress(
    THSTATE *pTHS,
    DSNAME *pNC,
    LPWSTR pszSourceServer,
    BOOL fMoreData,
    DRA_REPL_SESSION_STATISTICS *pReplStats
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\hiertab.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       hiertab.h
//
//--------------------------------------------------------------------------


#define HT_MAX_NAME	(257 * sizeof(wchar_t))
#define HT_MAX_RDN	64

typedef struct _HierarchyTableElement {
    wchar_t               *displayName;                        
    DWORD                 dwEph;
    DWORD                 depth;
    PUCHAR		  pucStringDN;
} HierarchyTableElement, * PHierarchyTableElement;

typedef struct _HierarchyTableType {
    DWORD                  Version;
    DWORD                  GALCount;
    DWORD                 *pGALs;
    DWORD                  TemplateRootsCount;
    DWORD                 *pTemplateRoots;
    DWORD	           Size;
    PHierarchyTableElement Table;
} HierarchyTableType, * PHierarchyTableType;


extern ULONG gulHierRecalcPause;

extern PHierarchyTableType    HierarchyTable;


extern void
BuildHierarchyTableMain (
        void *,
        void **,
        DWORD *
        );

extern DWORD
GetIndexSize (
        THSTATE *pTHS,
        DWORD ABCont
        );

extern DWORD
InitHierarchy (
        void
        );

extern void
HTGetHierarchyTablePointer (
        PHierarchyTableType    *ptHierTab,
        DWORD                  **ppIndexArray,
        DWORD                  SortLocale
        );

extern void
HTGetGALAndTemplateDNT (
        NT4SID *pSid,
        DWORD   cbSid,
        DWORD  *pGALDNT,
        DWORD  *pTemplateDNT
        ); 

#define HIERARCHY_DO_ONCE        0
#define HIERARCHY_PERIODIC_TASK  1
#define HIERARCHY_DELAYED_START  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\gcverify.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       gcverify.h
//
//--------------------------------------------------------------------------

#ifndef __GCVERIFY_H__
#define __GCVERIFY_H__

extern
ENTINF *
GCVerifyCacheLookup(
    DSNAME *pDSName);

ULONG
PreTransVerifyNcName(
    THSTATE *                 pTHS,
    ADDCROSSREFINFO *         pCRInfo
    );

extern
ULONG
GCVerifyDirAddEntry(
    ADDARG *pAddArg);

extern
ULONG
GCVerifyDirModifyEntry(
    MODIFYARG   *pModifyArg);

VOID
VerifyDSNAMEs_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

VOID
VerifySIDs_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

VOID
VerifySamAccountNames_V1(
    struct _THSTATE         *pTHS,
    DRS_MSG_VERIFYREQ_V1    *pmsgIn,
    DRS_MSG_VERIFYREPLY_V1  *pmsgOut);

typedef struct _FIND_DC_INFO
{
    DWORD   cBytes;
    DWORD   seqNum;
    DWORD   cchDomainNameOffset;
    WCHAR   addr[1];
    //  Note: pFindDCInfo->addr = server name
    //        pFindDCInfo->addr + cchDomainNameOffset = domain name
} FIND_DC_INFO;

// Structure to implement invalidated DC list
typedef struct _INVALIDATED_DC_LIST {
    struct _INVALIDATED_DC_LIST *pNext;
    LARGE_INTEGER   lastInvalidation;   // last time this DC was invalidated
    WCHAR           dcName[1];
} INVALIDATED_DC_LIST, *PINVALIDATED_DC_LIST;

extern LARGE_INTEGER gliForceRediscoveryWindow; 
extern LARGE_INTEGER gliForceWaitExpired;
extern LARGE_INTEGER gliHonorFailureWindow;
extern DWORD gdwFindGcOffsiteFailbackTime;
extern LARGE_INTEGER gliDcInvalidationPeriod;

// Returns DNS domain name of GC given a FIND_DC_INFO *.
#define FIND_DC_INFO_DOMAIN_NAME(pFindDCInfo) \
    (&(pFindDCInfo)->addr[(pFindDCInfo)->cchDomainNameOffset])

//
// Flags for Find GC/Find DC
//
#define FIND_DC_USE_CACHED_FAILURES      (0x1)
#define FIND_DC_USE_FORCE_ON_CACHE_FAIL  (0x2)
#define FIND_DC_GC_ONLY                 (0x4)
#define FIND_DC_FLUSH_INVALIDATED_DC_LIST (0x8)

extern
DWORD
FindDC(
    DWORD       dwFlags,
    WCHAR *     wszNcDns,
    FIND_DC_INFO **ppInfo);

#define FindGC(flags, output)   FindDC((flags) | FIND_DC_GC_ONLY, NULL, output)

extern
VOID
InvalidateGC(
    FIND_DC_INFO *pInfo,
    DWORD       winError);


DWORD
GCGetVerifiedNames (
        IN  THSTATE *pTHS,
        IN  DWORD    count,
        IN  PDSNAME *pObjNames,
        OUT PDSNAME *pVerifiedNames
        );

VOID
GCVerifyCacheAdd(
    IN struct _SCHEMA_PREFIX_MAP_TABLE * hPrefixMap,
    IN ENTINF * pEntInf);


#endif // __GCVERIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\lht.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    lht.h

Abstract:

    This module defines the data structures and function prototypes for an
    unsynchronized linear hash table (LHT).

Author:

    Andrew E. Goodsell (andygo) 01-Apr-2001

Revision History:

--*/

#ifndef _LHT_
#define _LHT_


typedef enum _LHT_ERR {
    LHT_errSuccess,             //  success
    LHT_errOutOfMemory,         //  not enough memory
    LHT_errInvalidParameter,    //  bad argument to function
    LHT_errEntryNotFound,       //  entry was not found
    LHT_errNoCurrentEntry,      //  currently not positioned on an entry
    LHT_errKeyDuplicate,        //  cannot insert because key already exists
    LHT_errKeyChange,           //  cannot replace because key has changed
    } LHT_ERR;

typedef
SIZE_T
(*LHT_PFNHASHKEY) (
    IN      PVOID   pvKey
    );

typedef
SIZE_T
(*LHT_PFNHASHENTRY) (
    IN      PVOID   pvEntry
    );

typedef
BOOLEAN
(*LHT_PFNENTRYMATCHESKEY) (
    IN      PVOID   pvEntry,
    IN      PVOID   pvKey
    );

typedef
VOID
(*LHT_PFNCOPYENTRY) (
    OUT     PVOID   pvEntryDest,
    IN      PVOID   pvEntrySrc
    );

typedef
PVOID
(*LHT_PFNMALLOC) (
    IN      SIZE_T  cbAlloc
    );

typedef
VOID
(*LHT_PFNFREE) (
    IN      PVOID   pvAlloc
    );

typedef struct _LHT LHT, *PLHT;
typedef struct _LHT_CLUSTER LHT_CLUSTER, *PLHT_CLUSTER;

typedef struct _LHT_POS {
    PLHT            plht;                   //  linear hash table
    BOOLEAN         fScan;                  //  we are scanning the table
    PLHT_CLUSTER    pClusterHead;           //  the first cluster in the current bucket
    SIZE_T          iBucket;                //  the current bucket index
    PLHT_CLUSTER    pCluster;               //  the current cluster in the current bucket
    PVOID           pvEntryPrev;            //  the previous entry
    PVOID           pvEntry;                //  the current entry
    PVOID           pvEntryNext;            //  the next entry
} LHT_POS, *PLHT_POS;

typedef struct _LHT_STAT {
    SIZE_T          cEntry;                 //  number of entries in table
    SIZE_T          cBucket;                //  number of buckets in use
    SIZE_T          cBucketPreferred;       //  preferred number of buckets
    SIZE_T          cOverflowClusterAlloc;  //  total overflow clusters allocated
    SIZE_T          cOverflowClusterFree;   //  total overflow clusters freed
    SIZE_T          cBucketSplit;           //  total buckets split
    SIZE_T          cBucketMerge;           //  total buckets merged
    SIZE_T          cDirectorySplit;        //  total directory splits
    SIZE_T          cDirectoryMerge;        //  total directory merges
    SIZE_T          cStateTransition;       //  total maintenance state transitions
    SIZE_T          cPolicySelection;       //  total maintenance policy selections
    SIZE_T          cMemoryAllocation;      //  total memory allocations
    SIZE_T          cMemoryFree;            //  total memory frees
    SIZE_T          cbMemoryAllocated;      //  total bytes of memory allocated
    SIZE_T          cbMemoryFreed;          //  total bytes of memory freed
} LHT_STAT, *PLHT_STAT;


EXTERN_C
LHT_ERR LhtCreate(
    IN      SIZE_T                      cbEntry,
    IN      LHT_PFNHASHKEY              pfnHashKey,
    IN      LHT_PFNHASHENTRY            pfnHashEntry,
    IN      LHT_PFNENTRYMATCHESKEY      pfnEntryMatchesKey,
    IN      LHT_PFNCOPYENTRY            pfnCopyEntry        OPTIONAL,
    IN      SIZE_T                      cLoadFactor         OPTIONAL,
    IN      SIZE_T                      cEntryMin           OPTIONAL,
    IN      LHT_PFNMALLOC               pfnMalloc           OPTIONAL,
    IN      LHT_PFNFREE                 pfnFree             OPTIONAL,
    IN      SIZE_T                      cbCacheLine         OPTIONAL,
    OUT     PLHT*                       pplht
    );
EXTERN_C
VOID LhtDestroy(
    IN      PLHT        plht    OPTIONAL
    );

EXTERN_C
VOID LhtMoveBeforeFirst(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    );
EXTERN_C
LHT_ERR LhtMoveNext(
    IN OUT  PLHT_POS    ppos
    );
EXTERN_C
LHT_ERR LhtMovePrev(
    IN OUT  PLHT_POS    ppos
    );
EXTERN_C
VOID LhtMoveAfterLast(
    IN      PLHT        plht,
    OUT     PLHT_POS    ppos
    );

EXTERN_C
LHT_ERR LhtFindEntry(
    IN      PLHT        plht,
    IN      PVOID       pvKey,
    OUT     PLHT_POS    ppos
    );

EXTERN_C
LHT_ERR LhtRetrieveEntry(
    IN OUT  PLHT_POS    ppos,
    OUT     PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtReplaceEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtInsertEntry(
    IN OUT  PLHT_POS    ppos,
    IN      PVOID       pvEntry
    );
EXTERN_C
LHT_ERR LhtDeleteEntry(
    IN OUT  PLHT_POS    ppos
    );

EXTERN_C
VOID LhtQueryStatistics(
    IN      PLHT        plht,
    OUT     PLHT_STAT   pstat
    );


#endif  //  _LHT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\mappings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       mappings.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains the Mappings from SAM Objects to DS Objects

Author:

    Murlis 16-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    14-Jun-96
        Added missing attributes (and corresponding ones in mappings.c), miscellaneous
        clean up and documentation.

    Murlis      16-Jun-96
        Added additional documentation, ordered attributes.

    ChrisMay    26-Jun-96
        Added work around so that SAMP_USER_FULL_NAME doesn't to the admin
        display name. Remapped SAMP_USER_GROUPS from zero to ATT_EXTENSION_ATTRIBUTE_2.

    ColinBr     18-Jul-96
        Added 3 new mappings for membership relation SAM attributes. If
        a SAM object doesn't use these attributes(SAMP_USER_GROUPS,
        SAMP_ALIAS_MEMBERS, and SAMP_GROUP_MEMBERS), then they are mapped
        to a benign field (ATT_USER_GROUPS).

--*/

#ifndef __MAPPINGS_H__
#define __MAPPINGS_H__

// Isolate the required includes here so most of SAM sources needn't be aware
// of DS include dependencies.

#include <samrpc.h>
#include <ntdsa.h>
#include <drs.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>

//+
//+  Define SAMP_OBJECT_TYPE structure
//+
typedef enum _SAMP_OBJECT_TYPE  {

    SampServerObjectType = 0,   // local-account object types
    SampDomainObjectType,
    SampGroupObjectType,
    SampAliasObjectType,
    SampUserObjectType,
    SampUnknownObjectType       // This is used as a max index value
                                // and so must follow the valid object types.
} SAMP_OBJECT_TYPE, *PSAMP_OBJECT_TYPE;

//++
//++ Define Unknowns for error handling
//++

#define DS_CLASS_UNKNOWN                        -1
#define DS_ATTRIBUTE_UNKNOWN                    -1
#define SAM_ATTRIBUTE_UNKNOWN                   -1



#define DS_SAM_ATTRIBUTE_BASE                   (131072+460)



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Each object type has a defined set of variable length attributes.   //
// These are arranged within the object as an array of offsets and     //
// lengths (SAMP_VARIABLE_LENGTH_ATTRIBUTE data types).                //
// This section defines the offset of each variable length attribute   //
// for each object type.                                               //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Variable length attributes common to all objects
//

#define SAMP_OBJECT_SECURITY_DESCRIPTOR (0L)


//
// Variable length attributes of a SERVER object
//

#define SAMP_SERVER_SECURITY_DESCRIPTOR (SAMP_OBJECT_SECURITY_DESCRIPTOR)

#define SAMP_SERVER_VARIABLE_ATTRIBUTES (1L)


//
// Variable length attributes of a DOMAIN object
//

#define SAMP_DOMAIN_SECURITY_DESCRIPTOR (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_DOMAIN_SID                 (1L)
#define SAMP_DOMAIN_OEM_INFORMATION     (2L)
#define SAMP_DOMAIN_REPLICA             (3L)

#define SAMP_DOMAIN_VARIABLE_ATTRIBUTES (4L)



//
// Variable length attributes of a USER object
//

#define SAMP_USER_SECURITY_DESCRIPTOR   (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_USER_ACCOUNT_NAME          (1L)
#define SAMP_USER_FULL_NAME             (2L)
#define SAMP_USER_ADMIN_COMMENT         (3L)
#define SAMP_USER_USER_COMMENT          (4L)
#define SAMP_USER_PARAMETERS            (5L)
#define SAMP_USER_HOME_DIRECTORY        (6L)
#define SAMP_USER_HOME_DIRECTORY_DRIVE  (7L)
#define SAMP_USER_SCRIPT_PATH           (8L)
#define SAMP_USER_PROFILE_PATH          (9L)
#define SAMP_USER_WORKSTATIONS          (10L)
#define SAMP_USER_LOGON_HOURS           (11L)
#define SAMP_USER_GROUPS                (12L)
#define SAMP_USER_DBCS_PWD              (13L)
#define SAMP_USER_UNICODE_PWD           (14L)
#define SAMP_USER_NT_PWD_HISTORY        (15L)
#define SAMP_USER_LM_PWD_HISTORY        (16L)

#define SAMP_USER_VARIABLE_ATTRIBUTES   (17L)


//
// Variable length attributes of a GROUP object
//

#define SAMP_GROUP_SECURITY_DESCRIPTOR  (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_GROUP_NAME                 (1L)
#define SAMP_GROUP_ADMIN_COMMENT        (2L)
#define SAMP_GROUP_MEMBERS              (3L)

#define SAMP_GROUP_VARIABLE_ATTRIBUTES  (4L)


//
// Variable length attributes of an ALIAS object
//

#define SAMP_ALIAS_SECURITY_DESCRIPTOR  (SAMP_OBJECT_SECURITY_DESCRIPTOR)
#define SAMP_ALIAS_NAME                 (1L)
#define SAMP_ALIAS_ADMIN_COMMENT        (2L)
#define SAMP_ALIAS_MEMBERS              (3L)

#define SAMP_ALIAS_VARIABLE_ATTRIBUTES  (4L)



//++
//++ Define SAM fixed-attribute IDs on a per-object type.
//++

#define SAM_FIXED_ATTRIBUTES_BASE                       100

//++ Server Object

#define SAMP_FIXED_SERVER_REVISION_LEVEL                SAM_FIXED_ATTRIBUTES_BASE +1
#define SAMP_FIXED_SERVER_USER_PASSWORD                 SAM_FIXED_ATTRIBUTES_BASE +2

//++ Domain Object


#define SAMP_FIXED_DOMAIN_CREATION_TIME                 SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_DOMAIN_MODIFIED_COUNT                SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE              SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE              SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_DOMAIN_FORCE_LOGOFF                  SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_DOMAIN_LOCKOUT_DURATION              SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW    SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION       SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_FIXED_DOMAIN_NEXT_RID                      SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_DOMAIN_PWD_PROPERTIES                SAM_FIXED_ATTRIBUTES_BASE + 9
#define SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH           SAM_FIXED_ATTRIBUTES_BASE + 10
#define SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH       SAM_FIXED_ATTRIBUTES_BASE + 11
#define SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD             SAM_FIXED_ATTRIBUTES_BASE + 12
#define SAMP_FIXED_DOMAIN_SERVER_STATE                  SAM_FIXED_ATTRIBUTES_BASE + 13
#define SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED           SAM_FIXED_ATTRIBUTES_BASE + 14
#define SAMP_DOMAIN_ACCOUNT_TYPE                        SAM_FIXED_ATTRIBUTES_BASE + 15
// The Following Domain Fixed Properties Correspond to fields added in NT 4.0 SP3 to the
// SAM fixed length data structures. These are used for encrypting credential information
// in NT4 SP3 SAM. Since NT5 Encryption relies upon a different scheme, No corresponding
// DS attributes are defined in mappings.c, but the following constants are reserved,
// should a use arise
#define SAMP_FIXED_DOMAIN_KEY_AUTH_TYPE                 SAM_FIXED_ATTRIBUTES_BASE + 16
#define SAMP_FIXED_DOMAIN_KEY_FLAGS                     SAM_FIXED_ATTRIBUTES_BASE + 17
#define SAMP_FIXED_DOMAIN_KEY_INFORMATION               SAM_FIXED_ATTRIBUTES_BASE + 18
// The following is a pseudo-attribute strictly so we have something to
// stick in DomainAttributeMappingTable in mappings.c.
#define SAMP_DOMAIN_MIXED_MODE                          SAM_FIXED_ATTRIBUTES_BASE + 19
#define SAMP_DOMAIN_MACHINE_ACCOUNT_QUOTA               SAM_FIXED_ATTRIBUTES_BASE + 20
#define SAMP_DOMAIN_BEHAVIOR_VERSION                    SAM_FIXED_ATTRIBUTES_BASE + 21 
#define SAMP_DOMAIN_LASTLOGON_TIMESTAMP_SYNC_INTERVAL   SAM_FIXED_ATTRIBUTES_BASE + 22 
#define SAMP_FIXED_DOMAIN_USER_PASSWORD                 SAM_FIXED_ATTRIBUTES_BASE + 23

//++ Group Object

#define SAMP_FIXED_GROUP_RID                            SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_GROUP_OBJECTCLASS                    SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_GROUP_ACCOUNT_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_GROUP_SID_HISTORY                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_GROUP_TYPE                           SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_GROUP_IS_CRITICAL                    SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_GROUP_MEMBER_OF                      SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_GROUP_SID                            SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_GROUP_NON_MEMBERS                          SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_GROUP_USER_PASSWORD                  SAM_FIXED_ATTRIBUTES_BASE + 9



//++ Alias Object

#define SAMP_FIXED_ALIAS_RID                            SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_ALIAS_OBJECTCLASS                    SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_ALIAS_ACCOUNT_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_ALIAS_SID_HISTORY                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_ALIAS_TYPE                           SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_ALIAS_SID                            SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_ALIAS_NON_MEMBERS                          SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_ALIAS_LDAP_QUERY                           SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_FIXED_ALIAS_USER_PASSWORD                  SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_ALIAS_IS_CRITICAL                    SAM_FIXED_ATTRIBUTES_BASE + 9



//++ User Object

#define SAMP_FIXED_USER_LAST_LOGON                      SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_FIXED_USER_LAST_LOGOFF                     SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_FIXED_USER_PWD_LAST_SET                    SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_FIXED_USER_ACCOUNT_EXPIRES                 SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME          SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_FIXED_USER_USERID                          SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_FIXED_USER_PRIMARY_GROUP_ID                SAM_FIXED_ATTRIBUTES_BASE + 6
#define SAMP_FIXED_USER_ACCOUNT_CONTROL                 SAM_FIXED_ATTRIBUTES_BASE + 7
#define SAMP_FIXED_USER_COUNTRY_CODE                    SAM_FIXED_ATTRIBUTES_BASE + 8
#define SAMP_FIXED_USER_CODEPAGE                        SAM_FIXED_ATTRIBUTES_BASE + 9
#define SAMP_FIXED_USER_BAD_PWD_COUNT                   SAM_FIXED_ATTRIBUTES_BASE + 10
#define SAMP_FIXED_USER_LOGON_COUNT                     SAM_FIXED_ATTRIBUTES_BASE + 11
#define SAMP_FIXED_USER_OBJECTCLASS                     SAM_FIXED_ATTRIBUTES_BASE + 12
#define SAMP_USER_ACCOUNT_TYPE                          SAM_FIXED_ATTRIBUTES_BASE + 13
#define SAMP_FIXED_USER_LOCAL_POLICY_FLAGS              SAM_FIXED_ATTRIBUTES_BASE + 14
#define SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS        SAM_FIXED_ATTRIBUTES_BASE + 15
#define SAMP_USER_SID_HISTORY                           SAM_FIXED_ATTRIBUTES_BASE + 16
#define SAMP_FIXED_USER_LOCKOUT_TIME                    SAM_FIXED_ATTRIBUTES_BASE + 17
#define SAMP_FIXED_USER_IS_CRITICAL                     SAM_FIXED_ATTRIBUTES_BASE + 18
#define SAMP_FIXED_USER_UPN                             SAM_FIXED_ATTRIBUTES_BASE + 19
#define SAMP_USER_CREATOR_SID                           SAM_FIXED_ATTRIBUTES_BASE + 20
#define SAMP_FIXED_USER_SID                             SAM_FIXED_ATTRIBUTES_BASE + 21
#define SAMP_FIXED_USER_SITE_AFFINITY                   SAM_FIXED_ATTRIBUTES_BASE + 22
#define SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP            SAM_FIXED_ATTRIBUTES_BASE + 23
#define SAMP_FIXED_USER_CACHED_MEMBERSHIP               SAM_FIXED_ATTRIBUTES_BASE + 24
#define SAMP_FIXED_USER_CACHED_MEMBERSHIP_TIME_STAMP    SAM_FIXED_ATTRIBUTES_BASE + 25
#define SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED        SAM_FIXED_ATTRIBUTES_BASE + 26
#define SAMP_USER_PASSWORD                              SAM_FIXED_ATTRIBUTES_BASE + 27
#define SAMP_USER_A2D2LIST                              SAM_FIXED_ATTRIBUTES_BASE + 28
#define SAMP_USER_SPN                                   SAM_FIXED_ATTRIBUTES_BASE + 29
#define SAMP_USER_KVNO                                  SAM_FIXED_ATTRIBUTES_BASE + 30
#define SAMP_USER_DNS_HOST_NAME                         SAM_FIXED_ATTRIBUTES_BASE + 31

//++ Unknown Object

#define SAMP_UNKNOWN_OBJECTCLASS                        SAM_FIXED_ATTRIBUTES_BASE + 0
#define SAMP_UNKNOWN_OBJECTRID                          SAM_FIXED_ATTRIBUTES_BASE + 1
#define SAMP_UNKNOWN_OBJECTNAME                         SAM_FIXED_ATTRIBUTES_BASE + 2
#define SAMP_UNKNOWN_OBJECTSID                          SAM_FIXED_ATTRIBUTES_BASE + 3
#define SAMP_UNKNOWN_COMMON_NAME                        SAM_FIXED_ATTRIBUTES_BASE + 4
#define SAMP_UNKNOWN_ACCOUNT_TYPE                       SAM_FIXED_ATTRIBUTES_BASE + 5
#define SAMP_UNKNOWN_GROUP_TYPE                         SAM_FIXED_ATTRIBUTES_BASE + 6


//
// Define the maximum number of attributes that SAM cares about any object. This
// constant is used in SAM to declare attribute blocks in the stack
//

#define MAX_SAM_ATTRS   64


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//  Mapping table structures for SAM to DS object Mappings                   //
//                                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// Various fields declared as pointer to avoid "initializer is
// not a constant" errors in mappings.c.

typedef enum
{
    Integer,
    LargeInteger,
    OctetString,
    UnicodeString,
    Dsname
} ATTRIBUTE_SYNTAX;

// Define 'flavors' of mapped attributes.  Any attribute for which SAM
// needs to perform semantic validation, auditing or netlogon notification
// is declared as SamWriteRequired.  Any attribute which only SAM itself
// can write (eg: RID) is declared as SamReadOnly.  Attributes which SAM
// maps, but can be written without notifying SAM are declared as
// NonSamWriteAllowed (though we know of none like this at present - 8/1/96).

typedef enum
{
    SamWriteRequired,       // SAM checks semantics, audits or notifies
    NonSamWriteAllowed,     // SAM maps but doesn't care
    SamReadOnly             // SAM owns and no one can write
} SAMP_WRITE_RULES;


// SAM doesn't have a counterpart to all core (DS - LDAP) modification
// choice, define the choices SAM can understand and execute. 

typedef enum
{
    SamAllowAll,                // Don't check this attr operation
    SamAllowDeleteOnly,         // Value or attribute can only be removed
    SamAllowReplaceAndRemove,   // Attribute can be replaced and removed
    SamAllowReplaceOnly         // Replace attribute only
} SAMP_ALLOWED_MOD_TYPE;

typedef struct {
    BOOL                    fSamWriteRequired;
    BOOL                    fIgnore;
    USHORT                  choice;             // ATT_CHOICE_*
    ATTR                    attr;
    ULONG                   iAttr;              // index into class' attr map
    ATTCACHE                *pAC;
} SAMP_CALL_MAPPING;
         

//
// There are different scopes that are interesting for triggering an audit and
// all of the flags below fall into one of these categories.
//
// 1. An audited attribute was changed (i.e. SamAccountName).
//
//      Each SAM attribute includes an audit type mask in it's mapping table 
//      entry.  The mask indicates which types of audits should be generated
//      when that attribute is modified in some way. 
//
// 2. An audited operation has occured (i.e. Password change).
//      
//      This provides a mechanism for dedicated audits to be generated from
//      the audit notification logic.  SampAuditDetermineRequiredAudits can
//      be extended to detect the need for an audit and commicate that to
//      SampAuditAddNotifications.           
//
// 3. An object level operation occured (i.e. Object deletion).
//
//      This provides a way to generate audits for object level operations.      
//
// The following audit flags are collected by SampAuditDetermineRequiredAudits.
// The flags are used when the notifications are being generated to ensure 
// the appropriate data is collected and all the necessary audit notifications 
// are queued.
//
// See samaudit.c file header for more on the SAM auditing model.
//

//
// The attribute has no audits associated with it.
//
#define SAMP_AUDIT_TYPE_NONE                               0x00000000

//
// The attribute has SACL or other access change based audits.
//
#define SAMP_AUDIT_TYPE_OBJ_ACCESS                         0x00000001

// 
// The attribute's new value will *not* be included in a general change audit.
//
#define SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_NO_VALUES     0x00000002

//
// The attribute's new value will be included in a general change audit.
//
#define SAMP_AUDIT_TYPE_OBJ_CREATE_OR_CHANGE_WITH_VALUES   0x00000004

//
// The attribute/operation has a dedicated audit ID (i.e. a password change).
//
#define SAMP_AUDIT_TYPE_DEDICATED_AUDIT                    0x00000008    

//
// An object deletion audit is required.
//
#define SAMP_AUDIT_TYPE_OBJ_DELETED                        0x00000010

//
// A pre-created audit notification.
//
#define SAMP_AUDIT_TYPE_PRE_CREATED                        0x00000020
//
// Object access and dedicated audit flags are not currently used but are
// included for documentation of the auditing behavior and future extension.
//
                  
typedef struct
{
    ULONG                           SamAttributeType;
    ULONG                           DsAttributeId;
    ATTRIBUTE_SYNTAX                AttributeSyntax;
    SAMP_WRITE_RULES                writeRule;
    SAMP_ALLOWED_MOD_TYPE           SampAllowedModType; 
    ACCESS_MASK                     domainModifyRightsRequired;
    ACCESS_MASK                     objectModifyRightsRequired;
    ULONG                           AuditTypeMask;
}   SAMP_ATTRIBUTE_MAPPING;

#define SAM_CREATE_ONLY         TRUE    // SAMP_CLASS_MAPPING.fSamCreateOnly
#define NON_SAM_CREATE_ALLOWED  FALSE   // SAMP_CLASS_MAPPING.fSamCreateOnly

typedef struct
{
    ULONG                       DsClassId;
    SAMP_OBJECT_TYPE            SamObjectType;
    BOOL                        fSamCreateOnly;
    ULONG                       *pcSamAttributeMap;
    SAMP_ATTRIBUTE_MAPPING      *rSamAttributeMap;
    ACCESS_MASK                 domainAddRightsRequired;
    ACCESS_MASK                 domainRemoveRightsRequired;
    ACCESS_MASK                 objectAddRightsRequired;
    ACCESS_MASK                 objectRemoveRightsRequired;
}   SAMP_CLASS_MAPPING;

typedef enum
{
    LoopbackAdd,
    LoopbackModify,
    LoopbackRemove
} SAMP_LOOPBACK_TYPE;

typedef struct
{
    SAMP_LOOPBACK_TYPE  type;               // original Dir* operation type
    DSNAME              *pObject;           // object being operated on
    ULONG               cCallMap;           // elements in rCallMap
    SAMP_CALL_MAPPING   *rCallMap;          // original arguments
    BOOL                fPermissiveModify;  // fPermissiveModify in original call
    ULONG               MostSpecificClass;  // Most specific object class of the loop
                                            // back object
} SAMP_LOOPBACK_ARG;

/////////////////////////////////////////////////////////////////////////
//                                                                     //
//  Group Type Definitions                                             //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


typedef enum _NT4_GROUP_TYPE
{
    NT4LocalGroup=1,
    NT4GlobalGroup
} NT4_GROUP_TYPE;

typedef enum _NT5_GROUP_TYPE
{
    NT5ResourceGroup=1,
    NT5AccountGroup,
    NT5UniversalGroup,
    NT5AppBasicGroup,
    NT5AppQueryGroup
} NT5_GROUP_TYPE;




///////////////////////////////////////////////////////////////////////
//                                                                   //
//                                                                   //
//  SAM_ACCOUNT_TYPE Definitions. The SAM account type property      //
//  is used to keep information about every account type object,     //
//                                                                   //
//   There is a value defined for every type of account which        //
//   May wish to list using the enumeration or Display Information   //
//   API. In addition since Machines, Normal User Accounts and Trust //
//   accounts can also be enumerated as user objects the values for  //
//   these must be a contiguous range.                               //
//                                                                   //
///////////////////////////////////////////////////////////////////////

#define SAM_DOMAIN_OBJECT               0x0
#define SAM_GROUP_OBJECT                0x10000000
#define SAM_NON_SECURITY_GROUP_OBJECT   0x10000001
#define SAM_ALIAS_OBJECT                0x20000000
#define SAM_NON_SECURITY_ALIAS_OBJECT   0x20000001
#define SAM_USER_OBJECT                 0x30000000
#define SAM_NORMAL_USER_ACCOUNT         0x30000000
#define SAM_MACHINE_ACCOUNT             0x30000001
#define SAM_TRUST_ACCOUNT               0x30000002
#define SAM_APP_BASIC_GROUP             0x40000000
#define SAM_APP_QUERY_GROUP             0x40000001
#define SAM_ACCOUNT_TYPE_MAX            0x7fffffff


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//   Structure used to communicate a control request to the DS.              //
//   SampDsControl exports a generic in process interface for SAM to         //
//   request DS operations.  The operation is set within the appropriate     //
//   input argument.  The output arguement is allocated and returned upon    //
//   success and is depedent on the type of operation.                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

typedef enum _SAMP_DS_CTRL_OP_TYPE {
    
    SampDsCtrlOpTypeFillGuidAndSid = 0,
    SampDsCtrlOpTypeClearPwdForSupplementalCreds,
    SampDsCtrlOpTypeUpdateAuditNotification
        
} SAMP_DS_CTRL_OP_TYPE;


//
// SampDsCtrlOpTypeFillGuidAndSid
//
// This operation improves a DSNAME by looking up the Guid and Sid
// The returned output argument is a pointer to the DSNAME upon success,
// otherwise NULL.
//
typedef struct _SAMP_FILL_GUID_AND_SID {
    
    DSNAME *DSName;   
    
} SAMP_FILL_GUID_AND_SID, *PSAMP_FILL_GUID_AND_SID; 

//
//  SampDsCtrlOpTypeClearPwdForSupplementalCreds
//
// This operation will update the SupplementalCreds
typedef struct _SAMP_SUPPLEMENTAL_CREDS {

    PDSNAME pUserName;
    PVOID   UpdateInfo;

} SAMP_SUPPLEMENTAL_CREDS, *PSAMP_SUPPLEMENTAL_CREDS;
  
//
// This type defines the nature of the update to an audit notification.
//
typedef enum _SAMP_AUDIT_NOTIFICATION_UPDATE_TYPE {
    
    SampAuditUpdateTypePrivileges = 0,
    SampAuditUpdateTypeUserAccountControl
    
} SAMP_AUDIT_NOTIFICATION_UPDATE_TYPE;

//
// SampDsCtrlOpTypeUpdateAuditNotification
//
// This operation adds information to an existing audit notification.  This
// is necessary when the information is not available at the time the 
// notification would normally be created.  If a notification doesn't
// already exist, one is created and updated.
//
typedef struct _SAMP_UPDATE_AUDIT_NOTIFICATION {
    
    SAMP_AUDIT_NOTIFICATION_UPDATE_TYPE UpdateType; 
    PSID Sid;  
    
    union {
        
        DWORD IntegerData;
        PPRIVILEGE_SET Privileges;
        
    } UpdateData;
    
} SAMP_UPDATE_AUDIT_NOTIFICATION, *PSAMP_UPDATE_AUDIT_NOTIFICATION; 

//
// This is the request block comprised of an operation type and a type
// specific input structure.
//
typedef struct _SAMP_DS_CTRL_OP {

    SAMP_DS_CTRL_OP_TYPE OpType;

    union {

        SAMP_FILL_GUID_AND_SID  FillGuidAndSid;
        SAMP_SUPPLEMENTAL_CREDS UpdateSupCreds;
        SAMP_UPDATE_AUDIT_NOTIFICATION UpdateAuditNotification;

    } OpBody;
    
} SAMP_DS_CTRL_OP, *PSAMP_DS_CTRL_OP;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Export the Mapping Functions and Data Structures                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

extern BOOL                 gfDoSamChecks;
extern SAMP_CLASS_MAPPING   ClassMappingTable[];
extern ULONG                cClassMappingTable;

extern
ULONG
SampGetSamAttrIdByName(
    SAMP_OBJECT_TYPE ObjectType,
    UNICODE_STRING AttributeIdentifier);
    
extern
ULONG
SampGetDsAttrIdByName(
    UNICODE_STRING AttributeIdentifier);
    
extern
ULONG
SampDsAttrFromSamAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG               SamAttr);

extern
ULONG
SampSamAttrFromDsAttr(
    SAMP_OBJECT_TYPE    ObjectType,
    ULONG DsAttr);

extern
ULONG
SampDsClassFromSamObjectType(
    ULONG SamObjectType);

extern
ULONG
SampSamObjectTypeFromDsClass(
    ULONG DsClass);

typedef enum
{
    TransactionRead,
    TransactionWrite,
    TransactionAbort,
    TransactionCommit,
    TransactionCommitAndKeepThreadState,
    TransactionAbortAndKeepThreadState
} SAMP_DS_TRANSACTION_CONTROL;

extern
NTSTATUS
SampMaybeBeginDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL ReadOrWrite);

extern
NTSTATUS
SampMaybeEndDsTransaction(
    SAMP_DS_TRANSACTION_CONTROL CommitOrAbort);

extern
BOOL
SampExistsDsTransaction();

extern
BOOL
SampExistsDsLoopback(
    DSNAME  **ppLoopbackName);

extern
BOOL
SampSamClassReferenced(
    CLASSCACHE  *pClassCache,
    ULONG       *piClass);

extern
BOOLEAN
SampIsSecureLdapConnection(
    VOID
    );


extern
BOOL
SampSamAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    );

extern
BOOL
SampSamReplicatedAttributeModified(
    ULONG       iClass,
    MODIFYARG   *pModifyArg
    );

extern
ULONG
SampAddLoopbackRequired(
    ULONG       iClass,
    ADDARG      *pAddArg,
    BOOL        *pfLoopbackRequired,
    BOOL        *pfUserPasswordSupport);

extern
ULONG
SampModifyLoopbackRequired(
    ULONG       iClass,
    MODIFYARG   *pModifyArg,
    BOOL        *pfLoopbackRequired,
    BOOL        *pfUserPasswordSupport);

extern
VOID
SampBuildAddCallMap(
    ADDARG              *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired,
    BOOL                fUserPasswordSupport);

extern
VOID
SampBuildModifyCallMap(
    MODIFYARG           *pArg,
    ULONG               iClass,
    ULONG               *pcCallMap,
    SAMP_CALL_MAPPING   **prCallMap,
    ACCESS_MASK         *pDomainModifyRightsRequired,
    ACCESS_MASK         *pObjectModifyRightsRequired,
    BOOL                fUserPasswordSupport);

extern
ULONG
SampAddLoopbackCheck(
    ADDARG      *pAddArg,
    BOOL        *pfContinue);

extern
ULONG
SampModifyLoopbackCheck(
    MODIFYARG   *pModifyArg,
    BOOL        *pfContinue,
    BOOL        fIsUndelete);

extern
ULONG
SampRemoveLoopbackCheck(
    REMOVEARG   *pRemoveArg,
    BOOL        *pfContinue);

extern
NTSTATUS
SampGetMemberships(
    IN  PDSNAME     *rgObjNames,
    IN  ULONG       cObjNames,
    IN  OPTIONAL    DSNAME  *pLimitingDomain,
    IN  REVERSE_MEMBERSHIP_OPERATION_TYPE   OperationType,
    OUT ULONG       *pcDsNames,
    OUT PDSNAME     **prpDsNames,
    OUT PULONG      *Attributes OPTIONAL,
    OUT PULONG      pcSidHistory OPTIONAL,
    OUT PSID        **rgSidHistory OPTIONAL
    );

NTSTATUS
SampGetGroupsForToken(
    IN  DSNAME * pObjName,
    IN  ULONG    Flags,
    OUT ULONG   *pcSids,
    OUT PSID    **prpSids
   );

NTSTATUS
SampDsControl(
    IN PSAMP_DS_CTRL_OP RequestedOp,
    OUT PVOID *Result
    );

extern
VOID
SampSplitNT4SID(
    IN NT4SID       *pAccountSid,
    IN OUT NT4SID   *pDomainSid,
    OUT ULONG       *pRid);

extern
DIRERR * APIENTRY
SampGetErrorInfo(
    VOID
    );

extern
VOID
SampMapSamLoopbackError(
    NTSTATUS status);

extern
ULONG
SampDeriveMostBasicDsClass(
    ULONG   DerivedClass);

extern
BOOL
SampIsWriteLockHeldByDs();

extern
NTSTATUS
SampSetIndexRanges(
    ULONG   IndexTypeToUse,
    ULONG   LowLimitLength1,
    PVOID   LowLimit1,
    ULONG   LowLimitLength2,
    PVOID   LowLimit2,
    ULONG   HighLimitLength1,
    PVOID   HighLimit1,
    ULONG   HighLimitLength2,
    PVOID   HighLimit2,
    BOOL    RootOfSearchIsNcHead
    );

extern
NTSTATUS
SampGetDisplayEnumerationIndex (
      IN    DSNAME      *DomainName,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG      Index,
      OUT   PRESTART    *RestartToReturn
      );


extern
NTSTATUS
SampGetQDIRestart(
    IN PDSNAME  DomainName,
    IN DOMAIN_DISPLAY_INFORMATION DisplayInformation, 
    IN ULONG    LastObjectDNT,
    OUT PRESTART *ppRestart
    );




extern
ULONG
SampQueueNotifications(
    DSNAME      * Object,
    ULONG       iClass,
    ULONG       LsaClass,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    BOOL      MixedModeChange,
    BOOL      RoleTransfer,
    DOMAIN_SERVER_ROLE NewRole,
    ULONG         cModAtts,
    ATTRTYP      *pModAtts
    );

ULONG
SampAddNetlogonAndLsaNotification(
    DSNAME      * Object,
    ULONG         iClass,
    ULONG         LsaClass,
    SECURITY_DB_DELTA_TYPE  DeltaType,
    BOOL          MixedModeChange,
    BOOL          RoleTransfer,
    DOMAIN_SERVER_ROLE NewRole,
    BOOL          UserAccountControlChanged
    );

extern
VOID
SampProcessReplicatedInChanges(
    SAMP_NOTIFICATION_INFORMATION * NotificationList
    );


extern
VOID
SampProcessAuditNotifications(
    SAMP_AUDIT_NOTIFICATION *NotificationList
    );


extern
VOID
SampGetLoopbackObjectClassId(
    PULONG  ClassId
    );

extern
NTSTATUS
SampGetAccountCounts(
        DSNAME * DomainObjectName,
        BOOLEAN  GetApproximateCount, 
        int    * UserCount,
        int    * GroupCount,
        int    * AliasCount
        );

extern
BOOLEAN
SampSamUniqueAttributeAdded(
        ADDARG * pAddarg
        );

extern
BOOLEAN
SampSamUniqueAttributeModified(
        MODIFYARG * pModifyarg
        );


extern
ULONG
SampVerifySids(
    ULONG           cSid,
    PSID            *rpSid,
    DSNAME         ***prpDSName
    );

extern
NTSTATUS
SampGCLookupSids(
    IN  ULONG         cSid,
    IN  PSID         *rpSid,
    OUT PDS_NAME_RESULTW *Results
    );

extern
NTSTATUS
SampGCLookupNames(
    IN  ULONG           cNames,
    IN  UNICODE_STRING *rNames,
    OUT ENTINF         **rEntInf
    );

extern
VOID
SampGetEnterpriseSidList(
   IN   PULONG pcSids,
   IN OPTIONAL PSID * rgSids
   );

extern
VOID
SampSignalStart(
        VOID
        );

extern
BOOL
SampAmIGC();

extern
VOID
SampSetSam(IN BOOLEAN fSAM);

NTSTATUS
InitializeLsaNotificationCallback(
    VOID
    );

NTSTATUS
UnInitializeLsaNotificationCallback(
    VOID
    );


ULONG
SampDetermineObjectClass(
    THSTATE     *pTHS,
    CLASSCACHE **ppClassCache);

BOOL
SampIsClassIdLsaClassId(
    THSTATE *pTHS,
    IN ULONG Class,
    IN ULONG cModAtt,
    IN ATTRTYP *pModAtt,
    OUT PULONG LsaClass
    );

BOOL
SampIsClassIdAllowedByLsa(
    THSTATE *pTHS,
    IN ULONG Class
    );

NTSTATUS
SampGetServerRoleFromFSMO(
   DOMAIN_SERVER_ROLE *ServerRole
   );


DWORD
SampCheckForDomainMods(
   IN   THSTATE    *pTHS,
   IN   DSNAME     *pObject,
   IN   ULONG      cModAtts,
   IN   ATTRTYP    *pModAtts,
   OUT  BOOL       *fIsMixedModeChange,
   OUT  BOOL       *fRoleChange,
   OUT  DOMAIN_SERVER_ROLE *NewRole
   );

NTSTATUS
SampComputeGroupType(
    ULONG  ObjectClass,
    ULONG  GroupType,
    NT4_GROUP_TYPE *pNT4GroupType,
    NT5_GROUP_TYPE *pNT5GroupType,
    BOOLEAN        *pSecurityEnabled
   );

BOOL
SampIsMixedModeChange(
    MODIFYARG * pModifyArg
    );


NTSTATUS
SampCommitBufferedWrites(
    IN SAMPR_HANDLE SamHandle
    );

VOID
SampInvalidateDomainCache();

//
// Functions to support external entities of data changes
// in the SAM database.  For example, notifying packages and the PDC
// when passwords change.
//
BOOLEAN
SampAddLoopbackTask(
    IN PVOID NotifyInfo
    );

VOID
SampProcessLoopbackTasks(
    VOID
    );


BOOL
LoopbackTaskPreProcessTransactionalData(
        BOOL fCommit
        );
void
LoopbackTaskPostProcessTransactionalData(
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );


BOOLEAN
SampDoesDomainExist(
    IN PDSNAME pDN
    );

VOID
SampNotifyLsaOfXrefChange(
    IN DSNAME * pObject
    );

NTSTATUS
MatchDomainDnByDnsName(
   IN LPWSTR         DnsName,
   OUT PDSNAME       DomainDsName OPTIONAL,
   IN OUT PULONG     DomainDsNameLen
   );

extern
NTSTATUS
SampNetlogonPing(
    IN  ULONG           DomainHandle,
    IN  PUNICODE_STRING AccountName,
    OUT PBOOLEAN        AccountExists,
    OUT PULONG          UserAccountControl
    );

/***************************************
*                                      *
*  Optypes for SamIHandleObjectUpdate  *
*                                      *
***************************************/

typedef enum _SAM_HANDLE_OBJECT_UPDATE_OPTYPE {

    eSamObjectUpdateOpCreateSupCreds = 0

} SAM_HANDLE_OBJECT_UPDATE_OPTYPE, *PSAM_HANDLE_OBJECT_UPDATE_OPTYPE;

NTSTATUS
SamIHandleObjectUpdate(
    IN SAM_HANDLE_OBJECT_UPDATE_OPTYPE  OpType,
    IN PVOID                            UpdateInfo,        
    IN ATTRBLOCK                        *AttrBlockIn,
    OUT ATTRBLOCK                       *AttrBlockOut
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\nlwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nlwrap.h
//
//--------------------------------------------------------------------------

/* 
    This file contains wrappers for various netlogon routines and either
    stubs them out or passes them on to netlogon depending on whether
    we're running as an executable or inside the lsass process.
*/

#include <crypt.h>                      // for samisrv.h
#include <samrpc.h>                     // for samisrv.h
#include <lsarpc.h>                     // for samisrv.h
#include <samisrv.h>                    // for nlrepl.h
#undef _AVOID_REPL_API
#include "nlrepl.h"                     // I_NetLogon* API and flag definitions

extern
NTSTATUS
dsI_NetNotifyNtdsDsaDeletion (
    IN LPWSTR DnsDomainName,
    IN GUID *DomainGuid,
    IN GUID *DsaGuid,
    IN LPWSTR DnsHostName
    );

extern
NTSTATUS
dsI_NetLogonReadChangeLog(
    IN PVOID InContext,
    IN ULONG InContextSize,
    IN ULONG ChangeBufferSize,
    OUT PVOID *ChangeBuffer,
    OUT PULONG BytesRead,
    OUT PVOID *OutContext,
    OUT PULONG OutContextSize
    );

extern
NTSTATUS
dsI_NetLogonNewChangeLog(
    OUT HANDLE *ChangeLogHandle
    );

NTSTATUS
extern
dsI_NetLogonAppendChangeLog(
    IN HANDLE ChangeLogHandle,
    IN PVOID ChangeBuffer,
    IN ULONG ChangeBufferSize
    );

extern
NTSTATUS
dsI_NetLogonCloseChangeLog(
    IN HANDLE ChangeLogHandle,
    IN BOOLEAN Commit
    );

extern
NTSTATUS
dsI_NetLogonLdapLookupEx(
    IN PVOID Filter,
    IN PVOID SockAddr,
    OUT PVOID *Response,
    OUT PULONG ResponseSize
    );

extern
NTSTATUS
dsI_NetLogonSetServiceBits(
    IN DWORD ServiceBitsOfInterest,
    IN DWORD ServiceBits
    );

extern
VOID
dsI_NetLogonFree(
    IN PVOID Buffer
    );

extern
NTSTATUS
dsI_NetNotifyDsChange(
    IN NL_DS_CHANGE_TYPE DsChangeType
    );

extern
NET_API_STATUS
dsDsrGetDcNameEx2(
    IN LPWSTR ComputerName OPTIONAL,
    IN LPWSTR AccountName OPTIONAL,
    IN ULONG AllowableAccountControlBits,
    IN LPWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\mdlocal.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       mdlocal.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

 * Include file for Core DS functions and data structures that are
 * internal to the DSA itself.

Author:

    DS Team

Environment:

Notes:

Revision History:

--*/

#ifndef _MDLOCAL_
#define _MDLOCAL_

#define SERVINFO_RUN_ONCE 1
#define SERVINFO_PERIODIC 0

#define GTC_FLAGS_HAS_SID_HISTORY 1

typedef struct _GROUPTYPECACHERECORD {
    DWORD DNT;
    DWORD NCDNT;
    DWORD GroupType;
    ATTRTYP Class;
    GUID   Guid;
    NT4SID Sid;
    DWORD  SidLen;
    DWORD  flags;
#if DBG == 1
    DWORD Hits;
#endif
} GROUPTYPECACHERECORD;

typedef struct _GROUPTYPECACHEGUIDRECORD {
    GUID guid;
    DWORD DNT;
} GROUPTYPECACHEGUIDRECORD;



VOID
GroupTypeCachePostProcessTransactionalData (
        THSTATE * pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

VOID
GroupTypeCacheAddCacheRequest (
        ULONG ulDNT
        );

BOOL
GetGroupTypeCacheElement (
        GUID  *pGuid,
        ULONG *pulDNT,
        GROUPTYPECACHERECORD *pGroupTypeCacheRecord);

VOID
InvalidateGroupTypeCacheElement(
        ULONG ulDNT
        );

extern BOOL gulDoNicknameResolution;
extern BOOL gbDoListObject;
extern BOOL gbLoadMapi;
extern ULONG gulTombstoneLifetimeSecs;
extern BOOL gbFsmoGiveaway;
extern HANDLE hMailReceiveThread;
extern BOOL gfTaskSchedulerInitialized;
extern BOOL gfDisableBackgroundTasks;
extern BOOL gfIsSynchronized;
extern BOOL gResetAfterInstall;
extern BOOL gbLDAPusefPermissiveModify;
extern ULONG gulLdapBlockAnonymousOps;
extern BOOL gbAllowAnonymousNspi;
extern BOOL gbSpecifyGuidOnAddAllowed;
extern BOOL gfDontStandardizeSDs;
extern BOOL gfRestoring; // only used for a small time of dsa init

int NoDelCriticalObjects(DSNAME *pObj, ULONG DNT);
int LocalRead(THSTATE *pTHS, READARG *pReadArg, READRES *pReadRes);
int LocalRemove(THSTATE *pTHS, REMOVEARG *pRemoveArg);
int LocalAdd(THSTATE *pTHS, ADDARG *pAddArg, BOOL fAddingDeleted);
int LocalModify(THSTATE *pTHS, MODIFYARG *pModifyArg);
int LocalRenameDSA(THSTATE *pTHS, DSNAME *pNewDSA);
int LocalFind(FINDARG *pFindArg, FINDRES *pFindRes);

BOOL
GetWellKnownDNT (
        DBPOS   *pDB,
        GUID *pGuid,
        DWORD *pDNT
        );

BOOL
GetWellKnownDN (
        DBPOS   *pDB,
        GUID    *pGuid,
        DSNAME   **pDN
        );

int
LocalModifyDN(THSTATE *pTHS,
              MODIFYDNARG *pModifyDNArg,
              MODIFYDNRES *pModifyDNRes,
              BOOL fIsUndelete);

int
LocalSearch (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags);

/* Check that an RDN doesn't violate any extra naming requirements.  */
extern DWORD
fVerifyRDN(WCHAR *pRDN, ULONG ulRDN);

// Find the DNT of the NC that pDN is in.  Return it in pncdnt
// Note: sets error in pTHStls.
#define FINDNCDNT_ALLOW_DELETED_PARENT    ( TRUE )
#define FINDNCDNT_DISALLOW_DELETED_PARENT ( FALSE )

#define FINDNCDNT_ALLOW_PHANTOM_PARENT    ( TRUE  )
#define FINDNCDNT_DISALLOW_PHANTOM_PARENT ( FALSE )

ULONG FindNcdntSlowly(
    IN  DSNAME * pdnObject,
    IN  BOOL     fAllowDeletedParent,
    IN  BOOL     fAllowPhantomParent,
    OUT ULONG *  pncdnt
    );

// By definition this one doesn't allow phantom parents
ULONG FindNcdntFromParent(
    IN  RESOBJ * pParent,
    IN  BOOL     fAllowDeletedParent,
    OUT ULONG *  pncdnt
    );


// Do appropriate security and schema checks before allowing new object.
// Used in LocalAdd and in LocalModifyDN
int
CheckParentSecurity (
        RESOBJ *pParent,
        CLASSCACHE *pObjSch,
        BOOL fAddingDeleted,
        PDSNAME pNewObjectDN,
        PSECURITY_DESCRIPTOR *pNTSD,
        ULONG *cbNTSD,
        BOOL* pfSDIsGlobalSDRef);

PDSNAME
mdGetExchangeDNForAnchor (
        THSTATE  *pTHS,
        DBPOS    *pDB
        );

/* This function invokes our garbage collection utility
   which removes all logically deleted objects that have aged
   beyond a certain point.
*/

USHORT
Garb_Collect(
DSTIME    AgeOutDate );

VOID
GarbageCollection(
    ULONG *pNextPeriod );

VOID
Garb_Collect_EntryTTL(
    IN DSTIME       AgeOutDate,
    IN OUT ULONG    *pulSuccessCount,
    IN OUT ULONG    *pulFailureCount,
    IN OUT ULONG    *pulNextSecs );

DWORD
DeleteExpiredEntryTTL(
    OUT ULONG   *pulNextSecs );

extern ULONG gulGCPeriodSecs;
extern LONG DynamicObjectDefaultTTL;
extern LONG DynamicObjectMinTTL;

void
SearchPerformanceLogging (void);

int
ReSetNamingAtts (
        THSTATE *pTHS,
        RESOBJ *pResObj,
        DSNAME *pNewParent,
        ATTR *pNewRDN,
        BOOL fCheckRDNConstraints,
        BOOL fAllowPhantomParent,
        CLASSCACHE *pClassSch
        );

/* This function sets an update error for output */

#define SetUpdError(p, e)  DoSetUpdError(p, e, 0,  DSID(FILENO,__LINE__))
#define SetUpdErrorEx(p, e, d) DoSetUpdError(p, e, d,  DSID(FILENO,__LINE__))

int APIENTRY
DoSetUpdError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* This function sets a name error for output. */

#define SetNamError(p, pDN, e) \
        DoSetNamError(p, pDN, e, 0, DSID(FILENO,__LINE__))
#define SetNamErrorEx(p, pDN, e, d) \
        DoSetNamError(p, pDN, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetNamError (
        USHORT problem,
        DSNAME *pDN,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid
        );

/* This function sets a security error for output */

#define SetSecError(p, e) DoSetSecError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSecErrorEx(p, e, d) DoSetSecError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSecError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);

/* This function sets a service error for output */
#define SetSvcError(p, e) DoSetSvcError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSvcErrorEx(p, e, d) DoSetSvcError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSvcError(
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* This function sets a system error for output */

#define SetSysError(p, e) DoSetSysError(p, e, 0, DSID(FILENO,__LINE__))
#define SetSysErrorEx(p, e, d) DoSetSysError(p, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetSysError (
        USHORT problem,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);

/* This function sets the att error.  Each call will add a new problem
   to the list.  The object name is only set the first time.  pVal can be
   set to NULL if not needed.
*/

#define SetAttError(pDN, aTyp, p, pAttVal, e) \
          DoSetAttError(pDN, aTyp, p, pAttVal, e, 0, DSID(FILENO,__LINE__))
#define SetAttErrorEx(pDN, aTyp, p, pAttVal, e, d) \
          DoSetAttError(pDN, aTyp, p, pAttVal, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetAttError (
        DSNAME *pDN,
        ATTRTYP aTyp,
        USHORT problem,
        ATTRVAL *pAttVal,
        DWORD extendedErr,
        DWORD extendedData,
        DWORD dsid);


/* In many cases processing will continue even with an attibute error.  This
   macro ensures that we were able to generate an attribute error since it
   is possible that we will generate a size error instead if we don't have
   enough space.  We return if an attribute error was not generated.
   Otherwise we continue.
*/

#define SAFE_ATT_ERROR(pDN,aTyp,problem,pVal,extendedErr)         \
   if (SetAttErrorEx((pDN),(aTyp),(problem),(pVal),(extendedErr), 0) \
                                             != attributeError){     \
      DPRINT1(2,"An attribute error was not safely generated"        \
                "...returning<%u>\n", (pTHStls)->errCode);              \
      return (pTHStls)->errCode;                                        \
   }                                                                 \
   else

#define SAFE_ATT_ERROR_EX(pDN,aTyp,problem,pVal,extendedErr,extendedData)  \
   if (SetAttErrorEx((pDN),(aTyp),(problem),(pVal),(extendedErr), \
                                                        (extendedData)) \
                                             != attributeError){     \
      DPRINT1(2,"An attribute error was not safely generated"        \
                "...returning<%u>\n", (pTHStls)->errCode);              \
      return (pTHStls)->errCode;                                        \
   }                                                                 \
   else

/* This function sets a referral error.  Each call will add a new access pnt
   to the list.  The contref info and base object name is only set the
   first time.
*/
#define SetRefError(pDN, aliasRDN, pOpState,                              \
                    RDNsInternal, refType, pDSA, e)                       \
                DoSetRefError(pDN, aliasRDN, pOpState, RDNsInternal,      \
                              refType, pDSA, e, 0, DSID(FILENO,__LINE__))

#define SetRefErrorEx(pDN, aliasRDN, pOpState,                            \
                      RDNsInternal, refType, pDSA, e, d)                  \
                DoSetRefError(pDN, aliasRDN, pOpState, RDNsInternal,      \
                              refType, pDSA, e, d, DSID(FILENO,__LINE__))

int APIENTRY
DoSetRefError(DSNAME *pDN,
              USHORT aliasRDN,
              NAMERESOP *pOpState,
              USHORT RDNsInternal,
              USHORT refType,
              DSA_ADDRESS *pDSA,
              DWORD extendedErr,
              DWORD extendedData,
              DWORD dsid);

// This routine takes exception information and stuffs it into a THSTATE
void
HandleDirExceptions(DWORD dwException,
                    ULONG ulErrorCode,
                    ULONG dsid);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initializes DSA by getting the DSAname and address from lanman and
   loading the knowledge information (REFS and NCs)
   associated with the DSA into memory.
*/

int APIENTRY InitDSAInfo(void);

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Loads the global gpRootDomainSid with the root domain's Sid, which
   is used for  SD conversions during schema cache load and during install.
*/

extern PSID gpRootDomainSid;
void LoadRootDomainSid();

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Initializes DSA by getting the DSAname and address from lanman and
   loading the knowledge information (REFS and NCs)
   associated with the DSA into memory.
*/

int APIENTRY LoadSchemaInfo(THSTATE *pTHS);


/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
/* Rebuild the cache that holds cross and superior knowledge references.

   Basically,  the cross references and seperior reference for this DSA
   reside as sibling objects of the DSA object itself.  The DSA object is
   a child of the DSA Application Process object.  The steps are as follows:

 - We free all existing cross references and the superior reference.

 - We retrieve the DSA AP object and set a filter for the
   cross-reference  object class.  We retrieve each object and move
   it to the cache.

 - We reposition on the DSA AP, set a filter for the superior reference
   (only 1), retrieve it an relocate it to the cache.
*/

int APIENTRY  BuildRefCache(BOOL fNotifyNetLogon);

// Enumerate all cross-refs in the db.
typedef DWORD (*PFN_ENUMERATE_CROSS_REFS) (THSTATE* pTHS, DBPOS* pDB, PVOID pContext);
DWORD EnumerateCrossRefs(THSTATE* pTHS, DBPOS* pDBCat, PFN_ENUMERATE_CROSS_REFS pfnCallback, PVOID pContext);


DSNAME *
SearchExactCrossRef(
    THSTATE *pTHS,
    DSNAME *pNC
    );

void APIENTRY GetInvocationId(void);

void UpdateAnchorWithInvocationID(IN THSTATE *pTHS);

// update flags in gAnchor from user-defined Options DWORD on the
// local NTDS-DSA object
DWORD UpdateGCAnchorFromDsaOptions( BOOL fInStartup );
DWORD UpdateNonGCAnchorFromDsaOptions( BOOL fInStartup );
DWORD UpdateGCAnchorFromDsaOptionsDelayed( BOOL fInStartup );

// Update gAnchor.pwszRootDomainDnsName with the value from DnsName
int UpdateRootDomainDnsName( IN WCHAR *pDnsName );

// Update gAnchor.pmtxDSA using the current gAnchor.pwszRootDomainDnsName and
// gAnchor.pDSADN->Guid.
int UpdateMtxAddress( void );

/*-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------*/
ULONG
GetNextObjByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    OUT     USN *     pusnFound         OPTIONAL
    );

ULONG
GetNextObjOrValByUsn(
    IN OUT  DBPOS *   pDB,
    IN      ULONG     ncdnt,
    IN      USN       usnSeekStart,
    IN      BOOL      fCritical,
    IN      BOOL      fIncludeValues,
    IN      ULONG *   pulTickToTimeOut  OPTIONAL,
    IN OUT  VOID **   ppvCachingContext,
    OUT     USN *     pusnFound         OPTIONAL,
    OUT     BOOL *    pfValueChangeFound OPTIONAL
    );

#define NAME_RES_QUERY_ONLY            0x1
#define NAME_RES_CHILDREN_NEEDED       0x2
#define NAME_RES_PHANTOMS_ALLOWED      0x4
#define NAME_RES_VACANCY_ALLOWED       0x8
#define NAME_RES_IMPROVE_STRING_NAME  0x10
#define NAME_RES_GC_SEMANTICS         0x20

int DoNameRes(THSTATE *pTHS,
              DWORD dwFlags,
              DSNAME *pObj,
              COMMARG *pComArg,
              COMMRES *pComRes,
              RESOBJ **ppResObj);

RESOBJ * CreateResObj(DBPOS *pDB,
                      DSNAME * pDN);

DWORD ResolveReplNotifyDelay(
    BOOL             fFirstNotify,
    DWORD *          pdwDBVal
    );

void APIENTRY NotifyReplicas(
                             ULONG ulNcdnt,
                             BOOL fUrgent
                             );

BOOL
fHasDescendantNC(THSTATE *pTHS,
                 ATTRBLOCK *pObj,
                 COMMARG *pComArg);

//
// Macro to check if the given attribute should be sent out through
// the GC port. If it is not a member of the partial set,
// it is still sent out if it is constructed or if it is a backlink.
//


#define IS_GC_ATTRIBUTE(_pAC) ((_pAC)->bMemberOfPartialSet ||  (_pAC)->bIsConstructed || (FIsBacklink((_pAC)->ulLinkID)) )


//
// GetEntInf flags
//

#define GETENTINF_FLAG_CAN_REORDER      0x00000001  // ok to reorder selection
#define GETENTINF_FLAG_DONT_OPTIMIZE    0x00000002  // not to optimize
#define GETENTINF_NO_SECURITY           0x00000004  // Don't apply a security
                                                    // check
#define GETENTINF_GC_ATTRS_ONLY         0x00000008  // Don't return non GC attrs
#define GETENTINF_IGNORE_DUPS           0x00000010  // Don't do any sorting to
                                                    // remove duplicate attrs

//
// wrapper around the attcache pointer to include an index for use in
// attribute reordering
//

typedef struct _INDEXED_AC {

    DWORD       Index;
    ATTCACHE*   AttCache;
} INDEXED_AC, *PINDEXED_AC;


//
// Used for passing preformatted ATTCACHE arrays between GetEntInf and
// it's callers.
//

typedef struct _CACHED_AC_ {

    DWORD       nAtts; // number of entries in AC
    PDWORD      pOrderIndex;  // pointer to the index array
    DWORD       classId;  // class id of this blob
    ATTCACHE**  AC;    // pointer to the ATTCACHE array

} CACHED_AC, *PCACHED_AC;



typedef struct _CLASSSTATEINFO
{
    DWORD    cOldObjClasses_alloced;
    DWORD    cOldObjClasses;
    ATTRTYP *pOldObjClasses;

    DWORD    cNewObjClasses_alloced;
    DWORD    cNewObjClasses;
    ATTRTYP *pNewObjClasses;

    DWORD    cNewAuxClasses_alloced;
    DWORD    cNewAuxClasses;
    ATTRTYP *pNewAuxClasses;
    CLASSCACHE **pNewAuxClassesCC;

    ATTCACHE *pObjClassAC;
    BOOL     fObjectClassChanged;

    BOOL     fOperationAdd;
} CLASSSTATEINFO;

int ReadClassInfoAttribute (DBPOS *pDB,
                           ATTCACHE *pAC,
                           ATTRTYP **ppClassID,
                           DWORD    *pcClasses_alloced,
                           DWORD    *pcClasses,
                           CLASSCACHE ***ppClassCC);

int SetClassInheritance(THSTATE *pTHS,
                        CLASSCACHE **ppClassSch,
                        CLASSSTATEINFO  *pClassInfo,
                        BOOL   bSetSystemFlags,
                        DSNAME *pObject);

int
VerifyAndAdjustAuxClasses (
        THSTATE *pTHS,
        DSNAME *pObject,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
BreakObjectClassesToAuxClasses (
        THSTATE *pTHS,
        CLASSCACHE **ppClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
BreakObjectClassesToAuxClassesFast (
        THSTATE *pTHS,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO  *pClassInfo);

int
CloseAuxClassList (
    THSTATE *pTHS,
    CLASSCACHE *pClassSch,
    CLASSSTATEINFO  *pClassInfo);

CLASSCACHE *
FindMoreSpecificClass(
        CLASSCACHE *pCC1,
        CLASSCACHE *pCC2
        );


// macros todo the allocation/reallocation of CLASSSTATEINFO data structures
//
#define ClassInfoAllocOrResizeElement(p,startSize,allocedSize,newSize) \
        if (!(p)) {                                                             \
            (allocedSize) = (startSize);                                        \
            (p) = THAllocEx (pTHS, sizeof (ATTRTYP) * (allocedSize) );          \
        }                                                                       \
        else if ( (allocedSize) < (newSize) ) {                                 \
            (allocedSize) = (newSize) + (startSize);                            \
            (p) = THReAllocEx (pTHS, (p), sizeof (ATTRTYP) * (allocedSize) );   \
        }


#define ClassInfoAllocOrResizeElement2(p,pCC,startSize,allocedSize,newSize) \
        if (!(p)) {                                                             \
            (allocedSize) = (startSize);                                        \
            (p) = THAllocEx (pTHS, sizeof (ATTRTYP) * (allocedSize) );          \
            (pCC) = THAllocEx (pTHS, sizeof (CLASSCACHE *) * (allocedSize) );   \
        }                                                                       \
        else if ( (allocedSize) < (newSize) ) {                                 \
            (allocedSize) = (newSize) + (startSize);                            \
            (p) = THReAllocEx (pTHS, (p), sizeof (ATTRTYP) * (allocedSize) );   \
            (pCC) = THReAllocEx (pTHS, (pCC), sizeof (CLASSCACHE *) * (allocedSize) ); \
        }


#define MIN_NUM_OBJECT_CLASSES  16


/* Retrieve object information based on the input selection list*/

// QUOTA_UNDONE: adding a "2" version of
// this function is a huge HACK to be able
// to pass the quota-trustee ldap control
// all the way down to dbGetConstructedAtt()
//
int APIENTRY
GetEntInf2 (
        IN DBPOS *pDB,
        IN ENTINFSEL *pSel,
        IN RANGEINFSEL *pSelRange,
        IN ENTINF *pEnt,
        IN RANGEINF *pRange,
        IN ULONG SecurityDescriptorFlags,
        IN PSECURITY_DESCRIPTOR pSec,
        IN DWORD Flags,
        IN OUT PCACHED_AC CachedAC,
        IN OPTIONAL RESOBJ *pResObj,
        IN OPTIONAL PSID psidQuotaTrustee);

__inline int APIENTRY
GetEntInf (
        IN DBPOS *pDB,
        IN ENTINFSEL *pSel,
        IN RANGEINFSEL *pSelRange,
        IN ENTINF *pEnt,
        IN RANGEINF *pRange,
        IN ULONG SecurityDescriptorFlags,
        IN PSECURITY_DESCRIPTOR pSec,
        IN DWORD Flags,
        IN OUT PCACHED_AC CachedAC,
        IN OPTIONAL RESOBJ *pResObj)
{
    return GetEntInf2(
                pDB,
                pSel,
                pSelRange,
                pEnt,
                pRange,
                SecurityDescriptorFlags,
                pSec,
                Flags,
                CachedAC,
                pResObj,
                NULL);
}

VOID
SvccntlFlagsToGetEntInfFlags(
    IN  SVCCNTL* Svccntl,
    OUT PDWORD Flags
    );

#define SEARCH_UNSECURE_SELECT 1
#define SEARCH_AB_FILTER       2
void
SearchBody (
        THSTATE *pTHS,
        SEARCHARG *pSearchArg,
        SEARCHRES *pSearchRes,
        DWORD flags);

void DBFreeSearhRes (
    THSTATE *pTHS, 
    SEARCHRES *pSearchRes, 
    BOOL fFreeOriginal);

int SetInstanceType(THSTATE *pTHS,
                    DSNAME *pDN,
                    CREATENCINFO * pCreateNC);

int AddCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN);

int DelCatalogInfo(THSTATE *pTHS,
                   DSNAME *pDN,
                   SYNTAX_INTEGER iType);

int GetObjSchemaMod(MODIFYARG* pModifyArg, CLASSCACHE **ppClassSch);

// Find ATTR for ATT_OBJ_CLASS in the given ATTRBLOCK and return a pointer to
// the corresponding class schema structure.  Sets thread-state error on
// failure.  Also, find the GUID and SID if they are there.
int
FindValuesInEntry (
        THSTATE    *pTHS,
        ADDARG     *pAddArg,
        CLASSCACHE **ppCC,
        GUID       *pGuid,
        BOOL       *pFoundGuid,
        NT4SID     *pSid,
        DWORD      *pSidLen,
        CLASSSTATEINFO  **ppClassInfo
        );

int
CheckRenameSecurity (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        PWCHAR szNewName,
        GUID*  pNewParentGUID,
        CLASSCACHE *pCC,
        RESOBJ * pResObj,
        ATTRTYP rdnType,
        BOOL    fMove,
        BOOL    fIsUndelete);

#define SECURITY_PRIVATE_OBJECT 0x1

int
CheckModifySecurity (
        THSTATE *pTHS,
        MODIFYARG *pModifyArg,
        BOOL *pfCheckDNSValues,
        BOOL *pfCheckAdditionalDNSValues,
        BOOL *pfCheckSPNValues,
        BOOL fIsUndelete);

int
CreateSecurityDescriptorForNewObject (
        THSTATE *pTHS,
        CLASSCACHE *pCC,
        ADDARG *pModifyArg,
        PSECURITY_DESCRIPTOR pNTSD,
        ULONG cbNTSD);

void
CheckReadSecurity (
        THSTATE *pTHS,
        ULONG SecurityDescriptorFlags,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        PSID psidQuotaTrustee,
        ULONG * cInAtts,
        ATTCACHE **rgpAC );

int
ModifyAuxclassSecurityDescriptor (
        THSTATE *pTHS,
        DSNAME *pDN,
        COMMARG *pCommArg,
        CLASSCACHE *pClassSch,
        CLASSSTATEINFO *pClassInfo,
        RESOBJ * pResParent);

BOOL
CheckConstraintEntryTTL (
        IN  THSTATE     *pTHS,
        IN  DSNAME      *pObject,
        IN  ATTCACHE    *pACTtl,
        IN  ATTR        *pAttr,
        OUT ATTCACHE    **ppACTtd,
        OUT LONG        *pSecs
        );

unsigned
CheckConstraint (
        ATTCACHE *pAttSchema,
        ATTRVAL *pAttVal
        );

BOOL
GetFilterSecurity (
        THSTATE *pTHS,
        FILTER *pFilter,
        ULONG   SortType,
        ATTRTYP SortAtt,
        BOOL fABFilter,
        POBJECT_TYPE_LIST *ppFilterSecurity,
        BOOL **ppbSortSkip,
        DWORD **ppResults,
        DWORD *pSecSize);

int GetObjSchema(DBPOS *pDB, CLASSCACHE **ppClassSch);
int GetObjRdnType(DBPOS *pDB, CLASSCACHE *pCC, ATTRTYP *pRdnType);
int CallerIsTrusted(THSTATE *pTHS);

int
ValidateObjClass(THSTATE *pTHS,
                 CLASSCACHE *pClassSch,
                 DSNAME *pDN,
                 ULONG cModAtts,
                 ATTRTYP *pModAtts,
                 CLASSSTATEINFO  **pClassInfo,
                 BOOL fIsUndelete);

CLASSSTATEINFO  *ClassStateInfoCreate (THSTATE *pTHS);
void ClassStateInfoFree (THSTATE *pTHS, CLASSSTATEINFO  *pClassInfo);

// This is the number of elements of a modifyProcessUpdateArray, a static 
// array defined in mdmod.c.  Its validity is gaurded by a run time assert.
#define MAX_MODIFY_PROCESS_UPDATE 1

struct _VERIFY_ATTS_INFO {
    DSNAME *    pObj;
    ULONG       NCDNT;   // May be INVALIDDNT if adding root of NC.
    CROSS_REF * pObjCR_DontAccessDirectly;  // use VerifyAttsGetObjCR
    DBPOS *     pDBTmp_DontAccessDirectly;  // use HVERIFYATTS_GET_PDBTMP
    ADDCROSSREFINFO * pCRInfo; // This is used when adding a cross-ref.
    BOOL          fIsUndelete; // is this an undelete operation?

    // the following are used to keep track of attribute changes between calls 
    // to ModSetAttsHelper*Process functions
    DWORD         fGroupTypeChange;
    ULONG         ulGroupTypeOld;
    DWORD         fLockoutTimeUpdated;
    LARGE_INTEGER LockoutTimeNew;
    DWORD         fUpdateScriptChanged;
    LONG          NewForestVersion;
    LONG          NewDomainVersion;
    
    BOOL          fRedirectWellKnownObjects;
    DSNAME*       pObjUsersOld;
    DSNAME*       pObjUsersNew;
    DSNAME*       pObjComputersOld;
    DSNAME*       pObjComputersNew;

    // A static list of the attributes which need to be
    // processed by external callers
    PVOID         UpdateList[MAX_MODIFY_PROCESS_UPDATE];
};

typedef struct _VERIFY_ATTS_INFO * HVERIFY_ATTS;

HVERIFY_ATTS
VerifyAttsBegin(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pObj,
    IN  ULONG       dntOfNCRoot,
    IN  ADDCROSSREFINFO *  pCRInfo
    );

void
VerifyAttsEnd(
    IN      THSTATE *       pTHS,
    IN OUT  HVERIFY_ATTS *  phVerifyAtts
    );

int
ReplaceAtt(
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAttSchema,
        ATTRVALBLOCK *pAttrVal,
        BOOL fCheckAttValConstraint);

int AddAtt(THSTATE *pTHS,
           HVERIFY_ATTS hVerifyAtts,
           ATTCACHE *pAttSchema,
           ATTRVALBLOCK *pAttrVal);

int AddAttType(THSTATE *pTHS,
               DSNAME *pObject,
               ATTCACHE *pAttSchema);

#define AAV_fCHECKCONSTRAINTS    1
#define AAV_fENFORCESINGLEVALUE  2
#define AAV_fPERMISSIVE          4
int
AddAttVals (
        THSTATE *pTHS,
        HVERIFY_ATTS hVerifyAtts,
        ATTCACHE *pAttSchema,
        ATTRVALBLOCK *pAttrVal,
        DWORD dwFlags);

int RemAttVals(THSTATE *pTHS,
               HVERIFY_ATTS hVerifyAtts,
               ATTCACHE *pAC,
               ATTRVALBLOCK *pAttrVal,
               BOOL fPermissive);

int InsertObj(THSTATE *pTHS,
              DSNAME *pDN,
              PROPERTY_META_DATA_VECTOR *pMetaDataVecRemote,
              BOOL bModExisting,
              DWORD dwMetaDataFlags);

BOOL
ObjCachingPreProcessTransactionalData (
        BOOL fCommit
        );
VOID
ObjCachingPostProcessTransactionalData (
        THSTATE *pTHS,
        BOOL fCommit,
        BOOL fCommitted
        );

int AddObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  DSNAME *pDN,
                  BOOL fAddingDeleted,
                  BOOL fIgnoreExisting
                  );

int DelObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  RESOBJ *pRes,
                  BOOL fCleanup);

int ModObjCaching(THSTATE *pTHS,
                  CLASSCACHE *pClassSch,
                  ULONG cModAtts,
                  ATTRTYP *pModAtts,
                  RESOBJ *pRes);
ULONG
AddCRToMem(THSTATE *pTHS,
           NAMING_CONTEXT *pCR,
           DSNAME *pObj,
           DWORD flags,
           WCHAR* NetbiosName,
           ULONG  NetbiosNameLen,
           WCHAR* DnsName,
           ULONG  DnsNameLen
           );
VOID
AddCRLToMem (
        struct CROSS_REF_LIST *pCRL
        );

DWORD
MakeStorableCRL(THSTATE *pTHS,
                DBPOS *pDB,
                DSNAME *pObj,
                struct CROSS_REF_LIST **ppCRL,
                struct CROSS_REF_LIST* pCheckForDupInList);

BOOL
DelCRFromMem(THSTATE *pTHS,
             NAMING_CONTEXT *pCR);

ULONG
ValidateCRDeletion(THSTATE *pTHS,
                   DSNAME  *pDN);

VOID
ModCrossRefCaching(
    THSTATE *pTHS,
    CROSS_REF *pCR
    );

int AddClassToSchema(void);

int DelClassFromSchema(void);

int ModClassInSchema(void);

int AddAttToSchema(void);

int DelAttFromSchema(void);

int ModAttInSchema(void);

int ModLocalDsaObj(void);

int APIENTRY RebuildLocalScopeInternally(void);

int GetExistingAtt(DBPOS *pDB, ATTRTYP type,
                          void *pOutBuf, ULONG cbOutBuf);


#define  PHANTOM_CHECK_FOR_FSMO    1
#define  PHANTOM_IS_PHANTOM_MASTER 2

void
PhantomCleanupLocal (
        DWORD * pcSecsUntilNextIteration,
        BOOL  * pIsPhantomMaster
        );

BOOL
IsObjVisibleBySecurity (THSTATE *pTHS, BOOL  fUseCache);


BOOL
IsAccessGrantedParent (
        ACCESS_MASK ulAccessMask,
        CLASSCACHE *pCC,
        BOOL fSetError
        );

BOOL
IsAccessGrantedAddGuid (
        DSNAME  *pDN,
        COMMARG *pCommArg
        );

DWORD
FindFirstObjVisibleBySecurity(
    THSTATE       *pTHS,
    ULONG          ulDNT,
    DSNAME       **ppParent
    );

DWORD
CheckObjDisclosure(
    THSTATE       *pTHS,
    RESOBJ        *pResObj,
    BOOL          fCheckForSecErr
    );

extern const GUID RIGHT_DS_CHANGE_INFRASTRUCTURE_MASTER;
extern const GUID RIGHT_DS_CHANGE_SCHEMA_MASTER;
extern const GUID RIGHT_DS_CHANGE_RID_MASTER;
extern const GUID RIGHT_DS_CHANGE_DOMAIN_MASTER;
extern const GUID RIGHT_DS_DO_GARBAGE_COLLECTION;
extern const GUID RIGHT_DS_RECALCULATE_HIERARCHY;
extern const GUID RIGHT_DS_RECALCULATE_SECURITY_INHERITANCE;
extern const GUID RIGHT_DS_CHECK_STALE_PHANTOMS;
extern const GUID RIGHT_DS_UPDATE_SCHEMA_CACHE;
extern const GUID RIGHT_DS_ALLOCATE_RIDS;
extern const GUID RIGHT_DS_OPEN_ADDRESS_BOOK;
extern const GUID RIGHT_DS_CHANGE_PDC;
extern const GUID RIGHT_DS_ADD_GUID;
extern const GUID RIGHT_DS_REPL_GET_CHANGES;
extern const GUID RIGHT_DS_REPL_GET_CHANGES_ALL;
extern const GUID RIGHT_DS_REPL_SYNC;
extern const GUID RIGHT_DS_REPL_MANAGE_TOPOLOGY;
extern const GUID RIGHT_DS_REPL_MONITOR_TOPOLOGY;
extern const GUID RIGHT_DS_REPL_MANAGE_REPLICAS;
extern const GUID RIGHT_DS_REFRESH_GROUP_CACHE;
extern const GUID RIGHT_DS_MIGRATE_SID_HISTORY;
extern const GUID RIGHT_DS_REANIMATE_TOMBSTONES;
extern const GUID RIGHT_DS_DUMP_DATABASE;
extern const GUID RIGHT_DS_EXECUTE_SCRIPT;
extern const GUID RIGHT_DS_QUERY_SELF_QUOTA;

extern const GUID PROPSET_GUID_DEFAULT;

extern const GUID GUID_WHISTLER_CREATED_ENTERPRISE;

BOOL
IsControlAccessGrantedEx (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        CLASSCACHE *pCC,
        GUID pControlGuid,
        DWORD dwFlags,
        BOOL fSetError
        );

#define IsControlAccessGranted(pNTSD, pDN, pCC, pControlGuid, fSetError) \
            IsControlAccessGrantedEx(pNTSD, pDN, pCC, pControlGuid, 0, fSetError)

BOOL
IsAccessGrantedAttribute (
        THSTATE *pTHS,
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME pDN,
        ULONG  cInAtts,
        CLASSCACHE *pCC,
        ATTCACHE **rgpAC,
        ACCESS_MASK ulAccessMask,
        BOOL fSetError
        );

BOOL
IsAccessGranted (
        PSECURITY_DESCRIPTOR pNTSD,
        PDSNAME     pDN,
        CLASSCACHE *pObjectCC,
        CLASSCACHE *pCC,
        ACCESS_MASK ulAccessMask,
        PWCHAR      szAdditionalInfo,
        GUID*       pAdditionalGUID,
        BOOL        fSetError
        );


BOOL
IsAccessGrantedSimpleEx (
        ACCESS_MASK ulAccessMask,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID,
        const ULONG cInAtts,
        ATTCACHE ** rgpAC,
        DWORD dwFlags,
        BOOL fSetError
        );

#define IsAccessGrantedSimple(ulAccessMask, fSetError) IsAccessGrantedSimpleEx(ulAccessMask, NULL, NULL, 0, NULL, 0, fSetError)

ATTRTYP KeyToAttrType(THSTATE *pTHS,
                      WCHAR * pKey,
                      unsigned cc);

typedef struct _OID {
    int cVal;
    unsigned *Val;
} OID;

unsigned EncodeOID(OID *pOID, unsigned char * pEncoded, unsigned ccEncoded);
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID);

OidStringToStruct(
                  THSTATE *pTHS,
                  WCHAR * pString,
                  unsigned len,
                  OID * pOID);

unsigned
OidStructToString(
                  OID *pOID,
                  WCHAR *pOut,
                  ULONG ccOut);
unsigned
AttrTypeToIntIdString (
        ATTRTYP attrtyp,
        WCHAR   *pOut,
        ULONG   ccOut
        );
int
AttrTypToString (
        THSTATE *pTHS,
        ATTRTYP attrTyp,
        WCHAR *pOutBuf,
        ULONG cLen
        );


int
StringToAttrTyp (
        THSTATE *pTHS,
        WCHAR   *pInString,
        ULONG   len,
        ATTRTYP *pAttrTyp
        );

extern int APIENTRY
AddNCToDSA(THSTATE *pTHS,
           ATTRTYP listType,
           DSNAME *pDN,
           SYNTAX_INTEGER iType);

extern DWORD
AddInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDBCat,
    IN  DSNAME *            pDN,
    IN  SYNTAX_INTEGER      iType
    );

extern DWORD
RemoveInstantiatedNC(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB,
    IN  DSNAME *            pDN
    );

extern DWORD
RemoveAllInstantiatedNCs(
    IN  THSTATE *           pTHS,
    IN  DBPOS *             pDB
    );


extern int APIENTRY
DelNCFromDSA(THSTATE *pTHS,
             ATTRTYP listType,
             DSNAME *pDN);

extern int APIENTRY
AddSubToNC(THSTATE *pTHS,
           DSNAME *pDN,
           DWORD dsid);

extern int APIENTRY
DelSubFromNC(THSTATE *pTHS,
             DSNAME *pDN,
             DWORD dsid);

#define PARENTMASTER  0x0001     /*The parent object must be a master*/
#define PARENTFULLREP 0x0002     /*The parent object must be a replica*/

extern int APIENTRY
      ParentExists(ULONG requiredParent, DSNAME *pDN);

extern int APIENTRY NoChildrenExist(THSTATE * pTHS, RESOBJ *pRes);

int
ModNCDNT(
    THSTATE *pTHS,
    DSNAME *pNC,
    SYNTAX_INTEGER beforeInstance,
    SYNTAX_INTEGER afterInstance
    );

extern void
RebuildCatalog(void * pv,
              void ** ppvNext,
              DWORD * pcSecsUntilNextIteration );

extern  DSNAME *FindNCParentDSName(DSNAME *pDN, BOOL masterOnly,
                                   BOOL parentOnly);

DSNAME *
SearchNCParentDSName(
    DSNAME *pDN,
    BOOL masterOnly,
    BOOL parentOnly
    );

extern int
MoveSUBInfoToParentNC(THSTATE *pTHS,
                      DSNAME *pDN);

extern int
MoveParentSUBInfoToNC(THSTATE *pTHS,
                      DSNAME *pDN);


/* from mdname.c */

CROSS_REF *
FindBestCrossRef(const DSNAME *pObj,
                 const COMMARG *pComArg);

CROSS_REF *
FindExactCrossRef(const DSNAME *pObj,
                  const COMMARG *pComArg);

CROSS_REF *
FindExactCrossRefForAltNcName(
                  ATTRTYP attrTyp,
                  ULONG crFlags,
                  const WCHAR * pwszVal);

BOOL
IsCrossRefProtectedFromDeletion(
    IN DSNAME * pDN
    );

int
GenSubRef(NAMING_CONTEXT * pSubNC,
          DSNAME *pObj,
          COMMARG *pComArg);

int
GenCrossRef(CROSS_REF *pCR,
            DSNAME *pObj);

int
GenSupRef(THSTATE *pTHS,
          DSNAME *pObj,
          ATTRBLOCK *pObjB,
          const COMMARG *pComArg,
          DSA_ADDRESS *pDA);

CROSS_REF *
FindCrossRefInList(const ATTRBLOCK *pObj,
                   struct CROSS_REF_LIST* pCRL);

#define FindCrossRef(pObj, pComArg) FindCrossRefInList(pObj, gAnchor.pCRL)

CROSS_REF *
FindCrossRefByGuid(GUID *pGuid);

void
SpliceDN(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pOriginalDN,
    IN  DSNAME *    pNewParentDN,   OPTIONAL
    IN  WCHAR *     pwchNewRDN,     OPTIONAL
    IN  DWORD       cchNewRDN,      OPTIONAL
    IN  ATTRTYP     NewRDNType,     OPTIONAL
    OUT DSNAME **   ppNewDN
    );

unsigned
BlockNamePrefix(THSTATE *pTHS,
                const ATTRBLOCK *pPrefix,
                const ATTRBLOCK *pDN);

unsigned
GetTopNameComponent(const WCHAR *pName,
                    unsigned ccName,
                    const WCHAR **ppKey,
                    unsigned *pccKey,
                    const WCHAR **ppVal,
                    unsigned *pccVal);

int DelAutoSubRef(DSNAME *pCR);

int
AddPlaceholderNC(
    IN OUT  DBPOS *         pDBTmp,
    IN OUT  DSNAME *        pNCName,
    IN      SYNTAX_INTEGER  it
    );

// Given a DSName, fill in the GUID and SID from the object you get by looking
// up the DSNAME.
DWORD
FillGuidAndSid (
        IN OUT DSNAME *pDN
        );

#define IsDNSepChar(x) (((x) == L',') || ((x) == L';'))

// Returns TRUE if this is the root
BOOL IsRoot(const DSNAME *pName);

// Convert from a DSNAME to a name in ATTRBLOCK format
unsigned DSNameToBlockName(THSTATE *pTHS,
                           const DSNAME *pDSName,
                           ATTRBLOCK ** ppBlockName,
                           BOOL fLowerCase
                           );
#define DN2BN_PRESERVE_CASE ( FALSE )
#define DN2BN_LOWER_CASE    ( TRUE )

// Free a block name returned by DSNameToBlockName
void FreeBlockName (ATTRBLOCK * pBlockName);

// convert a BLOCKNAME to DSName
DWORD BlockNameToDSName (THSTATE *pTHS, ATTRBLOCK * pBlockName, DSNAME **ppName);

//
// Converts a X500 Name to Ldap Convention
//
VOID
ConvertX500ToLdapDisplayName
(
    WCHAR* szX500Name,
    DWORD  cchX500Name,
    WCHAR* szLdapName,
    DWORD* pcchLdapName
);

// Mangle an RDN to avoid name conflicts.  NOTE: pszRDN must be pre-allocated
// to hold at least MAX_RDN_SIZE WCHARs.
VOID
MangleRDN(
    IN      MANGLE_FOR  eMangleFor,
    IN      GUID *      pGuid,
    IN OUT  WCHAR *     pszRDN,
    IN OUT  DWORD *     pcchRDN
    );

// Check if this rename operation has to exempted from Rename restriction
BOOL
IsExemptedFromRenameRestriction(THSTATE *pTHS, MODIFYDNARG *pModifyDNArg);

// Copy ATTRBLOCK format name into single chunk of permanent memory
ATTRBLOCK * MakeBlockNamePermanent(ATTRBLOCK * pName);

VOID
CheckNCRootNameOwnership(
    IN  THSTATE *   pTHS,
    IN  DSNAME *    pNC
    );


// C++ code in the core DS introduces potential problems with new/delete.
// This is because new'd items are not guaranteed to be cleaned up
// correctly during exception handling. In the typical case, allocations
// occur from the thread heap, but not always.  There being no way to tell
// new/delete which behaviour is desired, we redefine new/delete to generate
// a compiler error.  Astute developers should notice this before checkin
// and take appropriate action.  Implementing an asserting or exception
// raising new/delete is not an option as other C++ DS components which
// link with core.lib might get this version depending on the link order.

#define new     NEW_NOT_SUPPORTED_IN_CORE
#define delete  DELETE_NOT_SUPPORTED_IN_CORE

// This Unicode character is not allowed in a DS name.
#define BAD_NAME_CHAR 0x000A

// A globally available valid DSNAME of the root...
extern DSNAME * gpRootDN;
// ...and the same thing as a BLOCKNAME
extern ATTRBLOCK * gpRootDNB;

//
// The functions below set/check the state of the Dsa based on the value of
// the gInitPhase global variable.

extern BOOLEAN __fastcall DsaIsInstalling();
extern BOOLEAN __fastcall DsaIsRunning();
extern VOID DsaSetIsInstalling();
extern VOID DsaSetIsRunning();

// the following functions deal with SingleUserMode manipulations
extern BOOL __fastcall DsaIsSingleUserMode (void);
extern void DsaSetMultiUserMode();
extern BOOL DsaSetSingleUserMode();

// the function below keep track of if we are installing from media

extern BOOLEAN DsaIsInstallingFromMedia();
extern VOID DsaSetIsInstallingFromMedia();

//
// This function is used to set when the machine fully installed because it
// has done its first full sync
VOID DsaSetIsSynchronized( BOOL f );

//
// This function tests whether the ds is not fully installed
BOOL DsIsBeingBackSynced();

// Given a requested right, a security descriptor, and a SID, check to see what
// attributes in the provided list have the requested right granted
typedef enum {
    csacaAllAccessGranted = 1,
    csacaAllAccessDenied,
    csacaPartialGrant
} CSACA_RESULT;

CSACA_RESULT
CheckSecurityAttCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        CLASSCACHE *pObjectCC,
        CLASSCACHE *pCC,
        ULONG  cInAtts,
        ATTCACHE **rgpAC,
        DWORD flags,
        PWCHAR szAdditionalInfo,
        GUID*  pAdditionalGUID
        );

// Given a requested right, a security descriptor, and a SID, check to see what
// classes in the provided list have the requested right granted
DWORD
CheckSecurityClassCacheArray (
        THSTATE *pTHS,
        DWORD RightRequested,
        PSECURITY_DESCRIPTOR pSecurity,
        PDSNAME pDN,
        ULONG  cInClass,
        CLASSCACHE **rgpCC,
        CLASSCACHE *pCC,
        DWORD dwFlags
        );

// Helper function to extract the DSNAME out of various DN-valued
// attributes.

extern
PDSNAME
DSNameFromAttrVal(ATTCACHE *pAC, ATTRVAL *pAttrVal);

void APIENTRY
AddNCToMem(DWORD dwCatalog, DSNAME *pDN);

void APIENTRY
DelNCFromMem(DWORD dwCatalog, DSNAME *pDN);

DWORD MakeNCEntry(IN DSNAME *pDN, OUT NAMING_CONTEXT_LIST **ppNCL);

VOID FreeNCEntry(NAMING_CONTEXT_LIST *pNCL);

NAMING_CONTEXT_LIST *
FindNCLFromNCDNT(DWORD NCDNT,
                 BOOL fMasterOnly);

NAMING_CONTEXT * FindNamingContext(ATTRBLOCK *pObj,
                                   COMMARG *pComArg);

//
// Converts a text representation of a security descriptor into a real one
//
DWORD
ConvertTextSecurityDescriptor (
    IN  PWSTR                   pwszTextSD,
    OUT PSECURITY_DESCRIPTOR   *ppSD,
    OUT PULONG                  pcSDSize
    );


// Bit flags for CheckPermissionsAnyClient.
#define CHECK_PERMISSIONS_WITHOUT_AUDITING 1
#define CHECK_PERMISSIONS_AUDIT_ONLY       2
#define CHECK_PERMISSIONS_FLAG_MASK        3


//
// Permission checking. Returns 0 if permission checking was successful.
// On success *pAccessStatus is set to true if access is granted and false
// otherwise. On failure a detailed error code is available. This function
// assumes that it is being called within the security context of the
// client, i.e. that some flavor of client impersonation has been called.
//
// Returns:
// 0 if successful. On failure the result of GetLastError() immediately
// following the unsuccessful win32 api call.
//

DWORD
CheckPermissionsAnyClient(
    PSECURITY_DESCRIPTOR pSelfRelativeSD, // Security descriptor to test
    PDSNAME pDN,                          // DN of the object. We only
                                          // care about the GUID and
                                          // the SID
    CLASSCACHE* pCC,                      // className put into additional info audit field
    ACCESS_MASK ulDesiredAccess,          // Desired access mask
    POBJECT_TYPE_LIST pObjTypeList,       // Desired guids to check
    DWORD cObjTypeList,                   // Number of entries in list
    ACCESS_MASK *pGrantedAccess,          // What access was granted
    DWORD *pAccessStatus,                 // 0 = all granted; !0=denied
    DWORD flags,
    OPTIONAL AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzCtx,  // grab context from THSTATE by default
    OPTIONAL PWCHAR szAdditionalInfo,     // additional info string (audit only)
    OPTIONAL GUID*  pAdditionalGUID       // additional guid (audit only)
    );


// ========================================================
// Authz framework routines
// ========================================================

// Initializes global Authz RM
DWORD
InitializeAuthzResourceManager();

// releases global Authz RM
DWORD
ReleaseAuthzResourceManager();

extern AUTHZ_RESOURCE_MANAGER_HANDLE ghAuthzRM; // global AuthZ resource manager handle

// create a new client context
PAUTHZ_CLIENT_CONTEXT NewAuthzClientContext();

//
// Privilege checking. Returns 0 if privilege checking was successful.
// pResult says whether privilege was held. On failure a detailed error code is
// available. This function does not assume that it is being called within the
// security context of the client, i.e. that some flavor of client impersonation
// has been called. It does assume that some impersonation may be done.
//
DWORD
CheckPrivilegeAnyClient(
    IN DWORD privilege,
    OUT BOOL *pResult
    );


// Verify RPC caller is an authenticated user.

DWORD
VerifyRpcClientIsAuthenticatedUser(
    VOID            *Context,
    GUID            *InterfaceUuid);

// Bit flags for MergeSecurityDescriptorAnyClient.  Default behaviour is to do a
// normal merge (not creating a brand new SD) where we have the ability to
// impersonate a client.

#define MERGE_CREATE   1                // We're creating a new Security
                                        // Descriptor from a parent SD and an SD
                                        // specified for the object.  Default is
                                        // to assume we are trying to write a
                                        // new SD on an object that already has
                                        // an SD
#define MERGE_AS_DSA   2                // We are doing this in the context of
                                        // the DSA itself, meaning we can't
                                        // impersonate a client.
#define MERGE_DEFAULT_SD 4              // The SD provided is the default SD from
                                        // the schema.
#define MERGE_OWNER    8                // The SD prvoided lacks the OWNER and/or
                                        // group fields, Add these fields to the
                                        // SD, in most cases this will involve
                                        // impersonating the client.

DWORD
ValidateSPNsAndDNSHostName (
        THSTATE    *pTHS,
        DSNAME     *pDN,
        CLASSCACHE *pCC,
        BOOL        fCheckDNSHostNameValue,
        BOOL        fCheckAdditionalDNSHostNameValue,
        BOOL        fCheckSPNValues,
        BOOL        fNewObject
        );

DWORD
WrappedMakeSpnW(
        THSTATE *pTHS,
        WCHAR   *ServiceClass,
        WCHAR   *ServiceName,
        WCHAR   *InstanceName,
        USHORT  InstancePort,
        WCHAR   *Referrer,
        DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
        WCHAR  **ppszSpn
        );

DWORD
MergeSecurityDescriptorAnyClient(
        IN  THSTATE              *pTHS,
        IN  PSECURITY_DESCRIPTOR pParentSD,
        IN  ULONG                cbParentSD,
        IN  PSECURITY_DESCRIPTOR pCreatorSD,
        IN  ULONG                cbCreatorSD,
        IN  SECURITY_INFORMATION SI,
        IN  DWORD                flags,
        IN  GUID                 **ppGuid,
        IN  ULONG                GuidCount,
        IN  ADDARG               *pAddArg,
        OUT PSECURITY_DESCRIPTOR *ppMergedSD,
        OUT ULONG                *cbMergedSD
        );

DWORD
SidMatchesUserSidInToken (
        IN PSID pSid,
        IN DWORD cbSid,
        OUT BOOL* pfMatches
    );

DWORD
GetPlaceholderNCSD(
    IN  THSTATE *               pTHS,
    OUT PSECURITY_DESCRIPTOR *  ppSD,
    OUT DWORD *                 pcbSD
    );

ULONG ErrorOnShutdown(void);

//
// drive/volume mapping stuff
//

typedef struct DS_DRIVE_MAPPING_ {

    BOOL    fUsed:1;        // used by the DS
    BOOL    fChanged:1;     // letter and mapping changed
    BOOL    fListed:1;      // in reg key

    INT     NewDrive;    // drive index.  -1 if invalid.

} DS_DRIVE_MAPPING, *PDS_DRIVE_MAPPING;

#define DS_MAX_DRIVES   26      // A to Z

VOID
DBInitializeDriveMapping(
    IN PDS_DRIVE_MAPPING DriveMapping
    );

VOID
ValidateDsPath(
    IN LPSTR  Parameter,
    IN LPSTR  szPath,
    IN DWORD  Flags,
    IN PBOOL  fSwitched, OPTIONAL
    IN PBOOL  fDriveChanged OPTIONAL
    );

//
// Flags used for validatedspath
//

#define VALDSPATH_DIRECTORY         0x1
#define VALDSPATH_USE_ALTERNATE     0x2
#define VALDSPATH_ROOT_ONLY         0x4


// Global configuration variables
extern ULONG gulAOQAggressionLimit;
extern ULONG gulDraThreadOpPriThreshold;
extern int   gnDraThreadPriHigh;
extern int   gnDraThreadPriLow;
extern int   giDCFirstDsaNotifyOverride;
extern int   giDCSubsequentDsaNotifyOverride;
extern ULONG gcMaxIntraSiteObjects;
extern ULONG gcMaxIntraSiteBytes;
extern ULONG gcMaxInterSiteObjects;
extern ULONG gcMaxInterSiteBytes;
extern ULONG gcMaxAsyncInterSiteObjects;
extern ULONG gcMaxAsyncInterSiteBytes;
extern ULONG gulDrsCtxHandleLifetimeIntrasite;
extern ULONG gulDrsCtxHandleLifetimeIntersite;
extern ULONG gulDrsCtxHandleExpiryCheckInterval;
extern ULONG gulDrsRpcBindTimeoutInMins;
extern ULONG gulDrsRpcReplicationTimeoutInMins;
extern ULONG gulDrsRpcGcLookupTimeoutInMins;
extern ULONG gulDrsRpcMoveObjectTimeoutInMins;
extern ULONG gulDrsRpcNT4ChangeLogTimeoutInMins;
extern ULONG gulDrsRpcObjectExistenceTimeoutInMins;
extern ULONG gulDrsRpcGetReplInfoTimeoutInMins;
extern ULONG gcMaxTicksToGetSDPLock;
extern ULONG gcMaxTicksMailSendMsg;
extern ULONG gcMaxMinsSlowReplWarning;
extern ULONG gcSearchInefficientThreshold;
extern ULONG gcSearchExpensiveThreshold;
extern ULONG gulIntersectExpenseRatio;
extern ULONG gulMaxRecordsWithoutIntersection;
extern ULONG gulEstimatedAncestorsIndexSize;
extern ULONG gulReplQueueCheckTime;
extern ULONG gulLdapIntegrityPolicy;
extern ULONG gulDraCompressionLevel;
extern ULONG gulUnlockSystemSubtree;
extern ULONG gulDraCompressionAlg;

//
// Defines whether DSID will be returned.  Since DSID can reveal
// directory information, very high security sites may want to 
// prevent them from being returned.
//
#define DSID_REVEAL_ALL        0
#define DSID_HIDE_ON_NAME_ERR  1
#define DSID_HIDE_ALL          2
extern ULONG gulHideDSID;


// The maximum time (in msec) that a transaction should be allowed to be open
// during normal operation (e.g., unless we're stress testing huge group
// replication, etc.).
#define MAX_TRANSACTION_TIME   30 * 60 * 1000L    // 30 minutes

ULONG
DoSecurityChecksForLocalAdd(
    ADDARG      *pAddArg,
    CLASSCACHE  *pCC,
    GUID        *NewObjectGuid,
    BOOL        fAddingDeleted );

ULONG
CheckRemoveSecurity(
        BOOL fTree,
        CLASSCACHE * pCC,
        RESOBJ     *pResObj );

ULONG
CheckUndeleteSecurity(
    THSTATE *pTHS,
    RESOBJ* pResObj);

ULONG
CheckIfEntryTTLIsAllowed(
        THSTATE *pTHS,
        ADDARG  *pAddArg );

// Globals holding the Kerberos principal name, read during RPC startup, used
// constantly by the LDAP head.
extern ULONG gulLDAPServiceName;
extern PUCHAR gszLDAPServiceName;

// Forward decls, defs, and vars for inter-domain move.

ULONG
PhantomizeObject(
    DSNAME  *pObject,
    DSNAME  *pNewParent,
    BOOL    fChildrenAllowed
    );

// Fsmo transfer helper function
ULONG
GenericBecomeMaster(DSNAME *pFSMO,
                    ATTRTYP ObjClass,
                    GUID    RightRequired,
                    OPRES  *pOpRes);

// A helper function for qsort & bsearch on ATTRTYP arrays
int __cdecl
CompareAttrtyp(
        const void * pv1,
        const void * pv2
        );

VOID
MergeSortedACLists(
    IN  THSTATE    *pTHS,
    IN  ATTCACHE  **rgpAC1,
    IN  DWORD       cAtts1,
    IN  ATTCACHE  **rgpAC2,
    IN  DWORD       cAtts2,
    IN OUT ATTCACHE **rgpACOut,
    OUT DWORD      *pcAttsOut
    );

BOOL
IsACListSorted(
    IN ATTCACHE  **rgpAC,
    IN DWORD       cAtts
    );

// Used to notify NetLogon whether or not we're healthy.  The flag says what
// our current state is, the function is how you change the setting, and
// the cs is how the function serializes access.
extern BOOL gfDsaWritable;
extern CRITICAL_SECTION csDsaWritable;
void
SetDsaWritability(BOOL fNewState,
                  DWORD err);


#if DBG
// Used for asserts only
BOOL CheckCurrency(DSNAME *pDN);
#endif

ULONG
OidToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        OID_t *OID,
        ATTRTYP *attrtyp);

ULONG
OidToAttrCache (
        OID_t *OID,
        ATTCACHE **pAC);

ULONG
AttrTypeToOid (
        ATTRTYP attrtyp,
        OID_t *OID);

ULONG
OidStrToAttrType (
        THSTATE *pTHS,
        BOOL fAddToTable,
        char* StrOid,
        ATTRTYP *attrtyp);

// from sortlocales.c
BOOL
InitLocaleSupport (THSTATE *pTHS);

BOOL
AttrTypToLCID (THSTATE *pTHS,
               ATTRTYP attrType,
               DWORD *pLcid);

// These two items were added to support RemoteAddOneObjectSimply() in
//   boot\install.cxx and  src\mdndnc.c
struct _ADDENTRY_REPLY_INFO;

struct _SecBufferDesc;
typedef struct _SecBufferDesc SecBufferDesc;

ULONG
GetRemoteAddCredentials(
    THSTATE         *pTHS,
    WCHAR           *pDstDSA,
    SecBufferDesc   *pSecBufferDesc
    );

VOID
FreeRemoteAddCredentials(
    SecBufferDesc   *pSecBufferDesc
    );

DWORD
RemoteAddOneObjectSimply(
    IN   LPWSTR pServerName,
    IN   SecBufferDesc * pClientCreds,
    IN   ENTINFLIST* pEntInfList,
    OUT  struct _ADDENTRY_REPLY_INFO **infoList
    );

// These 3 functions (And 3 #defines) help safely pull these components out of the 
// thread error state.
#define  GetTHErrorExtData(pTHS)    GetErrInfoExtData(pTHS->errCode, pTHS->pErrInfo)
#define  GetTHErrorDSID(pTHS)       GetErrInfoDSID(pTHS->errCode, pTHS->pErrInfo)
#define  GetTHErrorProblem(pTHS)    GetErrInfoProblem(pTHS->errCode, pTHS->pErrInfo)
DWORD
GetErrInfoExtData(
    DWORD     errCode,
    DIRERR *  pErrInfo
    );
DWORD
GetErrInfoDSID(
    DWORD     errCode,
    DIRERR *  pErrInfo
    );
USHORT
GetErrInfoProblem(
    DWORD     errCode,
    DIRERR *  pErrInfo
    );

// Globals from drsuapi.c.
extern RTL_CRITICAL_SECTION gcsDrsAsyncRpcListLock;
extern LIST_ENTRY gDrsAsyncRpcList;

void
DsaEnableLinkedValueReplication(
    THSTATE *pTHS,
    BOOL fFirstTime
    );

// macros to get the composite SearchFlags from the CommArg
#define SEARCH_FLAGS(x) (((x).fForwardSeek?DB_SEARCH_FORWARD:0) | \
                         ((x).Svccntl.makeDeletionsAvail?DB_SEARCH_DELETIONS_VISIBLE:0))

#define REVERSE_SEARCH_FLAGS(x) (((x).fForwardSeek?0:DB_SEARCH_FORWARD) | \
                                 ((x).Svccntl.makeDeletionsAvail?DB_SEARCH_DELETIONS_VISIBLE:0))

//  Non-Domain Naming Contexts (NDNCs)
// This a section relating to mdndnc.c
// THese are all functions and helper functions related to NCs and creation and maintance.

// These functions are for NDNC Head stuff in mdndnc.c
DWORD  AddNCPreProcess(THSTATE * pTHS, ADDARG * pAddArg, ADDRES * pAddRes);
DWORD  AddNDNCInitAndValidate(THSTATE * pTHS, DSNAME * pNC, CREATENCINFO * pCreateNC);
DWORD  AddNDNCHeadCheck(THSTATE * pTHS, CROSS_REF * pCR);
DWORD  GetCrossRefForNC(THSTATE * pTHS, DSNAME * pNCDN);
ULONG  ModifyCRForNDNC(THSTATE * pTHS, DSNAME * pDN, CREATENCINFO * pCreateNC);
BOOL   AddNCWellKnownObjectsAtt(THSTATE * pTHS, ADDARG * pAddArg);
ULONG  AddSpecialNCContainers(THSTATE * pTHS, DSNAME * pDN, CROSS_REF * pSDRefDomCR);
BOOL   fIsNDNC(DSNAME * pNC);
BOOL   fIsNDNCCR(IN CROSS_REF * pCR);
DWORD  GetFsmoNtdsa(THSTATE * pTHS, DSNAME * pdnFsmoContainer, DSNAME ** pdnFsmoNtdsa, BOOL * pfRemoteFsmo);
DWORD  GetDcsInNcTransacted(THSTATE * pTHS, DSNAME * Domain, UCHAR cInfoType, SEARCHRES ** ppSearchRes);
CROSS_REF * FindCrossRefByDns(LPWSTR wszDnsDomain);
CROSS_REF * GetDefaultSDRefDomCR(DSNAME * pdnNC);
PSID   GetSDRefDomSid(CROSS_REF * pCR);
DWORD  ValidateDomainDnsName(THSTATE * pTHS, DSNAME * pdnName);
DWORD  ValidateDomainDnsNameComponent(THSTATE* pTHS, PWCHAR szVal, DWORD cbVal);
DSNAME * DSNameFromAddr(THSTATE * pTHS, LPWSTR pszAddr);
void   LogRemoteAdd(BOOL, LPWSTR, DSNAME *, THSTATE *, GUID *, DWORD);


#define fISADDNDNC(x)      ((x) && ((x)->iKind & CREATE_NONDOMAIN_NC))

DWORD
ForceChangeToCrossRef(
    IN DSNAME *  pdnCrossRefObj,
    IN WCHAR *   wszNcDn,
    IN GUID *    pDomainGuid,
    IN ULONG     cbSid,      OPTIONAL
    IN PSID      pSid        OPTIONAL
    );

// from dsatools.c

// This global variable indicates whether we should make a callback
// to give a stringized replication update.  This is used for dcpromo.
extern DSA_CALLBACK_STATUS_TYPE gpfnInstallCallBack;

// Allow other tasks to run by pausing garbage collection after
// processing this many objects. Garbage collection "pauses" by simply
// rescheduling itself to run in 0 seconds.
#define MAX_DUMPSTER_SIZE 5000

// NCL enumeration data structures

// a catalog is identified by an ID (see enum below). This is because a catalog
// essentially consists of two parts: the global list sitting in gAnchor, and the
// local updates that sit in nested_transactional_data. So, whenever we need to
// enumerate (or do whatever) with a catalog, we will pass a single ID instead
// of two pointers.
typedef enum {
    CATALOG_MASTER_NC = 1,
    CATALOG_REPLICA_NC = 2
} CATALOG_ID_ENUM;

// filters for the enumerator
typedef enum {
    NCL_ENUMERATOR_FILTER_NONE = 0,                   // no filter, include all entries
    NCL_ENUMERATOR_FILTER_NCDNT = 1,                  // search for a matching NCDNT
    NCL_ENUMERATOR_FILTER_NC = 2,                     // matching NC, using NameMatched
    NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX1 = 3,     // BlockNamePrefix(pTHS, pNCL->pNCBlock, matchValue) > 0
    NCL_ENUMERATOR_FILTER_BLOCK_NAME_PREFIX2 = 4      // BlockNamePrefix(pTHS, matchValue, pNCL->pNCBlock) > 0
} NCL_ENUMERATOR_FILTER;

typedef struct _NCL_ENUMERATOR {
    CATALOG_ID_ENUM             catalogID;                  // which catalog is being enumerated
    NAMING_CONTEXT_LIST         *pCurEntry;                 // current entry
    NAMING_CONTEXT_LIST         *pBase;                     // base entry (used in CatalogReset)
    NESTED_TRANSACTIONAL_DATA   *pCurTransactionalData;     // currently looking at this transactional level
    BOOL                        bNewEnumerator;             // is it a freshly initialized/reset enumerator?
    NCL_ENUMERATOR_FILTER       filter;                     // filter type
    PVOID                       matchValue;                 // filter match value
    DWORD                       matchResult;                // result of matching function (useful for BLOCK_NAME_PREFIX filters)
    THSTATE                     *pTHS;                      // pTHS cached for BlockNamePrefix calls
} NCL_ENUMERATOR;

// catalog enumerator functions
VOID __fastcall NCLEnumeratorInit(NCL_ENUMERATOR *pEnum, CATALOG_ID_ENUM catalogID);
VOID __fastcall NCLEnumeratorSetFilter(NCL_ENUMERATOR *pEnum, NCL_ENUMERATOR_FILTER filter, PVOID value);
VOID __fastcall NCLEnumeratorReset(NCL_ENUMERATOR *pEnum);
NAMING_CONTEXT_LIST* __fastcall NCLEnumeratorGetNext(NCL_ENUMERATOR *pEnum);

// catalog modification functions (no modifications to global data, only
// local transactional data is modified).
DWORD CatalogAddEntry(NAMING_CONTEXT_LIST *pNCL, CATALOG_ID_ENUM catalogID);
DWORD CatalogRemoveEntry(NAMING_CONTEXT_LIST *pNCL, CATALOG_ID_ENUM catalogID);

// catalog updates functions
// initialize CATALOG_UPDATES structure
VOID CatalogUpdatesInit(CATALOG_UPDATES *pCatUpdates);
// release any memory used by CATALOG_UPDATES structure
VOID CatalogUpdatesFree(CATALOG_UPDATES *pCatUpdates);
// merge CATALOG_UPDATES lists from inner into outer nested transactional data
VOID CatalogUpdatesMerge(CATALOG_UPDATES *pCUouter, CATALOG_UPDATES *pCUinner);
// apply updates in CATALOG_UPDATES list to the global catalog, return TRUE if there were changes
BOOL CatalogUpdatesApply(CATALOG_UPDATES *pCatUpdates, NAMING_CONTEXT_LIST **pGlobalList);

ULONG
PrePhantomizeChildCleanup(
    THSTATE     *pTHS,
    BOOL        fChildrenAllowed
    );

void DbgPrintErrorInfo();

BOOL
fDNTInProtectedList(
    ULONG DNT,
    BOOL *pfNtdsaAncestorWasProtected
    );

ULONG
MakeProtectedAncList(
    ULONG *pUnDeletableDNTs,
    unsigned UnDeletableNum,
    DWORD **ppList,
    DWORD *pCount
    );

// exported from mddit.c for bsearch() and bsort() of NDNC's DNTs in the gAnchor.
int _cdecl CompareDNT(const void *pv1, const void *pv2);

// the string id of the xml script for behavior version upgrade
#define IDS_BEHAVIOR_VERSION_UPGRADE_SCRIPT_0   1

int
CheckNameForRename(
        IN  THSTATE    *pTHS,
        IN  RESOBJ     *pResParent,
        IN  WCHAR      *pRDN,
        IN  DWORD       cchRDN,
        IN  DSNAME     *pDN
    );

DWORD
CheckNcNameForMangling(
    THSTATE *pTHS,
    DSNAME *pObj,
    DSNAME *pNCParent,
    DSNAME *pNCName
    );

BOOL
FPOAttrAllowed(ULONG Attr);  /* in */

DWORD
FPOUpdateWithReference(THSTATE *pTHS,           /* in */
                       ULONG    NCDNT,          /* in */
                       BOOL     fCreate,        /* in */
                       BOOL     fAllowInForest, /* in */
                       DSNAME  *pObject,        /* in */
                       ATTR    *pAttr);         /* in */


DWORD 
VerifyDomainRenameNotInProgress(THSTATE* pTHS);

VOID ScriptResetOptype();

void
FillHasMasterNCsFilters(
    DSNAME * pdnNC,
    FILTER * pHasNcFilter,
    FILTER * pNewHasNcFilter,
    FILTER * pOldHasNcFilter
    );

ULONG
GetRightHasMasterNCsAttr(
    DBPOS *  pDB
    );

VOID
DsStartOrStopNspisInterface( VOID );

BOOL
StandardizeSecurityDescriptor(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PDWORD pDaclSizeSaved,
    OUT PDWORD pSaclSizeSaved
    );

BOOL IsUnderSystemContainer(THSTATE *pTHS, ULONG ulDNT );

DSA_DEL_INFO *GatherDsaDelInfo(THSTATE *pTHS, RESOBJ *pResObj);
VOID FreeDsaDelInfo(THSTATE *pTHS, DSA_DEL_INFO *pDsaDelInfo);

VOID
DsaGetValidFSMOs(
    THSTATE *pTHS,
    LPSTR **ppszValidFsmos,
    DWORD *pcValidFsmos
    );

VOID
VerifyGUIDIsPresent(
    IN DBPOS* pDB,
    OUT DSNAME* pReturnDN OPTIONAL);

#endif /* _MDLOCAL_ */

/* end mdlocal.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\ntdscriptexec.h ===
//+-----------------------------------------------------------------------------
//
// NTDSriptExec.h
//
// Copyright (c) 2000 Microsoft Corporation. All rights reserved.
//
//------------------------------------------------------------------------------
#ifndef __NTDSCRIPTEXEC_H
#define __NTDSCRIPTEXEC_H


#ifdef __cplusplus
extern "C" {
#endif
    DWORD GeneralScriptExecute (THSTATE *pTHS, WCHAR * Script );

#ifdef DBG
    ULONG ExecuteScriptLDAP (OPARG *pOpArg, OPRES *pOpRes);
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTDSCRIPTEXEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\ntdsctr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ntdsctr.h
//
//--------------------------------------------------------------------------

//
//  NTDSCTR.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values of the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
//  We use a version number to keep track of which set of counters we are
//  using, and whether the performance counters in the registry need to be
//  reloaded.  If you add or delete any counters, please change the version
//  number at the end of this file.
//
#define DSAOBJ                  0
#define DRA_IN_PROPS            2
#define BROWSE                  4
#define REPL                    6
#define THREAD                  8
#define ABCLIENT                10
#define PENDSYNC                12
#define REMREPUPD               14
#define SDPROPS                 16
#define SDEVENTS                18
#define LDAPCLIENTS             20
#define LDAPACTIVE              22
#define LDAPWRITE               24
#define LDAPSEARCH              26
#define DRAOBJSHIPPED           28
#define DRAPROPSHIPPED          30
#define DRA_IN_VALUES           32
#define DRASYNCREQUESTMADE      34
#define DRASYNCREQUESTSUCCESSFUL 36
#define DRASYNCREQUESTFAILEDSCHEMAMISMATCH 38
#define DRASYNCOBJRECEIVED      40
#define DRASYNCPROPUPDATED      42
#define DRASYNCPROPSAME         44
#define MONLIST                 46
#define NOTIFYQ                 48
#define LDAPUDPCLIENTS          50
#define SUBSEARCHOPS            52
#define NAMECACHEHIT            54
#define NAMECACHETRY            56
#define HIGHESTUSNISSUEDLO      58
#define HIGHESTUSNISSUEDHI      60
#define HIGHESTUSNCOMMITTEDLO   62
#define HIGHESTUSNCOMMITTEDHI   64
#define SAMWRITES               66
#define TOTALWRITES1            68
#define DRAWRITES               70
#define TOTALWRITES2            72
#define LDAPWRITES              74
#define TOTALWRITES3            76
#define LSAWRITES               78
#define TOTALWRITES4            80
#define KCCWRITES               82
#define TOTALWRITES6            84
#define NSPIWRITES              86
#define TOTALWRITES7            88
#define OTHERWRITES             90
#define TOTALWRITES8            92
#define TOTALWRITES             94
#define SAMSEARCHES             96
#define TOTALSEARCHES1          98 
#define DRASEARCHES             100
#define TOTALSEARCHES2          102
#define LDAPSEARCHES            104
#define TOTALSEARCHES3          106
#define LSASEARCHES             108
#define TOTALSEARCHES4          110
#define KCCSEARCHES             112
#define TOTALSEARCHES6          114
#define NSPISEARCHES            116
#define TOTALSEARCHES7          118
#define OTHERSEARCHES           120
#define TOTALSEARCHES8          122
#define TOTALSEARCHES           124
#define SAMREADS                126
#define TOTALREADS1             128
#define DRAREADS                130
#define TOTALREADS2             132
#define DRA_IN_DN_VALUES        134
#define DRA_IN_OBJS_FILTERED    136
#define LSAREADS                138
#define TOTALREADS4             140
#define KCCREADS                142
#define TOTALREADS6             144
#define NSPIREADS               146
#define TOTALREADS7             148
#define OTHERREADS              150
#define TOTALREADS8             152
#define TOTALREADS              154
#define LDAPBINDSUCCESSFUL      156
#define LDAPBINDTIME            158
#define CREATEMACHINESUCCESSFUL 160
#define CREATEMACHINETRIES      162
#define CREATEUSERSUCCESSFUL    164
#define CREATEUSERTRIES         166
#define PASSWORDCHANGES         168
#define MEMBERSHIPCHANGES       170
#define QUERYDISPLAYS           172
#define ENUMERATIONS            174
#define MEMBEREVALTRANSITIVE    176
#define MEMBEREVALNONTRANSITIVE 178
#define MEMBEREVALRESOURCE      180
#define MEMBEREVALUNIVERSAL     182
#define MEMBEREVALACCOUNT       184
#define MEMBEREVALASGC          186
#define ASREQUESTS              188
#define TGSREQUESTS             190
#define KERBEROSAUTHENTICATIONS 192
#define MSVAUTHENTICATIONS      194
#define DRASYNCFULLREM          196
#define DRA_IN_BYTES_TOTAL_RATE      198
#define DRA_IN_BYTES_NOT_COMP_RATE   200
#define DRA_IN_BYTES_COMP_PRE_RATE   202
#define DRA_IN_BYTES_COMP_POST_RATE  204
#define DRA_OUT_BYTES_TOTAL_RATE     206
#define DRA_OUT_BYTES_NOT_COMP_RATE  208
#define DRA_OUT_BYTES_COMP_PRE_RATE  210
#define DRA_OUT_BYTES_COMP_POST_RATE 212
#define DS_CLIENT_BIND          214
#define DS_SERVER_BIND          216
#define DS_CLIENT_NAME_XLATE    218
#define DS_SERVER_NAME_XLATE    220
#define SDPROP_RUNTIME_QUEUE    222
#define SDPROP_WAIT_TIME        224
#define DRA_OUT_OBJS_FILTERED   226
#define DRA_OUT_VALUES          228
#define DRA_OUT_DN_VALUES       230
#define NSPI_ANR                232
#define NSPI_PROPERTY_READS     234
#define NSPI_OBJECT_SEARCH      236
#define NSPI_OBJECT_MATCHES     238
#define NSPI_PROXY_LOOKUP       240
#define ATQ_THREADS_TOTAL       242
#define ATQ_THREADS_LDAP        244
#define ATQ_THREADS_OTHER       246
#define DRA_IN_BYTES_TOTAL      248
#define DRA_IN_BYTES_NOT_COMP   250
#define DRA_IN_BYTES_COMP_PRE   252
#define DRA_IN_BYTES_COMP_POST  254
#define DRA_OUT_BYTES_TOTAL     256
#define DRA_OUT_BYTES_NOT_COMP  258
#define DRA_OUT_BYTES_COMP_PRE  260
#define DRA_OUT_BYTES_COMP_POST 262
#define LDAP_NEW_CONNS_PER_SEC  264
#define LDAP_CLS_CONNS_PER_SEC  266
#define LDAP_SSL_CONNS_PER_SEC  268
#define DRA_REPL_QUEUE_OPS      270
#define DRA_TDS_IN_GETCHNGS     272
#define DRA_TDS_IN_GETCHNGS_W_SEM    274
#define DRA_REM_REPL_UPD_LNK    276
#define DRA_REM_REPL_UPD_TOT    278
#define NTDSAPIWRITES           280
#define NTDSAPISEARCHES         282
#define NTDSAPIREADS            284
#define SAM_ACCT_GROUP_LATENCY  286
#define SAM_RES_GROUP_LATENCY   288

#define DSA_PERF_COUNTER_BLOCK  TEXT("Global\\Microsoft.Windows.NTDS.Perf")

//If the last counter changes, DSA_LAST_COUNTER_INDEX need to be changed
#define DSA_LAST_COUNTER_INDEX SAM_RES_GROUP_LATENCY

extern volatile unsigned long * pcBrowse;
extern volatile unsigned long * pcSDProps;
extern volatile unsigned long * pcSDEvents;
extern volatile unsigned long * pcLDAPClients;
extern volatile unsigned long * pcLDAPActive;
extern volatile unsigned long * pcLDAPWritePerSec;
extern volatile unsigned long * pcLDAPSearchPerSec;
extern volatile unsigned long * pcThread;
extern volatile unsigned long * pcABClient;
extern volatile unsigned long * pcMonListSize;
extern volatile unsigned long * pcNotifyQSize;
extern volatile unsigned long * pcLDAPUDPClientOpsPerSecond;
extern volatile unsigned long * pcSearchSubOperations;
extern volatile unsigned long * pcNameCacheHit;
extern volatile unsigned long * pcNameCacheTry;
extern volatile unsigned long * pcHighestUsnIssuedLo;
extern volatile unsigned long * pcHighestUsnIssuedHi;
extern volatile unsigned long * pcHighestUsnCommittedLo;
extern volatile unsigned long * pcHighestUsnCommittedHi;
extern volatile unsigned long * pcSAMWrites;
extern volatile unsigned long * pcDRAWrites;
extern volatile unsigned long * pcLDAPWrites;
extern volatile unsigned long * pcLSAWrites;
extern volatile unsigned long * pcKCCWrites;
extern volatile unsigned long * pcNSPIWrites;
extern volatile unsigned long * pcOtherWrites;
extern volatile unsigned long * pcNTDSAPIWrites;
extern volatile unsigned long * pcTotalWrites;
extern volatile unsigned long * pcSAMSearches;
extern volatile unsigned long * pcDRASearches;
extern volatile unsigned long * pcLDAPSearches;
extern volatile unsigned long * pcLSASearches;
extern volatile unsigned long * pcKCCSearches;
extern volatile unsigned long * pcNSPISearches;
extern volatile unsigned long * pcOtherSearches;
extern volatile unsigned long * pcNTDSAPISearches;
extern volatile unsigned long * pcTotalSearches;
extern volatile unsigned long * pcSAMReads;
extern volatile unsigned long * pcDRAReads;
extern volatile unsigned long * pcLSAReads;
extern volatile unsigned long * pcKCCReads;
extern volatile unsigned long * pcNSPIReads;
extern volatile unsigned long * pcOtherReads;
extern volatile unsigned long * pcNTDSAPIReads;
extern volatile unsigned long * pcTotalReads;
extern volatile unsigned long * pcLDAPBinds;
extern volatile unsigned long * pcLDAPBindTime;
extern volatile unsigned long * pcCreateMachineSuccessful;
extern volatile unsigned long * pcCreateMachineTries;
extern volatile unsigned long * pcCreateUserSuccessful;
extern volatile unsigned long * pcCreateUserTries;
extern volatile unsigned long * pcPasswordChanges;
extern volatile unsigned long * pcMembershipChanges;
extern volatile unsigned long * pcQueryDisplays;
extern volatile unsigned long * pcEnumerations;
extern volatile unsigned long * pcMemberEvalTransitive;
extern volatile unsigned long * pcMemberEvalNonTransitive;
extern volatile unsigned long * pcMemberEvalResource;
extern volatile unsigned long * pcMemberEvalUniversal;
extern volatile unsigned long * pcMemberEvalAccount;
extern volatile unsigned long * pcMemberEvalAsGC;
extern volatile unsigned long * pcAsRequests;
extern volatile unsigned long * pcTgsRequests;
extern volatile unsigned long * pcKerberosAuthentications;
extern volatile unsigned long * pcMsvAuthentications;
extern volatile unsigned long * pcDsClientBind;
extern volatile unsigned long * pcDsServerBind;
extern volatile unsigned long * pcDsClientNameTranslate;
extern volatile unsigned long * pcDsServerNameTranslate;
extern volatile unsigned long * pcSDPropRuntimeQueue;
extern volatile unsigned long * pcSDPropWaitTime;
extern volatile unsigned long * pcNspiANR;
extern volatile unsigned long * pcNspiPropertyReads;
extern volatile unsigned long * pcNspiObjectSearch;
extern volatile unsigned long * pcNspiObjectMatches;
extern volatile unsigned long * pcNspiProxyLookup;
extern volatile unsigned long * pcAtqThreadsTotal;
extern volatile unsigned long * pcAtqThreadsLDAP;
extern volatile unsigned long * pcAtqThreadsOther;
extern volatile unsigned long * pcLdapNewConnsPerSec;
extern volatile unsigned long * pcLdapClosedConnsPerSec;
extern volatile unsigned long * pcLdapSSLConnsPerSec;
extern volatile unsigned long * pcSAMAcctGroupLatency;
extern volatile unsigned long * pcSAMResGroupLatency;


// Replication-specific counters.
extern volatile unsigned long * pcRepl;
extern volatile unsigned long * pcPendSync;
extern volatile unsigned long * pcRemRepUpd;
extern volatile unsigned long * pcDRAObjShipped;
extern volatile unsigned long * pcDRAPropShipped;
extern volatile unsigned long * pcDRASyncRequestMade;
extern volatile unsigned long * pcDRASyncRequestSuccessful;
extern volatile unsigned long * pcDRASyncRequestFailedSchemaMismatch;
extern volatile unsigned long * pcDRASyncObjReceived;
extern volatile unsigned long * pcDRASyncPropUpdated;
extern volatile unsigned long * pcDRASyncPropSame;
extern volatile unsigned long * pcDRASyncFullRemaining;
extern volatile unsigned long * pcDRAInBytesTotal;
extern volatile unsigned long * pcDRAInBytesTotalRate;
extern volatile unsigned long * pcDRAInBytesNotComp;
extern volatile unsigned long * pcDRAInBytesNotCompRate;
extern volatile unsigned long * pcDRAInBytesCompPre;
extern volatile unsigned long * pcDRAInBytesCompPreRate;
extern volatile unsigned long * pcDRAInBytesCompPost;
extern volatile unsigned long * pcDRAInBytesCompPostRate;
extern volatile unsigned long * pcDRAOutBytesTotal;
extern volatile unsigned long * pcDRAOutBytesTotalRate;
extern volatile unsigned long * pcDRAOutBytesNotComp;
extern volatile unsigned long * pcDRAOutBytesNotCompRate;
extern volatile unsigned long * pcDRAOutBytesCompPre;
extern volatile unsigned long * pcDRAOutBytesCompPreRate;
extern volatile unsigned long * pcDRAOutBytesCompPost;
extern volatile unsigned long * pcDRAOutBytesCompPostRate;
extern volatile unsigned long * pcDRAInProps;
extern volatile unsigned long * pcDRAInValues;
extern volatile unsigned long * pcDRAInDNValues;
extern volatile unsigned long * pcDRAInObjsFiltered;
extern volatile unsigned long * pcDRAOutObjsFiltered;
extern volatile unsigned long * pcDRAOutValues;
extern volatile unsigned long * pcDRAOutDNValues;
extern volatile unsigned long * pcDRAReplQueueOps;
extern volatile unsigned long * pcDRATdsInGetChngs;
extern volatile unsigned long * pcDRATdsInGetChngsWSem;
extern volatile unsigned long * pcDRARemReplUpdLnk;
extern volatile unsigned long * pcDRARemReplUpdTot;

// Alignof perf counter data block
#define cbPerfCounterDataAlign 256

// Sizeof perf counter data block
extern size_t cbPerfCounterData;


///#define DISABLE_PERF_COUNTERS

#ifdef DISABLE_PERF_COUNTERS

#define INC(x)
#define DEC(x)
#define ISET(x,y)
#define IADJUST(x,y)
#define HIDWORD(usn)
#define LODWORD(usn)
#define PERFINC(x)
#define PERFDEC(x)

#else

#define ADDR(x) ((LPLONG)(((LPBYTE)(x)) + cbPerfCounterData * NtCurrentTeb()->IdealProcessor))
#define INC(x) InterlockedIncrement(ADDR(x))
#define DEC(x) InterlockedDecrement(ADDR(x))
#define IADJUST(x, y) InterlockedExchangeAdd(ADDR(x),y)
// We can't hash an absolute value so just set proc 0's counter and leave all others at zero
#define ISET(x, y)                                                             \
{                                                                              \
    size_t iProc;                                                              \
    extern size_t gcProcessor;                                                 \
                                                                               \
    InterlockedExchange((LPLONG)(x), y);                                       \
    for ( iProc = 1; iProc < gcProcessor; iProc++ ) {                          \
        *((LPLONG)(((LPBYTE)(x)) + cbPerfCounterData * iProc)) = 0;            \
    }                                                                          \
}
#define HIDWORD(usn) ((DWORD) (((usn) >> 32) & 0xffffffff))
#define LODWORD(usn) ((DWORD) ((usn) & 0xffffffff))

// Some of our counters are in fact only updated in one thread, or we
// may not care too much about accuracy.  For those, we have a cheaper
// increment macro.  Note that these are NOT SAFE for counters that must
// reliably return to zero (e.g., ThreadsInUse).
#define PERFINC(x) ((*ADDR(x))++)
#define PERFDEC(x) ((*ADDR(x))--)

#endif  // DISABLE_PERF_COUNTERS

// Version history
// 0 or none, pre April 1998, original set
// 1, April 1998, wlees, added pcDRASyncFullRemaining
// 2, Murlis May 1998 Changed Logon Perf Counters
// 3, Fix help text for logon counters
// 4, Nov 1998, jeffparh, Add DRA in/out byte counters
// 5, 11/21/98, DaveStr, Add DsBind & DsCrackNames counters
// 6, Jan 1999, jeffparh, Add/revise various DRA counters
// 7, Feb 1999, mariosz, Add various Nspi counters
// 8, May 1999, rrandall, Add Atq counters
// 9, June 1999, rrandall, fix counter names and descriptions.
// 10, July 1999, jeffparh, Add DRA cumulative byte ctrs (in addition to rates)
// 11, Feb, 2000, xinhe, Delete XDS counters
// 12, Oct, 2000, rrandall, add debug counters for tracking lping problems.
// 13, Nov, 2000, gregjohn, add DRA queue length and IDL_DRSGetNCChanges thread counters
// 14, Nov, 2000, gregjohn, add NTDSAPI Dir search/read/write counter
// 15, Jan, 2001, rrandall, remove "LDAP Successful Binds" counter
// 16, Aug, 2001, t-kchan, remove LDAP_THREADS_* counters
// 17, Oct, 2002, colinbr, add group evaluation latency counters

#define NTDS_PERFORMANCE_COUNTER_VERSION 17

         
//The size of the shared memory block for communication between 
//ntdsa.dll and ntdsperf.dll
#define DSA_PERF_SHARED_PAGE_SIZE 65536

//The following macro returns the offset in DWORD of counter X
#define COUNTER_OFFSET(X) ( (X) / 2 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\pek.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       pek.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    This file contains services for encrypting and decrypting password attributes
    at the DBLayer level

Author:

    Murlis 

Environment:

    User Mode - Win32

Revision History:
    19 Jan 1998 Created
    

--*/

#ifndef __PEK_H__
#define __PEK_H__

#include <nt.h>
#include <wxlpc.h>

// version number to be used in pek list
#define DS_PEK_CURRENT_VERSION      2
// the following version is used by pre-RC2 win2k DC's
#define DS_PEK_PRE_RC2_W2K_VERSION  1

#define DS_PEK_BOOT_KEY_RETRY_COUNT 3
#define DS_PEK_KEY_SIZE             16
#define DS_PEK_CHECKSUM_SIZE        16


//
// Flags for PEK intiatialze
//

#define DS_PEK_GENERATE_NEW_KEYSET 0x1
#define DS_PEK_READ_KEYSET         0x2


//
// Flags for PEK set Boot Options
//

#define DS_PEK_SET_OPERATION       0x4

// Algorithm ID definition
// 0x10 chosen so does not conflict with the
// algorithm ID that SAM's secret data structures
// use.
#define DS_PEK_DBLAYER_ENCRYPTION   0x10
#define DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT 0x11
#define DS_PEK_DBLAYER_ENCRYPTION_FOR_REPLICATOR 0x12

#include <pshpack1.h>

//
// The following structure is the encrypted data
// associated with the algorithm ID of DS_PEK_DBLAYER_ENCRYPTION
//
typedef struct _ENCRYPTED_DATA
{
   USHORT AlgorithmId;
   USHORT Flags;
   ULONG  KeyId;
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA;


//
// The following structure is the encrypted data
// associated with the algorithm ID of DS_PEK_DBLAYER_ENCRYPTION_WITH_SALT
//
typedef struct _ENCRYPTED_DATA_WITH_SALT
{
   USHORT AlgorithmId;
   USHORT Flags;
   ULONG  KeyId;
   UCHAR  Salt[16]; // 128 bits of Salt
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_WITH_SALT;

//
// The following structure is the encrypted data that is returned
// to replicator for replicating out the encrypted information
// We do not need an algorithm ID here as if we introduce a new kind
// of encryption we will need an extension bit to indicate that we support
// it and that bit conveys us the same information
//
typedef struct _ENCRYPTED_DATA_FOR_REPLICATOR
{
   UCHAR  Salt[16]; // 128 bits of Salt
   ULONG  CheckSum;
   UCHAR  EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_FOR_REPLICATOR;
   
typedef struct _ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_PEK_LIST_PRE_WIN2K_RC2;

typedef struct _ENCRYPTED_PEK_LIST
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           Salt[DS_PEK_KEY_SIZE];
    UCHAR           EncryptedData[ANYSIZE_ARRAY];
} ENCRYPTED_PEK_LIST;

typedef struct {
    ULONG           KeyId;
    UCHAR           Checksum[DS_PEK_CHECKSUM_SIZE];
} STRONG_CHECKSUM;


typedef struct _PEK_V1
{
    ULONG KeyId;
    UCHAR Key[DS_PEK_KEY_SIZE];
} PEK_V1;

typedef struct _PEK
{
    union 
    {
        PEK_V1 V1;
    };
} PEK;

typedef struct _CLEAR_PEK_LIST
{
    ULONG           Version;
    WX_AUTH_TYPE    BootOption;
    UCHAR           Salt[DS_PEK_KEY_SIZE];
    GUID            Authenticator;
    FILETIME        LastKeyGenerationTime;
    ULONG           CurrentKey;
    ULONG           CountOfKeys;
    PEK             PekArray[ANYSIZE_ARRAY];
} CLEAR_PEK_LIST;

#include <poppack.h>

//
// Macros for computing lengths
//

// Compute the length of a clear pek list, given the encrypted pek list
#define ClearPekListSize(n) (sizeof(CLEAR_PEK_LIST)+(n-1)*sizeof(PEK))



NTSTATUS
PEKInitialize(
    IN DSNAME * Object OPTIONAL, 
    IN ULONG Flags,
    IN PVOID Syskey OPTIONAL,
    IN ULONG cbSyskey OPTIONAL
    );

// Note: This checksum is not cryptographically strong.
// Consider PEKComputeStrongCheckSum if a strong checksum is needed.
ULONG
PEKCheckSum(
    IN PBYTE Data,
    IN ULONG Length
    );

DWORD
PEKComputeStrongCheckSum(
    IN  PBYTE               pbData,
    IN  ULONG               cbData,
    OUT STRONG_CHECKSUM *   pChecksum
    );

BOOL
PEKVerifyStrongCheckSum(
    IN  PBYTE               pbData,
    IN  ULONG               cbData,
    IN  STRONG_CHECKSUM *   pChecksum
    );

VOID
PEKEncrypt(
    IN THSTATE * pTHS,
    IN PVOID ClearData,
    IN ULONG ClearLength,
    OUT PVOID  EncryptedData OPTIONAL,
    OUT PULONG EncryptedLength
    );

VOID
PEKDecrypt(
    IN THSTATE * pTHS,
    IN PVOID  InputData,
    IN ULONG  EncryptedLength,
    OUT PVOID  ClearData, OPTIONAL
    OUT PULONG ClearLength
    );


NTSTATUS
PEKAddKey(
    IN PVOID NewKey,
    IN ULONG cbNewKey
    );

FILETIME
PEKGetLastKeyGenerationTime();



WX_AUTH_TYPE
PEKGetBootOptions(VOID);

NTSTATUS
PEKChangeBootOption(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    );

NTSTATUS
PEKSaveChanges(DSNAME *ObjectToSave);


VOID
PEKClearSessionKeys(
    THSTATE * pTHS
    );


NTSTATUS
PEKGetSessionKey(
    THSTATE * pTHS,
    VOID * RpcContext
    );

NTSTATUS
PEKGetSessionKey2(
    SESSION_KEY *SessionKeyOut,
    VOID * RpcContext
    );

VOID
PEKSecurityCallback(VOID *Context);

VOID
PEKSaveSessionKeyForMyThread(
    IN OUT  THSTATE *       pTHS,
    OUT     SESSION_KEY *   pSessionKey
    );

VOID
PEKRestoreSessionKeySavedByMyThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    );

VOID
PEKRestoreSessionKeySavedByDiffThread(
    IN OUT  THSTATE *       pTHS,
    IN      SESSION_KEY *   pSessionKey
    );

VOID
PEKDestroySessionKeySavedByDiffThread(
    IN OUT  SESSION_KEY *   pSessionKey
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\quota.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    quota.h

Abstract:

    This module defines the data structures and function prototypes for the
    quota subsystem.

Author:

    Jonathan Liem (jliem) 26-Jun-2002

Revision History:

--*/

#ifndef _QUOTA_
#define _QUOTA_


//	if enabled, detection of corruption in the quota table will log an event and cause the operation to fail
//	if disabled, detection of corruption in the quota table will log an event but NOT cause the operation to fail
//
///#define FAIL_OPERATION_ON_CORRUPT_QUOTA_TABLE


#ifdef DBG

//	if enabled, quota table is integrity-checked on init (and rebuilt if deemed corrupt)
//	if disabled, quota table is NOT integrity-checked on init
//
#define CHECK_QUOTA_TABLE_ON_INIT

//	if enabled, quota operations are tracked in a separate table to facilitate debugging
//	if disbled, quota operations are not tracked in a separate table
//
#define AUDIT_QUOTA_OPERATIONS

#endif	//	DBG


//	define a constant used to represent unlimited quota
//
#define g_ulQuotaUnlimited						0xffffffff

//	default number of entries to return on top-usage-query
//	if no range is specified
//
#define g_ulQuotaTopUsageQueryDefaultEntries	10

//	quota only tracked for writable, instantiated, non-NC-head objects
//
#define FQuotaTrackObject( insttype )	( ( ( insttype ) & IT_WRITE ) \
											&& !( ( insttype ) & IT_UNINSTANT ) \
											&& !( ( insttype ) & IT_NC_HEAD ) )



//
//	INTERNAL FUNCTIONS
//

INT ErrQuotaRebuild_(
	JET_SESID			sesid,
	JET_DBID			dbid,
	JET_TABLEID			tableidQuota,
	JET_TABLEID			tableidQuotaRebuildProgress,
	ULONG				ulDNTLast,
	JET_COLUMNID		columnidQuotaNcdnt,
	JET_COLUMNID		columnidQuotaSid,
	JET_COLUMNID		columnidQuotaTombstoned,
	JET_COLUMNID		columnidQuotaTotal,
	const BOOL			fAsync,
	const BOOL			fCheckOnly );


#ifdef AUDIT_QUOTA_OPERATIONS

VOID QuotaAudit_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	DWORD			dnt,
	DWORD			ncdnt,
	PSID			psidOwner,
	const ULONG		cbOwnerSid,
	const DWORD		fUpdatedTotal,
	const DWORD		fUpdatedTombstoned,
	const DWORD		fIncrementing,
	const DWORD		fAdding,
	const CHAR		fRebuild );

#else

__inline VOID QuotaAudit_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	DWORD			dnt,
	DWORD			ncdnt,
	PSID			psidOwner,
	const ULONG		cbOwnerSid,
	const DWORD		fUpdatedTotal,
	const DWORD		fUpdatedTombstoned,
	const DWORD		fIncrementing,
	const DWORD		fAdding,
	const CHAR		fRebuild )
	{
	return;
	}

#endif	//	AUDIT_QUOTA_OPERATIONS



//
//	EXTERNAL FUNCTIONS
//

INT ErrQuotaAddObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD,
	const BOOL				fIsTombstoned );

INT ErrQuotaTombstoneObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD );

INT ErrQuotaDeleteObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD,
	const BOOL				fIsTombstoned );

INT ErrQuotaResurrectObject(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSECURITY_DESCRIPTOR	pSD );

INT ErrQuotaQueryEffectiveQuota(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSID					pOwnerSid,
	ULONG *					pulEffectiveQuota );

INT ErrQuotaQueryUsedQuota(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	PSID					pOwnerSid,
	ULONG *					pulQuotaUsed );

INT ErrQuotaQueryTopQuotaUsage(
	DBPOS * const			pDB,
	const DWORD				ncdnt,
	const ULONG				ulRangeStart,
	ULONG * const			pulRangeEnd,
	ATTR *					pAttr );

VOID QuotaRebuildAsync(
	VOID *					pv,
	VOID **					ppvNext,
	DWORD *					pcSecsUntilNextIteration );

INT ErrQuotaIntegrityCheck(
	JET_SESID				sesid,
	JET_DBID				dbid,
	ULONG *					pcCorruptions );

#endif	//	_QUOTA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\prefix.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       prefix.h
//
//--------------------------------------------------------------------------

#ifndef _PREFIX_H_
#define _PREFIX_H_


// Indices upto 100 are reserved for MS

#define MS_RESERVED_PREFIX_RANGE 100

// Prefix indices for internal prefixes used

#define _dsP_attrTypePrefIndex       0
#define _dsP_objClassPrefIndex       1
#define _msP_attrTypePrefIndex       2
#define _msP_objClassPrefIndex       3
#define _dmsP_attrTypePrefIndex      4
#define _dmsP_objClassPrefIndex      5
#define _sdnsP_attrTypePrefIndex     6
#define _sdnsP_objClassPrefIndex     7
#define _dsP_attrSyntaxPrefIndex     8
#define _msP_attrSyntaxPrefIndex     9
#define _msP_ntdsObjClassPrefIndex   10

// [ArobindG: 7/15/98]: The following 8 prefixe spaces with indices
// from 11 to 18 were assigned long back for temporary use. Unfortunately
// we didn't take them out earlier. Now that we are in the upgrade mode,
// it is unadvisable to take them out, since older binaries will still
// have them, and the prefixes will replicate in to a DC with new binaries 
// (if we remove these) anyway, adding them to the prefix map with
// different indices, which is confusing. Moreover, we cannot reuse these
// indices now for the same reason. So we will just keep them around,
// calling them dead for code clarity. We can use these prefix spaces
// later on if we wish to.

#define _Dead_AttPrefIndex_1     11  
#define _Dead_ClassPrefIndex_1   12
#define _Dead_AttPrefIndex_2     13
#define _Dead_ClassPrefIndex_2   14
#define _Dead_AttPrefIndex_3     15
#define _Dead_ClassPrefIndex_3   16
#define _Dead_ClassPrefIndex_4   17
#define _Dead_AttPrefIndex_4     18

#define _Ldap_0AttPrefIndex     19
#define _Ldap_1AttPrefIndex     20
#define _Ldap_2AttPrefIndex     21
#define _Ldap_3AttPrefIndex     22

// This one is not temporary.  Keep this one around.
#define _msP_ntdsExtnObjClassPrefIndex 23

// Prefixes for constructed att OIDs
#define _Constr_1AttPrefIndex     24
#define _Constr_2AttPrefIndex     25
#define _Constr_3AttPrefIndex     26
#define _DynObjPrefixIndex        27
#define _InetOrgPersonPrefixIndex 28
#define _labeledURIPrefixIndex    29
#define _unstructuredPrefixIndex  30
#define _Ldap_3ClassPrefixIndex   31

#ifndef dsP_attributeType
  #define _dsP_attrTypePrefix "\x55\x4"
  #define _dsP_attrTypePrefLen 2
  #define dsP_attributeType(X) (_dsP_attrTypePrefix #X) /* joint-iso-ccitt 5 4 */
#endif

#ifndef dsP_objectClass
  #define _dsP_objClassPrefix "\x55\x6"
  #define _dsP_objClassPrefLen 2
  #define dsP_objectClass(X)   (_dsP_objClassPrefix #X) /* joint-iso-ccitt 5 6 */
#endif

#ifndef msP_attributeType
  #define _msP_attrTypePrefix "\x2A\x86\x48\x86\xF7\x14\x01\x02"
  #define _msP_attrTypePrefLen 8
  #define msP_attributeType(X) (_msP_attrTypePrefix #X) /* ms-ds 2 */
#endif

#ifndef msP_objectClass
  #define _msP_objClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x03"
  #define _msP_objClassPrefLen 8
  #define msP_objectClass(X)   (_msP_objClassPrefix #X) /* ms-ds 3 */
#endif

#ifndef dmsP_attrType
  #define _dmsP_attrTypePrefLen 8
  #define _dmsP_attrTypePrefix "\x60\x86\x48\x01\x65\x02\x02\x01"
  #define dmsP_attrType(X)   (_dmsP_attrTypePrefix #X)
#endif

#ifndef dmsP_objClass
  #define _dmsP_objClassPrefLen 8
  #define _dmsP_objClassPrefix "\x60\x86\x48\x01\x65\x02\x02\x03"
  #define dmsP_objClass(X)   (_dmsP_objClassPrefix #X)
#endif


#ifndef sdnsP_attrType
  #define _sdnsP_attrTypePrefLen 8
  #define _sdnsP_attrTypePrefix "\x60\x86\x48\x01\x65\x02\x01\x05"
  #define sdnsP_attrType(X)   (_sdnsP_attrTypePrefix #X)
#endif

#ifndef sdnsP_objClass
  #define _sdnsP_objClassPrefLen 8
  #define _sdnsP_objClassPrefix "\x60\x86\x48\x01\x65\x02\x01\x04"
  #define sdnsP_objClass(X)   (_sdnsP_objClassPrefix #X)
#endif

#ifndef dsP_attrSyntax
  #define _dsP_attrSyntaxPrefix "\x55\x5"
  #define _dsP_attrSyntaxPrefLen 2
  #define dsP_attrSyntax(X)   (_dsP_attrSyntaxPrefix #X) /* joint-iso-ccitt 5 5 */
#endif

#ifndef msP_attrSyntax
  #define _msP_attrSyntaxPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x04"
  #define _msP_attrSyntaxPrefLen 8
  #define msP_attrSyntax(X) (_msP_attrSyntaxPrefix #X) /* ms-ds 4 */
#endif

#ifndef msP_ntdsObjClass
  #define _msP_ntdsObjClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x05"
  #define _msP_ntdsObjClassPrefLen 8
  #define msP_ntdsObjClass(X) (_msP_ntdsObjClassPrefix #X) /* ms-nt-ds 5 */
#endif

#define _msP_ntdsExtnObjClassPrefix "\x2A\x86\x48\x86\xF7\x14\x01\x05\xB6\x58"
#define _msP_ntdsExtnObjClassPrefLen 10
#define msP_ntdsExntObjClass(X) (_msP_ntsExtnObjClassPrefix #X) /* ms-nt-ds 5 */
  

// 1.2.840.113556.1.4.260 - customer attributes
#define _Dead_AttPrefix_1 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x04"
#define _Dead_AttLen_1 10

// 1.2.840.113556.1.4.262  YiHsins Attribute Space
#define _Dead_AttPrefix_2 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x06"
#define _Dead_AttLen_2 10

// 1.2.840.113556.1.4.263  DaveStr's Attribute Space
#define _Dead_AttPrefix_3 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x07"
#define _Dead_AttLen_3 10

// 1.2.840.113556.1.5.56 Customer Class Space
#define _Dead_ClassPrefix_1 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x38"
#define _Dead_ClassLen_1 9

// 1.2.840.113556.1.5.57 YiHsins Class Space
#define _Dead_ClassPrefix_2 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x39"
#define _Dead_ClassLen_2 9

// 1.2.840.113556.1.5.58 DaveStr Class Space
#define _Dead_ClassPrefix_3 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x3A"
#define _Dead_ClassLen_3 9


// 1.2.840.113556.1.4.305 Srinigs Att Space
#define _Dead_AttPrefix_4 "\x2A\x86\x48\x86\xF7\x14\x01\x04\x82\x31"
#define _Dead_AttLen_4 10

// 1.2.840.113556.1.5.73 Srinig Class Space
#define _Dead_ClassPrefix_4 "\x2A\x86\x48\x86\xF7\x14\x01\x05\x49"
#define _Dead_ClassLen_4 9

#define _Ldap_0AttPrefix "\x09\x92\x26\x89\x93\xF2\x2C\x64"
#define _Ldap_0AttLen 8

#define _Ldap_1AttPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03"
#define _Ldap_1AttLen 8

#define _Ldap_2AttPrefix "\x09\x92\x26\x89\x93\xF2\x2C\x64\x01"
#define _Ldap_2AttLen 9

#define _Ldap_3AttPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03\x01"
#define _Ldap_3AttLen 9

#define _Constr_1AttPrefix "\x55\x15"
#define _Constr_1AttLen 2

#define _Constr_2AttPrefix "\x55\x12"
#define _Constr_2AttLen 2

#define _Constr_3AttPrefix "\x55\x14"
#define _Constr_3AttLen 2

// // 1.3.6.1.4.1.1466.101.119 x2B060104018B3A6577 LDAP RFC for Dynamic Objects
#define _DynObjPrefix   "\x2B\x06\x01\x04\x01\x8B\x3A\x65\x77"
#define _DynObjLen      9

// // 2.16.840.1.113730.3.2  x6086480186F8420302 InetOrgPerson prefix
#define _InetOrgPersonPrefix "\x60\x86\x48\x01\x86\xF8\x42\x03\x02"
#define _InetOrgPersonLen  9

// //  1.3.6.1.4.1.250.1  x2B06010401817A01 labeledURI prefix
#define _labeledURIPrefix "\x2B\x06\x01\x04\x01\x81\x7A\x01"
#define _labeledURILen 8

// // 1.2.840.113549.1.9  x2A864886F70D0109 unstructuredAddress and unstructuredName prefix                         
#define _unstructuredPrefix "\x2A\x86\x48\x86\xF7\x0D\x01\x09"
#define _unstructuredLen 8

// // 0.9.2342.19200300.100.4   x0992268993F22C6404 ldap v3 class prefix
#define _Ldap_3ClassPrefix "\x09\x92\x26\x89\x93\xF2\x2C\x64\x04"
#define _Ldap_3ClassLen 9

#define MSPrefixCount 32

// All hardcoded prefixes we added till the IDS at end of April are the only ones
// we can trust to be the same on any DC for a given prefix. From that IDS,
// we started supporting upgrades, and any new hardcoded prefix we added
// after that may have different indices on different DCs (that is, not
// necessarily the same as the hardcoded index here for that prefix), since
// some may have got a new OID with that prefix as part of a schema object
// add during schema upgrade, and since its (older) binaries still does not
// contain the prefix in the hardcoded table, it went ahead and added this
// as a new prefix with a random index. When it gets the new binaries with
// the hardcoded prefix, we will void out the hardcoded prefix so that there
// will be only one entry for the prefix.
//
// This also means that an OID with a prefix beyond this may have different
// attids in different DCs just like dynamically added schema objects, even
// though the OID is in schema.ini. So you cannot use this attids as hardcoded
// constants in code. Mkhdr comments out such attids in attids.h so that you
// cannot accidentally end up using them.
//
// 26 was the last index usable in hardcoded attids, so even if you add
// a new prefix, DO NOT CHANGE the following constant. Just change the
// MSPrefixCount as usual.

#define MAX_USABLE_HARDCODED_INDEX  26


#define DECLAREPREFIXPTR \
PrefixTableEntry *PrefixTable = ((SCHEMAPTR *)pTHStls->CurrSchemaPtr)->PrefixTable.pPrefixEntry; \
ULONG  PREFIXCOUNT =  ((SCHEMAPTR *)pTHStls->CurrSchemaPtr)->PREFIXCOUNT; 

int   InitPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
int   InitPrefixTable2(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
void  SCFreePrefixTable(PrefixTableEntry **ppPrefixTable, ULONG PREFIXCOUNT);
void  PrintPrefixTable(PrefixTableEntry *PrefixTable, ULONG PREFIXCOUNT);
int   AppendPrefix(OID_t *NewPrefix,
                   DWORD ndx,
                   UCHAR *pBuf,
                   BOOL fFirst);
int   WritePrefixToSchema(struct _THSTATE *pTHS);
int   AddPrefixToTable(PrefixTableEntry *NewPrefix, 
                       PrefixTableEntry **ppTable, 
                       ULONG *pPREFIXCOUNT);


typedef struct _SCHEMA_PREFIX_MAP_ENTRY {
    USHORT  ndxFrom;
    USHORT  ndxTo;
} SCHEMA_PREFIX_MAP_ENTRY;

#define SCHEMA_PREFIX_MAP_fFromLocal (1)
#define SCHEMA_PREFIX_MAP_fToLocal   (2)

/* Turn off the warning about the zero-sized array. */
#pragma warning (disable: 4200)

typedef struct _SCHEMA_PREFIX_MAP_TABLE {
    struct _THSTATE        *pTHS;
    DWORD                   dwFlags;
    DWORD                   cNumMappings;
    SCHEMA_PREFIX_MAP_ENTRY rgMapping[];
} SCHEMA_PREFIX_MAP_TABLE;

/* Turn back on the warning about the zero-sized array. */
#pragma warning (default: 4200)

#define SchemaPrefixMapSizeFromLen(x)               \
    (offsetof(SCHEMA_PREFIX_MAP_TABLE, rgMapping)   \
    + (x) * sizeof(SCHEMA_PREFIX_MAP_ENTRY))

typedef SCHEMA_PREFIX_MAP_TABLE * SCHEMA_PREFIX_MAP_HANDLE;

SCHEMA_PREFIX_MAP_HANDLE
PrefixMapOpenHandle(
    IN  SCHEMA_PREFIX_TABLE *   pTableFrom,
    IN  SCHEMA_PREFIX_TABLE *   pTableTo
    );

BOOL
PrefixTableAddPrefixes(
    IN  SCHEMA_PREFIX_TABLE *   pTable
    );

BOOL
PrefixMapTypes(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN      DWORD                     cNumTypes,
    IN OUT  ATTRTYP *                 pTypes
    );

BOOL
PrefixMapAttr(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTR *                    pAttr
    );

BOOL
PrefixMapAttrBlock(
    IN      SCHEMA_PREFIX_MAP_HANDLE  hPrefixMap,
    IN OUT  ATTRBLOCK *               pAttrBlock
    );

// need FILENO for THFree
#ifndef FILENO
#define FILENO_DEFINED
#define FILENO 0
#endif

__inline void PrefixMapCloseHandle(IN SCHEMA_PREFIX_MAP_HANDLE *phPrefixMap) {
    THFree(*phPrefixMap);
    *phPrefixMap = NULL;
}

// reset to the original state
#ifdef FILENO_DEFINED
#undef FILENO
#undef FILEO_DEFINED
#endif

#endif // _PREFIX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\servinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       servinfo.h
//
//--------------------------------------------------------------------------


typedef struct _ServiceClassArray {
    DWORD count;
    PWCHAR *Vals;
} ServiceClassArray;

extern ServiceClassArray ServicesToRemove;

void
WriteSPNsHelp(
        THSTATE *pTHS,
        ATTCACHE *pAC_SPN,
        ATTRVALBLOCK *pAttrValBlock,
        ServiceClassArray *pClasses,
        BOOL *pfChanged
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\samwrite.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samwrite.h
//
//--------------------------------------------------------------------------

/*++

Abstract:

    Prototypes for all the routines which map ATTR data to SAM information
    structs and writes them via Samr calls.

Author:

    DaveStr     01-Aug-96
    

Environment:

    User Mode - Win32

Revision History:


--*/

#ifndef __SAMWRITE_H__
#define __SAMWRITE_H__

#define WRITE_PROC(name)                    \
extern                                      \
ULONG                                       \
SampWrite##name(                            \
    SAMPR_HANDLE        hObj,               \
    ULONG               iAttr,              \
    DSNAME              *pObject,           \
    ULONG               cCallMap,           \
    SAMP_CALL_MAPPING   *rCallMap); 

WRITE_PROC(NotAllowed)

//WRITE_PROC(ServerSecurityDescriptor)

//WRITE_PROC(DomainSecurityDescriptor)
WRITE_PROC(DomainOemInformation)
WRITE_PROC(DomainMaxPasswordAge)
WRITE_PROC(DomainMinPasswordAge)
WRITE_PROC(DomainForceLogoff)
WRITE_PROC(DomainLockoutDuration)
WRITE_PROC(DomainLockoutObservationWindow)
WRITE_PROC(DomainPasswordProperties)
WRITE_PROC(DomainMinPasswordLength)
WRITE_PROC(DomainPasswordHistoryLength)
WRITE_PROC(DomainLockoutThreshold)
WRITE_PROC(DomainUasCompatRequired)
WRITE_PROC(DomainNtMixedDomain)

//WRITE_PROC(GroupSecurityDescriptor)
WRITE_PROC(GroupName)
WRITE_PROC(GroupAdminComment)
WRITE_PROC(GroupMembers)
WRITE_PROC(GroupTypeAttribute)

//WRITE_PROC(AliasSecurityDescriptor)
WRITE_PROC(AliasName)
WRITE_PROC(AliasAdminComment)
WRITE_PROC(AliasMembers)

//WRITE_PROC(UserSecurityDescriptor)
WRITE_PROC(UserAllInformation)
WRITE_PROC(UserForcePasswordChange)
WRITE_PROC(UserLockoutTimeAttribute)

WRITE_PROC(SidHistory);


#endif // __SAMWRITE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\sdprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sdprop.h
//
//--------------------------------------------------------------------------

// Critical sections, events to build a writer/reader lock
extern CRITICAL_SECTION csSDP_AddGate;
extern HANDLE hevSDP_OKToRead, hevSDP_OKToWrite;

// event signalled by SDPropagator thread when it dies.
extern HANDLE hevSDPropagatorDead;

// event the SDPropagator waits on. Should be set when something is in the
// SDProp queue
extern HANDLE hevSDPropagationEvent;

// event the SDPropagator waits on before running.  Intended to be signalled by
// SAM, which can conflict with the SDPropagator
extern HANDLE hevSDPropagatorStart;

extern PSECURITY_DESCRIPTOR pNoSDFoundSD;
extern DWORD                cbNoSDFoundSD;

NTSTATUS
__stdcall
SecurityDescriptorPropagationMain (
        PVOID StartupParam
        );



DWORD
SDPEnqueueTreeFixUp(
        THSTATE *pTHS,
        DWORD   rootDNT,
        DWORD   dwFlags
        );

// These routines manage a reader/writer gate which all calls to add objects
// should enter as readers BEFORE opening a transaction.  Currently, DirAdd
// calls the reader gates before entering a transaction and after closing the
// transaction.   The Security Descriptor Propagator enters as a writer before
// it's transaction.
// The implementation of this gate is that the writer is blocked until there are
// no active readers, while readers only block if there is an ACTIVE (not
// blocked) writer.  This could lead to starving the writer, but the writer is a
// background process which will eventually get resources when no one is adding
// an object.
//
// The routines that return BOOLs may ONLY fail if we are shutting down!
BOOL
SDP_EnterAddAsReader(
        VOID );

VOID
SDP_LeaveAddAsReader(
        VOID );

BOOL
SDP_EnterAddAsWriter(
        VOID );

VOID
SDP_LeaveAddAsWriter(
        VOID );

DWORD 
AncestryIsConsistentInSubtree(
    DBPOS* pDB, 
    BOOL* pfAncestryIsConsistent
    );

#define SDP_NEW_SD         1
#define SDP_NEW_ANCESTORS  2
#define SDP_TO_LEAVES      4
#define SDP_ANCESTRY_INCONSISTENT_IN_SUBTREE  0x08
#define SDP_ANCESTRY_BEING_UPDATED_IN_SUBTREE 0x10
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\ntdsa\include\scache.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       scache.h
//
//--------------------------------------------------------------------------

#ifndef __SCACHE_H__
#define __SCACHE_H__

// Define the Jet types used in this header file and in dbglobal.h.  Then, mark
// jet.h as included so that no one else will accidently include jet.h
#ifndef _JET_INCLUDED
typedef ULONG_PTR JET_TABLEID;
typedef unsigned long JET_DBID;
typedef ULONG_PTR JET_SESID;
typedef unsigned long JET_COLUMNID;
typedef unsigned long JET_GRBIT;
#define _JET_INCLUDE
#endif

// Starting (and minimum) table sizes for the schema cache tables.
// Tables will be grown dynamically beyond this if needed
// Note: START_PREFIXCOUNT must be at least as large as MSPrefixCount
// (defined in prefix.h) plus the maximum number of new prefixes that
// a thread can create

#define START_ATTCOUNT 2048
#define START_CLSCOUNT 512
#define START_PREFIXCOUNT 256

typedef unsigned short OM_syntax;
#define OM_S_NO_MORE_SYNTAXES           ( (OM_syntax) 0 )
#define OM_S_BIT_STRING                 ( (OM_syntax) 3 )
#define OM_S_BOOLEAN                    ( (OM_syntax) 1 )
#define OM_S_ENCODING_STRING            ( (OM_syntax) 8 )
#define OM_S_ENUMERATION                ( (OM_syntax) 10 )
#define OM_S_GENERAL_STRING             ( (OM_syntax) 27 )
#define OM_S_GENERALISED_TIME_STRING    ( (OM_syntax) 24 )
#define OM_S_GRAPHIC_STRING             ( (OM_syntax) 25 )
#define OM_S_IA5_STRING                 ( (OM_syntax) 22 )
#define OM_S_INTEGER                    ( (OM_syntax) 2 )
#define OM_S_NULL                       ( (OM_syntax) 5 )
#define OM_S_NUMERIC_STRING             ( (OM_syntax) 18 )
#define OM_S_OBJECT                     ( (OM_syntax) 127 )
#define OM_S_OBJECT_DESCRIPTOR_STRING   ( (OM_syntax) 7 )
#define OM_S_OBJECT_IDENTIFIER_STRING   ( (OM_syntax) 6 )
#define OM_S_OCTET_STRING               ( (OM_syntax) 4 )
#define OM_S_PRINTABLE_STRING           ( (OM_syntax) 19 )
#define OM_S_TELETEX_STRING             ( (OM_syntax) 20 )
#define OM_S_UTC_TIME_STRING            ( (OM_syntax) 23 )
#define OM_S_VIDEOTEX_STRING            ( (OM_syntax) 21 )
#define OM_S_VISIBLE_STRING             ( (OM_syntax) 26 )
#define OM_S_UNICODE_STRING  	        ( (OM_syntax) 64 )
#define OM_S_I8                         ( (OM_syntax) 65 )
#define OM_S_OBJECT_SECURITY_DESCRIPTOR ( (OM_syntax) 66 )

BOOL OIDcmp(OID_t const *string1, OID_t const *string2);

typedef struct _attcache
{
    ATTRTYP id;			    // Internal Id from msDS-IntId
    ATTRTYP Extid;			// Tokenized OID from attributeId
    UCHAR *name;		    /* Attribute name (null terminated) UTF8*/
    ULONG nameLen;          /* strlen(name) (doesn't include NULL)  */
    unsigned syntax;        /* Syntax				*/
    BOOL isSingleValued;	/* Single Valued or Multi-valued?	*/
    BOOL rangeLowerPresent;	/* Lower range present                  */
    ULONG rangeLower;		/* Optional - Lower range               */
    BOOL rangeUpperPresent;	/* Upper range present			*/
    ULONG rangeUpper;		/* Optional - Upper range               */
    JET_COLUMNID jColid;	/* Column id in JET database		*/
    ULONG ulMapiID;		    /* MAPI PropID (not PropTag)		*/
    ULONG ulLinkID;		    /* unique link/backlink id		*/
    GUID propGuid;              /* Guid of this att for security        */
    GUID propSetGuid;           /* Guid of the property set of this     */
    OID_t OMObjClass;           /* class of OM object referenced	*/
    int OMsyntax;		        /* OM syntax				*/
    DWORD fSearchFlags;	        /* Defined below                        */
    char*    pszPdntIndex;      /* Index name if fSearchFlags fPDNTATTINDEX set */
    struct tagJET_INDEXID *pidxPdntIndex; /* PDNT index hint              */
    char*    pszIndex;          /* Index name if fSearchFlags fATTINDEX set  */
    struct tagJET_INDEXID *pidxIndex; /* index hint                       */
    char*    pszTupleIndex;     /* Index name if fSearchFlags fTUPLEINDEX set */
    struct tagJET_INDEXID *pidxTupleIndex; /* index hint */
    unsigned bSystemOnly:1;     /* system only attribute?		*/
    unsigned bExtendedChars:1;	/* Skip character set checking?         */
    unsigned bMemberOfPartialSet:1; /* Is member of the partial attribute set? */
    unsigned bDefunct:1;	    /* Attribute is already deleted? */
    unsigned bIsConstructed:1;	/* Attribute is a constructed att? */
    unsigned bIsNotReplicated:1;/* Attribute is never replicated?       */
    unsigned bIsBaseSchObj:1;   /* shipped in NT5 base schema */
    unsigned bIsOperational:1;  /* not returned on read unless requested */

    // The new schema reuse, defunct, and delete feature doesn't
    // allow reusing attributes used as the rdnattid of any class,
    // alive or defunct, or with FLAG_ATTR_IS_RDN set in systemFlags.
    // Attributes that fall into one of these catagories are termed
    // rdn attributes.
    //
    // A user sets FLAG_ATTR_IS_RDN to select which of several
    // defunct attrs can be used as the rdnattid of a new class.
    // The system will identify attributes once used as rdnattids
    // in purged classes by setting FLAG_ATTR_IS_RDN.
    //
    // The restrictions are in place because the NameMatched(), DNLock(),
    // and phantom upgrade code (list not exhaustive) depends on the
    // invariant relationship between ATT_RDN, ATT_FIXED_RDN_TYPE,
    // the rdnattid column, LDN-syntaxed DNs, and the RDNAttId in
    // the class definition. Breaking that dependency is beyond
    // the scope of the schema delete project.
    //
    // Defuncted rdn attributes are silently resurrected and so "own"
    // their OID, LDN, and MapiID. The tokenized OID, RdnExtId, is
    // read from the DIT, the now-active rdn attribute looked up 
    // in the active table, and the RdnIntId assigned from pAC->id.
    //
    // The RDN of a new object must match its object's RdnIntId.
    // Replicated objects and existing objects might not match
    // the rdnattid of their class because the class may be
    // superced by a class with a different rdnattid. The code
    // handles these cases by using the value in the
    // ATT_FIXED_RDN_TYPE column and *NOT* the rdnattid in the
    // class definition.
    //
    // bIsRdn is set if any class, live or defunct, claims this
    // attribute as an rdnattid or if FLAG_ATTR_IS_RDN is set
    // in systemFlags.
    //
    // bFlagIsRdn is set if the systemFlags FLAG_ATTR_IS_RDN is set.
    unsigned bIsRdn:1;
    unsigned bFlagIsRdn:1;

    // Once the new schema-reuse behavior is enabled, active attributes
    // may collide with each other because the schema objects replicate
    // from oldest change to youngest change. Meaning a new attribute
    // may replicate before the attribute it supercedes if the superceded
    // attribute is modified after being superceded (eg, it was renamed).
    //
    // The schema cache detects and treats the colliding attributes as
    // if they were defunct. If later replication does not clear up the
    // collision, the user can choose a winner and officially defunct
    // the loser.
    //
    // Colliding attributes are left in the schema cache until all
    // attributes and classes are loaded so that multiple collisions
    // can be detected. For performance, the collision types are
    // recorded in these bit fields to avoid duplicate effort by
    // ValidSchemaUpdate().
    unsigned bDupLDN:1;
    unsigned bDupOID:1;
    unsigned bDupPropGuid:1; // aka schemaIdGuid
    unsigned bDupMapiID:1;

    // Out-of-order replication or divergent schemas can create
    // inconsistent schemas. Normally, the affected attributes
    // are marked defunct (See above). But if the attributes
    // are used as rdnattids, then one of the attributes must
    // win the OID, LDN, and mapiID for the code to work. All
    // other things being equal, the largest objectGuid wins.
    GUID objectGuid;        // 