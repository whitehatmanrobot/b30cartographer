ties->DeviceWake = PowerDeviceD0; // don't rely on FDO mungeing in the right thing for r2 cards
        capabilities->D1Latency = 0;    // No latency - since we do nothing
        capabilities->D2Latency = 0;    //
        capabilities->D3Latency = 100;
    }
    //
    // Store these capabilities away..
    //

    RtlCopyMemory(&pdoExtension->DeviceCapabilities,
                  capabilities,
                  sizeof(DEVICE_CAPABILITIES));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\power.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    fdopower.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for SD controllers

Authors:

    Neil Sandlin (neilsa) Jan 1, 2002

Environment:

    Kernel mode only

Notes:

Revision History:


--*/

#include "pch.h"

//
// Internal References
//


NTSTATUS
SdbusFdoSetSystemPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

VOID
SdbusFdoSetSystemPowerStateCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID          Context
    );
    
NTSTATUS
SdbusFdoRequestDevicePowerState(
    IN PDEVICE_OBJECT Fdo,
    IN DEVICE_POWER_STATE DevicePowerState,
    IN PSDBUS_COMPLETION_ROUTINE  CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN WaitForRequestComplete    
    );

VOID
SdbusFdoSystemPowerDeviceIrpComplete(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );
   
NTSTATUS
SdbusFdoSetDevicePowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    );

NTSTATUS
SdbusFdoSetDevicePowerStateCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
SdbusFdoSetDevicePowerStateActivateComplete(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context,
    IN NTSTATUS status
    );
   
NTSTATUS
SdbusSetPdoDevicePowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

VOID
SdbusPdoInitializeFunctionComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );
   
NTSTATUS   
SdbusPdoCompletePowerIrp(
    IN PPDO_EXTENSION pdoExtension,
    IN PIRP Irp,
    IN NTSTATUS status
    );
   

//************************************************
//
//      FDO Routines
//
//************************************************



NTSTATUS
SdbusSetFdoPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

   Dispatches the IRP based on whether a system power state
   or device power state transition is requested

Arguments

   DeviceObject      - Pointer to the functional device object for the sd controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
    PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS           status;
    
    if (irpStack->Parameters.Power.Type == DevicePowerState) {
        status = SdbusFdoSetDevicePowerState(Fdo, Irp);
    } else if (irpStack->Parameters.Power.Type == SystemPowerState) {
        status = SdbusFdoSetSystemPowerState(Fdo, Irp);
   
    } else {
        status = Irp->IoStatus.Status;
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);      
    }
    return status;
}


NTSTATUS
SdbusFdoSetSystemPowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

   Handles system power state IRPs for the host controller. 

Arguments

   DeviceObject      - Pointer to the functional device object for the sd controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
    PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    SYSTEM_POWER_STATE newSystemState = irpStack->Parameters.Power.State.SystemState;
    DEVICE_POWER_STATE devicePowerState;
    NTSTATUS           status = STATUS_SUCCESS;
    BOOLEAN            waitForCompletion = TRUE;

    try{
    
        //
        // Validate new system state
        //   
        if (newSystemState >= POWER_SYSTEM_MAXIMUM) {
            status = STATUS_UNSUCCESSFUL;
            leave;
        }
        
        //
        // Switch to the appropriate device power state
        //
       
        devicePowerState = fdoExtension->DeviceCapabilities.DeviceState[newSystemState];
           
        if (devicePowerState == PowerDeviceUnspecified) {
            status = STATUS_UNSUCCESSFUL;
            leave;
        }
        
        //
        // Transitioned to system state
        //
        DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x transition S state %d => %d, sending D%d\n",
                                        Fdo, Irp, fdoExtension->SystemPowerState-1, newSystemState-1, devicePowerState-1));
       
        fdoExtension->SystemPowerState = newSystemState;

        //
        // Don't wait for completion if we are coming out of standby/hibernate
        //
        waitForCompletion = (newSystemState != PowerSystemWorking);

        if (!waitForCompletion) {
            IoMarkIrpPending(Irp);
        }            

        status = SdbusFdoRequestDevicePowerState(fdoExtension->DeviceObject,
                                                 devicePowerState,
                                                 SdbusFdoSetSystemPowerStateCompletion,
                                                 Irp,
                                                 waitForCompletion);
                                            
                                        
    } finally {
        if (!NT_SUCCESS(status)) {
            PoStartNextPowerIrp (Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
        }
        
        if (!waitForCompletion && (status != STATUS_PENDING)) {
            //
            // We've already marked the IRP pending, so we must return STATUS_PENDING
            // (ie fail it asynchronously)
            //
            status = STATUS_PENDING;
        }
    }
   
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x <-- %08x\n", Fdo, Irp, status));
                                    
    return status;
}


VOID
SdbusFdoSetSystemPowerStateCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID          Context
    )
/*++

Routine Description

   Handles system power state IRPs for the host controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the sd controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
    PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
    PIRP Irp = Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    
    PoSetPowerState (Fdo, SystemPowerState, irpStack->Parameters.Power.State);
    PoStartNextPowerIrp (Irp);
    IoSkipCurrentIrpStackLocation(Irp);
    PoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
SdbusFdoRequestDevicePowerState(
    IN PDEVICE_OBJECT Fdo,
    IN DEVICE_POWER_STATE DevicePowerState,
    IN PSDBUS_COMPLETION_ROUTINE  CompletionRoutine,
    IN PVOID Context,
    IN BOOLEAN WaitForRequestComplete    
    )
/*++

Routine Description

    This routine is called to request a new device power state for the FDO

Parameters

    DeviceObject        - Pointer to the Fdo for the SDBUS controller
    PowerState          - Power state requested 
    CompletionRoutine   - Routine to be called when finished
    Context             - Context passed in to the completion routine
   
Return Value

   Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    POWER_STATE powerState;
    NTSTATUS status;
    
    powerState.DeviceState = DevicePowerState;

    if (!WaitForRequestComplete) {
        //
        // Call the completion routine immediately
        //
        (*CompletionRoutine)(Fdo, Context);
        //
        // Request the device power irp to be completed later
        //
        PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
       
        status = STATUS_SUCCESS;
       
    } else {
        PSD_POWER_CONTEXT powerContext;
        
        powerContext = ExAllocatePool(NonPagedPool, sizeof(SD_POWER_CONTEXT));
        
        if (!powerContext) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        
        powerContext->CompletionRoutine = CompletionRoutine;
        powerContext->Context = Context;
    
        status = PoRequestPowerIrp(fdoExtension->DeviceObject,
                                   IRP_MN_SET_POWER,
                                   powerState,
                                   SdbusFdoSystemPowerDeviceIrpComplete,
                                   powerContext,
                                   NULL
                                   );
       
    }
    return status;
}    


VOID
SdbusFdoSystemPowerDeviceIrpComplete(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the SDBUS controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
    PSD_POWER_CONTEXT powerContext = Context;
    
//    DebugPrint((SDBUS_DEBUG_POWER, "fdo %08x irp %08x request for D%d complete, passing S irp down\n",
//                                     Fdo, Irp, PowerState.DeviceState-1));

    (*powerContext->CompletionRoutine)(Fdo, powerContext->Context);

    ExFreePool(powerContext);
}



NTSTATUS
SdbusFdoSetDevicePowerState(
    IN PDEVICE_OBJECT Fdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

   Handles device power state IRPs for the pccard controller.

Arguments

   DeviceObject      - Pointer to the functional device object for the sd controller
   Irp               - Pointer to the Irp for the power dispatch

Return value

   status

--*/
{
    NTSTATUS           status;
    PFDO_EXTENSION     fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEVICE_POWER_STATE devicePowerState = irpStack->Parameters.Power.State.DeviceState;

    status = IoAcquireRemoveLock(&fdoExtension->RemoveLock, "Sdbu");
    
    if (!NT_SUCCESS(status)) {
        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    if (devicePowerState != PowerDeviceD0) {

        (*(fdoExtension->FunctionBlock->DisableEvent))(fdoExtension, SDBUS_EVENT_ALL);    

        //
        // Turn card off
        //
        (*(fdoExtension->FunctionBlock->SetPower))(fdoExtension, FALSE, NULL);
    }        
    
    // anything to do here?
    
    // Perform any device-specific tasks that must be done before device power is removed,
    // such as closing the device, completing or flushing any pending I/O, disabling interrupts,
    // queuing subsequent incoming IRPs, and saving device context from which to restore or
    // reinitialize the device. 

    // The driver should not cause a long delay (for example, a delay that a user might find
    // unreasonable for this type of device) while handling the IRP. 

    // The driver should queue any incoming I/O requests until the device has returned to the working state. 

    
    
    
    

    IoMarkIrpPending(Irp);
    IoCopyCurrentIrpStackLocationToNext (Irp);
    //
    // Set our completion routine in the Irp..
    //
    IoSetCompletionRoutine(Irp,
                           SdbusFdoSetDevicePowerStateCompletion,
                           Fdo,
                           TRUE,
                           TRUE,
                           TRUE);

    PoCallDriver(fdoExtension->LowerDevice, Irp);
    
    
    return STATUS_PENDING;
}    



NTSTATUS
SdbusFdoSetDevicePowerStateCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    NTSTATUS status;
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEVICE_POWER_STATE devicePowerState = irpStack->Parameters.Power.State.DeviceState;
    PSD_WORK_PACKET workPacket;
    BOOLEAN cardInSlot;
    BOOLEAN completeDeviceIrp;

    try{

        if (devicePowerState != PowerDeviceD0) {
            completeDeviceIrp = TRUE;
            status = Irp->IoStatus.Status;
            leave;
        }
        
        //
        // powering up
        //
        (*(fdoExtension->FunctionBlock->InitController))(fdoExtension);
       
        (*(fdoExtension->FunctionBlock->EnableEvent))(fdoExtension, (SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL));
        
        SdbusActivateSocket(Fdo, SdbusFdoSetDevicePowerStateActivateComplete, Irp);
        
        completeDeviceIrp = FALSE;
        status = STATUS_MORE_PROCESSING_REQUIRED;

    } finally {
        if (completeDeviceIrp) {
            PoSetPowerState(Fdo, DevicePowerState, irpStack->Parameters.Power.State);
            PoStartNextPowerIrp (Irp);
            IoReleaseRemoveLock(&fdoExtension->RemoveLock, "Sdbu");
        }
    }        
    return status;        
}



VOID
SdbusFdoSetDevicePowerStateActivateComplete(
    IN PDEVICE_OBJECT Fdo,
    IN PVOID Context,
    IN NTSTATUS status
    )
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PIRP Irp = Context;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    
    PoSetPowerState(Fdo, DevicePowerState, irpStack->Parameters.Power.State);
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}    

    


//************************************************
//
//      PDO Routines
//
//************************************************


NTSTATUS
SdbusSetPdoPowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )

/*++

Routine Description

    Dispatches the IRP based on whether a system power state
    or device power state transition is requested

Arguments

    Pdo      - Pointer to the physical device object for the pc-card
    Irp      - Pointer to the Irp for the power dispatch

Return value

    status

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION     pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION     fdoExtension = pdoExtension->FdoExtension;
    NTSTATUS status;
   
    switch (irpStack->Parameters.Power.Type) {
    

    case DevicePowerState:
        status = SdbusSetPdoDevicePowerState(Pdo, Irp);
        break;
   

    case SystemPowerState:

        pdoExtension->SystemPowerState = irpStack->Parameters.Power.State.SystemState;
        status = SdbusPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
        break;
   

    default:
        status = SdbusPdoCompletePowerIrp(pdoExtension, Irp, Irp->IoStatus.Status);
    }      
   
    return status;
}



NTSTATUS
SdbusSetPdoDevicePowerState(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    )
/*++

Routine Description

    Handles the device power state transition for the given SD function.

Arguments

    Pdo      - Pointer to the physical device object for the SD function
    Irp      - Irp for the system state transition

Return value

    status

--*/
{
    PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
    PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEVICE_POWER_STATE  newDevicePowerState;
    POWER_STATE newPowerState;
    NTSTATUS status;
   
    newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;
   
    DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x transitioning D state %d => %d\n",
                                      Pdo, pdoExtension->DevicePowerState, newDevicePowerState));
   
    if (newDevicePowerState == pdoExtension->DevicePowerState) {
       status = SdbusPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
       return status;
    }
   
    if (newDevicePowerState == PowerDeviceD0) {
        PSD_WORK_PACKET workPacket;    
        //
        // Power up, initialize function
        //
        
        status = SdbusBuildWorkPacket(fdoExtension,
                                      SDWP_INITIALIZE_FUNCTION,
                                      SdbusPdoInitializeFunctionComplete,
                                      Irp,
                                      &workPacket);        
        if (!NT_SUCCESS(status)) {
            status = SdbusPdoCompletePowerIrp(pdoExtension, Irp, status);
        } else {

            IoMarkIrpPending(Irp);
            
            workPacket->PdoExtension = pdoExtension;
            
            SdbusQueueWorkPacket(fdoExtension, workPacket, WP_TYPE_SYSTEM);
            status = STATUS_PENDING;
        }            
        
    } else {
        // 
        // moving to a low power state
        //
        
        newPowerState.DeviceState = newDevicePowerState;
     
        PoSetPowerState(Pdo, DevicePowerState, newPowerState);
        pdoExtension->DevicePowerState = newDevicePowerState;
      
        status = SdbusPdoCompletePowerIrp(pdoExtension, Irp, STATUS_SUCCESS);
    }        
    return status;
}



VOID
SdbusPdoInitializeFunctionComplete(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PPDO_EXTENSION pdoExtension = WorkPacket->PdoExtension;
    PIRP Irp = WorkPacket->CompletionContext;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    DEVICE_POWER_STATE  newDevicePowerState;
    POWER_STATE newPowerState;
    
    newDevicePowerState = irpStack->Parameters.Power.State.DeviceState;
    newPowerState.DeviceState = newDevicePowerState;
    PoSetPowerState(pdoExtension->DeviceObject, DevicePowerState, newPowerState);
    
    pdoExtension->DevicePowerState = newDevicePowerState;
    
    SdbusPdoCompletePowerIrp(pdoExtension, Irp, status);
}


 
NTSTATUS   
SdbusPdoCompletePowerIrp(
    IN PPDO_EXTENSION pdoExtension,
    IN PIRP Irp,
    IN NTSTATUS status
    )
/*++

Routine Description

    Completion routine for the Power Irp directed to the PDO of the
    SD function. 


Arguments

    DeviceObject   -  Pointer to the PDO for the SD function
    Irp            -  Irp that needs to be completed

Return Value

    status

--*/   
{
    InterlockedDecrement(&pdoExtension->DeletionLock);
    Irp->IoStatus.Status = status;
    PoStartNextPowerIrp(Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\sdbus.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    sdbus.c

Abstract:

    This module contains the code that controls the SD slots.

Author:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode

Revision History :


--*/

#include "pch.h"

//
// Internal References
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
SdbusUnload(
    IN PDRIVER_OBJECT DriverObject
    );
   
#ifdef ALLOC_PRAGMA
    #pragma alloc_text(INIT,DriverEntry)
    #pragma alloc_text(PAGE, SdbusUnload)
    #pragma alloc_text(PAGE, SdbusOpenCloseDispatch)
    #pragma alloc_text(PAGE, SdbusCleanupDispatch)
    #pragma alloc_text(PAGE, SdbusFdoSystemControl)
    #pragma alloc_text(PAGE, SdbusPdoSystemControl)
#endif

PUNICODE_STRING  DriverRegistryPath;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    The entry point that the system point calls to initialize
    any driver.
    Since this is a plug'n'play driver, we should return after setting
    the entry points & initializing our dispatch table.
    Currently we also detect our own SDBUS controllers and report
    them - which should not be needed in the future when a root bus
    driver such as PCI or ISAPNP will locate the controllers for us.

Arguments:

    DriverObject - Pointer to object representing this driver

    RegistryPath - Pointer the the registry key for this driver
                   under \CurrentControlSet\Services

Return Value:


--*/

{
    NTSTATUS                  status = STATUS_SUCCESS;
    ULONG                     i;
   
    PAGED_CODE();
    
#if DBG
    SdbusInitializeDbgLog(ExAllocatePool(NonPagedPool, DBGLOGWIDTH * DBGLOGCOUNT));
    SdbusClearDbgLog();
#endif    
    
   
    DebugPrint((SDBUS_DEBUG_INFO,"Initializing Driver\n"));
   
    //
    // Load in common parameters from the registry
    //
    status = SdbusLoadGlobalRegistryValues();
    if (!NT_SUCCESS(status)) {
       return status;
    }
   
    //
    //
    // Set up the device driver entry points.
    //
   
    DriverObject->DriverExtension->AddDevice = SdbusAddDevice;
   
    DriverObject->DriverUnload = SdbusUnload;
    //
    //
    // Save our registry path
    DriverRegistryPath = RegistryPath;
   
    //
    // Initialize the event used by the delay execution
    // routine.
    //
    KeInitializeEvent (&SdbusDelayTimerEvent,
                       NotificationEvent,
                       FALSE);
   
    //
    // Initialize global lock
    //
    KeInitializeSpinLock(&SdbusGlobalLock);
    
    //
    // Init device dispatch table
    //
    SdbusInitDeviceDispatchTable(DriverObject);
    
    //
    // Ignore the status. Regardless of whether we found controllers or not
    // we need to stick around since we might get an AddDevice non-legacy
    // controllers
    //
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusOpenCloseDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Open or Close device routine

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    NTSTATUS status;
   
    PAGED_CODE();
   
    DebugPrint((SDBUS_DEBUG_INFO, "SDBUS: Open / close of Sdbus controller for IO \n"));
   
    status = STATUS_SUCCESS;
   
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}



NTSTATUS
SdbusCleanupDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Handles IRP_MJ_CLEANUP

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    NTSTATUS status;
   
    PAGED_CODE();
   
    DebugPrint((SDBUS_DEBUG_INFO, "SDBUS: Cleanup of Sdbus controller for IO \n"));
    status = STATUS_SUCCESS;
   
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, 0);
    return status;
}



NTSTATUS
SdbusFdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    
    PAGED_CODE();
   
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(fdoExtension->LowerDevice, Irp);
}



NTSTATUS
SdbusPdoSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    Handles IRP_MJ_SYSTEM_CONTROL

Arguments:

    DeviceObject - Pointer to the device object.
    Irp - Pointer to the IRP

Return Value:

    Status

--*/

{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    
    PAGED_CODE();
   
    //
    // Complete the irp 
    //
    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}



VOID
SdbusUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Description:

    Unloads the driver after cleaning up

Arguments:

    DriverObject -- THe device drivers object

Return Value:

    None

--*/

{
    PDEVICE_OBJECT    fdo, pdo, nextFdo, nextPdo;
    PFDO_EXTENSION    fdoExtension;
   
    PAGED_CODE();
   
    DebugPrint((SDBUS_DEBUG_INFO, "SdbusUnload Entered\n"));
    
    for (fdo = FdoList; fdo !=NULL ; fdo = nextFdo) {
   
       fdoExtension = fdo->DeviceExtension;
       MarkDeviceDeleted(fdoExtension);      
       
       if (fdoExtension->SdbusInterruptObject) {
          IoDisconnectInterrupt(fdoExtension->SdbusInterruptObject);
       }
   
       //
       // Clean up all the PDOs
       //
       for (pdo=fdoExtension->PdoList; pdo != NULL; pdo=nextPdo) {
          nextPdo = ((PPDO_EXTENSION) pdo->DeviceExtension)->NextPdoInFdoChain;
          MarkDeviceDeleted((PPDO_EXTENSION)pdo->DeviceExtension);
          SdbusCleanupPdo(pdo);
          IoDeleteDevice(pdo);
       }
   
   
       IoDetachDevice(fdoExtension->LowerDevice);
       nextFdo = fdoExtension->NextFdo;
       IoDeleteDevice(fdo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\toshiba.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    toshiba.h

Abstract:

    This module provides the definitions for the Toshiba host controller

Author(s):

    Neil Sandlin (neilsa)

Revisions:

--*/

#ifndef _SDBUS_TOSHIBA_H_
#define _SDBUS_TOSHIBA_H_

//
// Memory registers
//

#define TOMHC_COMMAND                       0x00
#define TOMHC_PORT_SEL                      0x02
#define TOMHC_ARGUMENT                      0x04
#define TOMHC_STOP_INTERNAL                 0x08
#define TOMHC_TRANSFER_SECTOR_COUNT         0x0a
#define TOMHC_RESPONSE                      0x0c
#define TOMHC_CARD_STATUS                   0x1c
#define TOMHC_BUFFER_CTL_AND_ERR            0x1e
#define TOMHC_INTERRUPT_MASK                0x20
#define TOMHC_CARD_CLOCK_CTL                0x24
#define TOMHC_CARD_TRANSFER_LENGTH          0x26
#define TOMHC_OPTIONS                       0x28
#define TOMHC_GENERAL_PORT                  0x2a
#define TOMHC_ERROR_STATUS                  0x2c
#define TOMHC_DATA_PORT                     0x30
#define TOMHC_TRANSACTION_CONTROL           0x34
                                           
#define TOMHC_SOFTWARE_RESET                0xe0
#define TOMHC_HOST_CORE_VERSION             0xe2
                                           
#define TOMHC_MONITOR                       0xe6

#define TOMHC_EXT_WRITE_PROTECT_STATUS      0xf6
#define TOMHC_EXT_CARD_DETECT_BY_CTCTZ      0xf8
#define TOMHC_EXT_CARD_DETECT_BY_DATA3      0xfa
#define TOMHC_EXT_CARD_DETECT_BY_CTCTZ_MASK 0xfc
#define TOMHC_EXT_CARD_DETECT_BY_DATA3_MASK 0xfe

//
// Bits defined in TOMHC_COMMAND (0x0)
//

#define TOMHC_CMD_MSSL      0x2000
#define TOMHC_CMD_RWDI      0x1000
#define TOMHC_CMD_NTDT      0x0800

#define TOMHC_CMD_RESP_NORM     0x0000
#define TOMHC_CMD_RESP_NONE     0x0300
#define TOMHC_CMD_RESP_R1456    0x0400
#define TOMHC_CMD_RESP_R1B      0x0500
#define TOMHC_CMD_RESP_R2       0x0600
#define TOMHC_CMD_RESP_R3       0x0700

#define TOMHC_CMD_ACMD          0x0040
#define TOMHC_CMD_AUTHENTICATE  0x0080

//
// Bits defined in TOMHC_CARD_STATUS (0x1c)
//

#define TO_EVT_RESPONSE                 0x00000001
#define TO_EVT_RW_END                   0x00000004
#define TO_EVT_CARD_REMOVAL             0x00000008
#define TO_EVT_CARD_INSERTION           0x00000010
#define TO_STS_CARD_PRESENT             0x00000020
#define TO_STS_WRITE_PROTECT            0x00000080

#define TOMHC_BCE_CMD_INDEX_ERROR       0x00010000
#define TOMHC_BCE_CRC_ERROR             0x00020000
#define TOMHC_BCE_END_BIT_ERROR         0x00040000
#define TOMHC_BCE_DATA_TIMEOUT          0x00080000
#define TOMHC_BCE_FIFO_OVERFLOW         0x00100000
#define TOMHC_BCE_FIFO_UNDERFLOW        0x00200000
#define TOMHC_BCE_CMD_TIMEOUT           0x00400000
#define TOMHC_BCE_MEMORY_IDLE           0x00800000

#define TO_EVT_BUFFER_FULL              0x01000000
#define TO_EVT_BUFFER_EMPTY             0x02000000

#define TOMHC_BCE_CMD_BUSY              0x40000000
#define TOMHC_BCE_ILLEGAL_ACCESS        0x80000000

//
// Bit defined in TOMHC_CARD_CLOCK_CTL
//

#define TO_CCC_CLOCK_ENABLE             0x0100
#define TO_CCC_CLOCK_DIVISOR_128        0x0020


//------------------------------------------------
// IO registers
//------------------------------------------------

#define TOIOHC_COMMAND                      0x100
#define TOIOHC_CARD_SLOT_SELECT             0x102
#define TOIOHC_ARGUMENT                     0x104
                                           
#define TOIOHC_TRANSFER_DATA_NUM_SET        0x10a
#define TOIOHC_RESPONSE_0                   0x10c
#define TOIOHC_RESPONSE_1                   0x10e
#define TOIOHC_RESPONSE_2                   0x110
#define TOIOHC_RESPONSE_3                   0x112
#define TOIOHC_RESPONSE_4                   0x114
#define TOIOHC_RESPONSE_5                   0x116
#define TOIOHC_RESPONSE_6                   0x118
#define TOIOHC_RESPONSE_7                   0x11a
#define TOIOHC_CARD_STATUS                  0x11c
#define TOIOHC_INTERRUPT_MASK               0x120
                                           
#define TOIOHC_TRANSFER_DATA_LEN_SELECT     0x126
#define TOIOHC_CARD_OPTION                  0x128
#define TOIOHC_GENERAL_PURPOSE              0x12a
#define TOIOHC_ERROR_DETAIL_1               0x12c
#define TOIOHC_ERROR_DETAIL_2               0x12e
#define TOIOHC_DATA_TRANSFER                0x130
                                           
#define TOIOHC_TRANSACTION_CONTROL          0x134
#define TOIOHC_CARD_INTERRUPT_CONTROL       0x136
#define TOIOHC_CLOCK_AND_WAIT_CONTROL       0x138
#define TOIOHC_HOST_INFORMATION             0x13a
#define TOIOHC_ERROR_CONTROL                0x13c
#define TOIOHC_LED_CONTROL                  0x13e
                                           
#define TOIOHC_SOFTWARE_RESET               0x1e0
#define TOIOHC_SDIO_CORE_REVISION           0x1e2
#define TOIOHC_TOSHIBA_CORE_REVISION        0x1f0


//
// Bits defined in TOIOHC_CLOCK_AND_WAIT_CONTROL
//

#define TOIO_CWCF_CLOCK_ENABLE  0x0100
#define TOIO_CWCF_CARD_WAIT     0x0001

//
// Bits defined in TOIOHC_CARD_INTERRUPT_CONTROL
//

#define TOIO_CICF_CARD_INTERRUPT 0x1000
#define TOIO_CICF_CARD_INTMASK   0x0100


//-----------------------------------------------
// PCI Config definitions
//-----------------------------------------------

#define TOCFG_CLOCK_CONTROL     0x40
#define TOCFG_POWER_CTL1        0x48
#define TOCFG_POWER_CTL2        0x49
#define TOCFG_POWER_CTL3        0x4A
#define TOCFG_CARD_DETECT_MODE  0x4C
#define TOCFG_SD_SLOT_REGISTER  0x50

#define TO_POWER_18             0x01
#define TO_POWER_33             0x02

#endif  // _SDBUS_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\toshiba.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    toshiba.c

Abstract:

    This module supplies functions that control the Toshiba SD controller.
    Based on the Toshiba "Pelican3"

Author(s):

    Neil Sandlin (neilsa) Jan 1 2002

Revisions:
--*/

#include "pch.h"
#include "toshiba.h"

//
// Internal References
//

VOID
ToshibaInitializeController(
    IN PFDO_EXTENSION FdoExtension
    );

VOID
ToshibaInitializeFunction(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    );

ULONG
ToshibaGetPendingEvents(
    IN PFDO_EXTENSION FdoExtension
    );

VOID
ToshibaEnableEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    );

VOID
ToshibaDisableEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    );

VOID
ToshibaAcknowledgeEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    );

NTSTATUS
ToshibaSetPower(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable,
    OUT PULONG pDelayTime
    );

NTSTATUS
ToshibaResetHost(
    IN PFDO_EXTENSION FdoExtension,
    IN UCHAR Phase,
    OUT PULONG pDelayTime
    );

VOID
ToshibaSetLED(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable
    );
    
VOID
ToshibaSetFunctionType(
    IN PFDO_EXTENSION FdoExtension,
    IN UCHAR FunctionType
    );

BOOLEAN
ToshibaDetectCardInSocket(
    IN PFDO_EXTENSION FdoExtension
    );

BOOLEAN
ToshibaIsWriteProtected(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ToshibaCheckStatus(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ToshibaSDCommand(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
ToshibaSDGetResponse(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket
    );

VOID
ToshibaStartBlockOperation(
    IN PFDO_EXTENSION FdoExtension
    );
    
VOID
ToshibaSetBlockParameters(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT SectorCount
    );
    
VOID
ToshibaEndBlockOperation(
    IN PFDO_EXTENSION FdoExtension
    );

VOID
ToshibaReadDataPort(
    IN PFDO_EXTENSION FdoExtension,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

VOID
ToshibaWriteDataPort(
    IN PFDO_EXTENSION FdoExtension,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

UCHAR
ToshibaReadRegisterUchar(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register
    );

USHORT
ToshibaReadRegisterUshort(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register
    );

VOID
ToshibaWriteRegisterUshort(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register,
    IN USHORT Data
    );

ULONG
ToshibaReadRegisterUlong(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register
    );

VOID
ToshibaWriteRegisterUlong(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register,
    IN ULONG Data
    );


//
// Internal Data
//


SD_FUNCTION_BLOCK ToshibaSupportFns = {
    ToshibaInitializeController,
    ToshibaInitializeFunction,
    ToshibaSetPower,
    ToshibaResetHost,
    ToshibaSetLED,
    ToshibaSetFunctionType,
    ToshibaDetectCardInSocket,
    ToshibaIsWriteProtected,
    ToshibaCheckStatus,
    ToshibaSDCommand,
    ToshibaSDGetResponse,
    ToshibaStartBlockOperation,
    ToshibaSetBlockParameters,
    ToshibaEndBlockOperation,
    ToshibaReadDataPort,
    ToshibaWriteDataPort,
    ToshibaEnableEvent,
    ToshibaDisableEvent,
    ToshibaGetPendingEvents,
    ToshibaAcknowledgeEvent
};



VOID
DebugDumpRegs(
    IN PFDO_EXTENSION FdoExtension
    )
{
#if DBG
    if (SdbusDebugMask & SDBUS_DEBUG_DUMP_REGS) {
        USHORT i,j;
        USHORT buffer[8];
        USHORT offset;
        USHORT count = 0;
        ULONG skip = 0x03000000;
        USHORT index;
        
        offset = 0;
        
        for (j = 0; j < 8; j++) {
            for (i = 0; i < 8; i++) {
                index = offset + (i*2);
            
                if (skip & (1 << (index/2))) {
                    buffer[i] = 0xFEFE;
                } else {                    
                    buffer[i] = ToshibaReadRegisterUshort(FdoExtension, index);
                }                    
                count++;
            }                
            DebugPrint((SDBUS_DEBUG_DUMP_REGS, "%04x: %04x %04x %04x %04x-%04x %04x %04x %04x\n", offset,
                                               buffer[0], buffer[1], buffer[2], buffer[3],
                                               buffer[4], buffer[5], buffer[6], buffer[7]));
            offset += 16;
            
            if (offset == 0x40) {
                offset = 0x100;
            }
        }                                               
    }
#endif
}

// ---------------------------------------------------------------
// External interface routines
// ---------------------------------------------------------------

VOID
ToshibaInitializeController(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    USHORT data;
    UCHAR configData;

    DebugPrint((SDBUS_DEBUG_DEVICE, "ToshibaInitializeController\n"));

    //
    // The Toshiba device appears to need this in order to function at all
    //
//    SetPciConfigSpace(FdoExtension, 0x40, &configData, 1);

    configData = 0x1F;  // Clock enable
    SetPciConfigSpace(FdoExtension, TOCFG_CLOCK_CONTROL, &configData, 1);
    configData = 0x08;  // Power control
    SetPciConfigSpace(FdoExtension, TOCFG_POWER_CTL1, &configData, 1);

    data = ToshibaReadRegisterUshort(FdoExtension, TOMHC_HOST_CORE_VERSION);
    DebugPrint((SDBUS_DEBUG_DEVICE, "TOMHC_HOST_CORE_VERSION - %x\n",
                                    data));

    ToshibaWriteRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK, 0xFFFFFFFF);
    ToshibaWriteRegisterUlong(FdoExtension, TOIOHC_INTERRUPT_MASK, 0xFFFFFFFF);

    //
    // start the controller off in memory mode
    //    
    ToshibaSetFunctionType(FdoExtension, SDBUS_FUNCTION_TYPE_MEMORY);
}


VOID
ToshibaInitializeFunction(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG sdRca = FdoExtension->RelativeAddr;

    DebugPrint((SDBUS_DEBUG_DEVICE, "ToshibaInitializeFunction(%d)\n", PdoExtension->Function));
    
    if (PdoExtension->Function == 8) {
        //
        // Memory function
        //
    } else {
    }        

}



NTSTATUS
ToshibaSetPower(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable,
    OUT OPTIONAL PULONG pDelayTime
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    UCHAR reg;
    UCHAR mask;
    UCHAR data;

    GetPciConfigSpace(FdoExtension, TOCFG_POWER_CTL2, &reg, 1);

    mask = 0x03;
    reg &= ~mask;

    if (Enable) {
        reg |= TO_POWER_33;
    }

    SetPciConfigSpace(FdoExtension, TOCFG_POWER_CTL2, &reg, 1);

    if (pDelayTime) {    
        *pDelayTime = 0x5dc;
    }        
    return STATUS_SUCCESS;
}



NTSTATUS
ToshibaResetHost(
    IN PFDO_EXTENSION FdoExtension,
    IN UCHAR Phase,
    OUT PULONG pDelayTime
    )
{
    NTSTATUS status;
    UCHAR data;

    switch(Phase) {
    
    case 0:
        data = 0x0B;
        SetPciConfigSpace(FdoExtension, TOCFG_CLOCK_CONTROL, &data, 1);
       
       
        ToshibaWriteRegisterUshort(FdoExtension, TOMHC_SOFTWARE_RESET, 0);
        *pDelayTime = 0x5dc;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 1:
        ToshibaWriteRegisterUshort(FdoExtension, TOMHC_SOFTWARE_RESET, 1);

        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_SOFTWARE_RESET, 0);
        *pDelayTime = 0x5dc;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 2:        
        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_SOFTWARE_RESET, 1);

        //  ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CLOCK_AND_WAIT_CONTROL,
        //   ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CLOCK_AND_WAIT_CONTROL) & 0xFCFC);
        //
        // turn off IOHC clock enable and card wait
        //
        ToshibaWriteRegisterUshort(FdoExtension,
                                   TOIOHC_CLOCK_AND_WAIT_CONTROL,
                                   ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CLOCK_AND_WAIT_CONTROL) &
                                    ~(TOIO_CWCF_CLOCK_ENABLE | TOIO_CWCF_CARD_WAIT));
       
        //    
        // turn off MHC clock enable
        //
        ToshibaWriteRegisterUshort(FdoExtension,
                                   TOMHC_CARD_CLOCK_CTL,
                                   ToshibaReadRegisterUshort(FdoExtension, TOMHC_CARD_CLOCK_CTL) &
                                    ~TO_CCC_CLOCK_ENABLE);
       
        //
        // Turn on MHC clock enable 
        //
        ToshibaWriteRegisterUshort(FdoExtension,
                                   TOMHC_CARD_CLOCK_CTL,
//                                   (TO_CCC_CLOCK_ENABLE | TO_CCC_CLOCK_DIVISOR_128));
                                   TO_CCC_CLOCK_ENABLE);
       
        //
        // Turn on IOHC clock enable and card wait
        //                                             
        ToshibaWriteRegisterUshort(FdoExtension,
                                   TOIOHC_CLOCK_AND_WAIT_CONTROL,
                                   (TOIO_CWCF_CLOCK_ENABLE | TOIO_CWCF_CARD_WAIT));
       
        data = 0x1F;
        SetPciConfigSpace(FdoExtension, TOCFG_CLOCK_CONTROL, &data, 1);

        *pDelayTime = 0x3e8;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 3:
        status = STATUS_SUCCESS;
        break;
    }

    return status;
}


VOID
ToshibaSetLED(
    IN PFDO_EXTENSION FdoExtension,
    IN BOOLEAN Enable
    )
{
}    
    

//
// Event handling functions
//

ULONG
EventMaskToHardwareMask(
    ULONG EventMask
    )
{
    ULONG hardwareMask = 0;
    
    if (EventMask & SDBUS_EVENT_INSERTION) {
        hardwareMask |= TO_EVT_CARD_INSERTION;
    }
    if (EventMask & SDBUS_EVENT_REMOVAL) {
        hardwareMask |= TO_EVT_CARD_REMOVAL;
    }
    if (EventMask & SDBUS_EVENT_CARD_RESPONSE) {
        hardwareMask |= TO_EVT_RESPONSE;
    }
    if (EventMask & SDBUS_EVENT_CARD_RW_END) {
        hardwareMask |= TO_EVT_RW_END;
    }
    if (EventMask & SDBUS_EVENT_BUFFER_EMPTY) {
        hardwareMask |= TO_EVT_BUFFER_EMPTY;
    }
    if (EventMask & SDBUS_EVENT_BUFFER_FULL) {
        hardwareMask |= TO_EVT_BUFFER_FULL;
    }
    
    return hardwareMask;
}    
        
ULONG
HardwareMaskToEventMask(
    ULONG HardwareMask
    )
{
    ULONG eventMask = 0;
    
    if (HardwareMask & TO_EVT_CARD_INSERTION) {
        eventMask |= SDBUS_EVENT_INSERTION;
    }
    if (HardwareMask & TO_EVT_CARD_REMOVAL) {
        eventMask |= SDBUS_EVENT_REMOVAL;
    }
    if (HardwareMask & TO_EVT_RESPONSE) {
        eventMask |= SDBUS_EVENT_CARD_RESPONSE;
    }
    if (HardwareMask & TO_EVT_RW_END) {
        eventMask |= SDBUS_EVENT_CARD_RW_END;
    }
    if (HardwareMask & TO_EVT_BUFFER_EMPTY) {
        eventMask |= SDBUS_EVENT_BUFFER_EMPTY;
    }
    if (HardwareMask & TO_EVT_BUFFER_FULL) {
        eventMask |= SDBUS_EVENT_BUFFER_FULL;
    }
    return eventMask;
}    
        


VOID
ToshibaEnableEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG data;
    ULONG cardEvents, ctlrEvents, ioCardEvent;
    ULONG mask;
 
    DebugPrint((SDBUS_DEBUG_EVENT, "EnableEvent: %08x\n", EventMask));
    FdoExtension->CurrentlyEnabledEvents |= EventMask;
    
    ctlrEvents = EventMask & (SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL);
    EventMask &= ~(SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL);
    
    ioCardEvent = EventMask & SDBUS_EVENT_CARD_INTERRUPT;
    EventMask &= ~SDBUS_EVENT_CARD_INTERRUPT;
    
    cardEvents = EventMask;
 
    mask = EventMaskToHardwareMask(cardEvents);
    if (mask) {
        data = ToshibaReadRegisterUlong(FdoExtension, FdoExtension->InterruptMaskReg);
        data &= ~mask;
        ToshibaWriteRegisterUlong(FdoExtension, FdoExtension->InterruptMaskReg, data);
    }
            
    mask = EventMaskToHardwareMask(ctlrEvents);
    if (mask) {
        data = ToshibaReadRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK);
        data &= ~mask;
        ToshibaWriteRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK, data);
    }
    
    if (ioCardEvent) {
        USHORT usData;
        
        usData = ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL);
        usData &= ~TOIO_CICF_CARD_INTMASK;
        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL, usData);
    }
}



VOID
ToshibaDisableEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG data;
    ULONG cardEvents, ctlrEvents, ioCardEvent;
    ULONG mask;

    FdoExtension->CurrentlyEnabledEvents &= ~EventMask;
    
    ctlrEvents = EventMask & (SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL);
    EventMask &= ~(SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL);
    
    ioCardEvent = EventMask & SDBUS_EVENT_CARD_INTERRUPT;
    EventMask &= ~SDBUS_EVENT_CARD_INTERRUPT;
    
    cardEvents = EventMask;
    
    mask = EventMaskToHardwareMask(cardEvents);
    if (mask) {
        data = ToshibaReadRegisterUlong(FdoExtension, FdoExtension->InterruptMaskReg);
        data |= mask;
        ToshibaWriteRegisterUlong(FdoExtension, FdoExtension->InterruptMaskReg, data);
    }

    mask = EventMaskToHardwareMask(ctlrEvents);
    if (mask) {
        data = ToshibaReadRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK);
        data |= mask;
        ToshibaWriteRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK, data);
    }
    
    if (ioCardEvent) {
        USHORT usData;
        
        usData = ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL);
        usData |= TOIO_CICF_CARD_INTMASK;
        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL, usData);
    }
}



ULONG
ToshibaGetPendingEvents(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG statusMask, eventMask;
    ULONG mhcEvent = 0, iohcEvent = 0, iocardEvent = 0;
    USHORT usData;

    //
    // The Pelican3 has interrupt status spread out everywhere. First try
    // the memory host controller
    //
    
    statusMask = ToshibaReadRegisterUlong(FdoExtension, TOMHC_CARD_STATUS);
    eventMask = ToshibaReadRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK);

    // turn off undefined bits
    statusMask &= 0x837F031D;
    // turn off bits that are masked
    statusMask &= ~eventMask;
    
    mhcEvent = HardwareMaskToEventMask(statusMask);
    
    if (statusMask && (mhcEvent == 0)) {
        // got an interrupt, but we don't know what type
        ASSERT(FALSE);
        
        eventMask |= statusMask;
        ToshibaWriteRegisterUlong(FdoExtension, TOMHC_INTERRUPT_MASK, eventMask);
    }
    
    //
    // Now try the IO host controller
    //
    if (!mhcEvent) {     
        statusMask = ToshibaReadRegisterUlong(FdoExtension, TOIOHC_CARD_STATUS);
        eventMask = ToshibaReadRegisterUlong(FdoExtension, TOIOHC_INTERRUPT_MASK);
        
        // turn off undefined bits
        statusMask &= 0xA37F0005;
        // turn off bits that are masked
        statusMask &= ~eventMask;
       
        iohcEvent = HardwareMaskToEventMask(statusMask);
        
        if (statusMask && (iohcEvent == 0)) {
            // got an interrupt, but we don't know what type
            ASSERT(FALSE);
            
            eventMask |= statusMask;
            ToshibaWriteRegisterUlong(FdoExtension, TOIOHC_INTERRUPT_MASK, eventMask);
        }
       
        //
        // get IO card interrupt
        //
        
        usData = ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL);
        
        if ((usData & TOIO_CICF_CARD_INTERRUPT) && ((usData & TOIO_CICF_CARD_INTMASK)==0)) {
        
            if (ToshibaDetectCardInSocket(FdoExtension)) {
                iocardEvent = SDBUS_EVENT_CARD_INTERRUPT;
            } else {
                //
                // the card is gone, this must be spurious
                //
                usData |= TOIO_CICF_CARD_INTMASK;
                ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL, usData);
            }
        }
    }        
    return mhcEvent | iohcEvent | iocardEvent;
}


VOID
ToshibaAcknowledgeEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventMask
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG hardwareMask = EventMaskToHardwareMask(EventMask);
    ULONG data;
    USHORT interruptMaskReg, cardStatusReg;

    if (EventMask & SDBUS_EVENT_CARD_INTERRUPT) {
        //
        // No need to clear io card IRQ, just reenable it
        //
        USHORT usData;
        
        usData = ToshibaReadRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL);
        usData &= ~TOIO_CICF_CARD_INTMASK;
        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CARD_INTERRUPT_CONTROL, usData);
        return;        
    }

    
    if (EventMask & (SDBUS_EVENT_INSERTION | SDBUS_EVENT_REMOVAL)) {
        interruptMaskReg = TOMHC_INTERRUPT_MASK;
        cardStatusReg    = TOMHC_CARD_STATUS;
    } else {
        interruptMaskReg = FdoExtension->InterruptMaskReg;
        cardStatusReg    = FdoExtension->CardStatusReg;
    }


    //
    // Clear event in status register
    //

    data = ToshibaReadRegisterUlong(FdoExtension, cardStatusReg);
    DebugPrint((SDBUS_DEBUG_EVENT, "AcknowledgeEvent: %08x - cardstatus %08x\n", EventMask, data));
    data &= ~hardwareMask;
    ToshibaWriteRegisterUlong(FdoExtension, cardStatusReg, data);

#if DBG
    data = ToshibaReadRegisterUlong(FdoExtension, cardStatusReg);
    DebugPrint((SDBUS_DEBUG_EVENT, "AcknowledgeEvent: new cardstatus %08x\n", data));
#endif

    //
    // Reenable event
    //
    
    FdoExtension->CurrentlyEnabledEvents |= EventMask;
    data = ToshibaReadRegisterUlong(FdoExtension, interruptMaskReg);
    data &= ~hardwareMask;
    ToshibaWriteRegisterUlong(FdoExtension, interruptMaskReg, data);
}




VOID
ToshibaSetFunctionType(
    IN PFDO_EXTENSION FdoExtension,
    IN UCHAR FunctionType
    )
{
    ULONG currentlyEnabledEvents = FdoExtension->CurrentlyEnabledEvents;

    if (FunctionType == FdoExtension->FunctionType) {
        return;
    }

    //
    // The pelican3 implements these event masks in two places, so disable and reenable them
    // 
    if (currentlyEnabledEvents) {
        ToshibaDisableEvent(FdoExtension, currentlyEnabledEvents);
    }
    
    switch(FunctionType) {

    case SDBUS_FUNCTION_TYPE_MEMORY:
        
        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_CLOCK_AND_WAIT_CONTROL, 0x100);

        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_TRANSACTION_CONTROL,
         ToshibaReadRegisterUshort(FdoExtension, TOIOHC_TRANSACTION_CONTROL) & 0xEFFF);

        FdoExtension->ArgumentReg   = TOMHC_ARGUMENT;
        FdoExtension->CmdReg        = TOMHC_COMMAND;
        FdoExtension->CardStatusReg = TOMHC_CARD_STATUS;
        FdoExtension->ResponseReg   = TOMHC_RESPONSE;
        FdoExtension->InterruptMaskReg = TOMHC_INTERRUPT_MASK;
        break;

    case SDBUS_FUNCTION_TYPE_IO:

        FdoExtension->ArgumentReg   = TOIOHC_ARGUMENT;
        FdoExtension->CmdReg        = TOIOHC_COMMAND;
        FdoExtension->CardStatusReg = TOIOHC_CARD_STATUS;
        FdoExtension->ResponseReg   = TOIOHC_RESPONSE_0;
        FdoExtension->InterruptMaskReg = TOIOHC_INTERRUPT_MASK;
        break;

    default:
        ASSERT(FALSE);
    }

    if (currentlyEnabledEvents) {
        ToshibaEnableEvent(FdoExtension, currentlyEnabledEvents);
    }

    FdoExtension->FunctionType = FunctionType;
}
    


BOOLEAN
ToshibaDetectCardInSocket(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    USHORT data;

    data = ToshibaReadRegisterUshort(FdoExtension, TOMHC_CARD_STATUS);
    return !((data & TO_STS_CARD_PRESENT) == 0);
}



BOOLEAN
ToshibaIsWriteProtected(
    IN PFDO_EXTENSION FdoExtension
    )
{
    USHORT data;

    data = ToshibaReadRegisterUshort(FdoExtension, TOMHC_CARD_STATUS);
    return ((data & TO_STS_WRITE_PROTECT) == 0);
}


#if 0

BOOLEAN
ToshibaClearStatus(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{

    //
    // This was stuff that was done before the first SEND... it is unclear how
    // much should be moved to the send
    //

    ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_TRANSACTION_CONTROL,
     ToshibaReadRegisterUshort(FdoExtension, TOIOHC_TRANSACTION_CONTROL) & 0xEFFF);

    ToshibaWriteRegisterUshort(FdoExtension, TOMHC_BUFFER_CTL_AND_ERR,
     ToshibaReadRegisterUshort(FdoExtension, TOMHC_BUFFER_CTL_AND_ERR) & 0x7D00);

    ToshibaWriteRegisterUshort(FdoExtension, TOMHC_CARD_STATUS,
     ToshibaReadRegisterUshort(FdoExtension, TOMHC_CARD_STATUS) & 0xFFFA);


    return TRUE;
}
#endif


NTSTATUS
ToshibaCheckStatus(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    ULONG cardStatus;
    ULONG errorStatus;
    NTSTATUS status = STATUS_SUCCESS;
    
    DebugDumpRegs(FdoExtension);

    cardStatus = ToshibaReadRegisterUlong(FdoExtension, FdoExtension->CardStatusReg);


    if (FdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) {
        errorStatus = cardStatus & (TOMHC_BCE_CMD_INDEX_ERROR |
                                    TOMHC_BCE_CRC_ERROR |
                                    TOMHC_BCE_END_BIT_ERROR |
                                    TOMHC_BCE_CMD_TIMEOUT |
                                    TOMHC_BCE_DATA_TIMEOUT |
                                    TOMHC_BCE_FIFO_OVERFLOW |
                                    TOMHC_BCE_FIFO_UNDERFLOW |
                                    TOMHC_BCE_ILLEGAL_ACCESS);
    } else {
        errorStatus = cardStatus & (TOMHC_BCE_CMD_INDEX_ERROR |
//                                    TOMHC_BCE_CRC_ERROR |        
                                    TOMHC_BCE_END_BIT_ERROR |
                                    TOMHC_BCE_CMD_TIMEOUT |
                                    TOMHC_BCE_DATA_TIMEOUT |
                                    TOMHC_BCE_FIFO_OVERFLOW |
                                    TOMHC_BCE_FIFO_UNDERFLOW |
                                    TOMHC_BCE_ILLEGAL_ACCESS);
    }                                    
                  
    if (errorStatus) {
        DebugPrint((SDBUS_DEBUG_WARNING, "CheckStatus detected Error! status = %08x\n", errorStatus));
        
        //ISSUE: NEED TO IMPLEMENT: I/O error handling
        ToshibaWriteRegisterUlong(FdoExtension, FdoExtension->CardStatusReg, cardStatus & ~errorStatus);
        
        
        // possibilities:
        // STATUS_PARITY_ERROR
        // STATUS_DEVICE_DATA_ERROR
        // STATUS_DEVICE_POWER_FAILURE
        // STATUS_DEVICE_NOT_READY
        // STATUS_IO_TIMEOUT
        // STATUS_INVALID_DEVICE_STATE
        // STATUS_IO_DEVICE_ERROR
        // STATUS_DEVICE_PROTOCOL_ERROR
        // STATUS_DEVICE_REMOVED
        // STATUS_POWER_STATE_INVALID
        status = STATUS_IO_DEVICE_ERROR;
    }        

    return status;
}



NTSTATUS
ToshibaSDCommand(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    USHORT cmdWord;
    ULONG Flags = WorkPacket->Flags;
    NTSTATUS status;

    ToshibaWriteRegisterUlong(FdoExtension, FdoExtension->ArgumentReg, WorkPacket->Argument);

    cmdWord = WorkPacket->Cmd;

    switch (WorkPacket->ResponseType) {
    case SDCMD_RESP_NONE:
        cmdWord |= TOMHC_CMD_RESP_NONE;
        break;

    case SDCMD_RESP_1:
    case SDCMD_RESP_5:
    case SDCMD_RESP_6:
        cmdWord |= 0x400;
        break;

    case SDCMD_RESP_2:
        cmdWord |= 0x600;
        break;

    case SDCMD_RESP_3:
    case SDCMD_RESP_4:
        cmdWord |= 0x700;
        break;

    case SDCMD_RESP_1B:
    case SDCMD_RESP_5B:
        cmdWord |= 0x500;
        break;

    default:
        ASSERT(FALSE);
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Add flags
    //

    if (Flags & SDCMDF_ACMD) {
        cmdWord |= TOMHC_CMD_ACMD;
    }

    if (Flags & SDCMDF_DATA) {
        cmdWord |= TOMHC_CMD_NTDT;
    }

    if (Flags & SDCMDF_MULTIBLOCK) {
        cmdWord |= TOMHC_CMD_MSSL;
    }

    if (Flags & SDCMDF_READ) {
        cmdWord |= TOMHC_CMD_RWDI;
    }

    //
    // Write Cmd and flags to command register
    //

    DebugPrint((SDBUS_DEBUG_DEVICE, "SEND: Cmd%d (0x%04x) arg = 0x%08x\n", WorkPacket->Cmd, cmdWord, WorkPacket->Argument));
    
    ToshibaWriteRegisterUshort(FdoExtension, FdoExtension->CmdReg, cmdWord);
    
    return STATUS_SUCCESS;
}



NTSTATUS
ToshibaSDGetResponse(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
//    ULONG cardStatus;
    UCHAR i;
    PUCHAR pRespPtr;
    NTSTATUS status = STATUS_SUCCESS;

    pRespPtr = (PUCHAR) WorkPacket->ResponseBuffer;
    for (i=0; i<SDBUS_RESPONSE_BUFFER_LENGTH; i++) {
        *pRespPtr++ = ToshibaReadRegisterUchar(FdoExtension, FdoExtension->ResponseReg+i);
    }

    return status;
}


    
VOID
ToshibaStartBlockOperation(
    IN PFDO_EXTENSION FdoExtension
    )
{
    ToshibaWriteRegisterUshort(FdoExtension, TOMHC_CARD_CLOCK_CTL, 0x100);
    ToshibaWriteRegisterUshort(FdoExtension, TOMHC_OPTIONS, 0x40e0);
}    
    
VOID
ToshibaSetBlockParameters(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Length
    )
{
    if (FdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) {
    
        ToshibaWriteRegisterUshort(FdoExtension, TOMHC_CARD_TRANSFER_LENGTH, 512);
        ToshibaWriteRegisterUshort(FdoExtension, TOMHC_STOP_INTERNAL, 0x100);
        ToshibaWriteRegisterUshort(FdoExtension, TOMHC_TRANSFER_SECTOR_COUNT, Length);
        
    } else {

        ToshibaWriteRegisterUshort(FdoExtension, TOIOHC_TRANSFER_DATA_LEN_SELECT, Length);
        
    }        
}    
    
VOID
ToshibaEndBlockOperation(
    IN PFDO_EXTENSION FdoExtension
    )
{
    ToshibaWriteRegisterUshort(FdoExtension, TOMHC_BUFFER_CTL_AND_ERR, 0);
}  

VOID
ToshibaReadDataPort(
    IN PFDO_EXTENSION FdoExtension,
    IN PUCHAR Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    The data port must be accessed maintaining DWORD alignment. So for example:
    
        IN DWORD 130
        IN DWORD 130
        
    is the same as

        IN USHORT 130
        IN USHORT 132
        IN UCHAR  130
        IN UCHAR  131
        IN UCHAR  132
        IN UCHAR  133        
     

Arguments:

Return value:

--*/
{
    USHORT i;
    ULONG dwordCount, wordCount, byteCount;
    PULONG ulBuffer = (PULONG) Buffer;
    PUSHORT usBuffer;
    USHORT port = (FdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) ? TOMHC_DATA_PORT :
                                                                               TOIOHC_DATA_TRANSFER;
    PUCHAR portAddress = ((PUCHAR)FdoExtension->HostRegisterBase + port);

    dwordCount = Length / 4;
    wordCount = (Length % 4) / 2;
    byteCount = (Length % 4) % 2;
    
    for (i = 0; i < dwordCount; i++) {
        READ_REGISTER_BUFFER_ULONG((PULONG) portAddress, ulBuffer, 1);
        ulBuffer++;
    }
    
    if (wordCount) {
        usBuffer = (PUSHORT) ulBuffer;
        
        ASSERT(wordCount == 1);
        
        READ_REGISTER_BUFFER_USHORT((PUSHORT) portAddress, usBuffer, 1);
        usBuffer++;
    }
    
    if (byteCount) {
        PUCHAR ucBuffer = (PUCHAR) usBuffer;
        
        ASSERT(byteCount == 1);

        // maintain byte order within ULONG dataport        
        portAddress++;
        portAddress++;
        
        READ_REGISTER_BUFFER_UCHAR((PUCHAR) portAddress, ucBuffer, 1);
    }        
}  

VOID
ToshibaWriteDataPort(
    IN PFDO_EXTENSION FdoExtension,
    IN PUCHAR Buffer,
    IN ULONG Length
    )
{
    USHORT i;
    ULONG dwordCount, wordCount, byteCount;
    PULONG ulBuffer = (PULONG) Buffer;
    PUSHORT usBuffer;
    USHORT port = (FdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) ? TOMHC_DATA_PORT :
                                                                               TOIOHC_DATA_TRANSFER;
    PUCHAR portAddress = ((PUCHAR)FdoExtension->HostRegisterBase + port);

    dwordCount = Length / 4;
    wordCount = (Length % 4) / 2;
    byteCount = (Length % 4) % 2;
    
    for (i = 0; i < dwordCount; i++) {
        WRITE_REGISTER_BUFFER_ULONG((PULONG) portAddress, ulBuffer, 1);
        ulBuffer++;
    }
    
    if (wordCount) {
        usBuffer = (PUSHORT) ulBuffer;
        
        ASSERT(wordCount == 1);
        
        WRITE_REGISTER_BUFFER_USHORT((PUSHORT) portAddress, usBuffer, 1);
        usBuffer++;
    }
    
    if (byteCount) {
        PUCHAR ucBuffer = (PUCHAR) usBuffer;
        
        ASSERT(byteCount == 1);

        // maintain byte order within ULONG dataport        
        portAddress++;
        portAddress++;
        
        WRITE_REGISTER_BUFFER_UCHAR((PUCHAR) portAddress, ucBuffer, 1);
    }        
}  



// ---------------------------------------------------------------
// Internal routines
// ---------------------------------------------------------------



UCHAR
ToshibaReadRegisterUchar(
   IN PFDO_EXTENSION FdoExtension,
   IN USHORT Register
   )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
    UCHAR byte;
    //
    // Sanity check in case controller wasn't started
    //
    if (FdoExtension->HostRegisterBase) {
        byte = READ_REGISTER_UCHAR((PUCHAR) ((PUCHAR)FdoExtension->HostRegisterBase + Register));
    } else {
        byte = 0xff;
    }
    return byte;
}



USHORT
ToshibaReadRegisterUshort(
   IN PFDO_EXTENSION FdoExtension,
   IN USHORT Register
   )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
    USHORT word;
    //
    // Sanity check in case controller wasn't started
    //
    if (FdoExtension->HostRegisterBase) {
        word = READ_REGISTER_USHORT((PUSHORT) ((PUCHAR)FdoExtension->HostRegisterBase + Register));
    } else {
        word = 0xff;
    }
    return word;
}


VOID
ToshibaWriteRegisterUshort(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register,
    IN USHORT Data
    )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
    //
    // Sanity check in case controller wasn't started
    //
    if (FdoExtension->HostRegisterBase) {
        WRITE_REGISTER_USHORT((PUSHORT) ((PUCHAR)FdoExtension->HostRegisterBase + Register), Data);
    }
}


ULONG
ToshibaReadRegisterUlong(
   IN PFDO_EXTENSION FdoExtension,
   IN USHORT Register
   )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
    ULONG dword;
    //
    // Sanity check in case controller wasn't started
    //
    if (FdoExtension->HostRegisterBase) {
        dword = READ_REGISTER_ULONG((PULONG) ((PUCHAR)FdoExtension->HostRegisterBase + Register));
    } else {
        dword = 0xff;
    }
    return dword;
}


VOID
ToshibaWriteRegisterUlong(
    IN PFDO_EXTENSION FdoExtension,
    IN USHORT Register,
    IN ULONG Data
    )

/*++

Routine Description:

    This routine will read a byte from the specified socket EXCA register

Arguments:

    Socket -- Pointer to the socket from which we should read
    Register -- The register to be read

Return Value:

   The data returned from the port.

--*/

{
    //
    // Sanity check in case controller wasn't started
    //
    if (FdoExtension->HostRegisterBase) {
        WRITE_REGISTER_ULONG((PULONG) ((PUCHAR)FdoExtension->HostRegisterBase + Register), Data);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\sdbus.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sdbus.h

Abstract:

Author:

    Neil Sandlin (neilsa) 1-Jan-2002

Revision History

--*/

#ifndef _SDBUS_H_
#define _SDBUS_H_


typedef enum _DEVICE_OBJECT_TYPE {
   FDO = 0,
   PDO
} DEVICE_OBJECT_TYPE;

//
// Type of the controller
//
typedef ULONG SDBUS_CONTROLLER_TYPE, *PSDBUS_CONTROLLER_TYPE;

struct _FDO_EXTENSION;
struct _PDO_EXTENSION;
struct _SD_WORK_PACKET;

//
// Io Worker States
//

typedef enum {
    WORKER_IDLE = 0,
    PACKET_PENDING,
    IN_PROCESS,
    WAITING_FOR_TIMER
} WORKER_STATE;

//
// socket enumeration states
//

typedef enum {
    SOCKET_EMPTY = 0,
    CARD_DETECTED,
    CARD_NEEDS_ENUMERATION,
    CARD_ACTIVE,
    CARD_LOGICALLY_REMOVED
} SOCKET_STATE;

//
// Define SynchronizeExecution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZATION_ROUTINE) (
    IN PKINTERRUPT           Interrupt,
    IN PKSYNCHRONIZE_ROUTINE Routine,
    IN PVOID                 SynchronizeContext
    );

//
// Completion routine called by various timed routines
//

typedef
VOID
(*PSDBUS_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );


typedef
VOID
(*PSDBUS_ACTIVATE_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context,
    IN NTSTATUS Status
    );



//
// SD_FUNCTION_BLOCK allows for a level of indirection, thereby allowing
// the top-level SDBUS code to do it's work without worrying about who's
// particular brand of SD controller it's addressing.
//


typedef struct _SD_FUNCTION_BLOCK {

    //
    // Function to initialize controller. This is done once after
    // the host controller is started, or powered on.
    //
    VOID
    (*InitController)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    //
    // Function to initialize SD function. This is done once after
    // the function is started.
    //
    VOID
    (*InitFunction)(
        IN struct _FDO_EXTENSION *FdoExtension, 
        IN struct _PDO_EXTENSION *PdoExtension
        );
        

    //
    // function to set power for a socket
    //

    NTSTATUS
    (*SetPower)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN BOOLEAN Enable,
        OUT PULONG pDelayTime        
        );

    //
    // function to set reset an SD card
    //

    NTSTATUS
    (*ResetHost)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN UCHAR Phase,
        OUT PULONG pDelayTime        
        );
        
        
    //
    // function to control the external LED
    //

    VOID
    (*SetLED)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN BOOLEAN Enable
        );
        
    //
    // Switch focus between IO function or memory function
    //
    VOID
    (*SetFunctionType)(
        IN struct _FDO_EXTENSION *FdoExtension,
        UCHAR FunctionType
        );

    //
    // Function to determine if a card is in the socket
    //

    BOOLEAN
    (*DetectCardInSocket)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    BOOLEAN
    (*IsWriteProtected)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    NTSTATUS
    (*CheckStatus)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    NTSTATUS
    (*SendSDCommand)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN struct _SD_WORK_PACKET *WorkPacket
        );

    NTSTATUS
    (*GetSDResponse)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN struct _SD_WORK_PACKET *WorkPacket
        );

    //
    // Interfaces for block memory operations
    //
    
    VOID
    (*StartBlockOperation)(
        IN struct _FDO_EXTENSION *FdoExtension
        );
    VOID
    (*SetBlockParameters)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN USHORT SectorCount
        );
    VOID
    (*EndBlockOperation)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    //
    // Copy a sector from the data port to a buffer
    //        

    VOID
    (*ReadDataPort)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN PUCHAR Buffer,
        IN ULONG Length
        );
        
    //
    // Copy a sector from a buffer to the data port
    //
            
    VOID
    (*WriteDataPort)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN PUCHAR Buffer,
        IN ULONG Length
        );

    //
    // Function to enable/disable status change interrupts
    //

    VOID
    (*EnableEvent)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN ULONG EventMask
        );

    VOID
    (*DisableEvent)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN ULONG EventMask
        );
    //
    // vendor-specific function to handle interrupts
    //

    ULONG
    (*GetPendingEvents)(
        IN struct _FDO_EXTENSION *FdoExtension
        );

    VOID
    (*AcknowledgeEvent)(
        IN struct _FDO_EXTENSION *FdoExtension,
        IN ULONG EventMask
        );
        
} SD_FUNCTION_BLOCK, *PSD_FUNCTION_BLOCK;


//
// Enumeration structures
//

#define MAX_MANFID_LENGTH 64
#define MAX_IDENT_LENGTH 64

typedef struct _SD_FUNCTION_DATA {
    struct _SD_FUNCTION_DATA       *Next;
    //
    // Function Number
    //
    UCHAR   Function;

    ULONG   CardPsn;
    ULONG   CsaSize;
    ULONG   Ocr;
    
    UCHAR   IoDeviceInterface;
    
} SD_FUNCTION_DATA, *PSD_FUNCTION_DATA;

typedef struct _SD_CARD_DATA {

    UCHAR   MfgText[MAX_MANFID_LENGTH];
    UCHAR   ProductText[MAX_IDENT_LENGTH];

    USHORT  MfgId;
    USHORT  MfgInfo;

    //
    // SD Io card parameters
    //
    UCHAR   CardCapabilities;

    //
    // SD Memory Card parameters
    //
    SD_CID  SdCid;
    SD_CSD  SdCsd;
    UCHAR   ProductName[6];

    //
    // array of per-function data
    //
    PSD_FUNCTION_DATA               FunctionData;
} SD_CARD_DATA, *PSD_CARD_DATA;


//
// Synchronization primitives
//

#define SDBUS_TEST_AND_SET(X)   (InterlockedCompareExchange(X, 1, 0) == 0)
#define SDBUS_TEST_AND_RESET(X) (InterlockedCompareExchange(X, 0, 1) == 1)

//
// Power 
//

typedef struct _SD_POWER_CONTEXT {
    PSDBUS_COMPLETION_ROUTINE  CompletionRoutine;
    PVOID Context;
} SD_POWER_CONTEXT, *PSD_POWER_CONTEXT;


typedef struct _SD_ACTIVATE_CONTEXT {
    PSDBUS_ACTIVATE_COMPLETION_ROUTINE  CompletionRoutine;
    PVOID Context;
} SD_ACTIVATE_CONTEXT, *PSD_ACTIVATE_CONTEXT;



//
// Functional Device Object's device extension information
//
// There is one device object for each SDBUS socket controller
// located in the system.  This contains the root pointers for
// each of the lists of information on this controller.
//

//
// Flags common to both fdoExtension and pdoExtension
//

#define SDBUS_DEVICE_STARTED            0x00000001
#define SDBUS_DEVICE_LOGICALLY_REMOVED  0x00000002
#define SDBUS_DEVICE_PHYSICALLY_REMOVED 0x00000004
#define SDBUS_DEVICE_WAKE_PENDING       0x00000010
#define SDBUS_DEVICE_DELETED            0x00000040

//
// Flags indicating controller state (fdoExtension)
//

#define SDBUS_HOST_REGISTER_BASE_MAPPED 0x00010000
#define SDBUS_FDO_CONTEXT_SAVED         0x00020000
#define SDBUS_FDO_OFFLINE               0x00040000
#define SDBUS_FDO_WAKE_BY_CD            0x00080000
#define SDBUS_FDO_WORK_ITEM_ACTIVE      0x00100000

//
// Flags indicating interrupt status
//

#define SDBUS_EVENT_INSERTION           0x00000001
#define SDBUS_EVENT_REMOVAL             0x00000002
#define SDBUS_EVENT_CARD_RESPONSE       0x00000004
#define SDBUS_EVENT_CARD_RW_END         0x00000008
#define SDBUS_EVENT_BUFFER_EMPTY        0x00000010
#define SDBUS_EVENT_BUFFER_FULL         0x00000020
#define SDBUS_EVENT_CARD_INTERRUPT      0x00000040

#define SDBUS_EVENT_ALL                 0xFFFFFFFF

//
// Flags indicating what type of function is currently being addressed
//
#define SDBUS_FUNCTION_TYPE_MEMORY      1
#define SDBUS_FUNCTION_TYPE_IO          2

//
// FDO Flags
//



#define SDBUS_FDO_EXTENSION_SIGNATURE       'FmcP'

//
// Device extension for the functional device object for sd controllers
//
typedef struct _FDO_EXTENSION {
    ULONG Signature;
    //
    // Pointer to the next sd controller's FDO in the central list
    // of all sd controller managed by this driver.
    // The head of the list is pointed to by the global variable FdoList
    //
    PDEVICE_OBJECT NextFdo;
    //
    // The PDO ejected by the parent bus driver for this sd controller
    //
    //
    PDEVICE_OBJECT Pdo;
    //
    // The immediately lower device attached beneath the sd controller's FDO.
    // This would be the same as the Pdo above, excepting in cases when there are
    // lower filter drivers for the sd controller - like the ACPI driver
    //
    PDEVICE_OBJECT LowerDevice;
    //
    // Pointer to the miniport-like
    //
    PSD_FUNCTION_BLOCK FunctionBlock;
    //
    // Various flags used to track the state of this
    // (flags prefixed by SDBUS_ above)
    //
    ULONG Flags;
    //
    // Type of the controller. We need to know this since this is
    // a monolithic driver. We can do controller specific stuff
    // based on the type if needed.
    //
    SDBUS_CONTROLLER_TYPE ControllerType;
    //
    // Index into the device dispatch table for vendor-specific
    // controller functions
    //
    ULONG DeviceDispatchIndex;

    PDEVICE_OBJECT DeviceObject;
    PDRIVER_OBJECT DriverObject;
    PUNICODE_STRING RegistryPath;
    //
    // Kernel objects to handle Io processing
    //
    KTIMER          WorkerTimer;
    KDPC            WorkerTimeoutDpc;
    //
    // This field holds the "current work packet" so that the timeout
    // dpc can pass it back to the worker routine
    //    
    struct _SD_WORK_PACKET *TimeoutPacket;
    KDPC            WorkerDpc;

    WORKER_STATE    WorkerState;    
    KSPIN_LOCK      WorkerSpinLock;

    LIST_ENTRY      SystemWorkPacketQueue;
    LIST_ENTRY      IoWorkPacketQueue;

    //
    // Io workitem to execute card functions at passive level
    //
    PIO_WORKITEM IoWorkItem;
    KEVENT CardInterruptEvent;
    KEVENT WorkItemExitEvent;

    //
    // Sequence number for  event logging
    //
    ULONG SequenceNumber;

    //
    // Pointer to the interrupt object - if we use interrupt based
    // card status change detection
    //
    PKINTERRUPT SdbusInterruptObject;

    //
    // IsrEventStatus is the hardware state. It is accessed only at DIRQL
    //
    ULONG IsrEventStatus;
    //
    // LatchedIsrEventStatus is pulled from IsrEventStatus synchronously. It is
    // used by the ISR's DPC to reflect new hardware events.
    //
    ULONG LatchedIsrEventStatus;
    //
    // WorkerEventEventStatus is the set of events pending to be reflected to 
    // the io worker engine
    //
    ULONG WorkerEventStatus;
    //
    // Keeps track of currently enabled events
    //
    ULONG CurrentlyEnabledEvents;    
    //
    // These are the card events we would like to see
    //
    ULONG CardEvents;
    //
    // Power management related stuff.
    //
    //
    // Current power states
    //
    SYSTEM_POWER_STATE SystemPowerState;
    DEVICE_POWER_STATE DevicePowerState;
    //
    // Indicates device busy
    //
    ULONG PowerStateInTransition;
    //
    // Indicates how many children (pc-cards) are pending on an
    // IRP_MN_WAIT_WAKE
    //
    ULONG ChildWaitWakeCount;
    //
    // Device capabilities as reported by our bus driver
    //
    DEVICE_CAPABILITIES DeviceCapabilities;
    //
    // Pending wait wake Irp
    //
    PIRP WaitWakeIrp;
    LONG WaitWakeState;

    //
    // PCI Bus interface standard
    // This contains interfaces to read/write from PCI config space
    // of the cardbus controller, among other stuff..
    //
    BUS_INTERFACE_STANDARD PciBusInterface;
    //
    // Configuration resources for the sd controller
    //
    CM_PARTIAL_RESOURCE_DESCRIPTOR Interrupt;
    CM_PARTIAL_RESOURCE_DESCRIPTOR TranslatedInterrupt;
    //
    // Type of bus we are on
    //
    INTERFACE_TYPE InterfaceType;
    //
    // SD Host register base
    //
    PVOID HostRegisterBase;
    //
    // Size of the register base that has been mapped
    //
    ULONG HostRegisterSize;
    
    // Memory = 1, IO = 2    
    UCHAR FunctionType;

    USHORT ArgumentReg;
    USHORT CmdReg;
    USHORT CardStatusReg;
    USHORT ResponseReg;
    USHORT InterruptMaskReg;

    //
    // These are used for debugging
    //
    USHORT cardStatus;
    USHORT errorStatus;

    //
    // card data which describes current card in the socket
    //
    PSD_CARD_DATA CardData;

    //
    // State of the current card in the slot
    //
    UCHAR numFunctions;
    BOOLEAN memFunction;
    ULONG RelativeAddr;
    SD_CID SdCid;
    SD_CSD SdCsd;
    

    //
    // Status of socket
    //    
    SOCKET_STATE SocketState;

    //
    // Head of the list of child pc-card PDO's hanging off this controller.
    // This is a linked list running through "NextPdoInFdoChain" in the pdo
    // extension. This list represents the devices that were enumerated by
    // the fdo.
    //
    PDEVICE_OBJECT PdoList;
    //
    // Keeps track of the number of PDOs which are actually
    // valid (not removed).  This is primarily used in
    // enumeration of the sd controller upon an IRP_MN_QUERY_DEVICE_RELATIONS
    //
    ULONG LivePdoCount;
    
    //
    // Remove lock for PnP synchronization
    //
    IO_REMOVE_LOCK RemoveLock;

} FDO_EXTENSION, *PFDO_EXTENSION;



//
// Physical Device Object's device extension information
//
// There is one device object for each function of an SD device
//

//
// Flags indicating card state
//

#define SDBUS_PDO_GENERATES_IRQ         0x00010000
#define SDBUS_PDO_DPC_CALLBACK          0x00020000
#define SDBUS_PDO_CALLBACK_REQUESTED    0x00040000
#define SDBUS_PDO_CALLBACK_IN_SERVICE   0x00080000


#define SDBUS_PDO_EXTENSION_SIGNATURE       'PmcP'

//
// The PDO extension represents an instance of a single SD function on an SD card
//

typedef struct _PDO_EXTENSION {
    ULONG                           Signature;

    PDEVICE_OBJECT                  DeviceObject;

    //
    // Link to next pdo in the Fdo's pdo chain
    //
    PDEVICE_OBJECT                  NextPdoInFdoChain;

    //
    // Parent extension
    //
    PFDO_EXTENSION                  FdoExtension;

    //
    // Flags 
    //
    ULONG                           Flags;

    //
    // Device ISR
    //
    PSDBUS_CALLBACK_ROUTINE         CallbackRoutine;
    PVOID                           CallbackRoutineContext;

    //
    // Power declarations
    //
    DEVICE_POWER_STATE              DevicePowerState;
    SYSTEM_POWER_STATE              SystemPowerState;
    //
    // Device Capabilities
    //
    DEVICE_CAPABILITIES             DeviceCapabilities;
    //
    // Pending wait wake irp
    //
    PIRP                            WaitWakeIrp;
    //
    // Deletion Mutex
    //
    ULONG                           DeletionLock;
    //
    // SD Function number
    //
    UCHAR                           Function;
    UCHAR                           FunctionType;
} PDO_EXTENSION, *PPDO_EXTENSION;


//
// Struct for Database of card bus controller information
// which maps the vendor id/device id to a CONTROLLER_TYPE
//

typedef struct _PCI_CONTROLLER_INFORMATION {
   USHORT          VendorID;
   USHORT          DeviceID;
   SDBUS_CONTROLLER_TYPE ControllerType;
} PCI_CONTROLLER_INFORMATION, *PPCI_CONTROLLER_INFORMATION;

//
// Struct for database of generic vendor class based on vendor ID
//

typedef struct _PCI_VENDOR_INFORMATION {
    USHORT               VendorID;
    PSD_FUNCTION_BLOCK   FunctionBlock;
} PCI_VENDOR_INFORMATION, *PPCI_VENDOR_INFORMATION;



// The pccard device id prefix
#define  SDBUS_ID_STRING        "SDBUS"

// String to be substituted if manufacturer name is not known
#define SDBUS_UNKNOWN_MANUFACTURER_STRING "UNKNOWN_MANUFACTURER"

// Max length of device id
#define SDBUS_MAXIMUM_DEVICE_ID_LENGTH   128

// Sdbus controller device name
#define  SDBUS_DEVICE_NAME      "\\Device\\Sdbus"

// Sdbus controller device symbolic link name
#define  SDBUS_LINK_NAME        "\\DosDevices\\Sdbus"


#define  SDBUS_ENABLE_DELAY                   10000

//
// problems observed on tecra 750 and satellite 300, with dec-chipset cb nic
//
#define SDBUS_DEFAULT_CONTROLLER_POWERUP_DELAY  250000   // 250 msec

//
// Amount of time to wait after an event interrupt was asserted on the controller
//
#define SDBUS_DEFAULT_EVENT_DPC_DELAY  400000   // 400 msec


//
// Macros for manipulating PDO's flags
//

#define IsDeviceFlagSet(deviceExtension, Flag)        (((deviceExtension)->Flags & (Flag))?TRUE:FALSE)
#define SetDeviceFlag(deviceExtension, Flag)          ((deviceExtension)->Flags |= (Flag))
#define ResetDeviceFlag(deviceExtension,Flag)         ((deviceExtension)->Flags &= ~(Flag))

#define IsFdoExtension(fdoExtension)           (fdoExtension->Signature == SDBUS_FDO_EXTENSION_SIGNATURE)
#define IsPdoExtension(pdoExtension)           (pdoExtension->Signature == SDBUS_PDO_EXTENSION_SIGNATURE)

#define MarkDeviceStarted(deviceExtension)     ((deviceExtension)->Flags |=  SDBUS_DEVICE_STARTED)
#define MarkDeviceNotStarted(deviceExtension)  ((deviceExtension)->Flags &= ~SDBUS_DEVICE_STARTED)
#define MarkDeviceDeleted(deviceExtension)     ((deviceExtension)->Flags |= SDBUS_DEVICE_DELETED);
#define MarkDevicePhysicallyRemoved(deviceExtension)                                                              \
                                                  ((deviceExtension)->Flags |=  SDBUS_DEVICE_PHYSICALLY_REMOVED)
#define MarkDevicePhysicallyInserted(deviceExtension)                                                           \
                                               ((deviceExtension)->Flags &= ~SDBUS_DEVICE_PHYSICALLY_REMOVED)
#define MarkDeviceLogicallyRemoved(deviceExtension)                                                              \
                                                  ((deviceExtension)->Flags |=  SDBUS_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceLogicallyInserted(deviceExtension)                                                           \
                                               ((deviceExtension)->Flags &= ~SDBUS_DEVICE_LOGICALLY_REMOVED)
#define MarkDeviceMultifunction(deviceExtension)                                                                  \
                                               ((deviceExtension)->Flags |= SDBUS_DEVICE_MULTIFUNCTION)


#define IsDeviceStarted(deviceExtension)       (((deviceExtension)->Flags & SDBUS_DEVICE_STARTED)?TRUE:FALSE)
#define IsDevicePhysicallyRemoved(deviceExtension) \
                                               (((deviceExtension)->Flags & SDBUS_DEVICE_PHYSICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceLogicallyRemoved(deviceExtension) \
                                               (((deviceExtension)->Flags & SDBUS_DEVICE_LOGICALLY_REMOVED)?TRUE:FALSE)
#define IsDeviceDeleted(deviceExtension)       (((deviceExtension)->Flags & SDBUS_DEVICE_DELETED)?TRUE:FALSE)
#define IsDeviceMultifunction(deviceExtension) (((deviceExtension)->Flags & SDBUS_DEVICE_MULTIFUNCTION)?TRUE:FALSE)


//
// NT definitions
//
#ifdef POOL_TAGGING
#undef ExAllocatePool
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'ubdS')
#endif

#define IO_RESOURCE_LIST_VERSION  0x1
#define IO_RESOURCE_LIST_REVISION 0x1

#define IRP_MN_PNP_MAXIMUM_FUNCTION IRP_MN_QUERY_LEGACY_BUS_INFORMATION

//
// Some useful macros
//
#define MIN(x,y) ((x) > (y) ? (y) : (x))        // return minimum among x & y
#define MAX(x,y) ((x) > (y) ? (x) : (y))        // return maximum among x & y

//
// BOOLEAN
// IS_PDO (IN PDEVICE_OBJECT DeviceObject);
//
#define IS_PDO(DeviceObject)      (((DeviceObject)->Flags & DO_BUS_ENUMERATED_DEVICE)?TRUE:FALSE)


//
// Io extension macro to just pass on the Irp to a lower driver
//

//
// VOID
// SdbusSkipCallLowerDriver(OUT NTSTATUS Status,
//                           IN  PDEVICE_OBJECT DeviceObject,
//                           IN  PIRP Irp);
//
#define SdbusSkipCallLowerDriver(Status, DeviceObject, Irp) {          \
               IoSkipCurrentIrpStackLocation(Irp);                      \
               Status = IoCallDriver(DeviceObject,Irp);}

//
// VOID
// SdbusCopyCallLowerDriver(OUT NTSTATUS Status,
//                           IN  PDEVICE_OBJECT DeviceObject,
//                           IN  PIRP Irp);
//
#define SdbusCopyCallLowerDriver(Status, DeviceObject, Irp) {          \
               IoCopyCurrentIrpStackLocationToNext(Irp);                \
               Status = IoCallDriver(DeviceObject,Irp); }

//  BOOLEAN
//  CompareGuid(
//      IN LPGUID guid1,
//      IN LPGUID guid2
//      );

#define CompareGuid(g1, g2)  ((g1) == (g2) ?TRUE:                       \
                                 RtlCompareMemory((g1),                 \
                                                  (g2),                 \
                                                  sizeof(GUID))         \
                                 == sizeof(GUID)                        \
                             )


//
// BOOLEAN
// ValidateController(IN FDO_EXTENSION fdoExtension)
//
// Bit of paranoia code. Make sure that the cardbus controller's registers
// are still visible.
//

#define ValidateController(fdoExtension) TRUE



//
// Structure which defines what global parameters are read from the registry
//

typedef struct _GLOBAL_REGISTRY_INFORMATION {
   PWSTR Name;
   PULONG pValue;
   ULONG Default;
} GLOBAL_REGISTRY_INFORMATION, *PGLOBAL_REGISTRY_INFORMATION;


#endif  //_SDBUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\sdcard.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sdcard.h

Abstract:

    This is the include file that defines all constants and types for
    interfacing to the SD bus driver.

// @@BEGIN_DDKSPLIT
Author:

    Neil Sandlin

Revision History:


// @@END_DDKSPLIT
--*/

#ifndef _SDCARDH_
#define _SDCARDH_


#define SDCMD_GO_IDLE_STATE             0x00        // 0
#define SDCMD_ALL_SEND_CID              0x02        // 2
#define SDCMD_SEND_RELATIVE_ADDR        0x03        // 3
#define SDCMD_SET_DSR                   0x04        // 4

#define SDCMD_IO_SEND_OP_COND           0x05        // 5

#define SDCMD_SELECT_CARD               0x07        // 7
#define SDCMD_SEND_CSD                  0x09        // 9
#define SDCMD_SEND_CID                  0x0A        // 10
#define SDCMD_STOP_TRANSMISSION         0x0C        // 12
#define SDCMD_SEND_STATUS               0x0D        // 13
#define SDCMD_GO_INACTIVE_STATE         0x0F        // 15

#define SDCMD_SET_BLOCKLEN              0x10        // 16
#define SDCMD_READ_BLOCK                0x11        // 17
#define SDCMD_READ_MULTIPLE_BLOCK       0x12        // 18
#define SDCMD_WRITE_BLOCK               0x18        // 24
#define SDCMD_WRITE_MULTIPLE_BLOCK      0x19        // 25
#define SDCMD_PROGRAM_CSD               0x1B        // 27

#define SDCMD_SET_WRITE_PROT            0x1C        // 28
#define SDCMD_CLR_WRITE_PROT            0x1D        // 29
#define SDCMD_SEND_WRITE_PROT           0x1E        // 30

#define SDCMD_ERASE_WR_BLK_START        0x20        // 32
#define SDCMD_ERASE_WR_BLK_END          0x21        // 33
#define SDCMD_ERASE                     0x26        // 38

#define SDCMD_LOCK_UNLOCK               0x2A        // 42

#define SDCMD_IO_RW_DIRECT              0x34        // 52
#define SDCMD_IO_RW_EXTENDED            0x35        // 53

#define SDCMD_APP_CMD                   0x37        // 55
#define SDCMD_GEN_CMD                   0x38        // 56

#define MAX_SD_CMD                      0x38+1

//
// Response values used by the bus driver
//

#define SDCMD_RESP_NONE 0
#define SDCMD_RESP_1    1
#define SDCMD_RESP_1B   0x1B
#define SDCMD_RESP_2    2
#define SDCMD_RESP_3    3
#define SDCMD_RESP_4    4
#define SDCMD_RESP_5    5
#define SDCMD_RESP_5B   0x5B
#define SDCMD_RESP_6    6

//
// Flag values for SD send cmd
//

#define SDCMDF_ACMD         0x0001
#define SDCMDF_DATA         0x0002
#define SDCMDF_READ         0x0004
#define SDCMDF_WRITE        0x0008
#define SDCMDF_MULTIBLOCK   0x0010

//
// Application specific commands for Memory
//

#define SDCMD_SET_BUS_WIDTH             0x06        // 6
#define SDCMD_SD_STATUS                 0x0D        // 13
#define SDCMD_SEND_NUM_WR_BLOCKS        0x16        // 22
#define SDCMD_SET_WR_BLK_ERASE_COUNT    0x17        // 23

#define SDCMD_SD_APP_OP_COND            0x29        // 41
#define SDCMD_SET_CLR_CARD_DETECT       0x2A        // 42
#define SDCMD_SEND_SCR                  0x33        // 51

#define MAX_SD_ACMD                     0x38+1


//
// SD Card Registers
//

typedef struct _SD_OCR {

    union {
        struct {
            ULONG Reserved1:4;
            ULONG VddVoltage:20;
            ULONG Reserved2:7;
            ULONG PowerUpBusy:1;
        } bits;

        ULONG AsULONG;
    } u;
} SD_OCR, *PSD_OCR;


#pragma pack(1)

typedef struct _SD_CID {
    struct {
        UCHAR ManufactureMonth:4;
        UCHAR ManufactureYearLow:4;
    } a;
    struct {
        UCHAR ManufactureYearHigh:4;
        UCHAR reserved:4;
    } b;
    ULONG SerialNumber;
    UCHAR Revision;
    UCHAR ProductName[5];
    USHORT OemId;
    UCHAR ManufacturerId;
} SD_CID, *PSD_CID;

typedef struct _SD_CSD {

    struct {
        UCHAR reserved:2;
        UCHAR FileFormat:2;
        UCHAR TempWriteProtect:1;
        UCHAR PermWriteProtect:1;
        UCHAR CopyFlag:1;
        UCHAR FileFormatGroup:1;
    } e;

    struct {
        USHORT reserved:5;
        USHORT PartialBlocksWrite:1;
        USHORT MaxWriteDataBlockLength:4;
        USHORT WriteSpeedFactor:3;
        USHORT reserved2:2;
        USHORT WriteProtectGroupEnable:1;
    } d;
    
    struct {
        ULONG WriteProtectGroupSize:7;
        ULONG EraseSectorSize:7;
        ULONG EraseSingleBlockEnable:1;
        ULONG DeviceSizeMultiplier:3;
        ULONG WriteCurrentVddMax:3;
        ULONG WriteCurrentVddMin:3;
        ULONG ReadCurrentVddMax:3;
        ULONG ReadCurrentVddMin:3;
        ULONG DeviceSizeLow:2;
    } c;
    
    struct {
        ULONG DeviceSizeHigh:10;
        ULONG reserved:2;
        ULONG DsrImplemented:1;
        ULONG ReadBlockMisalignment:1;
        ULONG WriteBlockMisalignment:1;
        ULONG PartialBlocksRead:1;
        ULONG MaxReadDataBlockLength:4;
        ULONG CardCommandClasses:12;
    } b;
    UCHAR MaxDataTransferRate;
    UCHAR DataReadAccessTime2;
    UCHAR DataReadAccessTime1;
    struct {
        UCHAR reserved:6;
        UCHAR Version:2;
    } a;
} SD_CSD, *PSD_CSD;


typedef struct _SD_RW_DIRECT_ARGUMENT {

    union {
        struct {
            ULONG Data:8;
            ULONG Reserved1:1;
            ULONG Address:17;
            ULONG Reserved2:1;
            ULONG ReadAfterWrite:1;
            ULONG Function:3;
            ULONG WriteToDevice:1;
        } bits;

        ULONG AsULONG;
    } u;

} SD_RW_DIRECT_ARGUMENT, *PSD_RW_DIRECT_ARGUMENT;

typedef struct _SD_RW_EXTENDED_ARGUMENT {

    union {
        struct {
            ULONG Count:9;
            ULONG Address:17;
            ULONG OpCode:1;
            ULONG BlockMode:1;
            ULONG Function:3;
            ULONG WriteToDevice:1;
        } bits;

        ULONG AsULONG;
    } u;

} SD_RW_EXTENDED_ARGUMENT, *PSD_RW_EXTENDED_ARGUMENT;

#pragma pack()    

//
// SDIO definitions
//

//
// SDIO CCCR layout by offset
//
#define SD_CCCR_REVISION        0
#define SD_CCCR_SPEC_REVISION   1
#define SD_CCCR_IO_ENABLE       2
#define SD_CCCR_IO_READY        3
#define SD_CCCR_INT_ENABLE      4
#define SD_CCCR_INT_PENDING     5
#define SD_CCCR_IO_ABORT        6
#define SD_CCCR_BUS_CONTROL     7
#define SD_CCCR_CAPABILITIES    8
#define SD_CCCR_CIS_POINTER     9
#define SD_CCCR_BUS_SUSPEND     0x0C
#define SD_CCCR_FUNC_SELECT     0x0D
#define SD_CCCR_EXEC_FLAGS      0x0E
#define SD_CCCR_READY_FLAGS     0x0F
#define SD_CCCR_FN0_BLOCK_SIZE  0x10



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\wake.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    wake.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_WAKE_H_
#define _SDBUS_WAKE_H_


//
// Wait-Wake states
//
typedef enum {
    WAKESTATE_DISARMED,
    WAKESTATE_WAITING,
    WAKESTATE_WAITING_CANCELLED,
    WAKESTATE_ARMED,
    WAKESTATE_ARMING_CANCELLED,
    WAKESTATE_COMPLETING
} WAKESTATE;


//
// Device Wake
//

NTSTATUS
SdbusFdoWaitWake(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    );
    
NTSTATUS
SdbusPdoWaitWake(
    IN  PDEVICE_OBJECT Pdo,
    IN  PIRP           Irp,
    OUT BOOLEAN       *CompleteIrp
    );

NTSTATUS
SdbusFdoArmForWake(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
SdbusFdoDisarmWake(
    IN PFDO_EXTENSION FdoExtension
    );

NTSTATUS
SdbusPdoWaitWakeCompletion(
    IN PDEVICE_OBJECT Pdo,
    IN PIRP           Irp,
    IN PPDO_EXTENSION PdoExtension
    );
    
NTSTATUS
SdbusFdoCheckForIdle(
    IN PFDO_EXTENSION FdoExtension
    );

    
#endif // _SDBUS_WAKE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\utils.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_UTILS_H_
#define _SDBUS_UTILS_H_


//
// Utility routines
//

NTSTATUS
SdbusIoCallDriverSynchronous(
    PDEVICE_OBJECT deviceObject,
    PIRP Irp
    );

VOID
SdbusWait(
    IN ULONG MilliSeconds
    );

VOID
SdbusLogError(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG ErrorCode,
    IN ULONG UniqueId,
    IN ULONG Argument
    );

VOID
SdbusLogErrorWithStrings(
    IN PFDO_EXTENSION DeviceExtension,
    IN ULONG             ErrorCode,
    IN ULONG             UniqueId,
    IN PUNICODE_STRING   String1,
    IN PUNICODE_STRING   String2
    );

BOOLEAN
SdbusReportControllerError(
    IN PFDO_EXTENSION FdoExtension,
    NTSTATUS ErrorCode
    );

ULONG
SdbusCountOnes(
    IN ULONG Data
    );

NTSTATUS
SdbusStringsToMultiString(
    IN PCSTR * Strings,
    IN ULONG Count,
    IN PUNICODE_STRING MultiString
    );



    
#endif // _SDBUS_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\wake.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    wake.c

Abstract:

    This module contains code to handle
    IRP_MJ_POWER dispatches for SD controllers

Authors:

    Neil Sandlin (neilsa) Jan 1, 2002

Environment:

    Kernel mode only

Notes:

Revision History:


--*/

#include "pch.h"

//
// Internal References
//


NTSTATUS
SdbusFdoWaitWakeIoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN PVOID          Context
    );
   
VOID
SdbusPdoWaitWakeCancelRoutine(
    IN PDEVICE_OBJECT Pdo,
    IN OUT PIRP Irp
    );

/**************************************************************************

   FDO ROUTINES

 **************************************************************************/
 

NTSTATUS
SdbusFdoWaitWake(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp
    )
/*++


Routine Description

   Handles WAIT_WAKE for the given sd controller

Arguments

   Pdo - Pointer to the functional device object for the sd controller
   Irp - The IRP_MN_WAIT_WAKE Irp

Return Value

   STATUS_PENDING    - Wait wake is pending
   STATUS_SUCCESS    - Wake is already asserted, wait wake IRP is completed
                       in this case
   Any other status  - Error
--*/

{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    WAKESTATE oldWakeState;
   
    //
    // Record the wait wake Irp..
    //
    fdoExtension->WaitWakeIrp = Irp;
    
    oldWakeState = InterlockedCompareExchange(&fdoExtension->WaitWakeState,
                                              WAKESTATE_ARMED, WAKESTATE_WAITING);
                                              
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %x irp %x WaitWake: prevState %s\n",
                                     Fdo, Irp, WAKESTATE_STRING(oldWakeState)));
                   
    if (oldWakeState == WAKESTATE_WAITING_CANCELLED) {
       fdoExtension->WaitWakeState = WAKESTATE_COMPLETING;
       
       Irp->IoStatus.Status = STATUS_CANCELLED;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return STATUS_CANCELLED;
    }
    
    IoMarkIrpPending(Irp);
   
    IoCopyCurrentIrpStackLocationToNext (Irp);
    //
    // Set our completion routine in the Irp..
    //
    IoSetCompletionRoutine(Irp,
                           SdbusFdoWaitWakeIoCompletion,
                           Fdo,
                           TRUE,
                           TRUE,
                           TRUE);
    //
    // now pass this down to the lower driver..
    //
    PoCallDriver(fdoExtension->LowerDevice, Irp);
    return STATUS_PENDING;
}


NTSTATUS
SdbusFdoWaitWakeIoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

   Completion routine for the IRP_MN_WAIT_WAKE request for this
   sd controller. This is called when the WAIT_WAKE IRP is
   completed by the lower driver (PCI/ACPI) indicating either that
   1. SD bus controller asserted wake
   2. WAIT_WAKE was cancelled
   3. Lower driver returned an error for some reason

Arguments:
   Fdo            -    Pointer to Functional device object for the sd controller
   Irp            -    Pointer to the IRP for the  power request (IRP_MN_WAIT_WAKE)
   Context        -    Not used

Return Value:

   STATUS_SUCCESS   - WAIT_WAKE was completed with success
   Any other status - Wake could be not be accomplished.

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT pdo;
    WAKESTATE oldWakeState;
   
    UNREFERENCED_PARAMETER(Context);
   
    oldWakeState = InterlockedExchange(&fdoExtension->WaitWakeState, WAKESTATE_COMPLETING);
   
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %x irp %x WW IoComp: prev=%s\n",
                                     Fdo, Irp, WAKESTATE_STRING(oldWakeState)));
                   
    if (oldWakeState != WAKESTATE_ARMED) {
       ASSERT(oldWakeState == WAKESTATE_ARMING_CANCELLED);
       return STATUS_MORE_PROCESSING_REQUIRED;
    }            
   
   
    if (IsDeviceFlagSet(fdoExtension, SDBUS_FDO_WAKE_BY_CD)) {
       POWER_STATE powerState;
   
       ResetDeviceFlag(fdoExtension, SDBUS_FDO_WAKE_BY_CD);
    
       PoStartNextPowerIrp(Irp);
       
       powerState.DeviceState = PowerDeviceD0;
       PoRequestPowerIrp(fdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
       
    } else {
       // NOTE:
       // At this point we do NOT know how to distinguish which function
       // in a multifunction device has asserted wake.
       // So we go through the entire list of PDOs hanging off this FDO
       // and complete all the outstanding WAIT_WAKE Irps for every PDO that
       // that's waiting. We leave it up to the FDO for the device to figure
       // if it asserted wake
       //
      
       for (pdo = fdoExtension->PdoList; pdo != NULL ; pdo = pdoExtension->NextPdoInFdoChain) {
      
          pdoExtension = pdo->DeviceExtension;
      
          if (IsDeviceLogicallyRemoved(pdoExtension) ||
              IsDevicePhysicallyRemoved(pdoExtension)) {
             //
             // This pdo is about to be removed ..
             // skip it
             //
             continue;
          }
      
          if (pdoExtension->WaitWakeIrp != NULL) {
             PIRP  finishedIrp;
             //
             // Ah.. this is a possible candidate to have asserted the wake
             //
             //
             // Make sure this IRP will not be completed again or cancelled
             //
             finishedIrp = pdoExtension->WaitWakeIrp;
             
             DebugPrint((SDBUS_DEBUG_POWER, "fdo %x WW IoComp: irp %08x for pdo %08x\n",
                                              Fdo, finishedIrp, pdo));
   
      
             IoSetCancelRoutine(finishedIrp, NULL);
             //
             // Propagate parent's status to child
             //
             PoStartNextPowerIrp(finishedIrp);
             finishedIrp->IoStatus.Status = Irp->IoStatus.Status;
             
             //
             // Since we didn't pass this IRP down, call our own completion routine
             //
//             SdbusPdoWaitWakeCompletion(pdo, finishedIrp, pdoExtension);
             IoCompleteRequest(finishedIrp, IO_NO_INCREMENT);
          }
       }
       PoStartNextPowerIrp(Irp);
    }
    
    return Irp->IoStatus.Status;
}



VOID
SdbusFdoWaitWakePoCompletion(
    IN PDEVICE_OBJECT Fdo,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description

   This routine is called on completion of a D irp generated by an S irp.

Parameters

   DeviceObject   -  Pointer to the Fdo for the SDBUS controller
   MinorFunction  -  Minor function of the IRP_MJ_POWER request
   PowerState     -  Power state requested 
   Context        -  Context passed in to the completion routine
   IoStatus       -  Pointer to the status block which will contain
                     the returned status
Return Value

   Status

--*/
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;
   
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %x irp %x WaitWakePoCompletion: prevState %s\n",
                                     Fdo, fdoExtension->WaitWakeIrp,
                                     WAKESTATE_STRING(fdoExtension->WaitWakeState)));
    
    ASSERT (fdoExtension->WaitWakeIrp);
    fdoExtension->WaitWakeIrp = NULL;
    ASSERT (fdoExtension->WaitWakeState == WAKESTATE_COMPLETING);
    fdoExtension->WaitWakeState = WAKESTATE_DISARMED;
}



NTSTATUS
SdbusFdoArmForWake(
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

   This routine is called to enable the controller for wake. It is called by the Pdo
   wake routines when a wake-enabled controller gets a wait-wake irp, and also by
   the idle routine to arm for wake from D3 by card insertion.

Arguments:

   FdoExtension - device extension of the controller

Return Value:

   status

--*/
{
    NTSTATUS status = STATUS_PENDING;
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    LONG oldWakeState;
    POWER_STATE powerState;
    
    oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                              WAKESTATE_WAITING, WAKESTATE_DISARMED);
   
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %x ArmForWake: prevState %s\n",
                                     FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));
    
    if ((oldWakeState == WAKESTATE_ARMED) || (oldWakeState == WAKESTATE_WAITING)) {
       return STATUS_SUCCESS;
    }
    if (oldWakeState != WAKESTATE_DISARMED) {
       return STATUS_UNSUCCESSFUL;
    }
   
    
    
    powerState.SystemState = FdoExtension->DeviceCapabilities.SystemWake;
    
    status = PoRequestPowerIrp(FdoExtension->DeviceObject,
                               IRP_MN_WAIT_WAKE, 
                               powerState,
                               SdbusFdoWaitWakePoCompletion,
                               NULL,
                               NULL);
    
    if (!NT_SUCCESS(status)) {
    
       FdoExtension->WaitWakeState = WAKESTATE_DISARMED;
        
       DebugPrint((SDBUS_DEBUG_POWER, "WaitWake to FDO, expecting STATUS_PENDING, got %08X\n", status));
    }
    
    return status;
}



NTSTATUS
SdbusFdoDisarmWake(
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

   This routine is called to disable the controller for wake.

Arguments:

   FdoExtension - device extension of the controller

Return Value:

   status

--*/
{
    WAKESTATE oldWakeState;
    
    oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                              WAKESTATE_WAITING_CANCELLED, WAKESTATE_WAITING);
                                              
    DebugPrint((SDBUS_DEBUG_POWER, "fdo %x DisarmWake: prevState %s\n",
                                     FdoExtension->DeviceObject, WAKESTATE_STRING(oldWakeState)));
    
    if (oldWakeState != WAKESTATE_WAITING) {                                             
   
       oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                 WAKESTATE_ARMING_CANCELLED, WAKESTATE_ARMED);
                                                 
       if (oldWakeState != WAKESTATE_ARMED) {
          return STATUS_UNSUCCESSFUL;
       }
    }
   
    if (oldWakeState == WAKESTATE_ARMED) {
       IoCancelIrp(FdoExtension->WaitWakeIrp);
   
       //
       // Now that we've cancelled the IRP, try to give back ownership
       // to the completion routine by restoring the WAKESTATE_ARMED state
       //
       oldWakeState = InterlockedCompareExchange(&FdoExtension->WaitWakeState,
                                                 WAKESTATE_ARMED, WAKESTATE_ARMING_CANCELLED);
   
       if (oldWakeState == WAKESTATE_COMPLETING) {
          //
          // We didn't give control back of the IRP in time, we we own it now
          //
          IoCompleteRequest(FdoExtension->WaitWakeIrp, IO_NO_INCREMENT);
       }
   
    }                                                
   
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusFdoCheckForIdle(
    IN PFDO_EXTENSION FdoExtension
    )
{
    POWER_STATE powerState;
    NTSTATUS status;
    
    //
    // Make sure all sockets are empty
    //
    
#if 0
    for (socket = FdoExtension->SocketList; socket != NULL; socket = socket->NextSocket) {
       if (IsCardInSocket(socket)) {
          return STATUS_UNSUCCESSFUL;
       }
    }
#endif   
   
    //
    // Arm for wakeup
    //
       
    status = SdbusFdoArmForWake(FdoExtension);
    
    if (!NT_SUCCESS(status)) {
       return status;
    }   
   
    SetDeviceFlag(FdoExtension, SDBUS_FDO_WAKE_BY_CD);
   
    powerState.DeviceState = PowerDeviceD3;
    PoRequestPowerIrp(FdoExtension->DeviceObject, IRP_MN_SET_POWER, powerState, NULL, NULL, NULL);
    
    return STATUS_SUCCESS;
}   
            
           
/**************************************************************************

   PDO ROUTINES

 **************************************************************************/
 


NTSTATUS
SdbusPdoWaitWake(
   IN  PDEVICE_OBJECT Pdo,
   IN  PIRP           Irp,
   OUT BOOLEAN       *CompleteIrp
   )
/*++


Routine Description

   Handles WAIT_WAKE for the given pc-card.

Arguments

   Pdo - Pointer to the device object for the pc-card
   Irp - The IRP_MN_WAIT_WAKE Irp
   CompleteIrp - This routine will set this to TRUE if the IRP should be
                 completed after this is called and FALSE if it should not be
                 touched

Return Value

   STATUS_PENDING    - Wait wake is pending
   STATUS_SUCCESS    - Wake is already asserted, wait wake IRP is completed
                       in this case
   Any other status  - Error
--*/
{

   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
   NTSTATUS       status;
   
   *CompleteIrp = FALSE;

   if ((pdoExtension->DeviceCapabilities.DeviceWake == PowerDeviceUnspecified) ||
       (pdoExtension->DeviceCapabilities.DeviceWake < pdoExtension->DevicePowerState)) {
      //
      // Either we don't support wake at all OR the current device power state
      // of the PC-Card doesn't support wake
      //
      return STATUS_INVALID_DEVICE_STATE;
   }

   if (pdoExtension->Flags & SDBUS_DEVICE_WAKE_PENDING) {
      //
      // A WAKE is already pending
      //
      return STATUS_DEVICE_BUSY;
   }

   status = SdbusFdoArmForWake(fdoExtension);
   
   if (!NT_SUCCESS(status)) {
      return status;
   }

   //for the time being, expect STATUS_PENDING from FdoArmForWake
   ASSERT(status == STATUS_PENDING);
   
   //
   // Parent has one (more) waiter..
   //
   InterlockedIncrement(&fdoExtension->ChildWaitWakeCount);
   //for testing, make sure there is only one waiter   
   ASSERT (fdoExtension->ChildWaitWakeCount == 1);
   

   pdoExtension->WaitWakeIrp = Irp;
   pdoExtension->Flags |= SDBUS_DEVICE_WAKE_PENDING;
   
   //
   // Set Ring enable/cstschg for the card here..
   //
//   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, TRUE);

   //
   // PCI currently does not do anything with a WW irp for a cardbus PDO. So we hack around
   // this here by not passing the irp down. Instead it is held pending here, so we can
   // set a cancel routine just like the read PDO driver would. If PCI were to do something
   // with the irp, we could code something like the following:
   //
   // if (IsCardBusCard(pdoExtension)) {
   //    IoSetCompletionRoutine(Irp, SdbusPdoWaitWakeCompletion, pdoExtension,TRUE,TRUE,TRUE);
   //    IoCopyCurrentIrpStackLocationToNext(Irp);
   //    status = IoCallDriver (pdoExtension->LowerDevice, Irp);
   //    ASSERT (status == STATUS_PENDING);
   //    return status;
   // }      
       

   IoMarkIrpPending(Irp);

   //
   // Allow IRP to be cancelled..
   //
   IoSetCancelRoutine(Irp, SdbusPdoWaitWakeCancelRoutine);

   IoSetCompletionRoutine(Irp,
                          SdbusPdoWaitWakeCompletion,
                          pdoExtension,
                          TRUE,
                          TRUE,
                          TRUE);

   return STATUS_PENDING;
}



NTSTATUS
SdbusPdoWaitWakeCompletion(
   IN PDEVICE_OBJECT Pdo,
   IN PIRP           Irp,
   IN PPDO_EXTENSION PdoExtension
   )
/*++

Routine Description

   Completion routine called when a pending IRP_MN_WAIT_WAKE Irp completes

Arguments

   Pdo  -   Pointer to the physical device object for the pc-card
   Irp  -   Pointer to the wait wake IRP
   PdoExtension - Pointer to the device extension for the Pdo

Return Value

   Status from the IRP

--*/
{
   PFDO_EXTENSION fdoExtension = PdoExtension->FdoExtension;
   
   DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCompletion\n", Pdo, Irp));

   ASSERT (PdoExtension->Flags & SDBUS_DEVICE_WAKE_PENDING);

   PdoExtension->Flags &= ~SDBUS_DEVICE_WAKE_PENDING;
   PdoExtension->WaitWakeIrp = NULL;
   //
   // Reset ring enable/cstschg
   //

//   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, PdoExtension, FALSE);
   
   ASSERT (fdoExtension->ChildWaitWakeCount > 0);
   InterlockedDecrement(&fdoExtension->ChildWaitWakeCount);
   //
   // Wake completed
   //
   
   InterlockedDecrement(&PdoExtension->DeletionLock);
   return Irp->IoStatus.Status;
}



VOID
SdbusPdoWaitWakeCancelRoutine(
   IN PDEVICE_OBJECT Pdo,
   IN OUT PIRP Irp
   )
/*++

Routine Description:

    Cancel an outstanding (pending) WAIT_WAKE Irp.
    Note: The CancelSpinLock is held on entry

Arguments:

    Pdo     -  Pointer to the physical device object for the pc-card
               on which the WAKE is pending
    Irp     -  Pointer to the WAIT_WAKE Irp to be cancelled

Return Value

    None

--*/
{
   PPDO_EXTENSION pdoExtension = Pdo->DeviceExtension;
   PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;

   DebugPrint((SDBUS_DEBUG_POWER, "pdo %08x irp %08x --> WaitWakeCancelRoutine\n", Pdo, Irp));

   IoReleaseCancelSpinLock(Irp->CancelIrql);

   if (pdoExtension->WaitWakeIrp == NULL) {
      //
      //  Wait wake already completed/cancelled
      //
      return;
   }

   pdoExtension->Flags &= ~SDBUS_DEVICE_WAKE_PENDING;
   pdoExtension->WaitWakeIrp = NULL;

   //
   // Reset ring enable, disabling wake..
   //
//   (*socket->SocketFnPtr->PCBEnableDisableWakeupEvent)(socket, pdoExtension, FALSE);
   
   //
   // Since this is cancelled, see if parent's wait wake
   // needs to be cancelled too.
   // First, decrement the number of child waiters..
   //
   
   ASSERT (fdoExtension->ChildWaitWakeCount > 0);
   if (InterlockedDecrement(&fdoExtension->ChildWaitWakeCount) == 0) {
      //
      // No more waiters.. cancel the parent's wake IRP
      //
      ASSERT(fdoExtension->WaitWakeIrp);
      
      if (fdoExtension->WaitWakeIrp) {
         IoCancelIrp(fdoExtension->WaitWakeIrp);
      }         
   }

   
   InterlockedDecrement(&pdoExtension->DeletionLock);
   //
   // Complete the IRP
   //
   Irp->IoStatus.Information = 0;

   //
   // Is this necessary?
   //
   PoStartNextPowerIrp(Irp);

   Irp->IoStatus.Status = STATUS_CANCELLED;
   IoCompleteRequest(Irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\utils.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    utils.c

Abstract:

    This module contains utility functions for the sd bus driver

Author:

    Neil Sandlin (neilsa) Jan 1 2002

Environment:

    Kernel mode

Revision History :

--*/

#include "pch.h"


//
// Internal References
//

NTSTATUS
SdbusAdapterIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PKEVENT pdoIoCompletedEvent
   );



#ifdef ALLOC_PRAGMA
    #pragma alloc_text(PAGE, SdbusGetInterface)
    #pragma alloc_text(PAGE, SdbusReportControllerError)
    #pragma alloc_text(PAGE, SdbusStringsToMultiString)
#endif

//
//
//



NTSTATUS
SdbusIoCallDriverSynchronous(
   PDEVICE_OBJECT deviceObject,
   PIRP Irp
   )
/*++

Routine Description

Arguments

Return Value

--*/
{
   NTSTATUS status;
   KEVENT event;

   KeInitializeEvent(&event, NotificationEvent, FALSE);

   IoCopyCurrentIrpStackLocationToNext(Irp);
   IoSetCompletionRoutine(
                         Irp,
                         SdbusAdapterIoCompletion,
                         &event,
                         TRUE,
                         TRUE,
                         TRUE
                         );

   status = IoCallDriver(deviceObject, Irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = Irp->IoStatus.Status;
   }

   return status;
}



NTSTATUS
SdbusAdapterIoCompletion(
   IN PDEVICE_OBJECT DeviceObject,
   IN PIRP Irp,
   IN PKEVENT pdoIoCompletedEvent
   )
/*++

Routine Description:

    Generic completion routine used by the driver

Arguments:

    DeviceObject
    Irp
    pdoIoCompletedEvent - this event will be signalled before return of this routine

Return value:

    Status

--*/
{
   KeSetEvent(pdoIoCompletedEvent, IO_NO_INCREMENT, FALSE);
   return STATUS_MORE_PROCESSING_REQUIRED;
}



NTSTATUS
SdbusGetInterface(
   IN PDEVICE_OBJECT DeviceObject,
   IN CONST GUID *pGuid,
   IN USHORT sizeofInterface,
   OUT PINTERFACE pInterface
   )
/*

Routine Description

   Gets the interface exported by a lower driver, typically the bus driver

Arguments

   Pdo - Pointer to physical device object for the device stack

Return Value

   Status

*/

{
   KEVENT event;
   PIRP   irp;
   NTSTATUS status;
   IO_STATUS_BLOCK statusBlock;
   PIO_STACK_LOCATION irpSp;

   PAGED_CODE();
   
   KeInitializeEvent (&event, NotificationEvent, FALSE);
   irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                       DeviceObject,
                                       NULL,
                                       0,
                                       0,
                                       &event,
                                       &statusBlock
                                     );

   irp->IoStatus.Status = STATUS_NOT_SUPPORTED ;
   irp->IoStatus.Information = 0;

   irpSp = IoGetNextIrpStackLocation(irp);

   irpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;

   irpSp->Parameters.QueryInterface.InterfaceType= pGuid;
   irpSp->Parameters.QueryInterface.Size = sizeofInterface;
   irpSp->Parameters.QueryInterface.Version = 1;
   irpSp->Parameters.QueryInterface.Interface = pInterface;

   status = IoCallDriver(DeviceObject, irp);

   if (status == STATUS_PENDING) {
      KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
      status = statusBlock.Status;
   }

   if (!NT_SUCCESS(status)) {
      DebugPrint((SDBUS_DEBUG_INFO, "GetInterface failed with status %x\n", status));
   }      
   return status;
}



VOID
SdbusWait(
   IN ULONG MicroSeconds
   )

/*++
Routine Description

    Waits for the specified interval before returning,
    by yielding execution.

Arguments

    MicroSeconds -  Amount of time to delay in microseconds

Return Value

    None. Must succeed.

--*/
{
   LARGE_INTEGER  dueTime;
   NTSTATUS status;


   if ((KeGetCurrentIrql() < DISPATCH_LEVEL) && (MicroSeconds > 50)) {
      DebugPrint((SDBUS_DEBUG_INFO, "SdbusWait: wait %d\n", MicroSeconds));
      //
      // Convert delay to 100-nanosecond intervals
      //
      dueTime.QuadPart = -((LONG) MicroSeconds*10);

      //
      // We wait for an event that'll never be set.
      //
      status = KeWaitForSingleObject(&SdbusDelayTimerEvent,
                                     Executive,
                                     KernelMode,
                                     FALSE,
                                     &dueTime);

      ASSERT(status == STATUS_TIMEOUT);
   } else {
      if (MicroSeconds > 50) {
          DebugPrint((SDBUS_DEBUG_INFO, "SdbusWait: STALL %d\n", MicroSeconds));
      }
      KeStallExecutionProcessor(MicroSeconds);
   }
}



ULONG
SdbusCountOnes(
   IN ULONG Data
   )
/*++

Routine Description:

   Counts the number of 1's in the binary representation of the supplied argument

Arguments:

   Data - supplied argument for which 1's need to be counted

Return value:

   Number of 1's in binary rep. of Data

--*/
{
   ULONG count=0;
   while (Data) {
      Data &= (Data-1);
      count++;
   }
   return count;
}


VOID
SdbusLogError(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG ErrorCode,
   IN ULONG UniqueId,
   IN ULONG Argument
   )

/*++

Routine Description:

    This function logs an error.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

--*/

{
   PIO_ERROR_LOG_PACKET packet;

   packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                           sizeof(IO_ERROR_LOG_PACKET) + sizeof(ULONG));

   if (packet) {
      packet->ErrorCode = ErrorCode;
      packet->SequenceNumber = DeviceExtension->SequenceNumber++;
      packet->MajorFunctionCode = 0;
      packet->RetryCount = (UCHAR) 0;
      packet->UniqueErrorValue = UniqueId;
      packet->FinalStatus = STATUS_SUCCESS;
      packet->DumpDataSize = sizeof(ULONG);
      packet->DumpData[0] = Argument;

      IoWriteErrorLogEntry(packet);
   }
}


VOID
SdbusLogErrorWithStrings(
   IN PFDO_EXTENSION DeviceExtension,
   IN ULONG             ErrorCode,
   IN ULONG             UniqueId,
   IN PUNICODE_STRING   String1,
   IN PUNICODE_STRING   String2
   )

/*++

Routine Description

    This function logs an error and includes the strings provided.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.
    ErrorCode - Supplies the error code for this error.
    UniqueId - Supplies the UniqueId for this error.
    String1 - The first string to be inserted.
    String2 - The second string to be inserted.

Return Value:

    None.

--*/

{
   ULONG                length;
   PCHAR                dumpData;
   PIO_ERROR_LOG_PACKET packet;

   length = String1->Length + sizeof(IO_ERROR_LOG_PACKET) + 4;

   if (String2) {
      length += String2->Length;
   }

   if (length > ERROR_LOG_MAXIMUM_SIZE) {

      //
      // Don't have code to truncate strings so don't log this.
      //

      return;
   }

   packet = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                           (UCHAR) length);
   if (packet) {
      packet->ErrorCode = ErrorCode;
      packet->SequenceNumber = DeviceExtension->SequenceNumber++;
      packet->MajorFunctionCode = 0;
      packet->RetryCount = (UCHAR) 0;
      packet->UniqueErrorValue = UniqueId;
      packet->FinalStatus = STATUS_SUCCESS;
      packet->NumberOfStrings = 1;
      packet->StringOffset = (USHORT) ((PUCHAR)&packet->DumpData[0] - (PUCHAR)packet);
      packet->DumpDataSize = (USHORT) (length - sizeof(IO_ERROR_LOG_PACKET));
      packet->DumpDataSize /= sizeof(ULONG);
      dumpData = (PUCHAR) &packet->DumpData[0];

      RtlCopyMemory(dumpData, String1->Buffer, String1->Length);

      dumpData += String1->Length;
      if (String2) {
         *dumpData++ = '\\';
         *dumpData++ = '\0';

         RtlCopyMemory(dumpData, String2->Buffer, String2->Length);
         dumpData += String2->Length;
      }
      *dumpData++ = '\0';
      *dumpData++ = '\0';

      IoWriteErrorLogEntry(packet);
   }

   return;
}



BOOLEAN
SdbusReportControllerError(
   IN PFDO_EXTENSION FdoExtension,
   NTSTATUS ErrorCode
   )
/*++
Routine Description

    Causes a pop-up dialog to appear indicating an error that
    we should tell the user about. The device description of the
    controller is also included in the text of the pop-up.

Arguments

    FdoExtension - Pointer to device extension for sd controller
    ErrorCode    - the ntstatus code for the error

Return Value

    TRUE    -   If a an error was queued
    FALSE   -   If it failed for some reason

--*/
{
    UNICODE_STRING unicodeString;
    PWSTR   deviceDesc = NULL;
    NTSTATUS status;
    ULONG   length = 0;
    BOOLEAN retVal;

    PAGED_CODE();

    //
    // Obtain the device description for the SD controller
    // that is used in the error pop-up. If one cannot be obtained,
    // still pop-up the error dialog, indicating the controller as unknown
    //

    // First, find out the length of the buffer required to obtain
    // device description for this SD controller
    //
    status = IoGetDeviceProperty(FdoExtension->Pdo,
                                 DevicePropertyDeviceDescription,
                                 0,
                                 NULL,
                                 &length
                                );
    ASSERT(!NT_SUCCESS(status));

    if (status == STATUS_BUFFER_TOO_SMALL) {
         deviceDesc = ExAllocatePool(PagedPool, length);
         if (deviceDesc != NULL) {
            status = IoGetDeviceProperty(FdoExtension->Pdo,
                                         DevicePropertyDeviceDescription,
                                         length,
                                         deviceDesc,
                                         &length);
            if (!NT_SUCCESS(status)) {
                ExFreePool(deviceDesc);
            }
         } else {
           status = STATUS_INSUFFICIENT_RESOURCES;
         }
    }

    if (!NT_SUCCESS(status)) {
        deviceDesc = L"[unknown]";
    }

    RtlInitUnicodeString(&unicodeString, deviceDesc);

    retVal =  IoRaiseInformationalHardError(
                                ErrorCode,
                                &unicodeString,
                                NULL);

    //
    // Note: successful status here indicates success of
    // IoGetDeviceProperty above. This would mean we still have an
    // allocated buffer.
    //
    if (NT_SUCCESS(status)) {
        ExFreePool(deviceDesc);
    }

    return retVal;
}



NTSTATUS
SdbusStringsToMultiString(
    IN PCSTR * Strings,
    IN ULONG Count,
    IN PUNICODE_STRING MultiString
    )
/*++

Routine Description:

   This routine formats a set of supplied strings into a multi string format, terminating
   it with  a double '\0' character

Arguments:

   Strings - Pointer to an array of strings
   Count -   Number of strings in the supplied array which are packed into the multi-string
   MultiString - Pointer to the Unicode string which packs the supplied string as a multi-string
                 terminated by double NULL

Return value:

   STATUS_SUCCESS
   STATUS_INSUFFICIENT_RESOURCES - Could not allocate memory for the multi-string


--*/
{
   ULONG i, multiStringLength=0;
   UNICODE_STRING tempMultiString;
   PCSTR * currentString;
   ANSI_STRING ansiString;
   NTSTATUS status;


   ASSERT (MultiString->Buffer == NULL);

   for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
      RtlInitAnsiString(&ansiString, *currentString);
      multiStringLength += RtlAnsiStringToUnicodeSize(&ansiString);

   }
   ASSERT(multiStringLength != 0);
   multiStringLength += sizeof(WCHAR);

   MultiString->Buffer = ExAllocatePool(PagedPool, multiStringLength);
   if (MultiString->Buffer == NULL) {

      return STATUS_INSUFFICIENT_RESOURCES;

   }

   MultiString->MaximumLength = (USHORT) multiStringLength;
   MultiString->Length = (USHORT) multiStringLength;

   tempMultiString = *MultiString;

   for (i = Count, currentString = Strings; i > 0;i--, currentString++) {
      RtlInitAnsiString(&ansiString, *currentString);
      status = RtlAnsiStringToUnicodeString(&tempMultiString,
                                            &ansiString,
                                            FALSE);
      ASSERT(NT_SUCCESS(status));
      ((PSTR) tempMultiString.Buffer) += tempMultiString.Length + sizeof(WCHAR);
   };

   //
   // Add one more NULL to terminate the multi string
   //
   RtlZeroMemory(tempMultiString.Buffer, sizeof(WCHAR));
   return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\workeng.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    io.c

Abstract:

    This module contains the work engine for all SD card operations

Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode

Revision History :


Notes:

    STATE DIAGRAM
    
    
           IDLE  <-------------------+
            |                        |
            |--new work              |--done
            |                        |
            v                        |
       PACKET_QUEUED <=========> IN_PROCESS <==========> WAITING_FOR_TIMER
            ^                                                    |
            |                                                    |--interrupt
            +----------------------------------------------------+
            
            

--*/

#include "pch.h"


VOID
SdbusWorker(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
SdbusSendCmdAsync(
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
SdbusQueueCardReset(
    IN PFDO_EXTENSION FdoExtension
    );

//
//
//    



VOID
SdbusQueueWorkPacket(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket,
    IN UCHAR WorkPacketType
    )
/*++

Routine Description:

    Queue a new work packet. 
    
Synchronization:

    If the worker state is anything but IDLE, then all we need to do here
    is queue the work packet onto the FdoExtension's queue. That is because
    the non-idle worker is responsible for launching a DPC for any new work
    coming in.
    
    If the worker is IDLE, we need to launch the DPC here.

Arguments:

    FdoExtension - Pointer to the device object extension for the host controller
    WorkPacket   - Pointer to the work packet

Return Value:

    none

--*/
{
    KIRQL       Irql;
    
    KeAcquireSpinLock(&FdoExtension->WorkerSpinLock, &Irql);

    if (FdoExtension->WorkerState != WORKER_IDLE) {
    
        switch(WorkPacketType){
        
        case WP_TYPE_SYSTEM:
            InsertTailList(&FdoExtension->SystemWorkPacketQueue, &WorkPacket->WorkPacketQueue);
            break;
        case WP_TYPE_SYSTEM_PRIORITY:
            InsertHeadList(&FdoExtension->SystemWorkPacketQueue, &WorkPacket->WorkPacketQueue);
            break;
        case WP_TYPE_IO:
            InsertTailList(&FdoExtension->IoWorkPacketQueue, &WorkPacket->WorkPacketQueue);
            break;
        default:
            ASSERT(FALSE);
        }
                    
    } else {
        FdoExtension->WorkerState = PACKET_PENDING;
        KeInsertQueueDpc(&FdoExtension->WorkerDpc, WorkPacket, NULL);
    }        

    KeReleaseSpinLock(&FdoExtension->WorkerSpinLock, Irql);
}    



PSD_WORK_PACKET
SdbusGetNextWorkPacket(
    IN PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Remove a work packet from a queue
    
Synchronization:

    No synchronization is needed here, it is assumed that the worker's spin lock
    is held when called.

Arguments:

    FdoExtension - Pointer to the device object extension for the host controller

Return Value:

    WorkPacket   - Pointer to the work packet

--*/
{
    PSD_WORK_PACKET workPacket = NULL;
    PLIST_ENTRY NextEntry;

    if (!IsListEmpty(&FdoExtension->SystemWorkPacketQueue)) {

       NextEntry = RemoveHeadList(&FdoExtension->SystemWorkPacketQueue);
       workPacket = CONTAINING_RECORD(NextEntry, SD_WORK_PACKET, WorkPacketQueue);

    } else if (!IsListEmpty(&FdoExtension->IoWorkPacketQueue)) {


       NextEntry = RemoveHeadList(&FdoExtension->IoWorkPacketQueue);
       workPacket = CONTAINING_RECORD(NextEntry, SD_WORK_PACKET, WorkPacketQueue);
    }
    return workPacket;
}    



VOID
SdbusWorkerTimeoutDpc(
    IN PKDPC          Dpc,
    IN PFDO_EXTENSION FdoExtension,
    IN PVOID          SystemContext1,
    IN PVOID          SystemContext2
    )
/*++

Routine Description:

    DPC entered when a timeout occurs
    
Synchronization:

    There is a potential race condition between the timer DPC and a hardware interrupt
    from the controller. If we enter here, and manage to get the spin lock for
    the worker thread, it means we "beat" the hardware interrupt, which will 
    call into SdbusPushWorkerEvent(). In that case, we can transition to IN_PROCESS,
    and start running the Worker.
    
    If we detect that the hardware interrupt has beat us to it, we need to exit.

Arguments:

    FdoExtension - Pointer to the device object extension for the host controller
    WorkPacket   - Pointer to the work packet

Return Value:


--*/
{
    BOOLEAN callWorker = FALSE;
    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusWorkerTimeoutDpc entered\n"));
    
    KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);
    
    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusWorkerTimeoutDpc has spinlock, WorkerState = %s\n",
                                   WORKER_STATE_STRING(FdoExtension->WorkerState)));
    if (FdoExtension->WorkerState == WAITING_FOR_TIMER) {

        callWorker = TRUE;
        FdoExtension->WorkerState = IN_PROCESS;
    }
    
    KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
    
    if (callWorker) {
        SdbusWorker(FdoExtension, FdoExtension->TimeoutPacket);
    }        
}   


VOID
SdbusWorkerDpc(
    IN PKDPC          Dpc,
    IN PFDO_EXTENSION FdoExtension,
    IN PVOID          SystemContext1,
    IN PVOID          SystemContext2
    )
/*++

Routine Description:

    This DPC is entered in one of three ways:
     1) When new work comes in, this is launched from SdbusQueueWorkPacket()
     2) When the IO worker detects new work, and pops a work packet from its queue
     3) When an interrupt has cancelled a timer, and is delivering an event
    
Synchronization:

    In all cases, if the worker state is PACKET_QUEUED, it means we "own" the Io
    worker, an can proceed to set it in process.

Arguments:

    FdoExtension - Pointer to the device object extension for the host controller
    WorkPacket   - Pointer to the work packet

Return Value:


--*/
{
    PSD_WORK_PACKET WorkPacket = SystemContext1;
    BOOLEAN callWorker = FALSE;

    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusWorkerDpc entered\n"));
    
    KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);
    
    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusWorkerDpc has spinlock, WorkerState = %s\n",
                                   WORKER_STATE_STRING(FdoExtension->WorkerState)));
    if (FdoExtension->WorkerState == PACKET_PENDING) {

        callWorker = TRUE;
        FdoExtension->WorkerState = IN_PROCESS;
    }
    
    KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
    
    if (callWorker) {
        if (!WorkPacket->PacketStarted) {
            //
            // This is the first entry to the worker for this packet. Do some 
            // initialization
            //
            
            //ISSUE: should call SetFunctionType here
            
            if (!WorkPacket->DisableCardEvents) {
                (*(FdoExtension->FunctionBlock->EnableEvent))(FdoExtension, FdoExtension->CardEvents);
            }
            
            WorkPacket->PacketStarted = TRUE;
        }            
    
        SdbusWorker(FdoExtension, WorkPacket);
    }        
}   



VOID
SdbusPushWorkerEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventStatus
    )
/*++

Routine Description:

    This routine is entered when a hardware interrupt has occurred. Here we need
    to cancel the timer, if set, and queue the DPC to start the worker.
    
Synchronization:


Arguments:

    FdoExtension - Pointer to the device object extension for the host controller
    EventStatus  - New event

Return Value:


--*/
{

    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusPushWorkerEvent entered, event=%08x\n", EventStatus));
    
    KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);
    
    DebugPrint((SDBUS_DEBUG_EVENT, "SdbusPushWorkerEvent has spinlock, WorkerState = %s\n",
                                   WORKER_STATE_STRING(FdoExtension->WorkerState)));
                                   
    FdoExtension->WorkerEventStatus |= EventStatus;
    
    if (FdoExtension->WorkerState == WAITING_FOR_TIMER) {
    
        FdoExtension->WorkerState = PACKET_PENDING;    
        KeCancelTimer(&FdoExtension->WorkerTimer);
        KeInsertQueueDpc(&FdoExtension->WorkerDpc, FdoExtension->TimeoutPacket, NULL);
        
    }        
    
    KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
}



BOOLEAN
SdbusHasRequiredEventFired(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET workPacket
    )
/*++

Routine Description:

    This routine checks for a hardware event, and rolls it into the workpacket.
    Note that this has the side effect of CLEARING the corresponding required event
    bits in the workpacket.

Arguments:

    FdoExtension - device extension for the SD host controller
    WorkPacket - defines the current SD operation in progress

Return Value:

    TRUE if the required event in the workpacket has fired

--*/
{
    BOOLEAN bRet = FALSE;

    //
    // pull the latest event status
    //

    KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);
    workPacket->EventStatus |= FdoExtension->WorkerEventStatus;
    FdoExtension->WorkerEventStatus = 0;
    KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
    
    if ((workPacket->EventStatus & workPacket->RequiredEvent) != 0) {
    
        bRet = TRUE;    
        workPacket->EventStatus &= ~workPacket->RequiredEvent;
    }
            
    return bRet;
}
        


VOID
SdbusWorker(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET workPacket
    )
/*++

Routine Description:

    IO worker - This is the main entry point for the IO engine. The purpose of this
    routine is to run the individual units of work defined by a single work packet, and
    provide waits between units.
    
    This routine runs at DPC level.

Arguments:

    FdoExtension - device extension for the SD host controller
    WorkPacket - defines the current SD operation in progress

Return Value:

    None

--*/
{
    NTSTATUS status;
    PIRP irp;
    static ULONG ioCount = 0;

    DebugPrint((SDBUS_DEBUG_WORKENG, "IOW: fdo %08x workpacket %08x\n",
                                      FdoExtension->DeviceObject, workPacket));

    try{    
        if (workPacket->RequiredEvent) {

            //
            // See if an event we are interested in has occurred
            //            
            if (!SdbusHasRequiredEventFired(FdoExtension, workPacket)) {
                //
                // We are waiting for an event, but it hasn't happened yet
                //
                if (workPacket->Retries == 0) {
       
                    DebugPrint((SDBUS_DEBUG_FAIL, "IOW: EventStatus %08x missing %08x, ABORTING!\n",
                                            workPacket->EventStatus, workPacket->RequiredEvent));
                    SdbusDumpDbgLog();
                    
                    status = STATUS_UNSUCCESSFUL;
                    ASSERT(NT_SUCCESS(status));
                    leave;
                }
       
                DebugPrint((SDBUS_DEBUG_WORKENG, "IOW: EventStatus %08x missing %08x, waiting...\n",
                                                  workPacket->EventStatus, workPacket->RequiredEvent));

                workPacket->Retries--;
                status = STATUS_MORE_PROCESSING_REQUIRED;
                leave;
            }

            //
            // Event has occurred, so fall through and begin processing
            //
        }        
       
        while(TRUE) {
            status = (*(FdoExtension->FunctionBlock->CheckStatus))(FdoExtension);
            
            if (!NT_SUCCESS(status)) {
            
                if (workPacket->FunctionPhaseOnError) {
                    //
                    // here the worker miniproc has specified it can handle errors.
                    // Just give it one shot to clean up and exit
                    //
                    ASSERT(workPacket->WorkerMiniProc);
                    
                    workPacket->FunctionPhase = workPacket->FunctionPhaseOnError;
                    status = (*(workPacket->WorkerMiniProc))(workPacket);
                    leave;
                    
                } else {

                    DebugPrint((SDBUS_DEBUG_FAIL, "IOW: ErrorStatus %08x, unhandled error!\n", status));
                    SdbusDumpDbgLog();
                    ASSERT(NT_SUCCESS(status));
//                    SdbusQueueCardReset(FdoExtension);
                    leave;
                }                    
            }
            
            DebugPrint((SDBUS_DEBUG_WORKENG, "fdo %08x sdwp %08x IOW start - func %s phase %d\n",
                        FdoExtension->DeviceObject, workPacket, WP_FUNC_STRING(workPacket->Function), workPacket->FunctionPhase));
       
            workPacket->DelayTime = 0;

            //
            // Call the mini proc
            //
            
            if (workPacket->ExecutingSDCommand) {
                status = SdbusSendCmdAsync(workPacket);
            } else {
            
                if (workPacket->WorkerMiniProc) {
                    status = (*(workPacket->WorkerMiniProc))(workPacket);
                } else {
                    //
                    // no miniproc - this must be the end of a synchronous command
                    //
                    status = STATUS_SUCCESS;
                }
            }                    
            
            DebugPrint((SDBUS_DEBUG_WORKENG, "fdo %08x IOW end - func %s ph%d st=%08x to=%08x\n",
                        FdoExtension->DeviceObject, WP_FUNC_STRING(workPacket->Function), workPacket->FunctionPhase, status, workPacket->DelayTime));
       
            if (workPacket->ExecutingSDCommand && NT_SUCCESS(status)) {
                //
                // We've reached the successful end of an individual SD command, so
                // iterate back to the normal MiniProc handler
                //
                workPacket->ExecutingSDCommand = FALSE;
                continue;
            }

            if (status != STATUS_MORE_PROCESSING_REQUIRED) {
                //
                // done for now
                //
                leave;
            }                
                
            if (workPacket->DelayTime) {
                //
                // miniproc requested a wait... check to see if event is also required
                //
                
                if (workPacket->RequiredEvent && SdbusHasRequiredEventFired(FdoExtension, workPacket)) {
                    //
                    // event fired as we were processing the command... pre-empt the
                    // delay and just continue back to the miniproc
                    //
                    continue;
                }        
                //
                // go off to do the delay
                //                
                leave;
            }
       
        }
    } finally {        
                        
        if (status == STATUS_MORE_PROCESSING_REQUIRED) {

            ASSERT(workPacket->DelayTime);
            ASSERT(FdoExtension->WorkerState == IN_PROCESS);

            //
            // At this point, we will now want to schedule a reentry. 
            // If the hardware routine has already passed new status, then just queue
            // a DPC immediately
            //
            
            KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);
            
            if ((FdoExtension->WorkerEventStatus) || (workPacket->DelayTime == 0)) {

                FdoExtension->WorkerState = PACKET_PENDING;
                KeInsertQueueDpc(&FdoExtension->WorkerDpc, workPacket, NULL);

            } else {
                LARGE_INTEGER  dueTime;
       
                FdoExtension->WorkerState = WAITING_FOR_TIMER;    
                FdoExtension->TimeoutPacket = workPacket;
                
                DebugPrint((SDBUS_DEBUG_WORKENG, "fdo %.08x sdwp %08x Worker Delay %08x\n",
                            FdoExtension->DeviceObject, workPacket, workPacket->DelayTime));
       
                dueTime.QuadPart = -((LONG) workPacket->DelayTime*10);
                KeSetTimer(&FdoExtension->WorkerTimer, dueTime, &FdoExtension->WorkerTimeoutDpc);
       
            }
            
            KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
            
        } else {
            PSD_WORK_PACKET chainedWorkPacket = workPacket->NextWorkPacketInChain;
        
            //
            // The worker is done with the current work packet. 
            //
            DebugPrint((SDBUS_DEBUG_WORKENG, "fdo %08x sdwp %08x Worker %s - COMPLETE %08x\n",
                       FdoExtension->DeviceObject, workPacket, WP_FUNC_STRING(workPacket->Function), status));
                       
            (*(FdoExtension->FunctionBlock->DisableEvent))(FdoExtension, FdoExtension->CardEvents);

            (*(workPacket->CompletionRoutine))(workPacket, status);

            // The workpacket should have been freed by the completion routine,
            // so at this point, the contents of workPacket are not reliable
            workPacket = NULL;

            KeAcquireSpinLockAtDpcLevel(&FdoExtension->WorkerSpinLock);

            if (chainedWorkPacket) {
                workPacket = chainedWorkPacket;
            } else {
                workPacket = SdbusGetNextWorkPacket(FdoExtension);
            }
            
            if (workPacket) {
                FdoExtension->WorkerState = PACKET_PENDING;
                KeInsertQueueDpc(&FdoExtension->WorkerDpc, workPacket, NULL);
            } else {
                FdoExtension->WorkerState = WORKER_IDLE;
            }                
            
            KeReleaseSpinLockFromDpcLevel(&FdoExtension->WorkerSpinLock);
           
           
        }
    }                    

}




NTSTATUS
SdbusSendCmdAsync(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

    This routine is the "worker within the worker" for the operation of the "MiniProc"
    worker routines. Take any miniproc, for example, the one that handles memory block
    operations for an SD storage card. That miniproc directs the high level sequence for
    reading/writing sectors to the card. For each individual SD command that makes up that
    sequence, the work engine will "drop out" of the miniproc, and come here to handle
    the task of completing that SD command.

Arguments:

    WorkPacket - defines the current SD operation in progress
    
Return value:

    status

--*/
{
    PFDO_EXTENSION FdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;

    DebugPrint((SDBUS_DEBUG_DEVICE, "SEND async: Phase(%d) Cmd%d (0x%02x) %08x\n",
                WorkPacket->CmdPhase, WorkPacket->Cmd, WorkPacket->Cmd, WorkPacket->Argument));
        
    switch(WorkPacket->CmdPhase) {
    case 0:

        WorkPacket->Retries = 5;
        WorkPacket->DelayTime = 1000;
        WorkPacket->RequiredEvent = SDBUS_EVENT_CARD_RESPONSE;

        (*(FdoExtension->FunctionBlock->SendSDCommand))(FdoExtension, WorkPacket);
        
        WorkPacket->CmdPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 1:

        WorkPacket->RequiredEvent = 0;
        status = (*(FdoExtension->FunctionBlock->GetSDResponse))(FdoExtension, WorkPacket);
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }

    DebugPrint((SDBUS_DEBUG_DEVICE, "SEND async: Exit Cmd%d (0x%02x) status %08x\n",
                WorkPacket->Cmd, WorkPacket->Cmd, status));

#if DBG
    if (NT_SUCCESS(status)) {
        DebugDumpSdResponse(WorkPacket->ResponseBuffer, WorkPacket->ResponseType);
    }        
#endif
    return status;
                
}




NTSTATUS
SdbusQueueCardReset(
    IN PFDO_EXTENSION FdoExtension
    )
{
    DebugPrint((SDBUS_DEBUG_FAIL, "IOW: QueueCardReset NOT IMPLEMENTED!\n"));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\workproc.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    workproc.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_WORKPROC_H_
#define _SDBUS_WORKPROC_H_


typedef enum {
    SDWP_READBLOCK,
    SDWP_WRITEBLOCK,
    SDWP_READIO,
    SDWP_WRITEIO,
    SDWP_READIO_EXTENDED,
    SDWP_WRITEIO_EXTENDED,
    SDWP_CARD_RESET,
    SDWP_PASSTHRU,
    SDWP_POWER_ON,
    SDWP_POWER_OFF,
    SDWP_IDENTIFY_IO_DEVICE,
    SDWP_IDENTIFY_MEMORY_DEVICE,
    SDWP_INITIALIZE_CARD,
    SDWP_INITIALIZE_FUNCTION
} WORKPROC_FUNCTION; 
 


//
// Work proc routines
//
    
NTSTATUS
SdbusBuildWorkPacket(
    PFDO_EXTENSION          FdoExtension,
    WORKPROC_FUNCTION       Function,
    PSDBUS_WORKPACKET_COMPLETION_ROUTINE CompletionRoutine,
    PVOID                   CompletionContext,
    PSD_WORK_PACKET         *ReturnedWorkPacket
    );


NTSTATUS
SdbusExecuteWorkSynchronous(
    WORKPROC_FUNCTION Function,
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    );
    
    
#endif // _SDBUS_WORKPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\workeng.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    workeng.h

Abstract:

    External definitions for intermodule functions.

Revision History:

--*/
#ifndef _SDBUS_WORKENG_H_
#define _SDBUS_WORKENG_H_


typedef
VOID
(*PSDBUS_WORKPACKET_COMPLETION_ROUTINE) (
    IN struct _SD_WORK_PACKET *WorkPacket,
    IN NTSTATUS status
    );

typedef
NTSTATUS
(*PSDBUS_WORKER_MINIPROC) (
    IN struct _SD_WORK_PACKET *WorkPacket
    );


//
// IO worker structures
//

typedef struct _SD_WORK_PACKET {

    //
    // Routine to call on completion of work packet
    //
    PSDBUS_WORKPACKET_COMPLETION_ROUTINE CompletionRoutine;
    PVOID CompletionContext;

    //
    // List entry chain for work packets
    //    
    LIST_ENTRY WorkPacketQueue;
    
    //
    // Next workpacket in chain for an atomic workpacket sequence
    //
    struct _SD_WORK_PACKET *NextWorkPacketInChain;
    NTSTATUS ChainedStatus;
    
    //
    // Function this work packet will perform
    //
    UCHAR Function;
    PSDBUS_WORKER_MINIPROC WorkerMiniProc;
    //
    // Current phase of function
    //
    UCHAR FunctionPhase;
    //
    // Engine will switch to this phase if non-zero when an
    // error is detected.
    //
    UCHAR FunctionPhaseOnError;
    //
    // Delay in usec till next operation in function
    //
    ULONG DelayTime;
    //
    // Indicates the type of event that just occurred
    //
    ULONG EventStatus;
    //
    // Indicates the type of event that indicates success for the
    // current operation.
    //
    ULONG RequiredEvent;
    //
    // Set to TRUE if no card events are expected for this packet
    //    
    BOOLEAN DisableCardEvents;
    //
    // Indicates whether initialization has been run for this packet
    //
    BOOLEAN PacketStarted;
    //
    // Used for timeouts during packet processing
    //
    UCHAR Retries;
    //
    // scratch value used during reset
    //
    ULONG TempCtl;
    ULONG ResetCount;
    //
    // block operation variables
    //
    ULONG BlockCount;
    ULONG LastBlockLength;
    ULONG CurrentBlockLength;
    //
    // result of operation
    //
    ULONG_PTR Information;
    //
    // FdoExtension target of operation
    //
    struct _FDO_EXTENSION *FdoExtension;
    //
    // PdoExtension target of operation
    //
    struct _PDO_EXTENSION *PdoExtension;
    //
    // parameters
    //
    union {

        struct {
            PUCHAR Buffer;
            ULONG Length;
            ULONGLONG ByteOffset;
        } ReadBlock;

        struct {
            PUCHAR Buffer;
            ULONG Length;
            ULONGLONG ByteOffset;
        } WriteBlock;

        struct {
            PUCHAR Buffer;
            ULONG Length;
            ULONG Offset;
        } ReadIo;

        struct {
            PUCHAR Buffer;
            ULONG Length;
            ULONG Offset;
            UCHAR Data;
        } WriteIo;

    } Parameters;

    //
    // Current SD Command
    //
    BOOLEAN ExecutingSDCommand;
    
    UCHAR Cmd;
    UCHAR CmdPhase;
    UCHAR ResponseType;
    ULONG Argument;
    ULONG Flags;
    //
    // response from card
    //
    ULONG ResponseBuffer[4];
#define SDBUS_RESPONSE_BUFFER_LENGTH 16

} SD_WORK_PACKET, *PSD_WORK_PACKET;

//
// Work packet type defines in which queue the workpacket will be placed
//
#define WP_TYPE_SYSTEM          1
#define WP_TYPE_SYSTEM_PRIORITY 2
#define WP_TYPE_IO              3

//
// Set Cmd Parameters for ASYNC calls
//

#define SET_CMD_PARAMETERS(xWorkPacket, xCmd, xResponseType, xArgument, xFlags) { \
                               xWorkPacket->ExecutingSDCommand = TRUE;          \
                               xWorkPacket->Cmd = xCmd;                         \
                               xWorkPacket->ResponseType = xResponseType;       \
                               xWorkPacket->Argument = xArgument;               \
                               xWorkPacket->Flags = xFlags;                     \
                               xWorkPacket->CmdPhase = 0;                       }


//
// Work Engine routines
//

VOID
SdbusQueueWorkPacket(
    IN PFDO_EXTENSION FdoExtension,
    IN PSD_WORK_PACKET WorkPacket,
    IN UCHAR WorkPacketType
    );

VOID
SdbusPushWorkerEvent(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG EventStatus
    );

VOID
SdbusWorkerTimeoutDpc(
    IN PKDPC          Dpc,
    IN PFDO_EXTENSION FdoExtension,
    IN PVOID          SystemContext1,
    IN PVOID          SystemContext2
    );

VOID
SdbusWorkerDpc(
    IN PKDPC          Dpc,
    IN PFDO_EXTENSION FdoExtension,
    IN PVOID          SystemContext1,
    IN PVOID          SystemContext2
    );

NTSTATUS
SdbusSendCmdSynchronous(
    IN PFDO_EXTENSION FdoExtension,
    UCHAR Cmd,
    UCHAR ResponseType,
    ULONG Argument,
    ULONG Flags,
    PVOID Response,
    ULONG ResponseLength
    );
    
#endif // _SDBUS_WORKENG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\busdrv\sd\sys\workproc.c ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    workproc.c

Abstract:

    This module contains the various "miniproc" handlers which are called
    by the worker engine. These routines handles the bulk of the real
    work for interfacing with an SD card.

Authors:

    Neil Sandlin (neilsa) 1-Jan-2002

Environment:

    Kernel mode only

Notes:

Revision History:

--*/

#include "pch.h"

//
// Internal References
//

VOID
SdbusSynchronousWorkCompletion(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    );

//
// MiniProc routines
//

NTSTATUS
SdbusSetPowerWorker(
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
SdbusIdentifyIoDeviceWorker(
    IN PSD_WORK_PACKET WorkPacket
    );
    
NTSTATUS
SdbusIdentifyMemoryFunctionWorker(
    IN PSD_WORK_PACKET WorkPacket
    );
    
NTSTATUS
SdbusInitializeCardWorker(
    IN PSD_WORK_PACKET WorkPacket
    );
    
NTSTATUS
SdbusInitializeFunctionWorker(
    IN PSD_WORK_PACKET WorkPacket
    );
    
NTSTATUS
SdbusMemoryBlockWorker(
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
SdbusIoDirectWorker(
    IN PSD_WORK_PACKET WorkPacket
    );

NTSTATUS
SdbusIoExtendedWorker(
    IN PSD_WORK_PACKET WorkPacket
    );



NTSTATUS
SdbusBuildWorkPacket(
    PFDO_EXTENSION FdoExtension,
    WORKPROC_FUNCTION Function,
    PSDBUS_WORKPACKET_COMPLETION_ROUTINE CompletionRoutine,
    PVOID CompletionContext,
    PSD_WORK_PACKET *ReturnedWorkPacket
    )
/*++

Routine Description

Arguments

Return Value

--*/
{
    PSD_WORK_PACKET workPacket;
    PSDBUS_WORKER_MINIPROC WorkerMiniProc;
    BOOLEAN disableCardEvents = FALSE;
    
    switch(Function) {
    case SDWP_READBLOCK:
    case SDWP_WRITEBLOCK:
        WorkerMiniProc = SdbusMemoryBlockWorker;
        break;
    
    case SDWP_READIO:
    case SDWP_WRITEIO:
        WorkerMiniProc = SdbusIoDirectWorker;
        break;    
    
    case SDWP_READIO_EXTENDED:
    case SDWP_WRITEIO_EXTENDED:
        WorkerMiniProc = SdbusIoExtendedWorker;
        break;    
    

    case SDWP_POWER_ON:
    case SDWP_POWER_OFF:
        WorkerMiniProc = SdbusSetPowerWorker;
        disableCardEvents = TRUE;
        break;


    case SDWP_IDENTIFY_IO_DEVICE:
        WorkerMiniProc = SdbusIdentifyIoDeviceWorker;    
        break;
        

    case SDWP_IDENTIFY_MEMORY_DEVICE:
        WorkerMiniProc = SdbusIdentifyMemoryFunctionWorker;    
        break;
    

    case SDWP_INITIALIZE_CARD:
        WorkerMiniProc = SdbusInitializeCardWorker;    
        break;

    
    case SDWP_INITIALIZE_FUNCTION:
        WorkerMiniProc = SdbusInitializeFunctionWorker;    
        break;
    

    case SDWP_PASSTHRU:
        WorkerMiniProc = NULL;
        break;
        
    default:
        ASSERT(FALSE);
    }
    
       
    workPacket = ExAllocatePool(NonPagedPool, sizeof(SD_WORK_PACKET));
    if (workPacket == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(workPacket, sizeof(SD_WORK_PACKET));
    
    workPacket->Function           = Function;
    workPacket->WorkerMiniProc     = WorkerMiniProc;
    workPacket->FdoExtension       = FdoExtension;
    workPacket->CompletionRoutine  = CompletionRoutine;
    workPacket->CompletionContext  = CompletionContext;
    workPacket->DisableCardEvents  = disableCardEvents;

    *ReturnedWorkPacket = workPacket;
    return STATUS_SUCCESS;
}



NTSTATUS
SdbusSendCmdSynchronous(
    IN PFDO_EXTENSION FdoExtension,
    UCHAR Cmd,
    UCHAR ResponseType,
    ULONG Argument,
    ULONG Flags,
    PULONG ResponseBuffer,
    ULONG ResponseLength
    )
/*++

Routine Description:

    This routine is called from the enumeration routine to execute IO operations
    in the same manner as the normal IO worker, only that we are running here
    at passive level.

Arguments:

    FdoExtension - device extension for the SD host controller

Return Value:

    None

--*/
{
    PSD_WORK_PACKET workPacket;
    NTSTATUS status = STATUS_MORE_PROCESSING_REQUIRED;
    KEVENT event;    

    DebugPrint((SDBUS_DEBUG_DEVICE, "SEND: Begin Cmd%d (0x%02x) %08x\n", Cmd, Cmd, Argument));
    
    status = SdbusBuildWorkPacket(FdoExtension,
                                  SDWP_PASSTHRU,
                                  SdbusSynchronousWorkCompletion,
                                  &event,
                                  &workPacket);

    if (!NT_SUCCESS(status)) {    
        return status;
    }
    
    workPacket->ExecutingSDCommand = TRUE;
    workPacket->Cmd                = Cmd;
    workPacket->ResponseType       = ResponseType;
    workPacket->Argument           = Argument;
    workPacket->Flags              = Flags;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);
    
    SdbusQueueWorkPacket(FdoExtension, workPacket, WP_TYPE_IO);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = (NTSTATUS) workPacket->CompletionContext;
    
    DebugPrint((SDBUS_DEBUG_DEVICE, "SEND: End Cmd%d (0x%02x) status %08x\n", Cmd, Cmd, status));    

    if (NT_SUCCESS(status)) {
        ULONG copyLength = MIN(ResponseLength, SDBUS_RESPONSE_BUFFER_LENGTH);
    
        RtlCopyMemory(ResponseBuffer, &workPacket->ResponseBuffer, copyLength);
#if DBG    
        DebugDumpSdResponse(workPacket->ResponseBuffer, workPacket->ResponseType);
#endif   
    }    

    ExFreePool(workPacket);
    return(status);
}



NTSTATUS
SdbusExecuteWorkSynchronous(
    WORKPROC_FUNCTION Function,
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    )
/*++

Routine Description:

    This routine is called from the enumeration routine to execute IO operations
    in the same manner as the normal IO worker, only that we are running here
    at passive level.

Arguments:

    FdoExtension - device extension for the SD host controller

Return Value:

    None

--*/
{
    PSD_WORK_PACKET workPacket;
    NTSTATUS status;
    KEVENT event;

    DebugPrint((SDBUS_DEBUG_WORKPROC, "ExecuteWorkSynchronous: %s\n", WP_FUNC_STRING(Function)));

    status = SdbusBuildWorkPacket(FdoExtension,
                                  Function,
                                  SdbusSynchronousWorkCompletion,
                                  &event,
                                  &workPacket);

    if (!NT_SUCCESS(status)) {    
        return status;
    }
    
    workPacket->PdoExtension = PdoExtension;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    SdbusQueueWorkPacket(FdoExtension, workPacket, WP_TYPE_SYSTEM);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    status = (NTSTATUS) workPacket->CompletionContext;

    ExFreePool(workPacket);
    return(status);
} 



VOID
SdbusSynchronousWorkCompletion(
    IN PSD_WORK_PACKET WorkPacket,
    IN NTSTATUS status
    )
/*++

Routine Description:

    Generic completion routine used by the driver

Arguments:

    DeviceObject
    Irp
    pdoIoCompletedEvent - this event will be signalled before return of this routine

Return value:

    Status

--*/
{
    PKEVENT pEvent = WorkPacket->CompletionContext;

    WorkPacket->CompletionContext = (PVOID) status;

    KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);

}
 

//------------------------------------------------------------------
//
// Worker miniproc routines
//
//------------------------------------------------------------------



NTSTATUS
SdbusSetPowerWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;
    
    switch(WorkPacket->FunctionPhase) {
    case 0:

        if (WorkPacket->Function == SDWP_POWER_OFF) {
            (*(fdoExtension->FunctionBlock->SetPower))(fdoExtension, FALSE, NULL);
            status = STATUS_SUCCESS;
            break;
        }
        
        status = (*(fdoExtension->FunctionBlock->SetPower))(fdoExtension, TRUE, &WorkPacket->DelayTime);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Used for phase during host reset
        //
        WorkPacket->TempCtl = 0;
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 1:
    
    
        status = (*(fdoExtension->FunctionBlock->ResetHost))(fdoExtension,
                                                             (UCHAR)WorkPacket->TempCtl,
                                                             &WorkPacket->DelayTime);

        // Reset host will continue returning STATUS_MORE_PROCESSING_REQUIRED until
        // the end of the reset phase. At that point we are done here, so we will
        // just exit
        WorkPacket->TempCtl++;
        break;
    }

    return status;
}
        


NTSTATUS
SdbusIdentifyIoDeviceWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;
    ULONG ioOcr;
    ULONG cmdResponse;

    switch(WorkPacket->FunctionPhase) {
    case 0:
    
        fdoExtension->numFunctions = 0;
        fdoExtension->memFunction = FALSE;
        
        // need to return STATUS_SUCCESS on error
        WorkPacket->FunctionPhaseOnError = 255;

        //
        // send CMD5 to look for an SDIO card
        //
        
        //ISSUE: have the worker handle this housekeeping
        (*(fdoExtension->FunctionBlock->SetFunctionType))(fdoExtension, SDBUS_FUNCTION_TYPE_IO);

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_SEND_OP_COND, SDCMD_RESP_4, 0, 0);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 1:        
    
        cmdResponse = WorkPacket->ResponseBuffer[0];
        fdoExtension->numFunctions = (UCHAR)((cmdResponse >> 28) & 0x7);
        fdoExtension->memFunction = ((cmdResponse & 0x8000000) != 0);
        ioOcr = cmdResponse & 0xFFFFFF;

        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x #func=%d ioOCR=%06X\n", fdoExtension->DeviceObject,
                                       fdoExtension->numFunctions, ioOcr));
        

        if (fdoExtension->numFunctions == 0) {
            status = STATUS_SUCCESS;
            break;
        }
        
        //
        // SDIO card exists
        //

        //
        // ISSUE: NEED TO IMPLEMENT: test OCR for validity, and set new voltage
        //

        
        WorkPacket->TempCtl = ioOcr;  // shouldn't this be host dependent?
        WorkPacket->ResetCount = 0;
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

#define CASE_IO_IDENTIFY_LOOP 2
    case CASE_IO_IDENTIFY_LOOP:
    
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_SEND_OP_COND, SDCMD_RESP_4, WorkPacket->TempCtl, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        

    case 3:
        cmdResponse = WorkPacket->ResponseBuffer[0];
        if ((cmdResponse >> 31) == 1) {
            status = STATUS_SUCCESS;
            break;
        }
        
        if (++WorkPacket->ResetCount > 20) {
            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x enumerate IO card fails\n", fdoExtension->DeviceObject));
            fdoExtension->numFunctions = 0;
            fdoExtension->memFunction = FALSE;
            status = STATUS_SUCCESS;
            break;
        }
        
        WorkPacket->DelayTime = 100000;
        WorkPacket->FunctionPhase = CASE_IO_IDENTIFY_LOOP;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 255:
        //
        // Called on error, probably a CMD timeout. This means that an IO card
        // isn't there.
        //
        fdoExtension->numFunctions = 0;
        fdoExtension->memFunction = FALSE;
        status = STATUS_SUCCESS;
        break;
            
    default:
        ASSERT(FALSE);
    }
    return status;
}
    


NTSTATUS
SdbusIdentifyMemoryFunctionWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;
    ULONG argument;    
    SD_OCR sdOCR;
    
    switch(WorkPacket->FunctionPhase) {
    case 0:
    
        if (fdoExtension->numFunctions && !fdoExtension->memFunction) {
            //
            // This means that the IoDevice worker found an IO device without
            // a memory function. So we just exit
            //
            status = STATUS_SUCCESS;
            break;
        }
        
        // need to return STATUS_SUCCESS on error
        WorkPacket->FunctionPhaseOnError = 255;

        (*(fdoExtension->FunctionBlock->SetFunctionType))(fdoExtension, SDBUS_FUNCTION_TYPE_MEMORY);
        
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_GO_IDLE_STATE, SDCMD_RESP_NONE, 0, 0);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 1:

        WorkPacket->TempCtl = 0;  
        WorkPacket->ResetCount = 0;
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

#define CASE_MEM_IDENTIFY_LOOP 2
    case CASE_MEM_IDENTIFY_LOOP:
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_APP_CMD, SDCMD_RESP_1, 0, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 3:
        
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SD_APP_OP_COND, SDCMD_RESP_3, WorkPacket->TempCtl, SDCMDF_ACMD);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 4:

        sdOCR.u.AsULONG = WorkPacket->ResponseBuffer[0];
        WorkPacket->TempCtl = WorkPacket->ResponseBuffer[0];
        
        if (sdOCR.u.bits.PowerUpBusy) {
            // Memory Function found
            
            DebugPrint((SDBUS_DEBUG_INFO, "fdo %08x OCR voltage range == %08x\n",
                        fdoExtension->DeviceObject, (ULONG)sdOCR.u.bits.VddVoltage));
                        
            WorkPacket->FunctionPhase++;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }

        if (++WorkPacket->ResetCount > 20) {
            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x enumerate MEM card fails\n", fdoExtension->DeviceObject));
            status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        WorkPacket->DelayTime = 10000;
        WorkPacket->FunctionPhase = CASE_MEM_IDENTIFY_LOOP;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 5:
        fdoExtension->memFunction = TRUE;

        //
        //
        // The memory function has moved from the Idle state, and should now be in the Ready state.
        // Issue a CMD2 to move the card to the Identification state.
        //
        
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_ALL_SEND_CID, SDCMD_RESP_2, 0, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 6:        
        status = STATUS_SUCCESS;
        break;
        
    case 255:
        //
        // Called on error, probably a CMD timeout. This means that an memory function
        // isn't there.
        //
        fdoExtension->memFunction = FALSE;
        status = STATUS_SUCCESS;
        break;
            
    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    

    return status;
}



NTSTATUS
SdbusInitializeCardWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = WorkPacket->PdoExtension;
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;
    SD_RW_DIRECT_ARGUMENT argument;
    UCHAR data;
    PUCHAR pResponse, pTarget;
    UCHAR i;
    
    switch(WorkPacket->FunctionPhase) {

    case 0:
    
        if (!fdoExtension->numFunctions && !fdoExtension->memFunction) {
            DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x initialize card worker fails\n", fdoExtension->DeviceObject));
            SdbusDumpDbgLog();
            status = STATUS_UNSUCCESSFUL;
            break;;
        }
    
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SEND_RELATIVE_ADDR, SDCMD_RESP_6, 0, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 1:
    
        fdoExtension->RelativeAddr = WorkPacket->ResponseBuffer[0] & 0xFFFF0000;
        DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x relative addr %08x\n", fdoExtension->DeviceObject, fdoExtension->RelativeAddr));
        
        
        if (!fdoExtension->memFunction) {
            //
            // Skip to I/O
            //
            WorkPacket->FunctionPhase = 10;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }
            

        (*(fdoExtension->FunctionBlock->SetFunctionType))(fdoExtension, SDBUS_FUNCTION_TYPE_MEMORY);
        //
        // The CSD contains the equivalent of tuples in a single 128-bit register
        //

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SEND_CSD, SDCMD_RESP_2, fdoExtension->RelativeAddr, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 2:
    

        //
        // Need to reverse the order of the bytes
        //
        for (i=0, pResponse=(PUCHAR)WorkPacket->ResponseBuffer, pTarget=(PUCHAR)&fdoExtension->SdCsd; i<15; i++) {
            pTarget[i] = pResponse[i];
        }


        //
        // Get CID
        // A CID is a unique 128=bit id for each individual memory card.
        //

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SEND_CID, SDCMD_RESP_2, fdoExtension->RelativeAddr, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 3:
    

        //
        // Need to reverse the order of the bytes
        //
        for (i=0, pResponse=(PUCHAR)WorkPacket->ResponseBuffer, pTarget=(PUCHAR)&fdoExtension->SdCid; i<15; i++) {
            pTarget[i] = pResponse[i];
        }

#if DBG
        SdbusDebugDumpCsd(&fdoExtension->SdCsd);
        SdbusDebugDumpCid(&fdoExtension->SdCid);
#endif
        //
        // Skip to I/O
        //
        WorkPacket->FunctionPhase = 10;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 10:        

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SELECT_CARD, SDCMD_RESP_1B, fdoExtension->RelativeAddr, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 11:

        if (!fdoExtension->numFunctions) {
            status = STATUS_SUCCESS;
            break;
        }
        
        (*(fdoExtension->FunctionBlock->SetFunctionType))(fdoExtension, SDBUS_FUNCTION_TYPE_IO);
        
        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_BUS_CONTROL;

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_READ);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 12:        
        
        data = (UCHAR)WorkPacket->ResponseBuffer[0];
        data |= 2; // turn on 4-bit mode
        
        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_BUS_CONTROL;
        argument.u.bits.Data = data;
        argument.u.bits.WriteToDevice = 1;
            
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_WRITE);
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
    case 13:

        status = STATUS_SUCCESS;
        break;        
        
    
    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    

    return status;
}



NTSTATUS
SdbusInitializeFunctionWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = WorkPacket->PdoExtension;
    PFDO_EXTENSION fdoExtension = WorkPacket->FdoExtension;
    NTSTATUS status;
    SD_RW_DIRECT_ARGUMENT argument;
    UCHAR data;
    
    switch(WorkPacket->FunctionPhase) {

    case 0:
    
        if (pdoExtension->FunctionType == SDBUS_FUNCTION_TYPE_MEMORY) {
            // memory is already initialized during identify
            status = STATUS_SUCCESS;
            break;
        }

        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_IO_ENABLE;

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_READ);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 1:
    
        //
        // Turn on I/O enable
        //
            
        data = (UCHAR)WorkPacket->ResponseBuffer[0];
        data |= (1 << pdoExtension->Function);
                
        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_IO_ENABLE;
        argument.u.bits.Data = data;
        argument.u.bits.WriteToDevice = 1;
            
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_WRITE);
        
        WorkPacket->TempCtl = 200; // wait up to 2 seconds (200 * 10msec)
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

#define CASE_INIT_FUNC_LOOP 2
    case CASE_INIT_FUNC_LOOP:

        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_IO_READY;

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_READ);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        

    case 3:

        //
        // Check to see if I/O ready for this function is on
        //

        data = (UCHAR)WorkPacket->ResponseBuffer[0];

        if (!(data & (1 << pdoExtension->Function))) {
            if (--WorkPacket->TempCtl == 0) {
                //
                // timeout waiting for I/O ready
                //
                DebugPrint((SDBUS_DEBUG_ENUM, "fdo %08x enumerate MEM card fails\n", fdoExtension->DeviceObject));
                status = STATUS_UNSUCCESSFUL;
                break;
                
            }
            //
            // Delay and loop back to re-read for I/O ready
            //
            WorkPacket->DelayTime = 10000; // 10 msec increments
            WorkPacket->FunctionPhase = CASE_INIT_FUNC_LOOP;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }

        //
        // I/O ready is on, continue
        //

        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_INT_ENABLE;

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_READ);

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 4:

        //    
        // Turn on INT ENABLE
        //

        data = (UCHAR)WorkPacket->ResponseBuffer[0];
        data |= (1 << pdoExtension->Function) + 1;        
                
        argument.u.AsULONG = 0;    
        argument.u.bits.Address = SD_CCCR_INT_ENABLE;
        argument.u.bits.Data = data;
        argument.u.bits.WriteToDevice = 1;
            
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_IO_RW_DIRECT, SDCMD_RESP_5, argument.u.AsULONG, SDCMDF_WRITE);
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 5:
        status = STATUS_SUCCESS;
        break;

            
    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    

    return status;
}



NTSTATUS
SdbusMemoryBlockWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION PdoExtension = WorkPacket->PdoExtension;
    PFDO_EXTENSION fdoExtension = PdoExtension->FdoExtension;
    ULONG sdRca = fdoExtension->RelativeAddr;
    ULONG Length;
    NTSTATUS status;

    switch(WorkPacket->FunctionPhase) {
    case 0:

        (*(fdoExtension->FunctionBlock->StartBlockOperation))(fdoExtension);

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SET_BLOCKLEN, SDCMD_RESP_1B, 512, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 1:
        
        SET_CMD_PARAMETERS(WorkPacket, SDCMD_APP_CMD,      SDCMD_RESP_1,  sdRca, 0);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 2:        

        SET_CMD_PARAMETERS(WorkPacket, SDCMD_SET_BUS_WIDTH,SDCMD_RESP_1,  2, SDCMDF_ACMD);
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;


    case 3:

        Length = (WorkPacket->Function == SDWP_READBLOCK) ? WorkPacket->Parameters.ReadBlock.Length :
                                                            WorkPacket->Parameters.WriteBlock.Length;
        WorkPacket->BlockCount = Length / 512;
        (*(fdoExtension->FunctionBlock->SetBlockParameters))(fdoExtension, (USHORT) WorkPacket->BlockCount);

#if 0
        if (workPacket->Function == SDWP_WRITEBLOCK) {
            DebugPrint((SDBUS_DEBUG_WORKER, "%02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\n",
                                          Buffer[0], Buffer[1], Buffer[2], Buffer[3],
                                          Buffer[4], Buffer[5], Buffer[6], Buffer[7],
                                          Buffer[8], Buffer[9], Buffer[10],Buffer[11],
                                          Buffer[12], Buffer[13], Buffer[14], Buffer[15]));
        }         
#endif

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 4:

        if (WorkPacket->Function == SDWP_READBLOCK) {

            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_READ_MULTIPLE_BLOCK,
                               SDCMD_RESP_1,
                               (ULONG) WorkPacket->Parameters.ReadBlock.ByteOffset,
                               SDCMDF_READ | SDCMDF_DATA | SDCMDF_MULTIBLOCK);

        } else if (WorkPacket->Function == SDWP_WRITEBLOCK) {

            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_WRITE_MULTIPLE_BLOCK,
                               SDCMD_RESP_1,
                               (ULONG) WorkPacket->Parameters.WriteBlock.ByteOffset,
                               SDCMDF_WRITE | SDCMDF_DATA | SDCMDF_MULTIBLOCK);
                               
        } else {
            ASSERT(FALSE);
        }                               

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 5:
        
        WorkPacket->Retries = 5;
        WorkPacket->DelayTime = 1000;
        WorkPacket->RequiredEvent = (WorkPacket->Function == SDWP_READBLOCK) ? SDBUS_EVENT_BUFFER_FULL :
                                                                               SDBUS_EVENT_BUFFER_EMPTY;
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
#define MBW_START_COPY 6
    case MBW_START_COPY:        
        DebugPrint((SDBUS_DEBUG_WORKPROC, "MemBlockWorker: begin sector copy\n"));


        if (WorkPacket->Function == SDWP_READBLOCK) {
        
            (*(fdoExtension->FunctionBlock->ReadDataPort))(fdoExtension,
                                                           WorkPacket->Parameters.ReadBlock.Buffer,
                                                           512);
            
            WorkPacket->DelayTime = 1000;
            if (--WorkPacket->BlockCount > 0) {
                WorkPacket->RequiredEvent = SDBUS_EVENT_BUFFER_FULL;
            } else {            
                WorkPacket->RequiredEvent = SDBUS_EVENT_CARD_RW_END;
            }            

        } else if (WorkPacket->Function == SDWP_WRITEBLOCK) {
        
            (*(fdoExtension->FunctionBlock->WriteDataPort))(fdoExtension,
                                                            WorkPacket->Parameters.WriteBlock.Buffer,
                                                            512);
            
            WorkPacket->DelayTime = 50000;
            
            if (--WorkPacket->BlockCount > 0) {
                WorkPacket->RequiredEvent = SDBUS_EVENT_BUFFER_EMPTY;
            } else {
                WorkPacket->RequiredEvent = SDBUS_EVENT_CARD_RW_END;
            }            
        }

        DebugPrint((SDBUS_DEBUG_WORKPROC, "MemBlockWorker: end sector copy\n"));

        
        WorkPacket->Retries = 5;
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 7:

        if (WorkPacket->BlockCount > 0) {
            if (WorkPacket->Function == SDWP_READBLOCK) {
                WorkPacket->Parameters.ReadBlock.Buffer += 512;
            } else {
                WorkPacket->Parameters.WriteBlock.Buffer += 512;
            }                
            WorkPacket->FunctionPhase = MBW_START_COPY;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }

#if 0
        if (workPacket->Function == SDWP_READBLOCK) {
            DebugPrint((SDBUS_DEBUG_WORKER, "%02x %02x %02x %02x %02x %02x %02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\n",
                                          Buffer[0], Buffer[1], Buffer[2], Buffer[3],
                                          Buffer[4], Buffer[5], Buffer[6], Buffer[7],
                                          Buffer[8], Buffer[9], Buffer[10],Buffer[11],
                                          Buffer[12], Buffer[13], Buffer[14], Buffer[15]));
        }         
#endif

        (*(fdoExtension->FunctionBlock->EndBlockOperation))(fdoExtension);

        Length = (WorkPacket->Function == SDWP_READBLOCK) ? WorkPacket->Parameters.ReadBlock.Length :
                                                            WorkPacket->Parameters.WriteBlock.Length;
        DebugPrint((SDBUS_DEBUG_WORKPROC, "MemBlockWorker: returns %x\n", Length));
        WorkPacket->Information = Length;
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}



NTSTATUS
SdbusIoDirectWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = WorkPacket->PdoExtension;
    PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
    NTSTATUS status;
    SD_RW_DIRECT_ARGUMENT argument;
    
    argument.u.AsULONG = 0;    

    switch(WorkPacket->FunctionPhase) {
    case 0:

        if (WorkPacket->Function == SDWP_READIO) {

            argument.u.bits.Address = WorkPacket->Parameters.ReadIo.Offset;
            argument.u.bits.Function = pdoExtension->Function;

            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_IO_RW_DIRECT,
                               SDCMD_RESP_5,
                               argument.u.AsULONG,
                               SDCMDF_READ);

        } else if (WorkPacket->Function == SDWP_WRITEIO) {

            argument.u.bits.Address = WorkPacket->Parameters.WriteIo.Offset;
            argument.u.bits.Data = WorkPacket->Parameters.WriteIo.Data;
            argument.u.bits.WriteToDevice = 1;
            argument.u.bits.Function = pdoExtension->Function;
            
            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_IO_RW_DIRECT,
                               SDCMD_RESP_5,
                               argument.u.AsULONG,
                               SDCMDF_WRITE);
                               
        } else {
            ASSERT(FALSE);
        }                               

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 1:
        if (WorkPacket->Function == SDWP_READIO) {
            *(PUCHAR) WorkPacket->Parameters.ReadIo.Buffer = (UCHAR)WorkPacket->ResponseBuffer[0];
        }
        status = STATUS_SUCCESS;
        break;
        
    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }
    

    return status;
}
    



NTSTATUS
SdbusIoExtendedWorker(
    IN PSD_WORK_PACKET WorkPacket
    )
/*++

Routine Description:

Arguments:

Return value:

--*/
{
    PPDO_EXTENSION pdoExtension = WorkPacket->PdoExtension;
    PFDO_EXTENSION fdoExtension = pdoExtension->FdoExtension;
    NTSTATUS status;
    SD_RW_EXTENDED_ARGUMENT argument;
    ULONG totalLength;
    
    argument.u.AsULONG = 0;    

    switch(WorkPacket->FunctionPhase) {

    case 0:
    
        totalLength = (WorkPacket->Function == SDWP_READIO_EXTENDED) ?
                       WorkPacket->Parameters.ReadIo.Length :
                       WorkPacket->Parameters.WriteIo.Length;
    
#define IO_BUFFER_SIZE 64
        WorkPacket->BlockCount = totalLength / IO_BUFFER_SIZE;
        WorkPacket->LastBlockLength = totalLength % IO_BUFFER_SIZE;

        DebugPrint((SDBUS_DEBUG_WORKPROC, "IoExtendedWorker: begin I/O length=%d, blocks=%d, last=%d\n",
                                           totalLength, WorkPacket->BlockCount, WorkPacket->LastBlockLength));
        
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;
        
#define IEW_START_CMD 1
    case IEW_START_CMD:

        WorkPacket->CurrentBlockLength = WorkPacket->BlockCount ? IO_BUFFER_SIZE : 
                                                                  WorkPacket->LastBlockLength;
        
        (*(fdoExtension->FunctionBlock->SetBlockParameters))(fdoExtension, (USHORT)WorkPacket->CurrentBlockLength);

        if (WorkPacket->Function == SDWP_READIO_EXTENDED) {

            argument.u.bits.Address = WorkPacket->Parameters.ReadIo.Offset;
            argument.u.bits.Count   = WorkPacket->CurrentBlockLength;
            argument.u.bits.Function = pdoExtension->Function;

            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_IO_RW_EXTENDED,
                               SDCMD_RESP_5,
                               argument.u.AsULONG,
                               SDCMDF_READ | SDCMDF_DATA);

        } else if (WorkPacket->Function == SDWP_WRITEIO_EXTENDED) {

            argument.u.bits.Address = WorkPacket->Parameters.WriteIo.Offset;
            argument.u.bits.Count   = WorkPacket->CurrentBlockLength;
            argument.u.bits.WriteToDevice = 1;
            argument.u.bits.Function = pdoExtension->Function;
            
            SET_CMD_PARAMETERS(WorkPacket,
                               SDCMD_IO_RW_EXTENDED,
                               SDCMD_RESP_5,
                               argument.u.AsULONG,
                               SDCMDF_WRITE | SDCMDF_DATA);
                               
        } else {
            ASSERT(FALSE);
        }                               

        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 2:
        
        WorkPacket->Retries = 5;
        WorkPacket->DelayTime = 1000;
        WorkPacket->RequiredEvent = (WorkPacket->Function == SDWP_READIO_EXTENDED) ? SDBUS_EVENT_BUFFER_FULL :
                                                                                     SDBUS_EVENT_BUFFER_EMPTY;
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

#define IEW_START_COPY 3
    case IEW_START_COPY:
        DebugPrint((SDBUS_DEBUG_WORKPROC, "IoExtendedWorker: begin data copy %d bytes\n", WorkPacket->CurrentBlockLength));

        if (WorkPacket->BlockCount) {
            //
            // Still have full blocks to copy
            //
        
            WorkPacket->BlockCount--;
            
//            if (WorkPacket->BlockCount || WorkPacket->LastBlockLength) {
//                WorkPacket->RequiredEvent = (WorkPacket->Function == SDWP_READIO_EXTENDED) ? SDBUS_EVENT_BUFFER_FULL :
//                                                                                             SDBUS_EVENT_BUFFER_EMPTY;
//            } else {
                WorkPacket->RequiredEvent = SDBUS_EVENT_CARD_RW_END;
//            }
            
        } else {
            //
            // Copying the last partial block
            //
            ASSERT(WorkPacket->LastBlockLength);
            
            WorkPacket->LastBlockLength = 0;
            WorkPacket->RequiredEvent = SDBUS_EVENT_CARD_RW_END;
        }
            
        if (WorkPacket->Function == SDWP_READIO_EXTENDED) {
        
            (*(fdoExtension->FunctionBlock->ReadDataPort))(fdoExtension,
                                                           WorkPacket->Parameters.ReadIo.Buffer,
                                                           WorkPacket->CurrentBlockLength);

            WorkPacket->Parameters.ReadIo.Buffer += WorkPacket->CurrentBlockLength;
            WorkPacket->DelayTime = 1000;

        } else if (WorkPacket->Function == SDWP_WRITEIO_EXTENDED) {
        
            (*(fdoExtension->FunctionBlock->WriteDataPort))(fdoExtension,
                                                            WorkPacket->Parameters.WriteIo.Buffer,
                                                            WorkPacket->CurrentBlockLength);

            WorkPacket->Parameters.WriteIo.Buffer += WorkPacket->CurrentBlockLength;
            WorkPacket->DelayTime = 50000;
        }

        DebugPrint((SDBUS_DEBUG_WORKPROC, "IoExtendedWorker: end data copy\n"));

        
        WorkPacket->Retries = 5;
        WorkPacket->FunctionPhase++;
        status = STATUS_MORE_PROCESSING_REQUIRED;
        break;

    case 4:

        if (WorkPacket->BlockCount || WorkPacket->LastBlockLength) {
            WorkPacket->FunctionPhase = IEW_START_CMD;
            status = STATUS_MORE_PROCESSING_REQUIRED;
            break;        
        }

//        (*(fdoExtension->FunctionBlock->EndBlockOperation))(fdoExtension);
        totalLength = (WorkPacket->Function == SDWP_READIO_EXTENDED) ? WorkPacket->Parameters.ReadIo.Length :
                                                                       WorkPacket->Parameters.WriteIo.Length;
        DebugPrint((SDBUS_DEBUG_WORKPROC, "IoExtendedWorker: returns %x\n", totalLength));
        WorkPacket->Information = totalLength;
        status = STATUS_SUCCESS;
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_UNSUCCESSFUL;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\sources.inc ===
!INCLUDE $(PROJECT_ROOT)\cluster\sources.inc

C_DEFINES=$(C_DEFINES) -DSTRSAFE_LIB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This is the cluster-wide sources include file. All cluster sources files
    include this.

Author:

    Steve Wood (stevewo) 12-Apr-1990

    C. Brent Thomas (a-brentt) 23-Mar-1998

	Eliminated the use of the ALT_PROJECT_TARGET macro with the result
	that the symbol files will be placed in the ??? directory.

!ENDIF

MAJORCOMP=cluster
BINPLACE_PLACEFILE=$(PROJECT_ROOT)\cluster\placefil.txt
MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=$(C_DEFINES) -DCLUSTER_BETA=0 -DSTARTUP_FAILURE_RESTART=1

LEAKSLIB=$(PROJECT_ROOT)\cluster\clusexts\leaks\$(O)\leaks.lib

!IF !DEFINED(NO_SPECIAL_DEBUG)
!IF DEFINED(USE_DEBUG_CRTS)
DEBUG_CRTS=1
!ENDIF
!IF !$(FREEBUILD)
RCOPTIONS=$(RCOPTIONS) -D_DEBUG
!ENDIF
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\app.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		App.inl
//
//	Abstract:
//		Inline method implementations for the CApp class.
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __APP_INL_
#define __APP_INL_

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

// Display a message box
inline int CApp::MessageBox(
	HWND hwndParent,
	LPCWSTR lpszText,
	UINT fuStyle
	)
{
	return ::MessageBox(
			hwndParent,
			lpszText,
			m_pszAppName,
			fuStyle
			);

} //*** CApp::MessageBox(lpszText)

// Display a message box
inline int CApp::MessageBox(
	HWND hwndParent,
	UINT nID,
	UINT fuStyle
	)
{
	CString strMsg;

	strMsg.LoadString(nID);
	return MessageBox(hwndParent, strMsg, fuStyle);

} //*** CApp::MessageBox(nID)

/////////////////////////////////////////////////////////////////////////////
// Helper Functions
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CApp * GetApp(void)
{
	return &_Module;
}

// Display an application message box
inline int AppMessageBox(HWND hwndParent, LPCWSTR lpszText, UINT fuStyle)
{
	return GetApp()->MessageBox(hwndParent, lpszText, fuStyle);

} // AppMessageBox()

// Display an application message box
inline int AppMessageBox(HWND hwndParent, UINT nID, UINT fuStyle)
{
	return GetApp()->MessageBox(hwndParent, nID, fuStyle);

} // MessageBox()

/////////////////////////////////////////////////////////////////////////////
// Provide TRACE support
/////////////////////////////////////////////////////////////////////////////

// Get a pointer to the application object
inline CApp * TRACE_GetApp(void)
{
	return GetApp();
}

inline int TRACE_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(NULL, lpszText, nType);
}

inline int TRACE_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(NULL, nIDPrompt, nType);
}

/////////////////////////////////////////////////////////////////////////////

#endif // __APP_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\app.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		App.h
//
//	Abstract:
//		Definition of the CApp class.
//
//	Implementation File:
//		App.cpp
//
//	Author:
//		David Potter (davidp)	December 1, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __APP_H_
#define __APP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

namespace ATL
{
	class CString;
}

/////////////////////////////////////////////////////////////////////////////
// External Declarations
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
_CRTIMP void __cdecl _CrtMemCheckpoint(_CrtMemState * state);
_CRTIMP int __cdecl _CrtMemDifference(
		_CrtMemState * state,
		const _CrtMemState * oldState,
		const _CrtMemState * newState
		);
_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(const _CrtMemState * state);
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEAPP_H_
#include <AtlBaseApp.h>
#endif

/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////

const LPTSTR g_pszHelpFileName = { _T( "CluAdmin.hlp" ) };

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

class CApp : public CBaseApp
{
protected:
	LPWSTR m_pszAppName;

#ifdef _DEBUG
	static _CrtMemState CApp::s_msStart;
#endif // _DEBUG

public:
	// Default constructor
	CApp(void)
	{
		m_pszAppName = NULL;
	}

	// Destructor
	~CApp(void)
	{
		delete [] m_pszAppName;
	}

	// Initialize the application object
	void Init(_ATL_OBJMAP_ENTRY * p, HINSTANCE h, LPCWSTR pszAppName);

	// Initialize the application object
	void Init(_ATL_OBJMAP_ENTRY * p, HINSTANCE h, UINT idsAppName);

	void Term(void)
	{
		delete [] m_pszAppName;
		m_pszAppName = NULL;
		CComModule::Term();
#ifdef _DEBUG
		_CrtMemState msNow;
		_CrtMemState msDiff;
		_CrtMemCheckpoint(&msNow);
		if (_CrtMemDifference(&msDiff, &s_msStart, &msNow))
		{
			ATLTRACE(_T("Possible memory leaks detected in CLADMWIZ!\n"));
            _CrtMemDumpAllObjectsSince(&s_msStart);
		} // if:  memory leak detected
#endif // _DEBUG

	} //*** Term()

	// Returns the name of the application.
	LPCTSTR PszAppName(void)
	{
		return m_pszAppName;
	}

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		LPCWSTR lpszText,
		UINT fuStyle = MB_OK
		);

	// Display a message box as a child of the console
	int MessageBox(
		HWND hwndParent,
		UINT nID,
		UINT fuStyle = MB_OK
		);

	// Read a value from the profile
	CString GetProfileString(
		LPCTSTR lpszSection,
		LPCTSTR lpszEntry,
		LPCTSTR lpszDefault = NULL
		);

	virtual LPCTSTR PszHelpFilePath( void );

}; // class CApp

/////////////////////////////////////////////////////////////////////////////

#endif // __APP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\app.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      App.cpp
//
//  Abstract:
//      Implementation of the CApp class.
//
//  Author:
//      David Potter (davidp)   December 1, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "App.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CApp
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
_CrtMemState CApp::s_msStart = { 0 };
#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::Init
//
//  Routine Description:
//      Initialize the module.
//
//  Arguments:
//      p           COM Object map.
//      h           Instance handle.
//      pszAppName  Application name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CApp::Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h, LPCWSTR pszAppName )
{
    ASSERT( pszAppName != NULL );

    size_t  cch;

#ifdef _DEBUG
    _CrtMemCheckpoint( &s_msStart );
#endif // _DEBUG

    CComModule::Init( p, h );

    // Deallocate the buffer if it was allocated previously
    // since we don't have any way of knowing if it is big
    // enough for the new app name.
    if ( m_pszAppName != NULL )
    {
        delete [] m_pszAppName;
        m_pszAppName = NULL;
    } // if: allocated previously

    // Allocate an app name buffer and copy the app name to it.
    cch = wcslen( pszAppName ) + 1;
    m_pszAppName = new WCHAR[ cch ];
    ASSERT( m_pszAppName != NULL );
    if ( m_pszAppName != NULL )
    {
#if DBG
        HRESULT hr = 
#endif
        StringCchCopyW( m_pszAppName, cch, pszAppName );
        ASSERT( SUCCEEDED( hr ) );
    } // if: memory for app name allocated successfully

} //*** CApp::Init( pszAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::Init
//
//  Routine Description:
//      Initialize the module.
//
//  Arguments:
//      p           COM Object map.
//      h           Instance handle.
//      idsAppName  Resource ID for the application name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CApp::Init( _ATL_OBJMAP_ENTRY * p, HINSTANCE h, UINT idsAppName )
{
    ASSERT( idsAppName != 0 );

#ifdef _DEBUG
    _CrtMemCheckpoint( &s_msStart );
#endif // _DEBUG

    CComModule::Init( p, h );

    //
    // Save the application name.
    //
    {
        CString strAppName;
        size_t  cch;

        strAppName.LoadString( idsAppName );

        // Deallocate the buffer if it was allocated previously
        // since we don't have any way of knowing if it is big
        // enough for the new app name.
        if ( m_pszAppName != NULL )
        {
            delete [] m_pszAppName;
            m_pszAppName = NULL;
        } // if: allocated previously

        // Allocate an app name buffer and copy the app name to it.
        cch = strAppName.GetLength() + 1;
        m_pszAppName = new WCHAR[ cch ];
        ASSERT( m_pszAppName != NULL );
        if ( m_pszAppName != NULL )
        {
#if DBG
            HRESULT hr =
#endif
            StringCchCopyW( m_pszAppName, cch, strAppName );
            ASSERT( SUCCEEDED( hr ) );
        } // if: memory for app name allocated successfully
    } // Save the application name

} //*** CApp::Init( idsAppName )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::GetProfileString
//
//  Routine Description:
//      Read a value from the profile.
//
//  Arguments:
//      lpszSection [IN] Name of subkey below HKEY_CURRENT_USER to read from.
//      lpszEntry   [IN] Name of value to read.
//      lpszDefault [IN] Default if no value found.
//
//  Return Value:
//      CString value.
//
//--
/////////////////////////////////////////////////////////////////////////////
CString CApp::GetProfileString(
    LPCTSTR lpszSection,
    LPCTSTR lpszEntry,
    LPCTSTR lpszDefault // = NULL
    )
{
    CRegKey key;
    CString strKey;
    CString strValue;
    LPTSTR  pszValue;
    DWORD   cbValue;
    DWORD   sc;

    ASSERT( m_pszAppName != NULL );
    if ( m_pszAppName == NULL )
    {
        return _T( "" );
    } // if: app name buffer not allocated

    // Open the key.
    strKey.Format( _T("Software\\%s\\%s"), m_pszAppName, lpszSection );
    sc = key.Open( HKEY_CURRENT_USER, strKey, KEY_READ );
    if ( sc != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error opening the key

    // Read the value.
    cbValue = 256;
    pszValue = strValue.GetBuffer( cbValue / sizeof( TCHAR ) );
    sc = key.QueryValue( pszValue, lpszEntry, &cbValue );
    if ( sc != ERROR_SUCCESS )
    {
        return lpszDefault;
    } // if:  error querying the value

    // Return the buffer to the caller.
    strValue.ReleaseBuffer();
    return strValue;

} //*** CApp::GetProfileString()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CApp::PszHelpFilePath
//
//  Routine Description:
//      Return the help file path.
//
//  Arguments:
//      None.
//
//  Return Value:
//      LPCTSTR
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CApp::PszHelpFilePath( void )
{
    static TCHAR    s_szHelpFilePath[ _MAX_PATH ] = { 0 };
    TCHAR           szPath[ _MAX_PATH ];
    TCHAR           szDrive[ _MAX_PATH ];
    TCHAR           szDir[ _MAX_DIR ];
    size_t          cchPath;
#if DBG
    HRESULT         hr;
#endif

    //
    // Generate the help file path.  The help file is located in
    // %SystemRoot%\Help.
    //
    if ( s_szHelpFilePath[ 0 ] == _T('\0') )
    {
        ::GetSystemWindowsDirectory( szPath, _MAX_PATH );
        cchPath = _tcslen( szPath );
        if ( szPath[ cchPath - 1 ] != _T('\\') )
        {
            szPath[ cchPath++ ] = _T('\\');
            szPath[ cchPath ] = _T('\0');
        } // if: no backslash on the end of the path

#if DBG
        hr =
#endif
        StringCchCopy( &szPath[ cchPath ], RTL_NUMBER_OF( szPath ) - cchPath, _T("Help\\") );
        ASSERT( SUCCEEDED( hr ) );
        _tsplitpath( szPath, szDrive, szDir, NULL, NULL );
        _tmakepath( s_szHelpFilePath, szDrive, szDir, _T("cluadmin"), _T(".hlp") );
    } // if: help file name hasn't been constructed yet

    return s_szHelpFilePath;

} //*** CApp::PszHelpFilePath()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\artype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARType.h
//
//	Abstract:
//		Definition of the CWizPageARType class.
//
//	Implementation File:
//		ARType.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARTYPE_H_
#define __ARTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARType;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusResTypeInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARType
/////////////////////////////////////////////////////////////////////////////

class CWizPageARType : public CClusterAppStaticWizardPage< CWizPageARType >
{
	typedef CClusterAppStaticWizardPage< CWizPageARType > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARType( void )
		: m_prti( NULL )
	{
	} //*** CWizPageARType()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ART )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ART )

	enum { IDD = IDD_APP_RESOURCE_TYPE };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CWizardPageImpl required methods.
	//

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARType )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );


// Implementation
protected:
	//
	// Controls.
	//
	CComboBox	m_cboxResTypes;

	//
	// Page state.
	//
	CString				m_strResType;
	CClusResTypeInfo *	m_prti;

	// Fill the combobox with a list of resource types
	void FillComboBox( void );

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_TYPE; }

}; //*** class CWizPageARType

/////////////////////////////////////////////////////////////////////////////

#endif // __ARTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\arcreate.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARCreate.h
//
//	Abstract:
//		Definition of the CWizPageARCreate class.
//
//	Implementation File:
//		ARCreate.cpp
//
//	Author:
//		David Potter (davidp)	December 8, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARCREATE_H_
#define __ARCREATE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreate;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreate
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreate : public CClusterAppStaticWizardPage< CWizPageARCreate >
{
	typedef CClusterAppStaticWizardPage< CWizPageARCreate > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARCreate( void ) : m_bCreatingAppResource( TRUE )
	{
	} //*** CWizPageARCreate()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARC )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARC )

	enum { IDD = IDD_APP_RESOURCE_CREATE };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARCreate )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

// Implementation
protected:
	//
	// Controls.
	//
	CButton		m_rbCreateAppRes;
	CButton		m_rbDontCreateAppRes;

	//
	// Page state.
	//
	BOOL		m_bCreatingAppResource;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_CREATE; }

}; //*** class CWizPageARCreate

/////////////////////////////////////////////////////////////////////////////

#endif // __ARCREATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\artype.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ARType.cpp
//
//  Abstract:
//      Implementation of the CWizPageARType class.
//
//  Author:
//      David Potter (davidp)   December 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARType.h"
#include "ClusAppWiz.h"
#include "WizThread.h"  // for CWizardThread

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARType
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARType )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ART_RESTYPES_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ART_RESTYPES )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_cboxResTypes, IDC_ART_RESTYPES );

    return TRUE;

} //*** CWizPageARType::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::OnSetActive( void )
{
    //
    // Get info from the sheet.
    //
    m_prti = PwizThis()->RriApplication().Prti();

    //
    // Fill the list of resource types.
    //
    FillComboBox();

    //
    // Call the base class and return.
    //
    return baseClass::OnSetActive();

} //*** CWizPageARType::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::UpdateData( BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        //
        // Save the combobox selection.
        //
        DDX_GetText( m_hWnd, IDC_ART_RESTYPES, m_strResType );

        if ( ! BBackPressed() )
        {
            if ( ! DDV_RequiredText( m_hWnd, IDC_ART_RESTYPES, IDC_ART_RESTYPES_LABEL, m_strResType ) )
            {
                return FALSE;
            } // if:  required text isn't present
        } // if:  Back button not presssed

        //
        // Get the pointer to the currently selected resource type.
        //
        int idx = m_cboxResTypes.GetCurSel();
        if ( idx != CB_ERR )
        {
            m_prti = reinterpret_cast< CClusResTypeInfo * >( m_cboxResTypes.GetItemDataPtr( idx ) );
        } // if:  item is selected
    } // if: saving data from the page
    else
    {
        //
        // Set the combobox selection.
        //
        ASSERT( m_prti != NULL );
        DDX_SetComboBoxText( m_hWnd, IDC_ART_RESTYPES, m_prti->RstrName() );

    } // else:  setting data to the page

    return bSuccess;

} //*** CWizPageARType::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::OnWizardBack
//
//  Routine Description:
//      Handler for PSN_WIZBACK.
//
//  Arguments:
//      None.
//
//  Return Value:
//      0               Move to previous page.
//      -1              Don't move to previous page.
//      anything else   Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageARType::OnWizardBack( void )
{
    int nResult;

    //
    // Call the base class.  This causes our UpdateData() method to get
    // called.  If it succeeds, save our values.
    //
    nResult = baseClass::OnWizardBack();
    if ( nResult != -1 )
    {
        if ( ! BApplyChanges() )
        {
            nResult = -1;
        } // if:  error applying changes
    } // if:  base class called successfully

    return nResult;

} //*** CWizPageARType::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARType::BApplyChanges( void )
{
    BOOL    bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        if ( PwizThis()->RriApplication().BSetResourceType( m_prti ) )
        {
            //
            // If the resource has already been created, delete it.
            //
            if ( PwizThis()->BAppResourceCreated() )
            {
                if ( ! PwizThis()->BDeleteAppResource() )
                {
                    break;
                } // if:  failed to delete the resource
            } // if:  resource previously created

            PwizThis()->SetAppDataChanged();
        } // if:  resource type changed

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CWizPageARType::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARType::FillComboBox
//
//  Routine Description:
//      Fill the combobox with a list of resource types.
//      NOTE: THIS SHOULD ONLY BE CALLED FROM ONINITDIALOG!!!
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageARType::FillComboBox( void )
{
    int     idx;
    LPCWSTR pszDefaultTypeName;
    LPCWSTR pszDefaultTypeDisplayName = NULL;
    CString strGenAppString;

    //
    // Set the default resource type name.
    //
    if ( (PcawData() != NULL) && (PcawData()->pszAppResourceType != NULL) )
    {
        pszDefaultTypeName = PcawData()->pszAppResourceType;
    } // if:  default type name specified
    else
    {
        strGenAppString.LoadString(IDS_RESTYPE_GENERIC_APPLICATION);
        pszDefaultTypeName = strGenAppString;
    } // else:  no default type name specified

    // Loop to avoid goto's.
    do
    {
        HDC             hCboxDC;
        HFONT           hfontOldFont;
        HFONT           hfontCBFont;
        int             nCboxHorizExtent = 0;
        SIZE            cboxTextSize;
        TEXTMETRIC      tm;

        tm.tmAveCharWidth = 0;

        //
        // Refer to Knowledge base article Q66370 for details on how to
        // set the horizontal extent of a list box (or drop list).
        //
        hCboxDC = m_cboxResTypes.GetDC();                   // Get the device context (DC) from the combo box.
        hfontCBFont = m_cboxResTypes.GetFont();             // Get the combo box font.
        hfontOldFont = (HFONT) SelectObject( hCboxDC, hfontCBFont); // Select this font into the DC. Save the old font.
        GetTextMetrics(hCboxDC, &tm);                       // Get the text metrics of this DC.

        //
        // Collect the list of resource types.
        //
        if ( ! PwizThis()->BCollectResourceTypes( GetParent() ) )
        {
            break;
        } // if:  error collecting resource types

        //
        // Clear the combobox first.
        //
        m_cboxResTypes.ResetContent();

        //
        // Add each resource type in the list to the combobox.
        //
        CClusResTypePtrList::iterator itrestype;
        for ( itrestype = PwizThis()->PlprtiResourceTypes()->begin()
            ; itrestype != PwizThis()->PlprtiResourceTypes()->end()
            ; itrestype++ )
        {
            //
            // Add the resource types to the combobox.
            //
            CClusResTypeInfo * prti = *itrestype;

            // Compute the horizontal extent of this string.
            ::GetTextExtentPoint( 
                    hCboxDC, 
                    prti->RstrDisplayName(),
                    prti->RstrDisplayName().GetLength(),
                    &cboxTextSize);

            if (cboxTextSize.cx > nCboxHorizExtent)
            {
                nCboxHorizExtent = cboxTextSize.cx;
            }

            idx = m_cboxResTypes.AddString( prti->RstrDisplayName() );
            if ( prti->RstrName() == pszDefaultTypeName )
            {
                pszDefaultTypeDisplayName = prti->RstrDisplayName();
            } // if:  found the default resource type
            m_cboxResTypes.SetItemDataPtr( idx, prti );
        } // for:  each entry in the list

        SelectObject(hCboxDC, hfontOldFont);                // Reset the original font in the DC
        m_cboxResTypes.ReleaseDC(hCboxDC);                  // Release the DC
        m_cboxResTypes.SetHorizontalExtent(nCboxHorizExtent + tm.tmAveCharWidth);

        //
        // Select the currently saved entry, or the one specified by
        // the caller of the wizard, or the first one if none are
        // currently saved or specified.
        //
        if ( m_strResType.GetLength() == 0 )
        {
            idx = m_cboxResTypes.FindString( -1, pszDefaultTypeDisplayName );
            if ( idx == CB_ERR )
            {
                idx = 0;
            } // if:  default value not found
            m_cboxResTypes.SetCurSel( idx );
            m_prti = reinterpret_cast< CClusResTypeInfo * >( m_cboxResTypes.GetItemDataPtr( idx ) );
        } // if:  nothing specified yet
        else
        {
            idx = m_cboxResTypes.FindStringExact( -1, m_strResType );
            ASSERT( idx != CB_ERR );
            if ( idx != CB_ERR )
            {
                m_cboxResTypes.SetCurSel( idx );
            } // if:  string found in list
        } // else:  resource type saved
    } while ( 0 );

} //*** CWizPageARType::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\arname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ARName.cpp
//
//  Abstract:
//      Implementation of the CWizPageARNameDesc class.
//
//  Author:
//      David Potter (davidp)   December 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARName.h"
#include "ClusAppWiz.h"
#include "ResAdv.h"         // for CGeneralResourceAdvancedSheet

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARNameDesc
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARNameDesc )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME_TITLE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC_TITLE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_RES_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_ADVANCED_PROPS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARND_ADVANCED_PROPS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_CLICK_NEXT )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN] Property sheet object to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::BInit( IN CBaseSheetWindow * psht )
{
    //
    // Call the base class method.
    //
    return baseClass::BInit( psht );

} //*** CWizPageARNameDesc::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::OnInitDialog( void )
{
    //
    // Make a local copy of the dependency list and the possible owners
    // list. This is needed to find out the changes made to these lists.
    //
    CClusResInfo *  _priAppResInfoPtr = PwizThis()->PriApplication();

    m_lpriOldDependencies = *(_priAppResInfoPtr->PlpriDependencies());
    m_lpniOldPossibleOwners = *(_priAppResInfoPtr->PlpniPossibleOwners());

    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_editResName, IDC_ARND_RES_NAME );
    AttachControl( m_editResDesc, IDC_ARND_RES_DESC );

    return TRUE;

} //*** CWizPageARNameDesc::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::UpdateData( BOOL bSaveAndValidate )
{
    BOOL            _bSuccess = TRUE;
    CClusResInfo *  _priAppResInfoPtr = PwizThis()->PriApplication();

    if ( bSaveAndValidate )
    {
        DDX_GetText( m_hWnd, IDC_ARND_RES_NAME, m_strResName );
        DDX_GetText( m_hWnd, IDC_ARND_RES_DESC, m_strResDesc );

        if ( ! BBackPressed() && ( m_bAdvancedButtonPressed == FALSE ) )
        {
            if ( ! DDV_RequiredText( m_hWnd, IDC_ARND_RES_NAME, IDC_ARND_RES_NAME_LABEL, m_strResName ) )
            {
                return FALSE;
            } // if: required text not specified
        } // if:  Back button not presssed

        //
        // Check if the resource name has changed. If so update the data in
        // the wizard and set a flag.
        //
        if ( _priAppResInfoPtr->RstrName().CompareNoCase( m_strResName ) != 0 )
        {
            _priAppResInfoPtr->SetName( m_strResName );
            m_bNameChanged = TRUE;
        } // if: resource name changed

        //
        // Check if the resource description has changed. If so update the data in
        // the wizard and set a flag.
        //
        if ( _priAppResInfoPtr->RstrDescription().CompareNoCase( m_strResDesc ) != 0 )
        {
            _priAppResInfoPtr->SetDescription( m_strResDesc );
            PwizThis()->SetAppDataChanged();
        } // if: description changed
    } // if: saving data from the page
    else
    {
        m_strResName = _priAppResInfoPtr->RstrName();
        m_strResDesc = _priAppResInfoPtr->RstrDescription();
        m_editResName.SetWindowText( m_strResName );
        m_editResDesc.SetWindowText( m_strResDesc );
    } // else:  setting data to the page

    return _bSuccess;

} //*** CWizPageARNameDesc::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::OnWizardBack
//
//  Routine Description:
//      Handler for PSN_WIZBACK.
//
//  Arguments:
//      None.
//
//  Return Value:
//      0               Move to previous page.
//      -1              Don't move to previous page.
//      anything else   Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageARNameDesc::OnWizardBack( void )
{
    int _nResult;

    //
    // Call the base class.  This causes our UpdateData() method to get
    // called.  If it succeeds, save our values.
    //
    _nResult = baseClass::OnWizardBack();

    return _nResult;

} //*** CWizPageARNameDesc::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARNameDesc::BApplyChanges( void )
{
    BOOL    _bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        CClusResInfo *  priAppResInfoPtr = &PwizThis()->RriApplication();

        if ( BResourceNameInUse() )
        {
            CString _strMsg;
            _strMsg.FormatMessage( IDS_ERROR_RESOURCE_NAME_IN_USE, m_strResName );
            AppMessageBox( m_hWnd, _strMsg, MB_OK | MB_ICONEXCLAMATION );
            break;
        } // if:  resource name is already in use


        //
        // Create the resource if the if the resource does not exist.
        //
        if ( PwizThis()->PriApplication()->BCreated() == FALSE )
        {
            //
            // Delete the resource if it already exists.
            //
            _bSuccess = PwizThis()->BDeleteAppResource();
            if ( _bSuccess == FALSE )
            {
                break;
            } // if:    resource deletion failed.

            //
            //
            // Ensure all required dependencies are present.
            //
            _bSuccess = PwizThis()->BRequiredDependenciesPresent( &PwizThis()->RriApplication() );
            if ( _bSuccess == FALSE )
            {
                break;
            } // if:  all required dependencies not present

            //
            // Create the resource.
            //
            _bSuccess = PwizThis()->BCreateAppResource();
            if ( _bSuccess == FALSE )
            {
                break;
            } // if:    resource creation failed.

            //
            // Copy the list of dependencies and possible owners.
            // This is required to update only the changes to these lists.
            //
            m_lpriOldDependencies = *(priAppResInfoPtr->PlpriDependencies());
            m_lpniOldPossibleOwners = *(priAppResInfoPtr->PlpniPossibleOwners());

            m_bNameChanged = FALSE;
            //
            // Add extension pages.
            //
            Pwiz()->AddExtensionPages( NULL /*hfont*/, PwizThis()->HiconRes() );

        } // if:  the application has not been created
        else
        {
            CClusResInfo *  _priAppResInfoPtr = &PwizThis()->RriApplication();

            //
            // The name of the resource has changed. We cannot set it with the
            // rest of the properties since it is a read only property. So, use
            // the SetClusterResourceName API.
            //
            if ( m_bNameChanged != FALSE )
            {
                if ( SetClusterResourceName(
                            _priAppResInfoPtr->Hresource(), 
                            _priAppResInfoPtr->RstrName()
                            )
                    != ERROR_SUCCESS 
                    )
                {
                    _bSuccess = FALSE;
                    break;
                } // if: the name of the resource could not be set

                m_bNameChanged = FALSE;
            } // if: the name of the resource has changed

            // 
            // If the app data has changed, update the data.
            //
            if ( PwizThis()->BAppDataChanged() )
            {
                _bSuccess = PwizThis()->BSetAppResAttributes( &m_lpriOldDependencies, &m_lpniOldPossibleOwners );
                if ( _bSuccess )
                {
                    //
                    // Copy the list of dependencies and possible owners.
                    // This is required to update only the changes to these lists.
                    //
                    m_lpriOldDependencies = *(_priAppResInfoPtr->PlpriDependencies());
                    m_lpniOldPossibleOwners = *(_priAppResInfoPtr->PlpniPossibleOwners());
                } // if: set attributes successfully
            } // if:  application data changed
            else
            {
                _bSuccess = TRUE;
            } // else:  application data has not changed.
        } // else:  the application has been created

    } while ( 0 );

    return _bSuccess;

} //*** CWizPageARNameDesc::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageARNameDesc::OnAdvancedProps
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on IDC_ARA_ADVANCED_PROPS.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageARNameDesc::OnAdvancedProps(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    CWaitCursor     _wc;
    CClusResInfo *  _priAppResInfoPtr = PwizThis()->PriApplication();
    BOOL            _bAppDataChanged = PwizThis()->BAppDataChanged();

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    m_bAdvancedButtonPressed = TRUE;

    UpdateData( TRUE );

    CGeneralResourceAdvancedSheet _sht( IDS_ADV_RESOURCE_PROP_TITLE, PwizThis() );
    if ( _sht.BInit( *_priAppResInfoPtr, _bAppDataChanged ) )
    {
        //
        // Display the property sheet.  If any properties were changed,
        // update the display of the resource name and description.
        //
        _sht.DoModal();

        PwizThis()->SetAppDataChanged( _bAppDataChanged );
        UpdateData( FALSE );
    } // if:  sheet successfully initialized

    m_bAdvancedButtonPressed = FALSE;

    return 0;

} //*** CWizPageARNameDesc::OnAdvancedProps()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\arcreated.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ARCreated.h
//
//	Abstract:
//		Definition of the CWizPageARCreated class.
//
//	Implementation File:
//		ARCreated.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARCREATED_H_
#define __ARCREATED_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreated;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreated
/////////////////////////////////////////////////////////////////////////////

class CWizPageARCreated : public CClusterAppStaticWizardPage< CWizPageARCreated >
{
	typedef CClusterAppStaticWizardPage< CWizPageARCreated > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageARCreated( void )
	{
	} //*** CWizPageARCreated()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARCD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARCD )

	enum { IDD = IDD_APP_RESOURCE_CREATED };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageARCreated )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

// Implementation
protected:

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_CREATED; }

}; //*** class CWizPageARCreated

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARCreated )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __ARCREATED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\arcreate.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		ARCreate.cpp
//
//	Abstract:
//		Implementation of the CWizPageARCreate class.
//
//	Author:
//		David Potter (davidp)	December 8, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ARCreate.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARCreate
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageARCreate )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARC_CREATE_RES )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ARC_DONT_CREATE_RES )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbCreateAppRes, IDC_ARC_CREATE_RES );
	AttachControl( m_rbDontCreateAppRes, IDC_ARC_DONT_CREATE_RES );

	return TRUE;

} //*** CWizPageARCreate::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//
	m_bCreatingAppResource = PwizThis()->BCreatingAppResource();


	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageARCreate::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::UpdateData( BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		BOOL bChecked = (m_rbCreateAppRes.GetCheck() == BST_CHECKED);
		m_bCreatingAppResource = bChecked;
	} // if: saving data from the page
	else
	{
		if ( m_bCreatingAppResource )
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateAppRes.SetCheck( BST_CHECKED );
			m_rbDontCreateAppRes.SetCheck( BST_UNCHECKED );

		} // if:  creating application resource
		else
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateAppRes.SetCheck( BST_UNCHECKED );
			m_rbDontCreateAppRes.SetCheck( BST_CHECKED );

		} // else:  not creating application resource

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageARCreate::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageARCreate::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageARCreate::BApplyChanges( void )
{
	if ( ! PwizThis()->BSetCreatingAppResource( m_bCreatingAppResource ) )
	{
		return FALSE;
	} // if:  error applying the change to the wizard

	if ( ! m_bCreatingAppResource )
	{
		SetNextPage( IDD_COMPLETION );
		PwizThis()->RemoveExtensionPages();
	} // if: not creating applicaton resource

	return TRUE;

} //*** CWizPageARCreate::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\arname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ARName.h
//
//  Abstract:
//      Definition of the CWizPageARNameDesc class.
//
//  Implementation File:
//      ARName.cpp
//
//  Author:
//      David Potter (davidp)   December 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ARNAME_H_
#define __ARNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageARNameDesc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h" // for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"     // for using CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageARNameDesc
/////////////////////////////////////////////////////////////////////////////

class CWizPageARNameDesc : public CClusterAppStaticWizardPage< CWizPageARNameDesc >
{
    typedef CClusterAppStaticWizardPage< CWizPageARNameDesc > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CWizPageARNameDesc( void ) 
        : m_bAdvancedButtonPressed( FALSE )
        , m_bNameChanged( FALSE )
    {
    } //*** CCWizPageARNameDesc()

    WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_ARND )
    WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_ARND )

    enum { IDD = IDD_APP_RESOURCE_NAME_DESC };

public:
    //
    // CWizardPageWindow public methods.
    //

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

public:
    //
    // CWizardPageImpl required methods.
    //

    // Initialize the page
    BOOL BInit( IN CBaseSheetWindow * psht );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( BOOL bSaveAndValidate );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CWizPageARNameDesc )
        COMMAND_HANDLER( IDC_ARND_RES_NAME, EN_CHANGE, OnResNameChanged )
        COMMAND_HANDLER( IDC_ARND_ADVANCED_PROPS, BN_CLICKED, OnAdvancedProps )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the EN_CHANGE command notification on IDC_ARND_RES_NAME
    LRESULT OnResNameChanged(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        BOOL bEnable = (m_editResName.GetWindowTextLength() > 0);
        EnableNext( bEnable );
        return 0;

    } //*** OnResNameChanged()

    // Handler for the BN_CLICKED command notification on IDC_ARA_ADVANCE_PROPS
    LRESULT OnAdvancedProps(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

    // Handler for PSN_WIZBACK
    int OnWizardBack( void );

// Implementation
protected:
    //
    // Controls.
    //
    CEdit       m_editResName;
    CEdit       m_editResDesc;

    //
    // Page state.
    //
    CString             m_strResName;
    CString             m_strResDesc;
    BOOL                m_bAdvancedButtonPressed;
    BOOL                m_bNameChanged;
    CClusResPtrList     m_lpriOldDependencies;
    CClusNodePtrList    m_lpniOldPossibleOwners;

    //
    // Utility methods.
    //

    // Determine if the resource name is already in use
    BOOL BResourceNameInUse( void )
    {
        return ( PwizThis()->PriFindResourceNoCase( m_strResName ) != NULL );

    } //*** BResourceNameInUse()

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC; }

}; //*** class CWizPageARNameDesc

/////////////////////////////////////////////////////////////////////////////

#endif // __ARNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlbasepropsheets.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBasePropSheetS.cpp
//
//	Abstract:
//		Stub for implementation of base property sheet classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBasePropSheet.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlbasewizs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizS.cpp
//
//	Abstract:
//		Stub for implementation of base wizard classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBaseWiz.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlextdlls.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlExtDllS.cpp
//
//	Abstract:
//		Stub for implementation of the Cluster Administrator extension classes.
//
//	Author:
//		David Potter (davidp)	May 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlExtDll.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlbasewizpages.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseWizPageS.cpp
//
//	Abstract:
//		Stub for implementation of wizard page classes.
//
//	Author:
//		David Potter (davidp)	May 26, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlBaseWizPage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlUtilS.cpp
//
//	Abstract:
//		Stub for implementation of ATL utility functions.
//
//	Author:
//		David Potter (davidp)	December 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlUtil.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlbasesheets.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlBaseSheetS.cpp
//
//	Abstract:
//		Stub for implementation of base property sheet classes.
//
//	Author:
//		David Potter (davidp)	April 20, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "AtlBaseSheet.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atldbgwins.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		AtlDbgWinS.cpp
//
//	Abstract:
//		Stub for implementation of the ATL window debugging functions.
//
//	Author:
//		David Potter (davidp)	June 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlDbgWin.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\atlwin.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLWIN_H__
	#error atlwin.cpp requires atlwin.h to be included first
#endif

#ifndef ATL_NO_NAMESPACE
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// CWindow

HWND CWindow::GetDescendantWindow(int nID) const
{
	_ASSERTE(::IsWindow(m_hWnd));

	// GetDlgItem recursive (return first found)
	// breadth-first for 1 level, then depth-first for next level

	// use GetDlgItem since it is a fast USER function
	HWND hWndChild, hWndTmp;
	CWindow wnd;
	if((hWndChild = ::GetDlgItem(m_hWnd, nID)) != NULL)
	{
		if(::GetTopWindow(hWndChild) != NULL)
		{
			// children with the same ID as their parent have priority
			wnd.Attach(hWndChild);
			hWndTmp = wnd.GetDescendantWindow(nID);
			if(hWndTmp != NULL)
				return hWndTmp;
		}
		return hWndChild;
	}

	// walk each child
	for(hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		wnd.Attach(hWndChild);
		hWndTmp = wnd.GetDescendantWindow(nID);
		if(hWndTmp != NULL)
			return hWndTmp;
	}

	return NULL;    // not found
}

void CWindow::SendMessageToDescendants(UINT message, WPARAM wParam/*= 0*/, LPARAM lParam/*= 0*/, BOOL bDeep/* = TRUE*/)
{
	CWindow wnd;
	for(HWND hWndChild = ::GetTopWindow(m_hWnd); hWndChild != NULL;
		hWndChild = ::GetNextWindow(hWndChild, GW_HWNDNEXT))
	{
		::SendMessage(hWndChild, message, wParam, lParam);

		if(bDeep && ::GetTopWindow(hWndChild) != NULL)
		{
			// send to child windows after parent
			wnd.Attach(hWndChild);
			wnd.SendMessageToDescendants(message, wParam, lParam, bDeep);
		}
	}
}

BOOL CWindow::CenterWindow(HWND hWndCenter/* = NULL*/)
{
	_ASSERTE(::IsWindow(m_hWnd));

	// determine owner window to center against
	DWORD dwStyle = GetStyle();
	if(hWndCenter == NULL)
	{
		if(dwStyle & WS_CHILD)
			hWndCenter = ::GetParent(m_hWnd);
		else
			hWndCenter = ::GetWindow(m_hWnd, GW_OWNER);
	}

	// get coordinates of the window relative to its parent
	RECT rcDlg;
	::GetWindowRect(m_hWnd, &rcDlg);
	RECT rcArea;
	RECT rcCenter;
	HWND hWndParent;
	if(!(dwStyle & WS_CHILD))
	{
		// don't center against invisible or minimized windows
		if(hWndCenter != NULL)
		{
			DWORD dwStyle2 = ::GetWindowLong(hWndCenter, GWL_STYLE);
			if(!(dwStyle2 & WS_VISIBLE) || (dwStyle2 & WS_MINIMIZE))
            {
				hWndCenter = NULL;
            }
		}

		// center within screen coordinates
		::SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

		if(hWndCenter == NULL)
			rcCenter = rcArea;
		else
			::GetWindowRect(hWndCenter, &rcCenter);
	}
	else
	{
		// center within parent client coordinates
		hWndParent = ::GetParent(m_hWnd);
		_ASSERTE(::IsWindow(hWndParent));

		::GetClientRect(hWndParent, &rcArea);
		_ASSERTE(::IsWindow(hWndCenter));
		::GetClientRect(hWndCenter, &rcCenter);
		::MapWindowPoints(hWndCenter, hWndParent, (POINT*)&rcCenter, 2);
	}

	int DlgWidth = rcDlg.right - rcDlg.left;
	int DlgHeight = rcDlg.bottom - rcDlg.top;

	// find dialog's upper left based on rcCenter
	int xLeft = (rcCenter.left + rcCenter.right) / 2 - DlgWidth / 2;
	int yTop = (rcCenter.top + rcCenter.bottom) / 2 - DlgHeight / 2;

	// if the dialog is outside the screen, move it inside
	if(xLeft < rcArea.left)
		xLeft = rcArea.left;
	else if(xLeft + DlgWidth > rcArea.right)
		xLeft = rcArea.right - DlgWidth;

	if(yTop < rcArea.top)
		yTop = rcArea.top;
	else if(yTop + DlgHeight > rcArea.bottom)
		yTop = rcArea.bottom - DlgHeight;

	// map screen coordinates to child coordinates
	return ::SetWindowPos(m_hWnd, NULL, xLeft, yTop, -1, -1,
		SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
}

BOOL CWindow::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_STYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_STYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
{
	_ASSERTE(::IsWindow(m_hWnd));

	DWORD dwStyle = ::GetWindowLong(m_hWnd, GWL_EXSTYLE);
	DWORD dwNewStyle = (dwStyle & ~dwRemove) | dwAdd;
	if(dwStyle == dwNewStyle)
		return FALSE;

	::SetWindowLong(m_hWnd, GWL_EXSTYLE, dwNewStyle);
	if(nFlags != 0)
	{
		::SetWindowPos(m_hWnd, NULL, 0, 0, 0, 0,
			SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | nFlags);
	}

	return TRUE;
}

BOOL CWindow::GetWindowText(BSTR& bstrText)
{
	USES_CONVERSION;
	_ASSERTE(::IsWindow(m_hWnd));

    int     nLen = 0;
    LPTSTR  lpszText = NULL;
    BOOL    fSuccess = FALSE;

	nLen = ::GetWindowTextLength(m_hWnd);
	if(nLen == 0)
    {
		goto Cleanup;
    }

	lpszText = new TCHAR[ nLen + 1 ];

	if(!::GetWindowText(m_hWnd, lpszText, nLen+1))
    {
        goto Cleanup;
    }

	bstrText = ::SysAllocString(T2OLE(lpszText));

    fSuccess = (bstrText != NULL) ? TRUE : FALSE;

Cleanup:

    delete [] lpszText;

    return fSuccess;
}

HWND CWindow::GetTopLevelParent() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp;
	while((hWndTmp = ::GetParent(hWndParent)) != NULL)
		hWndParent = hWndTmp;

	return hWndParent;
}

HWND CWindow::GetTopLevelWindow() const
{
	_ASSERTE(::IsWindow(m_hWnd));

	HWND hWndParent = m_hWnd;
	HWND hWndTmp = hWndParent;

	while(hWndTmp != NULL)
	{
		hWndTmp = (::GetWindowLong(hWndParent, GWL_STYLE) & WS_CHILD) ? ::GetParent(hWndParent) : ::GetWindow(hWndParent, GW_OWNER);
		hWndParent = hWndTmp;
	}

	return hWndParent;
}

/////////////////////////////////////////////////////////////////////////////
// CDynamicChain

CDynamicChain::~CDynamicChain()
{
	if(m_pChainEntry != NULL)
	{
		for(int i = 0; i < m_nEntries; i++)
		{
			if(m_pChainEntry[i] != NULL)
				delete m_pChainEntry[i];
		}

		delete [] m_pChainEntry;
	}
}

BOOL CDynamicChain::SetChainEntry(DWORD dwChainID, CMessageMap* pObject, DWORD dwMsgMapID /* = 0 */)
{
// first search for an existing entry

	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			m_pChainEntry[i]->m_pObject = pObject;
			m_pChainEntry[i]->m_dwMsgMapID = dwMsgMapID;
			return TRUE;
		}
	}

// create a new one

	ATL_CHAIN_ENTRY* pEntry = NULL;
	ATLTRY(pEntry = new ATL_CHAIN_ENTRY);

	if(pEntry == NULL)
		return FALSE;

// search for an empty one

	for(i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] == NULL)
		{
			m_pChainEntry[i] = pEntry;
			return TRUE;
		}
	}

// add a new one

	ATL_CHAIN_ENTRY** ppNew = NULL;
	ATLTRY(ppNew = new ATL_CHAIN_ENTRY*[m_nEntries + 1]);

	if(ppNew == NULL)
	{
		delete pEntry;
		return FALSE;
	}

	pEntry->m_dwChainID = dwChainID;
	pEntry->m_pObject = pObject;
	pEntry->m_dwMsgMapID = dwMsgMapID;

	if(m_pChainEntry != NULL)
	{
		memcpy(ppNew, m_pChainEntry, m_nEntries * sizeof(ATL_CHAIN_ENTRY*));
		delete [] m_pChainEntry;
	}

	m_pChainEntry = ppNew;

	m_pChainEntry[m_nEntries] = pEntry;

	m_nEntries++;

	return TRUE;
}

BOOL CDynamicChain::RemoveChainEntry(DWORD dwChainID)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
		{
			delete m_pChainEntry[i];
			m_pChainEntry[i] = NULL;
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CDynamicChain::CallChain(DWORD dwChainID, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult)
{
	for(int i = 0; i < m_nEntries; i++)
	{
		if(m_pChainEntry[i] != NULL && m_pChainEntry[i]->m_dwChainID == dwChainID)
			return (m_pChainEntry[i]->m_pObject)->ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, m_pChainEntry[i]->m_dwMsgMapID);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWndClassInfo

ATOM CWndClassInfo::Register(WNDPROC* pProc)
{
	if (m_atom == 0)
	{
		::EnterCriticalSection(&_Module.m_csWindowCreate);
		if(m_atom == 0)
		{
			HINSTANCE hInst = _Module.GetModuleInstance();
			if (m_lpszOrigName != NULL)
			{
				_ASSERTE(pProc != NULL);
				LPCTSTR lpsz = m_wc.lpszClassName;
				WNDPROC proc = m_wc.lpfnWndProc;

				WNDCLASSEX wc;
				wc.cbSize = sizeof(WNDCLASSEX);
				if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
				{
					::LeaveCriticalSection(&_Module.m_csWindowCreate);
					return 0;
				}
				memcpy(&m_wc, &wc, sizeof(WNDCLASSEX));
				pWndProc = m_wc.lpfnWndProc;
				m_wc.lpszClassName = lpsz;
				m_wc.lpfnWndProc = proc;
			}
			else
			{
				m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst,
					m_lpszCursorID);
			}

			m_wc.hInstance = hInst;
			m_wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes
			if (m_wc.lpszClassName == NULL)
			{
			    HRESULT hr;
#ifdef _WIN64       // %p isn't available on Win2k/Win9x
                hr = StringCchPrintf( m_szAutoName, RTL_NUMBER_OF( m_szAutoName ), _T("ATL:%p"), &m_wc );
#else
                hr = StringCchPrintf( m_szAutoName, RTL_NUMBER_OF( m_szAutoName ), _T("ATL:%8.8X"), PtrToUlong( &m_wc ) );
#endif
                _ASSERTE( SUCCEEDED( hr ) );
				m_wc.lpszClassName = m_szAutoName;
			}
			WNDCLASSEX wcTemp;
			memcpy(&wcTemp, &m_wc, sizeof(WNDCLASSEX));
			m_atom = (ATOM) ::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
			if (m_atom == 0)
				m_atom = ::RegisterClassEx(&m_wc);
		}
		::LeaveCriticalSection(&_Module.m_csWindowCreate);
	}

	if (m_lpszOrigName != NULL)
	{
		_ASSERTE(pProc != NULL);
		_ASSERTE(pWndProc != NULL);
		*pProc = pWndProc;
	}
	return m_atom;
}

/////////////////////////////////////////////////////////////////////////////
// CWindowImpl

LRESULT CALLBACK CWindowImplBase::StartWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init(WindowProc, pT);
	WNDPROC pProc = (WNDPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// if somebody has subclassed us already we can't do anything,
	// so discard return value from SetWindowLong
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CWindowImplBase::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBase* pT = (CWindowImplBase*)hWnd;
	LRESULT lRes;
	BOOL bRet = pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

#ifdef _WIN64
static LONG g_nNextWindowID;  // Intentionally left uninitialized.
#endif

HWND CWindowImplBase::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT_PTR nID, ATOM atom)
{
	_ASSERTE(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), NULL);

	_ASSERTE(m_hWnd == hWnd);

	return hWnd;
}

BOOL CWindowImplBase::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));
	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)(m_thunk.thunk.pThunk);
	WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CWindowImplBase::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

	if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;

	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
// CDialogImplBase

INT_PTR CALLBACK CDialogImplBase::StartDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)_Module.ExtractCreateWndData();
	_ASSERTE(pT != NULL);
	pT->m_hWnd = hWnd;
	pT->m_thunk.Init((WNDPROC)DialogProc, pT);
	DLGPROC pProc = (DLGPROC)(pT->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, DWLP_DLGPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

INT_PTR CALLBACK CDialogImplBase::DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CDialogImplBase* pT = (CDialogImplBase*)hWnd;
	LRESULT lRes;
	if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0))
	{
		switch (uMsg)
		{
		case WM_COMPAREITEM:
		case WM_VKEYTOITEM:
		case WM_CHARTOITEM:
		case WM_INITDIALOG:
		case WM_QUERYDRAGICON:
		case WM_CTLCOLORMSGBOX:
		case WM_CTLCOLOREDIT:
		case WM_CTLCOLORLISTBOX:
		case WM_CTLCOLORBTN:
		case WM_CTLCOLORDLG:
		case WM_CTLCOLORSCROLLBAR:
		case WM_CTLCOLORSTATIC:
			return lRes;
			break;
		}
		if (lRes != 0)
			::SetWindowLongPtr(pT->m_hWnd, DWLP_MSGRESULT, lRes);
		return TRUE;
	}
	return FALSE;
}

BOOL CDialogImplBase::EndDialog(int nRetCode)
{
	_ASSERTE(m_hWnd);
	return ::EndDialog(m_hWnd, nRetCode);
}

/////////////////////////////////////////////////////////////////////////////
// CContainedWindow

LRESULT CALLBACK CContainedWindow::StartWindowProc(HWND hWnd, UINT uMsg,
	WPARAM wParam, LPARAM lParam)
{
	CContainedWindow* pThis = (CContainedWindow*)_Module.ExtractCreateWndData();
	_ASSERTE(pThis != NULL);
	pThis->m_hWnd = hWnd;
	pThis->m_thunk.Init(pThis->WindowProc, pThis);
	WNDPROC pProc = (WNDPROC)(pThis->m_thunk.thunk.pThunk);
	::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	// check if somebody has subclassed us already since we don't hold onto it
	ATLTRACE(_T("Subclassing through a hook discarded.\n"));
	return pProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK CContainedWindow::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam,
	LPARAM lParam)
{
	CContainedWindow* pT = (CContainedWindow*)hWnd;
	_ASSERTE(pT->m_hWnd != NULL);
	_ASSERTE(pT->m_pObject != NULL);

	LRESULT lRes;
	BOOL bRet = pT->m_pObject->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, pT->m_dwMsgMapID);
	if(uMsg == WM_NCDESTROY)
	{
		pT->m_hWnd = NULL;
		return 0;
	}
	if(bRet)
		return lRes;
	return pT->DefWindowProc(uMsg, wParam, lParam);
}

ATOM CContainedWindow::RegisterWndSuperclass()
{
    HRESULT hr;
	ATOM    atom = 0;
	LPTSTR  pszBuff = NULL;
    size_t  cchBuff = 0;
    
    cchBuff = lstrlen( m_lpszClassName ) + 14;
    pszBuff = new TCHAR[ cchBuff ];
    if ( pszBuff == NULL )
    {
        goto Cleanup;
    }

	WNDCLASSEX wc;
	wc.cbSize = sizeof(WNDCLASSEX);

	if(::GetClassInfoEx(NULL, m_lpszClassName, &wc))
	{
		m_pfnSuperWindowProc = wc.lpfnWndProc;

        hr = StringCchPrintf( pszBuff, cchBuff, _T("ATL:%s"), m_lpszClassName );
        _ASSERTE( SUCCEEDED( hr ) );

		WNDCLASSEX wc1;
		wc1.cbSize = sizeof(WNDCLASSEX);
		atom = (ATOM)::GetClassInfoEx(_Module.GetModuleInstance(), pszBuff, &wc1);

		if(atom == 0)   // register class
		{
			wc.lpszClassName = pszBuff;
			wc.lpfnWndProc = StartWindowProc;
			wc.hInstance = _Module.GetModuleInstance();
			wc.style &= ~CS_GLOBALCLASS;	// we don't register global classes

			atom = ::RegisterClassEx(&wc);
		}
	}

Cleanup:

    delete [] pszBuff;

	return atom;
}

HWND CContainedWindow::Create(HWND hWndParent, RECT& rcPos,
	LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID)
{
	_ASSERTE(m_hWnd == NULL);

	ATOM atom = RegisterWndSuperclass();
	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
   {
#ifdef _WIN64
      nID = InterlockedIncrement( &g_nNextWindowID );
      nID |= 0x80000000;  // Make sure the ID isn't zero
#else
      nID = (UINT)this;
#endif
   }

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)(LONG_PTR)MAKELONG(atom, 0), szWindowName,
							dwStyle,
							rcPos.left, rcPos.top,
							rcPos.right - rcPos.left,
							rcPos.bottom - rcPos.top,
							hWndParent, (HMENU)(DWORD_PTR)nID,
							_Module.GetModuleInstance(), this);

	_ASSERTE(m_hWnd == hWnd);
	return hWnd;
}

BOOL CContainedWindow::SubclassWindow(HWND hWnd)
{
	_ASSERTE(m_hWnd == NULL);
	_ASSERTE(::IsWindow(hWnd));

	m_thunk.Init(WindowProc, this);
	WNDPROC pProc = (WNDPROC)m_thunk.thunk.pThunk;
   WNDPROC pfnWndProc = (WNDPROC)::SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)pProc);
	if(pfnWndProc == NULL)
		return FALSE;
	m_pfnSuperWindowProc = pfnWndProc;
	m_hWnd = hWnd;
	return TRUE;
}

HWND CContainedWindow::UnsubclassWindow()
{
	_ASSERTE(m_hWnd != NULL);

   if(!::SetWindowLongPtr(m_hWnd, GWLP_WNDPROC, (LONG_PTR)m_pfnSuperWindowProc))
		return NULL;
	m_pfnSuperWindowProc = ::DefWindowProc;

	HWND hWnd = m_hWnd;
	m_hWnd = NULL;

	return hWnd;
}

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

///////////////////////////////////////////////////////////////////////////////
//All Global stuff goes below this line
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __BARFCLUS_H_
#define __BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // __BARFCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\cladmwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClApdmWiz.cpp
//
//  Description:
//      Implementation of the DLL exports
//
//  Maintained By:
//      David Potter (davidp)   November 24, 1997
//
//  Notes:
//
//      Proxy/Stub Information
//
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ClAdmWiz.idl by adding the following 
//      files to the Outputs.
//          ClAdmWiz_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ClAdmWizps.mk in the project directory.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define __RESOURCE_H_
#include "initguid.h"
#include "dlldatax.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "WizObject.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CApp _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ClusAppWiz, CClusAppWizardObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Routine Description:
//      DLL Entry Point.
//
//  Arguments:
//      hInstance       Handle to this DLL.
//      dwReason        Reason this function was called.
//                          Can be Process/Thread Attach/Detach.
//      lpReserved      Reserved.
//
//  Return Value:
//      TRUE            No error.
//      FALSE           Error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
extern "C"
BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved )
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if ( ! PrxDllMain( hInstance, dwReason, lpReserved ) )
        return FALSE;
#endif
    if ( dwReason == DLL_PROCESS_ATTACH )
    {
#ifdef _DEBUG
        _CrtSetDbgFlag( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );
        _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_DEBUG );
#endif
        _Module.Init( ObjectMap, hInstance, IDS_CLASS_DISPLAY_NAME );
        DisableThreadLibraryCalls( hInstance );

        //
        // Initialize Fusion.
        //
        // The value of IDR_MANIFEST in the call to
        // SHFusionInitializeFromModuleID() must match the value specified in the
        // sources file for SXS_MANIFEST_RESOURCE_ID.
        //
        if ( ! SHFusionInitializeFromModuleID( hInstance, IDR_MANIFEST ) )
        {
#ifdef _DEBUG
            DWORD   sc = GetLastError();
            ASSERT( sc == ERROR_SUCCESS ); // this will always fire
#endif
        }

    } // if: DLL_PROCESS_ATTACH
    else if ( dwReason == DLL_PROCESS_DETACH )
    {
        SHFusionUninitialize();
        _Module.Term();
    } // else if: DLL_PROCESS_DETACH
    return TRUE;    // ok

} //*** DllMain()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllCanUnloadNow
//
//  Routine Description:
//      Used to determine whether the DLL can be unloaded by OLE.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        DLL can be unloaded.
//      S_FALSE     DLL can not be unloaded.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

} //*** DllCanUnloadNow()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllGetClassObject
//
//  Routine Description:
//      Returns a class factory to create an object of the requested type.
//
//  Arguments:
//      rclsid      CLSID of class desired.
//      riid        IID of interface on class factory desired.
//      ppv         Filled with interface pointer to class factory.
//
//  Return Value:
//      S_OK        Class object returned successfully.
//      Any status codes returned from _Module.GetClassObject().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);

} //*** DllGetClassObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Routine Description:
//      Registers the interfaces and objects that this DLL supports in the
//      system registry.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        DLL registered successfully.
//      Any status codes returned from _Module.RegisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer( FALSE /*bRegTypeLib*/ );

} //*** DllRegisterServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterServer
//
//  Routine Description:
//      Unregisters the interfaces and objects that this DLL supports in the
//      system registry.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK        DLL unregistered successfully.
//      Any status codes returned from _Module.UnregisterServer().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    _Module.UnregisterServer();
    return S_OK;

} //*** DllUnregisterServer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\clusappwizpage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusAppWizPage.h
//
//	Abstract:
//		Definitions of the CClusterAppWizardPage classes.
//
//	Implementation File:
//		None.
//
//	Author:
//		David Potter (davidp)	December 6, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSAPPWIZPAGE_H_
#define __CLUSAPPWIZPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class TBase > class CClusterAppWizardPage;
template < class T > class CClusterAppStaticWizardPage;
template < class T > class CClusterAppDynamicWizardPage;
template < class T > class CClusterAppExtensionWizardPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLBASEWIZPAGE_H_
#include "AtlBaseWizPage.h"	// for CBaseWizardPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class TBase >
class CClusterAppWizardPage : public TBase
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: TBase( lpszTitle )
	{
	} //*** CClusterAppWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppWizardPage(
		IN UINT nIDTitle
		)
		: TBase( nIDTitle )
	{
	} //*** CClusterAppWizardPage()

public:
	//
	// CClusterAppWizardPage public methods.
	//

public:
	//
	// Message handler functions.
	//

// Implementation
protected:
	CClusterAppWizard *		PwizThis( void ) const	{ return (CClusterAppWizard *) Pwiz(); }
	CLUSAPPWIZDATA const *	PcawData( void ) const	{ return PwizThis()->PcawData(); }

}; //*** class CClusterAppWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppStaticWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppStaticWizardPage : public CClusterAppWizardPage< CStaticWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppStaticWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CStaticWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppStaticWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppStaticWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CStaticWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppStaticWizardPage()

	// Handler for PSN_WIZFINISH
	BOOL OnWizardFinish( void )
	{
		return CBasePageWindow::OnWizardFinish();

	} //*** OnWizardFinish()

}; //*** class CClusterAppStaticWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppDynamicWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppDynamicWizardPage : public CClusterAppWizardPage< CDynamicWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppDynamicWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppDynamicWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppDynamicWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppDynamicWizardPage()

}; //*** class CClusterAppDynamicWizardPage

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppExtensionWizardPage
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CClusterAppExtensionWizardPage : public CClusterAppWizardPage< CExtensionWizardPageImpl< T > >
{
public:
	//
	// Construction
	//

	// Standard constructor
	CClusterAppExtensionWizardPage(
		IN OUT LPCTSTR lpszTitle = NULL
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( lpszTitle )
	{
	} //*** CClusterAppExtensionWizardPage()

	// Constructor taking a resource ID for the title
	CClusterAppExtensionWizardPage(
		IN UINT nIDTitle
		)
		: CClusterAppWizardPage< CDynamicWizardPageImpl< T > >( nIDTitle )
	{
	} //*** CClusterAppExtensionWizardPage()

}; //*** class CClusterAppExtensionWizardPage

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSAPPWIZPAGE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\clusobjs.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ClusObjS.cpp
//
//	Abstract:
//		Stub for implementation of the CClusterObject classes.
//
//	Author:
//		David Potter (davidp)	September 15, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusObj.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\complete.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Complete.h
//
//	Abstract:
//		Definition of the CWizPageCompletion class.
//
//	Implementation File:
//		Complete.cpp
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __COMPLETE_H_
#define __COMPLETE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageCompletion;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAG_H_
#include "ClusAppWizPage.h"	// for CClusterAppDynamicWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageCompletion
/////////////////////////////////////////////////////////////////////////////

class CWizPageCompletion : public CClusterAppDynamicWizardPage< CWizPageCompletion >
{
	typedef CClusterAppDynamicWizardPage< CWizPageCompletion > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageCompletion( void )
	{
	} //*** CWizPageCompletion()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = IDD_COMPLETION };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageCompletion )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic			m_staticTitle;
	CListViewCtrl	m_lvcProperties;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_COMPLETION; }

}; //*** class CWizPageCompletion

/////////////////////////////////////////////////////////////////////////////

#endif // __COMPLETE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\complete.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Complete.cpp
//
//	Abstract:
//		Implementation of the CWizPageCompletion class.
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Complete.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageCompletion
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageCompletion )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LISTBOX )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageCompletion::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None..
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageCompletion::OnInitDialog( void )
{
	//
	// Attach controls to control member variables.
	//
	AttachControl( m_staticTitle, IDC_WIZARD_TITLE );
	AttachControl( m_lvcProperties, IDC_WIZARD_LISTBOX );

	//
	// Set the font of the title control.
	//
	m_staticTitle.SetFont( PwizThis()->RfontExteriorTitle() );

	//
	// Initialize and add columns to the list view control.
	//
	{
		DWORD	_dwExtendedStyle;
		CString	_strWidth;
		int		_nWidth;

		//
		// Change list view control extended styles.
		//
		_dwExtendedStyle = m_lvcProperties.GetExtendedListViewStyle();
		m_lvcProperties.SetExtendedListViewStyle( 
			LVS_EX_FULLROWSELECT,
			LVS_EX_FULLROWSELECT
			);

		//
		// Insert the property name column.
		//
		_strWidth.LoadString( IDS_COMPLETED_PROP_NAME_WIDTH );
		_nWidth = _tcstoul( _strWidth, NULL, 10 );
		m_lvcProperties.InsertColumn( 0, _T(""), LVCFMT_LEFT, _nWidth, -1 );

		//
		// Insert the property value column.
		//
		_strWidth.LoadString( IDS_COMPLETED_PROP_VALUE_WIDTH );
		_nWidth = _tcstoul( _strWidth, NULL, 10 );
		m_lvcProperties.InsertColumn( 1, _T(""), LVCFMT_LEFT, _nWidth, -1 );

	} // Add columns

	return TRUE;

} //*** CWizPageCompletion::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageCompletion::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageCompletion::OnSetActive( void )
{
	int		_idxCurrent = 0;
	int		_idxActual;
	CString	_strPropName;
	CString	_strVirtualServer;
	CString	_strNetworkName;
	CString	_strIPAddress;
	CString	_strNetwork;
	CString	_strAppName;
	CString	_strResType;

	//
	// FILL THE LIST VIEW CONTROL WITH THE PROPERTIES THE USER SPECIFIED.
	//

	//
	// Remove all items from the list view control to begin with.
	//
	m_lvcProperties.DeleteAllItems();

	//
	// Collect the data.
	//
	if ( PwizThis()->BCreatingNewVirtualServer() )
	{
		_strVirtualServer = PwizThis()->RgiCurrent().RstrName();
		_strNetworkName = PwizThis()->RgiCurrent().RstrNetworkName();
		_strIPAddress = PwizThis()->RgiCurrent().RstrIPAddress();
		_strNetwork = PwizThis()->RgiCurrent().RstrNetwork();
	} // if:  created new virtual server
	else
	{
		_strVirtualServer = PwizThis()->PgiExistingVirtualServer()->RstrName();
		_strNetworkName = PwizThis()->PgiExistingVirtualServer()->RstrNetworkName();
		_strIPAddress = PwizThis()->PgiExistingVirtualServer()->RstrIPAddress();
		_strNetwork = PwizThis()->PgiExistingVirtualServer()->RstrNetwork();
	} // else:  used existing virtual server

	if ( PwizThis()->BCreatingAppResource() )
	{
		_strAppName = PwizThis()->RriApplication().RstrName();
		_strResType = PwizThis()->RriApplication().Prti()->RstrDisplayName();
	} // if:  created application resource

	//
	// Set the virtual server name.
	//
	_strPropName.LoadString( IDS_COMPLETED_VIRTUAL_SERVER );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strVirtualServer );

	//
	// Set the Network Name.
	//
	_strPropName.LoadString( IDS_COMPLETED_NETWORK_NAME );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strNetworkName );

	//
	// Set the IP Address.
	//
	_strPropName.LoadString( IDS_COMPLETED_IP_ADDRESS );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strIPAddress );

	//
	// Set the Network.
	//
	_strPropName.LoadString( IDS_COMPLETED_NETWORK );
	_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
	m_lvcProperties.SetItemText( _idxActual, 1, _strNetwork );

	//
	// If we created an application resource, add properties
	// for it as well.
	//
	if ( PwizThis()->BCreatingAppResource() )
	{
		//
		// Set the application resource name.
		//
		_strPropName.LoadString( IDS_COMPLETED_APP_RESOURCE );
		_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
		m_lvcProperties.SetItemText( _idxActual, 1, _strAppName );

		//
		// Set the application resource type.
		//
		_strPropName.LoadString( IDS_COMPLETED_APP_RESOURCE_TYPE );
		_idxActual = m_lvcProperties.InsertItem( _idxCurrent++, _strPropName );
		m_lvcProperties.SetItemText( _idxActual, 1, _strResType );
	} // if:  created application resource

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageCompletion::OnSetActive()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\clusappwiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusAppWiz.cpp
//
//  Abstract:
//      Implementation of the CClusterAppWizard class.
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusAppWiz.h"

#include "ExcOper.h"    // for CNTException
#include "WizThread.h"  // for CWizardThread

#include "Welcome.h"    // for CWizPageWelcome
#include "VSCreate.h"   // for CWizPageVSCreate
#include "VSGroup.h"    // for CWizPageVSGroup
#include "VSGrpName.h"  // for CWizPageVSGroupName
#include "VSAccess.h"   // for CWizPageVSAccessInfo
#include "VSAdv.h"      // for CWizPageVSAdvanced
#include "ARCreate.h"   // for CWizPageARCreate
#include "ARType.h"     // for CWizPageARType
#include "ARName.h"     // for CWizPageARNameDesc
#include "Complete.h"   // for CWizPageCompletion

#include "App.h"
#include "App.inl"

#include "StlUtils.h"   // for STL utility functions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizard
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CClusterAppWizard )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::CClusterAppWizard
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAppWizard::CClusterAppWizard( void )
    : CWizardImpl< CClusterAppWizard >( IDS_CLASS_DISPLAY_NAME )
    , m_hwndParent( NULL )
    , m_hCluster( NULL )
    , m_pcawData( NULL )
    , m_pnte( NULL )
    , m_bCanceled( FALSE )
    , m_pThread( NULL )

    , m_bCollectedGroups( FALSE )
    , m_bCollectedResources( FALSE )
    , m_bCollectedResourceTypes( FALSE )
    , m_bCollectedNetworks( FALSE )
    , m_bCollectedNodes( FALSE )

    , m_bClusterUpdated( FALSE )
    , m_bVSDataChanged( FALSE )
    , m_bAppDataChanged( FALSE )
    , m_bNetNameChanged( FALSE )
    , m_bIPAddressChanged( FALSE )
    , m_bNetworkChanged( FALSE )
    , m_bCreatingNewVirtualServer( TRUE )
    , m_bCreatingNewGroup( TRUE )
    , m_bCreatingAppResource( TRUE )
    , m_bNewGroupCreated( FALSE )
    , m_bExistingGroupRenamed( FALSE )

    , m_pgiExistingVirtualServer( NULL )
    , m_pgiExistingGroup( NULL )
    , m_giCurrent( &m_ci )
    , m_riIPAddress( &m_ci )
    , m_riNetworkName( &m_ci )
    , m_riApplication( &m_ci )

    , m_bEnableNetBIOS( TRUE )

    , m_hiconRes( NULL )
{
    m_psh.dwFlags &= ~PSH_WIZARD;
    m_psh.dwFlags |= PSH_WIZARD97
        | PSH_WATERMARK
        | PSH_HEADER
        | PSH_WIZARDCONTEXTHELP
        ;
    m_psh.pszbmWatermark = MAKEINTRESOURCE( IDB_WELCOME );
    m_psh.pszbmHeader = MAKEINTRESOURCE( IDB_HEADER );

} //*** CClusterAppWizard::CClusterAppWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::~CClusterAppWizard
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAppWizard::~CClusterAppWizard( void )
{
    ASSERT( ! BCanceled() ); // Cancel state should already have been handled by now

    //
    // Cleanup the worker thread.
    //
    if ( m_pThread != NULL )
    {
        //
        // Terminate the thread and then wait for it to exit.
        //
        PThread()->QuitThread( HwndParent() );
        PThread()->WaitForThreadToExit( HwndParent() );

        //
        // Cleanup the thread object.
        //
        delete m_pThread;
        m_pThread = NULL;
    } // if:  thread created

    //
    // Delete the lists.
    //
    DeleteListItems< CClusGroupPtrList,   CClusGroupInfo >( PlpgiGroups() );
    DeleteListItems< CClusResPtrList,     CClusResInfo >( PlpriResources() );
    DeleteListItems< CClusResTypePtrList, CClusResTypeInfo >( PlprtiResourceTypes() );
    DeleteListItems< CClusNetworkPtrList, CClusNetworkInfo >( PlpniNetworks() );
    DeleteListItems< CClusNodePtrList,    CClusNodeInfo >( PlpniNodes() );

} //*** CClusterAppWizard::~CClusterAppWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      hwndParent  [IN] Handle to parent window.
//      hCluster    [IN] Handle to cluster.
//      pcawData    [IN] Default data for the wizard.
//      pnte        [IN OUT] Exception object to fill if an error occurs.
//
//  Return Value:
//      TRUE        Wizard initialized successfully.
//      FALSE       Error initializing the wizard.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BInit(
    IN HWND                     hwndParent,
    IN HCLUSTER                 hCluster,
    IN CLUSAPPWIZDATA const *   pcawData,
    IN OUT CNTException *       pnte
    )
{
    ASSERT( hCluster != NULL );
    ASSERT( m_pnte == NULL );

    BOOL bSuccess = FALSE;

    m_hwndParent = hwndParent;
    m_hCluster = hCluster;
    m_pcawData = pcawData;
    m_pnte = pnte;
    m_ci.SetClusterHandle( hCluster );
    m_bCanceled = FALSE;

    m_strIPAddressResNameSuffix.LoadString( IDS_IP_ADDRESS_SUFFIX );
    m_strNetworkNameResNameSuffix.LoadString( IDS_NETWORK_NAME_SUFFIX );

    //
    // Set defaults from the data passed in.
    //
    if ( pcawData != NULL )
    {
        m_bCreatingNewVirtualServer = pcawData->bCreateNewVirtualServer;
        m_bCreatingNewGroup = pcawData->bCreateNewGroup;
        m_bCreatingAppResource = pcawData->bCreateAppResource;
        if ( pcawData->pszIPAddress != NULL )
        {
            m_strIPAddress = pcawData->pszIPAddress;
        } // if:  IP Address was specified
        if ( pcawData->pszNetwork != NULL )
        {
            m_strNetwork = pcawData->pszNetwork;
        } // if:  network was specified;
        if ( pcawData->pszAppResourceName != NULL )
        {
            m_riApplication.SetName( pcawData->pszAppResourceName );
        } // if:  application resource name specified
    } // if:  default data was passed in

    //
    // Add the standard resource types that we must have to operate.
    // We will be able to tell if they don't actually exist if they
    // continue to return FALSE from BQueried().
    //
    {
        CClusResTypeInfo * prti;

        //
        // Make sure these don't exist already.
        //
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_IPADDR ) == NULL );
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_NETNAME ) == NULL );
        ASSERT( PobjFromName( PlprtiResourceTypes(), CLUS_RESTYPE_NAME_GENAPP ) == NULL );

        //
        // Add the IP Address resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_IPADDR );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riIPAddress.BSetResourceType( prti );
        prti = NULL;

        //
        // Add the Network Name resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_NETNAME );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riNetworkName.BSetResourceType( prti );
        prti = NULL;

        //
        // Add the Generic Application resource type.
        prti = new CClusResTypeInfo( Pci(), CLUS_RESTYPE_NAME_GENAPP );
        if ( prti == NULL )
        {
            goto MemoryError;
        } // if: error allocating memory
        PlprtiResourceTypes()->insert( PlprtiResourceTypes()->end(), prti );
        m_riApplication.BSetResourceType( prti );
        prti = NULL;

    } // Add standard resource types to list

    //
    // Fill the page array.
    //
    if ( ! BAddAllPages() )
    {
        goto Cleanup;
    } // if: error adding all pages

    //
    // Call the base class.
    //
    if ( ! baseClass::BInit() )
    {
        goto Cleanup;
    } // if: error initializing the base class

    //
    // Create welcome and completion page title font.
    //
    if ( ! BCreateFont(
                m_fontExteriorTitle,
                IDS_EXTERIOR_TITLE_FONT_SIZE,
                IDS_EXTERIOR_TITLE_FONT_NAME,
                TRUE // bBold
                ) )
    {
        goto WinError;
    } // if: error creating the font

    //
    // Create bold font.
    //
    if ( ! BCreateFont(
                m_fontBoldText,
                8,
                _T("MS Shell Dlg"),
                TRUE // bBold
                ) )
    {
        goto WinError;
    } // if: error creating the font

    //
    // Load the resource icon.
    //
    m_hiconRes = LoadIcon( _Module.m_hInst, MAKEINTRESOURCE( IDB_RES_32 ) );
    if ( m_hiconRes == NULL )
    {
        goto WinError;
    } // if: error loading the font

    //
    // Initialize the worker thread.
    //
    if ( ! BInitWorkerThread() )
    {
        goto Cleanup;
    } // if:  error initializing the worker thread

    //
    // Read cluster information, such as the cluster name.
    //
    if ( ! BReadClusterInfo() )
    {
        goto Cleanup;
    } // if:  error reading cluster information

    //
    // Initialize group pointers, dependency lists, and resource lists.
    //
    RriNetworkName().PlpriDependencies()->insert( RriNetworkName().PlpriDependencies()->end(), PriIPAddress() );
    RriNetworkName().SetGroup( &RgiCurrent() );
    RriIPAddress().SetGroup( &RgiCurrent() );
    RriApplication().SetGroup( &RgiCurrent() );
    RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriIPAddress() );
    RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriNetworkName() );

    //
    // Specify the object to be extended.  The object to extend is the
    // application resource object for which pages will be added to the
    // wizard.
    //
    SetObjectToExtend( &RriApplication() );
    bSuccess = TRUE;

Cleanup:
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( static_cast< DWORD >( E_OUTOFMEMORY ), static_cast< UINT >( 0 ) );
    goto Cleanup;

WinError:
    {
        DWORD   sc = GetLastError();
        m_pnte->SetOperation( static_cast< DWORD >( HRESULT_FROM_WIN32( sc ) ), static_cast< UINT >( 0 ) );
    }
    goto Cleanup;

} //*** CClusterAppWizard::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BAddAllPages
//
//  Routine Description:
//      Initialize the wizard page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BAddAllPages( void )
{
    ASSERT( m_pnte != NULL );

    BOOL                bSuccess    = FALSE;
    CWizardPageWindow * pwpw        = NULL;

    //
    // Add static pages.
    //

    pwpw = new CWizPageWelcome;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSCreate;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSGroup;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSGroupName;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSAccessInfo;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageVSAdvanced;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARCreate;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARType;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = new CWizPageARNameDesc;
    if ( pwpw == NULL )
    {
        goto MemoryError;
    };
    if ( ! BAddPage( pwpw ) )
    {
        goto Cleanup;
    } // if: error adding the page

    pwpw = NULL;

    //
    // Add dynamic pages, which includes the Completion page.
    //
    if ( ! BAddDynamicPages() )
    {
        goto Cleanup;
    } // if:  error adding the completion page

    //
    // Enable the first page.
    //
    pwpw = *PlwpPages()->begin();
    ASSERT( pwpw != NULL );
    pwpw->EnablePage();

    bSuccess = TRUE;
    pwpw = NULL;

Cleanup:
    delete pwpw;
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( static_cast< DWORD >( E_OUTOFMEMORY ), static_cast< UINT >( 0 ) );
    goto Cleanup;

} //*** CClusterAppWizard::BAddAllPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BAddDynamicPages
//
//  Routine Description:
//      Add dynamic pages to the wizard, which includes the Completion page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BAddDynamicPages( void )
{
    ASSERT( m_pnte != NULL );

    DWORD                   sc;
    BOOL                    bSuccess    = FALSE;
    CWizPageCompletion *    pwp         = NULL;

    //
    // Allocate the Completion page.
    //
    pwp = new CWizPageCompletion;
    if ( pwp == NULL )
    {
        goto MemoryError;
    } // if:  error allocating the Completion page

    //
    // Initialize the page.
    //
    if ( ! pwp->BInit( this ) )
    {
        goto Cleanup;
    } // if:  error initializing the page

    //
    // Enable the page.  This is done because this page
    // will always reside after extension pages and must be
    // enabled or the user won't be able to finish.
    //
    pwp->EnablePage();

    //
    // Create the page.
    //
    sc = pwp->ScCreatePage();
    if ( sc != ERROR_SUCCESS )
    {
        m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CREATE_WIZ_PROPERTY_PAGE );
        goto Cleanup;
    } // if:  error creating the page

    //
    // Add the page.
    //
    if ( ! BAddPage( pwp ) )
    {
        goto Cleanup;
    } // if:  error adding the page

    pwp = NULL;
    bSuccess = TRUE;

Cleanup:
    delete pwp;
    return bSuccess;

MemoryError:
    m_pnte->SetOperation( static_cast< DWORD >( E_OUTOFMEMORY ), static_cast< UINT >( 0 ) );
    goto Cleanup;

} //*** CClusterAppWizard::HrAddDynamicPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BInitWorkerThread
//
//  Routine Description:
//      Get a worker thread.  If one isn't available and we haven't reached
//      the maximum number of threads, create a new thread.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Thread initialized successfully.
//      FALSE       Error initializing the thread.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BInitWorkerThread( void )
{
    ASSERT( m_pThread == NULL );
    ASSERT( m_pnte != NULL );

    BOOL            bSuccess    = FALSE;
    DWORD           sc          = ERROR_SUCCESS;
    CWizardThread * pThread     = NULL;

    //
    // Take out the thread critical section so we can make changes to
    // the thread pool.
    //
    m_csThread.Lock();

    {
        CWaitCursor     wc;

        //
        // Allocate a new worker thread class instance.
        //
        pThread = new CWizardThread( this );
        if ( pThread == NULL )
        {
            m_pnte->SetOperation( static_cast< DWORD >( E_OUTOFMEMORY ), static_cast< ULONG >( 0 ) );
            goto Cleanup;
        } // if:  error allocation the thread

        //
        // Create the worker thread.
        //
        sc = pThread->CreateThread();
        if ( sc != ERROR_SUCCESS )
        {
            m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_CREATING_THREAD );
            goto Cleanup;
        } // if:  error creating the thread

        //
        // Save the pointer to the thread we just created.
        //
        m_pThread = pThread;
        pThread = NULL;
        bSuccess = TRUE;
    }

Cleanup:
    //
    // Release the thread critical section.
    //
    m_csThread.Unlock();

    return bSuccess;

} //*** CClusterAppWizard::BInitWorkerThread()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BReadClusterInfo
//
//  Routine Description:
//      Read cluster information, such as the cluster name.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BReadClusterInfo( void )
{
    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BReadClusterInfo( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error collecting groups

    return bSuccess;

} //*** CClusterAppWizard::BReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectGroups
//
//  Routine Description:
//      Collect a list of groups from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectGroups( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedGroups() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectGroups( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting groups
    } // if:  groups not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  groups already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectResources
//
//  Routine Description:
//      Collect a list of resources from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectResources( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedResources() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectResources( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting resources
    } // if:  resources not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  resources already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectResourceTypes
//
//  Routine Description:
//      Collect a list of resource types from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectResourceTypes( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedResourceTypes() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectResourceTypes( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting resource types
    } // if:  resource types not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  resource types already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectNetworks
//
//  Routine Description:
//      Collect a list of networks from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectNetworks( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedNetworks() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectNetworks( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting networks
    } // if:  networks not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  networks already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectNodes
//
//  Routine Description:
//      Collect a list of nodes from the cluster.
//
//  Arguments:
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectNodes( IN HWND hWnd /* = NULL */ )
{
    BOOL bSuccess;

    if ( ! BCollectedNodes() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectNodes( hWnd );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting nodes
    } // if:  nodes not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  nodes already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCopyGroupInfo
//
//  Routine Description:
//      Copy one group info object to another.
//
//  Arguments:
//      rgiDst      [OUT] Destination group.
//      rgiSrc      [IN] Source group.
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCopyGroupInfo(
    OUT CClusGroupInfo &    rgiDst,
    IN CClusGroupInfo &     rgiSrc,
    IN HWND                 hWnd // = NULL
    )
{
    BOOL                bSuccess;
    CClusGroupInfo *    rgGroups[ 2 ] = { &rgiDst, &rgiSrc };

    hWnd = HwndOrParent( hWnd );

    bSuccess = PThread()->BCopyGroupInfo( hWnd, rgGroups );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error copying the group

    return bSuccess;

} //*** CClusterAppWizard::BCopyGroupInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCollectDependencies
//
//  Routine Description:
//      Collect dependencies for a resource.
//
//  Arguments:
//      pri         [IN OUT] Resource to collect dependencies for.
//      hWnd        [IN] Parent window.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCollectDependencies(
    IN OUT CClusResInfo *   pri,
    IN HWND                 hWnd /* = NULL */
    )
{
    ASSERT( pri != NULL );

    BOOL bSuccess;

    if ( ! pri->BCollectedDependencies() )
    {
        hWnd = HwndOrParent( hWnd );

        bSuccess = PThread()->BCollectDependencies( hWnd, pri );
        if ( ! bSuccess )
        {
            PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
        } // if:  error collecting groups
    } // if:  dependencies not collected yet
    else
    {
        bSuccess = TRUE;
    } // else:  dependencies already collected

    return bSuccess;

} //*** CClusterAppWizard::BCollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BIsVirtualServer
//
//  Routine Description:
//      Determine if the group is a virtual server or not.
//
//  Arguments:
//      pwszName    Name of the group.
//
//  Return Value:
//      TRUE        Group is a virtual server.
//      FALSE       Group is not a virtual server, or an error occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BIsVirtualServer( IN LPCWSTR pwszName )
{
    ASSERT( pwszName != NULL );
    ASSERT( BCollectedGroups() );

    //
    // Find the group name in the map.  If found and the group has been
    // queried already, just return the result of the previous query.
    //
    CClusGroupPtrList::iterator itgrp;
    for ( itgrp = PlpgiGroups()->begin() ; itgrp != PlpgiGroups()->end() ; itgrp++ )
    {
        if ( (*itgrp)->RstrName() == pwszName )
        {
            break;
        } // if:  match found
    } // for:  each item in the list
    if ( itgrp == PlpgiGroups()->end() )
    {
        return FALSE;
    } // if:  no match found
    ASSERT( (*itgrp)->BQueried() );
    return (*itgrp)->BIsVirtualServer();

} //*** CClusterAppWizard::BIsVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCreateVirtualServer
//
//  Routine Description:
//      Create the virtual server.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Virtual server created successfully.
//      FALSE       Error creating the virtual server.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCreateVirtualServer( void )
{
    ASSERT( BCreatingNewVirtualServer() );
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BCreateVirtualServer( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error creating the virtual server

    return bSuccess;

} //*** CClusterAppWizard::BCreateVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BCreateAppResource
//
//  Routine Description:
//      Create the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource created successfully.
//      FALSE       Error creating the resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BCreateAppResource( void )
{
    ASSERT( BCreatingAppResource() );
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BCreateAppResource( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error creating the resource

    return bSuccess;

} //*** CClusterAppWizard::BCreateAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BDeleteAppResource
//
//  Routine Description:
//      Delete the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Resource deleted successfully.
//      FALSE       Error deleted the resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BDeleteAppResource( void )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BDeleteAppResource( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error deleting the resource

    return bSuccess;

} //*** CClusterAppWizard::BDeleteAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BResetCluster
//
//  Routine Description:
//      Reset the cluster back to the state it was in before we started.
//
//  Arguments:
//      pwszName    Name of the group.
//
//  Return Value:
//      TRUE        Cluster reset successfully.
//      FALSE       Error resetting the cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BResetCluster( void )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BResetCluster( hWnd );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error resetting the cluster

    return bSuccess;

} //*** CClusterAppWizard::BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetAppResAttributes
//
//  Routine Description:
//      Set the properties, dependency list and preferred owner list of the
//      application resource. Assumes that the application resource has 
//      already been created.
//
//  Arguments:
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Successfully set the attributes.
//      FALSE       Error setting the attributes.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetAppResAttributes( 
    IN CClusResPtrList *    plpriOldDependencies,   // = NULL
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    ASSERT( Hcluster() != NULL );

    BOOL    bSuccess;
    HWND    hWnd;

    hWnd = HwndOrParent( NULL );

    bSuccess = PThread()->BSetAppResAttributes( hWnd, plpriOldDependencies, plpniOldPossibleOwners );
    if ( ! bSuccess )
    {
        PThread()->Nte().ReportError( hWnd, MB_OK | MB_ICONEXCLAMATION );
    } // if:  error resetting the cluster

    return bSuccess;

} //*** CClusterAppWizard::BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::ConstructNetworkName
//
//  Routine Description:
//      Construct the network name from a string by converting to all
//      uppercase and removing invalid characters.  For now that means
//      removing spaces, although there are probably other characters we
//      should look at as well.
//
//  Arguments:
//      pszName     String to construct the network name from.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAppWizard::ConstructNetworkName( IN LPCTSTR pszName )
{
    CString str;
    LPTSTR  pszSrcStart;
    LPTSTR  pszSrcBegin;
    LPTSTR  pszSrcEnd;
    LPTSTR  pszDst;
    size_t  cchCopy;
    size_t  cchName;
    HRESULT hr;

#define INVALID_CHARS _T(" ")

    //
    // Convert the string to all uppercase characters.well.
    //
    m_strNetName = pszName;
    m_strNetName.MakeUpper();

    //
    // Prepare the buffer for parsing.
    //
    pszSrcStart = pszSrcEnd = m_strNetName.GetBuffer( 0 );
    cchName = m_strNetName.GetLength() + 1;

    //
    // Skip to the first invalid character.
    //
    cchCopy = _tcscspn( pszSrcEnd, INVALID_CHARS );
    pszSrcEnd += cchCopy;
    pszDst = pszSrcEnd;

    //
    // Loop through the buffer moving valid characters up in the buffer
    // over invalid characters.
    //
    while ( *pszSrcEnd != _T('\0') )
    {
        ASSERT( _tcsspn( pszSrcEnd, INVALID_CHARS ) != 0 );

        //
        // Find the first valid character.
        //
        pszSrcBegin = pszSrcEnd + _tcsspn( pszSrcEnd, INVALID_CHARS );
        if ( *pszSrcBegin == _T('\0') )
        {
            break;
        } // if:  no vald characters found

        //
        // Find the next invalid character.
        //
        cchCopy = _tcscspn( pszSrcBegin, INVALID_CHARS );
        pszSrcEnd = pszSrcBegin + cchCopy;

        //
        // Copy the string to the destination.
        //
        hr = StringCchCopyN( pszDst, cchName - ( pszDst - pszSrcStart ), pszSrcBegin, cchCopy );
        ASSERT( SUCCEEDED( hr ) );
        pszDst += cchCopy;
    } // while:  more characters in the string

    //
    // Make sure the buffer isn't too long.
    //
    if ( _tcslen( pszSrcStart ) > MAX_COMPUTERNAME_LENGTH )
    {
        pszSrcStart[ MAX_COMPUTERNAME_LENGTH ] = _T('\0');
    } // if:  string is too long

    //
    // Release the buffer back to the CString class.
    //
    *pszDst = _T('\0');
    m_strNetName.ReleaseBuffer();

    SetVSDataChanged();
    SetNetNameChanged();

} //*** CClusterAppWizard::ConstructNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if all required dependencies are present on a resource
//
//  Arguments:
//      pri         [IN] Resource to check against.
//      plpri       [IN] List of resources considered dependencies.
//                      Defaults to specified resource's dependencies.
//
//  Return Value:
//      TRUE        All required dependencies are present.
//      FALSE       At least one required dependency is not present.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BRequiredDependenciesPresent(
    IN CClusResInfo *           pri,
    IN CClusResPtrList const *  plpri   // = NULL
    )
{
    ASSERT( pri != NULL );

    BOOL    bFound;
    CString strMissing;
    CString strMsg;
    BOOL    bMissingTypeName;

    bFound = pri->BRequiredDependenciesPresent(
                    plpri,
                    strMissing,
                    bMissingTypeName
                    );
    if ( ! bFound )
    {
        //
        // If missing a resource type name, translate it to
        // the resource type display name, if possible.
        //
        if ( bMissingTypeName )
        {
            CClusResTypeInfo * prti = PrtiFindResourceTypeNoCase( strMissing );
            if ( prti != NULL )
            {
                strMissing = prti->RstrDisplayName();
            } // if:  found resource type in our list
        } // if:  missing a type name

        //
        // Display an error message.
        //
        strMsg.FormatMessage( IDS_ERROR_REQUIRED_DEPENDENCY_NOT_FOUND, strMissing );
        AppMessageBox( GetActiveWindow(), strMsg, MB_OK | MB_ICONSTOP );
    } // if:  all required dependencies not present

    return bFound;

} //*** CClusterAppWizard::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetCreatingNewVirtualServer
//
//  Routine Description:
//      Indicate whether a new virtual server should be created or if an
//      existing group should be used.  If this state changes and changes
//      have already been made to the cluster (such as if the user backed
//      up in the wizard), undo those changes first.
//
//  Arguments:
//      bCreate     [IN] New value of this state.
//      pgi         [IN] Group info if using existing virtual server.
//
//  Return Value:
//      TRUE        State changed successfully.
//      FALSE       Error occurred changing state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetCreatingNewVirtualServer(
    IN BOOL             bCreate,    // = TRUE
    IN CClusGroupInfo * pgi         // = NULL
    )
{
    BOOL bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        //
        // If the state changed or the group changed, save the new state.
        //
        if (   bCreate != BCreatingNewVirtualServer()
            || (! bCreate && (pgi != PgiExistingVirtualServer())) )
        {
            //
            // If the cluster has been updated, reset it back to its original state.
            //
            if ( BClusterUpdated() )
            {
                if ( ! BResetCluster() )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  error resetting the cluster
            } // if:  cluster was updated

            //
            // Save the new state.
            //
            m_bCreatingNewVirtualServer = bCreate;
            if ( bCreate )
            {
                RgiCurrent().Reset( Pci() );
                ClearExistingVirtualServer();
            } // if:  creating new virtual server
            else
            {
                ASSERT( pgi != NULL );
                bSuccess = BCopyGroupInfo( RgiCurrent(), *pgi );
                if ( bSuccess )
                {
                    SetExistingVirtualServer( pgi );
                } // if:  group copied successfully
            } // else:  using existing virtual server
            SetVSDataChanged();
        } // if:  state changed
    } while ( 0 );

    return bSuccess;

} //*** CClusterAppWizard::BSetCreatingNewVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAppWizard::BSetCreatingNewGroup
//
//  Routine Description:
//      Indicate whether a new group should be created or if an existing group
//      should be used.  If this state changes and changes have already been
//      made to the cluster (such as if the user backed up in the wizard),
//      undo those changes first.
//
//  Arguments:
//      bCreate     [IN] New value of this state.
//      pgi         [IN] Group info if using existing group.
//
//  Return Value:
//      TRUE        State changed successfully.
//      FALSE       Error occurred changing state.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAppWizard::BSetCreatingNewGroup(
    IN BOOL             bCreate,    // = TRUE
    IN CClusGroupInfo * pgi         // = NULL
    )
{
    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's.
    do
    {
        //
        // If the state changed or the group changed, save the new state.
        //
        if (   bCreate != BCreatingNewGroup()
            || (! bCreate && (pgi != PgiExistingGroup())) )
        {
            //
            // If the cluster has been updated, reset it back to its original state.
            //
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                bSuccess = FALSE;
                break;
            } // if:  error resetting the cluster

            //
            // Save the new state.
            //
            if ( bCreate )
            {
                RgiCurrent().Reset( Pci() );
                ClearExistingGroup();
            } // if:  creating new group
            else
            {
                ASSERT( pgi != NULL );

                if ( ! BSetGroupName( pgi->RstrName() ) )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  error setting the group name

                sc = RgiCurrent().ScCopy( *pgi );

                //
                // Copy destroys original list of resources in the group.
                // Re-add the IP address and NetName resources to the list
                // of resources in this group.
                //
                RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriIPAddress() );
                RgiCurrent().PlpriResources()->insert( RgiCurrent().PlpriResources()->end(), &RriNetworkName() );

                if ( sc != ERROR_SUCCESS )
                {
                    m_pnte->SetOperation( HRESULT_FROM_WIN32( sc ), IDS_ERROR_OPEN_GROUP );
                    bSuccess = FALSE;
                } // if: error copying the group
                SetExistingGroup( pgi );
            } // else:  using existing group
            m_bCreatingNewGroup = bCreate;
            SetVSDataChanged();
        } // if:  state changed
    } while ( 0 );

    return bSuccess;

} //*** CClusterAppWizard::BSetCreatingNewGroup()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "ClAdmWiz_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\clusappwiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      ClusAppWiz.h
//
//  Abstract:
//      Definition of the CClusterAppWizard class.
//
//  Implementation File:
//      ClusAppWiz.cpp
//
//  Author:
//      David Potter (davidp)   December 2, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSAPPWIZ_H_
#define __CLUSAPPWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizardThread;
class CWizPageCompletion;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __ATLDBGWIN_H_
#include "AtlDbgWin.h"  // for DECLARE_CLASS_NAME
#endif

#ifndef __ATLBASEWIZ_H_
#include "AtlBaseWiz.h" // for CWizardImpl
#endif

#ifndef __CRITSEC_H_
#include "CritSec.h"    // for CCritSec
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"    // for CClusterObject, etc.
#endif

#ifndef __EXCOPER_H_
#include "ExcOper.h"    // for CNTException
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterAppWizard
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard : public CWizardImpl< CClusterAppWizard >
{
    typedef CWizardImpl< CClusterAppWizard > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CClusterAppWizard( void );

    // Destructor
    ~CClusterAppWizard( void );

    // Initialize the sheet
    BOOL BInit(
        IN HWND                     hwndParent,
        IN HCLUSTER                 hCluster,
        IN CLUSAPPWIZDATA const *   pcawData,
        IN OUT CNTException *       pnte
        );

    // Add all pages to the page array
    BOOL BAddAllPages( void );

    // Handle a reset from one of the pages
    void OnReset( void )
    {
        m_bCanceled = TRUE;

    } //*** OnReset()

public:
    //
    // CClusterAppWizard public methods.
    //

    // Wait for group data collection to be completed
    void WaitForGroupsToBeCollected( void )
    {
    } //*** WaitForGroupsToBeCollected()

    // Determine if the group is a virtual server or not
    BOOL BIsVirtualServer( IN LPCWSTR pwszName );

    // Create a virtual server
    BOOL BCreateVirtualServer( void );

    // Create an application resource
    BOOL BCreateAppResource( void );

    // Delete the application resource
    BOOL BDeleteAppResource( void );

    // Reset the cluster
    BOOL BResetCluster( void );

    // Set the properties, dependency list and preferred owner list of the
    // application resource
    BOOL CClusterAppWizard::BSetAppResAttributes(
        IN CClusResPtrList *    plpriOldDependencies    = NULL,
        IN CClusNodePtrList *   plpniOldPossibleOwners  = NULL
        );

    // Set the group name and update any other names that are calculated from it
    BOOL BSetGroupName( IN LPCTSTR pszGroupName )
    {
        if ( RgiCurrent().RstrName() != pszGroupName )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster

            RriNetworkName().SetName( pszGroupName + m_strNetworkNameResNameSuffix );
            RriIPAddress().SetName( pszGroupName + m_strIPAddressResNameSuffix );
            RgiCurrent().SetName( pszGroupName );
            ConstructNetworkName( pszGroupName );
            SetVSDataChanged();
        } // if:  group name changed

        return TRUE;

    } //*** BSetGroupName()

    // Find an object in a list
    template < class ObjT >
    ObjT PobjFind( IN std::list< ObjT > * pList, IN LPCTSTR pszName )
    {
        ASSERT( pszName != NULL );

        ObjT pobj = NULL;

        //
        // Find the name in the list.
        //
        std::list< ObjT >::iterator itpobj;
        for ( itpobj = pList->begin()
            ; itpobj != pList->end()
            ; itpobj++ )
        {
            if ( (*itpobj)->RstrName() == pszName )
            {
                pobj = *itpobj;
                break;
            } // if:  match found
        } // for:  each item in the list

        return pobj;

    } //*** PobjFind()

    // Find an object in a list, ignoring case
    template < class ObjT >
    ObjT PobjFindNoCase( IN std::list< ObjT > * pList, IN LPCTSTR pszName )
    {
        ASSERT( pszName != NULL );

        ObjT pobj = NULL;

        //
        // Find the name in the list.
        //
        std::list< ObjT >::iterator itpobj;
        for ( itpobj = pList->begin()
            ; itpobj != pList->end()
            ; itpobj++ )
        {
            if ( (*itpobj)->RstrName().CompareNoCase( pszName ) == 0 )
            {
                pobj = *itpobj;
                break;
            } // if:  match found
        } // for:  each item in the list

        return pobj;

    } //*** PobjFindNoCase()

    // Find a node in our list
    CClusNodeInfo * PniFindNode( IN LPCTSTR pszName )
    {
        return PobjFind( PlpniNodes(), pszName );

    } //*** PniFindNode()

    // Find a node in our list, ignoring case
    CClusNodeInfo * PniFindNodeNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpniNodes(), pszName );

    } //*** PniFindNodeNoCase()

    // Find a group in our list
    CClusGroupInfo * PgiFindGroup( IN LPCTSTR pszName )
    {
        return PobjFind( PlpgiGroups(), pszName );

    } //*** PgiFindGroups()

    // Find a group in our list, ignoring case
    CClusGroupInfo * PgiFindGroupNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpgiGroups(), pszName );

    } //*** PgiFindGroupsNoCase()

    // Find a resource in our list
    CClusResInfo * PriFindResource( IN LPCTSTR pszName )
    {
        return PobjFind( PlpriResources(), pszName );

    } //*** PriFindResource()

    // Find a resource in our list, ignoring case
    CClusResInfo * PriFindResourceNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpriResources(), pszName );

    } //*** PriFindResourceNoCase()

    // Find a resource type in our list
    CClusResTypeInfo * PrtiFindResourceType( IN LPCTSTR pszName )
    {
        return PobjFind( PlprtiResourceTypes(), pszName );

    } //*** PrtiFindResourceType()

    // Find a resource type in our list, ignoring case
    CClusResTypeInfo * PrtiFindResourceTypeNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlprtiResourceTypes(), pszName );

    } //*** PrtiFindResourceTypeNoCase()

    // Find a network in our list
    CClusNetworkInfo * PniFindNetwork( IN LPCTSTR pszName )
    {
        return PobjFind( PlpniNetworks(), pszName );

    } //*** PniFindNetwork()

    // Find a network in our list, ignoring case
    CClusNetworkInfo * PniFindNetworkNoCase( IN LPCTSTR pszName )
    {
        return PobjFindNoCase( PlpniNetworks(), pszName );

    } //*** PniFindNetworkNoCase()

    // Determine if all required dependencies are present on a resource
    BOOL BRequiredDependenciesPresent(
        IN CClusResInfo *           pri,
        IN CClusResPtrList const *  plpri = NULL
        );

public:
    //
    // Multithreading support.
    //

    // Initialize the worker thread
    BOOL BInitWorkerThread( void );

    // Return the thread.
    CWizardThread * PThread( void )
    {
        ASSERT( m_pThread != NULL );
        return m_pThread;

    } //*** PThread( void )

protected:
    CCritSec        m_csThread; // Critical section for initializing thread.
    CWizardThread * m_pThread;  // Worker thread pointer.

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CClusterAppWizard )
//      CHAIN_MSG_MAP( baseClass )
//  END_MSG_MAP()

    DECLARE_CLASS_NAME()

    //
    // Message override functions.
    //

    // Handler for the final message after WM_DESTROY
    void OnFinalMessage( HWND hWnd )
    {
        //
        // If the user canceled the wizard, reset the cluster back to
        // the state it was in before we ran.
        //
        if ( BCanceled() )
        {
            BResetCluster();
            m_bCanceled = FALSE;
        } // if:  wizard was canceled

    } //*** OnFinalMessage()

// Implementation
protected:
    HWND                    m_hwndParent;
    HCLUSTER                m_hCluster;
    CLUSAPPWIZDATA const *  m_pcawData;
    CNTException *          m_pnte;
    CClusterInfo            m_ci;
    BOOL                    m_bCanceled;

    // Construct a network name
    void ConstructNetworkName( IN LPCTSTR psz );

    //
    // Fonts
    //
    CFont           m_fontExteriorTitle;
    CFont           m_fontBoldText;

    //
    // Icons
    //
    HICON           m_hiconRes;

    //
    // Object lists.
    //
    CClusNodePtrList    m_lpniNodes;
    CClusGroupPtrList   m_lpgiGroups;
    CClusResPtrList     m_lpriResources;
    CClusResTypePtrList m_lprtiResourceTypes;
    CClusNetworkPtrList m_lpniNetworks;

    BOOL    m_bCollectedGroups;
    BOOL    m_bCollectedResources;
    BOOL    m_bCollectedResourceTypes;
    BOOL    m_bCollectedNetworks;
    BOOL    m_bCollectedNodes;

    //
    // Helper Methods
    //
protected:
    HWND HwndOrParent( IN HWND hWnd )
    {
        if ( hWnd == NULL )
        {
            hWnd = m_hWnd;
            if ( hWnd == NULL )
            {
                hWnd = HwndParent();
            } // if:  no wizard window yet
        } // if:  no window specified

        return hWnd;

    } //*** HwndOrParent()

public:
    // Remove the Completion page so extension pages can be added
    void RemoveCompletionPage( void );

    // Add dynamic pages to the end of the wizard, including the Completion page
    BOOL BAddDynamicPages( void );

    // Remove all extension pages.
    void RemoveExtensionPages( void )   { baseClass::RemoveAllExtensionPages(); }

    CFont & RfontExteriorTitle( void )  { return m_fontExteriorTitle; }
    CFont & RfontBoldText( void )       { return m_fontBoldText; }

    HWND                    HwndParent( void ) const    { return m_hwndParent; }
    HCLUSTER                Hcluster( void ) const      { return m_hCluster; }
    CLUSAPPWIZDATA const *  PcawData( void ) const      { return m_pcawData; }
    CClusterInfo *          Pci( void )                 { return &m_ci; }
    BOOL                    BCanceled( void ) const     { return m_bCanceled; }
    HICON                   HiconRes( void ) const      { return m_hiconRes; }

    CClusNodePtrList *      PlpniNodes( void )          { return &m_lpniNodes; }
    CClusGroupPtrList *     PlpgiGroups( void )         { return &m_lpgiGroups; }
    CClusResPtrList *       PlpriResources( void )      { return &m_lpriResources; }
    CClusResTypePtrList *   PlprtiResourceTypes( void ) { return &m_lprtiResourceTypes; }
    CClusNetworkPtrList *   PlpniNetworks( void )       { return &m_lpniNetworks; }

    // Read cluster information, such as the cluster name
    BOOL BReadClusterInfo( void );

    // Collect a list of groups from the cluster
    BOOL BCollectGroups( IN HWND hWnd = NULL );

    // Collect a list of resources from the cluster
    BOOL BCollectResources( IN HWND hWnd = NULL );

    // Collect a list of resource types from the cluster
    BOOL BCollectResourceTypes( IN HWND hWnd = NULL );

    // Collect a list of networks from the cluster
    BOOL BCollectNetworks( IN HWND hWnd = NULL );

    // Collect a list of nodes from the cluster
    BOOL BCollectNodes( IN HWND hWnd = NULL );

    // Copy one group info object to another
    BOOL BCopyGroupInfo(
        OUT CClusGroupInfo &    rgiDst,
        IN CClusGroupInfo &     rgiSrc,
        IN HWND                 hWnd = NULL
        );

    // Collect dependencies for a resource
    BOOL BCollectDependencies( IN OUT CClusResInfo * pri, IN HWND hWnd = NULL );

    BOOL BCollectedGroups( void ) const         { return m_bCollectedGroups; }
    BOOL BCollectedResources( void ) const      { return m_bCollectedResources; }
    BOOL BCollectedResourceTypes( void ) const  { return m_bCollectedResourceTypes; }
    BOOL BCollectedNetworks( void ) const       { return m_bCollectedNetworks; }
    BOOL BCollectedNodes( void ) const          { return m_bCollectedNodes; }

    void SetCollectedGroups( void )             { ASSERT( ! m_bCollectedGroups ); m_bCollectedGroups = TRUE; }
    void SetCollectedResources( void )          { ASSERT( ! m_bCollectedResources ); m_bCollectedResources = TRUE; }
    void SetCollectedResourceTypes( void )      { ASSERT( ! m_bCollectedResourceTypes ); m_bCollectedResourceTypes = TRUE; }
    void SetCollectedNetworks( void )           { ASSERT( ! m_bCollectedNetworks ); m_bCollectedNetworks = TRUE; }
    void SetCollectedNodes( void )              { ASSERT( ! m_bCollectedNodes ); m_bCollectedNodes = TRUE; }

protected:
    //
    // Page data.
    //

    // State information.
    BOOL m_bClusterUpdated;
    BOOL m_bVSDataChanged;
    BOOL m_bAppDataChanged;
    BOOL m_bNetNameChanged;
    BOOL m_bIPAddressChanged;
    BOOL m_bSubnetMaskChanged;
    BOOL m_bNetworkChanged;
    BOOL m_bCreatingNewVirtualServer;
    BOOL m_bCreatingNewGroup;
    BOOL m_bCreatingAppResource;
    BOOL m_bNewGroupCreated;
    BOOL m_bExistingGroupRenamed;

    // Common properties.
    CClusGroupInfo *    m_pgiExistingVirtualServer;
    CClusGroupInfo *    m_pgiExistingGroup;
    CClusGroupInfo      m_giCurrent;
    CClusResInfo        m_riIPAddress;
    CClusResInfo        m_riNetworkName;
    CClusResInfo        m_riApplication;

    // Private properties.
    CString         m_strIPAddress;
    CString         m_strSubnetMask;
    CString         m_strNetwork;
    CString         m_strNetName;
    BOOL            m_bEnableNetBIOS;

    // Names used to create/rename objects so we can undo it.
    CString         m_strGroupName;

    // Strings for constructing resource names.
    CString         m_strIPAddressResNameSuffix;
    CString         m_strNetworkNameResNameSuffix;

    // Set pointer to existing virtual server to create app in
    void SetExistingVirtualServer( IN CClusGroupInfo * pgi )    
    {
        ASSERT( pgi != NULL );

        if ( m_pgiExistingVirtualServer != pgi )
        {
            m_pgiExistingVirtualServer = pgi;
            SetVSDataChanged();
        } // if:  new virtual server selected

    } //*** SetExistingVirtualServer()

    // Set pointer to existing group to use for virtual server
    void SetExistingGroup( IN CClusGroupInfo * pgi )
    {
        ASSERT( pgi != NULL );

        if ( m_pgiExistingGroup != pgi )
        {
            m_pgiExistingGroup = pgi;
            SetVSDataChanged();
        } // if:  new group selected

    } //*** SetExistingGroup()

public:
    //
    // Access methods.
    //

    // State information -- READ.
    BOOL BClusterUpdated( void ) const              { return m_bClusterUpdated; }
    BOOL BVSDataChanged( void ) const               { return m_bVSDataChanged; }
    BOOL BAppDataChanged( void ) const              { return m_bAppDataChanged; }
    BOOL BNetNameChanged( void ) const              { return m_bNetNameChanged; }
    BOOL BIPAddressChanged( void ) const            { return m_bIPAddressChanged; }
    BOOL BSubnetMaskChanged( void ) const           { return m_bSubnetMaskChanged; }
    BOOL BNetworkChanged( void ) const              { return m_bNetworkChanged; }
    BOOL BCreatingNewVirtualServer( void ) const    { return m_bCreatingNewVirtualServer; }
    BOOL BCreatingNewGroup( void ) const            { return m_bCreatingNewGroup; }
    BOOL BCreatingAppResource( void ) const         { return m_bCreatingAppResource; }
    BOOL BNewGroupCreated( void ) const             { return m_bNewGroupCreated; }
    BOOL BExistingGroupRenamed( void ) const        { return m_bExistingGroupRenamed; }
    BOOL BIPAddressCreated( void ) const            { return m_riIPAddress.BCreated(); }
    BOOL BNetworkNameCreated( void ) const          { return m_riNetworkName.BCreated(); }
    BOOL BAppResourceCreated( void ) const          { return m_riApplication.BCreated(); }

    // State information -- WRITE.

    // TRUE = cluster has been changed by this wizard
    void SetClusterUpdated( IN BOOL bUpdated = TRUE )
    {
        m_bClusterUpdated = bUpdated;

    } //*** SetClusterUpdated()

    // TRUE = delete virtual server before creating new one, FALSE = ??
    void SetVSDataChanged( IN BOOL bChanged = TRUE )
    {
        m_bVSDataChanged = bChanged;
    
    } //*** SetVSDataChanged()

    // TRUE = delete application resource before creating new one, FALSE = ??
    void SetAppDataChanged( IN BOOL bChanged = TRUE )
    {
        m_bAppDataChanged = bChanged;

    } //*** SetAppDataChanged()

    // TRUE = refresh net name on page, FALSE = ??
    void SetNetNameChanged( IN BOOL bChanged = TRUE )
    {
        m_bNetNameChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetNetNameChanged()

    // TRUE = refresh IP Address on page, FALSE = ??
    void SetIPAddressChanged( IN BOOL bChanged = TRUE )
    {
        m_bIPAddressChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetIPAddressChanged()

    // TRUE = refresh subnet mask on page, FALSE = ??
    void SetSubnetMaskChanged( IN BOOL bChanged = TRUE )
    {
        m_bSubnetMaskChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetSubnetMaskChanged()

    // TRUE = refresh network on page, FALSE = ??
    void SetNetworkChanged( IN BOOL bChanged = TRUE )
    {
        m_bNetworkChanged = bChanged;
        SetVSDataChanged( bChanged );

    } //*** SetNetworkChanged()

    // TRUE = create a new virtual server, FALSE = use existing
    BOOL BSetCreatingNewVirtualServer( IN BOOL bCreate = TRUE, IN CClusGroupInfo * pgi = NULL );

    // TRUE = creating new group for VS, FALSE = use existing group
    BOOL BSetCreatingNewGroup( IN BOOL bCreate = TRUE, IN CClusGroupInfo * pgi = NULL );

    // TRUE = creating application resource, FALSE = skip
    BOOL BSetCreatingAppResource( IN BOOL bCreate = TRUE )
    {
        if ( bCreate != m_bCreatingAppResource )
        {
            if ( BAppResourceCreated() && ! BDeleteAppResource() )
            {
                return FALSE;
            } // if:  error deleting the application resource
            m_bCreatingAppResource = bCreate;
            SetAppDataChanged();
        } // if:  state changed

        return TRUE;
    
    } //*** BSetCreateAppResource()

    // TRUE = new group was created
    void SetNewGroupCreated( IN BOOL bCreated = TRUE )
    {
        m_bNewGroupCreated = bCreated;
    
    } //*** SetNewGroupCreated()

    // TRUE = existing group was renamed
    void SetExistingGroupRenamed( IN BOOL bRenamed = TRUE )
    {
        m_bExistingGroupRenamed = bRenamed;
    
    } //*** SetExistingGroupRenamed()

    // Common properties.
    CClusGroupInfo *    PgiExistingVirtualServer( void ) const  { return m_pgiExistingVirtualServer; }
    CClusGroupInfo *    PgiExistingGroup( void ) const          { return m_pgiExistingGroup; }
    CClusGroupInfo &    RgiCurrent( void )                      { return m_giCurrent; }
    CClusResInfo &      RriIPAddress( void )                    { return m_riIPAddress; }
    CClusResInfo &      RriNetworkName( void )                  { return m_riNetworkName; }
    CClusResInfo &      RriApplication( void )                  { return m_riApplication; }
    CClusResInfo *      PriIPAddress( void )                    { return &m_riIPAddress; }
    CClusResInfo *      PriNetworkName( void )                  { return &m_riNetworkName; }
    CClusResInfo *      PriApplication( void )                  { return &m_riApplication; }

    void ClearExistingVirtualServer( void ) { m_pgiExistingVirtualServer = NULL; }
    void ClearExistingGroup( void )         { m_pgiExistingGroup = NULL; }

    // Private properties.
    const CString &     RstrIPAddress( void ) const     { return m_strIPAddress; }
    const CString &     RstrSubnetMask( void ) const    { return m_strSubnetMask; }
    const CString &     RstrNetwork( void ) const       { return m_strNetwork; }
    const CString &     RstrNetName( void ) const       { return m_strNetName; }
    BOOL                BEnableNetBIOS( void ) const    { return m_bEnableNetBIOS; }

    // Set the IP Address private property
    BOOL BSetIPAddress( IN LPCTSTR psz )
    {
        if ( m_strIPAddress != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strIPAddress = psz;
            SetIPAddressChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetIPAddress()

    // Set the subnet mask private property
    BOOL BSetSubnetMask( IN LPCTSTR psz )
    {
        if ( m_strSubnetMask != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strSubnetMask = psz;
            SetSubnetMaskChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetSubnetMask()

    // Set the Network private property
    BOOL BSetNetwork( IN LPCTSTR psz )
    {
        if ( m_strNetwork != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strNetwork = psz;
            SetNetworkChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetNetwork()

    // Set the network name private property
    BOOL BSetNetName( IN LPCTSTR psz )
    {
        if ( m_strNetName != psz )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_strNetName = psz;
            SetNetNameChanged();
        } // if:  string changed

        return TRUE;

    } //*** BSetNetName()

    // Set the EnableNetBIOS property for the IP Address resource
    BOOL BSetEnableNetBIOS( IN BOOL bEnable )
    {
        if ( m_bEnableNetBIOS != bEnable )
        {
            if ( BClusterUpdated() && ! BResetCluster() )
            {
                return FALSE;
            } // if:  error resetting the cluster
            m_bEnableNetBIOS = bEnable;
            SetNetNameChanged();
        } // if:  state changed

        return TRUE;

    } //*** BSetEnableNetBIOS()

    // Names used to create/rename objects so we can undo it.
    const CString & RstrIPAddressResName( void )                { return RriIPAddress().RstrName(); }
    const CString & RstrNetworkNameResName( void )              { return RriNetworkName().RstrName(); }

    // Strings for constructing resource names.
    const CString & RstrIPAddressResNameSuffix( void ) const      { return m_strIPAddressResNameSuffix; }
    const CString & RstrNetworkNameResNameSuffix( void ) const    { return m_strNetworkNameResNameSuffix; }

}; //*** class CClusterAppWizard

/////////////////////////////////////////////////////////////////////////////

#endif // __CLUSAPPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_)
#define AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__CC7C59FA_64F2_11D1_9AA7_00C04FB93A80__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

inline int EXC_AppMessageBox(LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(NULL, lpszText, nType);
}

inline int EXC_AppMessageBox(UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(NULL, nIDPrompt, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, LPCTSTR lpszText, UINT nType = MB_OK, UINT nIDHelp = 0)
{
	return AppMessageBox(hwndParent, lpszText, nType);
}

inline int EXC_AppMessageBox(HWND hwndParent, UINT nIDPrompt, UINT nType = MB_OK, UINT nIDHelp = (UINT)-1)
{
	return AppMessageBox(hwndParent, nIDPrompt, nType);
}

inline HINSTANCE EXC_GetResourceInstance(void)
{
	return _Module.GetResourceInstance();
}

#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\entersubnet.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      EnterSubnet.h
//
//  Abstract:
//      Definition of the CEnterSubnetMaskDlg class.
//
//  Implementation File:
//      EnterSubnet.cpp
//
//  Author:
//      David Potter (davidp)   February 9, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __ENTERSUBNET_H_
#define __ENTERSUBNET_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CEnterSubnetMaskDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEDLG_H_
#include "AtlBaseDlg.h" // for CBaseDlg
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CEnterSubnetMaskDlg
/////////////////////////////////////////////////////////////////////////////

class CEnterSubnetMaskDlg : public CBaseDlg< CEnterSubnetMaskDlg >
{
public:
    //
    // Construction
    //

    // Default constructor
    CEnterSubnetMaskDlg(
        LPCTSTR pszIPAddress,
        LPCTSTR pszSubnetMask,
        LPCTSTR pszNetwork,
        CClusterAppWizard * pwiz
        )
        : m_strIPAddress( pszIPAddress )
        , m_strSubnetMask( pszSubnetMask )
        , m_strNetwork( pszNetwork )
        , m_pwiz( pwiz )
    {
        ASSERT( pszIPAddress != NULL );
        ASSERT( pszSubnetMask != NULL );
        ASSERT( pszNetwork != NULL );
        ASSERT( pwiz != NULL );

    } //*** CEnterSubnetMaskDlg()

    enum { IDD = IDD_ENTER_SUBNET_MASK };

public:
    //
    // CEnterSubnetMaskDlg public methods.
    //

public:
    //
    // CBaseDlg public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( BOOL bSaveAndValidate );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CEnterSubnetMaskDlg )
        COMMAND_HANDLER( IDC_ESM_SUBNET_MASK, EN_CHANGE, OnChangedSubnetMask )
        COMMAND_HANDLER( IDC_ESM_NETWORKS, CBN_SELCHANGE, OnChangedNetwork )
        COMMAND_HANDLER( IDOK, BN_CLICKED, OnOK )
        COMMAND_HANDLER( IDCANCEL, BN_CLICKED, OnCancel )
        CHAIN_MSG_MAP( CBaseDlg< CEnterSubnetMaskDlg > )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the EN_CHANGE command notification on IDC_ESM_SUBNET_MASK
    LRESULT OnChangedSubnetMask(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        CheckForRequiredFields();
        return 0;

    } //*** OnChangedSubnetMask()

    // Handler for the EN_CHANGE command notification on IDC_ESM_NETWORK
    LRESULT OnChangedNetwork(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        CheckForRequiredFields();
        return 0;

    } //*** OnChangedNetwork()

    // Handler for the BN_CLICKED command notification on IDOK
    LRESULT OnOK(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        if ( UpdateData(TRUE /*bSaveAndValidate*/ ) )
        {
            EndDialog( IDOK );
        } // if:  data updated successfully

        return 0;

    } //*** OnOK()

    // Handler for the BN_CLICKED command notification on IDCANCEL
    LRESULT OnCancel(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        EndDialog( IDCANCEL );
        return 0;

    } //*** OnCancel()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog(void);


// Implementation
protected:
    //
    // Controls.
    //
    CIPAddressCtrl      m_ipaIPAddress;
    CIPAddressCtrl      m_ipaSubnetMask;
    CComboBox           m_cboxNetworks;
    CButton             m_pbOK;

    //
    // Page state.
    //
    CString             m_strIPAddress;
    CString             m_strSubnetMask;
    CString             m_strNetwork;

    CClusterAppWizard * m_pwiz;

    // Check for required fields and enable/disable Next button
    void CheckForRequiredFields( void )
    {
        BOOL bIsSubnetMaskBlank = m_ipaSubnetMask.IsBlank();
        BOOL bIsNetworkBlank = m_cboxNetworks.GetWindowTextLength() == 0;
        BOOL bEnable = ! bIsSubnetMaskBlank && ! bIsNetworkBlank;
        m_pbOK.EnableWindow( bEnable );

    } //*** CheckForRequiredFields()

    // Fill the combobox with a list of networks that are accessible by clients
    void FillComboBox( void );

public:
    //
    // Data access.
    //
    const CString RstrSubnetMask( void ) const  { return m_strSubnetMask; }
    const CString RstrNetwork( void ) const     { return m_strNetwork; }
    CClusterAppWizard * Pwiz( void )            { return m_pwiz; }

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_ENTER_SUBNET_MASK; }

}; //*** class CEnterSubnetMaskDlg

/////////////////////////////////////////////////////////////////////////////

#endif // __ENTERSUBNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\grpadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      GrpAdv.cpp
//
//  Abstract:
//      Implementation of the class that implement the advanced group
//      property sheet.
//
//  Author:
//      David Potter (davidp)   February 26, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AtlBaseWiz.h"
#include "GrpAdv.h"
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CGroupAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CGroupAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupAdvancedSheet::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      rgi         [IN OUT] The group info object.
//      pwiz        [IN] Wizard containing common info.
//      rbChanged   [IN OUT] TRUE = group info was changed by property sheet.
//
//  Return Value:
//      TRUE        Sheet initialized successfully.
//      FALSE       Error initializing sheet.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupAdvancedSheet::BInit(
    IN OUT CClusGroupInfo & rgi,
    IN CClusterAppWizard *  pwiz,
    IN OUT BOOL &           rbChanged
    )
{
    ASSERT( pwiz != NULL );

    BOOL bSuccess = FALSE;

    m_pgi = &rgi;
    m_pwiz = pwiz;
    m_pbChanged = &rbChanged;

    // Loop to avoid goto's.
    do
    {
        //
        // Fill the page array.
        //
        if ( ! BAddAllPages() )
        {
            break;
        } // if:  error adding pages

        //
        // Call the base class method.
        //
        if ( ! baseClass::BInit() )
        {
            break;
        } // if:  error initializing the base class

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CGroupAdvancedSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGroupGeneralPage )
            || ! BAddPage( new CGroupFailoverPage )
            || ! BAddPage( new CGroupFailbackPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CGroupAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupGeneralPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAG_PREF_OWNERS_MODIFY )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lbPreferredOwners, IDC_GAG_PREF_OWNERS );

    //
    // Get data from the sheet.
    //
    m_strName = Pgi()->RstrName();
    m_strDesc = Pgi()->RstrDescription();

    //
    // Copy the preferred owners list.
    //
    m_lpniPreferredOwners = *Pgi()->PlpniPreferredOwners();

    //
    // Fill the preferred owners list.
    //
    FillPreferredOwnersList();

    return TRUE;

} //*** CGroupGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetText( m_hWnd, IDC_GAG_NAME, m_strName );
        DDX_GetText( m_hWnd, IDC_GAG_DESC, m_strDesc );
        if ( ! DDV_RequiredText(
                    m_hWnd,
                    IDC_GAG_NAME,
                    IDC_GAG_NAME_LABEL,
                    m_strName
                    ) )
        {
            return FALSE;
        } // if:  error getting number
    } // if: saving data from the page
    else
    {
        DDX_SetText( m_hWnd, IDC_GAG_NAME, m_strName );
        DDX_SetText( m_hWnd, IDC_GAG_DESC, m_strDesc );
    } // else:  setting data to the page

    return bSuccess;

} //*** CGroupGeneralPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupGeneralPage::BApplyChanges( void )
{
    if (   BSaveName()
        || BSaveDescription()
        || BSavePreferredOwners() )
    {
        SetGroupInfoChanged();
    } // if:  user changed info

    return TRUE;

} //*** CGroupGeneralPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::OnModifyPrefOwners
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on the Modify push
//      button.  Display a dialog that allows the user to modify the list of
//      preferred owners.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupGeneralPage::OnModifyPrefOwners(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    CModifyPreferredOwners dlg( Pwiz(), Pgi(), &m_lpniPreferredOwners, Pwiz()->PlpniNodes() );

    INT_PTR id = dlg.DoModal( m_hWnd );
    if ( id == IDOK )
    {
        SetModified();
        m_bPreferredOwnersChanged = TRUE;
        FillPreferredOwnersList();
    } // if:  user accepted changes

    return 0;

} //*** CGroupGeneralPage::OnModifyPrefOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupGeneralPage::FillPreferredOwnersList
//
//  Routine Description:
//      Fill the list of preferred owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGroupGeneralPage::FillPreferredOwnersList( void )
{
    CWaitCursor wc;

    //
    // Make sure nodes have been collected.
    //
    if ( ! Pwiz()->BCollectNodes() )
    {
        return;
    } // if:  error collecting nodes

    //
    // Remove all items to begin with.
    //
    m_lbPreferredOwners.ResetContent();

    //
    // Add each preferred owner to the list.
    //
    CClusNodePtrList::iterator itnode;
    for ( itnode = m_lpniPreferredOwners.begin()
        ; itnode != m_lpniPreferredOwners.end()
        ; itnode++ )
    {
        //
        // Add the string to the list box.
        //
        m_lbPreferredOwners.AddString( (*itnode)->RstrName() );
    } // for:  each entry in the list

} //*** CGroupGeneralPage::FillPreferredOwnersList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupFailoverPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupFailoverPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_THRESH_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_THRESH )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFO_FAILOVER_PERIOD_LABEL2 )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //

    //
    // Get data from the sheet.
    //
    m_nFailoverThreshold = Pgi()->NFailoverThreshold();
    m_nFailoverPeriod = Pgi()->NFailoverPeriod();

    return TRUE;

} //*** CGroupFailoverPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        if ( ! DDX_GetNumber(
                    m_hWnd,
                    IDC_GAFO_FAILOVER_THRESH,
                    m_nFailoverThreshold,
                    CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
                    CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD,
                    FALSE       // bSigned
                    ) )
        {
            return FALSE;
        } // if:  error getting number
        if ( ! DDX_GetNumber(
                    m_hWnd,
                    IDC_GAFO_FAILOVER_PERIOD,
                    m_nFailoverPeriod,
                    CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
                    CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD,
                    FALSE       // bSigned
                    ) )
        {
            return FALSE;
        } // if:  error getting number
    } // if: saving data from the page
    else
    {
        DDX_SetNumber(
            m_hWnd,
            IDC_GAFO_FAILOVER_THRESH,
            m_nFailoverThreshold,
            CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD,
            CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD,
            FALSE       // bSigned
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_GAFO_FAILOVER_PERIOD,
            m_nFailoverPeriod,
            CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD,
            CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD,
            FALSE       // bSigned
            );
    } // else:  setting data to the page

    return bSuccess;

} //*** CGroupFailoverPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailoverPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailoverPage::BApplyChanges( void )
{
    if ( Pgi()->BSetFailoverProperties( m_nFailoverThreshold, m_nFailoverPeriod ) )
    {
        SetGroupInfoChanged();
    } // if:  user changed info

    return TRUE;

} //*** CGroupFailoverPage::BApplyChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGroupFailbackPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGroupFailbackPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_PREVENT_FAILBACK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_ALLOW_FAILBACK_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_ALLOW_FAILBACK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_WHEN_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_IMMED )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FAILBACK_WINDOW )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_START )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_START_SPIN )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FB_WINDOW_LABEL1 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_END )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FBWIN_END_SPIN )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_GAFB_FB_WINDOW_LABEL2 )
END_CTRL_NAME_MAP()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_rbPreventFailback,         IDC_GAFB_PREVENT_FAILBACK );
    AttachControl( m_rbAllowFailback,           IDC_GAFB_ALLOW_FAILBACK );
    AttachControl( m_staticFailbackWhenDesc,    IDC_GAFB_FAILBACK_WHEN_DESCRIPTION );
    AttachControl( m_rbFBImmed,                 IDC_GAFB_FAILBACK_IMMED );
    AttachControl( m_rbFBWindow,                IDC_GAFB_FAILBACK_WINDOW );
    AttachControl( m_editStart,                 IDC_GAFB_FBWIN_START );
    AttachControl( m_spinStart,                 IDC_GAFB_FBWIN_START_SPIN );
    AttachControl( m_staticWindowAnd,           IDC_GAFB_FB_WINDOW_LABEL1 );
    AttachControl( m_editEnd,                   IDC_GAFB_FBWIN_END );
    AttachControl( m_spinEnd,                   IDC_GAFB_FBWIN_END_SPIN );
    AttachControl( m_staticWindowUnits,         IDC_GAFB_FB_WINDOW_LABEL2 );

    //
    // Get data from the sheet.
    //
    m_cgaft = Pgi()->CgaftAutoFailbackType();
    m_nStart = Pgi()->NFailbackWindowStart();
    m_nEnd = Pgi()->NFailbackWindowEnd();
    m_bNoFailbackWindow = (    (m_cgaft == ClusterGroupPreventFailback)
                            || (m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE)
                            || (m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE) );

    return TRUE;

} //*** CGroupFailbackPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        //
        // If failback is allowed, make sure there is a preferred owner
        // and validate the failback window.
        //
        if ( m_cgaft == ClusterGroupAllowFailback )
        {
            //
            // Make sure there is a preferred owner.
            //

            //
            // If there is a failback window, validate it.
            //
            if ( ! m_bNoFailbackWindow )
            {
                if ( ! DDX_GetNumber(
                            m_hWnd,
                            IDC_GAFB_FBWIN_START,
                            m_nStart,
                            0,      // nMin
                            CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START,
                            TRUE    // bSigned
                            ) )
                {
                    return FALSE;
                } // if:  error getting number
                if ( ! DDX_GetNumber(
                            m_hWnd,
                            IDC_GAFB_FBWIN_END,
                            m_nEnd,
                            0,      // nMin
                            CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,
                            TRUE    // bSigned
                            ) )
                {
                    return FALSE;
                } // if:  error getting number
                if ( m_nStart == m_nEnd )
                {
                    AppMessageBox( m_hWnd, IDS_ERROR_SAME_START_AND_END, MB_OK | MB_ICONEXCLAMATION );
                    m_editStart.SetFocus();
                    m_editStart.SetSel( 0, -1, FALSE );
                    return FALSE;
                }  // if:  values are the same
            } // if:  there is a failback window
        } // if:  failback is allowed
    } // if: saving data from the page
    else
    {
        BOOL bHandled;
        if ( m_cgaft == ClusterGroupPreventFailback )
        {
            m_rbPreventFailback.SetCheck( BST_CHECKED );
            m_rbAllowFailback.SetCheck( BST_UNCHECKED );
            OnClickedPreventFailback( 0, 0, 0, bHandled );
        }  // if:  failbacks are not allowed
        else
        {
            m_rbPreventFailback.SetCheck( BST_UNCHECKED );
            m_rbAllowFailback.SetCheck( BST_CHECKED );
            OnClickedAllowFailback( 0, 0, 0, bHandled );
        }  // else:  failbacks are allowed
        m_rbFBImmed.SetCheck( m_bNoFailbackWindow ? BST_CHECKED : BST_UNCHECKED );
        m_rbFBWindow.SetCheck( m_bNoFailbackWindow ? BST_UNCHECKED : BST_CHECKED );

        // Set up the Start and End window controls.
        DDX_SetNumber(
            m_hWnd,
            IDC_GAFB_FBWIN_START,
            m_nStart,
            0,      // nMin
            CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START,
            FALSE   // bSigned
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_GAFB_FBWIN_END,
            m_nEnd,
            0,      // nMin
            CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,
            FALSE   // bSigned
            );
        m_spinStart.SetRange( 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START );
        m_spinEnd.SetRange( 0, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END );
        if ( m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
        {
            m_editStart.SetWindowText( _T("") );
        } // if:  no start window
        if ( m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
        {
            m_editEnd.SetWindowText( _T("") );
        } // if:  no end window
    } // else:  setting data to the page

    return bSuccess;

} //*** CGroupFailbackPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGroupFailbackPage::BApplyChanges( void )
{
    if ( m_bNoFailbackWindow )
    {
        m_nStart = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
        m_nEnd = CLUSTER_GROUP_FAILBACK_WINDOW_NONE;
    }  // if:  no failback window

    if ( Pgi()->BSetFailbackProperties( m_cgaft, m_nStart, m_nEnd ) )
    {
        SetGroupInfoChanged();
    } // if:  user changed info

    return TRUE;

} //*** CGroupFailbackPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedPreventFailback
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on the PREVENT radio
//      button.  Disable controls in the ALLOW group.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedPreventFailback(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    BOOL bHandledX;

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    m_staticFailbackWhenDesc.EnableWindow( FALSE );
    m_rbFBImmed.EnableWindow( FALSE );
    m_rbFBWindow.EnableWindow( FALSE );

    OnClickedFailbackImmediate( 0, 0, 0, bHandledX );

    m_editStart.EnableWindow( FALSE );
    m_spinStart.EnableWindow( FALSE );
    m_staticWindowAnd.EnableWindow( FALSE );
    m_editEnd.EnableWindow( FALSE );
    m_spinEnd.EnableWindow( FALSE );
    m_staticWindowUnits.EnableWindow( FALSE );

    if ( m_cgaft != ClusterGroupPreventFailback ) 
    {
        m_cgaft = ClusterGroupPreventFailback;
        SetModified( TRUE );
    } // if:  value changed

    return 0;

} //*** CGroupFailbackPage::OnClickedPreventFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedAllowFailback
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on the ALLOW radio
//      button.  Enable controls in the ALLOW group.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedAllowFailback(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    BOOL bHandledX;

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    m_staticFailbackWhenDesc.EnableWindow( TRUE );
    m_rbFBImmed.EnableWindow( TRUE );
    m_rbFBWindow.EnableWindow( TRUE );

    if ( m_bNoFailbackWindow )
    {
        OnClickedFailbackImmediate( 0, 0, 0, bHandledX );
    } // if:  no failback window
    else
    {
        OnClickedFailbackInWindow( 0, 0, 0, bHandledX );
    } // else:  failback window specified


    if ( m_cgaft != ClusterGroupAllowFailback )
    {
        m_cgaft = ClusterGroupAllowFailback;
        SetModified( TRUE );
    } // if:  value changed

    return 0;

} //*** CGroupFailbackPage::OnClickedAllowFailback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedFailbackImmediate
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on the IMMEDIATE radio
//      button.  Disable the 'failback in time window' controls.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedFailbackImmediate(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    m_editStart.EnableWindow( FALSE );
    m_spinStart.EnableWindow( FALSE );
    m_staticWindowAnd.EnableWindow( FALSE );
    m_editEnd.EnableWindow( FALSE );
    m_spinEnd.EnableWindow( FALSE );
    m_staticWindowUnits.EnableWindow( FALSE );

    if ( ! m_bNoFailbackWindow )
    {
        m_bNoFailbackWindow = TRUE;
        SetModified( TRUE );
    } // if:  value changed

    return 0;

} //*** CGroupFailbackPage::OnClickedFailbackImmediate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGroupFailbackPage::OnClickedFailbackInWindow
//
//  Routine Description:
//      Handler for the BN_CLICKED command notification on the IN WINDOW radio
//      button.  Enable the 'failback in time window' controls.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CGroupFailbackPage::OnClickedFailbackInWindow(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    m_editStart.EnableWindow( TRUE );
    m_spinStart.EnableWindow( TRUE );
    m_staticWindowAnd.EnableWindow( TRUE );
    m_editEnd.EnableWindow( TRUE );
    m_spinEnd.EnableWindow( TRUE );
    m_staticWindowUnits.EnableWindow( TRUE );

    if ( m_bNoFailbackWindow )
    {
        // Set the values of the edit controls.
        if ( m_nStart == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
        {
            SetDlgItemInt( IDC_GAFB_FBWIN_START, 0, FALSE );
        } // if:  no failback window
        if ( m_nEnd == CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
        {
            SetDlgItemInt( IDC_GAFB_FBWIN_END, 0, FALSE );
        } // if:  no failback window

        m_bNoFailbackWindow = FALSE;
        SetModified( TRUE );
    } // if:  value changed

    return 0;

} //*** CGroupFailbackPage::OnClickedFailbackInWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		Galen Barbee (galenb)	May 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "AdmCommonRes.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\entersubnet.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      EnterSubnet.cpp
//
//  Abstract:
//      Implementation of the CEnterSubnetMaskDlg class.
//
//  Author:
//      David Potter (davidp)   February 10, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "EnterSubnet.h"
#include "AdmNetUtils.h"    // for BIsValidxxx network functions
#include "AtlUtil.h"        // for DDX/DDV

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CEnterSubnetMaskDlg
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CEnterSubnetMaskDlg )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_IP_ADDRESS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_IP_ADDRESS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_SUBNET_MASK_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_SUBNET_MASK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_NETWORKS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_ESM_NETWORKS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnterSubnetMaskDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEnterSubnetMaskDlg::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_ipaIPAddress, IDC_ESM_IP_ADDRESS );
    AttachControl( m_ipaSubnetMask, IDC_ESM_SUBNET_MASK );
    AttachControl( m_cboxNetworks, IDC_ESM_NETWORKS );
    AttachControl( m_pbOK, IDOK );

    //
    // Initialize the data in the controls.
    //
    UpdateData( FALSE /*bSaveAndValidate*/ );

    //
    // Set the IP Address control to be read only.
    //
    SetDlgItemReadOnly( m_ipaIPAddress.m_hWnd );

    //
    // Fill the networks combobox.
    //
    FillComboBox();

    //
    // Set the focus on the subnet mask control.
    //
    m_ipaSubnetMask.SetFocus( 0 );

    return FALSE;

} //*** CEnterSubnetMaskDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnterSubnetMaskDlg::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEnterSubnetMaskDlg::UpdateData( BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetText( m_hWnd, IDC_ESM_SUBNET_MASK, m_strSubnetMask );
        DDX_GetText( m_hWnd, IDC_ESM_NETWORKS, m_strNetwork );

        if (    ! DDV_RequiredText( m_hWnd, IDC_ESM_SUBNET_MASK, IDC_ESM_SUBNET_MASK_LABEL, m_strSubnetMask )
            ||  ! DDV_RequiredText( m_hWnd, IDC_ESM_NETWORKS, IDC_ESM_NETWORKS_LABEL, m_strNetwork )
            )
        {
            return FALSE;
        } // if: required text not present

        //
        // Validate the subnet mask.
        //
        if ( ! BIsValidSubnetMask( m_strSubnetMask ) )
        {
            CString strMsg;
            strMsg.FormatMessage( IDS_ERROR_INVALID_SUBNET_MASK, m_strSubnetMask );
            AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
            return FALSE;
        }  // if: invalid subnet mask
        if ( ! BIsValidIpAddressAndSubnetMask( m_strIPAddress, m_strSubnetMask ) )
        {
            CString strMsg;
            strMsg.FormatMessage( IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask );
            AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
            return FALSE;
        }  // if: invalid subnet mask
    } // if: saving data from the page
    else
    {
        DDX_SetText( m_hWnd, IDC_ESM_IP_ADDRESS, m_strIPAddress );
        DDX_SetText( m_hWnd, IDC_ESM_SUBNET_MASK, m_strSubnetMask );
        DDX_SetComboBoxText( m_hWnd, IDC_ESM_NETWORKS, m_strNetwork );
    } // else: setting data to the page

    return bSuccess;

} //*** CEnterSubnetMaskDlg::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CEnterSubnetMaskDlg::FillComboBox
//
//  Routine Description:
//      Fill the combobox with a list of networks that are accessible by clients.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEnterSubnetMaskDlg::FillComboBox( void )
{
    // Loop to avoid goto's.
    do
    {
        //
        // Clear the combobox first.
        //
        m_cboxNetworks.ResetContent();

        //
        // Add each network in the list to the combobox.
        //
        CClusNetworkPtrList::iterator itnet;
        int idx;
        for ( itnet = Pwiz()->PlpniNetworks()->begin()
            ; itnet != Pwiz()->PlpniNetworks()->end()
            ; itnet++ )
        {
            //
            // Add the network to the combobox.
            //
            CClusNetworkInfo * pni = *itnet;
            if ( pni->BIsClientNetwork() )
            {
                idx = m_cboxNetworks.AddString( pni->RstrName() );
                ASSERT( idx != CB_ERR );
                m_cboxNetworks.SetItemDataPtr( idx, (void *) pni );
            } // if:  client network
        } // for:  each entry in the list

        //
        // Select the currently saved entry, or the first one if none are
        // currently saved.
        //
        if ( m_strNetwork.GetLength() == 0 )
        {
            m_cboxNetworks.SetCurSel( 0 );
        } // if:  empty string
        else
        {
            idx = m_cboxNetworks.FindStringExact( -1, m_strNetwork );
            if ( idx != CB_ERR )
            {
                m_cboxNetworks.SetCurSel( idx );
            } // if:  saved selection found in the combobox
            else
            {
                m_cboxNetworks.SetCurSel( 0 );
            } // else:  saved selection not found in the combobox
        } // else:  network saved
    } while ( 0 );

} //*** CEnterSubnetMaskDlg::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\grpadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      GrpAdv.h
//
//  Abstract:
//      Definition of the advanced group page classes.
//
//  Implementation File:
//      GrpAdv.cpp
//
//  Author:
//      David Potter (davidp)   February 25, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __GRPADV_H_
#define __GRPADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGroupAdvancedSheet;
class CGroupGeneralPage;
class CGroupFailoverPage;
class CGroupFailbackPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEPROPSHEET_H_
#include "AtlBasePropSheet.h"   // for CBasePropertySheetImpl
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"    // for CBasePropertyPageImpl
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"         // for CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"           // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CGroupAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CGroupAdvancedSheet : public CBasePropertySheetImpl< CGroupAdvancedSheet >
{
    typedef CBasePropertySheetImpl< CGroupAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CGroupAdvancedSheet( IN UINT nIDCaption )
        : CBasePropertySheetImpl< CGroupAdvancedSheet >( nIDCaption )
        , m_pgi( NULL )
        , m_pbChanged( NULL )
    {
    } //*** CGroupAdvancedSheet()

    // Initialize the sheet
    BOOL BInit(
        IN OUT CClusGroupInfo & rgi,
        IN CClusterAppWizard *  pwiz,
        IN OUT BOOL &           rbChanged
        );

    // Add all pages to the page array
    BOOL BAddAllPages( void );

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CGroupAdvancedSheet )
//  END_MSG_MAP()
    DECLARE_EMPTY_MSG_MAP()
    DECLARE_CLASS_NAME()

    //
    // Message handler functions.
    //

// Implementation
protected:
    CClusGroupInfo *    m_pgi;
    CClusterAppWizard * m_pwiz;
    BOOL *              m_pbChanged;

public:
    CClusGroupInfo *    Pgi( void ) const   { return m_pgi; }
    CClusterAppWizard * Pwiz( void ) const  { return m_pwiz; }
    void                SetGroupInfoChanged( void ) { ASSERT( m_pbChanged != NULL ); *m_pbChanged = TRUE; }

}; //*** class CGroupAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CGroupGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CGroupGeneralPage : public CStaticPropertyPageImpl< CGroupGeneralPage >
{
    typedef CStaticPropertyPageImpl< CGroupGeneralPage > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CGroupGeneralPage( void )
        : m_bPreferredOwnersChanged( FALSE )
    {
    } //*** CGroupGeneralPage()

    enum { IDD = IDD_GRPADV_GENERAL };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CGroupGeneralPage )
        COMMAND_HANDLER( IDC_GAG_PREF_OWNERS_MODIFY, BN_CLICKED, OnModifyPrefOwners )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on the Modify button
    LRESULT OnModifyPrefOwners(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CListBox    m_lbPreferredOwners;

    //
    // Page state.
    //
    CString m_strName;
    CString m_strDesc;

    CClusNodePtrList m_lpniPreferredOwners;

    BOOL m_bPreferredOwnersChanged;

protected:
    CGroupAdvancedSheet *   PshtThis( void ) const      { return (CGroupAdvancedSheet *) Psht(); }
    CClusGroupInfo *        Pgi( void ) const           { return PshtThis()->Pgi(); }
    CClusterAppWizard *     Pwiz( void ) const          { return PshtThis()->Pwiz(); }
    void                    SetGroupInfoChanged( void ) { PshtThis()->SetGroupInfoChanged(); }

    // Save the group name
    BOOL BSaveName( void )
    {
        if ( Pgi()->RstrName() != m_strName )
        {
            Pgi()->SetName( m_strName );
            return TRUE;
        } // if:  value changed

        return FALSE;

    } //*** BSaveName()

    // Save the group description
    BOOL BSaveDescription( void )
    {
        if ( Pgi()->RstrDescription() != m_strDesc )
        {
            Pgi()->SetDescription( m_strDesc );
            return TRUE;
        } // if:  value changed

        return FALSE;

    } //*** BSaveDescription()

    // Save preferred owners
    BOOL BSavePreferredOwners( void )
    {
        if ( m_bPreferredOwnersChanged )
        {
            *Pgi()->PlpniPreferredOwners() = m_lpniPreferredOwners;
            return TRUE;
        } // if:  preferred owners changed

        return FALSE;

    } //*** BSavePreferredOwners()

    // Fill the list of preferred owners
    void FillPreferredOwnersList( void );

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_GENERAL; }

}; //*** class CGroupGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CGroupFailoverPage
/////////////////////////////////////////////////////////////////////////////

class CGroupFailoverPage : public CStaticPropertyPageImpl< CGroupFailoverPage >
{
    typedef CStaticPropertyPageImpl< CGroupFailoverPage > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CGroupFailoverPage( void )
        : m_nFailoverThreshold( CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD )
        , m_nFailoverPeriod( CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD )
    {
    } //*** CGroupFailoverPage()

    enum { IDD = IDD_GRPADV_FAILOVER };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CGroupFailoverPage )
        COMMAND_HANDLER( IDC_GAFO_FAILOVER_THRESH, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_GAFO_FAILOVER_PERIOD, EN_CHANGE, OnChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the EN_CHANGE command notification on edit fields
    LRESULT OnChanged(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        SetModified( TRUE );
        return 0;

    } // OnChanged()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CUpDownCtrl m_spinThreshold;
    CUpDownCtrl m_spinPeriod;

    //
    // Page state.
    //
    ULONG       m_nFailoverThreshold;
    ULONG       m_nFailoverPeriod;

protected:
    CGroupAdvancedSheet *   PshtThis( void ) const      { return (CGroupAdvancedSheet *) Psht(); }
    CClusGroupInfo *        Pgi( void ) const           { return PshtThis()->Pgi(); }
    CClusterAppWizard *     Pwiz( void ) const          { return PshtThis()->Pwiz(); }
    void                    SetGroupInfoChanged( void ) { PshtThis()->SetGroupInfoChanged(); }

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_FAILOVER; }

}; //*** class CGroupFailoverPage

/////////////////////////////////////////////////////////////////////////////
// class CGroupFailbackPage
/////////////////////////////////////////////////////////////////////////////

class CGroupFailbackPage : public CStaticPropertyPageImpl< CGroupFailbackPage >
{
    typedef CStaticPropertyPageImpl< CGroupFailbackPage > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CGroupFailbackPage( void )
        : m_cgaft( ClusterGroupPreventFailback )
        , m_bNoFailbackWindow( TRUE )
        , m_nStart( CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
        , m_nEnd( CLUSTER_GROUP_FAILBACK_WINDOW_NONE )
    {
    } //*** CGroupFailoverPage()

    enum { IDD = IDD_GRPADV_FAILBACK };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CGroupFailbackPage )
        COMMAND_HANDLER( IDC_GAFB_PREVENT_FAILBACK, BN_CLICKED, OnClickedPreventFailback )
        COMMAND_HANDLER( IDC_GAFB_ALLOW_FAILBACK, BN_CLICKED, OnClickedAllowFailback )
        COMMAND_HANDLER( IDC_GAFB_FAILBACK_IMMED, BN_CLICKED, OnClickedFailbackImmediate )
        COMMAND_HANDLER( IDC_GAFB_FAILBACK_WINDOW, BN_CLICKED, OnClickedFailbackInWindow )
        COMMAND_HANDLER( IDC_GAFB_FBWIN_START, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_GAFB_FBWIN_END, EN_CHANGE, OnChanged )

        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the BN_CLICKED command notification on the PREVENT radio button
    LRESULT OnClickedPreventFailback(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    // Handler for the BN_CLICKED command notification on the ALLOW radio button
    LRESULT OnClickedAllowFailback(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    // Handler for the BN_CLICKED command notification on the IMMEDIATE radio button
    LRESULT OnClickedFailbackImmediate(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    // Handler for the BN_CLICKED command notification on the IN WINDOW radio button
    LRESULT OnClickedFailbackInWindow(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    // Handler for the EN_CHANGE command notification on edit fields
    LRESULT OnChanged(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        SetModified( TRUE );
        return 0;

    } // OnChanged()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CButton     m_rbPreventFailback;
    CButton     m_rbAllowFailback;
    CStatic     m_staticFailbackWhenDesc;
    CButton     m_rbFBImmed;
    CButton     m_rbFBWindow;
    CEdit       m_editStart;
    CUpDownCtrl m_spinStart;
    CStatic     m_staticWindowAnd;
    CEdit       m_editEnd;
    CUpDownCtrl m_spinEnd;
    CStatic     m_staticWindowUnits;

    //
    // Page state.
    //
    CGAFT   m_cgaft;
    BOOL    m_bNoFailbackWindow;
    DWORD   m_nStart;
    DWORD   m_nEnd;

protected:
    CGroupAdvancedSheet *   PshtThis( void ) const      { return (CGroupAdvancedSheet *) Psht(); }
    CClusGroupInfo *        Pgi( void ) const           { return PshtThis()->Pgi(); }
    CClusterAppWizard *     Pwiz( void ) const          { return PshtThis()->Pwiz(); }
    void                    SetGroupInfoChanged( void ) { PshtThis()->SetGroupInfoChanged(); }

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_GRPADV_FAILBACK; }

}; //*** class CGroupFailbackPage

/////////////////////////////////////////////////////////////////////////////

#endif // __GRPADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\proplists.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      PropListS.cpp
//
//  Abstract:
//      Stub for implementation of property list classes.
//
//  Author:
//      David Potter (davidp)	February 24, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\helparr.h ===
//disable instructional text and icons
#define IDH_DISABLEHELP	((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_APP_RESOURCE_CREATE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ARC_DONT_CREATE_RES, IDH_ARC_DONT_CREATE_RES,
	IDC_ARC_CREATE_RES, IDH_ARC_CREATE_RES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC[]=
{
	IDC_ARND_RES_NAME_TITLE, IDH_DISABLEHELP,
	IDC_ARND_RES_NAME_LABEL, IDH_ARND_RES_NAME,
	IDC_ARND_RES_NAME, IDH_ARND_RES_NAME,
	IDC_ARND_RES_DESC_LABEL, IDH_ARND_RES_DESC, 
	IDC_ARND_RES_DESC, IDH_ARND_RES_DESC,
	IDC_ARND_ADVANCED_PROPS_LABEL, IDH_ARND_ADVANCED_PROPS,
	IDC_ARND_ADVANCED_PROPS, IDH_ARND_ADVANCED_PROPS,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_APP_RESOURCE_TYPE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ART_RESTYPES_LABEL, IDH_ART_RESTYPES,
	IDC_ART_RESTYPES, IDH_ART_RESTYPES,
	0, 0
};

const DWORD g_aHelpIDs_IDD_COMPLETION[]=
{
	IDC_WIZARD_TITLE, IDH_DISABLEHELP,
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_WIZARD_LISTBOX, IDH_WIZARD_LISTBOX,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ENTER_SUBNET_MASK[]=
{
	IDC_ESM_DESCRIPTION, IDH_DISABLEHELP,
	IDC_ESM_IP_ADDRESS_LABEL, IDH_ESM_IP_ADDRESS,
	IDC_ESM_IP_ADDRESS, IDH_ESM_IP_ADDRESS,
	IDC_ESM_SUBNET_MASK_LABEL, IDH_ESM_SUBNET_MASK,
	IDC_ESM_SUBNET_MASK, IDH_ESM_SUBNET_MASK,
	IDC_ESM_NETWORKS_LABEL, IDH_ESM_NETWORKS,
	IDC_ESM_NETWORKS, IDH_ESM_NETWORKS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_FAILBACK[]=
{
	IDC_GAFB_FAILBACK_DESCRIPTION, IDH_DISABLEHELP, 
	IDC_GAFB_PREVENT_FAILBACK, IDH_PP_GROUP_AUTOFB_PREVENT,
	IDC_GAFB_ALLOW_FAILBACK, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_ALLOW_FAILBACK_GROUP, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_FAILBACK_WHEN_DESCRIPTION, IDH_PP_GROUP_AUTOFB_ALLOW,
	IDC_GAFB_FAILBACK_IMMED, IDH_PP_GROUP_FB_IMMED,
	IDC_GAFB_FAILBACK_WINDOW, IDH_PP_GROUP_FB_WINDOW,
	IDC_GAFB_FBWIN_START, IDH_PP_GROUP_FBWIN_START,
	IDC_GAFB_FB_WINDOW_LABEL1, IDH_PP_GROUP_FBWIN_START,
	IDC_GAFB_FBWIN_END, IDH_PP_GROUP_FBWIN_END,
	IDC_GAFB_FB_WINDOW_LABEL2, IDH_PP_GROUP_FBWIN_END,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_FAILOVER[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAFO_FAILOVER_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAFO_FAILOVER_THRESH_LABEL, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_GAFO_FAILOVER_THRESH, IDH_PP_GROUP_FAILOVER_THRESH,
	IDC_GAFO_FAILOVER_PERIOD_LABEL, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_GAFO_FAILOVER_PERIOD, IDH_PP_GROUP_FAILOVER_PERIOD,
	IDC_GAFO_FAILOVER_PERIOD_LABEL2, IDH_PP_GROUP_FAILOVER_PERIOD,
	0, 0
};

const DWORD g_aHelpIDs_IDD_GRPADV_GENERAL[]=
{
	IDC_GAG_NAME_LABEL, IDH_GAG_NAME,
	IDC_GAG_NAME, IDH_GAG_NAME,
	IDC_GAG_DESC_LABEL, IDH_PP_GROUP_DESC,
	IDC_GAG_DESC, IDH_PP_GROUP_DESC,
	IDC_GAFB_PREFERRED_OWNERS_DESCRIPTION, IDH_DISABLEHELP,
	IDC_GAG_PREF_OWNERS_LABEL, IDH_PP_GROUP_PREF_OWNERS,
	IDC_GAG_PREF_OWNERS, IDH_PP_GROUP_PREF_OWNERS,
	IDC_GAG_PREF_OWNERS_MODIFY, IDH_GAG_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_POSSIBLE_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_POSSIBLE_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_POSSIBLE_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_POSSIBLE_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_POSSIBLE_LCP_RIGHT_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[]=
{
	ADMC_IDC_LCP_LEFT_LABEL, IDH_PREF_LCP_LEFT_LIST,
	ADMC_IDC_LCP_LEFT_LIST, IDH_PREF_LCP_LEFT_LIST,
	ADMC_IDC_LCP_ADD, IDH_POSSIBLE_LCP_ADD,
	ADMC_IDC_LCP_REMOVE, IDH_POSIBLE_LCP_REMOVE,
	ADMC_IDC_LCP_RIGHT_LABEL, IDH_PREF_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_RIGHT_LIST, IDH_PREF_LCP_RIGHT_LIST,
	ADMC_IDC_LCP_MOVE_UP, IDH_LCP_MOVE_UP,
	ADMC_IDC_LCP_MOVE_DOWN, IDH_LCP_MOVE_DOWN,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_ADVANCED[]=
{
	IDC_RES_DONT_RESTART, IDH_PP_RES_DONT_RESTART,
	IDC_RES_RESTART, IDH_PP_RES_RESTART,
	IDC_RES_RESTART_GROUP, IDH_PP_RES_RESTART,
	IDC_RES_AFFECT_THE_GROUP, IDH_PP_RES_AFFECT_THE_GROUP,
	IDC_RES_RESTART_THRESH_LABEL, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_RES_RESTART_THRESHOLD, IDH_PP_RES_RESTART_THRESHOLD,
	IDC_RES_RESTART_PERIOD_LABEL, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_RESTART_PERIOD, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_RESTART_PERIOD_LABEL2, IDH_PP_RES_RESTART_PERIOD,
	IDC_RES_LOOKS_ALIVE_GROUP, IDH_PP_RES_LOOKS_ALIVE_GROUP,
	IDC_RES_DEFAULT_LOOKS_ALIVE, IDH_PP_RES_DEFAULT_LOOKS_ALIVE,
	IDC_RES_SPECIFY_LOOKS_ALIVE, IDH_PP_RES_SPECIFY_LOOKS_ALIVE,
	IDC_RES_LOOKS_ALIVE, IDH_PP_RES_LOOKS_ALIVE,
	IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL, IDH_PP_RES_LOOKS_ALIVE,
	IDC_RES_IS_ALIVE_GROUP, IDH_PP_RES_IS_ALIVE_GROUP,
	IDC_RES_DEFAULT_IS_ALIVE, IDH_PP_RES_DEFAULT_IS_ALIVE,
	IDC_RES_SPECIFY_IS_ALIVE, IDH_PP_RES_SPECIFY_IS_ALIVE,
	IDC_RES_IS_ALIVE, IDH_PP_RES_IS_ALIVE,
	IDC_RES_IS_ALIVE_LABEL, IDH_PP_RES_IS_ALIVE,
	IDC_RES_PENDING_TIMEOUT_LABEL, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_RES_PENDING_TIMEOUT, IDH_PP_RES_PENDING_TIMEOUT,
	IDC_RES_PENDING_TIMEOUT_LABEL2, IDH_PP_RES_PENDING_TIMEOUT,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_DEPENDENCIES[]=
{
	IDC_RES_NOTE, IDH_DISABLEHELP,
	IDC_RES_DEPENDS_LIST_LABEL, IDH_PP_RES_DEPENDS_LIST,
	IDC_RES_DEPENDS_LIST, IDH_PP_RES_DEPENDS_LIST,
	IDC_RES_DEPENDS_MODIFY, IDH_PP_RES_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_GENERAL[]=
{
	IDC_RES_NAME_LABEL, IDH_PP_RES_NAME,
	IDC_RES_NAME, IDH_PP_RES_NAME,
	IDC_RES_DESC_LABEL, IDH_PP_RES_DESC,
	IDC_RES_DESC, IDH_PP_RES_DESC,
	IDC_RES_POSSIBLE_OWNERS_LABEL, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_RES_POSSIBLE_OWNERS, IDH_PP_RES_POSSIBLE_OWNERS,
	IDC_RES_SEPARATE_MONITOR, IDH_PP_RES_SEPARATE_MONITOR,
	IDC_RES_POSSIBLE_OWNERS_MODIFY, IDH_RES_POSSIBLE_OWNERS_MODIFY,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_IP_PARAMS[]=
{
	IDC_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
	IDC_IPADDR_PARAMS_ADDRESS, IDH_PP_IPADDR_PARAMS_ADDRESS,
	IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
	IDC_IPADDR_PARAMS_SUBNET_MASK, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
	IDC_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
	IDC_IPADDR_PARAMS_NETWORK, IDH_PP_IPADDR_PARAMS_NETWORK,
	IDC_IPADDR_PARAMS_ENABLE_NETBIOS, IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_RES_NETNAME_PARAMS[]=
{
	IDC_NETNAME_PARAMS_NAME_LABEL, IDH_NETNAME_PARAMS_NAME,
	IDC_NETNAME_PARAMS_NAME, IDH_RES_NETNAME_NAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSAI_NETWORK_NAME_LABEL, IDH_VSAI_NETWORK_NAME,
	IDC_VSAI_NETWORK_NAME, IDH_VSAI_NETWORK_NAME,
	IDC_VSAI_IP_ADDRESS_LABEL, IDH_VSAI_IP_ADDRESS,
	IDC_VSAI_IP_ADDRESS, IDH_VSAI_IP_ADDRESS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSA_CATEGORIES_LABEL, IDH_VSA_CATEGORIES,
	IDC_VSA_CATEGORIES, IDH_VSA_CATEGORIES,
	IDC_VSA_ADVANCED_PROPS, IDH_VSA_ADVANCED_PROPS,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSC_CREATE_NEW, IDH_VSC_CREATE_NEW,
	IDC_VSC_USE_EXISTING, IDH_VSC_USE_EXISTING,
	IDC_VSC_VIRTUAL_SERVERS_LABEL, IDH_VSC_VIRTUAL_SERVERS,
	IDC_VSC_VIRTUAL_SERVERS, IDH_VSC_VIRTUAL_SERVERS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP[]=
{
	IDC_WIZARD_PAGE_DESCRIPTION, IDH_DISABLEHELP,
	IDC_VSG_CREATE_NEW, IDH_VSG_CREATE_NEW,
	IDC_VSG_USE_EXISTING, IDH_VSG_USE_EXISTING,
	IDC_VSG_GROUPS_LABEL, IDH_VSG_GROUPS,
	IDC_VSG_GROUPS, IDH_VSG_GROUPS,
	0, 0
};

const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME[]=
{
	IDC_VSGN_GROUP_NAME_TITLE, IDH_DISABLEHELP,
	IDC_VSGN_GROUP_NAME_LABEL, IDH_VSGN_GROUP_NAME,
	IDC_VSGN_GROUP_NAME, IDH_VSGN_GROUP_NAME,
	IDC_VSGN_GROUP_DESC_LABEL, IDH_VSGN_GROUP_DESC,
	IDC_VSGN_GROUP_DESC, IDH_VSGN_GROUP_DESC,
	0, 0
};

const DWORD g_aHelpIDs_IDD_WELCOME[]=
{
	IDC_WIZARD_TITLE, IDH_DISABLEHELP,
	IDC_WIZARD_SUBTITLE_1, IDH_DISABLEHELP,
	IDC_WIZARD_SUBTITLE_2, IDH_DISABLEHELP,
	IDC_WIZARD_CLICK_NEXT, IDH_DISABLEHELP,
	0, 0
};

#else

extern const DWORD g_aHelpIDs_IDD_WELCOME[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO[];
extern const DWORD g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_CREATE[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_TYPE[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_NAME_DESC[];
extern const DWORD g_aHelpIDs_IDD_APP_RESOURCE_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_COMPLETION[];
extern const DWORD g_aHelpIDs_IDD_ENTER_SUBNET_MASK[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS[];
extern const DWORD g_aHelpIDs_IDD_MODIFY_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_FAILOVER[];
extern const DWORD g_aHelpIDs_IDD_GRPADV_FAILBACK[];
extern const DWORD g_aHelpIDs_IDD_RES_GENERAL[];
extern const DWORD g_aHelpIDs_IDD_RES_DEPENDENCIES[];
extern const DWORD g_aHelpIDs_IDD_RES_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_RES_IP_PARAMS[];
extern const DWORD g_aHelpIDs_IDD_RES_NETNAME_PARAMS[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		Galen Barbee (galenb)	May 19, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __HELPDATA_H_
#define __HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // __HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\helpids.h ===
// This file is used by CLADMWIZ.RC
//
// Created in Dev. Studio by Melissa Simmons, 4/7/99

//text unique to this wizard
#define IDH_ARC_CREATE_RES 700003000
#define IDH_ARC_DONT_CREATE_RES 700003001
#define IDH_ARND_ADVANCED_PROPS 700003027
#define IDH_ARND_RES_DESC 700003026
#define IDH_ARND_RES_NAME 700003025
#define IDH_ART_RESTYPES 700003050
#define IDH_ESM_IP_ADDRESS 700003100
#define IDH_ESM_SUBNET_MASK 700003101
#define IDH_RES_POSSIBLE_OWNERS_MODIFY 700003328
#define IDH_VSA_ADVANCED_PROPS 700003426
#define IDH_VSA_CATEGORIES 700003425
#define IDH_VSAI_IP_ADDRESS 700003401
#define IDH_VSAI_NETWORK_NAME 700003400
#define IDH_ESM_NETWORKS 700003402
#define IDH_VSC_CREATE_NEW 700003450
#define IDH_VSC_USE_EXISTING 700003451
#define IDH_VSC_VIRTUAL_SERVERS 700003452
#define IDH_VSG_CREATE_NEW 700003475
#define IDH_VSG_GROUPS 700003477
#define IDH_VSG_USE_EXISTING 700003476
#define IDH_VSGN_GROUP_DESC 700003501
#define IDH_VSGN_GROUP_NAME 700003500
#define IDH_WIZARD_LISTBOX 700003075
#define IDH_GAG_MODIFY 700003080
#define IDH_RES_NETNAME_NAME 700003090
#define IDH_GAG_NAME 700003175
#define IDH_NETNAME_PARAMS_NAME 700003375
//borrowed text
#define	IDH_PP_GROUP_AUTOFB_ALLOW	700001276
#define	IDH_PP_GROUP_AUTOFB_PREVENT	700001275
#define	IDH_PP_GROUP_FB_IMMED	700001277
#define	IDH_PP_GROUP_FB_WINDOW	700001278
#define	IDH_PP_GROUP_FBWIN_END	700001280
#define	IDH_PP_GROUP_FBWIN_START	700001279
//borrowed text
#define	IDH_PP_GROUP_FAILOVER_PERIOD	700001301
#define	IDH_PP_GROUP_FAILOVER_THRESH	700001300
//borrowed text
#define	IDH_PP_GROUP_DESC	700001326
#define	IDH_PP_GROUP_PREF_OWNERS	700001327
#define	IDH_PP_GROUP_PREF_OWNERS_MODIFY	700001328
//borrowed text
#define	IDH_LCP_ADD	700001076
#define	IDH_LCP_LEFT_LIST	700001075
#define	IDH_LCP_REMOVE	700001077
#define	IDH_LCP_RIGHT_LIST	700001078
//borrowed text
#define	IDH_POSIBLE_LCP_REMOVE	700001102
#define	IDH_POSSIBLE_LCP_ADD	700001101
#define	IDH_POSSIBLE_LCP_LEFT_LIST	700001100
#define	IDH_POSSIBLE_LCP_RIGHT_LIST	700001103
//borrowed text
#define	IDH_PREF_LCP_LEFT_LIST	700001125
#define	IDH_PREF_LCP_RIGHT_LIST	700001128
#define	IDH_LCP_MOVE_DOWN	700001130
#define	IDH_LCP_MOVE_UP	700001129
//borrowed text
#define	IDH_PP_RES_AFFECT_THE_GROUP	700001437
#define	IDH_PP_RES_DONT_RESTART	700001435
#define	IDH_PP_RES_RESTART	700001436
#define	IDH_PP_RES_RESTART_THRESHOLD	70000143
#define	IDH_PP_RES_RESTART_PERIOD	700001425
#define	IDH_PP_RES_LOOKS_ALIVE_GROUP	700001426
#define	IDH_PP_RES_DEFAULT_LOOKS_ALIVE	700001427
#define	IDH_PP_RES_SPECIFY_LOOKS_ALIVE	700001428
#define	IDH_PP_RES_LOOKS_ALIVE	700001429
#define	IDH_PP_RES_IS_ALIVE_GROUP	700001430
#define	IDH_PP_RES_DEFAULT_IS_ALIVE	700001431
#define	IDH_PP_RES_SPECIFY_IS_ALIVE	700001432
#define	IDH_PP_RES_IS_ALIVE	700001433
#define	IDH_PP_RES_PENDING_TIMEOUT	700001434
//borrowed text
#define	IDH_PP_RES_DEPENDS_LIST	700001450
#define	IDH_PP_RES_MODIFY	700001451
//borrowed text
#define	IDH_PP_RES_NAME	700001475
#define	IDH_PP_RES_DESC	700001476
#define	IDH_PP_RES_POSSIBLE_OWNERS	700001477
#define	IDH_PP_RES_SEPARATE_MONITOR	700001479
//borrowed text
#define	IDH_PP_IPADDR_PARAMS_ADDRESS	700000200
#define	IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS	700000203
#define	IDH_PP_IPADDR_PARAMS_NETWORK	700000202
#define	IDH_PP_IPADDR_PARAMS_SUBNET_MASK	700000201
//borrowed text
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\lcpair.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		LCPair.h
//
//	Abstract:
//		Definition of the CModifyNodesDlg and CModifyResourcesDlg dialogs.
//
//	Implementation File:
//		LCPair.cpp
//
//	Author:
//		David Potter (davidp)	April 16, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __LCPAIR_H_
#define __LCPAIR_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT > class CModifyNodesDlg;
template < class T, class BaseT > class CModifyResourcesDlg;
class CModifyPreferredOwners;
class CModifyPossibleOwners;
class CModifyDependencies;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;
class CClusResInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"	// for CClusterObject, CClusObjPtrList
#endif

#ifndef __ATLLCPAIR_H_
#include "AtlLCPair.h"	// for CListCtrlPair
#endif

#ifndef __ATLBASEDLG_H_
#include "AtlBaseDlg.h"	// for CBaseDlg
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"	// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CModifyNodesDlg
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT >
class CModifyNodesDlg : public CListCtrlPair< T, CClusNodeInfo, BaseT >
{
	typedef CModifyNodesDlg< T, BaseT >	thisClass;
	typedef CListCtrlPair< T, CClusNodeInfo, BaseT > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CModifyNodesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN LPCTSTR				pszTitle = NULL
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				pszTitle
				)
	{
		ASSERT( pwiz != NULL );

		m_pwiz = pwiz;

	} //*** CModifyNodesDlg()

	// Constructor taking a resource ID for the title
	CModifyNodesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN UINT					nIDCaption
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				nIDCaption
				)
	{
		ASSERT( pwiz != NULL );

		m_pwiz = pwiz;

	} //*** CModifyNodesDlg()

protected:
	CClusterAppWizard * m_pwiz;

public:
	CClusterAppWizard * Pwiz( void ) const { return m_pwiz; }

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Get column text and image
	void GetColumnInfo(
		IN OUT CClusNodeInfo *	pobj,
		IN int					iItem,
		IN int					icol,
		OUT CString &			rstr,
		OUT int *				piimg
		)
	{
		switch ( icol )
		{
			case 0:
				rstr = pobj->RstrName();
				break;
			default:
				ASSERT( 0 );
				break;
		} // switch: icol

	} //*** GetColumnInfo()

	// Display an application-wide message box
	virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
	{
		return ::AppMessageBox( m_hWnd, lpszText, fuStyle );

	} //*** AppMessageBox()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void )
	{
		//
		// Add columns.
		//
		AddColumn( IDS_COLTEXT_NODE_NAME, 125 /* nWidth */);

		//
		// Call the base class.
		//
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//static const DWORD * PidHelpMap( void ) { return g_; };

};  //*** class CModifyNodesDlg

/////////////////////////////////////////////////////////////////////////////
// class CModifyResourcesDlg
/////////////////////////////////////////////////////////////////////////////

template < class T, class BaseT >
class CModifyResourcesDlg : public CListCtrlPair< T, CClusResInfo, BaseT >
{
	typedef CModifyResourcesDlg< T, BaseT >	thisClass;
	typedef CListCtrlPair< T, CClusResInfo, BaseT > baseClass;

public:
	//
	// Construction
	//

	// Constructor taking a string pointer for the title
	CModifyResourcesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN LPCTSTR				pszTitle = NULL
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				pszTitle
				)
		, m_pwiz( pwiz )
	{
		ASSERT( pwiz != NULL);

	} //*** CModifyResourcesDlg()

	// Constructor taking a resource ID for the title
	CModifyResourcesDlg(
		IN CClusterAppWizard *	pwiz,
		IN DWORD				dwStyle,
		IN UINT					nIDCaption
		)
		: baseClass(
				dwStyle | /*LCPS_PROPERTIES_BUTTON | */(dwStyle & LCPS_ORDERED ? LCPS_CAN_BE_ORDERED : 0),
				nIDCaption
				)
		, m_pwiz( pwiz )
	{
		ASSERTE( pwiz != NULL );

	} //*** CModifyResourcesDlg()

protected:
	CClusterAppWizard * m_pwiz;

public:
	CClusterAppWizard * Pwiz( void ) const { return m_pwiz; }

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Get column text and image
	void GetColumnInfo(
		IN OUT CClusResInfo *	pobj,
		IN int					iItem,
		IN int					icol,
		OUT CString &			rstr,
		OUT int *				piimg
		)
	{
		switch ( icol )
		{
			case 0:
				rstr = pobj->RstrName();
				break;
			case 1:
				rstr = pobj->Prti()->RstrDisplayName();
				break;
			default:
				ASSERT( 0 );
				break;
		} // switch:  icol

	} //*** GetColumnInfo()

	// Display an application-wide message box
	virtual int AppMessageBox( LPCWSTR lpszText, UINT fuStyle )
	{
		return ::AppMessageBox( m_hWnd, lpszText, fuStyle );

	} //*** AppMessageBox()

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( thisClass )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void )
	{
		//
		// Add columns.
		//
		AddColumn( IDS_COLTEXT_RESOURCE_NAME, 125 /* nWidth */);
		AddColumn( IDS_COLTEXT_RESOURCE_TYPE, 100 /* nWidth */);

		//
		// Call the base class.
		//
		return baseClass::OnInitDialog();

	} //*** OnInitDialog()

	//static const DWORD * PidHelpMap( void ) { return g_; };

};  //*** class CModifyResourcesDlg

/////////////////////////////////////////////////////////////////////////////
// class CModifyPreferredOwners
/////////////////////////////////////////////////////////////////////////////

class CModifyPreferredOwners : public CModifyNodesDlg< CModifyPreferredOwners, CBaseDlg< CModifyPreferredOwners > >
{
	typedef CModifyNodesDlg< CModifyPreferredOwners, CBaseDlg< CModifyPreferredOwners > > baseClass;

public:
	// Constructor
	CModifyPreferredOwners(
		IN CClusterAppWizard *		pwiz,
		IN CClusGroupInfo *			pgi,
		IN OUT CClusNodePtrList *	plpniRight,
		IN CClusNodePtrList *		plpniLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY | LCPS_CAN_BE_ORDERED | LCPS_ORDERED )
		, m_pgi( pgi )
		, m_plpniRight( plpniRight )
		, m_plpniLeft( plpniLeft )
	{
		ASSERT( pgi != NULL );
		ASSERT( plpniRight != NULL );
		ASSERT( plpniLeft != NULL );

	} //*** CModifyPreferredOwners()

	enum { IDD = IDD_MODIFY_PREFERRED_OWNERS };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusGroupInfo *	m_pgi;
	CClusNodePtrList *	m_plpniRight;
	CClusNodePtrList *	m_plpniLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusNodePtrList * PlpobjRight( void ) const
	{
		return m_plpniRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusNodePtrList * PlpobjLeft( void ) const
	{
		return m_plpniLeft;

	} //*** PlpobjRight()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_PREFERRED_OWNERS; };

}; //*** class CModifyPreferredOwners

/////////////////////////////////////////////////////////////////////////////
// class CModifyPossibleOwners
/////////////////////////////////////////////////////////////////////////////

class CModifyPossibleOwners : public CModifyNodesDlg< CModifyPossibleOwners, CBaseDlg< CModifyPossibleOwners > >
{
	typedef CModifyNodesDlg< CModifyPossibleOwners, CBaseDlg< CModifyPossibleOwners > > baseClass;

public:
	// Constructor
	CModifyPossibleOwners(
		IN CClusterAppWizard *		pwiz,
		IN CClusResInfo *			pri,
		IN OUT CClusNodePtrList *	plpniRight,
		IN CClusNodePtrList *		plpniLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY )
		, m_pri( pri )
		, m_plpniRight( plpniRight )
		, m_plpniLeft( plpniLeft )
	{
		ASSERT( pri != NULL );
		ASSERT( plpniRight != NULL );
		ASSERT( plpniLeft != NULL );

	} //*** CModifyPossibleOwners()

	enum { IDD = IDD_MODIFY_POSSIBLE_OWNERS };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusResInfo *		m_pri;
	CClusNodePtrList *	m_plpniRight;
	CClusNodePtrList *	m_plpniLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusNodePtrList * PlpobjRight( void ) const
	{
		return m_plpniRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusNodePtrList * PlpobjLeft( void ) const
	{
		return m_plpniLeft;

	} //*** PlpobjRight()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_POSSIBLE_OWNERS; };

}; //*** class CModifyPossibleOwners

/////////////////////////////////////////////////////////////////////////////
// class CModifyDependencies
/////////////////////////////////////////////////////////////////////////////

class CModifyDependencies
	: public CModifyResourcesDlg< CModifyDependencies, CBaseDlg< CModifyDependencies > >
{
	typedef CModifyResourcesDlg< CModifyDependencies, CBaseDlg< CModifyDependencies > > baseClass;

public:
	// Constructor
	CModifyDependencies(
		IN CClusterAppWizard *		pwiz,
		IN CClusResInfo *			pri,
		IN OUT CClusResPtrList *	plpriRight,
		IN CClusResPtrList *		plpriLeft
		)
		: baseClass( pwiz, LCPS_SHOW_IMAGES | LCPS_ALLOW_EMPTY )
		, m_pri( pri )
		, m_plpriRight( plpriRight )
		, m_plpriLeft( plpriLeft )
	{
		ASSERT( pri != NULL );
		ASSERT( plpriRight != NULL );
		ASSERT( plpriLeft != NULL );

	} //*** CModifyDependencies()

	enum { IDD = IDD_MODIFY_DEPENDENCIES };

	DECLARE_CTRL_NAME_MAP()

protected:
	CClusResInfo * m_pri;
	CClusResPtrList * m_plpriRight;
	CClusResPtrList * m_plpriLeft;

public:
	//
	// Functions that are required to be implemented by CListCtrlPair.
	//

	// Return list of objects for right list control
	CClusResPtrList * PlpobjRight( void ) const
	{
		return m_plpriRight;

	} //*** PlpobjRight()

	// Return list of objects for left list control
	CClusResPtrList * PlpobjLeft( void ) const
	{
		return m_plpriLeft;

	} //*** PlpobjRight()

	// Update data on or from the dialog
	BOOL UpdateData( IN BOOL bSaveAndValidate )
	{
		BOOL	bSuccess = TRUE;

		bSuccess = baseClass::UpdateData( bSaveAndValidate );
		if ( bSuccess )
		{
			if ( bSaveAndValidate )
			{
				//
				// Ensure all required dependencies are present.
				//
				if ( ! Pwiz()->BRequiredDependenciesPresent( m_pri, &LpobjRight() ) )
				{
					bSuccess = FALSE;
				} // if:  all required dependencies not present
			} // if:  saving data from the dialog
		} // if:  base class was successful

		return bSuccess;

	} //*** UpdateData()

	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_MODIFY_DEPENDENCIES; };

}; //*** class CModifyDependencies

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CModifyPreferredOwners Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyPreferredOwners )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_MOVE_UP )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_MOVE_DOWN )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifyPossibleOwners Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyPossibleOwners )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModifyDependencies Control Name Map

BEGIN_CTRL_NAME_MAP( CModifyDependencies )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_LEFT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_ADD )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_REMOVE )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( ADMC_IDC_LCP_RIGHT_LIST )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDOK )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDCANCEL )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __LCPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\resadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ResAdv.h
//
//  Abstract:
//      Definition of the advanced resource property sheet classes.
//
//  Implementation File:
//      ResAdv.cpp
//
//  Author:
//      David Potter (davidp)   March 5, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESADV_H_
#define __RESADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

template < class T > class CResourceAdvancedSheet;
class CGeneralResourceAdvancedSheet;
class CIPAddrAdvancedSheet;
template < class T, class TSht > class CResourceAdvancedBasePage;
template < class T, class TSht > class CResourceGeneralPage;
template < class T, class TSht > class CResourceDependenciesPage;
template < class T, class TSht > class CResourceAdvancedPage;
class CIPAddrParametersPage;
class CNetNameParametersPage;
class CGeneralResourceGeneralPage;
class CGeneralResourceDependenciesPage;
class CGeneralResourceAdvancedPage;
class CIPAddrResourceGeneralPage;
class CIPAddrResourceDependenciesPage;
class CIPAddrResourceAdvancedPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __ATLBASEPROPSHEET_H_
#include "AtlBasePropSheet.h"   // for CBasePropertySheetImpl
#endif

#ifndef __ATLBASEPROPPAGE_H_
#include "AtlBasePropPage.h"    // for CBasePropertyPageImpl
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"         // for CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"           // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

template < class T >
class CResourceAdvancedSheet : public CBasePropertySheetImpl< T >
{
    typedef CResourceAdvancedSheet< T > thisClass;
    typedef CBasePropertySheetImpl< T > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CResourceAdvancedSheet(
        IN UINT                 nIDCaption,
        IN CClusterAppWizard *  pwiz
        )
        : baseClass( nIDCaption )
        , m_pwiz( pwiz )
        , m_prti( NULL )
        , m_pri( NULL )
        , m_pbChanged( NULL )
    {
        ASSERT( pwiz != NULL );

    } //*** CResourceAdvancedSheet()

    // Initialize the sheet
    BOOL BInit( IN OUT CClusResInfo & rri, IN OUT BOOL & rbChanged );

    // Add all pages to the page array
    virtual BOOL BAddAllPages( void ) = 0;

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CResourceAdvancedSheet )
//  END_MSG_MAP()
//  DECLARE_EMPTY_MSG_MAP()

    //
    // Message handler functions.
    //

// Implementation
protected:
    CClusterAppWizard * m_pwiz;
    CClusResInfo *      m_pri;
    CClusResTypeInfo *  m_prti;
    BOOL *              m_pbChanged;

public:
    CClusterAppWizard * Pwiz( void ) const          { return m_pwiz; }
    CClusResInfo *      Pri( void ) const           { return m_pri; }
    CClusResTypeInfo *  Prti( void ) const          { return m_prti; }
    void                SetResInfoChanged( void )   { ASSERT( m_pbChanged != NULL ); *m_pbChanged = TRUE; }

    // Return the help ID map
    //static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CResourceAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceAdvancedSheet : public CResourceAdvancedSheet< CGeneralResourceAdvancedSheet >
{
    typedef CResourceAdvancedSheet< CGeneralResourceAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CGeneralResourceAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
        : baseClass( nIDCaption, pwiz )
    {
    } //*** CGeneralResourceAdvancedSheet()

    // Destructor
    ~CGeneralResourceAdvancedSheet( void )
    {
    } //*** ~CGeneralResourceAdvancedSheet()

    // Add all pages to the page array
    virtual BOOL BAddAllPages( void );

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CGeneralResourceAdvancedSheet )
//  END_MSG_MAP()
    DECLARE_EMPTY_MSG_MAP()
    DECLARE_CLASS_NAME()

    //
    // Message handler functions.
    //

// Implementation
protected:

public:

    // Return the help ID map
    //static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CGeneralResourceAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CIPAddrAdvancedSheet : public CResourceAdvancedSheet< CIPAddrAdvancedSheet >
{
    typedef CResourceAdvancedSheet< CIPAddrAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CIPAddrAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
        : baseClass( nIDCaption, pwiz )
    {
    } //*** CIPAddrAdvancedSheet()

    // Destructor
    ~CIPAddrAdvancedSheet( void )
    {
    } //*** ~CIPAddrAdvancedSheet()

    // Add all pages to the page array
    virtual BOOL BAddAllPages( void );

    // Initialize IP Address-specific data
    void InitPrivateData(
        IN const CString &      strIPAddress,
        IN const CString &      strSubnetMask,
        IN const CString &      strNetwork,
        IN BOOL                 bEnableNetBIOS,
        CClusNetworkPtrList *   plpniNetworks
        )
    {
        ASSERT( plpniNetworks != NULL );

        m_strIPAddress = strIPAddress;
        m_strSubnetMask = strSubnetMask;
        m_strNetwork = strNetwork;
        m_bEnableNetBIOS = bEnableNetBIOS;
        m_plpniNetworks = plpniNetworks;

    } //*** InitPrivateData()

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CIPAddrAdvancedSheet )
//  END_MSG_MAP()
    DECLARE_EMPTY_MSG_MAP()
    DECLARE_CLASS_NAME()

    //
    // Message handler functions.
    //

// Implementation
protected:
    CClusNetworkPtrList * m_plpniNetworks;

public:
    CString     m_strIPAddress;
    CString     m_strSubnetMask;
    CString     m_strNetwork;
    BOOL        m_bEnableNetBIOS;

    CClusNetworkPtrList * PlpniNetworks( void ) { return m_plpniNetworks; }

    // Return the help ID map
    //static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CIPAddrAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CNetNameAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

class CNetNameAdvancedSheet : public CResourceAdvancedSheet< CNetNameAdvancedSheet >
{
    typedef CResourceAdvancedSheet< CNetNameAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CNetNameAdvancedSheet( IN UINT nIDCaption, IN CClusterAppWizard * pwiz )
        : baseClass( nIDCaption, pwiz )
    {
    } //*** CNetNameAdvancedSheet()

    // Destructor
    ~CNetNameAdvancedSheet( void )
    {
    } //*** ~CNetNameAdvancedSheet()

    // Add all pages to the page array
    virtual BOOL BAddAllPages( void );

    // Initialize Network Name-specific data
    void InitPrivateData( IN const CString & strNetName )
    {
        m_strNetName = strNetName;

    } //*** InitPrivateData()

public:
    //
    // Message map.
    //
//  BEGIN_MSG_MAP( CNetNameAdvancedSheet )
//  END_MSG_MAP()
    DECLARE_EMPTY_MSG_MAP()
    DECLARE_CLASS_NAME()

    //
    // Message handler functions.
    //

// Implementation
protected:

public:
    CString     m_strNetName;

    // Return the help ID map
    //static const DWORD * PidHelpMap( void ) { return g_; }

}; //*** class CNetNameAdvancedSheet

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedBasePage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceAdvancedBasePage : public CStaticPropertyPageImpl< T >
{
    typedef CResourceAdvancedBasePage< T, TSht > thisClass;
    typedef CStaticPropertyPageImpl< T > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CResourceAdvancedBasePage( void )
    {
    } //*** CGroupFailoverPage()

public:
    //
    // Message map.
    //
    //
    // Message handler functions.
    //

    // Handler for changed fields
    LRESULT OnChanged(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        SetModified( TRUE );
        return 0;

    } // OnChanged()

// Implementation
protected:
    //
    // Controls.
    //

    //
    // Page state.
    //

protected:
    CResourceAdvancedSheet< TSht > *    PshtThis( void ) const      { return (CResourceAdvancedSheet< TSht > *) Psht(); }
    CClusResInfo *                      Pri( void ) const           { return PshtThis()->Pri(); }
    CClusResTypeInfo *                  Prti( void ) const          { return PshtThis()->Prti(); }
    CClusterAppWizard *                 Pwiz( void ) const          { return PshtThis()->Pwiz(); }
    void                                SetResInfoChanged( void )   { PshtThis()->SetResInfoChanged(); }

public:

}; //*** class CResourceAdvancedBasePage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedSheet::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      rgi         [IN OUT] The resource info object.
//      rbChanged   [IN OUT] TRUE = resource info was changed by property sheet.
//
//  Return Value:
//      TRUE        Sheet initialized successfully.
//      FALSE       Error initializing sheet.  Error already displayed.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T >
BOOL CResourceAdvancedSheet< T >::BInit(
    IN OUT CClusResInfo &   rri,
    IN OUT BOOL &           rbChanged
    )
{
    BOOL bSuccess = FALSE;

    m_pri = &rri;
    m_pbChanged = &rbChanged;

    // Loop to avoid goto's
    do
    {
        //
        // Collect resource types.
        //
        if ( ! Pwiz()->BCollectResourceTypes( m_hWnd ) )
        {
            break;
        } // if:  error collecting resource types

        //
        // Find the resource type of this resource
        //
        ASSERT( rri.Prti() != NULL );
        m_prti = Pwiz()->PrtiFindResourceTypeNoCase( rri.Prti()->RstrName() );
        if ( m_prti == NULL )
        {
            AppMessageBox( m_hWnd, IDS_RESOURCE_TYPE_NOT_FOUND, MB_OK | MB_ICONEXCLAMATION );
            break;
        } // if:  error finding resource type

        //
        // Fill the page array.
        //
        if ( ! BAddAllPages() )
        {
            break;
        } // if:  error adding pages

        //
        // Call the base class.
        //
        if ( ! baseClass::BInit() )
        {
            break;
        } // if:  error initializing the base class

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CResourceAdvancedSheet< class T >::BInit()

/////////////////////////////////////////////////////////////////////////////
// class CResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceGeneralPage : public CResourceAdvancedBasePage< T, TSht >
{
    typedef CResourceGeneralPage< T, TSht > thisClass;
    typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CResourceGeneralPage( void )
        : m_bSeparateMonitor( FALSE )
        , m_bPossibleOwnersChanged( FALSE )
    {
    } //*** CGroupFailoverPage()

    enum { IDD = IDD_RES_GENERAL };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        COMMAND_HANDLER( IDC_RES_NAME, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_RES_DESC, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_RES_POSSIBLE_OWNERS_MODIFY, BN_CLICKED, OnModify )
        COMMAND_HANDLER( IDC_RES_SEPARATE_MONITOR, BN_CLICKED, OnChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on the MODIFY push button
    LRESULT OnModify(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for WM_INITDIALOG
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CListBox    m_lbPossibleOwners;
    CButton     m_pbModifyPossibleOwners;

    //
    // Page state.
    //
    CString m_strName;
    CString m_strDesc;
    BOOL    m_bSeparateMonitor;

    CClusNodePtrList m_lpniPossibleOwners;

    BOOL m_bPossibleOwnersChanged;

protected:
    // Fill in the list of possible owners
    void FillPossibleOwnersList( void );

    // Save the resource name
    BOOL BSaveName( void )
    {
        if ( Pri()->RstrName() != m_strName )
        {
            Pri()->SetName( m_strName );
            return TRUE;
        } // if:  value changed

        return FALSE;

    } //*** BSaveName()

    // Save the group description
    BOOL BSaveDescription( void )
    {
        if ( Pri()->RstrDescription() != m_strDesc )
        {
            Pri()->SetDescription( m_strDesc );
            return TRUE;
        } // if:  value changed

        return FALSE;

    } //*** BSaveDescription()

    // Save the SeparateMonitor flag
    BOOL BSaveSeparateMonitor( void )
    {
        return Pri()->BSetSeparateMonitor( m_bSeparateMonitor );

    } //*** BSaveSeparateMonitor()

    // Save possible owners
    BOOL BSavePossibleOwners( void )
    {
        if ( m_bPossibleOwnersChanged )
        {
            *Pri()->PlpniPossibleOwners() = m_lpniPossibleOwners;
            return TRUE;
        } // if:  possible owners changed

        return FALSE;

    } //*** BSavePossibleOwners()

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_GENERAL; }

}; //*** class CResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceDependenciesPage : public CResourceAdvancedBasePage< T, TSht >
{
    typedef CResourceDependenciesPage< T, TSht > thisClass;
    typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CResourceDependenciesPage( void )
        : m_bDependenciesChanged( FALSE )
    {
    } //*** CResourceDependenciesPage()

    enum { IDD = IDD_RES_DEPENDENCIES };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        COMMAND_HANDLER( IDC_RES_DEPENDS_MODIFY, BN_CLICKED, OnModify )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on the MODIFY push button
    LRESULT OnModify(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CListViewCtrl   m_lvcDependencies;

    //
    // Page state.
    //
    CClusResPtrList m_lpriDependencies;
    CClusResPtrList m_lpriResourcesInGroup;

    BOOL m_bDependenciesChanged;

protected:
    // Fill in the list of dependencies
    void FillDependenciesList( void );

    // Returns whether dependencies list has changed
    BOOL BDependenciesChanged( void ) const { return m_bDependenciesChanged; }

    // Save dependencies
    BOOL BSaveDependencies( void )
    {
        if ( m_bDependenciesChanged )
        {
            *Pri()->PlpriDependencies() = m_lpriDependencies;
            return TRUE;
        } // if:  dependencies changed

        return FALSE;

    } //*** BSaveDependencies()

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_DEPENDENCIES; }

}; //*** class CResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

template < class T, class TSht >
class CResourceAdvancedPage : public CResourceAdvancedBasePage< T, TSht >
{
    typedef CResourceAdvancedPage< T, TSht > thisClass;
    typedef CResourceAdvancedBasePage< T, TSht > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CResourceAdvancedPage( void )
        : m_bAffectTheGroup( FALSE )
        , m_nRestart( -1 )
        , m_crraRestartAction( CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION )
        , m_nThreshold( CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD )
        , m_nPeriod( CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD )
        , m_nLooksAlive( CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE )
        , m_nIsAlive( CLUSTER_RESOURCE_DEFAULT_IS_ALIVE )
        , m_nPendingTimeout( CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT )
    {
    } //*** CResourceAdvancedPage()

    enum { IDD = IDD_RES_ADVANCED };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( thisClass )
        COMMAND_HANDLER( IDC_RES_DONT_RESTART, BN_CLICKED, OnClickedDontRestart )
        COMMAND_HANDLER( IDC_RES_RESTART, BN_CLICKED, OnClickedRestart )
        COMMAND_HANDLER( IDC_RES_AFFECT_THE_GROUP, BN_CLICKED, OnChanged )
        COMMAND_HANDLER( IDC_RES_RESTART_THRESHOLD, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_RES_RESTART_PERIOD, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_RES_DEFAULT_LOOKS_ALIVE, BN_CLICKED, OnClickedDefaultLooksAlive )
        COMMAND_HANDLER( IDC_RES_SPECIFY_LOOKS_ALIVE, BN_CLICKED, OnClickedSpecifyLooksAlive )
        COMMAND_HANDLER( IDC_RES_LOOKS_ALIVE, EN_CHANGE, OnChangeLooksAlive )
        COMMAND_HANDLER( IDC_RES_DEFAULT_IS_ALIVE, BN_CLICKED, OnClickedDefaultIsAlive )
        COMMAND_HANDLER( IDC_RES_SPECIFY_IS_ALIVE, BN_CLICKED, OnClickedSpecifyIsAlive )
        COMMAND_HANDLER( IDC_RES_IS_ALIVE, EN_CHANGE, OnChangeIsAlive )
        COMMAND_HANDLER( IDC_RES_PENDING_TIMEOUT, EN_CHANGE, OnChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    //
    // Message handler functions.
    //

    // Handler for BN_CLICKED on IDC_RES_DONT_RESTART
    LRESULT OnClickedDontRestart(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        //
        // Disable the restart parameter controls.
        //
        m_ckbAffectTheGroup.EnableWindow( FALSE );
        m_editThreshold.EnableWindow( FALSE );
        m_editPeriod.EnableWindow( FALSE );

        //
        // Set the page as modified if the state changed
        //
        if ( m_nRestart != 0 )
        {
            SetModified( TRUE );
        }  // if:  state changed

        return 0;

    } //*** OnClickedDontRestart()

    // Handler for BN_CLICKED on IDC_RES_RESTART
    LRESULT OnClickedRestart(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        //
        // Enable the restart parameter controls.
        //
        m_ckbAffectTheGroup.EnableWindow( TRUE );
        m_editThreshold.EnableWindow( TRUE );
        m_editPeriod.EnableWindow( TRUE );

        //
        // Set the page as modified if the state changed.
        //
        if ( m_nRestart != 1 )
        {
            SetModified( TRUE );
        }  // if:  state changed

        return 0;

    } //*** OnClickedRestart()

    // Default handler for clicking IDC_RES_DONT_RESTART
    void OnClickedDontRestart( void )
    {
        BOOL bHandled = TRUE;
        OnClickedDontRestart( 0, 0, 0, bHandled );

    } //*** OnClickedDontRestart()

    // Default handler for clicking IDC_RES_RESTART
    void OnClickedRestart( void )
    {
        BOOL bHandled = TRUE;
        OnClickedRestart( 0, 0, 0, bHandled );

    } //*** OnClickedRestart()

    // Handler for BN_CLICKED on IDC_RES_DEFAULT_LOOKS_ALIVE
    LRESULT OnClickedDefaultLooksAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_editLooksAlive.SetReadOnly();

        if ( m_nLooksAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            CString str;

            str.Format( _T("%d"), Pri()->NLooksAlive() );
            m_editLooksAlive.SetWindowText( str );

            m_rbDefaultLooksAlive.SetCheck( BST_CHECKED );
            m_rbSpecifyLooksAlive.SetCheck( BST_UNCHECKED );

            SetModified( TRUE );
        }  // if:  value changed

        return 0;

    } //*** OnClickedDefaultLooksAlive()

    // Handler for BN_CLICKED on IDC_RES_SPECIFY_LOOKS_ALIVE
    LRESULT OnClickedSpecifyLooksAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_editLooksAlive.SetReadOnly( FALSE );

        if ( m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            SetModified( TRUE );
        } // if:  state changed

        return 0;

    } //*** OnClickedSpecifyLooksAlive()

    // Handler for EN_CHANGE on IDC_RES_LOOKS_ALIVE
    LRESULT OnChangeLooksAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_rbDefaultLooksAlive.SetCheck( BST_UNCHECKED );
        m_rbSpecifyLooksAlive.SetCheck( BST_CHECKED );

        SetModified( TRUE );
        return 0;

    } //*** OnChangeLooksAlive()

    // Handler for BN_CLICKED on IDC_RES_DEFAULT_IS_ALIVE
    LRESULT OnClickedDefaultIsAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_editIsAlive.SetReadOnly();

        if ( m_nIsAlive != (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            CString str;

            str.Format( _T("%d"), Pri()->NIsAlive() );
            m_editIsAlive.SetWindowText( str );

            m_rbDefaultIsAlive.SetCheck( BST_CHECKED );
            m_rbSpecifyIsAlive.SetCheck( BST_UNCHECKED );

            SetModified( TRUE );
        }  // if:  value changed

        return 0;

    } //*** OnClickedDefaultIsAlive()

    // Handler for BN_CLICKED on IDC_RES_SPECIFY_IS_ALIVE
    LRESULT OnClickedSpecifyIsAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_editIsAlive.SetReadOnly( FALSE );

        if ( m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            SetModified( TRUE );
        } // if:  state changed

        return 0;

    } //*** OnClickedSpecifyIsAlive()

    // Handler for EN_CHANGE on IDC_RES_IS_ALIVE
    LRESULT OnChangeIsAlive(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        m_rbDefaultIsAlive.SetCheck( BST_UNCHECKED );
        m_rbSpecifyIsAlive.SetCheck( BST_CHECKED );

        SetModified( TRUE );
        return 0;

    } //*** OnChangeIsAlive()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CButton m_rbDontRestart;
    CButton m_rbRestart;
    CEdit   m_editThreshold;
    CEdit   m_editPeriod;
    CButton m_ckbAffectTheGroup;
    CButton m_rbDefaultLooksAlive;
    CButton m_rbSpecifyLooksAlive;
    CEdit   m_editLooksAlive;
    CButton m_rbDefaultIsAlive;
    CButton m_rbSpecifyIsAlive;
    CEdit   m_editIsAlive;
    CEdit   m_editPendingTimeout;

    //
    // Page state.
    //
    BOOL    m_bAffectTheGroup;
    int     m_nRestart;
    CRRA    m_crraRestartAction;
    DWORD   m_nThreshold;
    DWORD   m_nPeriod;
    DWORD   m_nLooksAlive;
    DWORD   m_nIsAlive;
    DWORD   m_nPendingTimeout;

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_ADVANCED; }

}; //*** class CResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrParametersPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrParametersPage
    : public CResourceAdvancedBasePage< CIPAddrParametersPage, CIPAddrAdvancedSheet >
{
    typedef CResourceAdvancedBasePage< CIPAddrParametersPage, CIPAddrAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CIPAddrParametersPage( void )
    {
    } //*** CIPAddrParametersPage()

    enum { IDD = IDD_RES_IP_PARAMS };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CIPAddrParametersPage )
        COMMAND_HANDLER( IDC_IPADDR_PARAMS_ADDRESS, EN_KILLFOCUS, OnKillFocusIPAddr )
        COMMAND_HANDLER( IDC_IPADDR_PARAMS_ADDRESS, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_IPADDR_PARAMS_SUBNET_MASK, EN_CHANGE, OnChanged )
        COMMAND_HANDLER( IDC_IPADDR_PARAMS_NETWORK, CBN_SELCHANGE, OnChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the EN_KILLFOCUS command notification on IDC_IPADDR_PARAMS_ADDRESS
    LRESULT OnKillFocusIPAddr(
        WORD wNotifyCode,
        int  idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CIPAddressCtrl  m_ipaIPAddress;
    CIPAddressCtrl  m_ipaSubnetMask;
    CComboBox       m_cboxNetworks;
    CButton         m_chkEnableNetBIOS;

    //
    // Page state.
    //
    CString         m_strIPAddress;
    CString         m_strSubnetMask;
    CString         m_strNetwork;
    BOOL            m_bEnableNetBIOS;

protected:
    CIPAddrAdvancedSheet * PshtThis( void ) const   { return reinterpret_cast< CIPAddrAdvancedSheet * >( Psht() ); }

    // Fill the list of networks
    void FillNetworksList( void );

    // Get a network info object from an IP address
    CClusNetworkInfo * PniFromIpAddress( IN LPCWSTR pszAddress );

    // Select a network based on a network info object
    void SelectNetwork(IN OUT CClusNetworkInfo * pni);

    BOOL BSaveIPAddress( void )
    {
        if ( PshtThis()->m_strIPAddress != m_strIPAddress )
        {
            PshtThis()->m_strIPAddress = m_strIPAddress;
            return TRUE;
        } // if:  user changed info

        return FALSE;

    } //*** BSaveIPAddress()

    BOOL BSaveSubnetMask( void )
    {
        if ( PshtThis()->m_strSubnetMask != m_strSubnetMask )
        {
            PshtThis()->m_strSubnetMask = m_strSubnetMask;
            return TRUE;
        } // if:  user changed info

        return FALSE;

    } //*** BSaveSubnetMask()

    BOOL BSaveNetwork( void )
    {
        if ( PshtThis()->m_strNetwork != m_strNetwork )
        {
            PshtThis()->m_strNetwork = m_strNetwork;
            return TRUE;
        } // if:  user changed info

        return FALSE;

    } //*** BSaveNetwork()

    BOOL BSaveEnableNetBIOS( void )
    {
        if ( PshtThis()->m_bEnableNetBIOS != m_bEnableNetBIOS )
        {
            PshtThis()->m_bEnableNetBIOS = m_bEnableNetBIOS;
            return TRUE;
        } // if:  user changed info

        return FALSE;

    } //*** BSaveEnableNetBIOS()

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_IP_PARAMS; }

}; //*** class CIPAddrParametersPage

/////////////////////////////////////////////////////////////////////////////
// class CNetNameParametersPage
/////////////////////////////////////////////////////////////////////////////

class CNetNameParametersPage
    : public CResourceAdvancedBasePage< CNetNameParametersPage, CNetNameAdvancedSheet >
{
    typedef CResourceAdvancedBasePage< CNetNameParametersPage, CNetNameAdvancedSheet > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CNetNameParametersPage( void )
    {
    } //*** CNetNameParametersPage()

    enum { IDD = IDD_RES_NETNAME_PARAMS };

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CNetNameParametersPage )
        COMMAND_HANDLER( IDC_NETNAME_PARAMS_NAME, EN_CHANGE, OnChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

// Implementation
protected:
    //
    // Controls.
    //
    CEdit   m_editNetName;

    //
    // Page state.
    //
    CString     m_strNetName;

protected:
    CNetNameAdvancedSheet * PshtThis( void ) const  { return reinterpret_cast< CNetNameAdvancedSheet * >( Psht() ); }

    BOOL BSaveNetName( void )
    {
        if ( PshtThis()->m_strNetName != m_strNetName )
        {
            PshtThis()->m_strNetName = m_strNetName;
            return TRUE;
        } // if:  user changed info

        return FALSE;

    } //*** BSaveNetName()

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_RES_NETNAME_PARAMS; }

}; //*** class CNetNameParametersPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceGeneralPage
    : public CResourceGeneralPage< CGeneralResourceGeneralPage, CGeneralResourceAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceGeneralPage
    : public CResourceGeneralPage< CIPAddrResourceGeneralPage , CIPAddrAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceGeneralPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceDependenciesPage
    : public CResourceDependenciesPage< CGeneralResourceDependenciesPage, CGeneralResourceAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceDependenciesPage
    : public CResourceDependenciesPage< CIPAddrResourceDependenciesPage, CIPAddrAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceDependenciesPage

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

class CGeneralResourceAdvancedPage
    : public CResourceAdvancedPage< CGeneralResourceAdvancedPage, CGeneralResourceAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CGeneralResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

class CIPAddrResourceAdvancedPage
    : public CResourceAdvancedPage< CIPAddrResourceAdvancedPage, CIPAddrAdvancedSheet >
{
public:
    DECLARE_CTRL_NAME_MAP()

}; //*** class CIPAddrResourceAdvancedPage

/////////////////////////////////////////////////////////////////////////////

#endif // __RESADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ClAdmWiz.rc
//
#define IDS_PROJNAME                    100
#define IDS_CLASS_DISPLAY_NAME          101
#define IDR_CLUSAPPWIZ                  102
#define IDB_WELCOME                     120
#define IDB_HEADER                      121
#define IDB_RES_32                      122
#define IDD_WELCOME                     200
#define IDD_VIRTUAL_SERVER_CREATE       201
#define IDD_VIRTUAL_SERVER_GROUP        202
#define IDD_VIRTUAL_SERVER_GROUP_NAME   203
#define IDD_VIRTUAL_SERVER_ACCESS_INFO  204
#define IDD_VIRTUAL_SERVER_ADVANCED     205
#define IDD_APP_RESOURCE_CREATE         206
#define IDD_APP_RESOURCE_TYPE           207
#define IDD_APP_RESOURCE_NAME_DESC      208
#define IDD_COMPLETION                  210
#define IDD_ENTER_SUBNET_MASK           250
#define IDD_MODIFY_PREFERRED_OWNERS     251
#define IDD_MODIFY_POSSIBLE_OWNERS      252
#define IDD_MODIFY_DEPENDENCIES         253
#define IDD_GRPADV_GENERAL              260
#define IDD_GRPADV_FAILOVER             261
#define IDD_GRPADV_FAILBACK             262
#define IDD_RES_GENERAL                 265
#define IDD_RES_DEPENDENCIES            266
#define IDD_RES_ADVANCED                267
#define IDD_RES_IP_PARAMS               270
#define IDD_RES_NETNAME_PARAMS          271
#define IDR_MANIFEST                    700
#define IDC_WIZARD_BACKGROUND           1000
#define IDC_WIZARD_TITLE                1001
#define IDC_WIZARD_SUBTITLE_1           1002
#define IDC_WIZARD_SUBTITLE_2           1003
#define IDC_WIZARD_HORIZ_LINE           1004
#define IDC_WIZARD_PAGE_DESCRIPTION     1005
#define IDC_WIZARD_CLICK_NEXT           1006
#define IDC_WIZARD_LISTBOX              1010
#define IDC_VSC_CREATE_NEW              1020
#define IDC_VSC_USE_EXISTING            1021
#define IDC_VSC_VIRTUAL_SERVERS_LABEL   1022
#define IDC_VSC_VIRTUAL_SERVERS         1023
#define IDC_VSG_CREATE_NEW              1030
#define IDC_VSG_USE_EXISTING            1031
#define IDC_VSG_GROUPS_LABEL            1032
#define IDC_VSG_GROUPS                  1033
#define IDC_VSGN_GROUP_NAME_TITLE       1040
#define IDC_VSGN_GROUP_NAME_LABEL       1041
#define IDC_VSGN_GROUP_NAME             1042
#define IDC_VSGN_GROUP_DESC_TITLE       1043
#define IDC_VSGN_GROUP_DESC_LABEL       1044
#define IDC_VSGN_GROUP_DESC             1045
#define IDC_VSAI_NETWORK_NAME_LABEL     1050
#define IDC_VSAI_NETWORK_NAME           1051
#define IDC_VSAI_IP_ADDRESS_LABEL       1052
#define IDC_VSAI_IP_ADDRESS             1053
#define IDC_VSA_CATEGORIES_LABEL        1060
#define IDC_VSA_CATEGORIES              1061
#define IDC_VSA_ADVANCED_PROPS          1062
#define IDC_ARC_CREATE_RES              1070
#define IDC_ARC_DONT_CREATE_RES         1071
#define IDC_ART_RESTYPES_LABEL          1080
#define IDC_ART_RESTYPES                1081
#define IDC_ARND_RES_NAME_TITLE         1090
#define IDC_ARND_RES_NAME_LABEL         1091
#define IDC_ARND_RES_NAME               1092
#define IDC_ARND_RES_DESC_TITLE         1093
#define IDC_ARND_RES_DESC_LABEL         1094
#define IDC_ARND_RES_DESC               1095
#define IDC_ARND_ADVANCED_PROPS_LABEL   1096
#define IDC_ARND_ADVANCED_PROPS         1097
#define IDC_ESM_DESCRIPTION             1501
#define IDC_ESM_IP_ADDRESS_LABEL        1502
#define IDC_ESM_IP_ADDRESS              1503
#define IDC_ESM_SUBNET_MASK_LABEL       1504
#define IDC_ESM_SUBNET_MASK             1505
#define IDC_ESM_NETWORKS_LABEL          1506
#define IDC_ESM_NETWORKS                1507
#define IDC_GAG_NAME_LABEL              1510
#define IDC_GAG_NAME                    1511
#define IDC_GAG_DESC_LABEL              1512
#define IDC_GAG_DESC                    1513
#define IDC_GAG_PREF_OWNERS_LABEL       1514
#define IDC_GAG_PREF_OWNERS             1515
#define IDC_GAG_PREF_OWNERS_MODIFY      1516
#define IDC_GAFO_FAILOVER_DESCRIPTION   1520
#define IDC_GAFO_FAILOVER_THRESH_LABEL  1521
#define IDC_GAFO_FAILOVER_THRESH        1522
#define IDC_GAFO_FAILOVER_THRESH_SPIN   1523
#define IDC_GAFO_FAILOVER_PERIOD_LABEL  1524
#define IDC_GAFO_FAILOVER_PERIOD        1525
#define IDC_GAFO_FAILOVER_PERIOD_SPIN   1526
#define IDC_GAFO_FAILOVER_PERIOD_LABEL2 1527
#define IDC_GAFB_FAILBACK_DESCRIPTION   1530
#define IDC_GAFB_PREVENT_FAILBACK       1531
#define IDC_GAFB_ALLOW_FAILBACK_GROUP   1532
#define IDC_GAFB_ALLOW_FAILBACK         1533
#define IDC_GAFB_PREFERRED_OWNERS_DESCRIPTION 1534
#define IDC_GAFB_PREF_OWNERS_LABEL      1535
#define IDC_GAFB_PREF_OWNERS            1536
#define IDC_GAFB_PREF_OWNERS_MODIFY     1537
#define IDC_GAFB_FAILBACK_WHEN_DESCRIPTION 1538
#define IDC_GAFB_FAILBACK_IMMED         1539
#define IDC_GAFB_FAILBACK_WINDOW        1540
#define IDC_GAFB_FBWIN_START            1541
#define IDC_GAFB_FBWIN_START_SPIN       1542
#define IDC_GAFB_FB_WINDOW_LABEL1       1543
#define IDC_GAFB_FBWIN_END              1544
#define IDC_GAFB_FBWIN_END_SPIN         1545
#define IDC_GAFB_FB_WINDOW_LABEL2       1546
#define IDC_RES_NAME_LABEL              1550
#define IDC_RES_NAME                    1551
#define IDC_RES_DESC_LABEL              1552
#define IDC_RES_DESC                    1553
#define IDC_RES_POSSIBLE_OWNERS_LABEL   1554
#define IDC_RES_POSSIBLE_OWNERS         1555
#define IDC_RES_POSSIBLE_OWNERS_MODIFY  1556
#define IDC_RES_SEPARATE_MONITOR        1557
#define IDC_RES_NOTE                    1560
#define IDC_RES_DEPENDS_LIST_LABEL      1561
#define IDC_RES_DEPENDS_LIST            1562
#define IDC_RES_DEPENDS_MODIFY          1563
#define IDC_RES_PROPERTIES              1564
#define IDC_RES_DONT_RESTART            1570
#define IDC_RES_RESTART_GROUP           1571
#define IDC_RES_RESTART                 1572
#define IDC_RES_AFFECT_THE_GROUP        1573
#define IDC_RES_RESTART_THRESH_LABEL    1574
#define IDC_RES_RESTART_THRESHOLD       1575
#define IDC_RES_RESTART_PERIOD_LABEL    1576
#define IDC_RES_RESTART_PERIOD          1577
#define IDC_RES_RESTART_PERIOD_LABEL2   1578
#define IDC_RES_LOOKS_ALIVE_GROUP       1579
#define IDC_RES_DEFAULT_LOOKS_ALIVE     1580
#define IDC_RES_SPECIFY_LOOKS_ALIVE     1581
#define IDC_RES_LOOKS_ALIVE             1582
#define IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL 1583
#define IDC_RES_IS_ALIVE_GROUP          1584
#define IDC_RES_DEFAULT_IS_ALIVE        1585
#define IDC_RES_SPECIFY_IS_ALIVE        1586
#define IDC_RES_IS_ALIVE                1587
#define IDC_RES_IS_ALIVE_LABEL          1588
#define IDC_RES_PENDING_TIMEOUT_LABEL   1589
#define IDC_RES_PENDING_TIMEOUT         1590
#define IDC_RES_PENDING_TIMEOUT_LABEL2  1591
#define IDC_IPADDR_PARAMS_ADDRESS_LABEL 1600
#define IDC_IPADDR_PARAMS_ADDRESS       1601
#define IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL 1602
#define IDC_IPADDR_PARAMS_SUBNET_MASK   1603
#define IDC_IPADDR_PARAMS_NETWORK_LABEL 1604
#define IDC_IPADDR_PARAMS_NETWORK       1605
#define IDC_IPADDR_PARAMS_ENABLE_NETBIOS 1606
#define IDC_NETNAME_PARAMS_NAME_LABEL   1610
#define IDC_NETNAME_PARAMS_NAME         1611
#define IDS_EXTERIOR_TITLE_FONT_SIZE    20000
#define IDS_EXTERIOR_TITLE_FONT_NAME    20001
#define IDS_HDR_TITLE_VSD               20010
#define IDS_HDR_SUBTITLE_VSD            20011
#define IDS_HDR_TITLE_VSC               20012
#define IDS_HDR_SUBTITLE_VSC            20013
#define IDS_HDR_TITLE_VSG               20014
#define IDS_HDR_SUBTITLE_VSG            20015
#define IDS_HDR_TITLE_VSGN              20016
#define IDS_HDR_SUBTITLE_VSGN           20017
#define IDS_HDR_TITLE_VSAI              20018
#define IDS_HDR_SUBTITLE_VSAI           20019
#define IDS_HDR_TITLE_VSA               20020
#define IDS_HDR_SUBTITLE_VSA            20021
#define IDS_HDR_TITLE_VSCD              20022
#define IDS_HDR_SUBTITLE_VSCD           20023
#define IDS_HDR_TITLE_IRT               20024
#define IDS_HDR_SUBTITLE_IRT            20025
#define IDS_HDR_TITLE_ARC               20026
#define IDS_HDR_SUBTITLE_ARC            20027
#define IDS_HDR_TITLE_ART               20028
#define IDS_HDR_SUBTITLE_ART            20029
#define IDS_HDR_TITLE_ARND              20030
#define IDS_HDR_SUBTITLE_ARND           20031
#define IDS_HDR_TITLE_ARA               20032
#define IDS_HDR_SUBTITLE_ARA            20033
#define IDS_HDR_TITLE_ARCD              20034
#define IDS_HDR_SUBTITLE_ARCD           20035
#define IDS_RESTYPE_GENERIC_APPLICATION 20036
#define IDS_VSA_CAT_RES_GROUP_PROPS     20100
#define IDS_VSA_CAT_IP_ADDRESS_PROPS    20101
#define IDS_VSA_CAT_NET_NAME_PROPS      20102
#define IDS_IP_ADDRESS_SUFFIX           20110
#define IDS_NETWORK_NAME_SUFFIX         20111
#define IDS_ADV_GRP_PROP_TITLE          20200
#define IDS_ADV_IPADDR_PROP_TITLE       20201
#define IDS_ADV_NETNAME_PROP_TITLE      20202
#define IDS_ADV_RESOURCE_PROP_TITLE     20203
#define IDS_COLTEXT_RESOURCE_NAME       21000
#define IDS_COLTEXT_RESOURCE_TYPE       21001
#define IDS_COLTEXT_NODE_NAME           21002
#define IDS_COMPLETED_VIRTUAL_SERVER    21010
#define IDS_COMPLETED_NETWORK_NAME      21011
#define IDS_COMPLETED_IP_ADDRESS        21012
#define IDS_COMPLETED_NETWORK           21013
#define IDS_COMPLETED_APP_RESOURCE      21015
#define IDS_COMPLETED_APP_RESOURCE_TYPE 21016
#define IDS_COMPLETED_PROP_NAME_WIDTH   21020
#define IDS_COMPLETED_PROP_VALUE_WIDTH  21021
#define IDS_ERROR_MSG_ID                40600
#define IDS_REQUIRED_FIELD_EMPTY        40601
#define IDS_ERROR_OPEN_CLUSTER_ENUM     41000
#define IDS_ERROR_ENUM_CLUSTER          41001
#define IDS_ERROR_OPEN_GROUP            41002
#define IDS_ERROR_OPEN_GROUP_ENUM       41003
#define IDS_ERROR_ENUM_GROUP            41004
#define IDS_ERROR_CREATE_GROUP          41005
#define IDS_ERROR_RENAME_GROUP          41006
#define IDS_ERROR_DELETE_GROUP          41007
#define IDS_ERROR_GET_GROUP_PROPERTIES  41008
#define IDS_ERROR_SET_COMMON_GROUP_PROPS 41009
#define IDS_ERROR_GROUP_NAME_IN_USE     41010
#define IDS_ERROR_SET_PREFERRED_OWNERS  41011
#define IDS_ERROR_OPEN_NETWORK          41012
#define IDS_ERROR_GET_NETWORK_PROPERTIES 41013
#define IDS_ERROR_OPEN_RESOURCE         41014
#define IDS_ERROR_CREATE_RESOURCE       41015
#define IDS_ERROR_DELETE_RESOURCE       41016
#define IDS_ERROR_OPEN_RESOURCE_ENUM    41017
#define IDS_ERROR_ENUM_RESOURCE         41018
#define IDS_ERROR_ADD_DEPENDENCY        41019
#define IDS_ERROR_REMOVE_RESOURCE_OWNER 41020
#define IDS_ERROR_GET_RESOURCE_TYPE     41021
#define IDS_ERROR_GET_RESOURCE_PROPERTIES 41022
#define IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES 41023
#define IDS_ERROR_RESOURCE_NAME_IN_USE  41024
#define IDS_ERROR_SET_COMMON_RES_PROPS  41025
#define IDS_ERROR_SET_PRIVATE_RES_PROPS 41026
#define IDS_ERROR_OPEN_NODE             41027
#define IDS_ERROR_GET_NODE_PROPERTIES   41028
#define IDS_ERROR_CREATE_WIZ_PROPERTY_PAGE 41029
#define IDS_ERROR_REMOVE_DEPENDENCY     41030
#define IDS_ERROR_ADD_RESOURCE_OWNER    41031
#define IDS_ERROR_INVALID_IP_ADDRESS    41100
#define IDS_ERROR_INVALID_SUBNET_MASK   41101
#define IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK 41102
#define IDS_ERROR_SAME_START_AND_END    41103
#define IDS_ERROR_GET_CLUSTER_INFO      41104
#define IDS_ERROR_GET_CLUSTER_KEY       41105
#define IDS_ERROR_OPEN_CLUSTER_KEY      41106
#define IDS_ERROR_QUERY_VALUE           41107
#define IDS_ERROR_INVALID_NETWORK_NAME  41108
#define IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG 41109
#define IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS 41110
#define IDS_ERROR_INVALID_NETWORK_NAME_IN_USE 41111
#define IDS_ERROR_GET_RESTYPE_REQUIRED_DEPENDENCIES 41112
#define IDS_ERROR_REQUIRED_DEPENDENCY_NOT_FOUND 41113
#define IDS_ERROR_VALIDATING_NETWORK_NAME 41114
#define IDS_ERROR_CREATING_THREAD       41115
#define IDS_RESOURCE_TYPE_NOT_FOUND     41116
#define IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS 41117
#define IDP_NO_ERROR_AVAILABLE          61472
#define IDP_PARSE_INT_RANGE             61714
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        251
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1515
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin21.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\resadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ResAdv.cpp
//
//  Abstract:
//      Implementation of the advanced resource property sheet classes.
//
//  Author:
//      David Potter (davidp)   March 6, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResAdv.h"
#include "AdmNetUtils.h"    // for BIsValidxxx network functions
#include "AtlUtil.h"        // for DDX/DDV routines
#include "LCPair.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CGeneralResourceAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CGeneralResourceAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGeneralResourceAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CGeneralResourceAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CIPAddrAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            || ! BAddPage( new CIPAddrParametersPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CIPAddrAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CNetNameAdvancedSheet
/////////////////////////////////////////////////////////////////////////////

DEFINE_CLASS_NAME( CNetNameAdvancedSheet )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameAdvancedSheet::BAddAllPages
//
//  Routine Description:
//      Add all pages to the page array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Pages added successfully.
//      FALSE   Error adding pages.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameAdvancedSheet::BAddAllPages( void )
{
    BOOL bSuccess = FALSE;

    // Loop to avoid goto's.
    do
    {
        //
        // Add static pages.
        //
        if (   ! BAddPage( new CGeneralResourceGeneralPage )
            || ! BAddPage( new CGeneralResourceDependenciesPage )
            || ! BAddPage( new CGeneralResourceAdvancedPage )
            || ! BAddPage( new CNetNameParametersPage )
            )
        {
            break;
        } // if:  error adding a page

        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CNetNameAdvancedSheet::BAddAllPages()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lbPossibleOwners,          IDC_RES_POSSIBLE_OWNERS );
    AttachControl( m_pbModifyPossibleOwners,    IDC_RES_POSSIBLE_OWNERS_MODIFY );

    //
    // Get data from the sheet.
    //
    m_strName = Pri()->RstrName();
    m_strDesc = Pri()->RstrDescription();
    m_bSeparateMonitor = Pri()->BSeparateMonitor();

    //
    // Copy the possible owners list.
    //
    m_lpniPossibleOwners = *Pri()->PlpniPossibleOwners();

    //
    // Fill the possible owners list.
    //
    FillPossibleOwnersList();

    return TRUE;

} //*** CResourceGeneralPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetText( m_hWnd, IDC_RES_NAME, m_strName );
        DDX_GetText( m_hWnd, IDC_RES_DESC, m_strDesc );
        DDX_GetCheck( m_hWnd, IDC_RES_SEPARATE_MONITOR, m_bSeparateMonitor );
        if ( ! DDV_RequiredText(
                    m_hWnd,
                    IDC_RES_NAME,
                    IDC_RES_NAME_LABEL,
                    m_strName
                    ) )
        {
            return FALSE;
        } // if:  error getting number
    } // if: saving data from the page
    else
    {
        DDX_SetText( m_hWnd, IDC_RES_NAME, m_strName );
        DDX_SetText( m_hWnd, IDC_RES_DESC, m_strDesc );
        DDX_SetCheck( m_hWnd, IDC_RES_SEPARATE_MONITOR, m_bSeparateMonitor );
    } // else:  setting data to the page

    return bSuccess;

} //*** CResourceGeneralPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceGeneralPage< T, TSht >::BApplyChanges( void )
{
    if (   BSaveName()
        || BSaveDescription()
        || BSaveSeparateMonitor()
        || BSavePossibleOwners() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CResourceGeneralPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::OnModify
//
//  Routine Description:
//      Handler for BN_CLICKED on the MODIFY push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
LRESULT CResourceGeneralPage< T, TSht >::OnModify(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    CModifyPossibleOwners dlg( Pwiz(), Pri(), &m_lpniPossibleOwners, Pwiz()->PlpniNodes() );

    INT_PTR id = dlg.DoModal( m_hWnd );
    if ( id == IDOK )
    {
        SetModified();
        m_bPossibleOwnersChanged = TRUE;
        FillPossibleOwnersList();
    } // if:  user accepted changes

    return 0;

} //*** CResourceGeneralPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceGeneralPage::FillPossibleOwnersList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
void CResourceGeneralPage< T, TSht >::FillPossibleOwnersList( void )
{
    CWaitCursor wc;

    //
    // Make sure nodes have been collected.
    //
    if ( ! Pwiz()->BCollectNodes() )
    {
        return;
    } // if:  error collecting nodes

    //
    // Remove all items to begin with.
    //
    m_lbPossibleOwners.ResetContent();

    //
    // Add each possible owner to the list.
    //
    CClusNodePtrList::iterator itnode;
    for ( itnode = m_lpniPossibleOwners.begin()
        ; itnode != m_lpniPossibleOwners.end()
        ; itnode++ )
    {
        //
        // Add the string to the list box.
        //
        m_lbPossibleOwners.AddString( (*itnode)->RstrName() );
    } // for:  each entry in the list

} //*** CResourceGeneralPage::FillPossibleOwnersList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceGeneralPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS_MODIFY )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SEPARATE_MONITOR )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceGeneralPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceGeneralPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DESC )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_POSSIBLE_OWNERS_MODIFY )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SEPARATE_MONITOR )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceDependenciesPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lvcDependencies, IDC_RES_DEPENDS_LIST );

    //
    // Copy the dependencies list.
    //
    m_lpriDependencies = *Pri()->PlpriDependencies();

    //
    // Copy the list of resources in the group and remove our entry.
    //
    {
        m_lpriResourcesInGroup = *Pri()->Pgi()->PlpriResources();
        CClusResPtrList::iterator itCurrent = m_lpriResourcesInGroup.begin();
        CClusResPtrList::iterator itLast = m_lpriResourcesInGroup.end();
        for ( ; itCurrent != itLast ; itCurrent++ )
        {
            CClusResInfo * pri = *itCurrent;
            if ( pri->RstrName().CompareNoCase( Pri()->RstrName() ) == 0 )
            {
                m_lpriResourcesInGroup.erase( itCurrent );
                break;
            } // if:  found this resource in the list
        } // for:  each entry in the list
    } // Copy the list of resources in the group and remove our entry

    //
    // Initialize and add columns to the dependencies list view control.
    //
    {
        DWORD       dwExtendedStyle;
        CString     strColText;

        //
        // Change list view control extended styles.
        //
        dwExtendedStyle = m_lvcDependencies.GetExtendedListViewStyle();
        m_lvcDependencies.SetExtendedListViewStyle(
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP,
            LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP
            );

        //
        // Insert the Resource Name column.
        //
        strColText.LoadString( IDS_COLTEXT_RESOURCE_NAME );
        m_lvcDependencies.InsertColumn( 0, strColText, LVCFMT_LEFT, 125 * 3 / 2, -1 );

        //
        // Insert the Resource Type column.
        //
        strColText.LoadString( IDS_COLTEXT_RESOURCE_TYPE );
        m_lvcDependencies.InsertColumn( 1, strColText, LVCFMT_LEFT, 100 * 3 / 2, -1 );

    } // Add columns

    //
    // Fill the dependencies list.
    //
    FillDependenciesList();

    return TRUE;

} //*** CResourceDependenciesPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceDependenciesPage< T, TSht >::BApplyChanges( void )
{
    if ( BSaveDependencies() )
    {
        SetResInfoChanged();
    } // if:  dependencies changed

    return TRUE;

} //*** CResourceDependenciesPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::OnModify
//
//  Routine Description:
//      Handler for BN_CLICKED on the MODIFY push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
LRESULT CResourceDependenciesPage< T, TSht >::OnModify(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    CModifyDependencies dlg( Pwiz(), Pri(), &m_lpriDependencies, &m_lpriResourcesInGroup );

    INT_PTR id = dlg.DoModal( m_hWnd );
    if ( id == IDOK )
    {
        SetModified();
        m_bDependenciesChanged = TRUE;
        FillDependenciesList();
    } // if:  user accepted changes

    return 0;

} //*** CResourceDependenciesPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceDependenciesPage::FillDependenciesList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
void CResourceDependenciesPage< T, TSht >::FillDependenciesList( void )
{
    CWaitCursor wc;
    int         idx;

    //
    // Remove all items to begin with.
    //
    m_lvcDependencies.DeleteAllItems();

    //
    // Add each dependency to the list.
    //
    CClusResPtrList::iterator itCurrent = m_lpriDependencies.begin();
    CClusResPtrList::iterator itLast = m_lpriDependencies.end();
    for ( ; itCurrent  != itLast ; itCurrent++ )
    {
        //
        // Add the string to the list control.
        //
        CClusResInfo * pri = *itCurrent;
        ASSERT( pri->Prti() != NULL );
        idx = m_lvcDependencies.InsertItem( 0, pri->RstrName() );
        m_lvcDependencies.SetItemText( idx, 1, pri->Prti()->RstrName() );

        m_lvcDependencies.SetItemData( idx, (DWORD_PTR)pri );

    } // for:  each entry in the list

} //*** CResourceDependenciesPage::FillDependenciesList()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceDependenciesPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NOTE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_MODIFY )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceDependenciesPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceDependenciesPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_NOTE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_LIST )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEPENDS_MODIFY )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_rbDontRestart,         IDC_RES_DONT_RESTART );
    AttachControl( m_rbRestart,             IDC_RES_RESTART );
    AttachControl( m_editThreshold,         IDC_RES_RESTART_THRESHOLD );
    AttachControl( m_editPeriod,            IDC_RES_RESTART_PERIOD );
    AttachControl( m_ckbAffectTheGroup,     IDC_RES_AFFECT_THE_GROUP );
    AttachControl( m_rbDefaultLooksAlive,   IDC_RES_DEFAULT_LOOKS_ALIVE );
    AttachControl( m_rbSpecifyLooksAlive,   IDC_RES_SPECIFY_LOOKS_ALIVE );
    AttachControl( m_editLooksAlive,        IDC_RES_LOOKS_ALIVE );
    AttachControl( m_rbDefaultIsAlive,      IDC_RES_DEFAULT_IS_ALIVE );
    AttachControl( m_rbSpecifyIsAlive,      IDC_RES_SPECIFY_IS_ALIVE );
    AttachControl( m_editIsAlive,           IDC_RES_IS_ALIVE );
    AttachControl( m_editPendingTimeout,    IDC_RES_PENDING_TIMEOUT );

    //
    // Get data from the sheet.
    //
    m_crraRestartAction = Pri()->CrraRestartAction();
    m_nThreshold = Pri()->NRestartThreshold();
    m_nPeriod = Pri()->NRestartPeriod() / 1000; // display units are seconds, stored units are milliseconds
    m_nLooksAlive = Pri()->NLooksAlive();
    m_nIsAlive = Pri()->NIsAlive();
    m_nPendingTimeout = Pri()->NPendingTimeout() / 1000; // display units are seconds, stored units are milliseconds

    switch ( m_crraRestartAction )
    {
        case ClusterResourceDontRestart:
            m_nRestart = 0;
            break;
        case ClusterResourceRestartNoNotify:
            m_nRestart = 1;
            break;
        case ClusterResourceRestartNotify:
            m_nRestart = 1;
            m_bAffectTheGroup = TRUE;
            break;
    } // switch:  restart action

    return TRUE;

} //*** CResourceAdvancedPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        DDX_GetRadio( m_hWnd, IDC_RES_DONT_RESTART, m_nRestart );
        DDX_GetCheck( m_hWnd, IDC_RES_AFFECT_THE_GROUP, m_bAffectTheGroup );

        //if (!BReadOnly())
        //{
            if ( m_nRestart == 1 )
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_RESTART_THRESHOLD,
                    m_nThreshold,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD,
                    FALSE /*bSigned*/
                    );
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_RESTART_PERIOD,
                    m_nPeriod,
                    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
                    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000, // display units are seconds, stored units are milliseconds
                    FALSE /*bSigned*/
                    );
            }  // if:  restart is enabled

            if ( m_rbDefaultLooksAlive.GetCheck() == BST_CHECKED )
            {
                m_nLooksAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            } // if:  Default Looks Alive checkbox checked
            else
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_LOOKS_ALIVE,
                    m_nLooksAlive,
                    CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI,
                    FALSE /*bSigned*/
                    );
            } // else:  Specify Looks Alive checkbox checked

            if ( m_rbDefaultIsAlive.GetCheck() == BST_CHECKED )
            {
                m_nIsAlive = CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL;
            } // if:  Default Is Alive checkbox checked
            else
            {
                DDX_GetNumber(
                    m_hWnd,
                    IDC_RES_IS_ALIVE,
                    m_nIsAlive,
                    CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
                    CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI,
                    FALSE /*bSigned*/
                    );
            } // else:  Specify Is Alive checkbox checked

            DDX_GetNumber(
                m_hWnd,
                IDC_RES_PENDING_TIMEOUT,
                m_nPendingTimeout,
                CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
                CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000, // display units are seconds, stored units are milliseconds
                FALSE /*bSigned*/
                );
        //}  // if:  not read only
    } // if: saving data from the page
    else
    {
        int     nDefault;
        int     nSpecify;
        BOOL    bReadOnly;

        DDX_SetNumber(
            m_hWnd,
            IDC_RES_RESTART_THRESHOLD,
            m_nThreshold,
            CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD,
            FALSE /*bSigned*/
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_RESTART_PERIOD,
            m_nPeriod,
            CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,
            CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD / 1000, // display units are seconds, stored units are milliseconds
            FALSE /*bSigned*/
            );
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_PENDING_TIMEOUT,
            m_nPendingTimeout,
            CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,
            CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT / 1000, // display units are seconds, stored units are milliseconds
            FALSE /*bSigned*/
            );

        if ( m_nRestart == 0 )
        {
            m_rbDontRestart.SetCheck( BST_CHECKED );
            m_rbRestart.SetCheck( BST_UNCHECKED );
            OnClickedDontRestart();
        }  // if:  Don't Restart selected
        else
        {
            m_rbDontRestart.SetCheck( BST_UNCHECKED );
            m_rbRestart.SetCheck( BST_CHECKED );
            OnClickedRestart();
            if ( m_bAffectTheGroup )
            {
                m_ckbAffectTheGroup.SetCheck( BST_CHECKED );
            } // if: restart and notify
            else
            {
                m_ckbAffectTheGroup.SetCheck( BST_UNCHECKED );
            } // else: restart and don't notify
        }  // else:  Restart selected

        DWORD nLooksAlive = m_nLooksAlive;
        if ( m_nLooksAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            nLooksAlive = Prti()->NLooksAlive();
            nDefault = BST_CHECKED;
            nSpecify = BST_UNCHECKED;
            bReadOnly = TRUE;
        }  // if:  using default
        else
        {
            nDefault = BST_UNCHECKED;
            nSpecify = BST_CHECKED;
            bReadOnly = FALSE;
        }  // if:  not using default
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_LOOKS_ALIVE,
            nLooksAlive,
            CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,
            CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE_UI,
            FALSE /*bSigned*/
            );
        m_editLooksAlive.SetReadOnly( bReadOnly );
        m_rbDefaultLooksAlive.SetCheck( nDefault );
        m_rbSpecifyLooksAlive.SetCheck( nSpecify );

        DWORD nIsAlive = m_nIsAlive;
        if ( m_nIsAlive == (DWORD) CLUSTER_RESOURCE_USE_DEFAULT_POLL_INTERVAL )
        {
            nIsAlive = Prti()->NIsAlive();
            nDefault = BST_CHECKED;
            nSpecify = BST_UNCHECKED;
            bReadOnly = TRUE;
        }  // if:  using default
        else
        {
            nDefault = BST_UNCHECKED;
            nSpecify = BST_CHECKED;
            bReadOnly = TRUE;
        }  // if:  not using default
        DDX_SetNumber(
            m_hWnd,
            IDC_RES_IS_ALIVE,
            nIsAlive,
            CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,
            CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE_UI,
            FALSE /*bSigned*/
            );
        m_editIsAlive.SetReadOnly( bReadOnly );
        m_rbDefaultIsAlive.SetCheck( nDefault );
        m_rbSpecifyIsAlive.SetCheck( nSpecify );
    } // else:  setting data to the page

    return bSuccess;

} //*** CResourceAdvancedPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResourceAdvancedPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
template < class T, class TSht >
BOOL CResourceAdvancedPage< T, TSht >::BApplyChanges( void )
{
    //
    // Calculate the restart action value.
    //
    if ( m_nRestart == 0 )
    {
        m_crraRestartAction = ClusterResourceDontRestart;
    } // if:  Don't Restart selected
    else if ( m_bAffectTheGroup )
    {
        m_crraRestartAction = ClusterResourceRestartNotify;
    } // else if:  Restart and Affects Group selected
    else
    {
        m_crraRestartAction = ClusterResourceRestartNoNotify;
    } // else:  Restart but not Affects Group selected

    //
    // Save all changed data.
    //
    if ( Pri()->BSetAdvancedProperties(
                m_crraRestartAction,
                m_nThreshold,
                m_nPeriod * 1000, // display units are seconds, stored units are milliseconds
                m_nLooksAlive,
                m_nIsAlive,
                m_nPendingTimeout * 1000 // display units are seconds, stored units are milliseconds
                ) )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CResourceAdvancedPage::BApplyChanges()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CGeneralResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CGeneralResourceAdvancedPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DONT_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_AFFECT_THE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESH_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESHOLD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL2 )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrResourceAdvancedPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrResourceAdvancedPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DONT_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_AFFECT_THE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESH_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_THRESHOLD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_RESTART_PERIOD_LABEL2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_LOOKS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_LOOKS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_GROUP )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_DEFAULT_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_SPECIFY_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_IS_ALIVE_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_RES_PENDING_TIMEOUT_LABEL2 )
END_CTRL_NAME_MAP()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CIPAddrParametersPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CIPAddrParametersPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ADDRESS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ADDRESS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_SUBNET_MASK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_NETWORK_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_NETWORK )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_IPADDR_PARAMS_ENABLE_NETBIOS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_ipaIPAddress,  IDC_IPADDR_PARAMS_ADDRESS );
    AttachControl( m_ipaSubnetMask, IDC_IPADDR_PARAMS_SUBNET_MASK );
    AttachControl( m_cboxNetworks,  IDC_IPADDR_PARAMS_NETWORK );
    AttachControl( m_chkEnableNetBIOS, IDC_IPADDR_PARAMS_ENABLE_NETBIOS );

    //
    // Get data from the sheet.
    //
    m_strIPAddress = PshtThis()->m_strIPAddress;
    m_strSubnetMask = PshtThis()->m_strSubnetMask;
    m_strNetwork = PshtThis()->m_strNetwork;
    m_bEnableNetBIOS = PshtThis()->m_bEnableNetBIOS;

    //
    // Fill the networks combobox.
    //
    FillNetworksList();

    //
    // Default the subnet mask if not set.
    //

    return TRUE;

} //*** CIPAddrParametersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_ADDRESS, m_strIPAddress );
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask );
            DDX_GetText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, m_strNetwork );
            DDX_GetCheck( m_hWnd, IDC_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS );

            if (   ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_ADDRESS, IDC_IPADDR_PARAMS_ADDRESS_LABEL, m_strIPAddress )
                || ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_SUBNET_MASK, IDC_IPADDR_PARAMS_SUBNET_MASK_LABEL, m_strSubnetMask )
                || ! DDV_RequiredText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, IDC_IPADDR_PARAMS_NETWORK_LABEL, m_strNetwork )
                )
            {
                bSuccess = FALSE;
                break;
            } // if:  required text not specified

            //
            // Validate the IP address.
            //
            if ( ! BIsValidIpAddress( m_strIPAddress ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_IP_ADDRESS, m_strIPAddress );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaIPAddress.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid IP address

            //
            // Make sure we process the IP address.
            // If we don't call it here, and the user pressed a tab button
            // while sitting in the IP address field, the EN_KILLFOCUS
            // message won't get processed until after this method returns.
            //
            if (   (m_strSubnetMask.GetLength() == 0)
                || (m_ipaSubnetMask.IsBlank()) )
            {
                BOOL bHandled = TRUE;
                OnKillFocusIPAddr( EN_KILLFOCUS, IDC_IPADDR_PARAMS_ADDRESS, m_ipaIPAddress.m_hWnd, bHandled );
            } // if:  subnet mask not specified

            //
            // Validate the subnet mask.
            //
            if ( ! BIsValidSubnetMask( m_strSubnetMask ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_SUBNET_MASK, m_strSubnetMask );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaSubnetMask.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid subnet mask

            //
            // Validate the IP address and the subnet mask together.
            //
            if ( ! BIsValidIpAddressAndSubnetMask( m_strIPAddress, m_strSubnetMask ) )
            {
                CString strMsg;
                strMsg.FormatMessage( IDS_ERROR_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask );
                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                m_ipaIPAddress.SetFocus( 0 /*nField*/ );
                bSuccess = FALSE;
                break;
            }  // if:  invalid IP address with subnet mask
        } // if: saving data from the page
        else
        {
            m_ipaIPAddress.SetWindowText( m_strIPAddress );
            m_ipaSubnetMask.SetWindowText( m_strSubnetMask );
            DDX_SetComboBoxText( m_hWnd, IDC_IPADDR_PARAMS_NETWORK, m_strNetwork );
            DDX_SetCheck( m_hWnd, IDC_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS );
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CIPAddrParametersPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIPAddrParametersPage::BApplyChanges( void )
{
    if (   BSaveIPAddress()
        || BSaveSubnetMask()
        || BSaveNetwork()
        || BSaveEnableNetBIOS() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CIPAddrParametersPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::OnKillFocusIPAddr
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on IDC_IPADDR_PARAMS_ADDRESS.
//
//  Arguments:
//      bHandled    [IN OUT] TRUE = we handled message (default).
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CIPAddrParametersPage::OnKillFocusIPAddr(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    CString             strAddress;
    CString             strMsg;
    CClusNetworkInfo *  pni;

    BSTR bstr = NULL;
    m_ipaIPAddress.GetWindowText( bstr );
    strAddress = bstr;
    SysFreeString( bstr );
    bstr = NULL;

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );

    if ( strAddress.GetLength() == 0 )
    {
        ((CEdit &)m_ipaIPAddress).SetSel( 0, 0, FALSE );
    } // if:  empty string
    else if ( !BIsValidIpAddress( strAddress ) )
    {
    } // else if:  invalid address
    else
    {
        pni = PniFromIpAddress( strAddress );
        if ( pni != NULL )
        {
            SelectNetwork( pni );
        } // if:  network found
        else
        {
            //m_strSubnetMask = _T("");
        } // else:  network not found
    } // else:  valid address

    bHandled = FALSE;
    return 0;

} //*** CIPAddrParametersPage::OnIPAddrChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::FillNetworksList
//
//  Routine Description:
//      Fill the list of possible owners.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIPAddrParametersPage::FillNetworksList( void )
{
    CWaitCursor wc;

    // Loop to avoid goto's.
    do
    {
        //
        // Add each network in the list to the combobox.
        //
        CClusNetworkPtrList::iterator itnet;
        int idx;
        for ( itnet = PshtThis()->PlpniNetworks()->begin()
            ; itnet != PshtThis()->PlpniNetworks()->end()
            ; itnet++ )
        {
            //
            // Add the network to the combobox.
            //
            CClusNetworkInfo * pni = *itnet;
            if ( pni->BIsClientNetwork() )
            {
                idx = m_cboxNetworks.AddString( pni->RstrName() );
                ASSERT( idx != CB_ERR );
                m_cboxNetworks.SetItemDataPtr( idx, (void *) pni );
            } // if:  client network
        } // for:  each entry in the list

        //
        // Select the currently saved entry, or the first one if none are
        // currently saved.
        //
        if ( m_strNetwork.GetLength() == 0 )
        {
            m_cboxNetworks.SetCurSel( 0 );
        } // if:  empty string
        else
        {
            idx = m_cboxNetworks.FindStringExact( -1, m_strNetwork );
            ASSERT( idx != CB_ERR );
            if ( idx != CB_ERR )
            {
                m_cboxNetworks.SetCurSel( idx );
            } // if:  saved selection found in the combobox
        } // else:  network saved
    } while ( 0 );

} //*** CIPAddrParametersPage::FillNetworksList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::PniFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pni             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkInfo * CIPAddrParametersPage::PniFromIpAddress( IN LPCWSTR pszAddress )
{
    DWORD               dwStatus;
    DWORD               nAddress;
    CClusNetworkInfo *  pni;

    //
    // Convert the address to a number.
    //
    dwStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return NULL;
    } // if:  error converting the address to a number

    //
    // Search the list for a matching address.
    //
    CClusNetworkPtrList::iterator itnet;
    for ( itnet = PshtThis()->PlpniNetworks()->begin()
        ; itnet != PshtThis()->PlpniNetworks()->end()
        ; itnet++ )
    {
        pni = *itnet;
        if ( ClRtlAreTcpipAddressesOnSameSubnet( nAddress, pni->NAddress(), pni->NAddressMask() ) )
        {
            return pni;
        } // if:  IP address is on this network
    }  // while:  more items in the list

    return NULL;

}  //*** CIPAddrParametersPage::PniFromIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIPAddrParametersPage::SelectNetwork
//
//  Routine Description:
//      Select the specified network in the network combobox, and set the
//      subnet mask.
//
//  Arguments:
//      pni         [IN OUT] Network info object for network to select.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIPAddrParametersPage::SelectNetwork( IN OUT CClusNetworkInfo * pni )
{
    ASSERT( pni != NULL );

    int     inet;
    CString strSubnetMask;
    BSTR    bstrSubnetMask = NULL;

    // Find the proper item in the checkbox.
    inet = m_cboxNetworks.FindStringExact( -1, pni->RstrName() );
    if ( inet != CB_ERR )
    {
        m_cboxNetworks.SetCurSel( inet );
        m_ipaSubnetMask.GetWindowText( bstrSubnetMask );
        strSubnetMask = bstrSubnetMask;
        SysFreeString( bstrSubnetMask );
        if ( strSubnetMask != pni->RstrAddressMask() )
            m_ipaSubnetMask.SetWindowText( pni->RstrAddressMask() );
        m_strNetwork = pni->RstrName();
        m_strSubnetMask = pni->RstrAddressMask();
    }  // if:  match found

}  //*** CIPAddrParametersPage::SelectNetwork()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// class CNetNameParametersPage
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CNetNameParametersPage )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_NETNAME_PARAMS_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_NETNAME_PARAMS_NAME )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_editNetName, IDC_NETNAME_PARAMS_NAME );

    //
    // Set limits on edit controls.
    //
    m_editNetName.SetLimitText( MAX_CLUSTERNAME_LENGTH );

    //
    // Get data from the sheet.
    //
    m_strNetName = PshtThis()->m_strNetName;

    return TRUE;

} //*** CIPAddrParametersPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            CString strNetName;

            DDX_GetText( m_hWnd, IDC_NETNAME_PARAMS_NAME, strNetName );

            if ( ! DDV_RequiredText( m_hWnd, IDC_NETNAME_PARAMS_NAME, IDC_NETNAME_PARAMS_NAME_LABEL, strNetName ) )
            {
                bSuccess = FALSE;
                break;
            } // if:  required text not specified

            //
            // Validate the network name if the data on the page is different
            //
            if ( m_strNetName != strNetName )
            {
                CLRTL_NAME_STATUS cnStatus;

                if ( ! ClRtlIsNetNameValid( strNetName, &cnStatus, FALSE /*CheckIfExists*/) )
                {
                    CString     strMsg;
                    UINT        idsError = IDS_ERROR_INVALID_NETWORK_NAME;

                    switch ( cnStatus )
                    {
                        case NetNameTooLong:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG;
                            break;
                        case NetNameInvalidChars:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS;
                            break;
                        case NetNameInUse:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME_IN_USE;
                            break;
                        case NetNameDNSNonRFCChars:
                            idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                            break;
                        case NetNameSystemError:
                        {
                            DWORD scError = GetLastError();
                            CNTException nte( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strNetName );
                            nte.ReportError();
                            break;
                        }
                        default:
                            idsError = IDS_ERROR_INVALID_NETWORK_NAME;
                            break;
                    }  // switch:  cnStatus

                    if ( cnStatus != NetNameSystemError )
                    {
                        strMsg.LoadString( idsError );

                        if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                        {
                            int id = AppMessageBox( m_hWnd, strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                            if ( id == IDNO )
                            {
                                bSuccess = FALSE;
                            }
                        }
                        else
                        {
                            AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                            bSuccess = FALSE;
                        }

                        if ( ! bSuccess )
                        {
                            break;
                        }
                    } // if:  popup not displayed yet
                }  // if:  invalid network name

                m_strNetName = strNetName;
            } // if: the network name has changed
        } // if: saving data from the page
        else
        {
            m_editNetName.SetWindowText( m_strNetName );
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CNetNameParametersPage::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetNameParametersPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetNameParametersPage::BApplyChanges( void )
{
    if ( BSaveNetName() )
    {
        SetResInfoChanged();
    } // if:  data changed

    return TRUE;

} //*** CNetNameParametersPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(__STDAFX_H_)
#define __STDAFX_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

//#define _DBG_MSG_NOTIFY
//#define _DBG_MSG_COMMAND

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define THIS_FILE __FILE__
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#define _CRTDBG_MAP_ALLOC
#endif // _DEBUG

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

// Disable some benign warnings.
#pragma warning(disable : 4100) // unreferenced formal parameter
#pragma warning(disable : 4505) // unreferenced local function has been removed
//#pragma warning(disable : 4245) // signed/unsigned mismatch

// Enable some warnings.
#pragma warning(error : 4706)  // assignment within conditional expression

//
// Enable cluster debug reporting
//
#if DBG
#define CLRTL_INCLUDE_DEBUG_REPORTING
#endif // DBG
#include "ClRtlDbg.h"
#if DBG
#define ASSERT( _expr ) _CLRTL_ASSERTE( _expr )
#else
#define ASSERT( _expr )
#endif
#define ATLASSERT( _expr ) ASSERT( _expr )

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
#include "App.h"
extern CApp _Module;
#include <atlcom.h>

// atlwin.h needs this for the definition of DragAcceptFiles
#include <shellapi.h>

// atlwin.h needs this for the definition of psh1
#ifndef _DLGSH_INCLUDED_
#include <dlgs.h>
#endif

#pragma warning( push )
#pragma warning( disable : 4189 ) // local variable is initialized but not referenced

#if (_ATL_VER < 0x0300)
#include <atlwin21.h>
#endif //(_ATL_VER < 0x0300)

#ifndef _ASSERTE
#define _ASSERTE _CLRTL_ASSERTE
#endif

#pragma warning( push )
#pragma warning( disable : 4267 ) // conversion from 'size_t' to 'int', pssible data loss
#include <atltmp.h>
#pragma warning( pop )

#include <atlctrls.h>
#include <atlgdi.h>
#include <atlapp.h>
#include <atldlgs.h>

#include <shfusion.h>

#include <clusapi.h>
#include "clusudef.h"
#include "clusrtl.h"

#if DBG
#include <crtdbg.h>
#endif // DBG

// Include parts of STL
#include <list>
#include <vector>
#include <algorithm>

typedef std::list< CString > cstringlist;

#include <StrSafe.h>

#include "WaitCrsr.h"
#include "ExcOper.h"
#include "AtlUtil.h"
#include "TraceTag.h"
#include "App.inl"
#include "AtlBaseApp.inl"
#include "AtlBaseWiz.h"
#include "ClAdmWiz.h"

//#ifndef ASSERT
//#define ASSERT _ASSERTE
//#endif

#ifndef MAX_DWORD
#define MAX_DWORD ((DWORD)-1)
#endif // MAX_DWORD

#ifdef _DEBUG
//void * __cdecl operator new(size_t nSize, LPCSTR lpszFileName, int nLine);
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#pragma warning( pop )

#endif // !defined(__STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Definition of the CTraceTag class.
//
//	Implementation File:
//		TraceTag.cpp
//
//	Author:
//		David Potter (davidp)	May 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __TRACETAG_H_
#define __TRACETAG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )
class CTraceTag;
#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define TRACE_TAG_REG_SECTION		TEXT("Debug")
#define TRACE_TAG_REG_SECTION_FMT	TRACE_TAG_REG_SECTION TEXT("\\%s")
#define TRACE_TAG_REG_FILE			TEXT("Trace File")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CTraceTag
//
//	Purpose:
//		Object containing a specific set of trace settings allowing trace
//		output to go to multiple outputs.
//
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )
class CTraceTag : public CString
{
	friend class CTraceDialog;
	friend void InitAllTraceTags( void );
	friend void CleanupAllTraceTags( void );

public:
	CTraceTag( IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL );
	~CTraceTag( void );

	enum TraceFlags
	{
		tfCom2		= 1,
		tfFile		= 2,
		tfDebug		= 4,
		tfBreak		= 8
	};

// Attributes
protected:
	UINT		m_uiFlags;
	UINT		m_uiFlagsDialog;
	UINT		m_uiFlagsDefault;
	UINT		m_uiFlagsDialogStart;	// of Selection...

	LPCTSTR		m_pszSubsystem;
	LPCTSTR		m_pszName;

	LPCTSTR		PszSubsystem( void )				{ return m_pszSubsystem; }
	LPCTSTR		PszName( void )						{ return m_pszName; }

	void		ConstructRegState( OUT CString & rstr );

	void		SetFlags( IN UINT tf, IN BOOL bEnable );
	void		SetFlagsDialog( IN UINT tf, IN BOOL bEnable );

	void		SetBCom2( IN BOOL bEnable )			{ SetFlags( tfCom2, bEnable ); }
	void		SetBCom2Dialog( IN BOOL bEnable )	{ SetFlagsDialog( tfCom2, bEnable ); }
	BOOL		BCom2Dialog( void ) const			{ return m_uiFlagsDialog & tfCom2 ? TRUE : FALSE; }

	void		SetBFile( IN BOOL bEnable )			{ SetFlags( tfFile, bEnable ); }
	void		SetBFileDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfFile, bEnable ); }
	BOOL		BFileDialog( void ) const			{ return m_uiFlagsDialog & tfFile ? TRUE : FALSE; }

	void		SetBDebug( IN BOOL bEnable )		{ SetFlags( tfDebug, bEnable ); }
	void		SetBDebugDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfDebug, bEnable ); }
	BOOL		BDebugDialog( void ) const			{ return m_uiFlagsDialog & tfDebug ? TRUE : FALSE; }

	void		SetBBreak( IN BOOL bEnable )		{ SetFlags( tfBreak, bEnable ); }
	void		SetBBreakDialog( IN BOOL bEnable )	{ SetFlagsDialog( tfBreak, bEnable ); }
	BOOL		BBreakDialog( void ) const			{ return m_uiFlagsDialog & tfBreak ? TRUE : FALSE; }

public:
	BOOL		BCom2( void ) const					{ return m_uiFlags & tfCom2 ? TRUE : FALSE; }
	BOOL		BFile( void ) const					{ return m_uiFlags & tfFile ? TRUE : FALSE; }
	BOOL		BDebug( void ) const				{ return m_uiFlags & tfDebug ? TRUE : FALSE; }
	BOOL		BBreak( void ) const				{ return m_uiFlags & tfBreak ? TRUE : FALSE; }
	BOOL		BAny( void ) const					{ return m_uiFlags != 0; }

// Operations
public:

// Implementation
public:
	void				TraceV( IN LPCTSTR pszFormat, va_list );

protected:
	void				Init( void );

	static LPCTSTR		s_pszCom2;
	static LPCTSTR		s_pszFile;
	static LPCTSTR		s_pszDebug;
	static LPCTSTR		s_pszBreak;

	static LPCTSTR		PszFile( void );

	static CTraceTag *	s_ptagFirst;
	static CTraceTag *	s_ptagLast;
	CTraceTag *			m_ptagNext;
//	static HANDLE			s_hfileCom2;

	static CRITICAL_SECTION	s_critsec;
	static BOOL				s_bCritSecValid;

	static BOOL				BCritSecValid( void ) { return s_bCritSecValid; }

};  //*** class CTraceTag

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

 extern		CTraceTag				g_tagAlways;
 extern		CTraceTag				g_tagError;
 void		Trace( IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ... );
 void		TraceError( IN OUT CException & rexcept );
 void		TraceError( IN LPCTSTR pszModule, IN SC sc );
 void		InitAllTraceTags( void );
 void		CleanupAllTraceTags( void );
 void		TraceMenu( IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix );

// extern		LPTSTR		g_pszTraceIniFile;
 extern		CString		g_strTraceFile;
 extern		BOOL		g_bBarfDebug;

#else // _DEBUG

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
 inline void TraceError( IN OUT CException & rexcept )		{ }
 inline void TraceError( IN LPCTSTR pszModule, IN SC sc )	{ }
 #define TraceMenu( _rtag, _pmenu, _pszPrefix )
 inline void InitAllTraceTags( void )						{ }
 inline void CleanupAllTraceTags( void )					{ }

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////

#endif // __TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsaccess.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSAccess.cpp
//
//  Abstract:
//      Implementation of the CWizPageVSAccessInfo class.
//
//  Author:
//      David Potter (davidp)   December 9, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSAccess.h"
#include "ClusAppWiz.h"
#include "AdmNetUtils.h"    // for BIsValidxxx network functions
#include "WizThread.h"      // for CWizardThread
#include "EnterSubnet.h"    // for CEnterSubnetMaskDlg

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAccessInfo
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSAccessInfo )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_NETWORK_NAME_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_NETWORK_NAME )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_IP_ADDRESS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSAI_IP_ADDRESS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::OnInitDialog(void)
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_editNetName, IDC_VSAI_NETWORK_NAME );
    AttachControl( m_ipaIPAddress, IDC_VSAI_IP_ADDRESS );

    //
    // Set limits on edit controls.
    //
    m_editNetName.SetLimitText( MAX_CLUSTERNAME_LENGTH );

    PwizThis()->BCollectNetworks( GetParent() );

    return TRUE;

} //*** CWizPageVSAccessInfo::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        if ( bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CString     strTempNetName;
                CString     strTempIPAddress;

                DDX_GetText( m_hWnd, IDC_VSAI_NETWORK_NAME, strTempNetName );
                DDX_GetText( m_hWnd, IDC_VSAI_IP_ADDRESS, strTempIPAddress );

                if (    ! DDV_RequiredText( m_hWnd, IDC_VSAI_NETWORK_NAME, IDC_VSAI_NETWORK_NAME_LABEL, strTempNetName )
                    ||  ! DDV_RequiredText( m_hWnd, IDC_VSAI_IP_ADDRESS, IDC_VSAI_IP_ADDRESS_LABEL, strTempIPAddress )
                    )
                {
                    bSuccess = FALSE;
                    break;
                } // if:  required text not specified

                //
                // If the IP address has changed, validate it.
                //
                if ( strTempIPAddress != PwizThis()->RstrIPAddress() )
                {
                    BOOL bHandled = TRUE;

                    if ( ! BIsValidIpAddress( strTempIPAddress ) )
                    {
                        CString strMsg;
                        strMsg.FormatMessage( IDS_ERROR_INVALID_IP_ADDRESS, strTempIPAddress );
                        AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                        bSuccess = FALSE;
                        break;
                    }  // if:  invalid IP address

                    // The IP address has changed - recompute the subnet mask and network.
                    m_strSubnetMask.Empty();
                    m_strNetwork.Empty();

                    //
                    // Make sure we process the IP address.
                    // If we don't call it here, and the user pressed Next
                    // while sitting in the IP address field, the EN_KILLFOCUS
                    // message won't get processed until after this method returns.
                    //
                    OnKillFocusIPAddr( EN_KILLFOCUS, IDC_VSAI_IP_ADDRESS, m_ipaIPAddress.m_hWnd, bHandled );

                    //
                    // If no subnet mask has been specified yet, make the
                    // user enter it manually.
                    //
                    if (    ( m_strSubnetMask.GetLength() == 0 )
                        ||  ( m_strNetwork.GetLength() == 0 )
                        )
                    {
                        CEnterSubnetMaskDlg dlg( strTempIPAddress, m_strSubnetMask, m_strNetwork, PwizThis() );
                        if ( dlg.DoModal() == IDOK )
                        {
                            m_strSubnetMask = dlg.RstrSubnetMask();
                            m_strNetwork = dlg.RstrNetwork();
                        } // if:  user accepted subnet mask
                        else
                        {
                            bSuccess = FALSE;
                            break;
                        } // else:  user cancelled subnet mask.
                    } // if:  no subnet mask specified yet
                } // if:  the IP address has changed

                //
                // If the network name has changed, validate it.
                //
                if ( strTempNetName != PwizThis()->RstrNetName() )
                {
                    CLRTL_NAME_STATUS cnStatus;

                    if ( ! ClRtlIsNetNameValid( strTempNetName, &cnStatus, FALSE /*CheckIfExists*/) )
                    {
                        CString     strMsg;
                        UINT        idsError = IDS_ERROR_INVALID_NETWORK_NAME;

                        switch ( cnStatus )
                        {
                            case NetNameTooLong:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_TOO_LONG;
                                break;
                            case NetNameInvalidChars:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_INVALID_CHARS;
                                break;
                            case NetNameInUse:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME_IN_USE;
                                break;
                            case NetNameDNSNonRFCChars:
                                idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                                break;
                            case NetNameSystemError:
                            {
                                DWORD scError = GetLastError();
                                CNTException nte( scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strTempNetName );
                                nte.ReportError();
                                break;
                            }
                            default:
                                idsError = IDS_ERROR_INVALID_NETWORK_NAME;
                                break;
                        }  // switch:  cnStatus

                        if ( cnStatus != NetNameSystemError )
                        {
                            strMsg.LoadString( idsError );

                            if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS ) {
                                int id = AppMessageBox( m_hWnd, strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                                if ( id == IDNO )
                                {
                                    bSuccess = FALSE;
                                }
                            }
                            else
                            {
                                AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
                                bSuccess = FALSE;
                            }
                        } // if:  popup not displayed yet

                        if ( ! bSuccess )
                        {
                            break;
                        }
                    }  // if:  invalid network name
                }  // if:  the network name has changed

                //
                // These two variables contain the net name and the IP address that will be
                // the sheet when we leave this page.
                //
                m_strNetName = strTempNetName;
                m_strIPAddress = strTempIPAddress;
            } // if:  Back button not presssed
            else
            {
                //
                // These two variables contain the net name and the IP address that will be
                // the sheet when we leave this page. This is needed to compare against the 
                // sheet data the next time we enter this page. If the sheet data is different
                // from this data, it means that the user has changed the data elsewhere and
                // the sheet data is reloaded into the UI. If the data has not changed in the
                // sheet then what is in the UI is the latest data and so it left unchanged.
                //
                m_strNetName = PwizThis()->RstrNetName();
                m_strIPAddress = PwizThis()->RstrIPAddress();
            } // if:  Back button has been pressed
        } // if:  saving data from the page
        else
        {
            //
            // If the copy of the data stored in this sheet is different from
            // the copy of the data in the sheet, then the user has changed the
            // data elsewhere in the wizard. So, reload it.
            // If not, we should not change the UI since it may contain unvalidated
            // user input.
            //
            if ( m_strNetName != PwizThis()->RstrNetName() )
            {
                m_editNetName.SetWindowText( PwizThis()->RstrNetName() );
            } // if:  the page copy of the net name is different from the sheet copy

            if ( m_strIPAddress != PwizThis()->RstrIPAddress() )
            {
                m_ipaIPAddress.SetWindowText( PwizThis()->RstrIPAddress() );
            } // if:  the page copy of the IP address is different from the sheet copy
        } // else:  setting data to the page
    } while ( 0 );

    return bSuccess;

} //*** CWizPageVSAccessInfo::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAccessInfo::BApplyChanges( void )
{
    if (    ! PwizThis()->BSetNetName( m_strNetName )
        ||  ! PwizThis()->BSetIPAddress( m_strIPAddress )
        ||  ! PwizThis()->BSetSubnetMask( m_strSubnetMask )
        ||  ! PwizThis()->BSetNetwork( m_strNetwork ) )
    {
        return FALSE;
    } // if:  error setting data in the wizard

    return TRUE;

} //*** CWizPageVSAccessInfo::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::OnKillFocusIPAddr
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on IDC_VSAI_IP_ADDRESS.
//
//  Arguments:
//      bHandled    [IN OUT] TRUE = we handled message (default).
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageVSAccessInfo::OnKillFocusIPAddr(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    CString             strAddress;
    CString             strMsg;
    CClusNetworkInfo *  pni;

    BSTR bstr = NULL;

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );

    m_ipaIPAddress.GetWindowText( bstr );
    strAddress = bstr;
    SysFreeString( bstr );
    bstr = NULL;

    if ( strAddress.GetLength() == 0 )
    {
        ((CEdit &) m_ipaIPAddress).SetSel( 0, 0, FALSE );
    } // if:  empty string
    else if ( ! BIsValidIpAddress( strAddress ) )
    {
    } // else if:  invalid address
    else
    {
        pni = PniFromIpAddress( strAddress );
        if ( pni != NULL )
        {
            m_strNetwork = pni->RstrName();
            m_strSubnetMask = pni->RstrAddressMask();
        } // if:  network found
        else
        {
            //m_strSubnetMask = _T("");
        } // else:  network not found
    } // else:  valid address

    bHandled = FALSE;
    return 0;

} //*** CWizPageVSAccessInfo::OnKillFocusIPAddr()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAccessInfo::PniFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pni             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusNetworkInfo * CWizPageVSAccessInfo::PniFromIpAddress( IN LPCWSTR pszAddress )
{
    DWORD               dwStatus;
    DWORD               nAddress;
    CClusNetworkInfo *  pni;

    //
    // Convert the address to a number.
    //
    dwStatus = ClRtlTcpipStringToAddress( pszAddress, &nAddress );
    if ( dwStatus != ERROR_SUCCESS )
    {
        return NULL;
    } // if:  error converting the address to a number

    //
    // Search the list for a matching address.
    //
    CClusNetworkPtrList::iterator itnet;
    for ( itnet = PwizThis()->PlpniNetworks()->begin()
        ; itnet != PwizThis()->PlpniNetworks()->end()
        ; itnet++ )
    {
        pni = *itnet;
        if ( ClRtlAreTcpipAddressesOnSameSubnet( nAddress, pni->NAddress(), pni->NAddressMask() ) )
        {
            return pni;
        } // if:  IP address is on this network
    }  // while:  more items in the list

    return NULL;

}  //*** CWizPageVSAccessInfo::PniFromIpAddress()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\tracetag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      TraceTag.cpp
//
//  Abstract:
//      Implementation of the CTraceTag class.
//
//  Author:
//      David Potter (davidp)   May 28, 1996
//
//  Revision History:
//
//  Notes:
//
//      TRACE_GetApp() must be defined to return a pointer to an object
//      that defines the GetProfileString() method.
//
//      TRACE_AppMessageBox must be defined and implemented.
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winnls.h>
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if DBG || defined( _DEBUG )

#ifndef CP_ANSI
#define CP_ANSI 1252
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagAlways( _T("Debug"), _T("Always"), CTraceTag::tfDebug );
CTraceTag   g_tagError( _T("Debug"), _T("Error"), CTraceTag::tfDebug );

// g_pszTraceIniFile must be an LPTSTR so it exists before "{" of WinMain.
// If we make it a CString, it may not be constructed when some of the
// tags are constructed, so we won't restore their value.
//LPTSTR        g_pszTraceIniFile       = _T("Trace.INI");
CString     g_strTraceFile;
BOOL        g_bBarfDebug            = TRUE;

CRITICAL_SECTION    CTraceTag::s_critsec;
BOOL                CTraceTag::s_bCritSecValid = FALSE;

#endif // DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
// CTraceTag
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

//  Static Variables...

CTraceTag *     CTraceTag::s_ptagFirst  = NULL;
CTraceTag *     CTraceTag::s_ptagLast   = NULL;
//HANDLE            CTraceTag::s_hfileCom2  = NULL;
LPCTSTR         CTraceTag::s_pszCom2    = _T(" com2 ");
LPCTSTR         CTraceTag::s_pszFile    = _T(" file ");
LPCTSTR         CTraceTag::s_pszDebug   = _T(" debug ");
LPCTSTR         CTraceTag::s_pszBreak   = _T(" break ");

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::CTraceTag
//
//  Routine Description:
//      Constructor.  "Initializes" the tag by giving it its name, giving
//      it a startup value (from the registry if possible), and adding it
//      to the list of current tags.
//
//  Arguments:
//      pszSubsystem    [IN] 8 char string to say to what the tag applies
//      pszName         [IN] Description of the tag (~30 chars)
//      uiFlagsDefault  [IN] Default value.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::CTraceTag(
    IN LPCTSTR  pszSubsystem,
    IN LPCTSTR  pszName,
    IN UINT     uiFlagsDefault
    )
{
    //  Store the calling parameters
    m_pszSubsystem = pszSubsystem;
    m_pszName = pszName;
    m_uiFlagsDefault = uiFlagsDefault;
    m_uiFlags = uiFlagsDefault;

    //  Add the tag to the list of tags
    if ( s_ptagLast != NULL )
    {
        s_ptagLast->m_ptagNext = this;
    } // if:  tag list not empty
    else
    {
        s_ptagFirst = this;
    } // else:  tag list is empty

    s_ptagLast = this;
    m_ptagNext = NULL;

    m_uiFlags = 0;

} //*** CTraceTag::CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::~CTraceTag
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CTraceTag::~CTraceTag( void )
{
#ifdef NEVER
    if ( s_hfileCom2 && (s_hfileCom2 != INVALID_HANDLE_VALUE) )
    {
        ::CloseHandle( s_hfileCom2 );
        s_hfileCom2 = NULL;
    } // if:  tracing to COM port and valid COM port handle
#endif

} //*** CTraceTag::~CTraceTag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::Init
//
//  Routine Description:
//      Initializes the tag by giving it its name and giving it a startup value
//      (from the registry if possible).
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::Init( void )
{
    CString     strSection;
    CString     strValue;

    //  Get the value from the Registry.
    strSection.Format( TRACE_TAG_REG_SECTION_FMT, m_pszSubsystem );
    strValue = TRACE_GetApp()->GetProfileString( strSection, m_pszName );
    strValue.MakeLower();
    if ( strValue.Find( s_pszCom2 ) != -1 )
    {
        m_uiFlags |= tfCom2;
    } // if:  logging to COM port
    if ( strValue.Find( s_pszFile ) != -1 )
    {
        m_uiFlags |= tfFile;
    } // if:  logging to file
    if ( strValue.Find( s_pszDebug ) != -1 )
    {
        m_uiFlags |= tfDebug;
    } // if:  logging to debugger
    if ( strValue.Find( s_pszBreak ) != -1 )
    {
        m_uiFlags |= tfBreak;
    } // if:  breaking into debugger

} //*** CTraceTag::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::ConstructRegState
//
//  Routine Description:
//      Constructs the registry state string.
//
//  Arguments:
//      rstr        [OUT] String in which to return the state string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::ConstructRegState( OUT CString & rstr )
{
    rstr = _T("");
    if ( BDebug() )
    {
        rstr += s_pszDebug;
    } // if:  logging to debugger
    if ( BBreak() )
    {
        rstr += s_pszBreak;
    } // if:  breaking into debugger
    if ( BCom2() )
    {
        rstr += s_pszCom2;
    } // if:  logging to COM port
    if ( BFile() )
    {
        rstr += s_pszFile;
    } // if:  logging to file

} //*** CTraceTag::ConstructRegState()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlags
//
//  Routine Description:
//      Sets/Resets TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlags( IN UINT tf, IN BOOL bEnable )
{
    if ( bEnable )
    {
        m_uiFlags |= tf;
    } // if:  enabling flag
    else
    {
        m_uiFlags &= ~tf;
    } // else:  disabling flag

} //*** CTraceTag::SetFlags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::SetFlagsDialog
//
//  Routine Description:
//      Sets/Resets the "Dialog Settings"  version of the TraceFlags.
//
//  Arguments:
//      tf          [IN] Flags to set.
//      bEnable     [IN] TRUE = set the flags, FALSE = clear the flags.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::SetFlagsDialog( IN UINT tf, IN BOOL bEnable )
{
    if ( bEnable )
    {
        m_uiFlagsDialog |= tf;
    } // if:  enabling flag
    else
    {
        m_uiFlagsDialog &= ~tf;
    } // else:  disabling flag

} //*** CTraceTag::SetFlagsDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::PszFile
//
//  Routine Description:
//      Returns the name of the file where to write the trace output.
//      The filename is read from the registry if it is unknown.
//
//  Arguments:
//      None.
//
//  Return Value:
//      psz     Name of the file.
//
//--
/////////////////////////////////////////////////////////////////////////////
LPCTSTR CTraceTag::PszFile( void )
{
    static  BOOL    bInitialized    = FALSE;

    if ( ! bInitialized )
    {
        g_strTraceFile = TRACE_GetApp()->GetProfileString(
                                        TRACE_TAG_REG_SECTION,
                                        TRACE_TAG_REG_FILE,
                                        _T("C:\\Trace.out")
                                        );
        bInitialized = TRUE;
    } // if:  not initialized

    return g_strTraceFile;

} //*** CTraceTag::PszFile()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CTraceTag::TraceV
//
//  Routine Description:
//      Processes a Trace statement based on the flags of the tag.
//
//  Arguments:
//      pszFormat   [IN] printf-style format string.
//      va_list     [IN] Argument block for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CTraceTag::TraceV( IN LPCTSTR pszFormat, va_list marker )
{
    CString     strTraceMsg;
    LPSTR       psz;
    int         cb;
    int         cbActual;
    
    //
    // Get out quick with any formats if we're not turned on.
    //
    if ( ! m_pszName || ! BAny() )
    {
        return;
    } // if:  nothing to do

    if ( BCritSecValid() )
    {
        EnterCriticalSection( &s_critsec );
    } // if:  critical section has been initialized

    FormatV( pszFormat, marker );
    strTraceMsg.Format( _T("%s: %s\x0D\x0A"), m_pszName, m_pchData );

    //
    // Send trace output to the debug window.
    //
    if ( BDebug() )
    {
        OutputDebugString( strTraceMsg );
    } // if:  logging to debugger

    if ( BCom2() || BFile() )
    {
#ifdef _UNICODE
        // Not much point in sending UNICODE output to COMM or file at the moment,
        // so convert to ANSI
        CHAR    aszTraceMsg[256];
        cb = ::WideCharToMultiByte(
                    CP_ANSI,
                    NULL,
                    strTraceMsg,
                    strTraceMsg.GetLength(),
                    aszTraceMsg,
                    sizeof( aszTraceMsg ),
                    NULL,
                    NULL
                    );
        psz = aszTraceMsg;
#else
        cb = strTraceMsg.GetLength();
        psz = (LPSTR) (LPCSTR) strTraceMsg;
#endif // _UNICODE

        // Send trace output to COM2.
        if ( BCom2() )
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if ( ! bOpenFailed )
            {
                hfile = ::CreateFile(
                                _T("COM2:"),
                                GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            } // if:  not currently in a 'COM2 failed to open' state
            
            if ( hfile != INVALID_HANDLE_VALUE )
            {
                ASSERT (::WriteFile( hfile, psz, cb, (LPDWORD) &cbActual, NULL ) );
//              ASSERT( ::FlushFileBuffers( hfile ) );
                ASSERT( ::CloseHandle( hfile ) );
            } // if:  COM2 opened successfully
            else
            {
                if ( ! bOpenFailed )
                {
                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    TRACE_AppMessageBox( _T("COM2 could not be opened."), MB_OK | MB_ICONINFORMATION );
                } // if:  open file didn't fail
            } // else:  file not opened successfully
        } // if:  sending trace output to COM2

        // Send trace output to a file.
        if ( BFile() )
        {
            HANDLE          hfile           = INVALID_HANDLE_VALUE;
            static  BOOL    bOpenFailed     = FALSE;

            if ( ! bOpenFailed )
            {
                hfile = ::CreateFile(
                                PszFile(),
                                GENERIC_WRITE,
                                FILE_SHARE_WRITE,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_FLAG_WRITE_THROUGH,
                                NULL
                                );
            } // if:  not currently in a 'file failed to open' state

            if ( hfile != INVALID_HANDLE_VALUE )
            {
                // Fail these calls silently to avoid recursive failing calls.
                ::SetFilePointer( hfile, NULL, NULL, FILE_END );
                ::WriteFile( hfile, psz, cb, (LPDWORD) &cbActual, NULL );
                ::CloseHandle( hfile );
            } // if:  file opened successfully
            else
            {
                if ( ! bOpenFailed )
                {
                    CString     strMsg;

                    bOpenFailed = TRUE;     // Do this first, so the str.Format
                                            // do not cause problems with their trace statement.

                    strMsg.Format( _T("The DEBUG ONLY trace log file '%s' could not be opened"), PszFile() );
                    TRACE_AppMessageBox( strMsg, MB_OK | MB_ICONINFORMATION );
                } // if:  open file didn't fail
            } // else:  file not opened successfully
        } // if:  sending trace output to a file
    } // if:  tracing to com and/or file

    // Do a DebugBreak on the trace.
    if ( BBreak() )
    {
        DebugBreak();
    } // if:  breaking into the debugger

    if ( BCritSecValid() )
    {
        LeaveCriticalSection( &s_critsec );
    } // if:  critical section has been initialized

} //*** CTraceTag::TraceFn()

#endif // DBG || defined( _DEBUG )


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

#if DBG || defined( _DEBUG )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  Trace
//
//  Routine Description:
//      Maps the Trace statement to the proper method call.  This is needed
//      (instead of doing directly ptag->Trace()) to guarantee that no code
//      is added in the retail build.
//
//  Arguments:
//      rtag        [IN OUT] Tag controlling the debug output
//      pszFormat   [IN] printf style formatting string.
//      ...         [IN] printf style parameters, depends on pszFormat
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void Trace( IN OUT CTraceTag & rtag, IN LPCTSTR pszFormat, ... )
{
    va_list     marker;

    va_start( marker, pszFormat );
    rtag.TraceV( pszFormat, marker );
    va_end( marker );

} //*** Trace()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      rexcept     [IN OUT] Exception from which to obtain the message.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError( IN OUT CException & rexcept )
{
    TCHAR           szMessage[1024];

    rexcept.GetErrorMessage( szMessage, sizeof( szMessage ) / sizeof( TCHAR ) );

    Trace(
        g_tagError,
        _T("EXCEPTION: %s"),
        szMessage
        );

} //*** TraceError(CException&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceError
//
//  Routine Description:
//      Formats a standard error string and outputs it to all trace outputs.
//
//  Arguments:
//      pszModule   [IN] Name of module in which error occurred.
//      sc          [IN] NT status code.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceError( IN LPCTSTR pszModule, IN SC sc )
{
    TCHAR           szMessage[1024];
    CNTException    nte( sc );

    nte.GetErrorMessage( szMessage, sizeof( szMessage ) / sizeof( TCHAR ) );

    Trace(
        g_tagError,
        _T("Module %s, SC = %#08lX = %d (10)\r\n = '%s'"),
        pszModule,
        sc,
        sc,
        szMessage
        );

} //*** TraceError(pszModule, sc)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  InitAllTraceTags
//
//  Routine Description:
//      Initializes all trace tags in the tag list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitAllTraceTags( void )
{
    CTraceTag * ptag;

    // Loop through the tag list.
    for ( ptag = CTraceTag::s_ptagFirst ; ptag != NULL ; ptag = ptag->m_ptagNext )
    {
        ptag->Init();
    } // for:  each trace tag

    InitializeCriticalSection( &CTraceTag::s_critsec );
    CTraceTag::s_bCritSecValid = TRUE;

} //*** InitAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CleanupAllTraceTags
//
//  Routine Description:
//      Cleanup after the trace tags.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupAllTraceTags(void)
{
    if ( CTraceTag::BCritSecValid() )
    {
        DeleteCriticalSection( &CTraceTag::s_critsec );
        CTraceTag::s_bCritSecValid = FALSE;
    } // if:  critical section is valid

} //*** CleanupAllTraceTags()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  TraceMenu
//
//  Routine Description:
//      Display information about menus.
//
//  Arguments:
//      rtag        [IN OUT] Trace tag to use to display information.
//      pmenu       [IN] Menu to traverse.
//      pszPrefix   [IN] Prefix string to display.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void TraceMenu(
    IN OUT CTraceTag &  rtag,
    IN const CMenu *    pmenu,
    IN LPCTSTR          pszPrefix
    )
{
    if ( rtag.BAny() )
    {
        UINT    cItems;
        UINT    iItem;
        UINT    nState;
        CString strMenu;
#ifndef __AFXWIN_H__
        BSTR    bstrMenu;
#endif
        CString strPrefix(pszPrefix);
        
        strPrefix += _T("->");

        cItems = pmenu->GetMenuItemCount();
        for ( iItem = 0 ; iItem < cItems ; iItem++ )
        {
#ifdef __AFXWIN_H__
            pmenu->GetMenuString( iItem, strMenu, MF_BYPOSITION );
#else // __ATLGDI_H__ must be defined
            pmenu->GetMenuString( iItem, bstrMenu, MF_BYPOSITION );
            strMenu = bstrMenu;
            SysFreeString( bstrMenu );
#endif
            nState = pmenu->GetMenuState( iItem, MF_BYPOSITION );
            if ( nState & MF_SEPARATOR )
            {
                strMenu += _T("SEPARATOR");
            } // if:  menu item is a separate
            if ( nState & MF_CHECKED )
            {
                strMenu += _T(" (checked)");
            } // if:  menu item is checked
            if ( nState & MF_DISABLED )
            {
                strMenu += _T(" (disabled)");
            } // if:  menu item is disabled
            if ( nState & MF_GRAYED )
            {
                strMenu += _T(" (grayed)");
            } // if:  menu item is grayed
            if ( nState & MF_MENUBARBREAK )
            {
                strMenu += _T(" (MenuBarBreak)");
            } // if:  menu item is a menu bar break
            if ( nState & MF_MENUBREAK )
            {
                strMenu += _T(" (MenuBreak)");
            } // if:  menu item is a menu break
            if ( nState & MF_POPUP )
            {
                strMenu += _T(" (popup)");
            } // if:  menu item is a popup menu

            Trace( rtag, _T("(0x%08.8x) %s%s"), pszPrefix, pmenu->m_hMenu, strMenu );

            if ( nState & MF_POPUP )
            {
#ifdef __AFXWIN_H__
                TraceMenu( rtag, pmenu->GetSubMenu( iItem ), strPrefix );
#else // __ATLGDI_H__ must be defined
                CMenu submenu( pmenu->GetSubMenu( iItem ) );
                TraceMenu( rtag, &submenu, strPrefix );
            } // if:  popup menu
#endif // __AFXWIN_H__
        } // for:  each item in the menu
    } // if:  any output is enabled

} //*** TraceMenu()

struct AFX_MAP_MESSAGE
{
    UINT    nMsg;
    LPCSTR  lpszMsg;
};

#include "dde.h"
#define DEFINE_MESSAGE(wm)  { wm, #wm }

static const AFX_MAP_MESSAGE allMessages[] =
{
    DEFINE_MESSAGE( WM_CREATE ),
    DEFINE_MESSAGE( WM_DESTROY ),
    DEFINE_MESSAGE( WM_MOVE ),
    DEFINE_MESSAGE( WM_SIZE ),
    DEFINE_MESSAGE( WM_ACTIVATE ),
    DEFINE_MESSAGE( WM_SETFOCUS ),
    DEFINE_MESSAGE( WM_KILLFOCUS ),
    DEFINE_MESSAGE( WM_ENABLE ),
    DEFINE_MESSAGE( WM_SETREDRAW ),
    DEFINE_MESSAGE( WM_SETTEXT ),
    DEFINE_MESSAGE( WM_GETTEXT ),
    DEFINE_MESSAGE( WM_GETTEXTLENGTH ),
    DEFINE_MESSAGE( WM_PAINT ),
    DEFINE_MESSAGE( WM_CLOSE ),
    DEFINE_MESSAGE( WM_QUERYENDSESSION ),
    DEFINE_MESSAGE( WM_QUIT ),
    DEFINE_MESSAGE( WM_QUERYOPEN ),
    DEFINE_MESSAGE( WM_ERASEBKGND ),
    DEFINE_MESSAGE( WM_SYSCOLORCHANGE ),
    DEFINE_MESSAGE( WM_ENDSESSION ),
    DEFINE_MESSAGE( WM_SHOWWINDOW ),
    DEFINE_MESSAGE( WM_CTLCOLORMSGBOX ),
    DEFINE_MESSAGE( WM_CTLCOLOREDIT ),
    DEFINE_MESSAGE( WM_CTLCOLORLISTBOX ),
    DEFINE_MESSAGE( WM_CTLCOLORBTN ),
    DEFINE_MESSAGE( WM_CTLCOLORDLG ),
    DEFINE_MESSAGE( WM_CTLCOLORSCROLLBAR ),
    DEFINE_MESSAGE( WM_CTLCOLORSTATIC ),
    DEFINE_MESSAGE( WM_WININICHANGE ),
    DEFINE_MESSAGE( WM_DEVMODECHANGE ),
    DEFINE_MESSAGE( WM_ACTIVATEAPP ),
    DEFINE_MESSAGE( WM_FONTCHANGE ),
    DEFINE_MESSAGE( WM_TIMECHANGE ),
    DEFINE_MESSAGE( WM_CANCELMODE ),
    DEFINE_MESSAGE( WM_SETCURSOR ),
    DEFINE_MESSAGE( WM_MOUSEACTIVATE ),
    DEFINE_MESSAGE( WM_CHILDACTIVATE ),
    DEFINE_MESSAGE( WM_QUEUESYNC ),
    DEFINE_MESSAGE( WM_GETMINMAXINFO ),
    DEFINE_MESSAGE( WM_ICONERASEBKGND ),
    DEFINE_MESSAGE( WM_NEXTDLGCTL ),
    DEFINE_MESSAGE( WM_SPOOLERSTATUS ),
    DEFINE_MESSAGE( WM_DRAWITEM ),
    DEFINE_MESSAGE( WM_MEASUREITEM ),
    DEFINE_MESSAGE( WM_DELETEITEM ),
    DEFINE_MESSAGE( WM_VKEYTOITEM ),
    DEFINE_MESSAGE( WM_CHARTOITEM ),
    DEFINE_MESSAGE( WM_SETFONT ),
    DEFINE_MESSAGE( WM_GETFONT ),
    DEFINE_MESSAGE( WM_QUERYDRAGICON ),
    DEFINE_MESSAGE( WM_COMPAREITEM ),
    DEFINE_MESSAGE( WM_COMPACTING ),
    DEFINE_MESSAGE( WM_NCCREATE ),
    DEFINE_MESSAGE( WM_NCDESTROY ),
    DEFINE_MESSAGE( WM_NCCALCSIZE ),
    DEFINE_MESSAGE( WM_NCHITTEST ),
    DEFINE_MESSAGE( WM_NCPAINT ),
    DEFINE_MESSAGE( WM_NCACTIVATE ),
    DEFINE_MESSAGE( WM_GETDLGCODE ),
    DEFINE_MESSAGE( WM_NCMOUSEMOVE ),
    DEFINE_MESSAGE( WM_NCLBUTTONDOWN ),
    DEFINE_MESSAGE( WM_NCLBUTTONUP ),
    DEFINE_MESSAGE( WM_NCLBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_NCRBUTTONDOWN ),
    DEFINE_MESSAGE( WM_NCRBUTTONUP ),
    DEFINE_MESSAGE( WM_NCRBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_NCMBUTTONDOWN ),
    DEFINE_MESSAGE( WM_NCMBUTTONUP ),
    DEFINE_MESSAGE( WM_NCMBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_KEYDOWN ),
    DEFINE_MESSAGE( WM_KEYUP ),
    DEFINE_MESSAGE( WM_CHAR ),
    DEFINE_MESSAGE( WM_DEADCHAR ),
    DEFINE_MESSAGE( WM_SYSKEYDOWN ),
    DEFINE_MESSAGE( WM_SYSKEYUP ),
    DEFINE_MESSAGE( WM_SYSCHAR ),
    DEFINE_MESSAGE( WM_SYSDEADCHAR ),
    DEFINE_MESSAGE( WM_KEYLAST ),
    DEFINE_MESSAGE( WM_INITDIALOG ),
    DEFINE_MESSAGE( WM_COMMAND ),
    DEFINE_MESSAGE( WM_SYSCOMMAND ),
    DEFINE_MESSAGE( WM_TIMER ),
    DEFINE_MESSAGE( WM_HSCROLL ),
    DEFINE_MESSAGE( WM_VSCROLL ),
    DEFINE_MESSAGE( WM_INITMENU ),
    DEFINE_MESSAGE( WM_INITMENUPOPUP ),
    DEFINE_MESSAGE( WM_MENUSELECT ),
    DEFINE_MESSAGE( WM_MENUCHAR ),
    DEFINE_MESSAGE( WM_ENTERIDLE ),
    DEFINE_MESSAGE( WM_MOUSEMOVE ),
    DEFINE_MESSAGE( WM_LBUTTONDOWN ),
    DEFINE_MESSAGE( WM_LBUTTONUP ),
    DEFINE_MESSAGE( WM_LBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_RBUTTONDOWN ),
    DEFINE_MESSAGE( WM_RBUTTONUP ),
    DEFINE_MESSAGE( WM_RBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_MBUTTONDOWN ),
    DEFINE_MESSAGE( WM_MBUTTONUP ),
    DEFINE_MESSAGE( WM_MBUTTONDBLCLK ),
    DEFINE_MESSAGE( WM_PARENTNOTIFY ),
    DEFINE_MESSAGE( WM_MDICREATE ),
    DEFINE_MESSAGE( WM_MDIDESTROY ),
    DEFINE_MESSAGE( WM_MDIACTIVATE ),
    DEFINE_MESSAGE( WM_MDIRESTORE ),
    DEFINE_MESSAGE( WM_MDINEXT ),
    DEFINE_MESSAGE( WM_MDIMAXIMIZE ),
    DEFINE_MESSAGE( WM_MDITILE ),
    DEFINE_MESSAGE( WM_MDICASCADE ),
    DEFINE_MESSAGE( WM_MDIICONARRANGE ),
    DEFINE_MESSAGE( WM_MDIGETACTIVE ),
    DEFINE_MESSAGE( WM_MDISETMENU ),
    DEFINE_MESSAGE( WM_CUT ),
    DEFINE_MESSAGE( WM_COPY ),
    DEFINE_MESSAGE( WM_PASTE ),
    DEFINE_MESSAGE( WM_CLEAR ),
    DEFINE_MESSAGE( WM_UNDO ),
    DEFINE_MESSAGE( WM_RENDERFORMAT ),
    DEFINE_MESSAGE( WM_RENDERALLFORMATS ),
    DEFINE_MESSAGE( WM_DESTROYCLIPBOARD ),
    DEFINE_MESSAGE( WM_DRAWCLIPBOARD ),
    DEFINE_MESSAGE( WM_PAINTCLIPBOARD ),
    DEFINE_MESSAGE( WM_VSCROLLCLIPBOARD ),
    DEFINE_MESSAGE( WM_SIZECLIPBOARD ),
    DEFINE_MESSAGE( WM_ASKCBFORMATNAME ),
    DEFINE_MESSAGE( WM_CHANGECBCHAIN ),
    DEFINE_MESSAGE( WM_HSCROLLCLIPBOARD ),
    DEFINE_MESSAGE( WM_QUERYNEWPALETTE ),
    DEFINE_MESSAGE( WM_PALETTEISCHANGING ),
    DEFINE_MESSAGE( WM_PALETTECHANGED ),
    DEFINE_MESSAGE( WM_DDE_INITIATE ),
    DEFINE_MESSAGE( WM_DDE_TERMINATE ),
    DEFINE_MESSAGE( WM_DDE_ADVISE ),
    DEFINE_MESSAGE( WM_DDE_UNADVISE ),
    DEFINE_MESSAGE( WM_DDE_ACK ),
    DEFINE_MESSAGE( WM_DDE_DATA ),
    DEFINE_MESSAGE( WM_DDE_REQUEST ),
    DEFINE_MESSAGE( WM_DDE_POKE ),
    DEFINE_MESSAGE( WM_DDE_EXECUTE ),
    DEFINE_MESSAGE( WM_DROPFILES ),
    DEFINE_MESSAGE( WM_POWER ),
    DEFINE_MESSAGE( WM_WINDOWPOSCHANGED ),
    DEFINE_MESSAGE( WM_WINDOWPOSCHANGING ),
#ifdef __AFXWIN_H__
// MFC specific messages
    DEFINE_MESSAGE( WM_SIZEPARENT ),
    DEFINE_MESSAGE( WM_SETMESSAGESTRING ),
    DEFINE_MESSAGE( WM_IDLEUPDATECMDUI ),
    DEFINE_MESSAGE( WM_INITIALUPDATE ),
    DEFINE_MESSAGE( WM_COMMANDHELP ),
    DEFINE_MESSAGE( WM_HELPHITTEST ),
    DEFINE_MESSAGE( WM_EXITHELPMODE ),
#endif // __AFXWIN_H__
    DEFINE_MESSAGE( WM_HELP ),
    DEFINE_MESSAGE( WM_NOTIFY ),
    DEFINE_MESSAGE( WM_CONTEXTMENU ),
    DEFINE_MESSAGE( WM_TCARD ),
    DEFINE_MESSAGE( WM_MDIREFRESHMENU ),
    DEFINE_MESSAGE( WM_MOVING ),
    DEFINE_MESSAGE( WM_STYLECHANGED ),
    DEFINE_MESSAGE( WM_STYLECHANGING ),
    DEFINE_MESSAGE( WM_SIZING ),
    DEFINE_MESSAGE( WM_SETHOTKEY ),
    DEFINE_MESSAGE( WM_PRINT ),
    DEFINE_MESSAGE( WM_PRINTCLIENT ),
    DEFINE_MESSAGE( WM_POWERBROADCAST ),
    DEFINE_MESSAGE( WM_HOTKEY ),
    DEFINE_MESSAGE( WM_GETICON ),
    DEFINE_MESSAGE( WM_EXITMENULOOP ),
    DEFINE_MESSAGE( WM_ENTERMENULOOP ),
    DEFINE_MESSAGE( WM_DISPLAYCHANGE ),
    DEFINE_MESSAGE( WM_STYLECHANGED ),
    DEFINE_MESSAGE( WM_STYLECHANGING ),
    DEFINE_MESSAGE( WM_GETICON ),
    DEFINE_MESSAGE( WM_SETICON ),
    DEFINE_MESSAGE( WM_SIZING ),
    DEFINE_MESSAGE( WM_MOVING ),
    DEFINE_MESSAGE( WM_CAPTURECHANGED ),
    DEFINE_MESSAGE( WM_DEVICECHANGE ),
    DEFINE_MESSAGE( WM_PRINT ),
    DEFINE_MESSAGE( WM_PRINTCLIENT ),
// MFC private messages
#ifdef __AFXWIN_H__
    DEFINE_MESSAGE( WM_QUERYAFXWNDPROC ),
    DEFINE_MESSAGE( WM_RECALCPARENT ),
    DEFINE_MESSAGE( WM_SIZECHILD ),
    DEFINE_MESSAGE( WM_KICKIDLE ),
    DEFINE_MESSAGE( WM_QUERYCENTERWND ),
    DEFINE_MESSAGE( WM_DISABLEMODAL ),
    DEFINE_MESSAGE( WM_FLOATSTATUS ),
    DEFINE_MESSAGE( WM_ACTIVATETOPLEVEL ),
    DEFINE_MESSAGE( WM_QUERY3DCONTROLS ),
    DEFINE_MESSAGE( WM_RESERVED_0370 ),
    DEFINE_MESSAGE( WM_RESERVED_0371 ),
    DEFINE_MESSAGE( WM_RESERVED_0372 ),
    DEFINE_MESSAGE( WM_SOCKET_NOTIFY ),
    DEFINE_MESSAGE( WM_SOCKET_DEAD ),
    DEFINE_MESSAGE( WM_POPMESSAGESTRING ),
    DEFINE_MESSAGE( WM_OCC_LOADFROMSTREAM ),
    DEFINE_MESSAGE( WM_OCC_LOADFROMSTORAGE ),
    DEFINE_MESSAGE( WM_OCC_INITNEW ),
    DEFINE_MESSAGE( WM_OCC_LOADFROMSTREAM_EX ),
    DEFINE_MESSAGE( WM_OCC_LOADFROMSTORAGE_EX ),
    DEFINE_MESSAGE( WM_QUEUE_SENTINEL ),
    DEFINE_MESSAGE( WM_RESERVED_037C ),
    DEFINE_MESSAGE( WM_RESERVED_037D ),
    DEFINE_MESSAGE( WM_RESERVED_037E ),
    DEFINE_MESSAGE( WM_RESERVED_037F ),
#endif // __AFXWIN_H_
    { 0, NULL, }   // end of message list
};

#undef DEFINE_MESSAGE

void TraceMsg( LPCTSTR lpszPrefix, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    ASSERT( lpszPrefix != NULL );

    if (   (message == WM_MOUSEMOVE) || (message == WM_NCMOUSEMOVE)
        || (message == WM_NCHITTEST)
        || (message == WM_SETCURSOR)
        || (message == WM_CTLCOLORBTN)
        || (message == WM_CTLCOLORDLG)
        || (message == WM_CTLCOLOREDIT)
        || (message == WM_CTLCOLORLISTBOX)
        || (message == WM_CTLCOLORMSGBOX)
        || (message == WM_CTLCOLORSCROLLBAR)
        || (message == WM_CTLCOLORSTATIC)
        || (message == WM_ENTERIDLE)
        || (message == WM_CANCELMODE)
        || (message == 0x0118)    // WM_SYSTIMER (caret blink)
        )
    {
        // don't report very frequently sent messages
        return;
    } // if:  frequently sent message

    LPCSTR paszMsgName = NULL;
    char aszBuf[80];

    // find message name
    if ( message >= 0xC000 )
    {
        // Window message registered with 'RegisterWindowMessage'
        //  (actually a USER atom)
        if ( ::GetClipboardFormatNameA( message, aszBuf, RTL_NUMBER_OF( aszBuf ) ) )
        {
            paszMsgName = aszBuf;
        } // if:  registered message
    }
    else if ( message >= WM_USER )
    {
        // User message
        HRESULT hr = StringCchPrintfA( aszBuf, RTL_NUMBER_OF( aszBuf ), "WM_USER+0x%04X", message - WM_USER );
        ASSERT( SUCCEEDED( hr ) );
        paszMsgName = aszBuf;
    } // else if:  WM_USER message
    else
    {
        // a system windows message
        const AFX_MAP_MESSAGE * pMapMsg = allMessages;
        for ( /*null*/; pMapMsg->lpszMsg != NULL; pMapMsg++ )
        {
            if ( pMapMsg->nMsg == message )
            {
                paszMsgName = pMapMsg->lpszMsg;
                break;
            } // if:  found a match
        } // for:  each message in the table
    } // else:  other message

    if ( paszMsgName != NULL )
    {
        AtlTrace(
            _T("%s: hwnd=0x%p, msg = %hs (0x%04X, 0x%08lX)\n"),
            lpszPrefix,
            hwnd,
            paszMsgName,
            wParam,
            lParam
            );
    } // if:  message found
    else
    {
        AtlTrace(
            _T("%s: hwnd=0x%p, msg = 0x%04X (0x%04X, 0x%08lX)\n"),
            lpszPrefix,
            hwnd,
            message,
            wParam,
            lParam
            );
    } // else:  unknown message

//#ifndef _MAC
//  if ( message >= WM_DDE_FIRST && message <= WM_DDE_LAST )
//      TraceDDE( lpszPrefix, pMsg );
//#endif

} //*** TraceMsg()

#endif // DBG || defined( _DEBUG )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSAdv.h
//
//  Abstract:
//      Definition of the CWizPageVSAdvanced class.
//
//  Implementation File:
//      VSAdv.cpp
//
//  Author:
//      David Potter (davidp)   December 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSADV_H_
#define __VSADV_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAdvanced;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h" // for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"        // for CClusGroupInfo, CClusResInfo
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAdvanced
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAdvanced : public CClusterAppStaticWizardPage< CWizPageVSAdvanced >
{
    typedef CClusterAppStaticWizardPage< CWizPageVSAdvanced > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CWizPageVSAdvanced( void )
        : m_bGroupChanged( FALSE )
        , m_bIPAddressChanged( FALSE )
        , m_bNetworkNameChanged( FALSE )
    {
    } //*** CWizPageVSAdvanced()

    WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSA )
    WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSA )

    enum { IDD = IDD_VIRTUAL_SERVER_ADVANCED };

public:
    //
    // CWizardPageWindow public methods.
    //

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

public:
    //
    // CWizardPageImpl required methods.
    //

    // Initialize the page
    BOOL BInit( IN CBaseSheetWindow * psht );

public:
    //
    // CBasePage public methods.
    //

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CWizPageVSAdvanced )
        COMMAND_HANDLER( IDC_VSA_CATEGORIES, LBN_DBLCLK, OnAdvancedProps )
        COMMAND_HANDLER( IDC_VSA_ADVANCED_PROPS, BN_CLICKED, OnAdvancedProps )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Command handler to display advanced properties
    LRESULT OnAdvancedProps(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

    // Handler for PSN_WIZBACK
    int OnWizardBack( void );

// Implementation
protected:
    //
    // Controls.
    //
    CListBox        m_lbCategories;

    //
    // Page state.
    //
    BOOL            m_bGroupChanged;
    BOOL            m_bIPAddressChanged;
    BOOL            m_bNetworkNameChanged;

    // Quick check if anything changed on the page
    BOOL BAnythingChanged( void ) const
    {
        return ( m_bGroupChanged || m_bIPAddressChanged || m_bNetworkNameChanged );

    } //*** BAnythingChanged()

    // Fill the list control with a list of advanced property categories
    void FillListBox( void );

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_ADVANCED; }

}; //*** class CWizPageVSAdvanced

/////////////////////////////////////////////////////////////////////////////

#endif // __VSADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vscreate.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSCreate.cpp
//
//  Abstract:
//      Implementation of the CWizPageVSCreate class.
//
//  Author:
//      David Potter (davidp)   December 5, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSCreate.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreate
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSCreate )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_CREATE_NEW )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_USE_EXISTING )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_VIRTUAL_SERVERS_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSC_VIRTUAL_SERVERS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSCreate::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_rbCreateNew, IDC_VSC_CREATE_NEW );
    AttachControl( m_rbUseExisting, IDC_VSC_USE_EXISTING );
    AttachControl( m_cboxVirtualServers, IDC_VSC_VIRTUAL_SERVERS );

    //
    // Get info from the sheet.
    //
    m_bCreateNew = PwizThis()->BCreatingNewVirtualServer();

    //
    // Stuff below here requires the groups to have been fully collected
    // so we can know which are virtual servers and which are not.
    //
    PwizThis()->WaitForGroupsToBeCollected();

    //
    // If there is no virtual server group yet, check to see if there is a
    // default virtual server name specified.  If not, clear the virtual server
    // name.  Otherwise, get the virtual name from the virtual server group.
    // This is only needed if the caller of the wizard passed in a
    // virtual server name.
    //
    if ( PwizThis()->PgiExistingVirtualServer() == NULL )
    {
        if (   (PcawData() != NULL )
            && ! PcawData()->bCreateNewVirtualServer
            && (PcawData()->pszVirtualServerName != NULL) )
        {
            m_strVirtualServer = PcawData()->pszVirtualServerName;
        } // if:  default data was specified
        else
        {
            m_strVirtualServer.Empty();
        } // else:  no default data specified
    } // if:  no existing virtual server yet
    else
    {
        m_strVirtualServer = PwizThis()->PgiExistingVirtualServer()->RstrName();
    } // else:  existing virtual server already specified

    //
    // Fill the list of virtual servers.
    //
    FillComboBox();

    return TRUE;

} //*** CWizPageVSCreate::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSCreate::UpdateData
//
//  Routine Description:
//      Update data on or from the page.
//
//  Arguments:
//      bSaveAndValidate    [IN] TRUE if need to read data from the page.
//                              FALSE if need to set data to the page.
//
//  Return Value:
//      TRUE        The data was updated successfully.
//      FALSE       An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::UpdateData( IN BOOL bSaveAndValidate )
{
    BOOL    bSuccess = TRUE;

    if ( bSaveAndValidate )
    {
        BOOL bChecked = (m_rbCreateNew.GetCheck() == BST_CHECKED);
        m_bCreateNew = bChecked;
        if ( ! bChecked )
        {
            //
            // Save the combobox selection.
            //
            DDX_GetText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, m_strVirtualServer );

            if ( ! BBackPressed() )
            {
                if ( ! DDV_RequiredText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, IDC_VSC_VIRTUAL_SERVERS_LABEL, m_strVirtualServer ) )
                {
                    return FALSE;
                } // if:  virtual server not specified
            } // if:  Back button not presssed

            //
            // Save the group info pointer.
            //
            int idx = m_cboxVirtualServers.GetCurSel();
            ASSERT( idx != CB_ERR );
            m_pgi = (CClusGroupInfo *) m_cboxVirtualServers.GetItemDataPtr( idx );
        } // if:  using an existing virtual server
    } // if: saving data from the page
    else
    {
        if ( m_bCreateNew )
        {
            //
            // Default the radio button selection.
            //
            m_rbCreateNew.SetCheck( BST_CHECKED );
            m_rbUseExisting.SetCheck( BST_UNCHECKED );

        } // if:  creating new virtual server
        else
        {
            //
            // Default the radio button selection.
            //
            m_rbCreateNew.SetCheck( BST_UNCHECKED );
            m_rbUseExisting.SetCheck( BST_CHECKED );

            //
            // Set the combobox selection.
            //
//          DDX_SetComboBoxText( m_hWnd, IDC_VSC_VIRTUAL_SERVERS, m_strVirtualServer, TRUE /*bRequired*/ );
        } // else:  using existing virtual server

        //
        // Enable/disable the combobox.
        //
        m_cboxVirtualServers.EnableWindow( ! m_bCreateNew /*bEnable*/ );

    } // else:  setting data to the page

    return bSuccess;

} //*** CWizPageVSCreate::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSCreate::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreate::BApplyChanges( void )
{
    //
    // Save the current state.
    //
    if ( ! PwizThis()->BSetCreatingNewVirtualServer( m_bCreateNew, m_pgi ) )
    {
        return FALSE;
    } // if:  error setting new state

    //
    // If using an existing server, skip all the virtual server pages and
    // move right to the create resource pages.
    //
    if ( ! m_bCreateNew )
    {
        SetNextPage( IDD_APP_RESOURCE_CREATE );
    } // if:  using existing virtual server

    return TRUE;

} //*** CWizPageVSCreate::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSCreate::FillComboBox
//
//  Routine Description:
//      Fill the combobox with a list of existing virtual servers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSCreate::FillComboBox( void )
{
    // Loop to avoid goto's.
    do
    {
        //
        // Collect the list of groups.
        //
        if ( ! PwizThis()->BCollectGroups( GetParent() ) )
        {
            break;
        } // if:  error collecting groups

        //
        // For each group in the cluster, find out if it is a virtual server
        // or not.  If so then add it to the combobox.
        //

        CClusGroupPtrList::iterator itgrp;
        int idx;
        for ( itgrp = PwizThis()->PlpgiGroups()->begin()
            ; itgrp != PwizThis()->PlpgiGroups()->end()
            ; itgrp++ )
        {
            //
            // If this is a virtual server, add it to the list.
            // Save a pointer to the group info object with the string
            // so we can retrieve it with the selection later.
            //
            CClusGroupInfo * pgi = *itgrp;
            if ( pgi->BIsVirtualServer() )
            {
                idx = m_cboxVirtualServers.AddString( pgi->RstrName() );
                ASSERT( idx != CB_ERR );
                m_cboxVirtualServers.SetItemDataPtr( idx, (void *) pgi );
            } // if:  group is a virtual server
        } // for:  each entry in the list

        //
        // Select the currently saved entry, or the first one if none are
        // currently saved.
        //
        if ( m_strVirtualServer.GetLength() == 0 )
        {
            m_cboxVirtualServers.SetCurSel( 0 );
        } // if:  no virtual server yet
        else
        {
            idx = m_cboxVirtualServers.FindStringExact( -1, m_strVirtualServer );
            ASSERT( idx != CB_ERR );
            if ( idx != CB_ERR )
            {
                m_cboxVirtualServers.SetCurSel( idx );
            } // if:  virtual server found in list
        } // else:  virtual server saved
    } while ( 0 );

} //*** CWizPageVSCreate::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsaccess.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSAccess.h
//
//  Abstract:
//      Definition of the CWizPageVSAccessInfo class.
//
//  Implementation File:
//      VSAccess.cpp
//
//  Author:
//      David Potter (davidp)   December 9, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSACCESS_H_
#define __VSACCESS_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAccessInfo;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusNetworkInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h" // for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAccessInfo
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSAccessInfo : public CClusterAppStaticWizardPage< CWizPageVSAccessInfo >
{
    typedef CClusterAppStaticWizardPage< CWizPageVSAccessInfo > baseClass;

public:
    //
    // Construction
    //

    // Default constructor
    CWizPageVSAccessInfo( void )
    {
    } //*** CCWizPageVSAccessInfo()

    WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSAI )
    WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSAI )

    enum { IDD = IDD_VIRTUAL_SERVER_ACCESS_INFO };

public:
    //
    // CWizardPageWindow public methods.
    //

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CWizPageVSAccessInfo )
        COMMAND_HANDLER( IDC_VSAI_NETWORK_NAME, EN_CHANGE, OnChangedNetName )
        COMMAND_HANDLER( IDC_VSAI_IP_ADDRESS, EN_CHANGE, OnChangedIPAddr )
        COMMAND_HANDLER( IDC_VSAI_IP_ADDRESS, EN_KILLFOCUS, OnKillFocusIPAddr )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the EN_CHANGE command notification on IDC_VSAI_NETWORK_NAME
    LRESULT OnChangedNetName(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        CheckForRequiredFields();
        return 0;

    } //*** OnChangedNetName()

    // Handler for the EN_CHANGE command notification on IDC_VSAI_IP_ADDRESS
    LRESULT OnChangedIPAddr(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        CheckForRequiredFields();
        return 0;

    } //*** OnChangedIPAddr()

    // Handler for the EN_KILLFOCUS command notification on IDC_VSAI_IP_ADDRESS
    LRESULT OnKillFocusIPAddr(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        );

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

// Implementation
protected:
    //
    // Controls.
    //
    CEdit           m_editNetName;
    CIPAddressCtrl  m_ipaIPAddress;
    CComboBox       m_cboxNetworks;

    //
    // Page state.
    //
    CString         m_strNetName;
    CString         m_strIPAddress;
    CString         m_strSubnetMask;
    CString         m_strNetwork;

    // Check for required fields and enable/disable Next button
    void CheckForRequiredFields( void )
    {
        int cchNetName = m_editNetName.GetWindowTextLength();
        BOOL bIsIPAddrBlank = m_ipaIPAddress.IsBlank();
        BOOL bEnable = (cchNetName > 0) && ! bIsIPAddrBlank;
        EnableNext( bEnable );

    } //*** CheckForRequiredFields()

    // Get a network info object from an IP address
    CClusNetworkInfo * PniFromIpAddress( IN LPCWSTR pszAddress );

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_ACCESS_INFO; }

}; //*** class CWizPageVSAccessInfo

/////////////////////////////////////////////////////////////////////////////

#endif // __VSACCESS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSAdv.cpp
//
//  Abstract:
//      Implementation of the CWizPageVSAdvanced class.
//
//  Author:
//      David Potter (davidp)   December 10, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSAdv.h"
#include "ClusAppWiz.h"
#include "GrpAdv.h"         // for CGroupAdvancedSheet
#include "ResAdv.h"         // for CResourceAdvancedSheet

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSAdvanced
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSAdvanced )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_DESCRIPTION_1 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_DESCRIPTION_2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_CATEGORIES_LABEL )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_CATEGORIES )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSA_ADVANCED_PROPS )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_CLICK_NEXT )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::OnInitDialog
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN] Property sheet object to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::BInit( IN CBaseSheetWindow * psht )
{
    //
    // Call the base class method.
    //
    if ( ! baseClass::BInit( psht ) )
    {
        return FALSE;
    } // if:  error calling base class method

    return TRUE;

} //*** CWizPageVSAdvanced::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::OnInitDialog( void )
{
    //
    // Attach the controls to control member variables.
    //
    AttachControl( m_lbCategories, IDC_VSA_CATEGORIES );

    //
    // Get info from the sheet.
    //

    //
    // Fill the list of categories.
    //
    FillListBox();

    return TRUE;

} //*** CWizPageVSAdvanced::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::OnSetActive
//
//  Routine Description:
//      Handler for PSN_SETACTIVE.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Page activated successfully.
//      FALSE       Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::OnSetActive( void )
{
    //
    // Get info from the sheet.
    //

    //
    // Call the base class and return.
    //
    return baseClass::OnSetActive();

} //*** CWizPageVSAdvanced::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::OnWizardBack
//
//  Routine Description:
//      Handler for PSN_WIZBACK.
//
//  Arguments:
//      None.
//
//  Return Value:
//      0               Move to previous page.
//      -1              Don't move to previous page.
//      anything else   Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageVSAdvanced::OnWizardBack( void )
{
    int _nResult;

    //
    // Call the base class.  This causes our UpdateData() method to get
    // called.  If it succeeds, save our values.
    //
    _nResult = baseClass::OnWizardBack();
    if ( _nResult != -1 )
    {
        if ( ! BApplyChanges() ) 
        {
            _nResult = -1;
        } // if:  applying changes failed
    } // if:  base class called successfully

    return _nResult;

} //*** CWizPageVSAdvanced::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::BApplyChanges
//
//  Routine Description:
//      Apply changes made on this page to the sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The data was applied successfully.
//      FALSE       An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSAdvanced::BApplyChanges( void )
{
    BOOL    _bSuccess = TRUE;

    if ( BAnythingChanged() )
    {
        //
        // If the cluster has been updated, reset the cluster.
        //
        if ( PwizThis()->BClusterUpdated() )
        {
            if ( ! PwizThis()->BResetCluster() )
            {
                return FALSE;
            } // if:  failed to reset the cluster
        } // if:  cluster was updated
        PwizThis()->SetVSDataChanged();
    } // if: anything changed

    //
    // Create the group and resources as appropriate.
    //
    if ( PwizThis()->BVSDataChanged() && ! BBackPressed() )
    {
        _bSuccess = PwizThis()->BCreateVirtualServer();
        if ( _bSuccess )
        {
            m_bGroupChanged = FALSE;
            m_bIPAddressChanged = FALSE;
            m_bNetworkNameChanged = FALSE;
        } // if: virtual server created successfully
    } // if:  virtual server data changed

    return _bSuccess;

} //*** CWizPageVSAdvanced::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::OnAdvancedProps
//
//  Routine Description:
//      Command handler to display advanced properties.  This is the handler
//      for the BN_CLICKED command notification on IDC_VSA_ADVANCED_PROPS, and
//      for the LBN_DBLCLK command notification on IDC_VSA_CATEGORIES.
//
//  Arguments:
//      wNotifyCode
//      idCtrl
//      hwndCtrl
//      bHandled
//
//  Return Value:
//      Ignored.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CWizPageVSAdvanced::OnAdvancedProps(
    WORD wNotifyCode,
    int idCtrl,
    HWND hwndCtrl,
    BOOL & bHandled
    )
{
    CWaitCursor     _wc;
    int             _idx;

    UNREFERENCED_PARAMETER( wNotifyCode );
    UNREFERENCED_PARAMETER( idCtrl );
    UNREFERENCED_PARAMETER( hwndCtrl );
    UNREFERENCED_PARAMETER( bHandled );

    //
    // Make sure nodes have been collected already.
    //
    if ( ! PwizThis()->BCollectedNodes() )
    {
        //
        // Collect the nodes in the cluster.
        //
        if ( PwizThis()->BCollectNodes( GetParent() ) )
        {
        } // if:  nodes collected successfully
    } // if:  nodes haven't been collected yet

    //
    // Get the current selection in the list box.
    //
    _idx = m_lbCategories.GetCurSel();
    ASSERT( _idx != LB_ERR );
    ASSERT( 0 <= _idx && _idx <= 2 );

    //
    // Display a property sheet based on which item is selected.
    //
    switch ( _idx )
    {
        case 0:
            {
                CGroupAdvancedSheet _sht( IDS_ADV_GRP_PROP_TITLE );

                if ( _sht.BInit( PwizThis()->RgiCurrent(), PwizThis(), m_bGroupChanged ) )
                {
                    _sht.DoModal( m_hWnd );
                } // if:  sheet successfully initialized
            }
            break;
        case 1:
            {
                CIPAddrAdvancedSheet _sht( IDS_ADV_IPADDR_PROP_TITLE, PwizThis() );

                if ( _sht.BInit( PwizThis()->RriIPAddress(), m_bIPAddressChanged ) )
                {
                    INT_PTR _idReturn;

                    _sht.InitPrivateData(
                        PwizThis()->RstrIPAddress(),
                        PwizThis()->RstrSubnetMask(),
                        PwizThis()->RstrNetwork(),
                        PwizThis()->BEnableNetBIOS(),
                        PwizThis()->PlpniNetworks()
                        );
                    _idReturn = _sht.DoModal( m_hWnd );
                    if ( _idReturn != IDCANCEL )
                    {
                        PwizThis()->BSetIPAddress( _sht.m_strIPAddress );
                        PwizThis()->BSetSubnetMask( _sht.m_strSubnetMask );
                        PwizThis()->BSetNetwork( _sht.m_strNetwork );
                        PwizThis()->BSetEnableNetBIOS( _sht.m_bEnableNetBIOS );
                    } // if:  sheet not canceled
                } // if:  sheet successfully initialized
            }
            break;
        case 2:
            {
                CNetNameAdvancedSheet _sht( IDS_ADV_NETNAME_PROP_TITLE, PwizThis() );

                if ( _sht.BInit( PwizThis()->RriNetworkName(), m_bNetworkNameChanged ) )
                {
                    INT_PTR _idReturn;

                    _sht.InitPrivateData( PwizThis()->RstrNetName() );
                    _idReturn = _sht.DoModal( m_hWnd );
                    if ( _idReturn != IDCANCEL )
                    {
                        PwizThis()->BSetNetName( _sht.m_strNetName );
                    } // if:  sheet not canceled
                } // if:  sheet successfully initialized
            }
            break;
        default:
            _ASSERT( 0 );
    } // switch:  idx

    return 0;

} //*** CWizPageVSAdvanced::OnAdvancedProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageVSAdvanced::FillListBox
//
//  Routine Description:
//      Fill the list control with a list of advanced property categories.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSAdvanced::FillListBox( void )
{
    CWaitCursor _wc;
    CString     _strType;

    //
    // Add each property type to the list.
    //

    _strType.LoadString( IDS_VSA_CAT_RES_GROUP_PROPS );
    m_lbCategories.InsertString( 0, _strType );

    _strType.LoadString( IDS_VSA_CAT_IP_ADDRESS_PROPS );
    m_lbCategories.InsertString( 1, _strType );

    _strType.LoadString( IDS_VSA_CAT_NET_NAME_PROPS );
    m_lbCategories.InsertString( 2, _strType );

    //
    // Set the current selection.
    //
    m_lbCategories.SetCurSel( 0 );

} //*** CWizPageVSAdvanced::FillListBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vscreated.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreated.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSCreated class.
//
//	Author:
//		David Potter (davidp)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSCreated.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreated
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSCreated )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2A )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2B )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2C )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSCreated::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None..
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSCreated::OnInitDialog( void )
{
	//
	// Attach controls to control member variables.
	//
	AttachControl( m_staticStep2, IDC_WIZARD_STEP2 );

	//
	// Set the font of the control.
	//
	m_staticStep2.SetFont( PwizThis()->RfontBoldText() );

	return TRUE;

} //*** CWizPageVSCreated::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vscreate.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSCreate.h
//
//  Abstract:
//      Definition of the CWizPageVSCreate class.
//
//  Implementation File:
//      VSCreate.cpp
//
//  Author:
//      David Potter (davidp)   December 5, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSCREATE_H_
#define __VSCREATE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreate;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h" // for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreate
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreate : public CClusterAppStaticWizardPage< CWizPageVSCreate >
{
    typedef CClusterAppStaticWizardPage< CWizPageVSCreate > baseClass;

public:
    //
    // Construction
    //

    // Standard constructor
    CWizPageVSCreate( void )
        : m_bCreateNew( TRUE )
        , m_pgi( NULL )
    {
    } //*** CWizPageVSCreate()

    WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSC )
    WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSC )

    enum { IDD = IDD_VIRTUAL_SERVER_CREATE };

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CWizPageVSCreate )
        COMMAND_HANDLER( IDC_VSC_CREATE_NEW, BN_CLICKED, OnRadioButtonsChanged )
        COMMAND_HANDLER( IDC_VSC_USE_EXISTING, BN_CLICKED, OnRadioButtonsChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the BN_CLICKED command notification on IDC_VSG_CREATE_NEW and IDC_VSG_USE_EXISTING
    LRESULT OnRadioButtonsChanged(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        BOOL bEnable = (m_rbCreateNew.GetCheck() != BST_CHECKED);
        m_cboxVirtualServers.EnableWindow( bEnable );
        return 0;

    } //*** OnRadioButtonsChanged()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

// Implementation
protected:
    //
    // Controls.
    //
    CButton         m_rbCreateNew;
    CButton         m_rbUseExisting;
    CComboBox       m_cboxVirtualServers;

    //
    // Page state.
    //
    BOOL                m_bCreateNew;
    CString             m_strVirtualServer;
    CClusGroupInfo *    m_pgi;

    // Fill the combobox with a list of existing virtual servers
    void FillComboBox( void );

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATE; }

}; //*** class CWizPageVSCreate

/////////////////////////////////////////////////////////////////////////////

#endif // __VSCREATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vscreated.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSCreated.h
//
//	Abstract:
//		Definition of the CWizPageVSCreated class.
//
//	Implementation File:
//		VSCreated.cpp
//
//	Author:
//		David Potter (davidp)	December 10, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSCREATED_H_
#define __VSCREATED_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreated;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSCreated
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSCreated : public CClusterAppStaticWizardPage< CWizPageVSCreated >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSCreated > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSCreated( void )
	{
	} //*** CWizPageVSCreated()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSCD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSCD )

	enum { IDD = IDD_VIRTUAL_SERVER_CREATED };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageVSCreated )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic		m_staticStep2;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_CREATED; }

}; //*** class CWizPageVSCreated

/////////////////////////////////////////////////////////////////////////////

#endif // __VSCREATED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsdesc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSDesc.h
//
//	Abstract:
//		Definition of the CWizPageVSDesc class.
//
//	Implementation File:
//		VSDesc.cpp
//
//	Author:
//		David Potter (davidp)	December 3, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSDESC_H_
#define __VSDESC_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSDesc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSDesc
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSDesc : public CClusterAppStaticWizardPage< CWizPageVSDesc >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSDesc > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSDesc( void )
	{
	} //*** CWizPageVSDesc()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSD )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSD )

	enum { IDD = IDD_VIRTUAL_SERVER_DESCRIPTION };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageVSDesc )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

// Implementation
protected:

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_DESCRIPTION; }

}; //*** class CWizPageVSDesc

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSDesc )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT1 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT2 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_LIST_DOT_3 )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSD_COMPONENT3 )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////

#endif // __VSDESC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsgroup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGroup.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSGroup class.
//
//	Author:
//		David Potter (davidp)	December 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSGroup.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroup
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSGroup )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_PAGE_DESCRIPTION )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_CREATE_NEW )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_USE_EXISTING )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_GROUPS_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSG_GROUPS )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_rbCreateNew, IDC_VSG_CREATE_NEW );
	AttachControl( m_rbUseExisting, IDC_VSG_USE_EXISTING );
	AttachControl( m_cboxGroups, IDC_VSG_GROUPS );

	//
	// Get info from the sheet in OnSetActive because we might be skipped
	// the first time through, and then the user could change his mind,
	// which would mean the information we retrieve here would be out of date.
	//

	return TRUE;

} //*** CWizPageVSGroup::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::OnSetActive( void )
{
	//
	// Get info from the sheet.
	//

	m_bCreateNew = PwizThis()->BCreatingNewGroup();

	//
	// Save the current group name, if any, so that we have a local copy.
	// Get the existing group name first since that will be the name in the
	// list, not the current group name.  If we just get the current group
	// name, the user could have changed that by moving to the next page,
	// changing the current group name, then moving back.  The new name
	// entered would not be found in the list.
	//
	// NOTE:  This is only needed for the case where the caller of the wizard
	// passed in a group name.
	//
	if ( PwizThis()->PgiExistingGroup() != NULL )
	{
		m_strGroupName = PwizThis()->PgiExistingGroup()->RstrName();
	} // if:  an existing group has previously been selected
	else
	{
		m_strGroupName = PwizThis()->RgiCurrent().RstrName();
	} // else:  no existing group selected yet

	//
	// If no new group name is found, use the default value.
	//
	if ( m_strGroupName.GetLength() == 0 )
	{
		if (   (PcawData() != NULL)
			&& (PcawData()->pszVirtualServerName != NULL) )
		{
			m_strGroupName = PcawData()->pszVirtualServerName;
		} // if: default data and value specified
	} // if:  group name is still empty

	//
	// Fill the list of groups.
	//
	FillComboBox();

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageVSGroup::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		BOOL bChecked = (m_rbCreateNew.GetCheck() == BST_CHECKED);
		m_bCreateNew = bChecked;
		if ( ! bChecked )
		{
			//
			// Save the combobox selection.
			//
			DDX_GetText( m_hWnd, IDC_VSG_GROUPS, m_strGroupName );

			if ( ! BBackPressed() )
			{
				if ( ! DDV_RequiredText( m_hWnd, IDC_VSG_GROUPS, IDC_VSG_GROUPS_LABEL, m_strGroupName ) )
				{
					return FALSE;
				} // if:  no group specified
			} // if:  Back button not presssed

			//
			// Get the group object for the selected group.
			//
			int idx = m_cboxGroups.GetCurSel();
			ASSERT( idx != CB_ERR );
			m_pgi = reinterpret_cast< CClusGroupInfo * >( m_cboxGroups.GetItemDataPtr( idx ) );
		} // if:  using an existing group
	} // if: saving data from the page
	else
	{
		if ( m_bCreateNew )
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_CHECKED );
			m_rbUseExisting.SetCheck( BST_UNCHECKED );

		} // if:  creating new group
		else
		{
			//
			// Default the radio button selection.
			//
			m_rbCreateNew.SetCheck( BST_UNCHECKED );
			m_rbUseExisting.SetCheck( BST_CHECKED );
		} // else:  using existing group

		//
		// Set the combobox selection.  If the selection is not
		// found, select the first entry.
		//
		if (   (m_strGroupName.GetLength() == 0)
			|| ! DDX_SetComboBoxText( m_hWnd, IDC_VSG_GROUPS, m_strGroupName, FALSE /*bRequired*/ ) )
		{
			m_cboxGroups.SetCurSel( 0 );
		} // if:  combobox selection not set

		//
		// Enable/disable the combobox.
		//
		m_cboxGroups.EnableWindow( ! m_bCreateNew /*bEnable*/ );

	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageVSGroup::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroup::BApplyChanges( void )
{
	//
	// Save the current state.
	//
	if ( ! PwizThis()->BSetCreatingNewGroup( m_bCreateNew, m_pgi ) )
	{
		return FALSE;
	} // if:  error setting new state

	return TRUE;

} //*** CWizPageVSGroup::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroup::FillComboBox
//
//	Routine Description:
//		Fill the combobox with a list of groups that are not virtual servers.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CWizPageVSGroup::FillComboBox( void )
{
	CWaitCursor wc;

	//
	// Clear the combobox first.
	//
	m_cboxGroups.ResetContent();

	//
	// For each group in the cluster, find out if it is a virtual server
	// or not.  If not then add it to the combobox.
	//

	CClusGroupPtrList::iterator itgrp;
	int idx;
	for ( itgrp = PwizThis()->PlpgiGroups()->begin()
		; itgrp != PwizThis()->PlpgiGroups()->end()
		; itgrp++ )
	{
		//
		// If this is not a virtual server, add it to the list.
		// Save a pointer to the group info object with the string
		// so we can retrieve it with the selection later.
		//
		CClusGroupInfo * pgi = *itgrp;
		ASSERT( pgi->BQueried() );
		if ( ! pgi->BIsVirtualServer() )
		{
			idx = m_cboxGroups.AddString( pgi->RstrName() );
			ASSERT( idx != CB_ERR );
			m_cboxGroups.SetItemDataPtr( idx, (void *) pgi );
		} // if:  not virtual server
	} // for:  each entry in the list

	//
	// Select the currently saved entry, or the first one if none are
	// currently saved.
	//
//	UpdateData( FALSE /*bSaveAndValidate*/ );

//	if ( m_strGroupName.GetLength() == 0 )
//	{
//		m_cboxGroups.SetCurSel( 0 );
//	} // if:  no group name specified
//	else
//	{
//		int idx = m_cboxGroups.FindStringExact( -1, m_strGroupName );
//		ASSERT( idx != CB_ERR );
//		if ( idx != CB_ERR )
//		{
//			m_cboxGroups.SetCurSel( idx );
//		} // if:  group found in list
//	} // else:  virtual server saved

} //*** CWizPageVSGroup::FillComboBox()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\welcome.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Welcome.cpp
//
//  Abstract:
//      Implementation of the CWizPageWelcome class.
//
//  Author:
//      David Potter (davidp)   December 4, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Welcome.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageWelcome
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageWelcome )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_TITLE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_SUBTITLE )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP1 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2 )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2A )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2B )
    DEFINE_CTRL_NAME_MAP_ENTRY( IDC_WIZARD_STEP2C )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizPageWelcome::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus still needs to be set.
//      FALSE       Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageWelcome::OnInitDialog( void )
{
    // Set the system menu so the context help "?" can be seen
    LONG mStyle = ::GetWindowLong( GetParent( ), GWL_STYLE );
    mStyle |= WS_SYSMENU;
    ::SetWindowLong( GetParent( ), GWL_STYLE, mStyle );

    //
    // Attach controls to control member variables.
    //
    AttachControl( m_staticTitle, IDC_WIZARD_TITLE );

    //
    // Set the font of the control.
    //
    m_staticTitle.SetFont( PwizThis()->RfontExteriorTitle() );

    return TRUE;

} //*** CWizPageWelcome::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsgrpname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGrpName.cpp
//
//	Abstract:
//		Implementation of the CWizPageVSGroupName class.
//
//	Author:
//		David Potter (davidp)	December 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VSGrpName.h"
#include "ClusAppWiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroupName
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Control name map

BEGIN_CTRL_NAME_MAP( CWizPageVSGroupName )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_NAME )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC_TITLE )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC_LABEL )
	DEFINE_CTRL_NAME_MAP_ENTRY( IDC_VSGN_GROUP_DESC )
END_CTRL_NAME_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus still needs to be set.
//		FALSE		Focus does not need to be set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::OnInitDialog( void )
{
	//
	// Attach the controls to control member variables.
	//
	AttachControl( m_editGroupName, IDC_VSGN_GROUP_NAME );
	AttachControl( m_editGroupDesc, IDC_VSGN_GROUP_DESC );

	return TRUE;

} //*** CWizPageVSGroupName::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnSetActive
//
//	Routine Description:
//		Handler for PSN_SETACTIVE.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Page activated successfully.
//		FALSE		Error activating page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::OnSetActive( void )
{
	//
	// Get info from the sheet.
	// This is done here because it is also affected by pages displayed
	// before this one, and the user could press the Back button to change it.
	//
	m_strGroupName = PwizThis()->RgiCurrent().RstrName();
	m_strGroupDesc = PwizThis()->RgiCurrent().RstrDescription();

	if ( m_strGroupName.GetLength() == 0 )
	{
		if (   (PcawData() != NULL)
			&& (PcawData()->pszVirtualServerName != NULL) )
		{
			m_strGroupName = PcawData()->pszVirtualServerName;
		} // if: default data and value specified
	} // if:  no group name specified

	//
	// Call the base class and return.
	//
	return baseClass::OnSetActive();

} //*** CWizPageVSGroupName::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::UpdateData
//
//	Routine Description:
//		Update data on or from the page.
//
//	Arguments:
//		bSaveAndValidate	[IN] TRUE if need to read data from the page.
//								FALSE if need to set data to the page.
//
//	Return Value:
//		TRUE		The data was updated successfully.
//		FALSE		An error occurred updating the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::UpdateData( IN BOOL bSaveAndValidate )
{
	BOOL	bSuccess = TRUE;

	if ( bSaveAndValidate )
	{
		DDX_GetText( m_hWnd, IDC_VSGN_GROUP_NAME, m_strGroupName );
		DDX_GetText( m_hWnd, IDC_VSGN_GROUP_DESC, m_strGroupDesc );

		if ( ! BBackPressed() )
		{
			if ( ! DDV_RequiredText( m_hWnd, IDC_VSGN_GROUP_NAME, IDC_VSGN_GROUP_NAME_LABEL, m_strGroupName ) )
			{
				return FALSE;
			} // if:  group name not specified
		} // if:  Back button not presssed
	} // if: saving data from the page
	else
	{
		m_editGroupName.SetWindowText( m_strGroupName );
		m_editGroupDesc.SetWindowText( m_strGroupDesc );
	} // else:  setting data to the page

	return bSuccess;

} //*** CWizPageVSGroupName::UpdateData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::OnWizardBack
//
//	Routine Description:
//		Handler for PSN_WIZBACK.
//
//	Arguments:
//		None.
//
//	Return Value:
//		0				Move to previous page.
//		-1				Don't move to previous page.
//		anything else	Move to specified page.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CWizPageVSGroupName::OnWizardBack( void )
{
	int nResult;

	//
	// Call the base class.  This causes our UpdateData() method to get
	// called.  If it succeeds, save our values.
	//
	nResult = baseClass::OnWizardBack();
	if ( nResult != -1 ) // -1 means failure
	{
		if ( ! PwizThis()->BSetGroupName( m_strGroupName ) )
		{
			return FALSE;
		} // if:  error setting the group name
		if ( m_strGroupDesc != PwizThis()->RgiCurrent().RstrDescription() )
		{
			if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
			{
				return FALSE;
			} // if:  error resetting the cluster
			PwizThis()->RgiCurrent().SetDescription( m_strGroupDesc );
			PwizThis()->SetVSDataChanged();
		} // if:  group description changed
	} // if:  base class called successfully

	return nResult;

} //*** CWizPageVSGroupName::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CWizPageVSGroupName::BApplyChanges
//
//	Routine Description:
//		Apply changes made on this page to the sheet.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		The data was applied successfully.
//		FALSE		An error occurred applying the data.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizPageVSGroupName::BApplyChanges( void )
{
	//
	// If creating a new group or giving a new name to an existing group,
	// make sure this group name isn't already in use.
	//
	if (   PwizThis()->BCreatingNewGroup()
		|| (m_strGroupName != PwizThis()->PgiExistingGroup()->RstrName()) )
	{
		if ( BGroupNameInUse() )
		{
			CString strMsg;
			strMsg.FormatMessage( IDS_ERROR_GROUP_NAME_IN_USE, m_strGroupName );
			AppMessageBox( m_hWnd, strMsg, MB_OK | MB_ICONEXCLAMATION );
			return FALSE;
		} // if:  group name is already in use
	} // if:  creating new group or changing name of existing group


	//
	// Save the info in the wizard object.
	//
	if ( m_strGroupName != PwizThis()->RgiCurrent().RstrName() )
	{
		if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
		{
			return FALSE;
		} // if:  error resetting the cluster

		if ( ! PwizThis()->BSetGroupName( m_strGroupName ) )
		{
			return FALSE;
		} // if:  error setting the group name
	} // if: name changed

	if ( m_strGroupDesc != PwizThis()->RgiCurrent().RstrDescription() )
	{
		if ( PwizThis()->BClusterUpdated() && ! PwizThis()->BResetCluster() )
		{
			return FALSE;
		} // if:  error resetting the cluster

		PwizThis()->RgiCurrent().SetDescription( m_strGroupDesc );
		PwizThis()->SetVSDataChanged();
	} // if:  description changed

	return TRUE;

} //*** CWizPageVSGroupName::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\welcome.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		Welcome.h
//
//	Abstract:
//		Definition of the CWizPageWelcome class.
//
//	Implementation File:
//		Welcome.cpp
//
//	Author:
//		David Potter (davidp)	December 2, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WELCOME_H_
#define __WELCOME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageWelcome;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageWelcome
/////////////////////////////////////////////////////////////////////////////

class CWizPageWelcome : public CClusterAppStaticWizardPage< CWizPageWelcome >
{
	typedef CClusterAppStaticWizardPage< CWizPageWelcome > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageWelcome(void)
	{
	} //*** CWizPageWelcome()

	WIZARDPAGE_HEADERTITLEID( 0 )
	WIZARDPAGE_HEADERSUBTITLEID( 0 )

	enum { IDD = IDD_WELCOME };

public:
	//
	// CWizardPageWindow public methods.
	//

public:
	//
	// CBasePage public methods.
	//

public:
	//
	// Message map.
	//
//	BEGIN_MSG_MAP( CWizPageWelcome )
//		CHAIN_MSG_MAP( baseClass )
//	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

// Implementation
protected:
	//
	// Controls.
	//
	CStatic		m_staticTitle;

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_WELCOME; }

}; //*** class CWizPageWelcome

/////////////////////////////////////////////////////////////////////////////

#endif // __WELCOME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsgroup.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      VSGroup.h
//
//  Abstract:
//      Definition of the CWizPageVSGroup class.
//
//  Implementation File:
//      VSGroup.cpp
//
//  Author:
//      David Potter (davidp)   December 5, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSGROUP_H_
#define __VSGROUP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroup;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusGroupInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h" // for CClusterAppStaticWizardPage
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"       // for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroup
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroup : public CClusterAppStaticWizardPage< CWizPageVSGroup >
{
    typedef CClusterAppStaticWizardPage< CWizPageVSGroup > baseClass;
public:
    //
    // Construction
    //

    // Standard constructor
    CWizPageVSGroup( void )
        : m_bCreateNew( TRUE )
        , m_pgi( NULL )
    {
    } //*** CCWizPageVSGroup()

    WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSG )
    WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSG )

    enum { IDD = IDD_VIRTUAL_SERVER_GROUP };

public:
    //
    // CWizardPageWindow public methods.
    //

    // Apply changes made on this page to the sheet
    BOOL BApplyChanges( void );

public:
    //
    // CBasePage public methods.
    //

    // Update data on or from the page
    BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
    //
    // Message map.
    //
    BEGIN_MSG_MAP( CWizPageVSGroup )
        COMMAND_HANDLER( IDC_VSG_CREATE_NEW, BN_CLICKED, OnRadioButtonsChanged )
        COMMAND_HANDLER( IDC_VSG_USE_EXISTING, BN_CLICKED, OnRadioButtonsChanged )
        CHAIN_MSG_MAP( baseClass )
    END_MSG_MAP()

    DECLARE_CTRL_NAME_MAP()

    //
    // Message handler functions.
    //

    // Handler for the BN_CLICKED command notification on IDC_VSG_CREATE_NEW and IDC_VSG_USE_EXISTING
    LRESULT OnRadioButtonsChanged(
        WORD wNotifyCode,
        int idCtrl,
        HWND hwndCtrl,
        BOOL & bHandled
        )
    {
        UNREFERENCED_PARAMETER( wNotifyCode );
        UNREFERENCED_PARAMETER( idCtrl );
        UNREFERENCED_PARAMETER( hwndCtrl );
        UNREFERENCED_PARAMETER( bHandled );

        BOOL bEnable = (m_rbCreateNew.GetCheck() != BST_CHECKED);
        m_cboxGroups.EnableWindow( bEnable );
        return 0;

    } //*** OnRadioButtonsChanged()

    //
    // Message handler overrides.
    //

    // Handler for the WM_INITDIALOG message
    BOOL OnInitDialog( void );

    // Handler for PSN_SETACTIVE
    BOOL OnSetActive( void );

// Implementation
protected:
    //
    // Controls.
    //
    CButton         m_rbCreateNew;
    CButton         m_rbUseExisting;
    CComboBox       m_cboxGroups;

    //
    // Page state.
    //
    BOOL                m_bCreateNew;
    CString             m_strGroupName;
    CClusGroupInfo *    m_pgi;

    // Fill the combobox with a list of groups that are not virtual servers
    void FillComboBox( void );

public:

    // Return the help ID map
    static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP; }

}; //*** class CWizPageVSGroup

/////////////////////////////////////////////////////////////////////////////

#endif // __VSGROUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\wizobject.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WizObject.h
//
//	Abstract:
//		Definition of the CClusAppWizardObject class.
//
//	Implementation File:
//		WizObject.cpp
//
//	Author:
//		David Potter (davidp)	November 26, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WIZOBJECT_H_
#define __WIZOBJECT_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusAppWizardObject;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"       // main symbols
#define __RESOURCE_H_
#endif

/////////////////////////////////////////////////////////////////////////////
// class CClusAppWizardObject
/////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CClusAppWizardObject : 
	public CComObjectRootEx< CComSingleThreadModel >,
	public CComCoClass< CClusAppWizardObject, &CLSID_ClusAppWiz >,
	public ISupportErrorInfo,
	public IClusterApplicationWizard
{
public:
	//
	// Object construction and destruction.
	//

	CClusAppWizardObject( void )
	{
	}

	DECLARE_NOT_AGGREGATABLE( CClusAppWizardObject )

	//
	// Map interfaces to this class.
	//
	BEGIN_COM_MAP( CClusAppWizardObject )
		COM_INTERFACE_ENTRY( IClusterApplicationWizard )
		COM_INTERFACE_ENTRY( ISupportErrorInfo )
	END_COM_MAP()

	// Update the registry for object registration
	static HRESULT WINAPI UpdateRegistry( BOOL bRegister );

public:
	//
	// IClusterApplicationWizard methods.
	//

	// Display a modal wizard
	STDMETHOD( DoModalWizard )(
		HWND					IN hwndParent,
		ULONG_PTR  /*HCLUSTER*/	IN hCluster,
		CLUSAPPWIZDATA const *	IN pcawData
		);

	// Display a modeless wizard
	STDMETHOD( DoModelessWizard )(
		HWND					IN hwndParent,
		ULONG_PTR  /*HCLUSTER*/	IN hCluster,
		CLUSAPPWIZDATA const *	IN pcawData
		);

public:
	//
	// ISupportsErrorInfo methods.
	//

	// Determine if interface supports IErrorInfo
	STDMETHOD( InterfaceSupportsErrorInfo )( REFIID riid );

}; //*** class CClusAppWizardObject

/////////////////////////////////////////////////////////////////////////////

#endif //__ACWIZOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\wizobject.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      WizObject.cpp
//
//  Abstract:
//      Implementation of the CClusAppWizardObject class.
//
//  Author:
//      David Potter (davidp)   November 26, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WizObject.h"
#include "ClusAppWiz.h"
#include "AdmCommonRes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static BOOL g_bInitializedCommonControls = FALSE;
static INITCOMMONCONTROLSEX g_icce =
{
    sizeof( g_icce ),
    ICC_WIN95_CLASSES | ICC_INTERNET_CLASSES
};

/////////////////////////////////////////////////////////////////////////////
// class CClusAppWizardObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::UpdateRegistry
//
//  Routine Description:
//      Update the registry for this object.
//
//  Arguments:
//      bRegister   TRUE = register, FALSE = unregister.
//
//  Return Value:
//      Any return values from _Module.UpdateRegistryFromResource.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CClusAppWizardObject::UpdateRegistry( BOOL bRegister )
{
    static WCHAR oszClassDisplayName[1024] = { 0 };
    static _ATL_REGMAP_ENTRY rgRegMap[] =
    {
        { OLESTR("ClassDisplayName"), oszClassDisplayName },
        { NULL, NULL }
    };

    //
    // Load replacement values.
    //
    if ( oszClassDisplayName[0] == OLESTR('\0') )
    {
        CString str;
        HRESULT hr;

        str.LoadString( IDS_CLASS_DISPLAY_NAME );
        hr = StringCchCopyNW( oszClassDisplayName, RTL_NUMBER_OF( oszClassDisplayName ), str, str.GetLength() );
        ASSERT( ! FAILED( hr ) );
    } // if:  replacement values not loaded yet

    return _Module.UpdateRegistryFromResource( IDR_CLUSAPPWIZ, bRegister, rgRegMap );

} //*** CClusAppWizardObject::UpdateRegistry()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::DoModalWizard [IClusterApplicationWizard]
//
//  Routine Description:
//      Display a modal wizard.
//
//  Arguments:
//      hwndParent      [IN] Parent window.
//      hCluster        [IN] Cluster in which to configure the application.
//      pDefaultData    [IN] Default data for the wizard.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::DoModalWizard(
    HWND                    IN hwndParent,
    ULONG_PTR  /*HCLUSTER*/ IN hCluster,
    CLUSAPPWIZDATA const *  IN pcawData
    )
{
    HRESULT             hr = S_FALSE;
    BOOL                bSuccess;
    INT_PTR             id;
    CClusterAppWizard   wiz;
    CNTException        nte(
                            ERROR_SUCCESS,  // sc
                            0,              // idsOperation
                            NULL,           // pszOperArg1
                            NULL,           // pszOperArg2
                            FALSE           // bAutoDelete
                            );

    //
    // Cluster handle must be valid.
    //
    ASSERT( hCluster != NULL );
    ASSERT( (pcawData == NULL) || (pcawData->nStructSize == sizeof(CLUSAPPWIZDATA)) );
    if (   (hCluster == NULL )
        || ((pcawData != NULL) && (pcawData->nStructSize != sizeof(CLUSAPPWIZDATA))) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:  no cluster handle specified or data not the right size

    //
    // Prepare the wizard.
    //
    bSuccess = wiz.BInit(
                    hwndParent,
                    reinterpret_cast< HCLUSTER >( hCluster ),
                    pcawData,
                    &nte
                    );
    if ( ! bSuccess )
    {
        goto Cleanup;
    } // if:  error initializing the wizard

    //
    // Initialize common controls.
    //
    if ( ! g_bInitializedCommonControls )
    {
        bSuccess = InitCommonControlsEx( &g_icce );
        ASSERT( bSuccess );
        g_bInitializedCommonControls = TRUE;
    } // if:  common controls not initialized yet

    //
    // Display the wizard.
    //
    id = wiz.DoModal( hwndParent );
    if ( id != ID_WIZFINISH )
    {
    }

    hr = S_OK;

Cleanup:
    if ( nte.Sc() != ERROR_SUCCESS )
    {
        nte.ReportError( hwndParent, MB_OK | MB_ICONEXCLAMATION );
    } // if: error occurred
    nte.Delete();
    return hr;

} //*** CClusAppWizardObject::DoModalWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::DoModlessWizard [IClusterApplicationWizard]
//
//  Routine Description:
//      Display a modless wizard.
//
//  Arguments:
//      hwndParent  [IN] Parent window.
//      hCluster    [IN] Cluster in which to configure the application.
//      pcawData    [IN] Default data for the wizard.
//
//  Return Value:
//      HRESULT
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::DoModelessWizard(
    HWND                    IN hwndParent,
    ULONG_PTR /*HCLUSTER*/  IN hCluster,
    CLUSAPPWIZDATA const *  IN pcawData
    )
{
    HRESULT             hr = S_FALSE;
    BOOL                bSuccess;
    CClusterAppWizard   wiz;
    CNTException        nte(
                            ERROR_SUCCESS,  // sc
                            0,              // idsOperation
                            NULL,           // pszOperArg1
                            NULL,           // pszOperArg2
                            FALSE           // bAutoDelete
                            );

    return E_NOTIMPL;

    //
    // Cluster handle must be valid.
    //
    ASSERT( hCluster != NULL );
    ASSERT( (pcawData == NULL) || (pcawData->nStructSize == sizeof(CLUSAPPWIZDATA)) );
    if (   (hCluster == NULL )
        || ((pcawData != NULL) && (pcawData->nStructSize != sizeof(CLUSAPPWIZDATA))) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    } // if:  no cluster handle specified or data not the right size

    //
    // Prepare the wizard.
    //
    bSuccess = wiz.BInit(
                    hwndParent,
                    reinterpret_cast< HCLUSTER >( hCluster ),
                    pcawData,
                    &nte
                    );
    if ( ! bSuccess )
    {
        goto Cleanup;
    } // if:  error initializing the wizard

    //
    // Initialize common controls.
    //
    if ( ! g_bInitializedCommonControls )
    {
        bSuccess = InitCommonControlsEx( &g_icce );
        ASSERT( bSuccess );
        g_bInitializedCommonControls = TRUE;
    } // if:  common controls not initialized yet

    hr = S_FALSE; // TODO:  Need to implement this still

Cleanup:
    return hr;

} //*** CClusAppWizardObject::DoModlessWizard()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusAppWizardObject::InterfaceSupportsErrorInfo [ISupportsErrorInfo]
//
//  Routine Description:
//      Indicates whether the interface identified by riid supports the
//      IErrorInfo interface.
//
//  Arguments:
//      riid        [IN] Interface to check.
//
//  Return Value:
//      S_OK        Specified interface supports the IErrorInfo interface.
//      S_FALSE     Specified interface does not support the IErrorInfo interface.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusAppWizardObject::InterfaceSupportsErrorInfo( REFIID riid )
{
    static const IID * arr[] = 
    {
        &IID_IClusterApplicationWizard,
    };
    for ( int idx = 0 ; idx < sizeof( arr ) / sizeof( arr[0] ) ; idx++ )
    {
        if ( InlineIsEqualGUID( *arr[idx], riid ) )
        {
            return S_OK;
        } // if:  found the GUID
    } // for:  each IID

    return S_FALSE;

}  //*** CClusAppWizardObject::InterfaceSupportsErrorInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\vsgrpname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		VSGrpName.h
//
//	Abstract:
//		Definition of the CWizPageVSGroupName class.
//
//	Implementation File:
//		VSGrpName.cpp
//
//	Author:
//		David Potter (davidp)	December 9, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __VSGRPNAME_H_
#define __VSGRPNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroupName;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __RESOURCE_H_
#include "resource.h"
#define __RESOURCE_H_
#endif

#ifndef __CLUSAPPWIZPAGE_H_
#include "ClusAppWizPage.h"	// for CClusterAppStaticWizardPage
#endif

#ifndef __CLUSAPPWIZ_H_
#include "ClusAppWiz.h"		// for using CClusterAppWizard
#endif

#ifndef __HELPDATA_H_
#include "HelpData.h"		// for control id to help context id mapping array
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CWizPageVSGroupName
/////////////////////////////////////////////////////////////////////////////

class CWizPageVSGroupName : public CClusterAppStaticWizardPage< CWizPageVSGroupName >
{
	typedef CClusterAppStaticWizardPage< CWizPageVSGroupName > baseClass;

public:
	//
	// Construction
	//

	// Standard constructor
	CWizPageVSGroupName( void )
	{
	} //*** CCWizPageVSGroupName()

	WIZARDPAGE_HEADERTITLEID( IDS_HDR_TITLE_VSGN )
	WIZARDPAGE_HEADERSUBTITLEID( IDS_HDR_SUBTITLE_VSGN )

	enum { IDD = IDD_VIRTUAL_SERVER_GROUP_NAME };

public:
	//
	// CWizardPageWindow public methods.
	//

	// Apply changes made on this page to the sheet
	BOOL BApplyChanges( void );

public:
	//
	// CBasePage public methods.
	//

	// Update data on or from the page
	BOOL UpdateData( IN BOOL bSaveAndValidate );

public:
	//
	// Message map.
	//
	BEGIN_MSG_MAP( CWizPageVSGroupName )
		COMMAND_HANDLER( IDC_VSGN_GROUP_NAME, EN_CHANGE, OnGroupNameChanged )
		CHAIN_MSG_MAP( baseClass )
	END_MSG_MAP()

	DECLARE_CTRL_NAME_MAP()

	//
	// Message handler functions.
	//

	// Handler for the EN_CHANGE command notification on IDC_VSGN_GROUP_NAME
	LRESULT OnGroupNameChanged(
		WORD /*wNotifyCode*/,
		WORD /*idCtrl*/,
		HWND /*hwndCtrl*/,
		BOOL & /*bHandled*/
		)
	{
		BOOL bEnable = ( m_editGroupName.GetWindowTextLength() > 0 );
		EnableNext( bEnable );
		return 0;

	} //*** OnGroupNameChanged()

	//
	// Message handler overrides.
	//

	// Handler for the WM_INITDIALOG message
	BOOL OnInitDialog( void );

	// Handler for PSN_SETACTIVE
	BOOL OnSetActive( void );

	// Handler for PSN_WIZBACK
	int OnWizardBack( void );

// Implementation
protected:
	//
	// Controls.
	//
	CEdit		m_editGroupName;
	CEdit		m_editGroupDesc;

	//
	// Page state.
	//
	CString		m_strGroupName;
	CString		m_strGroupDesc;

protected:
	//
	// Utility methods.
	//

	// Determine if the group name is already in use
	BOOL BGroupNameInUse( void )
	{
		return ( PwizThis()->PgiFindGroupNoCase( m_strGroupName ) != NULL );

	} //*** BGroupNameInUse()

public:

	// Return the help ID map
	static const DWORD * PidHelpMap( void ) { return g_aHelpIDs_IDD_VIRTUAL_SERVER_GROUP_NAME; }

}; //*** class CWizPageVSGroupName

/////////////////////////////////////////////////////////////////////////////

#endif // __VSGRPNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\types\idl\makefile.inc ===
CopyTLB : CLADMWIZ_TLB

CLADMWIZ_TLB : $(O)\ClAdmWiz.tlb
    -mkdir ..\..\src\$(O)
    copy $** ..\..\src\$(O)\ClAdmWiz.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\aclbase.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      AclBase.cpp
//
//  Description:
//      Implementation of the ISecurityInformation interface.  This interface
//      is the new common security UI in NT 5.0.
//
//  Author:
//      Galen Barbee    (galenb)    February 6, 1998
//          From \nt\private\admin\snapin\filemgmt\permpage.cpp
//          by JonN
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <NTSecApi.h>
#include "AclBase.h"
#include "AclUtils.h"
#include "resource.h"
#include <DsGetDC.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include "CluAdmx.h"

/////////////////////////////////////////////////////////////////////////////
// CSecurityInformation
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::CSecurityInformation
//
//  Routine Description:
//      ctor
//
//  Arguments:
//      none.
//
//  Return Value:
//      none.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSecurityInformation::CSecurityInformation(
    void
    ) : m_pShareMap( NULL ), m_dwFlags( 0 ), m_nDefAccess( 0 ), m_psiAccess( NULL ), m_pObjectPicker( NULL ), m_cRef( 1 )
{
    m_nLocalSIDErrorMessageID = 0;

}  //*** CSecurityInformation::CSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::~CSecurityInformation
//
//  Routine Description:
//      dtor
//
//  Arguments:
//      none.
//
//  Return Value:
//      none.
//
//--
/////////////////////////////////////////////////////////////////////////////
CSecurityInformation::~CSecurityInformation(
    void
    )
{
    if ( m_pObjectPicker != NULL )
    {
        m_pObjectPicker->Release();
        m_pObjectPicker = NULL;
    } // if:

}  //*** CSecurityInformation::CSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::MapGeneric
//
//  Routine Description:
//      Maps specific rights to generic rights
//
//  Arguments:
//      pguidObjectType [IN]
//      pAceFlags       [IN]
//      pMask           [OUT]
//
//  Return Value:
//      S_OK
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::MapGeneric(
    IN  const GUID *,   //pguidObjectType,
    IN  UCHAR *,        //pAceFlags,
    OUT ACCESS_MASK *pMask
   )
{
    ASSERT( pMask != NULL );
    ASSERT( m_pShareMap != NULL );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    ::MapGenericMask( pMask, m_pShareMap );

    return S_OK;

}  //*** CSecurityInformation::MapGeneric()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetInheritTypes
//
//  Routine Description:
//
//
//  Arguments:
//      None.
//
//  Return Value:
//      E_NOTIMPL
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetInheritTypes(
    PSI_INHERIT_TYPE    *,  //ppInheritTypes,
    ULONG               *   //pcInheritTypes
    )
{
    ASSERT( FALSE );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return E_NOTIMPL;

}  //*** CSecurityInformation::GetInheritTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::PropertySheetPageCallback
//
//  Routine Description:
//      This method is called by the ACL editor when something interesting
//      happens.
//
//  Arguments:
//      hwnd    [IN]    ACL editor window (currently NULL)
//      uMsg    [IN]    reason for call back
//      uPage   [IN]    kind of page we are dealing with
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::PropertySheetPageCallback(
    IN  HWND            hwnd,
    IN  UINT            uMsg,
    IN  SI_PAGE_TYPE    uPage
    )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    return S_OK;

}  //*** CSecurityInformation::PropertySheetPageCallback()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetObjectInformation
//
//  Routine Description:
//
//
//  Arguments:
//    pObjectInfo   [IN OUT]
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetObjectInformation(
    IN OUT PSI_OBJECT_INFO pObjectInfo
    )
{
    ASSERT( pObjectInfo != NULL && !IsBadWritePtr( pObjectInfo, sizeof( *pObjectInfo ) ) );
    ASSERT( !m_strServer.IsEmpty() );
    ASSERT( m_dwFlags != 0 );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    pObjectInfo->dwFlags = m_dwFlags;                   // SI_EDIT_PERMS | SI_NO_ACL_PROTECT;
    pObjectInfo->hInstance = AfxGetInstanceHandle();
    pObjectInfo->pszServerName = (LPTSTR)(LPCTSTR) m_strServer;
//  pObjectInfo->pszObjectName =
/*
    pObjectInfo->dwUgopServer =     UGOP_BUILTIN_GROUPS
                                //| UGOP_USERS
                                //| UGOP_COMPUTERS
                                //| UGOP_WELL_KNOWN_PRINCIPALS_USERS
                                //| UGOP_GLOBAL_GROUPS
                                //| UGOP_USER_WORLD
                                //| UGOP_USER_AUTHENTICATED_USER
                                //| UGOP_USER_ANONYMOUS
                                //| UGOP_USER_DIALUP
                                //| UGOP_USER_NETWORK
                                //| UGOP_USER_BATCH
                                //| UGOP_USER_INTERACTIVE
                                  | UGOP_USER_SERVICE
                                  | UGOP_USER_SYSTEM
                                  | UGOP_LOCAL_GROUPS
                                //| UGOP_UNIVERSAL_GROUPS
                                //| UGOP_UNIVERSAL_GROUPS_SE
                                //| UGOP_ACCOUNT_GROUPS
                                //| UGOP_ACCOUNT_GROUPS_SE
                                //| UGOP_RESOURCE_GROUPS
                                //| UGOP_RESOURCE_GROUPS_SE
                                ;

    pObjectInfo->dwUgopOther  = ( NT5_UGOP_FLAGS | NT4_UGOP_FLAGS ) &~ UGOP_COMPUTERS;
*/
    return S_OK;

}  //*** CSecurityInformation::GetObjectInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::SetSecurity
//
//  Routine Description:
//      ISecurityInformation is giving back the edited security descriptor
//      and we need to validate it.  A valid SD is one that doesn't contain
//      any local SIDs.
//
//  Arguments:
//      SecurityInformation [IN]
//      pSecurityDescriptor [IN OUT]
//
//  Return Value:
//      E_FAIL for error and S_OK for success and S_FALSE for SD no good.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::SetSecurity(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    ASSERT( m_nLocalSIDErrorMessageID != 0 );

    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = S_OK;
    BOOL    bFound = FALSE;

    hr = HrLocalAccountsInSD( pSecurityDescriptor, &bFound );
    if ( SUCCEEDED( hr ) )
    {
        if ( bFound )
        {
            CString strMsg;

            strMsg.LoadString( m_nLocalSIDErrorMessageID );
            AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

            hr = S_FALSE;   // if there are local accounts then return S_FALSE to keep AclUi alive.
        }
    }
    else
    {
        CString strMsg;
        CString strMsgIdFmt;
        CString strMsgId;
        CString strErrorMsg;

        strMsg.LoadString( IDS_ERROR_VALIDATING_CLUSTER_SECURITY_DESCRIPTOR );

        FormatError( strErrorMsg, hr );

        strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
        strMsgId.Format( strMsgIdFmt, hr, hr);

        strMsg.Format( _T("%s\n\n%s%s"), strMsg, strErrorMsg, strMsgId );

        AfxMessageBox( strMsg );
        hr = S_FALSE;   // return S_FALSE to keep AclUi alive.
    }

    return hr;

}  //*** CSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::GetAccessRights
//
//  Routine Description:
//      Return the access rights that you want the user to be able to set.
//
//  Arguments:
//      pguidObjectType [IN]
//      dwFlags         [IN]
//      ppAccess        [OUT]
//      pcAccesses      [OUT]
//      piDefaultAccess [OUT]
//
//  Return Value:
//      S_OK.   Want to keep everything movin' along
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSecurityInformation::GetAccessRights(
    IN  const GUID *    pguidObjectType,
    IN  DWORD           dwFlags,
    OUT PSI_ACCESS *    ppAccess,
    OUT ULONG *         pcAccesses,
    OUT ULONG *         piDefaultAccess
    )
{
    ASSERT( ppAccess != NULL );
    ASSERT( pcAccesses != NULL );
    ASSERT( piDefaultAccess != NULL );
    ASSERT( m_psiAccess != NULL );
    ASSERT( m_nAccessElems > 0 );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    *ppAccess = m_psiAccess;
    *pcAccesses = m_nAccessElems;
    *piDefaultAccess = m_nDefAccess;

    return S_OK;

}  //*** CSecurityInformation::GetAccessRights()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::Initialize
//
//  Routine Description:
//      Initialize.
//
//  Arguments:
//      pInitInfo   [IN]    - Info to use for initialization.
//
//  Return Value:
//      S_OK if successful, or HRESULT error if not.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSecurityInformation::Initialize( IN PDSOP_INIT_INFO pInitInfo )
{
    HRESULT                 hr = S_OK;
    DSOP_INIT_INFO          InitInfo;
    PDSOP_SCOPE_INIT_INFO   pDSOPScopes = NULL;


    if ( m_pObjectPicker == NULL )
    {
        hr = CoCreateInstance( CLSID_DsObjectPicker,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IDsObjectPicker,
                               (LPVOID *) &m_pObjectPicker
                               );

    } // if:

    if ( SUCCEEDED( hr ) )
    {
        //
        // Make a local copy of the InitInfo so we can modify it safely
        //

        CopyMemory( &InitInfo, pInitInfo, min( pInitInfo->cbSize, sizeof( InitInfo ) ) );

        //
        // Make a local copy of g_aDSOPScopes so we can modify it safely.
        // Note also that m_pObjectPicker->Initialize returns HRESULTs
        // in this buffer.
        //

        pDSOPScopes = (PDSOP_SCOPE_INIT_INFO) ::LocalAlloc( LPTR, sizeof( g_aDefaultScopes ) );
        if (pDSOPScopes != NULL )
        {
            CopyMemory( pDSOPScopes, g_aDefaultScopes, sizeof( g_aDefaultScopes ) );

            //
            // Override the ACLUI default scopes, but don't touch
            // the other stuff.
            //

            // pDSOPScopes->pwzDcName = m_strServer;
            InitInfo.cDsScopeInfos = ARRAYSIZE( g_aDefaultScopes );
            InitInfo.aDsScopeInfos = pDSOPScopes;
            InitInfo.pwzTargetComputer = m_strServer;

            hr = m_pObjectPicker->Initialize( &InitInfo );

            ::LocalFree( pDSOPScopes );
        }
        else
        {
            hr = HRESULT_FROM_WIN32( ::GetLastError() );
        } // else:
    } // if:

    return hr;

} //*** CSecurityInformation::Initialize()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::InvokeDialog
//
//  Routine Description:
//      Forward the InvokeDialog call into the contained object.
//
//  Arguments:
//      hwndParent      [IN]
//      ppdoSelection   [IN]
//
//  Return Value:
//      E_POINTER if m_pObjectPicker is NULL, or the return from
//      m_pObjectPicker->InvokeDialog().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSecurityInformation::InvokeDialog(
    IN HWND             hwndParent,
    IN IDataObject **   ppdoSelection
    )
{
    HRESULT hr = E_POINTER;

    if ( m_pObjectPicker != NULL )
    {
        hr = m_pObjectPicker->InvokeDialog( hwndParent, ppdoSelection );
    } // if:

    return hr;

} //*** CSecurityInformation::InvokeDialog()

//
//  It seems that you cannot resolve the problem with multiple definitions
//  between ntstatus.h and winnt.h/windows.h.
//
//  The core issue is that STATUS_SUCCESS is defined n ntstatus.h and I have
//  been unable to figure the proper sequence of includes and defines that
//  will allow ntstatus.h to be included in an MFC app.
//

//#define WIN32_NO_STATUS
//#include <NTStatus.h>
//#undef WIN32_NO_STATUS

#define STATUS_SUCCESS  0L

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CSecurityInformation::BLocalAccountsInSD
//
//  Routine Description:
//  Determines if any ACEs for local accounts are in DACL stored in
//  Security Descriptor (pSD) after the ACL editor has been called
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//
//  Return Value:
//      TRUE if at least one ACE was removed from the DACL, False otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
CSecurityInformation::HrLocalAccountsInSD(
      PSECURITY_DESCRIPTOR  pSDIn
    , BOOL *                pfFoundLocalOut
    )
{
    HRESULT                     hr = S_OK;
    PACL                        paclDACL            = NULL;
    BOOL                        bHasDACL            = FALSE;
    BOOL                        bDaclDefaulted      = FALSE;
    BOOL                        bLocalAccountInACL  = FALSE;
    BOOL                        fRet                = FALSE;
    ACL_SIZE_INFORMATION        asiAclSize;
    DWORD                       idxAce = 0L;
    ACCESS_ALLOWED_ACE *        paaAce;
    DWORD                       sc = ERROR_SUCCESS;
    PSID                        pAdminSid = NULL;
    PSID                        pServiceSid = NULL;
    PSID                        pSystemSid = NULL;
    PSID                        pSID;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    PSID                        LocalMachineSid = NULL;
    NTSTATUS                    nts = ERROR_SUCCESS;
    LSA_OBJECT_ATTRIBUTES       lsaoa;
    LSA_UNICODE_STRING          lsausSystemName;
    LSA_HANDLE                  lsah = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO ppadi = NULL;
    BOOL                        fEqual;

    ASSERT( m_strServer.IsEmpty() == FALSE );

    ZeroMemory( &lsaoa, sizeof( lsaoa ) );

    fRet = IsValidSecurityDescriptor( pSDIn );
    if ( fRet == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Create the well known Administrators group SID.
    //

    if ( AllocateAndInitializeSid( &siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pAdminSid ) == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Create the well known Local System account SID.
    //

    if ( AllocateAndInitializeSid( &siaNtAuthority, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSystemSid ) == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Create the well known Local Service account SID.
    //

    if ( AllocateAndInitializeSid( &siaNtAuthority, 1, SECURITY_SERVICE_RID, 0, 0, 0, 0, 0, 0, 0, &pServiceSid ) == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the DACL from the passed in SD so that we can run down its ACEs...
    //

    fRet = GetSecurityDescriptorDacl( pSDIn, (LPBOOL) &bHasDACL, (PACL *) &paclDACL, (LPBOOL) &bDaclDefaulted );
    if ( fRet == FALSE )
    {
        goto MakeHr;
    } // if:

    ASSERT( paclDACL != NULL );

    fRet = IsValidAcl( paclDACL );
    if ( fRet == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Get the number of ACEs in the DACL.
    //

    fRet = GetAclInformation( paclDACL, &asiAclSize, sizeof( asiAclSize ), AclSizeInformation );
    if ( fRet == FALSE )
    {
        goto MakeHr;
    } // if:

    //
    //  Open the policy object for the cluster.  Meaning the node that is currently
    //  hosting the cluster name.
    //

    lsausSystemName.Buffer = const_cast< PWSTR >( static_cast< LPCTSTR >( m_strServer ) );
    lsausSystemName.Length = (USHORT)( m_strServer.GetLength() * sizeof( WCHAR ) );
    lsausSystemName.MaximumLength = lsausSystemName.Length;

    nts = LsaOpenPolicy( &lsausSystemName, &lsaoa, POLICY_ALL_ACCESS, &lsah );
    if ( nts != STATUS_SUCCESS )
    {
        sc = LsaNtStatusToWinError( nts );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    nts = LsaQueryInformationPolicy( lsah, PolicyAccountDomainInformation, (void **) &ppadi );
    if ( nts != STATUS_SUCCESS )
    {
        sc = LsaNtStatusToWinError( nts );
        hr = HRESULT_FROM_WIN32( sc );
        goto Cleanup;
    } // if:

    //
    //  Search the ACL for local account ACEs
    //

    for ( idxAce = 0; idxAce < asiAclSize.AceCount; idxAce++ )
    {
        if ( GetAce( paclDACL, idxAce, (LPVOID *) &paaAce ) == FALSE )
        {
            goto MakeHr;
        } // if:

        //
        //  Get the SID from the ACE.
        //

        pSID = &paaAce->SidStart;

        //
        //  The local machine SIDs for the administrators group, local system, and local service are allowed.
        //

        if ( EqualSid( pSID, pAdminSid ) )
        {
            continue;                       // allowed
        } // if: is this the local admin SID?
        else if ( EqualSid( pSID, pSystemSid ) )
        {
            continue;                       // allowed
        } // else if: is this the local system SID?
        else if ( EqualSid( pSID, pServiceSid ) )
        {
            continue;                       // allowed
        } // else if: is this the service SID?

        //
        //  If the domains of these SIDs are equal then the SID is a local machine SID and is not allowed.
        //

        if ( EqualDomainSid( pSID, ppadi->DomainSid, &fEqual ) )
        {
            if ( fEqual )
            {
                bLocalAccountInACL = TRUE;
                break;
            } // if:
        } // if:
    } // for:

    hr = S_OK;
    goto Cleanup;

MakeHr:

    sc = GetLastError();
    hr = HRESULT_FROM_WIN32( sc );
    goto Cleanup;

Cleanup:

    if ( ppadi != NULL )
    {
        LsaFreeMemory( ppadi );
    } // if:

    if ( lsah != NULL )
    {
        LsaClose( lsah );
    } // if:

    if ( pAdminSid != NULL )
    {
        FreeSid( pAdminSid );
    } // if:

    if ( pServiceSid != NULL )
    {
        FreeSid( pServiceSid );
    } // if:

    if ( pSystemSid != NULL )
    {
        FreeSid( pSystemSid );
    } // if:

    if ( pfFoundLocalOut != NULL )
    {
        *pfFoundLocalOut = bLocalAccountInACL;
    } // if:

    return hr;

}  //*** CSecurityInformation::HrBLocalAccountsInSD()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\wizthread.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		WizThread.h
//
//	Abstract:
//		Definition of the CWizardThread class.
//
//	Implementation File:
//		WizThread.cpp
//
//	Author:
//		David Potter (davidp)	December 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __WIZTHREAD_H_
#define __WIZTHREAD_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterThread;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAppWizard;
class CClusNodeInfo;
class CClusGroupInfo;
class CClusResInfo;
class CClusResTypeInfo;
class CClusNetworkInfo;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __WORKTHRD_H_
#include "WorkThrd.h"		// for CWorkerThread
#endif

#ifndef __CLUSOBJ_H_
#include "ClusObj.h"		// for CClusResPtrList, etc.
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

// Cluster thread function codes.
enum
{
	WZTF_READ_CLUSTER_INFO = WTF_USER,	// Read cluster information.
	WZTF_COLLECT_GROUPS,				// Collect groups in the cluster.
	WZTF_COLLECT_RESOURCES,				// Collect resources in the cluster.
	WZTF_COLLECT_RESOURCE_TYPES,		// Collect resource types in the cluster.
	WZTF_COLLECT_NETWORKS,				// Collect networks in the cluster.
	WZTF_COLLECT_NODES,					// Collect nodes in the cluster.
	WZTF_COPY_GROUP_INFO,				// Copy one group to another.
	WZTF_COLLECT_DEPENDENCIES,			// Collect dependencies for a resource.
	WZTF_CREATE_VIRTUAL_SERVER,			// Create a virtual server.
	WZTF_CREATE_APP_RESOURCE,			// Create the application resource.
	WZTF_DELETE_APP_RESOURCE,			// Delete the application resource.
	WZTF_RESET_CLUSTER,					// Reset the cluster.
	WZTF_SET_APPRES_ATTRIBUTES,			// Set properties, dependencies, owners of the application resource.

	WZTF_MAX
};

/////////////////////////////////////////////////////////////////////////////
// class CWizardThread
/////////////////////////////////////////////////////////////////////////////

class CWizardThread : public CWorkerThread
{
public:
	//
	// Construction and destruction.
	//

	// Default constructor
	CWizardThread( IN CClusterAppWizard * pwiz )
		: m_pwiz( pwiz )
	{
		ASSERT( pwiz != NULL );

	} //*** CWizardThread()

	// Destructor
	~CWizardThread( void )
	{
	} //*** ~CWizardThread()

	//
	// Accessor functions.
	//

protected:
	//
	// Properties.
	//

	CClusterAppWizard * m_pwiz;

	// Returns the wizard object
	CClusterAppWizard * Pwiz( void )
	{
		ASSERT( m_pwiz != NULL );
		return m_pwiz;

	} //*** Pwiz()

public:
	//
	// Function marshaler macros.
	//

#define WIZ_THREAD_FUNCTION_0( funcname, funccode ) \
	public: \
	BOOL funcname( HWND hwnd ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		return CallThreadFunction( hwnd, funccode, NULL, NULL );\
	} \
	protected: \
    BOOL _##funcname( void );
#define WIZ_THREAD_FUNCTION_1( funcname, funccode, p1type, p1 ) \
	public: \
	BOOL funcname( HWND hwnd, p1type p1 ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		ASSERT( p1 != NULL ); \
		return CallThreadFunction( hwnd, funccode, (PVOID) p1, NULL );\
	} \
	protected: \
    BOOL _##funcname( p1type p1 );
#define WIZ_THREAD_FUNCTION_2( funcname, funccode, p1type, p1, p2type, p2 ) \
	public: \
	BOOL funcname( HWND hwnd, p1type p1, p2type p2 ) \
	{ \
		ASSERT( GetCurrentThreadId() != m_idThread ); \
		ASSERT( p1 != NULL ); \
		ASSERT( p2 != NULL ); \
		return CallThreadFunction( hwnd, funccode, (PVOID) p1, (PVOID) p2 );\
	} \
	protected: \
    BOOL _##funcname( p1type p1, p2type p2 );

	//
	// Function marshaler functions.
	//
	WIZ_THREAD_FUNCTION_0( BReadClusterInfo,      WZTF_READ_CLUSTER_INFO )
	WIZ_THREAD_FUNCTION_0( BCollectResources,     WZTF_COLLECT_RESOURCES )
	WIZ_THREAD_FUNCTION_0( BCollectGroups,        WZTF_COLLECT_GROUPS )
	WIZ_THREAD_FUNCTION_0( BCollectResourceTypes, WZTF_COLLECT_RESOURCE_TYPES )
	WIZ_THREAD_FUNCTION_0( BCollectNetworks,      WZTF_COLLECT_NETWORKS )
	WIZ_THREAD_FUNCTION_0( BCollectNodes,         WZTF_COLLECT_NODES )
	WIZ_THREAD_FUNCTION_1( BCopyGroupInfo,        WZTF_COPY_GROUP_INFO,      CClusGroupInfo **, ppgi )
	WIZ_THREAD_FUNCTION_1( BCollectDependencies,  WZTF_COLLECT_DEPENDENCIES, CClusResInfo *, pri )
	WIZ_THREAD_FUNCTION_0( BCreateVirtualServer,  WZTF_CREATE_VIRTUAL_SERVER )
	WIZ_THREAD_FUNCTION_0( BCreateAppResource,    WZTF_CREATE_APP_RESOURCE )
	WIZ_THREAD_FUNCTION_0( BDeleteAppResource,    WZTF_DELETE_APP_RESOURCE )
	WIZ_THREAD_FUNCTION_0( BResetCluster,         WZTF_RESET_CLUSTER )
	WIZ_THREAD_FUNCTION_2( BSetAppResAttributes,  WZTF_SET_APPRES_ATTRIBUTES,
						   CClusResPtrList *,	  plpriOldDependencies,
						   CClusNodePtrList *,	  plpniOldPossibleOwners
						 )

protected:
	//
	// Thread worker functions.
	//

	// Thread function handler
	virtual DWORD ThreadFunctionHandler(
						LONG	nFunction,
						PVOID	pvParam1,
						PVOID	pvParam2
						);

	//
	// Helper functions.
	//

	// Cleanup objects
	virtual void Cleanup( void )
	{
		CWorkerThread::Cleanup();
	}

protected:
	//
	// Utility functions callable by thread function handlers.
	//

	// Query for information about a resource
	BOOL _BQueryResource( IN OUT CClusResInfo * pri );

	// Get resource properties
	BOOL _BGetResourceProps( IN OUT CClusResInfo * pri );

	// Get possible owners for a resource
	BOOL _BGetPossibleOwners( IN OUT CClusResInfo * pri );

	// Get dependencies for a resource
	BOOL _BGetDependencies( IN OUT CClusResInfo * pri );

	// Query for information about a group
	BOOL _BQueryGroup( IN OUT CClusGroupInfo * pgi );

	// Get group properties
	BOOL _BGetGroupProps( IN OUT CClusGroupInfo * pgi );

	// Get resources in a group
	BOOL _BGetResourcesInGroup( IN OUT CClusGroupInfo * pgi );

	// Get preferred owners for a group
	BOOL _BGetPreferredOwners( IN OUT CClusGroupInfo * pgi );

	// Get private props of IP Address resource for the group
	BOOL _BGetIPAddressPrivatePropsForGroup(
		IN OUT CClusGroupInfo *	pgi,
		IN OUT CClusResInfo *	pri
		);

	// Get private props of Network Name resource for the group
	BOOL _BGetNetworkNamePrivatePropsForGroup(
		IN OUT CClusGroupInfo *	pgi,
		IN OUT CClusResInfo *	pri
		);

	// Query for information about a resource type
	BOOL _BQueryResourceType( IN OUT CClusResTypeInfo * prti );

	// Get resource type properties
	BOOL _BGetResourceTypeProps( IN OUT CClusResTypeInfo * prti );

	// Get resource type required dependencies
	BOOL _BGetRequiredDependencies( IN OUT CClusResTypeInfo * prti );

	// Query for information about a network
	BOOL _BQueryNetwork( IN OUT CClusNetworkInfo * pni );

	// Query for information about a node
	BOOL _BQueryNode( IN OUT CClusNodeInfo * pni );

	// Set properties on a group
	BOOL _BSetGroupProperties(
		IN OUT CClusGroupInfo *		pgi,
		IN const CClusGroupInfo *	pgiPrev
		);

	// Create a resource and set common properties
	BOOL _BCreateResource(
		IN CClusResInfo &	rri,
		IN HGROUP			hGroup
		);

	// Set the properties, dependency list and possible owner list of a resource.
	BOOL _BSetResourceAttributes( 
		IN CClusResInfo	&		rri,
		IN CClusResPtrList *	plpriOldDependencies	= NULL,
		IN CClusNodePtrList *	plpniOldPossibleOwners	= NULL
		);

	// Set the dependency list of a resource.
	DWORD _BSetResourceDependencies(
		IN CClusResInfo	&		rri,
		IN CClusResPtrList *	plpriOldDependencies	= NULL
		);

	// Set the possible owner list of a resource.
	DWORD _BSetPossibleOwners(
		IN CClusResInfo	&		rri,
		IN CClusNodePtrList *	plpniOldPossibleOwners	= NULL
		);

	// Delete a resource
	BOOL _BDeleteResource( IN CClusResInfo & rri );

	// Reset the group to its original state (deleted or renamed)
	BOOL _BResetGroup( void );

	// Read admin extensions directly from the cluster database
	BOOL _BReadAdminExtensions( IN LPCWSTR pszKey, OUT std::list< CString > & rlstr );

}; // class CWizardThread

/////////////////////////////////////////////////////////////////////////////

#endif // __WIZTHREAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\workthreads.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		WorkThreadS.cpp
//
//	Abstract:
//		Stub for implementation of the CWorkerThread class.
//
//	Author:
//		David Potter (davidp)	December 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "WorkThrd.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\aclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\aclutils.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AclUtils.cpp
//
//	Abstract:
//		Various Access Control List (ACL) utilities.
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AclUtils.h"
#include "DllBase.h"
#include <lmerr.h>

class CAclUiDLL : public CDynamicLibraryBase
{
public:
	CAclUiDLL()
	{
		m_lpszLibraryName = _T( "aclui.dll" );
		m_lpszFunctionName = "CreateSecurityPage";
	}

	HPROPSHEETPAGE CreateSecurityPage( LPSECURITYINFO psi );

protected:
	typedef HPROPSHEETPAGE (*ACLUICREATESECURITYPAGEPROC) (LPSECURITYINFO);
};


HPROPSHEETPAGE CAclUiDLL::CreateSecurityPage(
	LPSECURITYINFO psi
	)
{
	ASSERT( m_hLibrary != NULL );
	ASSERT( m_pfFunction != NULL );

	return ( (ACLUICREATESECURITYPAGEPROC) m_pfFunction ) ( psi );
}

//////////////////////////////////////////////////////////////////////////
// static instances of the dynamically loaded DLL's

static CAclUiDLL g_AclUiDLL;

//+-------------------------------------------------------------------------
//
//	Function:	CreateClusterSecurityPage
//
//	Synopsis:	Create the common NT security hpage.
//
//	Arguments:	[psecinfo] - *psecinfo points to a security descriptor.
//				Caller is responsible for freeing it.
//
//	Returns:	Valid hpage or 0 for error.
//
//	History:
//		  GalenB   11-Feb-1998	Created.
//
//--------------------------------------------------------------------------
HPROPSHEETPAGE
CreateClusterSecurityPage(
	CSecurityInformation* psecinfo
	)
{
	ASSERT( NULL != psecinfo );

	HPROPSHEETPAGE	hPage = 0;

	if ( g_AclUiDLL.Load() )
	{
		psecinfo->AddRef();
		hPage = g_AclUiDLL.CreateSecurityPage( psecinfo );
		ASSERT( hPage != NULL );
		if ( hPage == NULL )
		{
			TRACE( _T( "CreateClusterSecurityPage() - Failed to create security page.\r" ) );
		}

		psecinfo->Release();
	}
	else
	{
		TRACE( _T( "CreateClusterSecurityPage() - Failed to load AclUi.dll.\r" ) );
	}

	return hPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cladmwiz\src\wizthread.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      WizThread.cpp
//
//  Abstract:
//      Implementation of the CWizardThread class.
//
//  Author:
//      David Potter (davidp)   December 16, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WizThread.h"
#include <ResApi.h>         // for ResUtilxxx routine prototypes
#include "PropList.h"       // for CClusPropList
#include "ClusAppWiz.h"     // for CClusterAppWizard
#include "ClusObj.h"        // for CClusterObject, etc.
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

inline DWORD ScReallocString( LPWSTR & rpwsz, DWORD & rcchmac, DWORD & rcch )
{
    delete [] rpwsz;
    rpwsz = NULL;
    rcchmac = rcch + 1;
    rpwsz = new WCHAR[ rcchmac ];
    if ( rpwsz == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    } // if: error allocating memory

    rcch = rcchmac;
    return ERROR_SUCCESS;

} //*** ScReallocString()

/////////////////////////////////////////////////////////////////////////////
// class CWizardThread
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::ThreadFunctionHandler
//
//  Routine Description:
//      Thread function handler.  Processes thread function requests.
//
//  Arguments:
//      nFunction   [IN] Function code.
//      pvParam1    [IN OUT] Parameter 1 with function-specific data.
//      pvParam2    [IN OUT] Parameter 2 with function-specific data.
//
//  Return Value:
//      Status returned to the calling function.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::ThreadFunctionHandler(
    LONG    nFunction,
    PVOID   pvParam1,
    PVOID   pvParam2
    )
{
    DWORD sc = ERROR_SUCCESS;

    switch ( nFunction )
    {
        case WZTF_READ_CLUSTER_INFO:
            sc = _BReadClusterInfo();
            break;
        case WZTF_COLLECT_GROUPS:
            sc = _BCollectGroups();
            break;
        case WZTF_COLLECT_RESOURCES:
            sc = _BCollectResources();
            break;
        case WZTF_COLLECT_RESOURCE_TYPES:
            sc = _BCollectResourceTypes();
            break;
        case WZTF_COLLECT_NETWORKS:
            sc = _BCollectNetworks();
            break;
        case WZTF_COLLECT_NODES:
            sc = _BCollectNodes();
            break;
        case WZTF_COPY_GROUP_INFO:
            sc = _BCopyGroupInfo( (CClusGroupInfo **) pvParam1 );
            break;
        case WZTF_COLLECT_DEPENDENCIES:
            sc = _BCollectDependencies( (CClusResInfo *) pvParam1 );
            break;
        case WZTF_CREATE_VIRTUAL_SERVER:
            sc = _BCreateVirtualServer();
            break;
        case WZTF_CREATE_APP_RESOURCE:
            sc = _BCreateAppResource();
            break;
        case WZTF_DELETE_APP_RESOURCE:
            sc = _BDeleteAppResource();
            break;
        case WZTF_RESET_CLUSTER:
            sc = _BResetCluster();
            break;
        case WZTF_SET_APPRES_ATTRIBUTES:
            sc = _BSetAppResAttributes( 
                    (CClusResPtrList *) pvParam1, 
                    (CClusNodePtrList *) pvParam2
                    );
            break;
        default:
            ASSERT( 0 );
    } // switch:  nFunction

    return sc;

} //*** CWizardThread::ThreadFunctionHandler()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BReadClusterInfo
//
//  Routine Description:
//      (WZTF_READ_CLUSTER_INFO) Read cluster information, such as the
//      cluster name.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BReadClusterInfo( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );

    DWORD               sc;
    BOOL                bSuccess = TRUE;
    CLUSTERVERSIONINFO  cvi;
    LPWSTR              pwszName = NULL;
    DWORD               cchmacName = 128;
    DWORD               cchName;

    // Loop to avoid goto's.
    do
    {
        //
        // Allocate an initial buffer for the object name.  In most cases the
        // name will probably fit into this buffer, so doing this avoids an
        // additional call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_GET_CLUSTER_INFO );
            break;
        } // if: error allocating object name buffer

        //
        // Get cluster information.
        //
        ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Calling GetClusterInformation()\n") );
        cchName = cchmacName;
        cvi.dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );
        sc = GetClusterInformation( Pwiz()->Hcluster(), pwszName, &cchName, &cvi );
        if ( sc == ERROR_MORE_DATA )
        {
            cchName++;
            ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
            sc = ScReallocString( pwszName, cchmacName, cchName );
            if ( sc == ERROR_SUCCESS )
            {
                sc = GetClusterInformation( Pwiz()->Hcluster(), pwszName, &cchName, &cvi );
            } // if: name buffer reallocated successfully
        } // if:  buffer is too small
        if ( sc != ERROR_SUCCESS )
        {
            ATLTRACE( _T("CWizardThread::_BReadClusterInfo() - Error %08.8x from GetClusterInformation()\n"), sc );
            m_nte.SetOperation( sc, IDS_ERROR_GET_CLUSTER_INFO );
            bSuccess = FALSE;
            break;
        } // else if:  error reading from the enumerator

        //
        // Copy the information into the wizard's cluster object.
        //
        Pwiz()->Pci()->SetName( pwszName );

        //
        // Get admin extensions.
        //
        bSuccess = _BReadAdminExtensions( NULL, Pwiz()->Pci()->m_lstrClusterAdminExtensions );
        if ( bSuccess )
        {
            bSuccess = _BReadAdminExtensions( L"ResourceTypes", Pwiz()->Pci()->m_lstrResTypesAdminExtensions );
        } // if: read cluster extensions successfully

    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BReadClusterInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectGroups
//
//  Routine Description:
//      (WZTF_COLLECT_GROUPS) Collect groups in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectGroups( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedGroups() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Make sure resources have been collected.
        //
        if ( ! Pwiz()->BCollectedResources() )
        {
            bSuccess = _BCollectResources();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting resources
        } // if:  resources not collected yet

        //
        // Collect nodes now as well.  This is done because copies of the
        // objects are stored in individual pages, and if we wait for the
        // page to be initialized or displayed before collecting the data,
        // the node information won't be stored on the copies.
        //
        if ( ! Pwiz()->BCollectedNodes() )
        {
            bSuccess = _BCollectNodes();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting nodes
        } // if:  nodes not collected yet

        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectGroups() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_GROUP );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA)
            {
                ATLTRACE( _T("CWizardThread::_BCollectGroups() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the group info structure.
            //
            CClusGroupInfo * pgi = new CClusGroupInfo( Pwiz()->Pci(), pwszName );
            if ( pgi == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating group info structure

            //
            // Initialize the group info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectGroups() - Querying group info about '%s'\n"), pwszName );
            bSuccess = _BQueryGroup( pgi );
            if ( ! bSuccess )
            {
                delete pgi;
                break;
            } // if:  error getting properties

            //
            // Add this group to the list.
            //
            Pwiz()->PlpgiGroups()->insert( Pwiz()->PlpgiGroups()->end(), pgi );
        } // for:  each group in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedGroups();
    } // if:  groups collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectResources
//
//  Routine Description:
//      (WZTF_COLLECT_GROUPS) Collect resources in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectResources( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedResources() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Make sure resource types have been collected.
        //
        if ( ! Pwiz()->BCollectedResourceTypes() )
        {
            bSuccess = _BCollectResourceTypes();
            if ( ! bSuccess )
            {
                break;
            } // if:  error collecting resource types
        } // if:  resource types not collected yet

        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectResources() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_RESOURCE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectResources() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the resource info structure.
            //
            CClusResInfo * pri = new CClusResInfo( Pwiz()->Pci(), pwszName );
            if ( pri == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating resource info structure

            //
            // Initialize the resource info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectResources() - Querying resource info about '%s'\n"), pwszName );
            bSuccess = _BQueryResource( pri );
            if ( ! bSuccess )
            {
                delete pri;
                break;
            } // if:  error getting properties

            //
            // Add this resource to the list.
            //
            Pwiz()->PlpriResources()->insert( Pwiz()->PlpriResources()->end(), pri );
        } // for:  each resource in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedResources();
    } // if:  resources collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectResources()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectResourceTypes
//
//  Routine Description:
//      (WZTF_COLLECT_RESOURCE_TYPES) Collect resource types in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectResourceTypes( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedResourceTypes() );

    DWORD       sc;
    BOOL        bAllocated;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_RESTYPE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // If the resource type doesn't exist yet, allocate a new one.
            //
            CClusResTypeInfo * prti = PobjFromName( Pwiz()->PlprtiResourceTypes(), pwszName );
            if ( prti == NULL )
            {
                //
                // Allocate the resource type info structure.
                //
                prti = new CClusResTypeInfo( Pwiz()->Pci(), pwszName );
                if ( prti == NULL )
                {
                    sc = GetLastError();
                    m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                    break;
                } // if: error allocating resource type info structure
                bAllocated = TRUE;
            } // if:  resource type doesn't exist yet
            else
            {
                bAllocated = FALSE;
            } // else:  resource type already exists

            //
            // Initialize the resource type info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectResourceTypes() - Querying resource type info about '%s'\n"), pwszName );
            bSuccess = _BQueryResourceType( prti );
            if ( ! bSuccess )
            {
                if ( bAllocated )
                {
                    delete prti;
                } // if:  we allocated the resource type info structure

                // Set bSuccess to TRUE because the inability to query one resource type
                // should not abort the whole process of collecting resource types.
                bSuccess = TRUE;
            } // if:  error getting properties
            else
            {
                //
                // Add this resource type to the list.
                //
                if ( bAllocated )
                {
                    Pwiz()->PlprtiResourceTypes()->insert( Pwiz()->PlprtiResourceTypes()->end(), prti );
                } // if:  we allocated the resource type info structure
            } // else:  else: no errors getting properties
        } // for:  each group in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedResourceTypes();
    } // if:  resource types collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectResourceTypes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectNetworks
//
//  Routine Description:
//      (WZTF_COLLECT_NETWORKS) Collect networks in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectNetworks( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedNetworks() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectNetworks() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_NETWORK );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectNetworks() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the network info structure.
            //
            CClusNetworkInfo * pni = new CClusNetworkInfo( Pwiz()->Pci(), pwszName );
            if ( pni == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating network info structure

            //
            // Initialize the network info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectNetworks() - Querying network info about '%s'\n"), pwszName );
            bSuccess = _BQueryNetwork( pni );
            if ( ! bSuccess )
            {
                delete pni;
                break;
            } // if:  error querying for network properties

            //
            // Add this network to the list.
            //
            Pwiz()->PlpniNetworks()->insert( Pwiz()->PlpniNetworks()->end(), pni );
        } // for:  each network in the enumeration
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    if ( bSuccess )
    {
        Pwiz()->SetCollectedNetworks();
    } // if:  networks collected successfully

    return bSuccess;

} //*** CWizardThread::_BCollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectNodes
//
//  Routine Description:
//      (WZTF_COLLECT_NODES) Collect nodes in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectNodes( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( ! Pwiz()->BCollectedNodes() );

    DWORD       sc;
    BOOL        bSuccess = TRUE;
    HCLUSENUM   hclusenum = NULL;
    LPWSTR      pwszName = NULL;
    DWORD       cchmacName = 128;
    DWORD       cchName;
    int         ienum;
    ULONG       ceType;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the enumerator.
        //
        ATLTRACE( _T("CWizardThread::_BCollectNodes() - Calling ClusterOpenEnum()\n") );
        hclusenum = ClusterOpenEnum( Pwiz()->Hcluster(), CLUSTER_ENUM_NODE );
        if ( hclusenum == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_CLUSTER_ENUM );
            bSuccess = FALSE;
            break;
        } // if:  error opening the enumerator

        //
        // Allocate an initial buffer for the object name.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // Loop through the enumeration and add each item to our internal list.
        //
        for ( ienum = 0 ; ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BCollectNodes() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterEnum( hclusenum, ienum, &ceType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_CLUSTER );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Allocate the node info structure.
            //
            CClusNodeInfo * pni = new CClusNodeInfo( Pwiz()->Pci(), pwszName );
            if ( pni == NULL )
            {
                sc = GetLastError();
                m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
                break;
            } // if: error allocating node info structure

            //
            // Initialize the node info structure.
            //
            ATLTRACE( _T("CWizardThread::_BCollectNodes() - Querying network info about '%s'\n"), pwszName );
            bSuccess = _BQueryNode( pni );
            if ( ! bSuccess )
            {
                delete pni;
                break;
            } // if:  error querying for node properties

            //
            // Add this node to the list.
            //
            Pwiz()->PlpniNodes()->insert( Pwiz()->PlpniNodes()->end(), pni );

            //
            // Add this node to each of the resources we care about.
            //
            Pwiz()->PriIPAddress()->m_lpniPossibleOwners.insert( Pwiz()->PriIPAddress()->m_lpniPossibleOwners.end(), pni );
            Pwiz()->PriNetworkName()->m_lpniPossibleOwners.insert( Pwiz()->PriNetworkName()->m_lpniPossibleOwners.end(), pni );
            Pwiz()->PriApplication()->m_lpniPossibleOwners.insert( Pwiz()->PriApplication()->m_lpniPossibleOwners.end(), pni );
        } // for:  each node in the enumeration

        if ( m_nte.Sc() != ERROR_SUCCESS )
        {
            break;
        } // if: error occurred in the for loop

        //
        // Indicate that nodes have now been collected.
        //
        Pwiz()->SetCollectedNodes();

        //
        // Collect preferred owners for groups.
        //
        CClusGroupPtrList::iterator itgrp;
        for ( itgrp = Pwiz()->PlpgiGroups()->begin()
            ; itgrp != Pwiz()->PlpgiGroups()->end()
            ; itgrp++ )
        {
            //
            // Collect preferred owners.  Ignore errors as since error
            // collecting groups for one group may not affect other groups.
            //
            CClusGroupInfo * pgi = *itgrp;
            _BGetPreferredOwners( pgi );
        } // for:  each group already collected

        //
        // Collect possible owners for resources.
        //
        CClusResPtrList::iterator itres;
        for ( itres = Pwiz()->PlpriResources()->begin()
            ; itres != Pwiz()->PlpriResources()->end()
            ; itres++ )
        {
            //
            // Collect possible owners.  Ignore errors as an error collecting
            // groups for one resource may not affect other resources.
            //
            CClusResInfo * pri = *itres;
            _BGetPossibleOwners( pri );
        } // for:  each resource already collected
    } while ( 0 );

    //
    // Cleanup.
    //
    delete [] pwszName;
    if ( hclusenum != NULL )
    {
        ClusterCloseEnum( hclusenum );
    } // if:  enumeration still open

    return bSuccess;

} //*** CWizardThread::_BCollectNodes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCopyGroupInfo
//
//  Routine Description:
//      (WZTF_COPY_GROUP_INFO) Copy one group info object to another.
//
//  Arguments:
//      ppgi        [IN OUT] Array of two CGroupInfo pointers.
//                      [0] = Destination group info object pointer.
//                      [1] = Source group info object pointer.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCopyGroupInfo( IN OUT CClusGroupInfo ** ppgi )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( ppgi != NULL );
    ASSERT( ppgi[ 0 ] != NULL );
    ASSERT( ppgi[ 1 ] != NULL );

    DWORD   sc;
    BOOL    bSuccess = TRUE;

    // Loop to avoid goto's.
    do
    {
        //
        // Copy the group.
        //
        sc = ppgi[ 0 ]->ScCopy( *ppgi[ 1 ] );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, ppgi[ 1 ]->m_strName );
            bSuccess = FALSE;
            break;
        } // if:  error copying the group
    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BCopyGroupInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCollectDependencies
//
//  Routine Description:
//      (WZTF_COLLECT_DEPENDENCIES) Collect dependencies for a resource in
//      the cluster.
//
//  Arguments:
//      pri         [IN OUT] Resource to collect dependencies for.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCollectDependencies( IN OUT CClusResInfo * pri )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( pri != NULL );
    ASSERT( ! pri->m_bCollectedDependencies );

    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's.
    do
    {
        //
        // Open the resource if not open yet.
        //
        if ( pri->Hresource() == NULL )
        {
            sc = pri->ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, pri->RstrName() );
                bSuccess = FALSE;
                break;
            } // if:  error opening the enumerator
        } // if:  resource not open yet

        //
        // Collect dependencies for the resource.
        //
        bSuccess = _BGetDependencies( pri );
    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BCollectDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateVirtualServer
//
//  Routine Description:
//      (WZTF_CREATE_VIRTUAL_SERVER) Create a virtual server.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateVirtualServer( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->BCreatingNewVirtualServer() );
    ASSERT( ! Pwiz()->BNewGroupCreated() );
    ASSERT( ! Pwiz()->BExistingGroupRenamed() );
    ASSERT( ! Pwiz()->BIPAddressCreated() );
    ASSERT( ! Pwiz()->BNetworkNameCreated() );

    DWORD               sc = ERROR_SUCCESS;
    BOOL                bSuccess = FALSE;
    CClusGroupInfo *    pgiExisting = Pwiz()->PgiExistingGroup();
    CClusGroupInfo *    pgiNew = &Pwiz()->RgiCurrent();
    CClusResInfo *      priIPAddr = &Pwiz()->RriIPAddress();
    CClusResInfo *      priNetName = &Pwiz()->RriNetworkName();

    // Loop to avoid goto's
    do
    {
        //
        // If creating a new group, do it now.
        // Otherwise rename the existing group.
        //
        if ( Pwiz()->BCreatingNewGroup() )
        {
            //
            // Create the group.
            //
            sc = pgiNew->ScCreate();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_CREATE_GROUP, pgiNew->RstrName() );
                break;
            } // if:  error creating the group

            //
            // Indicate we created the group.
            //
            Pwiz()->SetNewGroupCreated();
        } // if:  creating a new group
        else
        {
            //
            // Open the group.
            //
            ASSERT( pgiExisting != NULL );
            if ( pgiExisting->Hgroup() == NULL )
            {
                sc = pgiExisting->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgiExisting->RstrName() );
                    break;
                } // if:  error opening the group
            } // if:  group not open yet

            //
            // Rename the group.
            //
            if ( pgiExisting->RstrName() != pgiNew->RstrName() )
            {
                sc = SetClusterGroupName( pgiExisting->Hgroup(), pgiNew->RstrName() );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_RENAME_GROUP, pgiExisting->RstrName(), pgiNew->RstrName() );
                    break;
                } // if:  error renaming the group
            } // if:  group name changed

            //
            // Open the other group object.
            //
            if ( pgiNew->Hgroup() == NULL )
            {
                sc = pgiNew->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgiNew->RstrName() );
                    break;
                } // if:  error opening the other group
            } // if:  new group object not open yet

            //
            // Indicate we renamed the group.
            //
            Pwiz()->SetExistingGroupRenamed();
        } // else:  using an existing group

        //
        // Set common group properties.
        //
        if ( ! _BSetGroupProperties( pgiNew, pgiExisting ) )
        {
            break;
        } // if:  error setting group properties

        //
        // Create the IP Address resource.
        //
        if ( ! _BCreateResource( *priIPAddr, pgiNew->Hgroup() ) )
        {
            break;
        } // if:  error creating IP Address resource

        //
        // Set private properties on the IP Address resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_IPADDR_ADDRESS, Pwiz()->RstrIPAddress() );
            props.ScAddProp( CLUSREG_NAME_IPADDR_SUBNET_MASK, Pwiz()->RstrSubnetMask() );
            props.ScAddProp( CLUSREG_NAME_IPADDR_NETWORK, Pwiz()->RstrNetwork() );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                priIPAddr->Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                props.PbPropList(),
                                static_cast< DWORD >( props.CbPropList() ),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_PRIVATE_RES_PROPS, priIPAddr->RstrName() );
                    break;
                } // if:  error setting private resource properties
            } // if:  any props were added

        } // Set private properties on the IP Address resource

        //
        // Create the Network Name resource.
        //
        if ( ! _BCreateResource( *priNetName, pgiNew->Hgroup() ) )
        {
            break;
        } // if:  error creating Network Name resource

        //
        // Add a dependency for the Network name resource on the IP Address resource.
        //
        if ( 0 )
        {
            sc = AddClusterResourceDependency( priNetName->Hresource(), priIPAddr->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_DEPENDENCY, priNetName->RstrName(), priIPAddr->RstrName() );
                break;
            } // if:  error adding the dependency
        } // Add a dependency for the Network name resource on the IP Address resource

        //
        // Set private properties on the Network Name resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_NETNAME_NAME, Pwiz()->RstrNetName() );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                priNetName->Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES,
                                props.PbPropList(),
                                static_cast< DWORD >( props.CbPropList() ),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_PRIVATE_RES_PROPS, priNetName->RstrName() );
                    break;
                } // if:  error setting private resource properties
            } // if:  any props were added

        } // Set private properties on the Network Name resource

        //
        // Update the virtual server properties on the group.
        //
        pgiNew->SetVirtualServerProperties( Pwiz()->RstrNetName(), Pwiz()->RstrIPAddress(), Pwiz()->RstrNetwork() );

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Construct the error info if an error occurred.
    //
    if ( ! bSuccess )
    {
        if ( Pwiz()->BNetworkNameCreated() && (priNetName->Hresource() != NULL) )
        {
            priNetName->ScDelete();
        } // if:  created Network Name resource
        if ( Pwiz()->BIPAddressCreated() && (priIPAddr->Hresource() != NULL) )
        {
            priIPAddr->ScDelete();
        } // if:  created IP Address resource
        if ( Pwiz()->BNewGroupCreated() && (pgiNew->Hgroup() != NULL) )
        {
            pgiNew->ScDelete();
            Pwiz()->SetNewGroupCreated( FALSE );
        } // if:  created group
        else if ( Pwiz()->BExistingGroupRenamed() && (pgiExisting->Hgroup() != NULL) )
        {
            sc = SetClusterGroupName( pgiExisting->Hgroup(), pgiExisting->RstrName() );
            Pwiz()->SetExistingGroupRenamed( FALSE );
        } // else if:  renamed group
    } // if:  error occurred
    else
    {
        Pwiz()->SetClusterUpdated();
        Pwiz()->SetVSDataChanged( FALSE );
    } // else:  cluster updated successfully

    return bSuccess;

} //*** CWizardThread::_BCreateVirtualServer()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateAppResource
//
//  Routine Description:
//      (WZTF_CREATE_APP_RESOURCE) Create an application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateAppResource( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    ASSERT( Pwiz()->BCreatingAppResource() );
    ASSERT( ! Pwiz()->BAppResourceCreated() );

    DWORD   sc = ERROR_SUCCESS;
    BOOL    bSuccess = FALSE;

    // Loop to avoid goto's
    do
    {
        //
        // Open the group.
        //
        if ( Pwiz()->RgiCurrent().Hgroup() == NULL )
        {
            sc = Pwiz()->RgiCurrent().ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperationIfEmpty(
                    sc,
                    IDS_ERROR_OPEN_GROUP,
                    Pwiz()->RgiCurrent().RstrName()
                    );
                break;
            } // if:  error opening the group
        } // if:  group not open yet

        //
        // Create the application resource.
        //
        if ( ! _BCreateResource( Pwiz()->RriApplication(), Pwiz()->RgiCurrent().Hgroup() ) )
        {
            break;
        } // if:  error creating IP Address resource

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Construct the error info if an error occurred.
    //
    if ( ! bSuccess )
    {
        if ( Pwiz()->BAppResourceCreated() && (Pwiz()->RriApplication().Hresource() != NULL) )
        {
            Pwiz()->RriApplication().ScDelete();
        } // if:  created application resource
    } // if:  error occurred
    else
    {
        Pwiz()->SetClusterUpdated();
        Pwiz()->SetAppDataChanged( FALSE );
    } // else:  cluster updated successfully

    return bSuccess;

} //*** CWizardThread::_BCreateAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BDeleteAppResource
//
//  Routine Description:
//      (WZTF_DELETE_APP_RESOURCE) Delete the application resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BDeleteAppResource( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );

    BOOL bSuccess = FALSE;

    //
    // Delete the application resource if we created it.
    //
    bSuccess = _BDeleteResource( Pwiz()->RriApplication() );
    if ( bSuccess )
    {
        Pwiz()->SetAppDataChanged( FALSE );
    } // if:  resource deleted successfully


    return bSuccess;

} //*** CWizardThread::_BDeleteAppResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BResetCluster
//
//  Routine Description:
//      (WZTF_RESET_CLUSTER) Reset the cluster.
//      Delete the resources we created and delete or rename the group.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BResetCluster( void )
{
    ASSERT( GetCurrentThreadId() == m_idThread );

    BOOL bSuccess = FALSE;

    //
    // Delete the application resource if we created it.
    //
    bSuccess = _BDeleteResource( Pwiz()->RriApplication() );

    //
    // Delete the Network Name resource if we created it.
    //
    if ( bSuccess )
    {
        bSuccess = _BDeleteResource( Pwiz()->RriNetworkName() );
    } // if:  successful up to here

    //
    // Delete the IP Address resource if we created it.
    //
    if ( bSuccess )
    {
        bSuccess = _BDeleteResource( Pwiz()->RriIPAddress() );
    } // if:  successful up to here

    //
    // Delete or rename the group if we created or renamed it.
    //
    if ( bSuccess )
    {
        bSuccess = _BResetGroup();
    } // if:  successful up to here

    //
    // If we are successful to this point, indicate that the cluster no longer
    // needs to be cleaned up.
    //
    if ( bSuccess )
    {
        Pwiz()->SetClusterUpdated( FALSE );
        Pwiz()->SetVSDataChanged( FALSE );
        Pwiz()->SetAppDataChanged( FALSE );
    } // if:  cluster reset successfully

    return bSuccess;

} //*** CWizardThread::_BResetCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetAppResAttributes
//
//  Routine Description:
//      (WZTF_SET_APPRES_ATTRIBUTES) Set properties, dependencies, owners of 
//      the application resource.
//
//  Arguments:
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetAppResAttributes(
        IN CClusResPtrList *    plpriOldDependencies,
        IN CClusNodePtrList *   plpniOldPossibleOwners
        )
{
    ASSERT( GetCurrentThreadId() == m_idThread );
    BOOL bSuccess;

    bSuccess = _BSetResourceAttributes( 
                    Pwiz()->RriApplication(),
                    plpriOldDependencies,
                    plpniOldPossibleOwners
                    );
    if ( bSuccess )
    {
        Pwiz()->SetAppDataChanged( FALSE );
    }

    return bSuccess;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryResource
//
//  Routine Description:
//      Query for information about a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryResource( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );

    BOOL    bSuccess = TRUE;
    DWORD   sc;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the resource.
        //
        pri->BSetQueried();

        //
        // Open the resource.
        //
        sc = pri->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource

        //
        // Get resource properties.
        //
        bSuccess = _BGetResourceProps( pri );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting properties

        //
        // Collect the possible owners.
        //
        bSuccess = _BGetPossibleOwners( pri );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting possible owners

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourceProps
//
//  Routine Description:
//      Get resource properties (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourceProps( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_RES_SEPARATE_MONITOR,  NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET( CClusResInfo, m_bSeparateMonitor ) }
    , { CLUSREG_NAME_RES_PERSISTENT_STATE,  NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PERSISTENT_STATE,  CLUSTER_RESOURCE_MINIMUM_PERSISTENT_STATE,  CLUSTER_RESOURCE_MAXIMUM_PERSISTENT_STATE, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusResInfo, m_nPersistentState ) }
    , { CLUSREG_NAME_RES_LOOKS_ALIVE,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE,       CLUSTER_RESOURCE_MINIMUM_LOOKS_ALIVE,       CLUSTER_RESOURCE_MAXIMUM_LOOKS_ALIVE, 0, FIELD_OFFSET( CClusResInfo, m_nLooksAlive ) }
    , { CLUSREG_NAME_RES_IS_ALIVE,          NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_IS_ALIVE,          CLUSTER_RESOURCE_MINIMUM_IS_ALIVE,          CLUSTER_RESOURCE_MAXIMUM_IS_ALIVE, 0, FIELD_OFFSET( CClusResInfo, m_nIsAlive ) }
    , { CLUSREG_NAME_RES_RESTART_ACTION,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION,    0,                                          CLUSTER_RESOURCE_MAXIMUM_RESTART_ACTION, 0, FIELD_OFFSET( CClusResInfo, m_crraRestartAction ) }
    , { CLUSREG_NAME_RES_RESTART_THRESHOLD, NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD, CLUSTER_RESOURCE_MINIMUM_RESTART_THRESHOLD, CLUSTER_RESOURCE_MAXIMUM_RESTART_THRESHOLD, 0, FIELD_OFFSET( CClusResInfo, m_nRestartThreshold ) }
    , { CLUSREG_NAME_RES_RESTART_PERIOD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD,    CLUSTER_RESOURCE_MINIMUM_RESTART_PERIOD,    CLUSTER_RESOURCE_MAXIMUM_RESTART_PERIOD, 0, FIELD_OFFSET( CClusResInfo, m_nRestartPeriod ) }
    , { CLUSREG_NAME_RES_PENDING_TIMEOUT,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MINIMUM_PENDING_TIMEOUT,   CLUSTER_RESOURCE_MAXIMUM_PENDING_TIMEOUT, 0, FIELD_OFFSET( CClusResInfo, m_nPendingTimeout ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get resource common properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_COMMON_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        (PBYTE) pri
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the Type property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_RES_TYPE,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        CClusResTypeInfo * prti = PobjFromName( Pwiz()->PlprtiResourceTypes(), pwsz );
        pri->BSetResourceType( prti );
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_RES_DESC,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pri->m_strDescription = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetResourceProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetPossibleOwners
//
//  Routine Description:
//      Collect the list of possible owners for a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetPossibleOwners( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HRESENUM        hre = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           reType;
    CClusNodeInfo * pniOwner;

    //
    // Only do this if nodes have been already been collected
    // and we haven't collected owners yet.
    //
    if ( ! Pwiz()->BCollectedNodes() || pri->m_bCollectedOwners )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the resource.
        //
        hre = ClusterResourceOpenEnum( pri->Hresource(), CLUSTER_RESOURCE_ENUM_NODES );
        if ( hre == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_RESOURCE_ENUM, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each owner, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetPossibleOwners() - owner name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_RESOURCE );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pniOwner = Pwiz()->PniFindNodeNoCase( pwszName );
            if ( pniOwner != NULL )
            {
                pri->m_lpniPossibleOwners.insert( pri->m_lpniPossibleOwners.end(), pniOwner );
            } // if:  node exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pri->m_bCollectedOwners = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hre != NULL )
    {
        ClusterResourceCloseEnum( hre );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetDependencies
//
//  Routine Description:
//      Collect the list of dependencies for a resource (thread).
//
//  Arguments:
//      pri         [IN OUT] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetDependencies( IN OUT CClusResInfo * pri )
{
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HRESENUM        hre = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           reType;
    CClusResInfo *  priDependency;

    //
    // Only do this if we haven't collected dependencies yet.
    //
    if ( pri->m_bCollectedDependencies )
    {
        return TRUE;
    } // if:  dependencies collected already

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the resource.
        //
        hre = ClusterResourceOpenEnum( pri->Hresource(), CLUSTER_RESOURCE_ENUM_DEPENDS );
        if ( hre == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_RESOURCE_ENUM, pri->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the resource enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each dependency, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetDependencies() - dependency name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterResourceEnum( hre, ienum, &reType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_RESOURCE );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the resource in our list and insert it into the list.
            //
            priDependency = Pwiz()->PriFindResourceNoCase( pwszName );
            if ( priDependency != NULL )
            {
                pri->m_lpriDependencies.insert( pri->m_lpriDependencies.end(), priDependency );
            } // if:  resource exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate dependencies have been collected.
        //
        pri->m_bCollectedDependencies = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hre != NULL )
    {
        ClusterResourceCloseEnum( hre );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryGroup
//
//  Routine Description:
//      Query for information about a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryGroup( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;

    // Loop to avoid goto's
    do
    {
        //
        // Open the group.
        //
        sc = pgi->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_GROUP, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group

        //
        // Get group properties.
        //
        bSuccess = _BGetGroupProps( pgi );
        if ( ! bSuccess )
        {
            pgi->Close();
            break;
        } // if:  error getting properties

        //
        // Collect the list of resources in the group.
        //
        bSuccess = _BGetResourcesInGroup( pgi );
        if ( ! bSuccess )
        {
            pgi->Close();
            break;
        } // if:  error getting resources in the group

        //
        // Collect the preferred owners.
        //
        bSuccess = _BGetPreferredOwners( pgi );
        if ( ! bSuccess )
        {
            pgi->PlpriResources()->erase( pgi->PlpriResources()->begin(), pgi->PlpriResources()->end() );
            pgi->Close();
            break;
        } // if:  error getting preferred owners

        //
        // Indicate that we've now queried the group.
        //
        pgi->BSetQueried();

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetGroupProps
//
//  Routine Description:
//      Get group properties (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetGroupProps(
    IN OUT CClusGroupInfo * pgi
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_GRP_PERSISTENT_STATE,      NULL, CLUSPROP_FORMAT_DWORD, 0, 0, 1, 0, FIELD_OFFSET( CClusGroupInfo, m_nPersistentState ) }
    , { CLUSREG_NAME_GRP_FAILOVER_THRESHOLD,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_THRESHOLD,    CLUSTER_GROUP_MINIMUM_FAILOVER_THRESHOLD, CLUSTER_GROUP_MAXIMUM_FAILOVER_THRESHOLD, 0, FIELD_OFFSET( CClusGroupInfo, m_nFailoverThreshold ) }
    , { CLUSREG_NAME_GRP_FAILOVER_PERIOD,       NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILOVER_PERIOD,       CLUSTER_GROUP_MINIMUM_FAILOVER_PERIOD, CLUSTER_GROUP_MAXIMUM_FAILOVER_PERIOD, 0, FIELD_OFFSET( CClusGroupInfo, m_nFailoverPeriod ) }
    , { CLUSREG_NAME_GRP_FAILBACK_TYPE,         NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_AUTO_FAILBACK_TYPE,    0, CLUSTER_GROUP_MAXIMUM_AUTO_FAILBACK_TYPE, 0, FIELD_OFFSET( CClusGroupInfo, m_cgaftAutoFailbackType ) }
    , { CLUSREG_NAME_GRP_FAILBACK_WIN_START,    NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_START, CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_START, CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_START, RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusGroupInfo, m_nFailbackWindowStart ) }
    , { CLUSREG_NAME_GRP_FAILBACK_WIN_END,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_GROUP_DEFAULT_FAILBACK_WINDOW_END,   CLUSTER_GROUP_MINIMUM_FAILBACK_WINDOW_END,   CLUSTER_GROUP_MAXIMUM_FAILBACK_WINDOW_END,   RESUTIL_PROPITEM_SIGNED, FIELD_OFFSET( CClusGroupInfo, m_nFailbackWindowEnd ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get group common properties.
        //
        sc = cpl.ScGetGroupProperties( pgi->Hgroup(), CLUSCTL_GROUP_GET_COMMON_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        reinterpret_cast< PBYTE >( pgi )
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_GRP_DESC,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strDescription = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_GROUP_PROPERTIES, pgi->RstrName() );
    } // if:  error occurred

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetGroupProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourcesInGroup
//
//  Routine Description:
//      Collect the list of resources contained in a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourcesInGroup( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HGROUPENUM      hge = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           geType;
    CClusResInfo *  pri;

    //
    // Only do this if resources have been already been collected
    // and we haven't collected resources in this group yet.
    //
    if ( ! Pwiz()->BCollectedResources() || pgi->m_bCollectedResources )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the group.
        //
        hge = ClusterGroupOpenEnum( pgi->Hgroup(), CLUSTER_GROUP_ENUM_CONTAINS );
        if ( hge == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_GROUP_ENUM, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each resource, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetResourcesInGroup() - name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_GROUP );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pri = Pwiz()->PriFindResourceNoCase( pwszName );
            if ( pri == NULL )
            {
                m_nte.SetOperation( ERROR_FILE_NOT_FOUND, 0 );
                bSuccess = FALSE;
                break;
            } // if:  didn't find the resource
            pgi->m_lpriResources.insert( pgi->m_lpriResources.end(), pri );

            //
            // Check to see if it is an IP Address resource or a Network Name
            // resource and store the result in the list entry.
            //
            ASSERT( pri->Prti() != NULL );
            if ( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_IPADDR ) == 0 )
            {
                if ( ! pgi->BHasIPAddress() )
                {
                    pgi->m_bHasIPAddress = TRUE;

                    //
                    // Read IP Address private properties.
                    //
                    bSuccess = _BGetIPAddressPrivatePropsForGroup( pgi, pri );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error getting props
                } // if:  first IP Address resource in group
            } // if:  this is an IP Address resource
            else if ( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_NETNAME ) == 0 )
            {
                if ( ! pgi->BHasNetName() )
                {
                    pgi->m_bHasNetName = TRUE;

                    //
                    // Read Network Name private properties.
                    //
                    bSuccess = _BGetNetworkNamePrivatePropsForGroup( pgi, pri );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error getting props
                } // if:  first Network Name resource in group
            } // else if:  this is a Network Name resource
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pgi->m_bCollectedResources = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hge != NULL )
    {
        ClusterGroupCloseEnum( hge );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetResourcesInGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetPreferredOwners
//
//  Routine Description:
//      Collect the list of preferred owners for a group (thread).
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetPreferredOwners( IN OUT CClusGroupInfo * pgi )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    HGROUPENUM      hge = NULL;
    LPWSTR          pwszName = NULL;
    DWORD           cchmacName = 128;
    DWORD           cchName;
    int             ienum;
    ULONG           geType;
    CClusNodeInfo * pniOwner;

    //
    // Only do this if nodes have been already been collected
    // and we haven't collected owners yet.
    //
    if ( ! Pwiz()->BCollectedNodes() || pgi->m_bCollectedOwners )
    {
        return TRUE;
    } // if:  nodes not collected yet

    // Loop to avoid goto's
    do
    {
        //
        // Open an enumeration for the group.
        //
        hge = ClusterGroupOpenEnum( pgi->Hgroup(), CLUSTER_GROUP_ENUM_NODES );
        if ( hge == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_OPEN_GROUP_ENUM, pgi->RstrName() );
            bSuccess = FALSE;
            break;
        } // if:  error opening the group enumerator

        //
        // Allocate an initial buffer for the object names.  Most names will
        // probably fit into this buffer, so doing this avoids an additional
        // call just to get the size of the data.
        //
        pwszName = new WCHAR[ cchmacName ];
        if ( pwszName == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_ENUM_CLUSTER );
            break;
        } // if: error allocating object name buffer

        //
        // For each owner, add it to the list.
        //
        for ( ienum = 0 ; 1 ; ienum++ )
        {
            //
            // Get the name of the next item in the enumerator.  If our name
            // buffer is too small, allocate a new one and try again.
            //
            cchName = cchmacName;
            sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
            if ( sc == ERROR_MORE_DATA )
            {
                ATLTRACE( _T("CWizardThread::_BGetPreferredOwners() - owner name buffer too small.  Expanding from %d to %d\n"), cchmacName, cchName );
                sc = ScReallocString( pwszName, cchmacName, cchName );
                if ( sc == ERROR_SUCCESS )
                {
                    sc = ClusterGroupEnum( hge, ienum, &geType, pwszName, &cchName );
                } // if: name buffer reallocated successfully
            }  // if:  name buffer was too small
            if ( sc == ERROR_NO_MORE_ITEMS )
            {
                break;
            } // if:  no more items in the enumeration
            else if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( GetLastError(), IDS_ERROR_ENUM_GROUP );
                bSuccess = FALSE;
                break;
            } // else if:  error reading from the enumerator

            //
            // Find the node in our list and insert it into the list.
            //
            pniOwner = Pwiz()->PniFindNodeNoCase( pwszName );
            if ( pniOwner != NULL )
            {
                pgi->m_lpniPreferredOwners.insert( pgi->m_lpniPreferredOwners.end(), pniOwner );
            } // if:  node exists in the list
        } // for:  each owner in the enumeration

        //
        // Indicate owners have been collected.
        //
        pgi->m_bCollectedOwners = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hge != NULL )
    {
        ClusterGroupCloseEnum( hge );
    } // if:  enumeration still open
    delete [] pwszName;

    return bSuccess;

} //*** CWizardThread::_BGetPreferredOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetIPAddressPrivatePropsForGroup
//
//  Routine Description:
//      Collect the private properties of the IP Address resource in the
//      group and save the IP Address and Network properties in the group
//      object.
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pri         [IN OUT] Resource info for an IP Address resource.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetIPAddressPrivatePropsForGroup(
    IN OUT CClusGroupInfo * pgi,
    IN OUT CClusResInfo *   pri
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );
    ASSERT( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_IPADDR ) == 0 );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Get resource private properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the IP Address property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_IPADDR_ADDRESS,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strIPAddress = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // Find the Network property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_IPADDR_NETWORK,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strNetwork = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetIPAddressPrivatePropsForGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetNetworkNamePrivatePropsForGroup
//
//  Routine Description:
//      Collect the private properties of the Network Name resource in the
//      group and save the Network Name property in the group object.
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pri         [IN OUT] Resource info for an Network Name resource.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetNetworkNamePrivatePropsForGroup(
    IN OUT CClusGroupInfo * pgi,
    IN OUT CClusResInfo *   pri
    )
{
    ASSERT( pgi != NULL );
    ASSERT( pgi->Hgroup() != NULL );
    ASSERT( pri != NULL );
    ASSERT( pri->Hresource() != NULL );
    ASSERT( pri->Prti()->RstrName().CompareNoCase( CLUS_RESTYPE_NAME_NETNAME ) == 0 );

    DWORD           sc;
    BOOL            bSuccess = TRUE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Get resource private properties.
        //
        sc = cpl.ScGetResourceProperties( pri->Hresource(), CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_NETNAME_NAME,
                        &pwsz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        pgi->m_strNetworkName = pwsz;
        LocalFree( pwsz );
        pwsz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_PROPERTIES, pri->RstrName() );
    } // if:  error occurred getting properties

    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BGetNetworkNamePrivatePropsForGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryResourceType
//
//  Routine Description:
//      Query for information about a resource type (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryResourceType( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( prti != NULL );
    ASSERT( Pwiz()->Hcluster() != NULL );

    BOOL bSuccess = TRUE;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the resource type.
        //
        prti->BSetQueried();

        //
        // Get resource type properties.
        //
        bSuccess = _BGetResourceTypeProps( prti );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting properties

        //
        // Get resource type class info.
        //
        {
            DWORD   cbReturned;
            DWORD   sc;

            sc = ClusterResourceTypeControl(
                            Pwiz()->Hcluster(),
                            prti->RstrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_CLASS_INFO,
                            NULL,
                            NULL,
                            &prti->m_rciResClassInfo,
                            sizeof( prti->m_rciResClassInfo ),
                            &cbReturned
                            );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES, prti->RstrName() );
                bSuccess = FALSE;
                break;
            } // if:  error getting class info
            else
            {
                ASSERT( cbReturned == sizeof( prti->m_rciResClassInfo ) );
            }  // else:  data retrieved successfully
        } // Get resource type class info

        //
        // Get required dependencies.
        //
        bSuccess = _BGetRequiredDependencies( prti );
        if ( ! bSuccess )
        {
            break;
        } // if:  error getting resource type class info

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BQueryResourceType()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetResourceTypeProps
//
//  Routine Description:
//      Get resource type properties (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetResourceTypeProps( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( prti != NULL );

    DWORD           sc;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          psz = NULL;
    DWORD           cbValue;

    RESUTIL_PROPERTY_ITEM ptable[] =
    { { CLUSREG_NAME_RESTYPE_LOOKS_ALIVE,   NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESTYPE_DEFAULT_LOOKS_ALIVE, 0, MAX_DWORD, 0, FIELD_OFFSET( CClusResTypeInfo, m_nLooksAlive ) }
    , { CLUSREG_NAME_RESTYPE_IS_ALIVE,      NULL, CLUSPROP_FORMAT_DWORD, CLUSTER_RESTYPE_DEFAULT_IS_ALIVE,    0, MAX_DWORD, 0, FIELD_OFFSET( CClusResTypeInfo, m_nIsAlive ) }
    , { 0 }
    };

    // Loop to avoid goto's
    do
    {
        //
        // Get resource type common properties.
        //
        sc = cpl.ScGetResourceTypeProperties(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Parse the properties.
        //
        sc = ResUtilVerifyPropertyTable(
                        ptable,
                        NULL,
                        TRUE, // AllowUnknownProperties
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        reinterpret_cast< PBYTE >( prti )
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error parsing properties

        //
        // Find the DLL Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_RESTYPE_NAME,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strDisplayName = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // Find the Description property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_RESTYPE_DESC,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strDescription = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // Find the AdminExtensions property.
        //
        sc = ResUtilFindMultiSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_ADMIN_EXT,
                        &psz,
                        &cbValue
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property

        //
        // Loop through each value in the property and add it to the list
        // of admin extension strings.
        //
        {
            //
            // Start with a fresh list.
            //
            prti->m_lstrAdminExtensions.erase(
                prti->m_lstrAdminExtensions.begin(),
                prti->m_lstrAdminExtensions.end()
                );

            LPWSTR pszCurrent = psz;
            while ( *pszCurrent != L'\0' )
            {
                prti->m_lstrAdminExtensions.insert(
                    prti->m_lstrAdminExtensions.end(),
                    pszCurrent
                    );
                pszCurrent += wcslen( pszCurrent ) + 1;
            } // while:  more strings in the array
        } // add strings to the list
        LocalFree( psz );
        psz = NULL;

        //
        // Get resource type common read-only properties.
        //
        sc = cpl.ScGetResourceTypeProperties(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        CLUSCTL_RESOURCE_TYPE_GET_RO_COMMON_PROPERTIES
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Find the DLL Name property.
        //
        sc = ResUtilFindSzProperty(
                        cpl.PbPropList(),
                        static_cast< DWORD >( cpl.CbPropList() ),
                        CLUSREG_NAME_RESTYPE_DLL_NAME,
                        &psz
                        );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error finding property
        prti->m_strResDLLName = psz;
        LocalFree( psz );
        psz = NULL;

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESOURCE_TYPE_PROPERTIES, prti->RstrName() );
    } // if:  error occurred

    return bSuccess;

} //*** CWizardThread::_BGetResourceTypeProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BGetRequiredDependencies
//
//  Routine Description:
//      Get resource type required dependencies (thread).
//
//  Arguments:
//      prti        [IN OUT] Resource type info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BGetRequiredDependencies( IN OUT CClusResTypeInfo * prti )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( prti != NULL );
    ASSERT( prti->m_pcrd == NULL );

    DWORD                   sc;
    BOOL                    bSuccess = FALSE;
    DWORD                   cbOutBuf = 512;
    CLUSPROP_BUFFER_HELPER  buf;

    buf.pb = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Allocate the initial buffer.
        //
        buf.pb = new BYTE[ cbOutBuf ];
        if ( buf.pb == NULL )
        {
            sc = ERROR_NOT_ENOUGH_MEMORY;
            break;
        } // if:  error allocating memory

        //
        // Get required dependencies.
        //
        sc = ClusterResourceTypeControl(
                        Pwiz()->Hcluster(),
                        prti->RstrName(),
                        NULL,
                        CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES,
                        NULL,
                        0,
                        buf.pb,
                        cbOutBuf,
                        &cbOutBuf
                        );
        if ( sc == ERROR_MORE_DATA )
        {
            delete [] buf.pb;
            buf.pb = new BYTE[ cbOutBuf ];
            if ( buf.pb == NULL )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                break;
            } // if:  error allocating memory
            sc = ClusterResourceTypeControl(
                            Pwiz()->Hcluster(),
                            prti->RstrName(),
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES,
                            NULL,
                            0,
                            buf.pb,
                            cbOutBuf,
                            &cbOutBuf
                            );
        } // if:  buffer too small
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error getting properties

        //
        // Save the required dependencies in the resource type if any exist.
        //
        if ( cbOutBuf > 0 )
        {
            prti->m_pcrd = buf.pRequiredDependencyValue;
            buf.pb = NULL;
        } // if:  resource type has required dependencies

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Check for errors getting properties.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperation( sc, IDS_ERROR_GET_RESTYPE_REQUIRED_DEPENDENCIES, prti->RstrName() );
    } // if:  error occurred

    delete [] buf.pb;
    return bSuccess;

} //*** CWizardThread::_BGetRequiredDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryNetwork
//
//  Routine Description:
//      Query for information about a network (thread).
//
//  Arguments:
//      pni         [IN OUT] Network info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryNetwork( IN OUT CClusNetworkInfo * pni )
{
    ASSERT( pni != NULL );

    DWORD           sc = ERROR_SUCCESS;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the network.
        //
        pni->BSetQueried();

        //
        // Open the network.
        //
        sc = pni->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_NETWORK, pni->RstrName() );
            break;
        } // if:  error opening the network

        // Loop to avoid goto's
        do
        {
            //
            // Get network common properties.
            //
            sc = cpl.ScGetNetworkProperties( pni->Hnetwork(), CLUSCTL_NETWORK_GET_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Description property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            CLUSREG_NAME_NET_DESC,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the description
            pni->m_strDescription = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Find the Role property.
            //
            sc = ResUtilFindDwordProperty(
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            CLUSREG_NAME_NET_ROLE,
                            (DWORD *) &pni->m_nRole
                            );
            ASSERT( sc == ERROR_SUCCESS );

            //
            // Get network common read-only properties.
            //
            sc = cpl.ScGetNetworkProperties( pni->Hnetwork(), CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Address property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            CLUSREG_NAME_NET_ADDRESS,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the property
            pni->m_strAddress = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Find the Address Mask property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            CLUSREG_NAME_NET_ADDRESS_MASK,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the property
            pni->m_strAddressMask = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

            //
            // Convert the address and address mask to numbers.
            //
            sc = ClRtlTcpipStringToAddress( pni->RstrAddress(), &pni->m_nAddress );
            if ( sc == ERROR_SUCCESS )
            {
                sc = ClRtlTcpipStringToAddress( pni->RstrAddressMask(), &pni->m_nAddressMask );
            } // if:  successfully converted address to number
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error converting address or address mask to a number
        } while ( 0 );

        //
        // Check for errors getting properties.
        //
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_GET_NETWORK_PROPERTIES, pni->RstrName() );
            break;
        } // if:  error getting properties

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BQueryNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BQueryNode
//
//  Routine Description:
//      Query for information about a node (thread).
//
//  Arguments:
//      pni         [IN OUT] Node info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BQueryNode( IN OUT CClusNodeInfo * pni )
{
    ASSERT( pni != NULL );

    DWORD           sc = ERROR_SUCCESS;
    BOOL            bSuccess = FALSE;
    CClusPropList   cpl;
    LPWSTR          pwsz = NULL;

    // Loop to avoid goto's
    do
    {
        //
        // Indicate that we've now queried the node.
        //
        pni->BSetQueried();

        //
        // Open the node.
        //
        sc = pni->ScOpen();
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_OPEN_NODE, pni->RstrName() );
            break;
        } // if:  error opening the node

        // Loop to avoid goto's
        do
        {
            //
            // Get node common properties.
            //
            sc = cpl.ScGetNodeProperties( pni->Hnode(), CLUSCTL_NODE_GET_COMMON_PROPERTIES );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error getting properties

            //
            // Find the Description property.
            //
            sc = ResUtilFindSzProperty(
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            CLUSREG_NAME_NODE_DESC,
                            &pwsz
                            );
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error finding the description
            pni->m_strDescription = pwsz;
            LocalFree( pwsz );
            pwsz = NULL;

        } while ( 0 );

        //
        // Check for errors getting properties.
        //
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_GET_NODE_PROPERTIES, pni->RstrName() );
            break;
        } // if:  error getting properties

        //
        // If we make it here, the operation was a success.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Cleanup.
    //
    if ( pwsz != NULL )
    {
        LocalFree( pwsz );
    } // if:  memory still allocated

    return bSuccess;

} //*** CWizardThread::_BQueryNode()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BResetGroup
//
//  Routine Description:
//      Reset the group to its original state. (thread)
//      This entails deleting the group if we created it or renaming it
//      if it was an existing group.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BResetGroup( void )
{
    BOOL        bSuccess = FALSE;
    DWORD       sc = ERROR_SUCCESS;
    DWORD       idsError;

    // Loop to avoid goto's.
    do
    {
        //
        // Delete or rename the group if we created or renamed it.
        //
        if ( Pwiz()->BNewGroupCreated() || Pwiz()->BExistingGroupRenamed() )
        {
            ASSERT( Pwiz()->Hcluster() != NULL );

            if ( Pwiz()->BNewGroupCreated() )
            {
                idsError = IDS_ERROR_DELETE_GROUP;
            } // if:  created the group
            else
            {
                idsError = IDS_ERROR_RENAME_GROUP;
            } // else:  renamed the group

            //
            // Open the group.
            //
            if ( Pwiz()->RgiCurrent().Hgroup() == NULL )
            {
                sc = Pwiz()->RgiCurrent().ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperationIfEmpty(
                        sc,
                        idsError,
                        Pwiz()->RgiCurrent().RstrName()
                        );
                    break;
                } // if:  error opening the group
            } // if:  group not open yet

            //
            // Delete or rename the group.
            //
            if ( Pwiz()->BNewGroupCreated() )
            {
                sc = Pwiz()->RgiCurrent().ScDelete();
            } // if:  created the group
            else
            {
                ASSERT( Pwiz()->PgiExistingGroup() != NULL );
                if ( Pwiz()->PgiExistingGroup()->RstrName() != Pwiz()->RgiCurrent().RstrName() )
                {
                    sc = SetClusterGroupName( Pwiz()->RgiCurrent().Hgroup(), Pwiz()->PgiExistingGroup()->RstrName() );
                } // if:  name changed
                if ( sc == ERROR_SUCCESS )
                {
                    bSuccess = _BSetGroupProperties( Pwiz()->PgiExistingGroup(), &Pwiz()->RgiCurrent() );
                    if ( ! bSuccess )
                    {
                        break;
                    } // if:  error setting group properties
                } // if:  cluster group name changed successfully
            } // if:  renamed the group
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperationIfEmpty(
                    sc,
                    idsError,
                    Pwiz()->RgiCurrent().RstrName(),
                    Pwiz()->PgiExistingGroup()->RstrName()
                    );
                break;
            } // if:  error deleting or renaming the group

            //
            // Indicate group was deleted or renamed back.
            //
            Pwiz()->SetNewGroupCreated( FALSE );
            Pwiz()->SetExistingGroupRenamed( FALSE );

        } // else:  group opened successfully

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BResetGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetGroupProperties
//
//  Routine Description:
//      Set properties on a group (thread)
//
//  Arguments:
//      pgi         [IN OUT] Group info.
//      pgiPrev     [IN] Previous group info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetGroupProperties(
    IN OUT CClusGroupInfo *     pgi,
    IN const CClusGroupInfo *   pgiPrev
    )
{
    ASSERT( pgi != NULL );

    BOOL            bSuccess = FALSE;
    DWORD           sc;
    CClusPropList   props;
    DWORD           cbProps;
    CClusGroupInfo  giDefault( pgi->Pci() );

    // Loop to avoid goto's.
    do
    {
        //
        // If there is no previous group info, point to a default
        // one so that group properties can be written if they
        // have changed.
        //
        if ( pgiPrev == NULL )
        {
            pgiPrev = &giDefault;
        } // if:  no previous group info

        //
        // Add changed properties to the property list.
        //
        props.ScAddProp( CLUSREG_NAME_GRP_DESC, pgi->RstrDescription(), pgiPrev->RstrDescription() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILOVER_THRESHOLD, pgi->NFailoverThreshold(), pgiPrev->NFailoverThreshold() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILOVER_PERIOD, pgi->NFailoverPeriod(), pgiPrev->NFailoverPeriod() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_TYPE, (DWORD) pgi->CgaftAutoFailbackType(), pgiPrev->CgaftAutoFailbackType() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_WIN_START, pgi->NFailbackWindowStart(), pgiPrev->NFailbackWindowStart() );
        props.ScAddProp( CLUSREG_NAME_GRP_FAILBACK_WIN_END, pgi->NFailbackWindowEnd(), pgiPrev->NFailbackWindowEnd() );

        //
        // Send the property list to the cluster.
        //
        if ( props.Cprops() > 0 )
        {
            sc = ClusterGroupControl(
                            pgi->Hgroup(),
                            NULL,   // hNode
                            CLUSCTL_GROUP_SET_COMMON_PROPERTIES,
                            props.PbPropList(),
                            static_cast< DWORD >( props.CbPropList() ),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_SET_COMMON_GROUP_PROPS, pgi->RstrName() );
                break;
            } // if:  error setting common group properties
        } // if:  any props were added

        //
        // Set the preferred owners on the group.
        //
        {
            HNODE * phnodes = NULL;

            //
            // Allocate node handle array.
            //
            phnodes = new HNODE[ pgi->PlpniPreferredOwners()->size() ];
            if ( phnodes == NULL )
            {
                m_nte.SetOperation( ERROR_NOT_ENOUGH_MEMORY, IDS_ERROR_SET_PREFERRED_OWNERS, pgi->RstrName() );
                break;
            } // if:  error allocating node handle array

            //
            // Copy the handle of all the nodes in the node list
            // to the handle array.
            //
            CClusNodePtrList::iterator  itCurrent = pgi->PlpniPreferredOwners()->begin();
            CClusNodePtrList::iterator  itLast = pgi->PlpniPreferredOwners()->end();
            CClusNodeInfo *             pni;
            int                         idxHnode;

            for ( idxHnode = 0 ; itCurrent != itLast ; itCurrent++, idxHnode++ )
            {
                pni = *itCurrent;
                phnodes[ idxHnode ] = pni->Hnode();
            } // for:  each node in the list

            //
            // Set the preferred owners.
            //
            sc = SetClusterGroupNodeList( pgi->Hgroup(), idxHnode, phnodes );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_SET_PREFERRED_OWNERS, pgi->RstrName() );
                delete [] phnodes;
                break;
            } // if:  error setting the preferred owners

            delete [] phnodes;
        } // Set the preferred owners on the group

        //
        // If we get here, we must be successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    return bSuccess;

} //*** CWizardThread::_BSetGroupProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BCreateResource
//
//  Routine Description:
//      Create a resource and set common properties (thread)
//      Caller is responsible for closing the resource handle.
//
//  Arguments:
//      rri         [IN] Resource info.
//      hGroup      [IN] Handle to group to create resource in.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BCreateResource(
    IN CClusResInfo &   rri,
    IN HGROUP           hGroup
    )
{
    ASSERT( Pwiz()->Hcluster() != NULL );
    ASSERT( hGroup != NULL );
    ASSERT( rri.RstrName().GetLength() > 0 );
    ASSERT( rri.Prti() != NULL );
    ASSERT( rri.Prti()->RstrName().GetLength() > 0 );
    ASSERT( ! rri.BCreated() );
    ASSERT( rri.Hresource() == NULL );

    BOOL    bSuccess = FALSE;
    DWORD   sc = ERROR_SUCCESS;
    DWORD   dwFlags;

    //
    // Create the resource.
    //
    if ( rri.BSeparateMonitor() )
    {
        dwFlags = CLUSTER_RESOURCE_SEPARATE_MONITOR;
    } // if:  bring resource online in a separate resource monitor
    else
    {
        dwFlags = 0;
    } // if:  bring resource online in the common resource monitor

    do  // do-while: dummy loop to avoid gotos
    {
        CClusNodePtrList *  plpniPossibleOwnersList = &rri.m_lpniPossibleOwners;

        sc = rri.ScCreate( hGroup, dwFlags );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_CREATE_RESOURCE, rri.RstrName() );
            break;
        } // if:  error creating resource

        //
        // Indicate we created the resource.
        //
        rri.BSetCreated();

        //
        // Get the possible owner list of the newly created resource.
        //
        
        // First clear the list.
        plpniPossibleOwnersList->erase( plpniPossibleOwnersList->begin(), plpniPossibleOwnersList->end() );

        // Then get it.
        bSuccess = _BGetPossibleOwners( &rri );
        if ( bSuccess == FALSE )
        {
            break;
        }

        //
        // Set the resource properties, dependencies and owner list.
        // There is no need to get the dependency list beforehand because it is empty.
        //
        bSuccess = _BSetResourceAttributes( rri, NULL, plpniPossibleOwnersList );
    }
    while ( FALSE ); // do-while: dummy loop to avoid gotos

    //
    // If an error occurred, delete the resource.
    //
    if ( bSuccess == FALSE )
    {
        if ( rri.BCreated() && (rri.Hresource() != NULL) )
        {
            rri.ScDelete();
        } // if:  created resource and opened successfully
    } // if:  error creating the resource

    return bSuccess;

} //*** CWizardThread::_BCreateResource()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetResourceAttributes
//
//  Routine Description:
//      Set the properties, the dependency and possible owner list of a 
//      resource. Assumes that the resource has already been created 
//      successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BSetResourceAttributes(
    IN CClusResInfo &       rri,
    IN CClusResPtrList *    plpriOldDependencies,   // = NULL
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    // Make sure that the resource is created and is valid.
    ASSERT( rri.BCreated() && (rri.Hresource() != NULL) );

    BOOL bSuccess = FALSE;
    DWORD   sc = ERROR_SUCCESS;

    // Loop to avoid goto's.
    do
    {
        //
        // Set common properties on the resource.
        //
        {
            CClusPropList   props;
            DWORD           cbProps;

            props.ScAddProp( CLUSREG_NAME_RES_DESC, rri.RstrDescription() );
            props.ScAddProp( CLUSREG_NAME_RES_SEPARATE_MONITOR, (DWORD) rri.BSeparateMonitor(), FALSE );
            props.ScAddProp( CLUSREG_NAME_RES_LOOKS_ALIVE, rri.NLooksAlive(), CLUSTER_RESOURCE_DEFAULT_LOOKS_ALIVE );
            props.ScAddProp( CLUSREG_NAME_RES_IS_ALIVE, rri.NIsAlive(), CLUSTER_RESOURCE_DEFAULT_IS_ALIVE );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_ACTION, (DWORD) rri.CrraRestartAction(), CLUSTER_RESOURCE_DEFAULT_RESTART_ACTION );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_THRESHOLD, rri.NRestartThreshold(), CLUSTER_RESOURCE_DEFAULT_RESTART_THRESHOLD );
            props.ScAddProp( CLUSREG_NAME_RES_RESTART_PERIOD, rri.NRestartPeriod(), CLUSTER_RESOURCE_DEFAULT_RESTART_PERIOD );
            props.ScAddProp( CLUSREG_NAME_RES_PENDING_TIMEOUT, rri.NPendingTimeout(), CLUSTER_RESOURCE_DEFAULT_PENDING_TIMEOUT );
            if ( props.Cprops() > 0 )
            {
                sc = ClusterResourceControl(
                                rri.Hresource(),
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_SET_COMMON_PROPERTIES,
                                props.PbPropList(),
                                static_cast< DWORD >( props.CbPropList() ),
                                NULL,   // lpOutBuffer
                                0,      // nOutBufferSize
                                &cbProps
                                );
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_SET_COMMON_RES_PROPS, rri.RstrName() );
                    break;
                } // if:  error setting common resource properties
            } // if:  any props were added

        } // Set common properties on the resource


        sc = _BSetResourceDependencies( rri, plpriOldDependencies );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        sc = _BSetPossibleOwners( rri, plpniOldPossibleOwners );
        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        bSuccess = ( sc == ERROR_SUCCESS );
    }
    while ( FALSE ); // Loop to avoid goto's.

    return bSuccess;

}  //*** CWizardThread::_BSetResourceAttributes()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetResourceDependencies
//
//  Routine Description:
//      Set the dependency list of a resource. Assumes that the resource has 
//      already been created successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpriOldDependencies    [IN] Pointer to the old resource dependency list
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::_BSetResourceDependencies(
    IN CClusResInfo &       rri,
    IN CClusResPtrList *    plpriOldDependencies    // = NULL
    )
{
    DWORD   sc = ERROR_SUCCESS;
    CClusResPtrList *           plpriDependencies   = &rri.m_lpriDependencies;

    //
    // If the old list is the same as the new list, do nothing.
    // This is a dummy while to do this check and to avoid gotos.
    //
    while ( plpriDependencies != plpriOldDependencies )
    {

        CClusResInfo *              priDep;
        CClusResPtrList::iterator   itNewDepCurrent;
        CClusResPtrList::iterator   itNewDepLast;
        CClusResPtrList::iterator   itOldDepCurrent;
        CClusResPtrList::iterator   itOldDepLast;

        //
        // Commit only the changes in the dependency list.
        // Delete those dependencies that are in old list but not in the new list.
        // Add those dependencies that are in new list but not in the old list.
        //

        // If the pointer to the old list of dependencies is NULL,
        // point it to a temporary dummy list to make code to follow simpler.
        //
        CClusResPtrList             lpriTempList;
        if ( plpriOldDependencies == NULL )
        {
            plpriOldDependencies = &lpriTempList;
        }
        else
        {
            plpriOldDependencies->sort();
        }

        //
        // The two lists need to be sorted. We do not care what order they are
        // sorted in as long as they are in a consistent order.
        // Note: Sorting invadidates the iterators
        //
        plpriDependencies->sort();

        itNewDepCurrent     = plpriDependencies->begin();
        itNewDepLast        = plpriDependencies->end();
        itOldDepCurrent     = plpriOldDependencies->begin();
        itOldDepLast        = plpriOldDependencies->end();

        while ( ( itNewDepCurrent != itNewDepLast ) &&
                ( itOldDepCurrent != itOldDepLast ) 
              )
        {
            BOOL                        bDeleteDependency;
            DWORD                       dwErrorCode;

            //
            // If the current elements in both the lists are equal, this element
            // is is both the lists. Do nothing.
            if ( *itNewDepCurrent == *itOldDepCurrent )
            {
                ++itNewDepCurrent;
                ++itOldDepCurrent;
                continue;
            }

            if ( *itNewDepCurrent > *itOldDepCurrent )
            {
                //
                // The current resource has been deleted from the old list.
                //
                priDep = *itOldDepCurrent;
                bDeleteDependency = TRUE;
                ++itOldDepCurrent;
            } // if:  the new dependency pointer is greater than the old pointer
            else
            {
                //
                // The current resource has been added to the new list.
                //
                priDep = *itNewDepCurrent;
                bDeleteDependency = FALSE;
                ++itNewDepCurrent;
            } // if:  the new dependency pointer is less than the old pointer

            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet


            if ( bDeleteDependency == FALSE )
            {
                sc = AddClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
                dwErrorCode = IDS_ERROR_ADD_DEPENDENCY;
            }
            else
            {
                sc = RemoveClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
                dwErrorCode = IDS_ERROR_REMOVE_DEPENDENCY;
            }

            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, dwErrorCode, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we have not reached the end of either list.

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more resources in the old list, remove them
        // all from the dependency list.
        //
        while ( itOldDepCurrent != itOldDepLast )
        {
            priDep = *itOldDepCurrent;
            ++itOldDepCurrent;
            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet

            sc = RemoveClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_REMOVE_DEPENDENCY, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more resources in the new list, add them
        // all to the dependency list.
        //
        while ( itNewDepCurrent != itNewDepLast )
        {
            priDep = *itNewDepCurrent;
            ++itNewDepCurrent;
            //
            // Open the resource.
            //
            if ( priDep->Hresource() == NULL )
            {
                sc = priDep->ScOpen();
                if ( sc != ERROR_SUCCESS )
                {
                    m_nte.SetOperation( sc, IDS_ERROR_OPEN_RESOURCE, priDep->RstrName() );
                    break;
                } // if:  error opening the resource
            } // if:  resource not open yet

            sc = AddClusterResourceDependency( rri.Hresource(), priDep->Hresource() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_DEPENDENCY, rri.RstrName(), priDep->RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the new list

        break;
    } // while: dummy while to avoid gotos

    return sc;

} //*** CWizardThread::_BSetResourceDependencies()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BSetPossibleOwners
//
//  Routine Description:
//      Set the possible owner list of a resource. Assumes that the resource has 
//      already been created successfully.
//
//  Arguments:
//      rri                     [IN] Resource info.
//      plpniOldPossibleOwners  [IN] Pointer to the old list of possible owner nodes
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CWizardThread::_BSetPossibleOwners(
    IN CClusResInfo &       rri,
    IN CClusNodePtrList *   plpniOldPossibleOwners  // = NULL
    )
{
    DWORD   sc = ERROR_SUCCESS;
    CClusNodePtrList *          plpniNewPossibleOwners  = &rri.m_lpniPossibleOwners;

    //
    // If the old list is the same as the new list, do nothing.
    // This is a dummy while to do this check and to avoid gotos.
    //
    while ( plpniNewPossibleOwners != plpniOldPossibleOwners )
    {
        CClusNodeInfo *             pniOwnerNodeInfo;
        CClusNodePtrList::iterator  itNewOwnersCurrent;
        CClusNodePtrList::iterator  itNewOwnersLast;
        CClusNodePtrList::iterator  itOldOwnersCurrent;
        CClusNodePtrList::iterator  itOldOwnersLast;

        //
        // Commit only the changes in the owners list.
        // Delete those owners that are in old list but not in the new list.
        // Add those owners that are in new list but not in the old list.
        //

        // If the pointer to the old list of owners is NULL,
        // point it to a temporary dummy list to make code to follow simpler.
        //
        CClusNodePtrList            lpniTempList;
        if ( plpniOldPossibleOwners == NULL )
        {
            plpniOldPossibleOwners = &lpniTempList;
        }
        else
        {
            plpniOldPossibleOwners->sort();
        }

        //
        // The two lists need to be sorted. We do not care what order they are
        // sorted in as long as they are in a consistent order.
        // Note: Sorting invadidates the iterators
        //
        plpniNewPossibleOwners->sort();

        itNewOwnersCurrent  = plpniNewPossibleOwners->begin();
        itNewOwnersLast     = plpniNewPossibleOwners->end();
        itOldOwnersCurrent  = plpniOldPossibleOwners->begin();
        itOldOwnersLast     = plpniOldPossibleOwners->end();

        while ( ( itNewOwnersCurrent != itNewOwnersLast ) &&
                ( itOldOwnersCurrent != itOldOwnersLast ) 
              )
        {
            BOOL                        bDeletePossibleOwner;
            DWORD                       dwErrorCode;

            //
            // If the current elements in both the lists are equal, this element
            // is is both the lists. Do nothing.
            if ( *itNewOwnersCurrent == *itOldOwnersCurrent )
            {
                ++itNewOwnersCurrent;
                ++itOldOwnersCurrent;
                continue;
            }

            if ( *itNewOwnersCurrent > *itOldOwnersCurrent )
            {
                //
                // The current resource has been deleted from the old list.
                //
                pniOwnerNodeInfo = *itOldOwnersCurrent;
                bDeletePossibleOwner = TRUE;
                ++itOldOwnersCurrent;
            } // if:  the new possible owner pointer is greater than the old pointer
            else
            {
                //
                // The current resource has been added to the new list.
                //
                pniOwnerNodeInfo = *itNewOwnersCurrent;
                bDeletePossibleOwner = FALSE;
                ++itNewOwnersCurrent;
            } // if:  the new possible owner pointer is less than the old pointer

            if ( bDeletePossibleOwner == FALSE )
            {
                sc = AddClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
                dwErrorCode = IDS_ERROR_ADD_RESOURCE_OWNER;
            }
            else
            {
                sc = RemoveClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
                dwErrorCode = IDS_ERROR_REMOVE_RESOURCE_OWNER;
            }

            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, dwErrorCode, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we have not reached the end of either list.

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more nodes in the old list, remove them
        // all from the possible owners list.
        //
        while ( itOldOwnersCurrent != itOldOwnersLast )
        {
            pniOwnerNodeInfo = *itOldOwnersCurrent;
            ++itOldOwnersCurrent;

            sc = RemoveClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_REMOVE_RESOURCE_OWNER, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        if ( sc != ERROR_SUCCESS )
        {
            break;
        }

        //
        // If there are any more nodes in the new list, add them
        // all to the possible owners list.
        //
        while ( itNewOwnersCurrent != itNewOwnersLast )
        {
            pniOwnerNodeInfo = *itNewOwnersCurrent;
            ++itNewOwnersCurrent;

            sc = AddClusterResourceNode( rri.Hresource(), pniOwnerNodeInfo->Hnode() );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_ADD_RESOURCE_OWNER, pniOwnerNodeInfo->RstrName(), rri.RstrName() );
                break;
            } // if:  error setting dependency.
        } // while:  we are not at the end of the old list

        break;
    } // while: dummy while to avoid gotos

    return sc;
} //*** CWizardThread::_BSetPossibleOwners()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BDeleteResource
//
//  Routine Description:
//      Delete a resource.
//
//  Arguments:
//      rri         [IN] Resource info.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BDeleteResource(
    IN CClusResInfo & rri
    )
{
    BOOL        bSuccess = FALSE;
    DWORD       sc = ERROR_SUCCESS;

    if ( ! rri.BCreated() )
    {
        return TRUE;
    } // if:  resource not created

    // Loop to avoid goto's.
    do
    {
        //
        // Open the resource.
        //
        if ( rri.Hresource() == NULL )
        {
            sc = rri.ScOpen();
            if ( sc != ERROR_SUCCESS )
            {
                break;
            } // if:  error opening the resource
        } // if:  resource not open yet

        //
        // Delete the resource.
        //
        sc = rri.ScDelete();
        if ( sc != ERROR_SUCCESS )
        {
            break;
        } // if:  error deleting the resource

        //
        // If we made it to here, the operation was successful.
        //
        bSuccess = TRUE;

    } while ( 0 );

    //
    // Handle errors.
    //
    if ( sc != ERROR_SUCCESS )
    {
        m_nte.SetOperationIfEmpty(
            sc,
            IDS_ERROR_DELETE_RESOURCE,
            rri.RstrName()
            );
    } // if:  error occurred

    return bSuccess;

} //*** CWizardThread::_BDeleteResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CWizardThread::_BReadAdminExtensions
//
//  Routine Description:
//      Read admin extensions directly from the cluster database.
//
//  Arguments:
//      pszKey      [IN] Key from which to read extensions.
//      rlstr       [OUT] List in which to return extension CLSIDs.
//
//  Return Value:
//      TRUE        Operation completed successfully.
//      FALSE       Error performing the operation.  Check m_nte for details.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CWizardThread::_BReadAdminExtensions(
    IN LPCWSTR                  pszKey,
    OUT std::list< CString > &  rlstr
    )
{
    ASSERT( Pwiz()->Hcluster() != NULL );

    BOOL    bSuccess = FALSE;
    HKEY    hkeyCluster = NULL;
    HKEY    hkeySubKey = NULL;
    HKEY    hkey;
    DWORD   sc;
    DWORD   dwType;
    LPWSTR  pszData = NULL;
    DWORD   cbData;

    // Loop to avoid goto's.
    do
    {
        //
        // Get the cluster key.
        //
        hkeyCluster = GetClusterKey( Pwiz()->Hcluster(), KEY_READ );
        if ( hkeyCluster == NULL )
        {
            m_nte.SetOperation( GetLastError(), IDS_ERROR_GET_CLUSTER_KEY );
            break;
        } // if:  error getting the cluster key

        //
        // Open the subkey if specified.
        //
        if ( pszKey != NULL )
        {
            sc = ClusterRegOpenKey( hkeyCluster, pszKey, KEY_READ, &hkeySubKey );
            if ( sc != ERROR_SUCCESS )
            {
                m_nte.SetOperation( sc, IDS_ERROR_OPEN_CLUSTER_KEY, pszKey );
                break;
            } // if:  error opening the subkey
            hkey = hkeySubKey;
        } // if:  subkey specified
        else
        {
            hkey = hkeyCluster;
        } // else:  no subkey specified

        //
        // Get the length of the AdminExtensions value.
        //
        cbData = 0;
        sc = ClusterRegQueryValue( hkey, CLUSREG_NAME_ADMIN_EXT, &dwType, NULL, &cbData );
        if ( sc != ERROR_SUCCESS )
        {
            if ( sc == ERROR_FILE_NOT_FOUND )
            {
                bSuccess = TRUE;
            } // if:  value didn't exist
            else
            {
                m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            } // else:  other error occurred
            break;
        } // if:  error reading extensions value

        //
        // Allocate a buffer for the value data.
        //
        pszData = new WCHAR[ cbData / sizeof( WCHAR ) ];
        if ( pszData == NULL )
        {
            sc = GetLastError();
            m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            break;
        } // if: error allocating the buffer

        //
        // Read the AdminExtensions value.
        //
        sc = ClusterRegQueryValue(
                        hkey,
                        CLUSREG_NAME_ADMIN_EXT,
                        &dwType,
                        reinterpret_cast< LPBYTE >( pszData ),
                        &cbData
                        );
        if ( sc != ERROR_SUCCESS )
        {
            m_nte.SetOperation( sc, IDS_ERROR_QUERY_VALUE, CLUSREG_NAME_ADMIN_EXT );
            break;
        } // if:  error reading extensions value

        //
        // Add each extension to the list.
        //
        LPWSTR pszEntry = pszData;
        while ( *pszEntry != L'\0' )
        {
            rlstr.insert( rlstr.end(), pszEntry );
            pszEntry += wcslen( pszEntry ) + 1;
        } // while:  more entries in the list

        bSuccess = TRUE;
    } while ( 0 );

    //
    // Cleanup.
    //
    if ( hkeyCluster != NULL )
    {
        ClusterRegCloseKey( hkeyCluster );
    } // if:  cluster key is open
    if ( hkeySubKey != NULL )
    {
        ClusterRegCloseKey( hkeySubKey );
    } // if:  sub key is open
    if ( pszData != NULL )
    {
        delete [] pszData;
    } // if:  data was allocated

    return bSuccess;

} //*** CWizardThread::_BReadAdminExtensions()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\aclbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2002 Microsoft Corporation
//
//  Module Name:
//      AclBase.h
//
//  Description:
//      Implementation of the ISecurityInformation interface.  This interface
//      is the new common security UI in NT 5.0.
//
//  Implementation File:
//      AclBase.cpp
//
//  Author:
//      Galen Barbee    (galenb)    February 6, 1998
//          From \nt\private\admin\snapin\filemgmt\permpage.h
//          by JonN
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLBASE_H
#define _ACLBASE_H

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLUI_H_
#include <aclui.h>      // for ISecurityInformation
#endif // _ACLUI_H_

#include "CluAdmEx.h"

#include <ObjSel.h>

//
// Stuff used for initializing the Object Picker below
//

#define DSOP_FILTER_COMMON1 ( DSOP_FILTER_INCLUDE_ADVANCED_VIEW  \
                            | DSOP_FILTER_USERS                  \
                            | DSOP_FILTER_UNIVERSAL_GROUPS_SE    \
                            | DSOP_FILTER_GLOBAL_GROUPS_SE       \
                            | DSOP_FILTER_COMPUTERS              \
                            )
#define DSOP_FILTER_COMMON2 ( DSOP_FILTER_COMMON1                \
                            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS  \
                            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE \
                            )
#define DSOP_FILTER_COMMON3 ( DSOP_FILTER_COMMON2                \
                            | DSOP_FILTER_BUILTIN_GROUPS         \
                            )
#define DSOP_FILTER_DL_COMMON1      ( DSOP_DOWNLEVEL_FILTER_USERS           \
                                    | DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS   \
                                    )
#define DSOP_FILTER_DL_COMMON2      ( DSOP_FILTER_DL_COMMON1                    \
                                    | DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS  \
                                    )
#define DSOP_FILTER_DL_COMMON3      ( DSOP_FILTER_DL_COMMON2                \
                                    | DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS    \
                                    )

//
//  Documentation of the DSOP_SCOPE_INIT_INFO struct so you can see how the macros below
//  fill it in...
//
/*
{   // DSOP_SCOPE_INIT_INFO
    cbSize,
    flType,
    flScope,
    {   // DSOP_FILTER_FLAGS
        {   // DSOP_UPLEVEL_FILTER_FLAGS
            flBothModes,
            flMixedModeOnly,
            flNativeModeOnly
        },
        flDownlevel
    },
    pwzDcName,
    pwzADsPath,
    hr // OUT
}
*/

#define DECLARE_SCOPE(t,f,b,m,n,d)  \
{ sizeof(DSOP_SCOPE_INIT_INFO), (t), (f|DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS|DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS), { { (b), (m), (n) }, (d) }, NULL, NULL, S_OK }

//
//  The domain to which the target computer is joined.
//  Make 2 scopes, one for uplevel domains, the other for downlevel.
//

#define JOINED_DOMAIN_SCOPE(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON2 & ~(DSOP_FILTER_UNIVERSAL_GROUPS_SE|DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE)),DSOP_FILTER_COMMON2,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON2)

//
//  The domain for which the target computer is a Domain Controller.
//  Make 2 scopes, one for uplevel domains, the other for downlevel.
//

#define JOINED_DOMAIN_SCOPE_DC(f)  \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,(f),0,(DSOP_FILTER_COMMON3 & ~DSOP_FILTER_UNIVERSAL_GROUPS_SE),DSOP_FILTER_COMMON3,0), \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

//
//  Target computer scope.  Computer scopes are always treated as
//  downlevel (i.e., they use the WinNT provider).
//

#define TARGET_COMPUTER_SCOPE(f)\
DECLARE_SCOPE(DSOP_SCOPE_TYPE_TARGET_COMPUTER,(f),0,0,0,DSOP_FILTER_DL_COMMON3)

//
//  The Global Catalog
//

#define GLOBAL_CATALOG_SCOPE(f) \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_GLOBAL_CATALOG,(f),DSOP_FILTER_COMMON1|DSOP_FILTER_WELL_KNOWN_PRINCIPALS,0,0,0)

//
//  The domains in the same forest (enterprise) as the domain to which
//  the target machine is joined.  Note these can only be DS-aware
//

#define ENTERPRISE_SCOPE(f)     \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,(f),DSOP_FILTER_COMMON1,0,0,0)

//
//  Domains external to the enterprise but trusted directly by the
//  domain to which the target machine is joined.
//

#define EXTERNAL_SCOPE(f)       \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN|DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,\
    (f),DSOP_FILTER_COMMON1,0,0,DSOP_DOWNLEVEL_FILTER_USERS|DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)

//
//  Workgroup scope.  Only valid if the target computer is not joined
//  to a domain.
//

#define WORKGROUP_SCOPE(f)      \
DECLARE_SCOPE(DSOP_SCOPE_TYPE_WORKGROUP,(f),0,0,0, DSOP_FILTER_DL_COMMON1|DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS )

//
// Array of Default Scopes
//

static const DSOP_SCOPE_INIT_INFO g_aDefaultScopes[] =
{
    JOINED_DOMAIN_SCOPE(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    TARGET_COMPUTER_SCOPE(0),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};

//
//  Same as above, but without the Target Computer.  Used when the target is a Domain Controller.
//

//
//  KB: 21-MAY-2002 GalenB
//
//  This array of scopes is not currently being used since these scopes are only interestng for a mixed mode
//  domain where all of the member nodes of the cluster are domain controllers or backup domain controllers.
//  This is the only configuration where domain local groups can be used in a cluster SD when the default
//  scopes above will not allow the user to pick them.
//
/*
static const DSOP_SCOPE_INIT_INFO g_aDCScopes[] =
{
    JOINED_DOMAIN_SCOPE_DC(DSOP_SCOPE_FLAG_STARTING_SCOPE),
    GLOBAL_CATALOG_SCOPE(0),
    ENTERPRISE_SCOPE(0),
    EXTERNAL_SCOPE(0),
};
*/
/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CSecurityInformation;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSecurityInformation security wrapper
/////////////////////////////////////////////////////////////////////////////

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot, public IDsObjectPicker
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
        COM_INTERFACE_ENTRY(IDsObjectPicker)
    END_COM_MAP()
#ifndef END_COM_MAP_ADDREF
    // *** IUnknown methods ***
    STDMETHOD_(ULONG, AddRef)( void )
    {
        return InternalAddRef();

    }

    STDMETHOD_(ULONG, Release)( void )
    {
        ULONG l = InternalRelease();

        if (l == 0)
        {
            delete this;
        }

        return l;

    }
#endif
    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation)( PSI_OBJECT_INFO pObjectInfo );

    STDMETHOD(GetSecurity)( SECURITY_INFORMATION    RequestedInformation,
                            PSECURITY_DESCRIPTOR *  ppSecurityDescriptor,
                            BOOL                    fDefault ) = 0;

    STDMETHOD(SetSecurity)( SECURITY_INFORMATION    SecurityInformation,
                            PSECURITY_DESCRIPTOR    pSecurityDescriptor );

    STDMETHOD(GetAccessRights)( const GUID *    pguidObjectType,
                                DWORD           dwFlags,
                                PSI_ACCESS *    ppAccess,
                                ULONG *         pcAccesses,
                                ULONG *         piDefaultAccess );

    STDMETHOD(MapGeneric)( const GUID *     pguidObjectType,
                           UCHAR *          pAceFlags,
                           ACCESS_MASK *    pMask );

    STDMETHOD(GetInheritTypes)( PSI_INHERIT_TYPE * ppInheritTypes,
                                ULONG * pcInheritTypes );

    STDMETHOD(PropertySheetPageCallback)( HWND hwnd, UINT uMsg, SI_PAGE_TYPE uPage );

    // IDsObjectPicker
    STDMETHODIMP Initialize( PDSOP_INIT_INFO pInitInfo );

    STDMETHODIMP InvokeDialog( HWND hwndParent, IDataObject ** ppdoSelection );

protected:
    CSecurityInformation( void );
    ~CSecurityInformation( void );

    HRESULT HrLocalAccountsInSD( IN PSECURITY_DESCRIPTOR pSD, OUT PBOOL pFound );

    PGENERIC_MAPPING    m_pShareMap;
    PSI_ACCESS          m_psiAccess;
    int                 m_nDefAccess;
    int                 m_nAccessElems;
    DWORD               m_dwFlags;
    CString             m_strServer;
    CString             m_strNode;
    int                 m_nLocalSIDErrorMessageID;
    IDsObjectPicker *   m_pObjectPicker;
    LONG                m_cRef;

};

#endif //_ACLBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	May 30, 1997
//
//	Revision History:
//
//	Notes:
//		Dummy file for not implementing BARF.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

/////////////////////////////////////////////////////////////////////////////

#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\aclutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		AclUtils.h
//
//	Abstract:
//		Various Access Control List (ACL) utilities.
//
//	Implementation File:
//		AclUtils.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACLUTILS_H
#define _ACLUTILS_H

#ifndef _ACLBASE_H
#include "AclBase.h"
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

extern HPROPSHEETPAGE
CreateClusterSecurityPage(
	CSecurityInformation* psecinfo
	);

#endif //_ACLUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\basedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.h
//
//	Abstract:
//		Definition of the CBaseDialogclass.  This class provides base
//		functionality for extension DLL dialogs.
//
//	Implementation File:
//		BaseDlg.cpp
//
//	Author:
//		David Potter (davidp)	April 30, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#define _BASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog dialog
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog : public CDialog
{
	DECLARE_DYNCREATE(CBaseDialog)

// Construction
public:
	CBaseDialog(void);
	CBaseDialog(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN CWnd *			pParentWnd
		);
	virtual ~CBaseDialog(void) { }

// Attributes

// Dialog Data
	//{{AFX_DATA(CBaseDialog)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseDialog)
	//}}AFX_VIRTUAL

// Implementation
protected:
	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBaseDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      BasePage.cpp
//
//  Abstract:
//      Implementation of the CBasePropertyPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//      1. Removed the calls to UpdateData from OnWizardNext and OnApply
//         since OnKillActive, called before both these functions does a
//         data update anyway.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "BasePage.h"
#include "BasePage.inl"
#include "PropList.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CBasePropertyPage, CPropertyPage )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBasePropertyPage, CPropertyPage )
    //{{AFX_MSG_MAP(CBasePropertyPage)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_HELPINFO()
    ON_WM_CONTEXTMENU()
    ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage( void )
{
    CommonConstruct();

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap
    )
    : m_dlghelp( pdwHelpMap, 0 )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CBasePropertyPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      idd                 [IN] Dialog template resource ID.
//      pdwHelpMap          [IN] Control-to-help ID map.
//      pdwWizardHelpMap    [IN] Control-to-help ID map if this is a wizard page.
//      nIDCaption          [IN] Caption string resource ID.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
    IN UINT             idd,
    IN const DWORD *    pdwHelpMap,
    IN const DWORD *    pdwWizardHelpMap,
    IN UINT             nIDCaption
    )
    : CPropertyPage( idd, nIDCaption )
    , m_dlghelp( pdwHelpMap, idd )
{
    CommonConstruct();
    m_pdwWizardHelpMap = pdwWizardHelpMap;

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::CommonConstruct( void )
{
    //{{AFX_DATA_INIT(CBasePropertyPage)
    //}}AFX_DATA_INIT

    m_peo = NULL;
    m_hpage = NULL;
    m_bBackPressed = FALSE;
    m_bSaved = FALSE;

    m_iddPropertyPage = NULL;
    m_iddWizardPage = NULL;
    m_idsCaption = NULL;

    m_pdwWizardHelpMap = NULL;

    m_bDoDetach = FALSE;

}  //*** CBasePropertyPage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertyPage::HrInit( IN OUT CExtObject * peo )
{
    ASSERT( peo != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT     hr = S_OK;
    CWaitCursor wc;

    m_peo = peo;

    // Change the help map if this is a wizard page.
    if ( Peo()->BWizard() )
    {
        m_dlghelp.SetMap( m_pdwWizardHelpMap );
    } // if: on wizard page

    // Don't display a help button.
    m_psp.dwFlags &= ~PSP_HASHELP;

    // Construct the property page.
    if ( Peo()->BWizard() )
    {
        ASSERT( IddWizardPage() != NULL );
        Construct( IddWizardPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddWizardPage() );
    }  // if:  adding page to wizard
    else
    {
        ASSERT( IddPropertyPage() != NULL );
        Construct( IddPropertyPage(), IdsCaption() );
        m_dlghelp.SetHelpMask( IddPropertyPage() );
    }  // else:  adding page to property sheet

    // Read the properties private to this resource and parse them.
    {
        DWORD           sc;
        CClusPropList   cpl;

        ASSERT( Peo() != NULL );
        ASSERT( Peo()->PrdResData() != NULL );
        ASSERT( Peo()->PrdResData()->m_hresource != NULL );

        // Get the read-write private properties.
        sc = cpl.ScGetResourceProperties(
                                Peo()->PrdResData()->m_hresource,
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES
                                );

        // Parse the properties.
        if ( sc == ERROR_SUCCESS )
        {
            // Parse the properties.
            try
            {
                sc = ScParseProperties( cpl );
            }  // try
            catch ( CMemoryException * pme )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  Properties read successfully.

        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, IDS_ERROR_GETTING_PROPERTIES, NULL, NULL, FALSE );
            nte.ReportError();
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }  // if:  Error getting or parsing properties.

        // Get the read-only private properties.
        sc = cpl.ScGetResourceProperties(
                                Peo()->PrdResData()->m_hresource,
                                CLUSCTL_RESOURCE_GET_RO_PRIVATE_PROPERTIES
                                );

        // Parse the properties.
        if ( sc == ERROR_SUCCESS )
        {
            // Parse the properties.
            try
            {
                sc = ScParseProperties( cpl );
            }  // try
            catch ( CMemoryException * pme )
            {
                sc = ERROR_NOT_ENOUGH_MEMORY;
                pme->Delete();
            }  // catch:  CMemoryException
        }  // if:  Properties read successfully.

        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, IDS_ERROR_GETTING_PROPERTIES, NULL, NULL, FALSE );
            nte.ReportError();
            hr = HRESULT_FROM_WIN32( sc );
            goto Cleanup;
        }  // if:  Error getting or parsing properties.
    }  // Read the properties private to this resource and parse them.

Cleanup:
    return hr;

}  //*** CBasePropertyPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from HrInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//      Any error returns from ScParseUnknownProperty().
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScParseProperties( IN CClusPropList & rcpl )
{
    DWORD                   sc;
    DWORD                   cprop;
    const CObjectProperty * pprop;

    ASSERT( rcpl.PbPropList() != NULL );

    sc = rcpl.ScMoveToFirstProperty();
    while ( sc == ERROR_SUCCESS )
    {
        //
        // Parse known properties.
        //
        for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
        {
            if ( ClRtlStrNICmp( rcpl.PszCurrentPropertyName(), pprop->m_pwszName, rcpl.CbhCurrentPropertyName().pValue->cbLength / sizeof( WCHAR ) ) == 0 )
            {
                ASSERT( rcpl.CpfCurrentValueFormat() == pprop->m_propFormat );
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT( ( rcpl.CbCurrentValueLength() == (wcslen( rcpl.CbhCurrentValue().pStringValue->sz ) + 1) * sizeof( WCHAR ) )
                             || (   ( rcpl.CbCurrentValueLength() == 0 )
                                 && ( rcpl.CbhCurrentValue().pStringValue->sz[ 0 ] == L'\0' )
                                )
                              );
                        *pprop->m_value.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                        *pprop->m_valuePrev.pstr = rcpl.CbhCurrentValue().pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( rcpl.CbCurrentValueLength() == sizeof( DWORD ) );
                        *pprop->m_value.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                        *pprop->m_valuePrev.pdw = rcpl.CbhCurrentValue().pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        delete [] *pprop->m_value.ppb;
                        *pprop->m_value.ppb = new BYTE[ rcpl.CbhCurrentValue().pBinaryValue->cbLength ];
                        if ( *pprop->m_value.ppb == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if:

                        CopyMemory( *pprop->m_value.ppb, rcpl.CbhCurrentValue().pBinaryValue->rgb, rcpl.CbhCurrentValue().pBinaryValue->cbLength );
                        *pprop->m_value.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;

                        delete [] *pprop->m_valuePrev.ppb;
                        *pprop->m_valuePrev.ppb = new BYTE[ rcpl.CbhCurrentValue().pBinaryValue->cbLength ];
                        if ( *pprop->m_valuePrev.ppb == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if:

                        CopyMemory( *pprop->m_valuePrev.ppb, rcpl.CbhCurrentValue().pBinaryValue->rgb, rcpl.CbhCurrentValue().pBinaryValue->cbLength );
                        *pprop->m_valuePrev.pcb = rcpl.CbhCurrentValue().pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                } // switch: property format

                // Exit the loop since we found the parameter.
                break;
            } // if: found a match
        } // for: each property that we know about

        //
        // If the property wasn't known, ask the derived class to parse it.
        //
        if ( cprop == 0 )
        {
            sc = ScParseUnknownProperty(
                        rcpl.CbhCurrentPropertyName().pName->sz,
                        rcpl.CbhCurrentValue(),
                        static_cast< DWORD >( rcpl.RPvlPropertyValue().CbDataLeft() )
                        );
            if ( sc != ERROR_SUCCESS )
            {
                return sc;
            } // if: error parsing the unknown property
        } // if: property not parsed

        //
        // Advance the buffer pointer past the value in the value list.
        //
        sc = rcpl.ScMoveToNextProperty();
    } // while: more properties to parse

    //
    // If we reached the end of the properties, fix the return code.
    //
    if ( sc == ERROR_NO_MORE_ITEMS )
    {
        sc = ERROR_SUCCESS;
    } // if: ended loop after parsing all properties

    return sc;

}  //*** CBasePropertyPage::ScParseProperties()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCreate
//
//  Routine Description:
//      Handler for the WM_CREATE message.
//
//  Arguments:
//      lpCreateStruct  [IN OUT] Window create structure.
//
//  Return Value:
//      -1      Error.
//      0       Success.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CBasePropertyPage::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Attach the window to the property page structure.
    // This has been done once already in the main application, since the
    // main application owns the property sheet.  It needs to be done here
    // so that the window handle can be found in the DLL's handle map.
    if ( FromHandlePermanent( m_hWnd ) == NULL ) // is the window handle already in the handle map
    {
        HWND hWnd = m_hWnd;
        m_hWnd = NULL;
        Attach( hWnd );
        m_bDoDetach = TRUE;
    } // if: is the window handle in the handle map

    return CPropertyPage::OnCreate( lpCreateStruct );

}  //*** CBasePropertyPage::OnCreate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnDestroy( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Detach the window from the property page structure.
    // This will be done again by the main application, since it owns the
    // property sheet.  It needs to be done here so that the window handle
    // can be removed from the DLL's handle map.
    if ( m_bDoDetach )
    {
        if ( m_hWnd != NULL )
        {
            HWND hWnd = m_hWnd;

            Detach();
            m_hWnd = hWnd;
        } // if: do we have a window handle?
    } // if: do we need to balance the attach we did with a detach?

    CPropertyPage::OnDestroy();

}  //*** CBasePropertyPage::OnDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DoDataExchange( CDataExchange * pDX )
{
    if ( ! pDX->m_bSaveAndValidate || !BSaved() )
    {
        AFX_MANAGE_STATE( AfxGetStaticModuleState() );

        //{{AFX_DATA_MAP(CBasePropertyPage)
            // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
        DDX_Control( pDX, IDC_PP_ICON, m_staticIcon );
        DDX_Control( pDX, IDC_PP_TITLE, m_staticTitle );

        if ( pDX->m_bSaveAndValidate )
        {
            if ( ! BBackPressed() )
            {
                CWaitCursor wc;

                // Validate the data.
                if ( ! BSetPrivateProps( TRUE /*bValidateOnly*/ ) )
                {
                    pDX->Fail();
                } // if: error setting private properties
            }  // if:  Back button not pressed
        }  // if:  saving data from dialog
        else
        {
            // Set the title.
            DDX_Text( pDX, IDC_PP_TITLE, m_strTitle );
        }  // if:  not saving data
    }  // if:  not saving or haven't saved yet

    CPropertyPage::DoDataExchange( pDX );

}  //*** CBasePropertyPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnInitDialog( void )
{
    ASSERT( Peo() != NULL );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    // Call the base class method.
    CPropertyPage::OnInitDialog();

    // Display an icon for the object.
    if ( Peo()->Hicon() != NULL )
    {
        m_staticIcon.SetIcon( Peo()->Hicon() );
    } // if: icon was specified

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePropertyPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnSetActive( void )
{
    HRESULT     hr;

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    // Reread the data.
    hr = Peo()->HrGetObjectInfo();
    if ( hr != NOERROR )
    {
        return FALSE;
    } // if: error getting object info

    // Set the title string.
    m_strTitle = Peo()->RrdResData().m_strName;

    m_bBackPressed = FALSE;
    m_bSaved = FALSE;
    return CPropertyPage::OnSetActive();

}  //*** CBasePropertyPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnApply
//
//  Routine Description:
//      Handler for the PSM_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnApply( void )
{
    ASSERT( ! BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor wc;

    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnApply();

}  //*** CBasePropertyPage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardBack
//
//  Routine Description:
//      Handler for the PSN_WIZBACK message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardBack( void )
{
    LRESULT     lResult;

    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    lResult = CPropertyPage::OnWizardBack();
    if ( lResult != -1 )
    {
        m_bBackPressed = TRUE;
    } // if: back processing performed successfully

    return lResult;

}  //*** CBasePropertyPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardNext
//
//  Routine Description:
//      Handler for the PSN_WIZNEXT message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      -1      Don't change the page.
//      0       Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnWizardNext( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor _wc;

    // Update the data in the class from the page.
    // This necessary because, while OnKillActive() will call UpdateData(),
    // it is called after this method is called, and we need to be sure that
    // data has been saved before we apply them.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return -1;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return -1;
    } // if: error applying changes

    // Create the object.

    return CPropertyPage::OnWizardNext();

}  //*** CBasePropertyPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnWizardFinish
//
//  Routine Description:
//      Handler for the PSN_WIZFINISH message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      FALSE   Don't change the page.
//      TRUE    Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnWizardFinish( void )
{
    ASSERT( BWizard() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    CWaitCursor wc;

    // BUG! There should be no need to call UpdateData in this function.
    // See BUG: Finish Button Fails Data Transfer from Page to Variables
    // MSDN Article ID: Q150349

    // Update the data in the class from the page.
    if ( ! UpdateData( TRUE /*bSaveAndValidate*/ ) )
    {
        return FALSE;
    } // if: error updating data

    // Save the data in the sheet.
    if ( ! BApplyChanges() )
    {
        return FALSE;
    } // if: error applying changes

    return CPropertyPage::OnWizardFinish();

}  //*** CBasePropertyPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnChangeCtrl
//
//  Routine Description:
//      Handler for the messages sent when a control is changed.  This
//      method can be specified in a message map if all that needs to be
//      done is enable the Apply button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnChangeCtrl( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    SetModified( TRUE );

}  //*** CBasePropertyPage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::EnableNext( IN BOOL bEnable /*TRUE*/ )
{
    ASSERT( BWizard() );
    ASSERT( PiWizardCallback() );

    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    PiWizardCallback()->EnableNext( (LONG *) Hpage(), bEnable );

}  //*** CBasePropertyPage::EnableNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BApplyChanges( void )
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    BOOL        bSuccess;
    CWaitCursor wc;

    // Make sure required dependencies have been set.
    if ( ! BSetPrivateProps() )
    {
        bSuccess = FALSE;
    } // if: all required dependencies are not present
    else
    {
        // Save data.
        bSuccess = BRequiredDependenciesPresent();
    } // else: all required dependencies are present

    return bSuccess;

}  //*** CBasePropertyPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BBuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      TRUE        Property list built successfully.
//      FALSE       Error building property list.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL                    bNewPropsFound = FALSE;
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
    {
        if ( bNoNewProps && ( pprop->m_fFlags & CObjectProperty::opfNew ) )
        {
            bNewPropsFound = TRUE;
            continue;
        } // if:  no new props allowed and this is a new property

        switch ( pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_EXPAND_SZ:
                rcpl.ScAddExpandSzProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_LONG:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pl,
                        *pprop->m_valuePrev.pl
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 );  // don't know how to deal with this type
                return FALSE;
        }  // switch:  property format
    }  // for:  each property

    return ( ! bNoNewProps || bNewPropsFound );

}  //*** CBasePropertyPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BSetPrivateProps
//
//  Routine Description:
//      Set the private properties for this object.
//
//  Arguments:
//      bValidateOnly   [IN] TRUE = only validate the data.
//      bNoNewProps     [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      ERROR_SUCCESS   The operation was completed successfully.
//      !0              Failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BSetPrivateProps(
    IN BOOL bValidateOnly,  // = FALSE
    IN BOOL bNoNewProps     // = FALSE
    )
{
    BOOL            bSuccess   = TRUE;
    CClusPropList   cpl(BWizard() /*bAlwaysAddProp*/);

    ASSERT( Peo() != NULL );
    ASSERT( Peo()->PrdResData() );
    ASSERT( Peo()->PrdResData()->m_hresource );

    // Build the property list.
    try
    {
        bSuccess = BBuildPropList( cpl, bNoNewProps );
    }  // try
    catch ( CException * pe )
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  CException

    // Set the data.
    if ( bSuccess )
    {
        if ( ( cpl.PbPropList() != NULL ) && ( cpl.CbPropList() > 0 ) )
        {
            DWORD       sc;
            DWORD       dwControlCode;
            DWORD       cbProps;

            // Determine which control code to use.
            if ( bValidateOnly )
            {
                dwControlCode = CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES;
            } // if: only validating
            else
            {
                dwControlCode = CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES;
            } // else: not just validating

            // Set private properties.
            sc = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,   // hNode
                            dwControlCode,
                            cpl.PbPropList(),
                            static_cast< DWORD >( cpl.CbPropList() ),
                            NULL,   // lpOutBuffer
                            0,      // nOutBufferSize
                            &cbProps
                            );
            if ( sc != ERROR_SUCCESS )
            {
                if ( sc == ERROR_INVALID_PARAMETER )
                {
                    if ( ! bNoNewProps )
                    {
                        bSuccess = BSetPrivateProps( bValidateOnly, TRUE /*bNoNewProps*/ );
                    } // if:  new props are allowed
                    else
                    {
                        bSuccess = FALSE;
                    } // else: new props are not allowed
                } // if:  invalid parameter error occurred
                else
                {
                    bSuccess = FALSE;
                } // else: some other error occurred
            }  // if:  error setting/validating data

            //
            // If an error occurred, display an error message.
            //
            if ( ! bSuccess )
            {
                DisplaySetPropsError( sc, bValidateOnly ? IDS_ERROR_VALIDATING_PROPERTIES : IDS_ERROR_SETTING_PROPERTIES );
                if ( sc == ERROR_RESOURCE_PROPERTIES_STORED )
                {
                    bSuccess = TRUE;
                } // if: properties only stored
            } // if:  error occurred
        }  // if:  there is data to set
    }  // if:  no errors building the property list

    // Save data locally.
    if ( ! bValidateOnly && bSuccess )
    {
        // Save new values as previous values.
        try
        {
            DWORD                   cprop;
            const CObjectProperty * pprop;

            for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
            {
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                    case CLUSPROP_FORMAT_EXPAND_SZ:
                        ASSERT( pprop->m_value.pstr != NULL );
                        ASSERT( pprop->m_valuePrev.pstr != NULL );
                        *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( pprop->m_value.pdw != NULL );
                        ASSERT( pprop->m_valuePrev.pdw != NULL );
                        *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( pprop->m_value.ppb != NULL );
                        ASSERT( *pprop->m_value.ppb != NULL );
                        ASSERT( pprop->m_value.pcb != NULL );
                        ASSERT( pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *pprop->m_valuePrev.ppb != NULL );
                        ASSERT( pprop->m_valuePrev.pcb != NULL );
                        delete [] *pprop->m_valuePrev.ppb;
                        *pprop->m_valuePrev.ppb = new BYTE[ *pprop->m_value.pcb ];
                        if ( *pprop->m_valuePrev.ppb == NULL )
                        {
                            AfxThrowMemoryException();
                        } // if: error allocating memory
                        CopyMemory( *pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb );
                        *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 );    // don't know how to deal with this type
                }  // switch:  property format
            }  // for:  each property
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  // if:  not just validating and successful so far

    //
    // Indicate we successfully saved the properties.
    //
    if ( ! bValidateOnly && bSuccess )
    {
        m_bSaved = TRUE;
    } // if:  successfully saved data

    return bSuccess;

}  //*** CBasePropertyPage::BSetPrivateProps()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::DisplaySetPropsError
//
//  Routine Description:
//      Display an error caused by setting or validating properties.
//
//  Arguments:
//      sc      [IN] Status to display error on.
//      idsOper [IN] Operation message.
//
//  Return Value:
//      nStatus ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::DisplaySetPropsError(
    IN DWORD    sc,
    IN UINT     idsOper
    ) const
{
    CString strErrorMsg;
    CString strOperMsg;
    CString strMsgIdFmt;
    CString strMsgId;
    CString strMsg;

    strOperMsg.LoadString( IDS_ERROR_SETTING_PROPERTIES );
    FormatError( strErrorMsg, sc );
    strMsgIdFmt.LoadString( IDS_ERROR_MSG_ID );
    strMsgId.Format( strMsgIdFmt, sc, sc );
    strMsg.Format( _T("%s\n\n%s%s"), strOperMsg, strErrorMsg, strMsgId );
    AfxMessageBox( strMsg );

}  //*** CBasePropertyPage::DisplaySetPropsError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BRequiredDependenciesPresent
//
//  Routine Description:
//      Determine if the specified list contains each required resource
//      for this type of resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::LoadString() or CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BRequiredDependenciesPresent( void )
{
    BOOL                        bFound = TRUE;
    DWORD                       sc;
    CClusPropValueList          pvl;
    HRESOURCE                   hres;
    PCLUS_RESOURCE_CLASS_INFO   prci = NULL;
    CString                     strMissing;

    do
    {
        // Collect the list of required dependencies.
        sc = pvl.ScGetResourceValueList(
                    Peo()->PrdResData()->m_hresource,
                    CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES
                    );
        if ( sc != ERROR_SUCCESS )
        {
            CNTException nte( sc, 0, NULL, NULL, FALSE );
            nte.ReportError();
            break;
        } // if: error collecting required dependencies

        // Move to the first value.
        sc = pvl.ScMoveToFirstValue();

        while ( sc == ERROR_SUCCESS )
        {
            switch ( pvl.CptCurrentValueType() )
            {
                case CLUSPROP_TYPE_RESCLASS:
                    prci = reinterpret_cast< PCLUS_RESOURCE_CLASS_INFO >( &pvl.CbhCurrentValue().pResourceClassInfoValue->li );
                    hres = ResUtilGetResourceDependencyByClass(
                                Hcluster(),
                                Peo()->PrdResData()->m_hresource,
                                prci,
                                FALSE // bRecurse
                                );
                    if ( hres != NULL )
                    {
                        CloseClusterResource( hres );
                    } // if:  found the resource
                    else
                    {
                        if ( ! strMissing.LoadString( IDS_RESCLASS_UNKNOWN + prci->rc ) )
                        {
                            strMissing.LoadString( IDS_RESCLASS_UNKNOWN );
                        } // if: unknown resource class

                        bFound = FALSE;
                    } // else: resource not found
                    break;

                case CLUSPROP_TYPE_NAME:
                    hres = ResUtilGetResourceDependencyByName(
                                Hcluster(),
                                Peo()->PrdResData()->m_hresource,
                                pvl.CbhCurrentValue().pName->sz,
                                FALSE // bRecurse
                                );
                    if ( hres != NULL )
                    {
                        CloseClusterResource( hres );
                    } // if:  found the resource
                    else
                    {
                        GetResTypeDisplayOrTypeName( pvl.CbhCurrentValue().pName->sz, &strMissing );
                        bFound = FALSE;
                    } // else: resource not found
                    break;

            } // switch: value type

            // If a match was not found, changes cannot be applied.
            if ( ! bFound )
            {
                CExceptionWithOper ewo( IDS_REQUIRED_DEPENDENCY_NOT_FOUND, NULL, NULL, FALSE );

                ewo.SetOperation( IDS_REQUIRED_DEPENDENCY_NOT_FOUND, static_cast< LPCWSTR >( strMissing ) );
                ewo.ReportError();

                break;
            }  // if:  not found

            sc = pvl.ScMoveToNextValue();
        } // while: more values in the value list

    } while( 0 );

    return bFound;

} //*** CBasePropertyPage::BRequiredDependenciesPresent()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::GetResTypeDisplayOrTypeName
//
//  Routine Description:
//      Get the display name for a resource type if possible.  If any errors
//      occur, just return the type name.
//
//  Arguments:
//      pszResTypeNameIn
//          [IN] Name of resource type.
//
//      pstrResTypeDisplayNameInOut
//          [IN OUT] CString in which to return the display name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::GetResTypeDisplayOrTypeName(
    IN      LPCWSTR     pszResTypeNameIn,
    IN OUT  CString *   pstrResTypeDisplayNameInOut
    )
{
    DWORD           sc;
    CClusPropList   cpl;

    // Get resource type properties.
    sc = cpl.ScGetResourceTypeProperties(
                Hcluster(),
                pszResTypeNameIn,
                CLUSCTL_RESOURCE_TYPE_GET_COMMON_PROPERTIES
                );
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Find the Name property.
    sc = cpl.ScMoveToPropertyByName( CLUSREG_NAME_RESTYPE_NAME );
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Move to the first value for the property.
    sc = cpl.ScMoveToFirstPropertyValue();
    if ( sc != ERROR_SUCCESS )
        goto Error;

    // Make sure the name is a string.
    if ( ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_SZ )
      && ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_EXPAND_SZ )
      && ( cpl.CpfCurrentValueFormat() != CLUSPROP_FORMAT_EXPANDED_SZ )
       )
       goto Error;

    // Copy the string into the output CString.
    *pstrResTypeDisplayNameInOut = cpl.CbhCurrentValue().pStringValue->sz;

Cleanup:
    return;

Error:
    *pstrResTypeDisplayNameInOut = pszResTypeNameIn;
    goto Cleanup;

} //*** CBasePropertyPage::GetResTypeDisplayOrTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      rstrValue       [OUT] String in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT CString &   rstrValue,
    IN HKEY         hkey
    )
{
    DWORD       sc;
    LPWSTR      pwszValue  = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;

    ASSERT( pszValueName != NULL );
    ASSERT( hkey != NULL );

    rstrValue.Empty();

    try
    {
        // Get the size of the value.
        dwValueLen = 0;
        sc = ::ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( sc == ERROR_SUCCESS ) || ( sc == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_SZ );

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer( dwValueLen / sizeof( WCHAR ) );
            if ( pwszValue == NULL )
            {
                AfxThrowMemoryException();
            } // if: error getting the buffer
            ASSERT( pwszValue != NULL );
            dwValueLen += 1 * sizeof( WCHAR );  // Don't forget the final null-terminator.

            // Read the value.
            sc = ::ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if ( sc == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_SZ );
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer();
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        sc = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    return sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pdwValue        [OUT] DWORD in which to return the value.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      _sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT DWORD *     pdwValue,
    IN HKEY         hkey
    )
{
    DWORD       _sc;
    DWORD       _dwValue;
    DWORD       _dwValueLen;
    DWORD       _dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue != NULL);
    ASSERT(hkey != NULL);

    *pdwValue = 0;

    // Read the value.
    _dwValueLen = sizeof(_dwValue);
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    (LPBYTE) &_dwValue,
                    &_dwValueLen
                    );
    if (_sc == ERROR_SUCCESS)
    {
        ASSERT(_dwValueType == REG_DWORD);
        ASSERT(_dwValueLen == sizeof(_dwValue));
        *pdwValue = _dwValue;
    }  // if:  value read successfully

    return _sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, DWORD*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//      hkey            [IN] Handle to the registry key to read from.
//
//  Return Value:
//      _sc ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScReadValue(
    IN LPCTSTR      pszValueName,
    OUT LPBYTE *    ppbValue,
    IN HKEY         hkey
    )
{
    DWORD       _sc;
    DWORD       _dwValueLen;
    DWORD       _dwValueType;

    ASSERT(pszValueName != NULL);
    ASSERT(ppbValue != NULL);
    ASSERT(hkey != NULL);

    *ppbValue = NULL;

    // Get the length of the value.
    _dwValueLen = 0;
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    NULL,
                    &_dwValueLen
                    );
    if (_sc != ERROR_SUCCESS)
        return _sc;

    ASSERT(_dwValueType == REG_BINARY);

    // Allocate a buffer,
    try
    {
        *ppbValue = new BYTE[_dwValueLen];
    }  // try
    catch (CMemoryException *)
    {
        _sc = ERROR_NOT_ENOUGH_MEMORY;
        return _sc;
    }  // catch:  CMemoryException

    // Read the value.
    _sc = ::ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &_dwValueType,
                    *ppbValue,
                    &_dwValueLen
                    );
    if (_sc != ERROR_SUCCESS)
    {
        delete [] *ppbValue;
        *ppbValue = NULL;
    }  // if:  value read successfully

    return _sc;

}  //*** CBasePropertyPage::ScReadValue(LPCTSTR, LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      rstrValue       [IN] Value data.
//      rstrPrevValue   [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN const CString &  rstrValue,
    IN OUT CString &    rstrPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;

    ASSERT(pszValueName != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (rstrValue != rstrPrevValue)
    {
        _sc = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_SZ,
                        (CONST BYTE *) (LPCTSTR) rstrValue,
                        (rstrValue.GetLength() + 1) * sizeof(TCHAR)
                        );
        if (_sc == ERROR_SUCCESS)
            rstrPrevValue = rstrValue;
    }  // if:  value changed
    else
        _sc = ERROR_SUCCESS;
    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, CString&)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      dwValue         [IN] Value data.
//      pdwPrevValue    [IN OUT] Previous value.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN DWORD            dwValue,
    IN OUT DWORD *      pdwPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwPrevValue != NULL);
    ASSERT(hkey != NULL);

    // Write the value if it hasn't changed.
    if (dwValue != *pdwPrevValue)
    {
        _sc = ::ClusterRegSetValue(
                        hkey,
                        pszValueName,
                        REG_DWORD,
                        (CONST BYTE *) &dwValue,
                        sizeof(dwValue)
                        );
        if (_sc == ERROR_SUCCESS)
            *pdwPrevValue = dwValue;
    }  // if:  value changed
    else
        _sc = ERROR_SUCCESS;
    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, DWORD)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ScWriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//      hkey            [IN] Handle to the registry key to write to.
//
//  Return Value:
//      _sc
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CBasePropertyPage::ScWriteValue(
    IN LPCTSTR          pszValueName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue,
    IN HKEY             hkey
    )
{
    DWORD       _sc;
    LPBYTE      _pbPrevValue    = NULL;

    ASSERT(pszValueName != NULL);
    ASSERT(pbValue != NULL);
    ASSERT(ppbPrevValue != NULL);
    ASSERT(cbValue > 0);
    ASSERT(hkey != NULL);

    // See if the data has changed.
    if (cbValue == cbPrevValue)
    {
        if (memcmp(pbValue, *ppbPrevValue, cbValue) == 0)
            return ERROR_SUCCESS;
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    try
    {
        _pbPrevValue = new BYTE[cbValue];
    }
    catch (CMemoryException *)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException
    ::CopyMemory(_pbPrevValue, pbValue, cbValue);

    // Write the value if it hasn't changed.
    _sc = ::ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if (_sc == ERROR_SUCCESS)
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = _pbPrevValue;
    }  // if:  set was successful
    else
        delete [] _pbPrevValue;

    return _sc;

}  //*** CBasePropertyPage::ScWriteValue(LPCTSTR, const LPBYTE)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnContextMenu
//
//  Routine Description:
//      Handler for the WM_CONTEXTMENU message.
//
//  Arguments:
//      pWnd    Window in which user clicked the right mouse button.
//      point   Position of the cursor, in screen coordinates.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::OnContextMenu(CWnd * pWnd, CPoint point)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePropertyPage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnHelpInfo
//
//  Routine Description:
//      Handler for the WM_HELPINFO message.
//
//  Arguments:
//      pHelpInfo   Structure containing info about displaying help.
//
//  Return Value:
//      TRUE        Help processed.
//      FALSE       Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::OnHelpInfo(HELPINFO * pHelpInfo)
{
    BOOL    _bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
    if (!_bProcessed)
        _bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
    return _bProcessed;

}  //*** CBasePropertyPage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::OnCommandHelp
//
//  Routine Description:
//      Handler for the WM_COMMANDHELP message.
//
//  Arguments:
//      wParam      [IN] WPARAM.
//      lParam      [IN] LPARAM.
//
//  Return Value:
//      TRUE    Help processed.
//      FALSE   Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePropertyPage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
    LRESULT _bProcessed;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _bProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
    if (!_bProcessed)
        _bProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

    return _bProcessed;

}  //*** CBasePropertyPage::OnCommandHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::ConstructDefaultDirectory
//
//  Routine Description:
//      Get the name of the first partition from the first storage-class
//      resource on which this resource is dependent.
//
//  Arguments:
//      rstrDir     [OUT] Directory string.
//      idsFormat   [IN] Resource ID for the format string.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertyPage::ConstructDefaultDirectory(
    OUT CString &   rstrDir,
    IN IDS          idsFormat
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESOURCE               _hres = NULL;
    DWORD                   _sc = ERROR_SUCCESS;
    DWORD                   _cbDiskInfo = sizeof(CLUSPROP_DWORD)
                                        + sizeof(CLUSPROP_SCSI_ADDRESS)
                                        + sizeof(CLUSPROP_DISK_NUMBER)
                                        + sizeof(CLUSPROP_PARTITION_INFO)
                                        + sizeof(CLUSPROP_SYNTAX);
    PBYTE                   _pbDiskInfo = NULL;
    CLUSPROP_BUFFER_HELPER  _cbh;

    // Get the first partition for the resource..
    try
    {
        // Get the storage-class resource on which we are dependent.
        _hres = GetDependentStorageResource();
        if (_hres == NULL)
            return;

        // Get disk info.
        _pbDiskInfo = new BYTE[_cbDiskInfo];
        _sc = ClusterResourceControl(
                        _hres,
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        _pbDiskInfo,
                        _cbDiskInfo,
                        &_cbDiskInfo
                        );
        if (_sc == ERROR_MORE_DATA)
        {
            delete [] _pbDiskInfo;
            _pbDiskInfo = new BYTE[_cbDiskInfo];
            _sc = ClusterResourceControl(
                            _hres,
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            _pbDiskInfo,
                            _cbDiskInfo,
                            &_cbDiskInfo
                            );
        }  // if:  buffer too small
        if (_sc == ERROR_SUCCESS)
        {
            // Find the first partition.
            _cbh.pb = _pbDiskInfo;
            while (_cbh.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
            {
                if (_cbh.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
                {
                    rstrDir.FormatMessage(
                                        idsFormat,
                                        _cbh.pPartitionInfoValue->szDeviceName
                                        );
                    break;
                }  // if:  found a partition
                _cbh.pb += sizeof(*_cbh.pValue) + ALIGN_CLUSPROP(_cbh.pValue->cbLength);
            }  // while:  not at end of list
        } // if:  no error getting disk info
        else
        {
            CNTException nte( _sc, IDS_ERROR_CONSTRUCTING_DEF_DIR );
            nte.ReportError();
        } // else:  error getting disk info
    }  // try
    catch (CMemoryException * _pme)
    {
        _pme->Delete();
    }  // catch:  CMemoryException

    CloseClusterResource(_hres);
    delete [] _pbDiskInfo;

}  //*** CBasePropertyPage::ConstructDefaultDirectory()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::GetDependentStorageResource
//
//  Routine Description:
//      Construct a default spool directory based on the drive on which
//      this resource is dependent and a default value for the directory.
//
//  Arguments:
//      phres       [OUT] Handle to dependent resource.
//
//  Return Value:
//      HRESOURCE for the open dependent resource, or NULL if error.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESOURCE CBasePropertyPage::GetDependentStorageResource(void)
{
    DWORD                       _sc = ERROR_SUCCESS;
    HRESENUM                    _hresenum;
    HRESOURCE                   _hres = NULL;
    DWORD                       _ires;
    DWORD                       _dwType;
    DWORD                       _cchName;
    DWORD                       _cchNameSize;
    LPWSTR                      _pszName = NULL;
    CLUS_RESOURCE_CLASS_INFO    _classinfo;
    DWORD                       _cbClassInfo;

    // Open the dependency enumerator.
    _hresenum = ClusterResourceOpenEnum(
                        Peo()->PrdResData()->m_hresource,
                        CLUSTER_RESOURCE_ENUM_DEPENDS
                        );
    if (_hresenum == NULL)
        return NULL;

    // Allocate a default size name buffer.
    _cchNameSize = 512;
    _pszName = new WCHAR[_cchNameSize];

    for (_ires = 0 ; ; _ires++)
    {
        // Get the name of the next resource.
        _cchName = _cchNameSize;
        _sc = ClusterResourceEnum(
                            _hresenum,
                            _ires,
                            &_dwType,
                            _pszName,
                            &_cchName
                            );
        if (_sc == ERROR_MORE_DATA)
        {
            delete [] _pszName;
            _cchNameSize = _cchName;
            _pszName = new WCHAR[_cchNameSize];
            _sc = ClusterResourceEnum(
                                _hresenum,
                                _ires,
                                &_dwType,
                                _pszName,
                                &_cchName
                                );
        }  // if:  name buffer too small
        if (_sc != ERROR_SUCCESS)
            break;

        // Open the resource.
        _hres = OpenClusterResource(Hcluster(), _pszName);
        if (_hres == NULL)
        {
            _sc = GetLastError();
            break;
        }  // if:  error opening the resource

        // Get the class of the resource.
        _sc = ClusterResourceControl(
                            _hres,
                            NULL,
                            CLUSCTL_RESOURCE_GET_CLASS_INFO,
                            NULL,
                            0,
                            &_classinfo,
                            sizeof(_classinfo),
                            &_cbClassInfo
                            );
        if (_sc != ERROR_SUCCESS)
        {
            CNTException nte( _sc, IDS_ERROR_GET_CLASS_INFO, _pszName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
            continue;
        }

        // If this is a storage-class resource, we're done.
        if (_classinfo.rc == CLUS_RESCLASS_STORAGE)
            break;

        // Not storage-class resource.
        CloseClusterResource(_hres);
        _hres = NULL;
    }  // for each resource on which we are dependent

    // Handle errors.
    if ((_sc != ERROR_SUCCESS) && (_hres != NULL))
    {
        CloseClusterResource(_hres);
        _hres = NULL;
    }  // if:  error getting resource

    // Cleanup.
    ClusterResourceCloseEnum(_hresenum);
    delete [] _pszName;

    return _hres;

}  //*** CBasePropertyPage::GetDependentStorageResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertyPage::BGetClusterNetworkNameNode
//
//  Routine Description:
//      Get the node hosting the Network Name resource.
//
//  Arguments:
//      rstrNode    [OUT] - receives the node name
//
//  Return Value:
//      BOOL -- TRUE for success, FALSE for error
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertyPage::BGetClusterNetworkNameNode( OUT CString & rstrNode )
{
    BOOL                    _bSuccess = TRUE;
    DWORD                   _sc;
    DWORD                   _dwFlag;
    DWORD                   _cbData;
    DWORD                   _ires;
    DWORD                   _dwType;
    DWORD                   _cchName = 0;
    DWORD                   _cchNameCurrent;
    LPWSTR                  _pszName = NULL;
    WCHAR                   _szResType[ RTL_NUMBER_OF( CLUS_RESTYPE_NAME_NETNAME ) ];
    WCHAR                   _szNode[ MAX_COMPUTERNAME_LENGTH + 1 ];
    HCLUSENUM               _hclusenum = NULL;
    HRESOURCE               _hresource = NULL;
    CLUSTER_RESOURCE_STATE  _crs;
    CWaitCursor             _wc;

    try
    {
        // Open a cluster enumerator.
        _hclusenum = ClusterOpenEnum( Hcluster(), CLUSTER_ENUM_RESOURCE );
        if (_hclusenum == NULL)
        {
            ThrowStaticException( GetLastError() );
        }

        // Allocate an initial buffer.
        _cchName = 256;
        _pszName = new WCHAR[_cchName];

        // Loop through each resource.
        for ( _ires = 0 ; ; _ires++ )
        {
            // Get the next resource.
            _cchNameCurrent = _cchName;
            _sc = ClusterEnum( _hclusenum, _ires, &_dwType, _pszName, &_cchNameCurrent );
            if ( _sc == ERROR_MORE_DATA )
            {
                delete [] _pszName;
                _cchName = ++_cchNameCurrent;
                _pszName = new WCHAR[_cchName];
                _sc = ClusterEnum(_hclusenum, _ires, &_dwType, _pszName, &_cchNameCurrent);
            }  // if:  buffer too small
            if (_sc == ERROR_NO_MORE_ITEMS)
                break;
            if (_sc != ERROR_SUCCESS)
                ThrowStaticException(_sc);

            // Open the resource.
            _hresource = OpenClusterResource(Hcluster(), _pszName);
            if (_hresource == NULL)
                ThrowStaticException(GetLastError());

            // Get its flags.
            _sc = ClusterResourceControl(
                                    _hresource,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_FLAGS,
                                    NULL,
                                    0,
                                    &_dwFlag,
                                    sizeof(DWORD),
                                    &_cbData
                                    );
            if (_sc != ERROR_SUCCESS)
            {
                CNTException nte( _sc, IDS_ERROR_GET_RESOURCE_FLAGS, _pszName, NULL, FALSE /*bAutoDelete*/ );
                nte.ReportError();
                continue;
            }

            // If this isn't a core resource, skip it.
            if ((_dwFlag & CLUS_FLAG_CORE) == 0)
                continue;

            // Get its resource type name.  If the buffer is too small,
            // it isn't a Network Name resource so skip it.
            _sc = ClusterResourceControl(
                                    _hresource,
                                    NULL,
                                    CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                    NULL,
                                    0,
                                    _szResType,
                                    sizeof(_szResType),
                                    &_cbData
                                    );
            if (_sc == ERROR_MORE_DATA)
                continue;
            if (_sc != ERROR_SUCCESS)
                ThrowStaticException(_sc);

            // If this is a Network Name resource, get which node it is online on.
            if ( ClRtlStrNICmp( _szResType, CLUS_RESTYPE_NAME_NETNAME, RTL_NUMBER_OF( CLUS_RESTYPE_NAME_NETNAME ) ) == 0 )
            {
                // Get the state of the resource.
                _crs = GetClusterResourceState(
                                    _hresource,
                                    _szNode,
                                    &_cchName,
                                    NULL,
                                    NULL
                                    );
                if (_crs == ClusterResourceStateUnknown)
                    ThrowStaticException(GetLastError());

                // Save the node name in the return argument.
                rstrNode = _szNode;

                break;
            }  // if:  Network Name resource

            CloseClusterResource( _hresource );
            _hresource = NULL;
        }  // for:  each resource

        if (rstrNode[0] == _T('\0'))
            ThrowStaticException(ERROR_FILE_NOT_FOUND, (IDS) 0);
    }  // try
    catch (CException * _pe)
    {
        _pe->ReportError();
        _pe->Delete();
        _bSuccess = FALSE;
    }  // catch:  CException

    delete [] _pszName;

    if ( _hresource != NULL )
    {
        CloseClusterResource( _hresource );
    } // if: resource is open
    if ( _hclusenum != NULL )
    {
        ClusterCloseEnum( _hclusenum );
    } // if: enumerator is open

    return _bSuccess;

}  //*** CBasePropertyPage::BGetClusterNetworkNameNode()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BasePage.h
//
//  Abstract:
//      Definition of the CBasePropertyPage class.  This class provides base
//      functionality for extension DLL property pages.
//
//  Implementation File:
//      BasePage.cpp
//      BasePage.inl
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"    // for CDialogHelp
#endif

#ifndef _PROPLIST_H_
#include "PropList.h"   // for CClusPropList, CObjectProperty
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
interface IWCWizardCallback;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE( CBasePropertyPage )

// Construction
public:
    CBasePropertyPage( void );
    CBasePropertyPage(
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap
        );
    CBasePropertyPage(
        IN UINT             idd,
        IN const DWORD *    pdwHelpMap,
        IN const DWORD *    pdwWizardHelpMap,
        IN UINT             nIDCaption = 0
        );
    virtual ~CBasePropertyPage( void ) { }

    // Second phase construction.
    virtual HRESULT         HrInit( IN OUT CExtObject * peo );

protected:
    void                    CommonConstruct( void );

// Attributes
protected:
    CExtObject *            m_peo;
    HPROPSHEETPAGE          m_hpage;

    IDD                     m_iddPropertyPage;
    IDD                     m_iddWizardPage;
    IDS                     m_idsCaption;

    CExtObject *            Peo( void ) const               { return m_peo; }
    HPROPSHEETPAGE          Hpage( void ) const             { return m_hpage; }

    IDD                     IddPropertyPage( void ) const   { return m_iddPropertyPage; }
    IDD                     IddWizardPage( void ) const     { return m_iddWizardPage; }
    IDS                     IdsCaption( void ) const        { return m_idsCaption; }

public:
    void                    SetHpage( IN OUT HPROPSHEETPAGE hpage ) { m_hpage = hpage; }

// Dialog Data
    //{{AFX_DATA(CBasePropertyPage)
    enum { IDD = 0 };
    //}}AFX_DATA
    CStatic m_staticIcon;
    CStatic m_staticTitle;
    CString m_strTitle;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CBasePropertyPage)
    public:
    virtual BOOL OnSetActive();
    virtual BOOL OnApply();
    virtual LRESULT OnWizardBack();
    virtual LRESULT OnWizardNext();
    virtual BOOL OnWizardFinish();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual DWORD           ScParseUnknownProperty(
                                IN LPCWSTR                          pwszName,
                                IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                IN DWORD                            cbBuf
                                )       { return ERROR_SUCCESS; }
    virtual BOOL            BApplyChanges( void );
    virtual BOOL            BBuildPropList( IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE );
    virtual void            DisplaySetPropsError( IN DWORD sc, IN UINT idsOper ) const;

    virtual const CObjectProperty * Pprops( void ) const    { return NULL; }
    virtual DWORD                   Cprops( void ) const    { return 0; }

// Implementation
protected:
    BOOL                    m_bBackPressed;
    BOOL                    m_bSaved;
    const DWORD *           m_pdwWizardHelpMap;
    BOOL                    m_bDoDetach;

    BOOL                    BGetClusterNetworkNameNode( OUT CString & rstrNode );
    BOOL                    BBackPressed( void ) const      { return m_bBackPressed; }
    BOOL                    BSaved( void ) const            { return m_bSaved; }
    IWCWizardCallback *     PiWizardCallback( void ) const;
    BOOL                    BWizard( void ) const;
    HCLUSTER                Hcluster( void ) const;
    void                    EnableNext( IN BOOL bEnable = TRUE );

    BOOL                    BRequiredDependenciesPresent( void );

    DWORD                   ScParseProperties( IN CClusPropList & rcpl );
    BOOL                    BSetPrivateProps(
                                IN BOOL             bValidateOnly = FALSE,
                                IN BOOL             bNoNewProps = FALSE
                                );

    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT CString &       rstrValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT DWORD *         pdwValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScReadValue(
                                IN LPCTSTR          pszValueName,
                                OUT LPBYTE *        ppbValue,
                                IN HKEY             hkey
                                );

    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const CString &  rstrValue,
                                IN OUT CString &    rstrPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN DWORD            dwValue,
                                IN OUT DWORD *      pdwPrevValue,
                                IN HKEY             hkey
                                );
    DWORD                   ScWriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue,
                                IN HKEY             hkey
                                );

    void                    SetHelpMask( IN DWORD dwMask )    { m_dlghelp.SetHelpMask(dwMask); }
    CDialogHelp             m_dlghelp;

    void                ConstructDefaultDirectory(
                                OUT CString &   rstrDir,
                                IN IDS          idsFormat
                                );
    HRESOURCE           GetDependentStorageResource( void );

    void                GetResTypeDisplayOrTypeName(
                                IN      LPCWSTR     pszResTypeNameIn,
                                IN OUT  CString *   pstrResTypeDisplayNameInOut
                                );

    // Generated message map functions
    //{{AFX_MSG(CBasePropertyPage)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
    //}}AFX_MSG
    virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnChangeCtrl();
    DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////
// CPageList
/////////////////////////////////////////////////////////////////////////////

typedef CList< CBasePropertyPage *, CBasePropertyPage * > CPageList;

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\basepage.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.inl
//
//	Abstract:
//		Implementation of inline methods of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	October 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_INL_
#define _BASEPAGE_INL_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////

IWCWizardCallback * CBasePropertyPage::PiWizardCallback(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->PiWizardCallback();
}

BOOL CBasePropertyPage::BWizard(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->BWizard();
}

HCLUSTER CBasePropertyPage::Hcluster(void) const
{
	ASSERT(Peo() != NULL);
	return Peo()->Hcluster();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\basedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.cpp
//
//	Abstract:
//		Implementation of the CBaseDialog class.
//
//	Author:
//		David Potter (davidp)	April 30, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseDlg.h"
#include "CluAdmX.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseDialog, CDialog)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(void)
{
}  //*** CBaseDialog::CBaseDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control-to-help ID map.
//		pParentWnd		[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN CWnd *			pParentWnd
	)
	: CDialog(idd, pParentWnd)
	, m_dlghelp(pdwHelpMap, idd)
{
}  //*** CBaseDialog::CBaseDialog(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::OnContextMenu(CWnd * pWnd, CPoint point)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBaseDialog::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseDialog::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CDialog::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBaseDialog::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseDialog::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	bProcessed;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	bProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!bProcessed)
		bProcessed = CDialog::OnCommandHelp(wParam, lParam);

	return bProcessed;

}  //*** CBaseDialog::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\clusname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusName.cpp
//
//  Abstract:
//      Implementation of the CChangeClusterNameDlg class.
//
//  Author:
//      David Potter (davidp)   April 28, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ClusName.h"
#include "DDxDDv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangeClusterNameDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CChangeClusterNameDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CChangeClusterNameDlg)
    ON_EN_CHANGE(IDC_CLUSNAME, OnChangeClusName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::CChangeClusterNameDlg
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParent         [IN] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CChangeClusterNameDlg::CChangeClusterNameDlg(CWnd * pParent /*=NULL*/)
    : CBaseDialog(IDD, g_aHelpIDs_IDD_EDIT_CLUSTER_NAME, pParent)
{
    //{{AFX_DATA_INIT(CChangeClusterNameDlg)
    m_strClusName = _T("");
    //}}AFX_DATA_INIT

}  //*** CChangeClusterNameDlg::CChangeClusterNameDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CChangeClusterNameDlg::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;
    CString     strClusName;

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChangeClusterNameDlg)
    DDX_Control(pDX, IDOK, m_pbOK);
    DDX_Control(pDX, IDC_CLUSNAME, m_editClusName);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        CLRTL_NAME_STATUS   cnStatus;

        //
        // get the name from the control into a temp variable
        //
        DDX_Text(pDX, IDC_CLUSNAME, strClusName);

        DDV_RequiredText(pDX, IDC_CLUSNAME, IDC_CLUSNAME_LABEL, m_strClusName);
        DDV_MaxChars(pDX, m_strClusName, MAX_CLUSTERNAME_LENGTH);

        //
        // Only do work if the names are different.
        //
        if ( m_strClusName != strClusName )
        {
            //
            // Check to see if the new name is valid
            //
            if( !ClRtlIsNetNameValid(strClusName, &cnStatus, FALSE /*CheckIfExists*/) )
            {
                //
                // The net name is not valid.  Display a message box with the error.
                //
                CString     strMsg;
                UINT        idsError;

                AFX_MANAGE_STATE(AfxGetStaticModuleState());

                switch (cnStatus)
                {
                    case NetNameTooLong:
                        idsError = IDS_INVALID_NETWORK_NAME_TOO_LONG;
                        break;
                    case NetNameInvalidChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_CHARS;
                        break;
                    case NetNameInUse:
                        idsError = IDS_INVALID_NETWORK_NAME_IN_USE;
                        break;
                    case NetNameDNSNonRFCChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                        break;
                    default:
                        idsError = IDS_INVALID_NETWORK_NAME;
                        break;
                }  // switch:  cnStatus

                strMsg.LoadString(idsError);

                if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                {
                    int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                    if ( id == IDNO )
                    {
                        strMsg.Empty();
                        pDX->Fail();
                    }
                }
                else
                {
                    AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                    strMsg.Empty(); // exception prep
                    pDX->Fail();
                }
            }  // if:  netname has changed and an invalid network name was specified

            //
            // A valid netname was entered or a non-standard netname was confirmed.
            // Save it.
            //
            m_strClusName = strClusName;

        } // if:    names are different
    }  // if:  saving data from dialog
    else
    {
        //
        // populate the control with data from the member variable
        //
        DDX_Text(pDX, IDC_CLUSNAME, m_strClusName);
    }
}  //*** CChangeClusterNameDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CChangeClusterNameDlg::OnInitDialog(void)
{
    CBaseDialog::OnInitDialog();

    if (m_strClusName.GetLength() == 0)
        m_pbOK.EnableWindow(FALSE);

    m_editClusName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CChangeClusterNameDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CChangeClusterNameDlg::OnChangeClusName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CChangeClusterNameDlg::OnChangeClusName(void)
{
    BOOL    bEnable;

    bEnable = (m_editClusName.GetWindowTextLength() > 0);
    m_pbOK.EnableWindow(bEnable);

}  //*** CChangeClusterNameDlg::OnChangeClusName()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\cluadmx.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      CluAdmX.h
//
//  Description:
//      Global definitions across the DLL.
//
//  Implementation File:
//      CluAdmEx.cpp
//
//  Maintained By:
//      David Potter (davidp)   August 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Constant Definitions
/////////////////////////////////////////////////////////////////////////////

#define REGPARAM_NAME                           _T("Name")
#define REGPARAM_PARAMETERS                     _T("Parameters")
#define REGPARAM_TYPE                           _T("Type")
#define REGPARAM_NETWORKS                       _T("Networks")
#define REGPARAM_CONNECTS_CLIENTS               _T("ConnectsClients")

#define REGPARAM_DISKS_SIGNATURE                CLUSREG_NAME_PHYSDISK_SIGNATURE

#define REGPARAM_GENAPP_COMMAND_LINE            CLUSREG_NAME_GENAPP_COMMAND_LINE
#define REGPARAM_GENAPP_CURRENT_DIRECTORY       CLUSREG_NAME_GENAPP_CURRENT_DIRECTORY
#define REGPARAM_GENAPP_INTERACT_WITH_DESKTOP   CLUSREG_NAME_GENAPP_INTERACT_WITH_DESKTOP
#define REGPARAM_GENAPP_USE_NETWORK_NAME        CLUSREG_NAME_GENAPP_USE_NETWORK_NAME

#define REGPARAM_GENSCRIPT_SCRIPT_FILEPATH      CLUSREG_NAME_GENSCRIPT_SCRIPT_FILEPATH

#define REGPARAM_GENSVC_SERVICE_NAME            CLUSREG_NAME_GENSVC_SERVICE_NAME
#define REGPARAM_GENSVC_COMMAND_LINE            CLUSREG_NAME_GENSVC_STARTUP_PARAMS
#define REGPARAM_GENSVC_USE_NETWORK_NAME        CLUSREG_NAME_GENSVC_USE_NETWORK_NAME

#define REGPARAM_IPADDR_ADDRESS                 CLUSREG_NAME_IPADDR_ADDRESS
#define REGPARAM_IPADDR_SUBNET_MASK             CLUSREG_NAME_IPADDR_SUBNET_MASK
#define REGPARAM_IPADDR_NETWORK                 CLUSREG_NAME_IPADDR_NETWORK
#define REGPARAM_IPADDR_ENABLE_NETBIOS          CLUSREG_NAME_IPADDR_ENABLE_NETBIOS

#define REGPARAM_NETNAME_NAME                   CLUSREG_NAME_NETNAME_NAME
#define REGPARAM_NETNAME_REMAP_PIPE_NAMES       CLUSREG_NAME_NETNAME_REMAP_PIPE_NAMES
#define REGPARAM_NETNAME_REQUIRE_DNS            CLUSREG_NAME_NETNAME_REQUIRE_DNS 
#define REGPARAM_NETNAME_REQUIRE_KERBEROS       CLUSREG_NAME_NETNAME_REQUIRE_KERBEROS        
#define REGPARAM_NETNAME_STATUS_NETBIOS         CLUSREG_NAME_NETNAME_STATUS_NETBIOS
#define REGPARAM_NETNAME_STATUS_DNS             CLUSREG_NAME_NETNAME_STATUS_DNS
#define REGPARAM_NETNAME_STATUS_KERBEROS        CLUSREG_NAME_NETNAME_STATUS_KERBEROS

#define REGPARAM_PRINT                          _T("Printers")
#define REGPARAM_PRTSPOOL_DEFAULT_SPOOL_DIR     CLUSREG_NAME_PRTSPOOL_DEFAULT_SPOOL_DIR
#define REGPARAM_PRTSPOOL_TIMEOUT               CLUSREG_NAME_PRTSPOOL_TIMEOUT
#define REGPARAM_PRTSPOOL_DRIVER_DIRECTORY      CLUSREG_NAME_PRTSPOOL_DRIVER_DIRECTORY

#define REGPARAM_FILESHR_SHARE_NAME             CLUSREG_NAME_FILESHR_SHARE_NAME
#define REGPARAM_FILESHR_PATH                   CLUSREG_NAME_FILESHR_PATH
#define REGPARAM_FILESHR_REMARK                 CLUSREG_NAME_FILESHR_REMARK
#define REGPARAM_FILESHR_MAX_USERS              CLUSREG_NAME_FILESHR_MAX_USERS
#define REGPARAM_FILESHR_SECURITY               CLUSREG_NAME_FILESHR_SECURITY
#define REGPARAM_FILESHR_SD                     CLUSREG_NAME_FILESHR_SD
#define REGPARAM_FILESHR_SHARE_SUBDIRS          CLUSREG_NAME_FILESHR_SHARE_SUBDIRS
#define REGPARAM_FILESHR_HIDE_SUBDIR_SHARES     CLUSREG_NAME_FILESHR_HIDE_SUBDIR_SHARES
#define REGPARAM_FILESHR_IS_DFS_ROOT            CLUSREG_NAME_FILESHR_IS_DFS_ROOT
#define REGPARAM_FILESHR_CSC_CACHE              CLUSREG_NAME_FILESHR_CSC_CACHE

#define RESTYPE_NAME_GENERIC_APP                CLUS_RESTYPE_NAME_GENAPP
#define RESTYPE_NAME_GENERIC_SCRIPT             CLUS_RESTYPE_NAME_GENSCRIPT
#define RESTYPE_NAME_GENERIC_SERVICE            CLUS_RESTYPE_NAME_GENSVC
#define RESTYPE_NAME_NETWORK_NAME               CLUS_RESTYPE_NAME_NETNAME
#define RESTYPE_NAME_PHYS_DISK                  CLUS_RESTYPE_NAME_PHYS_DISK
#define RESTYPE_NAME_FT_SET                     CLUS_RESTYPE_NAME_FTSET
#define RESTYPE_NAME_PRINT_SPOOLER              CLUS_RESTYPE_NAME_PRTSPLR
#define RESTYPE_NAME_FILE_SHARE                 CLUS_RESTYPE_NAME_FILESHR
#define RESTYPE_NAME_IP_ADDRESS                 CLUS_RESTYPE_NAME_IPADDR

/////////////////////////////////////////////////////////////////////////////
// Global Function Declarations
/////////////////////////////////////////////////////////////////////////////

void FormatError(CString & rstrError, DWORD dwError);

extern const WCHAR g_wszResourceTypeNames[];
extern const DWORD g_cchResourceTypeNames;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\clusname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		ClusName.h
//
//	Abstract:
//		Definition of the CChangeClusterNameDlg.
//
//	Implementation File:
//		ClusName.cpp
//
//	Author:
//		David Potter (davidp)	April 29, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSNAME_H_
#define _CLUSNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CChangeClusterNameDlg;

/////////////////////////////////////////////////////////////////////////////
// CChangeClusterNameDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CChangeClusterNameDlg : public CBaseDialog
{
// Construction
public:
	CChangeClusterNameDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CChangeClusterNameDlg)
	enum { IDD = IDD_EDIT_CLUSTER_NAME };
	CEdit	m_editClusName;
	CButton	m_pbOK;
	CString	m_strClusName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChangeClusterNameDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CChangeClusterNameDlg)
	afx_msg void OnChangeClusName();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CChangeClusterNameDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\cluadmex.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CluAdmEx.cpp
//
//  Abstract:
//      Implementation of the CCluAdmExApp class and DLL initialization
//      routines.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <aclui.h>      // for ISecurityInformation
#include <CluAdmEx.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "RegExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define IID_DEFINED
#include "ExtObjID_i.c"

CComModule _Module;

#pragma warning(disable : 4701) // local variable may be used without having been initialized
#include <atlimpl.cpp>
#pragma warning(default : 4701)

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CoCluAdmEx, CExtObject)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// Global Function Prototypes
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
STDAPI DllCanUnloadNow(void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hcluster);
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hcluster);

/////////////////////////////////////////////////////////////////////////////
// class CCluAdmExApp
/////////////////////////////////////////////////////////////////////////////

class CCluAdmExApp : public CWinApp
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
};

CCluAdmExApp theApp;

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExApp::InitInstance
//
//  Routine Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Application initialized successfully.
//      FALSE       Error initializing application.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CCluAdmExApp::InitInstance(void)
{
    _Module.Init(ObjectMap, m_hInstance);

    // Construct the help path.
    {
        TCHAR   szPath[_MAX_PATH];
        TCHAR   szDrive[_MAX_PATH];
        TCHAR   szDir[_MAX_DIR];
        size_t  cchPath;
        HRESULT hr;
        BOOL    fEnable;

        VERIFY(::GetSystemWindowsDirectory(szPath, _MAX_PATH));
        cchPath = _tcslen(szPath);
        if (szPath[cchPath - 1] != _T('\\'))
        {
            szPath[cchPath++] = _T('\\');
            szPath[cchPath] = _T('\0');
        } // if: no backslash on the end of the path
        hr = StringCchCopy( &szPath[ cchPath ], RTL_NUMBER_OF( szPath ) - cchPath, _T("Help\\") );
        ASSERT( SUCCEEDED( hr ) );
        _tsplitpath(szPath, szDrive, szDir, NULL, NULL);
        _tmakepath(szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp"));
        free((void *) m_pszHelpFilePath);
        fEnable = AfxEnableMemoryTracking(FALSE);
        m_pszHelpFilePath = _tcsdup(szPath);
        AfxEnableMemoryTracking(fEnable);
    }  // Construct the help path

    return CWinApp::InitInstance();

}  //*** CCluAdmExApp::InitInstance()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CCluAdmExApp::ExitInstance
//
//  Routine Description:
//      Cleans up this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Application's exit code.  0 indicates no errors.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CCluAdmExApp::ExitInstance(void)
{
    _Module.Term();
    return CWinApp::ExitInstance();

}  //*** CCluAdmExApp::ExitInstance()

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return ( AfxDllCanUnloadNow() && ( _Module.GetLockCount() == 0 ) ) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE /*bRegTypeLib*/);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//++
//
//  FormatError
//
//  Routine Description:
//      Format an error.
//
//  Arguments:
//      rstrError   [OUT] String in which to return the error message.
//      dwError     [IN] Error code to format.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void FormatError(CString & rstrError, DWORD dwError)
{
    DWORD   _cch;
    TCHAR   _szError[512];

    _cch = FormatMessage(
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    dwError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                    _szError,
                    sizeof(_szError) / sizeof(TCHAR),
                    0
                    );
    if (_cch == 0)
    {
        // Format the NT status code from NTDLL since this hasn't been
        // integrated into the system yet.
        _cch = FormatMessage(
                        FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                        ::GetModuleHandle(_T("NTDLL.DLL")),
                        dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                        _szError,
                        sizeof(_szError) / sizeof(TCHAR),
                        0
                        );

        if (_cch == 0)    
        {
            // One last chance: see if ACTIVEDS.DLL can format the status code
            HMODULE activeDSHandle = ::LoadLibrary(_T("ACTIVEDS.DLL"));

            _cch = FormatMessage(
                            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                            activeDSHandle,
                            dwError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                            _szError,
                            sizeof(_szError) / sizeof(TCHAR),
                            0
                            );

            ::FreeLibrary( activeDSHandle );
        }  // if:  error formatting status code from NTDLL
    }  // if:  error formatting status code from system

    if (_cch > 0)
    {
        rstrError = _szError;
    }  // if:  no error
    else
    {

#ifdef _DEBUG

        DWORD   _sc = GetLastError();

        TRACE(_T("FormatError() - Error 0x%08.8x formatting string for error code 0x%08.8x\n"), _sc, dwError);

#endif

        rstrError.Format(_T("Error 0x%08.8x"), dwError);

    }  // else:  error formatting the message

}  //*** FormatError()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllRegisterCluAdminExtension
//
//  Routine Description:
//      Register the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension registered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllRegisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hrReturn = RegisterCluAdminClusterExtension(
                hCluster,
                &CLSID_CoCluAdmEx
                );
    if ( hrReturn == S_OK )
    {
        while (*pwszResTypes != L'\0')
        {
            wprintf(L"  %ws\n", pwszResTypes);
            hr = RegisterCluAdminResourceTypeExtension(
                        hCluster,
                        pwszResTypes,
                        &CLSID_CoCluAdmEx
                        );
            if (hr != S_OK)
            {
                hrReturn = hr;
            }
            pwszResTypes += wcslen(pwszResTypes) + 1;
        }  // while:  more resource types
    }

    return hrReturn;

}  //*** DllRegisterCluAdminExtension()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DllUnregisterCluAdminExtension
//
//  Routine Description:
//      Unregister the extension with the cluster database.
//
//  Arguments:
//      hCluster        [IN] Handle to the cluster to modify.
//
//  Return Value:
//      S_OK            Extension unregistered successfully.
//      Win32 error code if another failure occurred.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDAPI DllUnregisterCluAdminExtension(IN HCLUSTER hCluster)
{
    HRESULT     hr;
    HRESULT     hrReturn = S_OK;
    LPCWSTR     pwszResTypes = g_wszResourceTypeNames;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    hrReturn = UnregisterCluAdminClusterExtension(
                hCluster,
                &CLSID_CoCluAdmEx
                );
    if ( hrReturn == S_OK )
    {
        while (*pwszResTypes != L'\0')
        {
            wprintf(L"  %ws\n", pwszResTypes);
            hr = UnregisterCluAdminResourceTypeExtension(
                        hCluster,
                        pwszResTypes,
                        &CLSID_CoCluAdmEx
                        );
            if (hr != S_OK)
            {
                hrReturn = hr;
            }
            pwszResTypes += wcslen(pwszResTypes) + 1;
        }  // while:  more resource types
    }

    return hrReturn;

}  //*** DllUnregisterCluAdminExtension()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\cluspage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-2000 Microsoft Corporation
//
//	Module Name:
//		ClusPage.h
//
//	Abstract:
//		CClusterSecurityPage class declaration.  This class will encapsulate
//		the cluster security extension page.
//
//	Implementation File:
//		ClusPage.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSPAGE_H_
#define _CLUSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif //_BASEPAGE_H_

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "ExtObj.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterSecurityInformation security information
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityInformation : public CSecurityInformation
{
	STDMETHOD(GetSecurity)(
		SECURITY_INFORMATION	RequestedInformation,
		PSECURITY_DESCRIPTOR *	ppSecurityDescriptor,
		BOOL					fDefault
		);
	STDMETHOD(SetSecurity)(
		SECURITY_INFORMATION	SecurityInformation,
		PSECURITY_DESCRIPTOR	pSecurityDescriptor
		);

public:
	CClusterSecurityInformation( void );
	virtual ~CClusterSecurityInformation( void )
	{
	} //*** ~CClusterSecurityInformation()

	HRESULT	HrInit( CClusterSecurityPage * pcsp, CString const & strServer, CString const & strNode );

protected:
	CClusterSecurityPage*	m_pcsp;

	BOOL BSidInSD( IN PSECURITY_DESCRIPTOR pSD, IN PSID pSid );
	HRESULT HrFixupSD( IN PSECURITY_DESCRIPTOR pSD );
	HRESULT HrAddSidToSD( IN OUT PSECURITY_DESCRIPTOR * ppSD, IN PSID pSid );

	CClusterSecurityPage*	Pcsp( void ) { return m_pcsp; };

}; //*** class CClusterSecurityInformation

/////////////////////////////////////////////////////////////////////////////
// CClusterSecurityPage security property page wrapper
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// KB: GalenB 18 Feb 1998
// This class only derives from CBasePropertyPage to get the
//  DwRead() and DwWrite() methods.  There is no hpage for this page in the
//  parent sheet.
/////////////////////////////////////////////////////////////////////////////

class CClusterSecurityPage : public CBasePropertyPage
{
public:
	CClusterSecurityPage( void );
	~CClusterSecurityPage( void );

			HRESULT					HrInit( IN CExtObject* peo );
	const	HPROPSHEETPAGE			GetHPage( void ) const		{ return m_hpage; };
	const	PSECURITY_DESCRIPTOR	Psec( void ) const			{ return m_psec; }
			LPCTSTR					StrClusterName( void ) const{ return Peo()->StrClusterName(); }
			HRESULT					HrSetSecurityDescriptor( IN PSECURITY_DESCRIPTOR psec );

protected:
	PSECURITY_DESCRIPTOR						m_psec;
	PSECURITY_DESCRIPTOR						m_psecPrev;
	HPROPSHEETPAGE								m_hpage;
	HKEY										m_hkey;
	BOOL										m_bSecDescModified;
	CComObject< CClusterSecurityInformation > *	m_psecinfo;
	PSID										m_pOwner;
	PSID										m_pGroup;
	BOOL										m_fOwnerDef;
	BOOL										m_fGroupDef;

	void					SetPermissions( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSecurityDescriptor( void );
	HRESULT					HrGetSDOwner( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSDGroup( IN const PSECURITY_DESCRIPTOR psec );
	HRESULT					HrSetSDOwner( IN PSECURITY_DESCRIPTOR psec );
	HRESULT					HrSetSDGroup( IN PSECURITY_DESCRIPTOR psec );
	HRESULT					HrGetSDFromClusterDB( OUT PSECURITY_DESCRIPTOR *ppsec );

}; //*** class CClusterSecurityPage

/////////////////////////////////////////////////////////////////////////////

#endif //_CLUSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\cluspage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation
//
//  Module Name:
//      ClusPage.cpp
//
//  Abstract:
//      CClusterSecurityPage class implementation.  This class will encapsulate
//      the cluster security extension page.
//
//  Author:
//      Galen Barbee    (galenb)    February 11, 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "ClusPage.h"
#include "AclUtils.h"
#include <clusudef.h>

static GENERIC_MAPPING ShareMap =
{
    CLUSAPI_READ_ACCESS,
    CLUSAPI_CHANGE_ACCESS,
    CLUSAPI_NO_ACCESS,
    CLUSAPI_ALL_ACCESS
};

static SI_ACCESS siClusterAccesses[] =
{
    { &GUID_NULL, CLUSAPI_ALL_ACCESS, MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_ALL), SI_ACCESS_GENERAL | SI_ACCESS_SPECIFIC /*| OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE*/ }
};

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::CClusterSecurityInformation
//
//  Routine Description:
//      Default contructor
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityInformation::CClusterSecurityInformation( void )
    : m_pcsp( NULL )
{
    m_pShareMap     = &ShareMap;
    m_psiAccess     = (SI_ACCESS *) &siClusterAccesses;
    m_nAccessElems  = ARRAYSIZE( siClusterAccesses );
    m_nDefAccess    = 0;
    m_dwFlags       =   SI_EDIT_PERMS
                      | SI_NO_ACL_PROTECT
                      //| SI_UGOP_PROVIDED
                      //| SI_NO_UGOP_ACCOUNT_GROUPS
                      //| SI_NO_UGOP_USERS
                      //| SI_NO_UGOP_LOCAL_GROUPS
                      //| SI_NO_UGOP_WELLKNOWN
                      //| SI_NO_UGOP_BUILTIN
                      ;

} //*** CClusterSecurityInformation::CClusterSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::GetSecurity
//
//  Routine Description:
//      Give our security descriptor to the ISecurityInfomation UI
//      so it can be displayed and edited.
//
//  Arguments:
//      RequestedInformation    [IN]
//      ppSecurityDescriptor    [IN OUT]
//      fDefault                [IN]
//
//  Return Value:
//      E_FAIL for error and S_OK for success.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterSecurityInformation::GetSecurity(
    IN      SECURITY_INFORMATION RequestedInformation,
    IN OUT  PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    IN      BOOL fDefault
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = E_FAIL;

    try
    {
        if ( ppSecurityDescriptor != NULL )
        {
            PSECURITY_DESCRIPTOR    pSD = NULL;

            pSD = ClRtlCopySecurityDescriptor( Pcsp()->Psec() );
            if ( pSD != NULL )
            {
                //hr = HrFixupSD( pSD );
                //if ( SUCCEEDED( hr ) )
                //{
                    *ppSecurityDescriptor = pSD;
                //}
                hr = S_OK;
            } // if: no errors copying the security descriptor
            else
            {
                hr = GetLastError();
                TRACE( _T("CClusterSecurityInformation::GetSecurity() - Error %08.8x copying the security descriptor.\n"), hr );
                hr = HRESULT_FROM_WIN32( hr );
            } // else: error copying the security descriptor
        }
        else
        {
            hr = S_OK;
        } // else: no security descriptor pointer
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::GetSecurity() - Unknown error occurred.\n") );
    }

    return hr;

} //*** CClusterSecurityInformation::GetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::SetSecurity
//
//  Routine Description:
//      ISecurityInformation is giving back the edited security descriptor.
//
//  Arguments:
//      SecurityInformation [IN]
//      pSecurityDescriptor [IN OUT]
//
//  Return Value:
//      E_FAIL for error and S_OK for success.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterSecurityInformation::SetSecurity(
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = E_FAIL;
    PSID    pSystemSid = NULL;
    PSID    pAdminSid = NULL;
    PSID    pNetServiceSid = NULL;

    try
    {
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        hr = CSecurityInformation::SetSecurity( SecurityInformation, pSecurityDescriptor );
        if ( hr == S_OK )
        {
            if ( AllocateAndInitializeSid(
                        &siaNtAuthority,
                        1,
                        SECURITY_LOCAL_SYSTEM_RID,
                        0, 0, 0, 0, 0, 0, 0,
                        &pSystemSid
                        ) )
            {
                CString strMsg;

                if ( BSidInSD( pSecurityDescriptor, pSystemSid ) )
                {
                    //
                    // allocate and init the Administrators group sid
                    //
                    if ( AllocateAndInitializeSid(
                                &siaNtAuthority,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                DOMAIN_ALIAS_RID_ADMINS,
                                0, 0, 0, 0, 0, 0,
                                &pAdminSid
                                ) )
                    {
                        if ( BSidInSD( pSecurityDescriptor, pAdminSid ) )
                        {
                            //
                            // allocate and init the Network Service sid
                            //
                            if ( AllocateAndInitializeSid(
                                        &siaNtAuthority,
                                        1,
                                        SECURITY_NETWORK_SERVICE_RID,
                                        0, 0, 0, 0, 0, 0, 0,
                                        &pNetServiceSid
                                        ) )
                            {
                                if ( BSidInSD( pSecurityDescriptor, pNetServiceSid ) )
                                {
                                    hr = Pcsp()->HrSetSecurityDescriptor( pSecurityDescriptor );
                                } // if: service SID in the SD
                                else
                                {
                                    strMsg.LoadString( IDS_NETSERVICE_ACCOUNT_NOT_SPECIFIED );
                                    AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                                    hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                                } // else
                            } // if: allocate and init service SID
                        } // if: admin SID in the SD
                        else
                        {
                            strMsg.LoadString( IDS_ADMIN_ACCOUNT_NOT_SPECIFIED );
                            AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                            hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                        } // else
                    } // if: allocate and init admin SID
                } // if: system SID in the SD
                else
                {
                    strMsg.LoadString( IDS_SYS_ACCOUNT_NOT_SPECIFIED );
                    AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );

                    hr = S_FALSE;   // if there are missing required accounts then return S_FALSE to keep AclUi alive.
                } // else
            } // if: allocate and init system SID
        } // if: CSecurityInformation::SetSecurity() worked
    }
    catch( ... )
    {
        ;
    }

    if ( pSystemSid != NULL )
    {
        FreeSid( pSystemSid );
    }

    if ( pAdminSid != NULL )
    {
        FreeSid( pAdminSid );
    }

    if ( pNetServiceSid != NULL )
    {
        FreeSid( pNetServiceSid );
    }

    return hr;

} //*** CClusterSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrInit
//
//  Routine Description:
//      Initialize method.
//
//  Arguments:
//      pcsp        [IN]    back pointer to parent property page wrapper
//      strServer   [IN]    cluster name
//
//  Return Value:
//      S_OK for success.  E_FAIL for failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrInit(
    IN CClusterSecurityPage *   pcsp,
    IN CString const &          strServer,
    IN CString const &          strNode
    )
{
    ASSERT( pcsp != NULL );
    ASSERT( strServer.GetLength() > 0 );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    m_pcsp                      = pcsp;
    m_strServer                 = strServer;
    m_strNode                   = strNode;
    m_nLocalSIDErrorMessageID   = IDS_LOCAL_ACCOUNTS_SPECIFIED_CLUS;

    return S_OK;

} //*** CClusterSecurityInformation::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::BSidInSD
//
//  Routine Description:
//      Determines if there is an ACEs for the passed in SID in the
//      Security Descriptor (pSD) after the ACL editor has been called
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//      pSid    [IN] - SID to look for
//
//  Return Value:
//      TRUE if an ACE for the SID was found, False otherwise.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterSecurityInformation::BSidInSD(
    IN PSECURITY_DESCRIPTOR pSD,
    IN PSID                 pSid
    )
{
    BOOL    bSIdInACL = FALSE;

    try
    {
        PACL    pDACL           = NULL;
        BOOL    bHasDACL        = FALSE;
        BOOL    bDaclDefaulted  = FALSE;

        if ( ::GetSecurityDescriptorDacl( pSD, &bHasDACL, &pDACL, &bDaclDefaulted ) )
        {
            if ( bHasDACL && ( pDACL != NULL ) && ::IsValidAcl( pDACL ) )
            {
                ACL_SIZE_INFORMATION    asiAclSize;
                ACCESS_ALLOWED_ACE *    paaAllowedAce;

                if ( ::GetAclInformation( pDACL, (LPVOID) &asiAclSize, sizeof( asiAclSize ), AclSizeInformation ) )
                {
                    //
                    // Search the ACL for the SID
                    //
                    for ( DWORD dwCount = 0; dwCount < asiAclSize.AceCount; dwCount++ )
                    {
                        if ( ::GetAce( pDACL, dwCount, (LPVOID *) &paaAllowedAce ) )
                        {
                            if ( paaAllowedAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE )
                            {
                                if ( EqualSid( &paaAllowedAce->SidStart, pSid ) )
                                {
                                    bSIdInACL = TRUE;
                                    break;
                                } // if: EqualSid
                            } // if: is this an access allowed ace?
                        } // if: can we get the ace from the DACL?
                    } // for
                } // if: get ACL information
            } // if: is the ACL valid
        } // if: get the ACL from the SD
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::BSidInSD() - Unknown error occurred.\n") );
    }

    return bSIdInACL;

} //*** CClusterSecurityInformation::BSidInSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrFixupSD
//
//  Routine Description:
//      Performs any fixups to the SD that may be requrired.
//
//  Arguments:
//      pSD     [IN] - Security Descriptor to be checked.
//
//  Return Value:
//      S_OK, or other Win32 error
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrFixupSD(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    PSID    pSystemSid = NULL;
    PSID    pAdminSid = NULL;
    PSID    pNetServiceSid = NULL;

    try
    {
        SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

        if ( AllocateAndInitializeSid( &siaNtAuthority,
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0, 0, 0, 0, 0, 0, 0,
                                       &pSystemSid ) )
        {
            if ( ! BSidInSD( pSD, pSystemSid ) )
            {
                HrAddSidToSD( &pSD, pSystemSid );
            } // if: system SID found in SD
        } // if: allocate system SID

        //
        // allocate and init the Administrators group sid
        //
        if ( AllocateAndInitializeSid(
                    &siaNtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    &pAdminSid
                    ) ) {
            if ( ! BSidInSD( pSD, pAdminSid ) )
            {
                HrAddSidToSD( &pSD, pAdminSid );
            } // if: admin SID found in SD
        } // if: allocate admin SID

        //
        // allocate and init the Network Service sid
        //
        if ( AllocateAndInitializeSid(
                    &siaNtAuthority,
                    1,
                    SECURITY_NETWORK_SERVICE_RID,
                    0, 0, 0, 0, 0, 0, 0,
                    &pNetServiceSid
                    ) ) {
            if ( ! BSidInSD( pSD, pNetServiceSid ) )
            {
                HrAddSidToSD( &pSD, pNetServiceSid );
            } // if: Network Service SID found in SD
        } // if: allocate Network Service SID
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::HrFixupSD() - Unknown error occurred.\n") );
    }

    if ( pSystemSid != NULL )
    {
        FreeSid( pSystemSid );
    }

    if ( pAdminSid != NULL )
    {
        FreeSid( pAdminSid );
    }

    if ( pNetServiceSid != NULL )
    {
        FreeSid( pNetServiceSid );
    }

    return hr;

} //*** CClusterSecurityInformation::HrFixupSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityInformation::HrAddSidToSD
//
//  Routine Description:
//      Adds the passed in SID to the DACL of the passed in SD
//
//  Arguments:
//      ppSD    [IN, OUT]   - Security Descriptor to be added to
//      PSid    [IN]        - SID to add
//
//  Return Value:
//      S_OK, or other Win32 error
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityInformation::HrAddSidToSD(
    IN OUT PSECURITY_DESCRIPTOR *   ppSD,
    IN     PSID                     pSid
    )
{
    HRESULT                 hr = S_OK;
    DWORD                   sc;
    SECURITY_DESCRIPTOR     sd;
    DWORD                   dwSDLen = sizeof( SECURITY_DESCRIPTOR );
    PACL                    pDacl = NULL;
    DWORD                   dwDaclLen = 0;
    PACL                    pSacl = NULL;
    DWORD                   dwSaclLen = 0;
    PSID                    pOwnerSid = NULL;
    DWORD                   dwOwnerSidLen = 0;
    PSID                    pGroupSid = NULL;
    DWORD                   dwGroupSidLen = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    DWORD                   dwNewSDLen = 0;

    try
    {
        BOOL bRet = FALSE;

        bRet = ::MakeAbsoluteSD(    *ppSD,              // address of self relative SD
                                    &sd,                // address of absolute SD
                                    &dwSDLen,           // address of size of absolute SD
                                    NULL,               // address of discretionary ACL
                                    &dwDaclLen,         // address of size of discretionary ACL
                                    NULL,               // address of system ACL
                                    &dwSaclLen,         // address of size of system ACL
                                    NULL,               // address of owner SID
                                    &dwOwnerSidLen,     // address of size of owner SID
                                    NULL,               // address of primary-group SID
                                    &dwGroupSidLen      // address of size of group SID
                                    );
        if ( ! bRet )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            if ( hr != ERROR_INSUFFICIENT_BUFFER )      // Duh, we're trying to find out how big the buffer should be?
            {
                goto fnExit;
            }
        }

        //
        // increase the DACL length to hold one more ace and its sid.
        //
        dwDaclLen += ( sizeof( ACCESS_ALLOWED_ACE ) + GetLengthSid( pSid ) +1024 );
        pDacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwDaclLen );
        if ( pDacl == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto fnExit;
        }

        InitializeAcl( pDacl,  dwDaclLen, ACL_REVISION );

        if ( dwSaclLen > 0 )
        {
            pSacl = (PACL) ::LocalAlloc( LMEM_ZEROINIT, dwSaclLen );
            if ( pSacl == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        if ( dwOwnerSidLen > 0 )
        {
            pOwnerSid = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwOwnerSidLen );
            if ( pOwnerSid == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        if ( dwGroupSidLen > 0 )
        {
            pGroupSid = (PSID) ::LocalAlloc( LMEM_ZEROINIT, dwGroupSidLen );
            if ( pGroupSid == NULL )
            {
                hr = E_OUTOFMEMORY;
                goto fnExit;
            }
        }

        bRet = ::MakeAbsoluteSD(    *ppSD,              // address of self relative SD
                                    &sd,                // address of absolute SD
                                    &dwSDLen,           // address of size of absolute SD
                                    pDacl,              // address of discretionary ACL
                                    &dwDaclLen,         // address of size of discretionary ACL
                                    pSacl,              // address of system ACL
                                    &dwSaclLen,         // address of size of system ACL
                                    pOwnerSid,          // address of owner SID
                                    &dwOwnerSidLen,     // address of size of owner SID
                                    pGroupSid,          // address of primary-group SID
                                    &dwGroupSidLen      // address of size of group SID
                                    );
        if ( !bRet )
        {
            goto fnExit;
        }

        //
        // Add the ACE for the SID to the DACL
        //
//      if ( !AddAccessAllowedAceEx( pDacl,
//                                     ACL_REVISION,
//                                     CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE,
//                                     CLUSAPI_ALL_ACCESS,
//                                     pSid ) )
        if ( ! AddAccessAllowedAce(
                    pDacl,
                    ACL_REVISION,
                    CLUSAPI_ALL_ACCESS,
                    pSid
                    ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorDacl( &sd, TRUE, pDacl, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorOwner( &sd, pOwnerSid, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorGroup( &sd, pGroupSid, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        if ( ! ::SetSecurityDescriptorSacl( &sd, TRUE, pSacl, FALSE ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            goto fnExit;
        }

        dwNewSDLen = 0 ;

        if ( ! ::MakeSelfRelativeSD( &sd, NULL, &dwNewSDLen ) )
        {
            sc = ::GetLastError();
            hr = HRESULT_FROM_WIN32( sc );
            if ( hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) // Duh, we're trying to find out how big the buffer should be?
            {
                goto fnExit;
            }
        }

        pNewSD = ::LocalAlloc( LPTR, dwNewSDLen );
        if ( pNewSD != NULL )
        {
            if ( ! ::MakeSelfRelativeSD( &sd, pNewSD, &dwNewSDLen ) )
            {
                sc = ::GetLastError();
                hr = HRESULT_FROM_WIN32( sc );
                goto fnExit;
            }

            ::LocalFree( *ppSD );
            *ppSD = pNewSD;
            hr = ERROR_SUCCESS;
        } else
        {
            hr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    catch ( ... )
    {
        TRACE( _T("CClusterSecurityInformation::HrAddSidToSD() - Unknown error occurred.\n") );
    }

fnExit:

    if ( pSacl != NULL )
    {
        ::LocalFree( pSacl );
    }

    if ( pOwnerSid != NULL )
    {
        ::LocalFree( pOwnerSid );
    }

    if ( pGroupSid != NULL )
    {
        ::LocalFree( pGroupSid );
    }

    return hr;

} //*** CClusterSecurityInformation::HrAddSidToSD()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::CClusterSecurityPage
//
//  Routine Description:
//      Default contructor.
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityPage::CClusterSecurityPage( void )
    : m_psec( NULL )
    , m_psecPrev( NULL )
    , m_hpage( 0 )
    , m_hkey( 0 )
    , m_psecinfo( NULL )
    , m_pOwner( NULL )
    , m_pGroup( NULL )
    , m_fOwnerDef( FALSE )
    , m_fGroupDef( FALSE )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    m_bSecDescModified = FALSE;

} //*** CClusterSecurityPage::CClusterSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::~CClusterSecurityPage
//
//  Routine Description:
//      Destructor
//
//  Arguments:
//      none
//
//  Return Value:
//      none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterSecurityPage::~CClusterSecurityPage( void )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    ::LocalFree( m_psec );
    m_psec = NULL;

    ::LocalFree( m_psecPrev );
    m_psecPrev = NULL;

    ::LocalFree( m_pOwner );
    m_pOwner = NULL;

    ::LocalFree( m_pGroup );
    m_pGroup = NULL;

    m_psecinfo->Release();

} //*** CClusterSecurityPage::~CClusterSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrInit
//
//  Routine Description:
//      Initialize method.
//
//  Arguments:
//      peo     [IN]    back pointer to parent extension object.
//
//  Return Value:
//      S_OK        Page was initialized successfully.
//      hr          Error initializing the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrInit( IN CExtObject * peo )
{
    ASSERT( peo != NULL );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT _hr = S_OK;
    DWORD   _sc;

    if ( peo != NULL )
    {
        m_peo = peo;

        _hr = CComObject< CClusterSecurityInformation >::CreateInstance( &m_psecinfo );
        if ( SUCCEEDED( _hr ) )
        {
            m_psecinfo->AddRef();

            m_hkey = GetClusterKey( Hcluster(), KEY_ALL_ACCESS );
            if ( m_hkey != NULL )
            {
                _hr = HrGetSecurityDescriptor();
                if ( SUCCEEDED( _hr ) )
                {
                    CString strServer;
                    CString strNode;

                    strServer.Format( _T( "\\\\%s" ), StrClusterName() );

                    // Get the node on which the Cluster Name resource is online.
                    if ( BGetClusterNetworkNameNode( strNode ) )
                    {
                        _hr = m_psecinfo->HrInit( this, strServer, strNode );
                        if ( SUCCEEDED( _hr ) )
                        {
                            m_hpage = CreateClusterSecurityPage( m_psecinfo );
                            if ( m_hpage == NULL )
                            {
                                _sc = ::GetLastError();
                                _hr = HRESULT_FROM_WIN32( _sc );
                            } // if: error creating the page
                        } // if: initialized security info successfully
                    } // if: retrieved cluster network name node successfully
                    else
                    {
                    } // else: error getting cluster network name node
                } // if: error getting SD
            } // if: retrieved cluster key
            else
            {
                _sc = ::GetLastError();
                _hr = HRESULT_FROM_WIN32( _sc );
                TRACE( _T( "CClusterSecurityPage::ScInit() - Failed to get the cluster key, 0x%08lx.\n" ), _sc );
            } // else: error getting cluster key
        } // if: created security info object successfully
        else
        {
            TRACE( _T( "CClusterSecurityPage::ScInit() - Failed to create CClusterSecurityInformation object, %0x%08lx.\n" ), _hr );
        }
    } // if: extension object is available

    return _hr;

} //*** CClusterSecurityPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSecurityDescriptor
//
//  Routine Description:
//      Get the security descriptor from the cluster database or create a
//      default one if it doesn't exist.
//
//  Arguments:
//      none
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSecurityDescriptor( void )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );
    HRESULT                 hr = S_OK;
    PSECURITY_DESCRIPTOR    psec = NULL;

    hr = HrGetSDFromClusterDB( &psec );                                             //uses localalloc
    if ( FAILED( hr ) || ( psec == NULL ) || ( IsValidSecurityDescriptor( psec ) == FALSE ) )
    {
        DWORD   sc;
        DWORD   dwLen = 0;
 
        //
        //  If the SD was not found or was not a valid SD then build a default
        //  SD and save it into the cluster DB...
        //
 
        TRACE( _T( "Security Descriptor is NULL.  Build default SD" ) );
        sc = ::ClRtlBuildDefaultClusterSD( NULL, &psec, &dwLen );                   //uses localalloc
        hr = HRESULT_FROM_WIN32( sc );
        if ( FAILED( hr ) )
        {
            TRACE( _T( "ClRtlBuildDefaultClusterSD failed, 0x%08x" ), hr );
        } // if: error building the default SD
        else
        {
            SetPermissions( psec );
        } // else: 
    } // if: error getting SD from cluster database

    if ( SUCCEEDED( hr ) )
    {
        delete m_psec;
        m_psec = ClRtlCopySecurityDescriptor( psec );
        hr = GetLastError();                // Get the last error
        ::LocalFree( psec );
        psec = NULL;
        if ( m_psec == NULL )
        {
            hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
            goto Cleanup;
        } // if: error copying the security descriptor

        hr = HrGetSDOwner( m_psec );
        if ( SUCCEEDED( hr ) )
        {
            hr = HrGetSDGroup( m_psec );
            if ( SUCCEEDED( hr ) )
            {
                m_psecPrev = ClRtlCopySecurityDescriptor( m_psec );
                if ( m_psecPrev == NULL )
                {
                    hr = GetLastError();            // Get the last error
                    hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                    goto Cleanup;
                } // if: error copying the security descriptor
            } // if: got SD group successfully
        } // if: got SD owner successfully
    } // if: retrieved or built SD successfully

#ifdef _DEBUG
    if ( m_psec != NULL )
    {
        ASSERT( IsValidSecurityDescriptor( m_psec ) );
    }
#endif

Cleanup:
    return hr;

} //*** CClusterSecurityPage::HrGetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSecurityDescriptor
//
//  Routine Description:
//      Save the new security descriptor to the cluster database.
//
//  Arguments:
//      psec    [IN]    the new security descriptor
//
//  Return Value:
//      hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    ASSERT( psec != NULL );
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );

    HRESULT hr = S_OK;

    try
    {
        if ( psec != NULL )
        {
            CWaitCursor wc;

            ASSERT( IsValidSecurityDescriptor( psec ) );
            if ( IsValidSecurityDescriptor( psec ) )
            {
                hr = HrSetSDOwner( psec );
                if ( SUCCEEDED( hr ) )
                {
                    hr = HrSetSDGroup( psec );
                    if ( SUCCEEDED( hr ) )
                    {
                        LocalFree( m_psecPrev );
                        m_psecPrev = NULL;

                        if ( m_psec == NULL )
                        {
                            m_psecPrev = NULL;
                        } // if: no previous value
                        else
                        {
                            m_psecPrev = ClRtlCopySecurityDescriptor( m_psec );
                            if ( m_psecPrev == NULL )
                            {
                                hr = GetLastError();            // Get the last error
                                TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Error %08.8x copying the previous SD.\n" ), hr );
                                hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                                goto Cleanup;
                            } // if: error copying the security descriptor
                        } // else: previous value exists

                        LocalFree( m_psec );
                        m_psec = NULL;

                        m_psec = ClRtlCopySecurityDescriptor( psec );
                        if ( m_psec == NULL )
                        {
                            hr = GetLastError();            // Get the last error
                            TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Error %08.8x copying the new SD.\n" ), hr );
                            hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
                            goto Cleanup;
                        } // if: error copying the security descriptor

                        SetPermissions( m_psec );
                    } // if: SD group set successfully
                } // if: SD owner set successfully
            } // if: security descriptor is valid
            else
            {
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_SECURITY_DESCR );
                TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Invalid security descriptor.\n" ) );
            } // else: invalid security descriptor
        } // if: security descriptor specified
        else
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_SECURITY_DESCR );
        } // else: no security descriptor specified
    } // try
    catch ( ... )
    {
        hr = E_FAIL;
        TRACE( _T( "CClusterSecurityPage::HrSetSecurityDescriptor() - Unknown error occurred.\n" ) );
    }

Cleanup:
    return hr;

}  //*** CClusterSecurityPage::HrSetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::SetPermissions
//
//  Routine Description:
//      Set the permissions for accessing the cluster.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusterItem::WriteValue().
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterSecurityPage::SetPermissions(
    IN const PSECURITY_DESCRIPTOR psec
)
{
    ASSERT( psec != NULL );
    ASSERT( IsValidSecurityDescriptor( psec ) );

    DWORD       cbNew;
    DWORD       cbOld;
    LPBYTE      psecPrev;       // buffer for use by ScWriteValue.  Prev SD is saved elsewhere now.

    // Get the length of the two security descriptors.
    if ( m_psecPrev == NULL )
    {
        cbOld = 0;
    }
    else
    {
        cbOld = ::GetSecurityDescriptorLength( m_psecPrev );
    }

    if ( psec == NULL )
    {
        cbNew = 0;
    }
    else
    {
        cbNew = ::GetSecurityDescriptorLength( psec );
    }

    // Allocate a new buffer for the previous data pointer.
    try
    {
        psecPrev = new BYTE [cbOld];
        if ( psecPrev == NULL )
        {
            return;
        } // if: error allocating previous data buffer
    }
    catch ( CMemoryException * )
    {
        return;
    }  // catch:  CMemoryException
    ::CopyMemory( psecPrev, m_psecPrev, cbOld );

    ScWriteValue( CLUSREG_NAME_CLUS_SD, (LPBYTE) psec, cbNew, (LPBYTE *) &psecPrev, cbOld, m_hkey );

    //
    //  Convert the NT5 SD to one that is compatible with the ACLEdit stuff on
    //  NT4.  If that conversion fails then don't write it to the cluster DB.
    //

    PSECURITY_DESCRIPTOR psd = NULL;

    psd = ClRtlConvertClusterSDToNT4Format( psec );
    if ( psd != NULL )
    {
        ScWriteValue( CLUSREG_NAME_CLUS_SECURITY, (LPBYTE) psd, cbNew, (LPBYTE *) &psecPrev, cbOld, m_hkey );
        ::LocalFree( psd );
    } // if:

    delete [] psecPrev;

}  //*** CClusterSecurityPage::SetPermissions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDOwner
//
//  Routine Description:
//      Get the owner sid and save it.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDOwner(
    IN const PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr      = S_OK;
    DWORD   sc;
    PSID    pOwner  = NULL;

    if ( ::GetSecurityDescriptorOwner( psec, &pOwner, &m_fOwnerDef ) != 0 )
    {
        // The security descriptor does not have an owner.
        if ( pOwner == NULL )
        {
            ::LocalFree( m_pOwner );
            m_pOwner = NULL;
        }
        else
        {
            DWORD   dwLen = ::GetLengthSid( pOwner );

            // copy the sid since AclUi will free the SD...
            hr = ::GetLastError();
            if ( SUCCEEDED( hr ) )
            {
                ::LocalFree( m_pOwner );

                m_pOwner = ::LocalAlloc( LMEM_ZEROINIT, dwLen );
                if ( m_pOwner != NULL )
                {
                    if ( ::CopySid( dwLen, m_pOwner, pOwner ) )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        sc = ::GetLastError();
                        hr = HRESULT_FROM_WIN32( sc );
                    }
                }
                else
                {
                    sc = ::GetLastError();
                    hr = HRESULT_FROM_WIN32( sc );
                }
            }
        }
    }
    else
    {
        sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrGetSDOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDGroup
//
//  Routine Description:
//      Get the group sid and save it.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDGroup(
    IN const PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr      = S_OK;
    DWORD   sc;
    PSID    pGroup  = NULL;

    if ( ::GetSecurityDescriptorOwner( psec, &pGroup, &m_fOwnerDef ) != 0 )
    {
        // This SID does not contain group information.
        if ( pGroup == NULL )
        {
            ::LocalFree( m_pGroup );
            m_pGroup = NULL;
        }
        else
        {
            DWORD   dwLen = ::GetLengthSid( pGroup );

            // copy the sid since AclUi will free the SD...
            hr = ::GetLastError();
            if ( SUCCEEDED( hr ) )
            {
                ::LocalFree( m_pGroup );
                m_pGroup = ::LocalAlloc( LMEM_ZEROINIT, dwLen );
                if ( m_pGroup != NULL )
                {
                    if ( ::CopySid( dwLen, m_pGroup, pGroup ) )
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        sc = ::GetLastError();
                        hr = HRESULT_FROM_WIN32( sc );
                    }
                }
                else
                {
                    sc = ::GetLastError();
                    hr = HRESULT_FROM_WIN32( sc );
                }
            }
        }
    }
    else
    {
        sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrGetSDGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSDOwner
//
//  Routine Description:
//      Set the owner sid.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSDOwner(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr = S_OK;

    if ( !::SetSecurityDescriptorOwner( psec, m_pOwner, m_fOwnerDef ) )
    {
        DWORD sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrSetSDOwner()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrSetSDGroup
//
//  Routine Description:
//      Set the group sid.
//
//  Arguments:
//      psec            [IN] Security descriptor.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrSetSDGroup(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    HRESULT hr = S_OK;

    if ( !::SetSecurityDescriptorGroup( psec, m_pGroup, m_fGroupDef ) )
    {
        DWORD sc = ::GetLastError();
        hr = HRESULT_FROM_WIN32( sc );
    }

    return( hr );

}  //*** CClusterSecurityPage::HrSetSDGroup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterSecurityPage::HrGetSDFromClusterDB
//
//  Routine Description:
//      Retrieve the SD from the cluster database.
//
//  Arguments:
//      ppsec           [OUT] Pointer to security descriptor.
//
//  Return Value:
//      S_OK for success
//      Any error returned by ScReadValue
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterSecurityPage::HrGetSDFromClusterDB(
    OUT PSECURITY_DESCRIPTOR * ppsec
    )
{
    AFX_MANAGE_STATE( ::AfxGetStaticModuleState() );
    ASSERT( ppsec != NULL );

    HRESULT                 hr = E_FAIL;
    PSECURITY_DESCRIPTOR    psd = NULL;

    if ( ppsec != NULL )
    {
        DWORD sc;

        // Read the security descriptor.
        sc = ScReadValue( CLUSREG_NAME_CLUS_SD, (LPBYTE *) &psd, m_hkey ); //alloc using new
        hr = HRESULT_FROM_WIN32( sc );

        if ( FAILED( hr ) || ( psd == NULL ) )
        {   // try getting the NT4 SD...
            sc = ScReadValue( CLUSREG_NAME_CLUS_SECURITY, (LPBYTE *) &psd, m_hkey ); //alloc using new
            hr = HRESULT_FROM_WIN32( sc );

            if ( SUCCEEDED( hr ) )
            {
                *ppsec = ::ClRtlConvertClusterSDToNT5Format( psd );
            }
        }
        else
        {
            *ppsec = ClRtlCopySecurityDescriptor( psd );
            if ( *ppsec == NULL )
            {
                hr = GetLastError();            // Get the last error
                hr = HRESULT_FROM_WIN32( hr );  // Convert to HRESULT
            } // if: error copying the security descriptor
        }

        delete [] psd;

        if ( *ppsec != NULL )
        {
            ::ClRtlExamineSD( *ppsec, "[ClusPage]" );
        } // if: security descriptor is available to be examined
    }

    return hr;

}  //*** CClusterSecurityPage::HrGetSDFromClusterDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\disks.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Disks.cpp
//
//  Abstract:
//      Implementation of the CPhysDiskParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "Disks.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPhysDiskParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPhysDiskParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CPhysDiskParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CPhysDiskParamsPage)
    ON_CBN_SELCHANGE(IDC_PP_DISKS_PARAMS_DISK, OnChangeDisk)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::CPhysDiskParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPhysDiskParamsPage::CPhysDiskParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_DISKS_PARAMETERS, g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CPhysDiskParamsPage)
    m_strDisk = _T("");
    //}}AFX_DATA_INIT

    m_dwSignature = 0;

    m_pbAvailDiskInfo = NULL;
    m_cbAvailDiskInfo = 0;
    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    // Setup the property array.
    {
        m_rgProps[epropSignature].Set(REGPARAM_DISKS_SIGNATURE, m_dwSignature, m_dwPrevSignature);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_DISKS_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_DISKS_PARAMETERS;

}  //*** CPhysDiskParamsPage::CPhysDiskParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::~CPhysDiskParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPhysDiskParamsPage::~CPhysDiskParamsPage(void)
{
    delete [] m_pbAvailDiskInfo;
    delete [] m_pbDiskInfo;

}  //*** CPhysDiskParamsPage::~CPhysDiskParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CPhysDiskParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if ( FAILED( _hr ) )
        {
            break;
        } // if: error from base class method

        // Collect available disk information.
        BGetAvailableDisks();

        // If creating a new resource, select the first disk.
        // Otherwise, collect information about the selected disk.
        if (BWizard())
        {
            CLUSPROP_BUFFER_HELPER  buf;

            buf.pb = m_pbAvailDiskInfo;
            if (m_cbAvailDiskInfo > 0)
            {
                while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
                {
                    if (BStringFromDiskInfo(buf, m_cbAvailDiskInfo, m_strDisk))
                        break;
                    ASSERT( (buf.pSyntax->dw == CLUSPROP_SYNTAX_ENDMARK)
                        ||  (buf.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE));
                }  // while:  more entries in the list
            }  // if:  there are available disks
        }  // if:  creating a new resource
        else
        {
            // Don't return false because that will prevent the page from showing up.
            BGetDiskInfo();

            // Get the current state of the resource.
            m_crs = GetClusterResourceState(Peo()->PrdResData()->m_hresource, NULL, NULL, NULL, NULL );
        }  // else:  viewing an existing resource
    } while ( 0 );

    return _hr;

}  //*** CPhysDiskParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::DoDataExchange(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CPhysDiskParamsPage)
        DDX_Control(pDX, IDC_PP_DISKS_PARAMS_DISK, m_cboxDisk);
        DDX_Text(pDX, IDC_PP_DISKS_PARAMS_DISK, m_strDisk);
        //}}AFX_DATA_MAP

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                if (BWizard()
                    && !(  (m_strDisk.GetLength() == 0)
                        && (m_crs == ClusterResourceOffline)))
                {
                    DDV_RequiredText(pDX, IDC_PP_DISKS_PARAMS_DISK, IDC_PP_DISKS_PARAMS_DISK_LABEL, m_strDisk);
                    m_dwSignature = (DWORD)m_cboxDisk.GetItemData(m_cboxDisk.GetCurSel());
                    ASSERT(m_dwSignature != 0);
                }  // if:  not offline with an empty disk string
            }  // if:  Back button not pressed
        }  // if:  saving data
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CPhysDiskParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set the combobox as read-only if not creating a new resource.
    m_cboxDisk.EnableWindow(BWizard());

    // Fill the disks list.
    FillList();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CPhysDiskParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strDisk.GetLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CPhysDiskParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    if (!(   (m_strDisk.GetLength() == 0)
          && (m_crs == ClusterResourceOffline)))
    {
        // Call the base class method.
        if (!CBasePropertyPage::BApplyChanges())
            return FALSE;

        // Reread the disk info and the available disks.
        // Ignore errors because we can't do anything about it at this point anyway.
        BGetAvailableDisks();
        BGetDiskInfo();

        // Refill the combobox.
        FillList();
    }  // if:  not offline with an empty disk string

    return TRUE;

}  //*** CPhysDiskParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::OnChangeDisk
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Disks combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::OnChangeDisk(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_cboxDisk.GetWindowTextLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CPhysDiskParamsPage::OnChangeDisk()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BGetAvailableDisks
//
//  Routine Description:
//      Get the list of disks for this type of resource that can be assigned
//      to a resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BGetAvailableDisks(void)
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof(CLUSPROP_DWORD)
                            + sizeof(CLUSPROP_SCSI_ADDRESS)
                            + sizeof(CLUSPROP_DISK_NUMBER)
                            + sizeof(CLUSPROP_PARTITION_INFO)
                            + sizeof(CLUSPROP_SYNTAX);
    PBYTE   pbDiskInfo = NULL;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[cbDiskInfo];
        dwStatus = ClusterResourceTypeControl(
                        Peo()->Hcluster(),
                        Peo()->PrdResData()->m_strResTypeName,
                        NULL,
                        CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[cbDiskInfo];
            dwStatus = ClusterResourceTypeControl(
                            Peo()->Hcluster(),
                            Peo()->PrdResData()->m_strResTypeName,
                            NULL,
                            CLUSCTL_RESOURCE_TYPE_STORAGE_GET_AVAILABLE_DISKS,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer too small
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_AVAILABLE_DISKS_ERROR,
                        Peo()->PrdResData()->m_strResTypeName,
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        delete [] pbDiskInfo;
        nte.ReportError();
        nte.Delete();
        return FALSE;
    }  // if:  error getting disk info

    delete [] m_pbAvailDiskInfo;
    m_pbAvailDiskInfo = pbDiskInfo;
    m_cbAvailDiskInfo = cbDiskInfo;

    return TRUE;

}  //*** CPhysDiskParamsPage::BGetAvailableDisks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BGetDiskInfo
//
//  Routine Description:
//      Get information about the currently selected disk.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BGetDiskInfo(void)
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof(CLUSPROP_DWORD)
                            + sizeof(CLUSPROP_SCSI_ADDRESS)
                            + sizeof(CLUSPROP_DISK_NUMBER)
                            + sizeof(CLUSPROP_PARTITION_INFO)
                            + sizeof(CLUSPROP_SYNTAX);
    PBYTE   pbDiskInfo = NULL;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[cbDiskInfo];
        dwStatus = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[cbDiskInfo];
            dwStatus = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer too small
    }  // try
    catch (CMemoryException * pme)
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if (dwStatus != ERROR_SUCCESS)
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_DISK_INFO_ERROR,
                        Peo()->PrdResData()->m_strName,
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        delete [] pbDiskInfo;
        nte.ReportError();
        nte.Delete();
        return FALSE;
    }  // if:  error getting disk info

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = pbDiskInfo;
    m_cbDiskInfo = cbDiskInfo;

    return TRUE;

}  //*** CPhysDiskParamsPage::BGetDiskInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::BStringFromDiskInfo
//
//  Routine Description:
//      Convert disk information to a string for display.
//
//  Arguments:
//      rbuf            [IN OUT] Buffer pointer.
//      cbBuf           [IN] Number of bytes in the buffer.
//      rstr            [OUT] String to fill.
//      pdwSignature    [OUT] Signature associated with the disk info being
//                          returned.
//
//  Return Value:
//      TRUE        A string was produced from disk info.
//      FALSE       No string could be produced.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPhysDiskParamsPage::BStringFromDiskInfo(
    IN OUT CLUSPROP_BUFFER_HELPER & rbuf,
    IN DWORD                        cbBuf,
    OUT CString &                   rstr,
    OUT DWORD *                     pdwSignature // = NULL
    ) const
{
    CString strPartitionInfo;
    DWORD   dwSignature = 0;
    DWORD   cbData;
    BOOL    bDisplay;

    ASSERT(cbBuf > 0);
    ASSERT(rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK);

    rstr = _T("");

    if (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
    {
        do
        {
            // Calculate the size of the value.
            cbData = sizeof(*rbuf.pValue) + ALIGN_CLUSPROP(rbuf.pValue->cbLength);
            ASSERT(cbData <= cbBuf);

            // Parse the value.
            if (rbuf.pSyntax->dw == CLUSPROP_SYNTAX_DISK_SIGNATURE)
            {
                // Save the signature.
                dwSignature = rbuf.pDwordValue->dw;
                ASSERT(dwSignature != 0);
            }  // if:  signature
            else if (rbuf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
            {
                // Add the partition to the string if it is a usable partition
                // and hasn't been added already.  If the resource is offline,
                // don't check the usable flag.
                bDisplay = ( rstr.Find(rbuf.pPartitionInfoValue->szDeviceName) == -1 );
                if ( bDisplay && ( m_crs == ClusterResourceOnline ) )
                {
                    bDisplay = (rbuf.pPartitionInfoValue->dwFlags & CLUSPROP_PIFLAG_USABLE) == CLUSPROP_PIFLAG_USABLE;
                } // if: resource is online
                if (bDisplay)
                {
                    try
                    {
                        strPartitionInfo.Format(
                                (rbuf.pPartitionInfoValue->szVolumeLabel[0] ? _T("%ls (%ls) ") : _T("%ls ")),
                                rbuf.pPartitionInfoValue->szDeviceName,
                                rbuf.pPartitionInfoValue->szVolumeLabel
                                );
                        rstr += strPartitionInfo;
                        if (pdwSignature != NULL)
                        {
                            _ASSERTE(dwSignature != 0);
                            *pdwSignature = dwSignature;
                        } // if:  caller wants signature as well
                    }  // try
                    catch (...)
                    {
                        // Ignore all errors because there is really nothing we can do.
                        // Displaying a message isn't really very useful.
                    }  // catch:  Anything
                }  // if:  partition should be displayed
            }  // else if:  partition info

            // Advance the buffer pointer
            rbuf.pb += cbData;
            cbBuf -= cbData;

        }  while ( (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
                && (rbuf.pSyntax->dw != CLUSPROP_SYNTAX_DISK_SIGNATURE));
    }  // if:  not an endmark

    return (rstr.GetLength() > 0);

}  //*** CPhysDiskParamsPage::BStringFromDiskInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPhysDiskParamsPage::FillList
//
//  Routine Description:
//      Fill the list of disks.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPhysDiskParamsPage::FillList(void)
{
    CString     strDisk;
    DWORD       dwSignature;
    int         icbox;

    // Clear the list first.
    m_cboxDisk.ResetContent();

    // Add the disk info first.
    if (m_cbDiskInfo > 0)
    {
        CLUSPROP_BUFFER_HELPER  buf;
        
        buf.pb = m_pbDiskInfo;
        if (BStringFromDiskInfo(buf, m_cbDiskInfo, m_strDisk, &dwSignature))
        {
            ASSERT(dwSignature != 0);
            icbox = m_cboxDisk.AddString(m_strDisk);
            m_cboxDisk.SetItemData(icbox, dwSignature);
        } // if:  disk info was found
    }  // if:  there is disk info

    // Now add the available disk info.
    if (m_cbAvailDiskInfo > 0)
    {
        CString                 strDisk;
        CLUSPROP_BUFFER_HELPER  buf;
        
        buf.pb = m_pbAvailDiskInfo;
        while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
        {
            if (BStringFromDiskInfo(buf, m_cbAvailDiskInfo, strDisk, &dwSignature))
            {
                ASSERT(dwSignature != 0);
                icbox = m_cboxDisk.AddString(strDisk);
                m_cboxDisk.SetItemData(icbox, dwSignature);
            } // if:  disk info was found
        }  // while:  more entries in the list
    }  // if:  there is available disk info

    // Now select an item in the list.
    if (m_strDisk.GetLength() > 0)
    {
        int nIndex;

        nIndex = m_cboxDisk.FindStringExact(-1, m_strDisk);
        m_cboxDisk.SetCurSel(nIndex);
    }  // if:  there is a selected item

}  //*** CPhysDiskParamsPage::FillList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\disks.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		Disks.cpp
//
//	Abstract:
//		Definition of the CPhysDiskParamsPage class, which implements the
//		Parameters page for Physical Disk resources.
//
//	Implementation File:
//		Disks.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DISKS_H_
#define _DISKS_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CPhysDiskParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusPropList;

/////////////////////////////////////////////////////////////////////////////
// CPhysDiskParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CPhysDiskParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CPhysDiskParamsPage)

// Construction
public:
	CPhysDiskParamsPage(void);
	~CPhysDiskParamsPage(void);

	// Second phase construction.
	virtual HRESULT		HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CPhysDiskParamsPage)
	enum { IDD = IDD_PP_DISKS_PARAMETERS};
	CComboBox	m_cboxDisk;
	CString	m_strDisk;
	//}}AFX_DATA
	CString	m_strPrevDisk;
	DWORD	m_dwSignature;
	DWORD	m_dwPrevSignature;

protected:
	enum
	{
		epropSignature,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPhysDiskParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual BOOL		BApplyChanges(void);
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	PBYTE				m_pbAvailDiskInfo;
	DWORD				m_cbAvailDiskInfo;
	PBYTE				m_pbDiskInfo;
	DWORD				m_cbDiskInfo;
	CLUSTER_RESOURCE_STATE	m_crs;

	BOOL				BGetAvailableDisks(void);
	BOOL				BGetDiskInfo(void);
	BOOL				BStringFromDiskInfo(
							IN OUT CLUSPROP_BUFFER_HELPER &	rbuf,
							IN DWORD						cbBuf,
							OUT CString &					rstr,
							OUT DWORD *						pdwSignature = NULL
							) const;
	void				FillList(void);

	// Generated message map functions
	//{{AFX_MSG(CPhysDiskParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeDisk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CPhysDiskParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _DISKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\excopers.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ExcOperS.cpp
//
//	Abstract:
//		Stub for implementation of exception classes.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ExcOper.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\dlghelps.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		DlgHelpS.cpp
//
//	Abstract:
//		Stub for implementation of dialog help classes.
//
//	Author:
//		David Potter (davidp)	February 18, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DlgHelp.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\editacl.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		EditAcl.h
//
//	Abstract:
//		Definition of ACL editor methods.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//			From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//			by BruceFo
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EDITACL_H_
#define _EDITACL_H_

LONG
EditShareAcl(
	IN HWND 					hwndParent,
	IN LPCTSTR					pszServerName,
	IN LPCTSTR					pszShareName,
	IN LPCTSTR					pszClusterNameNode,
	IN PSECURITY_DESCRIPTOR 	pSecDesc,
	OUT BOOL *					pbSecDescModified,
	OUT PSECURITY_DESCRIPTOR *	ppSecDesc
	);

LONG
CreateDefaultSecDesc(
	OUT PSECURITY_DESCRIPTOR* ppSecDesc
	);

VOID
DeleteDefaultSecDesc(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
	IN PSECURITY_DESCRIPTOR pSecDesc
	);


//
// Cluster API Specific Access Rights
//
#define SHARE_READ_ACCESS		0 //0x00000001L
#define SHARE_CHANGE_ACCESS		0 //0x00000002L
#define SHARE_NO_ACCESS 		0 //0x00000004L
#define SHARE_ALL_ACCESS		(SHARE_READ_ACCESS | SHARE_CHANGE_ACCESS)


//
// Share General Permissions
//


#if 0
#define FILE_PERM_NO_ACCESS 		 (0)
#define FILE_PERM_READ				 (STANDARD_RIGHTS_READ		|\
										SHARE_READ_ACCESS)
#define FILE_PERM_MODIFY			 (STANDARD_RIGHTS_WRITE 	|\
										SHARE_CHANGE_ACCESS)
#define FILE_PERM_ALL				 (STANDARD_RIGHTS_ALL		|\
										SHARE_ALL_ACCESS)
#else
#define FILE_PERM_NO_ACCESS 		(0)
#define FILE_PERM_READ				(GENERIC_READ    |\
									 GENERIC_EXECUTE)
#define FILE_PERM_MODIFY			(GENERIC_READ    |\
									 GENERIC_EXECUTE |\
									 GENERIC_WRITE   |\
									 DELETE )
#define FILE_PERM_ALL				(GENERIC_ALL)
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _EDITACL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\dllbase.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		DllBase.h
//
//	Abstract:
//		Dynamic Loadable Library (DLL) wrapper class.
//
//	Implementation File:
//		DllBase.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLLBASE_H_
#define _DLLBASE_H_

class CDynamicLibraryBase
{
public:
	CDynamicLibraryBase()
	{
		m_lpszLibraryName = NULL;
		m_lpszFunctionName = NULL;
		m_hLibrary = NULL;
		m_pfFunction = NULL;
	}
	virtual ~CDynamicLibraryBase()
	{
		if (m_hLibrary != NULL)
		{
			::FreeLibrary(m_hLibrary);
			m_hLibrary = NULL;
		}
	}
	BOOL Load()
	{
		if (m_hLibrary != NULL)
			return TRUE; // already loaded

		ASSERT(m_lpszLibraryName != NULL);
		m_hLibrary = ::LoadLibrary(m_lpszLibraryName);
		if (NULL == m_hLibrary)
		{
			// The library is not present
			return FALSE;
		}
		ASSERT(m_lpszFunctionName != NULL);
		ASSERT(m_pfFunction == NULL);
		m_pfFunction = ::GetProcAddress(m_hLibrary, m_lpszFunctionName );
		if ( NULL == m_pfFunction )
		{
			// The library is present but does not have the entry point
			::FreeLibrary( m_hLibrary );
			m_hLibrary = NULL;
			return FALSE;
		}
		ASSERT(m_hLibrary != NULL);
		ASSERT(m_pfFunction != NULL);
		return TRUE;
	}

protected:
	LPCSTR	m_lpszFunctionName;
	LPCTSTR m_lpszLibraryName;
	FARPROC m_pfFunction;
	HMODULE m_hLibrary;
};

#endif //_DLLBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\extobj.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ExtObj.cpp
//
//  Abstract:
//      Implementation of the CExtObject class, which implements the
//      extension interfaces required by a Microsoft Windows NT Cluster
//      Administrator Extension DLL.
//
//  Author:
//      David Potter (davidp)   August 29, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"

#include "GenApp.h"
#include "GenScript.h"
#include "GenSvc.h"
#include "NetName.h"
#include "Disks.h"
#include "PrtSpool.h"
#include "SmbShare.h"
#include "IpAddr.h"
#include "RegRepl.h"
#include "AclUtils.h"
#include "ClusPage.h"

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

const WCHAR g_wszResourceTypeNames[] =
        RESTYPE_NAME_GENERIC_APP L"\0"
        RESTYPE_NAME_GENERIC_SCRIPT L"\0"
        RESTYPE_NAME_GENERIC_SERVICE L"\0"
        RESTYPE_NAME_NETWORK_NAME L"\0"
        RESTYPE_NAME_PHYS_DISK L"\0"
#ifdef SUPPORT_FT_SET
        RESTYPE_NAME_FT_SET L"\0"
#endif // SUPPORT_FT_SET
        RESTYPE_NAME_PRINT_SPOOLER L"\0"
        RESTYPE_NAME_FILE_SHARE L"\0"
        RESTYPE_NAME_IP_ADDRESS L"\0"
        ;
const DWORD g_cchResourceTypeNames  = sizeof(g_wszResourceTypeNames) / sizeof(WCHAR);

static CRuntimeClass * g_rgprtcPSGenAppPages[]  = {
    RUNTIME_CLASS(CGenericAppParamsPage),
    RUNTIME_CLASS(CRegReplParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSGenScriptPages[]   = {
    RUNTIME_CLASS(CGenericScriptParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSGenSvcPages[]  = {
    RUNTIME_CLASS(CGenericSvcParamsPage),
    RUNTIME_CLASS(CRegReplParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSNetNamePages[] = {
    RUNTIME_CLASS(CNetworkNameParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSPhysDiskPages[]    = {
    RUNTIME_CLASS(CPhysDiskParamsPage),
    NULL
    };
#ifdef SUPPORT_FT_SET
static CRuntimeClass * g_rgprtcPSFTSetPages[]   = {
    RUNTIME_CLASS(CPhysDiskParamsPage),
    NULL
    };
#endif // SUPPORT_FT_SET
static CRuntimeClass * g_rgprtcPSPrintSpoolerPages[]    = {
    RUNTIME_CLASS(CPrintSpoolerParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSFileSharePages[]   = {
    RUNTIME_CLASS(CFileShareParamsPage),
    NULL
    };
static CRuntimeClass * g_rgprtcPSIpAddrPages[]  = {
    RUNTIME_CLASS(CIpAddrParamsPage),
    NULL
    };

static CRuntimeClass ** g_rgpprtcPSPages[]  = {
    g_rgprtcPSGenAppPages,
    g_rgprtcPSGenScriptPages,
    g_rgprtcPSGenSvcPages,
    g_rgprtcPSNetNamePages,
    g_rgprtcPSPhysDiskPages,
#ifdef SUPPORT_FT_SET
    g_rgprtcPSFTSetPages,
#endif // SUPPORT_FT_SET
    g_rgprtcPSPrintSpoolerPages,
    g_rgprtcPSFileSharePages,
    g_rgprtcPSIpAddrPages,
    };

// Wizard pages and property sheet pages are the same.
static CRuntimeClass ** g_rgpprtcWizPages[] = {
    g_rgprtcPSGenAppPages,
    g_rgprtcPSGenScriptPages,
    g_rgprtcPSGenSvcPages,
    g_rgprtcPSNetNamePages,
    g_rgprtcPSPhysDiskPages,
#ifdef SUPPORT_FT_SET
    g_rgprtcPSFTSetPages,
#endif // SUPPORT_FT_SET
    g_rgprtcPSPrintSpoolerPages,
    g_rgprtcPSFileSharePages,
    g_rgprtcPSIpAddrPages,
    };

#ifdef _DEMO_CTX_MENUS
static WCHAR g_wszGenAppMenuItems[] = {
    L"GenApp Item 1\0First Generic Application menu item\0"
    L"GenApp Item 2\0Second Generic Application menu item\0"
    L"GenApp Item 3\0Third Generic Application menu item\0"
    L"\0"
    };
static WCHAR g_wszGenScriptMenuItems[] = {
    L"GenApp Item 1\0First Generic Script menu item\0"
    L"GenApp Item 2\0Second Generic Script menu item\0"
    L"GenApp Item 3\0Third Generic Script menu item\0"
    L"\0"
    };
static WCHAR g_wszGenSvcMenuItems[] = {
    L"GenSvc Item 1\0First Generic Service menu item\0"
    L"GenSvc Item 2\0Second Generic Service menu item\0"
    L"GenSvc Item 3\0Third Generic Service menu item\0"
    L"\0"
    };
static WCHAR g_wszNetNameMenuItems[]    = {
    L"NetName Item 1\0First Network Name menu item\0"
    L"NetName Item 2\0Second Network Name menu item\0"
    L"NetName Item 3\0Third Network Name menu item\0"
    L"\0"
    };
static WCHAR g_wszPhysDiskMenuItems[]   = {
    L"PhysDisk Item 1\0First Physical Disk menu item\0"
    L"PhysDisk Item 2\0Second Physical Disk menu item\0"
    L"PhysDisk Item 3\0Third Physical Disk menu item\0"
    L"\0"
    };
static WCHAR g_wszPrintSpoolerMenuItems[]  = {
    L"FileShare Item 1\0First Print Spooler menu item\0"
    L"FileShare Item 2\0Second Print Spooler menu item\0"
    L"FileShare Item 3\0Third Print Spooler menu item\0"
    L"\0"
    };
static WCHAR g_wszFileShareMenuItems[]  = {
    L"FileShare Item 1\0First File Share menu item\0"
    L"FileShare Item 2\0Second File Share menu item\0"
    L"FileShare Item 3\0Third File Share menu item\0"
    L"\0"
    };
static WCHAR g_wszIpAddrMenuItems[] = {
    L"IpAddr Item 1\0First IP Address menu item\0"
    L"IpAddr Item 2\0Second IP Address menu item\0"
    L"IpAddr Item 3\0Third IP Address menu item\0"
    L"\0"
    };

static LPWSTR g_rgpwszContextMenuItems[]    = {
    g_wszGenAppMenuItems,
    g_wszGenScriptMenuItems,
    g_wszGenSvcMenuItems,
    g_wszNetNameMenuItems,
    g_wszPhysDiskMenuItems,
    g_wszPrintSpoolerMenuItems,
    g_wszFileShareMenuItems,
    g_wszIpAddrMenuItems,
    };

static WCHAR g_wszClusterMenuItems[] = {
    L"Cluster Item 1\0First Cluster menu item\0"
    L"Cluster Item 2\0Second Cluster menu item\0"
    L"Cluster Item 3\0Third Cluster menu item\0"
    L"\0"
    };

static LPWSTR g_rgpwszClusterContextMenuItems[]     = {
    g_wszClusterMenuItems,
    };
#endif

/////////////////////////////////////////////////////////////////////////////
// CExtObject
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CExtObject
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::CExtObject(void)
{
    m_piData = NULL;
    m_piWizardCallback = NULL;
    m_bWizard = FALSE;
    m_istrResTypeName = 0;

    m_hcluster = NULL;
    m_lcid = NULL;
    m_hfont = NULL;
    m_hicon = NULL;
    m_podObjData = NULL;
    m_pCvi = NULL;

}  //*** CExtObject::CExtObject()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::~CExtObject
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CExtObject::~CExtObject(void)
{
    // Release the data interface.
    if (PiData() != NULL)
    {
        PiData()->Release();
        m_piData = NULL;
    }  // if:  we have a data interface pointer

    // Release the wizard callback interface.
    if (PiWizardCallback() != NULL)
    {
        PiWizardCallback()->Release();
        m_piWizardCallback = NULL;
    }  // if:  we have a wizard callback interface pointer

    // Delete the pages.
    {
        POSITION    pos;

        pos = Lpg().GetHeadPosition();
        while (pos != NULL)
            delete Lpg().GetNext(pos);
    }  // Delete the pages

    delete m_podObjData;
    delete m_pCvi;

}  //*** CExtObject::~CExtObject()

/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfo Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InterfaceSupportsErrorInfo (ISupportErrorInfo)
//
//  Routine Description:
//      Indicates whether an interface suportes the IErrorInfo interface.
//      This interface is provided by ATL.
//
//  Arguments:
//      riid        Interface ID.
//
//  Return Value:
//      S_OK        Interface supports IErrorInfo.
//      S_FALSE     Interface does not support IErrorInfo.
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID * rgiid[] =
    {
        &IID_IWEExtendPropertySheet,
        &IID_IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
        &IID_IWEExtendContextMenu,
#endif
    };
    int     iiid;

    for (iiid = 0 ; iiid < sizeof(rgiid) / sizeof(rgiid[0]) ; iiid++)
    {
        if (InlineIsEqualGUID(*rgiid[iiid], riid))
            return S_OK;
    }
    return S_FALSE;

}  //*** CExtObject::InterfaceSupportsErrorInfo()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendPropertySheet Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreatePropertySheetPages (IWEExtendPropertySheet)
//
//  Routine Description:
//      Create property sheet pages and add them to the sheet.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the sheet is being displayed.
//      piCallback      Pointer to an IWCPropertySheetCallback interface
//                          for adding pages to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreatePropertySheetPages(
    IN IUnknown *                   piData,
    IN IWCPropertySheetCallback *   piCallback
    )
{
    HRESULT             hr      = E_FAIL;
    HPROPSHEETPAGE      hpage   = NULL;
    CException          exc(FALSE /*bAutoDelete*/);
    CRuntimeClass **    pprtc   = NULL;
    int                 irtc;
    CBasePropertyPage * ppage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Get info about displaying UI.
        hr = HrGetUIInfo(piData);
        if (hr != NOERROR)
            throw &exc;

        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while (pos != NULL)
                delete Lpg().GetNext(pos);
            Lpg().RemoveAll();
        }  // Delete any previous pages

        // Create property pages.
        ASSERT(PodObjData() != NULL);
        switch (PodObjData()->m_cot)
        {
            case CLUADMEX_OT_CLUSTER:
                {
                    CClusterSecurityPage    *pClusterSecurityPage = new CClusterSecurityPage;

                    if ( pClusterSecurityPage != NULL )
                    {
                        // Add it to the list.
                        Lpg().AddTail( pClusterSecurityPage );

                        hr = pClusterSecurityPage->HrInit( this );
                        if ( SUCCEEDED( hr ) )
                        {
                            hr = piCallback->AddPropertySheetPage(
                                    (LONG *) pClusterSecurityPage->GetHPage() );
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if ( FAILED( hr ) )
                    {
                        throw &exc;
                    }
                }
                break;
            case CLUADMEX_OT_RESOURCE:
                pprtc = g_rgpprtcPSPages[IstrResTypeName()];
                break;
            default:
                hr = E_NOTIMPL;
                throw &exc;
                break;
        }  // switch:  object type

        if (pprtc)
        {
            // Create each page.
            for (irtc = 0 ; pprtc[irtc] != NULL ; irtc++)
            {
                // Create the page.
                ppage = (CBasePropertyPage *) pprtc[irtc]->CreateObject();
                ASSERT(ppage->IsKindOf(pprtc[irtc]));

                // Add it to the list.
                Lpg().AddTail(ppage);

                // Initialize the property page.
                hr = ppage->HrInit(this);
                if (FAILED(hr))
                    throw &exc;

                // Create the page.
                hpage = ::CreatePropertySheetPage(&ppage->m_psp);
                if (hpage == NULL)
                {
                    DWORD sc = GetLastError();
                    hr = HRESULT_FROM_WIN32(sc);
                    throw &exc;
                } // if: error creating the page

                // Save the hpage in the page itself.
                ppage->SetHpage(hpage);

                // Add it to the property sheet.
                hr = piCallback->AddPropertySheetPage((LONG *) hpage);
                if (hr != NOERROR)
                    throw &exc;
            }  // for:  each page in the list
        } // if: pprtc is null

    }  // try
    catch (CMemoryException * pme)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  anything
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreatePropetySheetPages() - Failed to add property page\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  anything

    if (hr != NOERROR)
    {
        if (hpage != NULL)
            ::DestroyPropertySheetPage(hpage);
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    piCallback->Release();
    return hr;

}  //*** CExtObject::CreatePropertySheetPages()

/////////////////////////////////////////////////////////////////////////////
// IWEExtendWizard Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::CreateWizardPages (IWEExtendWizard)
//
//  Routine Description:
//      Create property sheet pages and add them to the wizard.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the wizard is being displayed.
//      piCallback      Pointer to an IWCPropertySheetCallback interface
//                          for adding pages to the sheet.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_FAIL          Error creating a page.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::CreateWizardPages(
    IN IUnknown *           piData,
    IN IWCWizardCallback *  piCallback
    )
{
    HRESULT             hr      = NOERROR;
    HPROPSHEETPAGE      hpage   = NULL;
    CException          exc(FALSE /*bAutoDelete*/);
    int                 irtc;
    CBasePropertyPage * ppage;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Get info about displaying UI.
        hr = HrGetUIInfo(piData);
        if (hr != NOERROR)
            throw &exc;

        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        // Delete any previous pages.
        {
            POSITION    pos;

            pos = Lpg().GetHeadPosition();
            while (pos != NULL)
                delete Lpg().GetNext(pos);
            Lpg().RemoveAll();
        }  // Delete any previous pages

        m_piWizardCallback = piCallback;
        m_bWizard = TRUE;

        // Add each page for this type of resource.
        for (irtc = 0 ; g_rgpprtcWizPages[IstrResTypeName()][irtc] != NULL ; irtc++)
        {
            // Create the property pages.
            ppage = (CBasePropertyPage *) g_rgpprtcWizPages[IstrResTypeName()][irtc]->CreateObject();
            ASSERT(ppage->IsKindOf(g_rgpprtcWizPages[IstrResTypeName()][irtc]));

            // Add it to the list.
            Lpg().AddTail(ppage);

            // Initialize the property page.
            hr = ppage->HrInit(this);
            if (FAILED(hr))
                throw &exc;

            // Create the page.
            hpage = ::CreatePropertySheetPage(&ppage->m_psp);
            if (hpage == NULL)
            {
                DWORD sc = GetLastError();
                hr = HRESULT_FROM_WIN32(sc);
                throw &exc;
            } // if: error creating the page

            // Save the hpage in the page itself.
            ppage->SetHpage(hpage);

            // Add it to the property sheet.
            hr = piCallback->AddWizardPage((LONG *) hpage);
            if (hr != NOERROR)
                throw &exc;
        }  // for:  each page for the type of resource
    }  // try
    catch (CMemoryException * pme)
    {
        TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (CMemoryException)\n"));
        pme->Delete();
        hr = E_OUTOFMEMORY;
    }  // catch:  CMemoryException
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (CException)\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  CException
//  catch (...)
//  {
//      TRACE(_T("CExtObject::CreateWizardPages: Failed to add wizard page (...)\n"));
//  } // catch:  anything

    if (hr != NOERROR)
    {
        if (hpage != NULL)
            ::DestroyPropertySheetPage(hpage);
        piCallback->Release();
        if ( m_piWizardCallback == piCallback )
        {
            m_piWizardCallback = NULL;
        } // if: already saved interface pointer
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    return hr;

}  //*** CExtObject::CreateWizardPages()

#ifdef _DEMO_CTX_MENUS
/////////////////////////////////////////////////////////////////////////////
// IWEExtendContextMenu Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::AddContextMenuItems (IWEExtendContextMenu)
//
//  Routine Description:
//      Add items to a context menu.  This is called each time the context
//      menu is invoked.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the context menu is being displayed.
//      piCallback      Pointer to an IWCContextMenuCallback interface
//                          for adding menu items to the context menu.
//
//  Return Value:
//      NOERROR         Pages added successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_FAIL          Error adding context menu item.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes returned by HrSaveData() or IWCContextMenuCallback::
//      AddExtensionMenuItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtObject::AddContextMenuItems(
    IN IUnknown *               piData,
    IN IWCContextMenuCallback * piCallback
    )
{
    HRESULT     hr      = NOERROR;
    ULONG       iCommandID;
    UINT        uFlags;
    LPWSTR      pwsz = NULL;
    LPWSTR      pwszName = NULL;
    LPWSTR      pwszStatusBarText = NULL;
    CString     strName;
    CException  exc(FALSE /*bAutoDelete*/);
    BSTR        bstrName = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Validate the parameters.
    if ((piData == NULL) || (piCallback == NULL))
        return E_INVALIDARG;

    try
    {
        // Save the data.
        hr = HrSaveData(piData);
        if (hr != NOERROR)
            throw &exc;

        switch ( PodObjData()->m_cot )
        {
            case CLUADMEX_OT_CLUSTER:

                // Add menu items to the cluster object.
                pwsz = g_rgpwszClusterContextMenuItems[ 0 ];

                for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
                {
                    pwszName = pwsz;
                    pwszStatusBarText = pwszName + (wcslen(pwszName) + 1);

                    // Gray the first item, disable the second and enable 
                    // the rest to show that it's working.
                    strName = "";
                    uFlags = 0;
                    if ( iCommandID == 0 )
                    {
                        uFlags = MF_GRAYED;
                        strName += L"(Grayed) ";
                    }
                    else if ( iCommandID == 1 ) 
                    { 
                        uFlags = MF_DISABLED; 
                        strName += L"(Disabled) ";
                    }

                    strName += pwszName;
                    bstrName = strName.AllocSysString();

                    hr = piCallback->AddExtensionMenuItem(
                                        bstrName,           // lpszName
                                        pwszStatusBarText,  // lpszStatusBarText
                                        iCommandID,         // lCommandID
                                        0,                  // lSubCommandID
                                        uFlags              // uFlags
                                        );
                    if (hr != NOERROR)
                    {
                        throw &exc;
                    }

                    SysFreeString( bstrName );
                    bstrName = NULL;

                    pwsz = pwszStatusBarText + (wcslen(pwszStatusBarText) + 1);
                }  // while:  more menu items to add
                break;

            case CLUADMEX_OT_RESOURCE:
            case CLUADMEX_OT_RESOURCETYPE:

                // Add menu items specific to this resource type.
                pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];

                for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
                {
                    pwszName = pwsz;
                    pwszStatusBarText = pwszName + (wcslen(pwszName) + 1);

                    // Gray the first item, disable the second and enable 
                    // the rest to show that it's working.
                    strName = "";
                    uFlags = 0;
                    if ( iCommandID == 0 )
                    {
                        uFlags = MF_GRAYED;
                        strName += L"(Grayed) ";
                    }
                    else if ( iCommandID == 1 ) 
                    { 
                        uFlags = MF_DISABLED; 
                        strName += L"(Disabled) ";
                    }

                    strName += pwszName;
                    bstrName = strName.AllocSysString();

                    hr = piCallback->AddExtensionMenuItem(
                                        bstrName,           // lpszName
                                        pwszStatusBarText,  // lpszStatusBarText
                                        iCommandID,         // lCommandID
                                        0,                  // lSubCommandID
                                        uFlags              // uFlags
                                        );
                    if (hr != NOERROR)
                    {
                        throw &exc;
                    }

                    SysFreeString( bstrName );
                    bstrName = NULL;

                    pwsz = pwszStatusBarText + (wcslen(pwszStatusBarText) + 1);
                }  // while:  more menu items to add
                break;

            default:
                hr = E_NOTIMPL;
                break;
        } // switch:

    }  // try
    catch (CException * pe)
    {
        TRACE(_T("CExtObject::AddContextMenuItems: Failed to add context menu item\n"));
        pe->Delete();
        if (hr == NOERROR)
            hr = E_FAIL;
    }  // catch:  anything

    if (hr != NOERROR)
    {
        piData->Release();
        m_piData = NULL;
    }  // if:  error occurred

    piCallback->Release();
    return hr;

}  //*** CExtObject::AddContextMenuItems()

/////////////////////////////////////////////////////////////////////////////
// IWEInvokeCommand Implementation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::InvokeCommand (IWEInvokeCommand)
//
//  Routine Description:
//      Invoke a command offered by a context menu.
//
//  Arguments:
//      lCommandID      ID of the menu item to execute.  This is the same
//                          ID passed to the IWCContextMenuCallback
//                          ::AddExtensionMenuItem() method.
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object for
//                          which the command is to be invoked.
//
//  Return Value:
//      NOERROR         Command invoked successfully.
//      E_INVALIDARG    Invalid arguments to the function.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IDataObject::GetData() (through HrSaveData()).
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::InvokeCommand(
    IN ULONG        nCommandID,
    IN IUnknown *   piData
    )
{
    HRESULT     hr = NOERROR;
    ULONG       iCommandID;
    LPWSTR      pwsz = NULL;
    LPWSTR      pwszName = NULL;
    LPWSTR      pwszStatusBarText = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Find the item that was executed in our table.
    hr = HrSaveData(piData);
    if (hr != NOERROR)
    {
        goto Cleanup;
    } // if:

    switch ( PodObjData()->m_cot )
    {
        case CLUADMEX_OT_CLUSTER:
            pwsz = g_rgpwszClusterContextMenuItems[ 0 ];

            for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
            {
                pwszName = pwsz;
                pwszStatusBarText = pwszName + (wcslen(pwszName) + 1);
                if (iCommandID == nCommandID)
                    break;
                pwsz = pwszStatusBarText + (wcslen(pwszStatusBarText) + 1);
            }  // while:  more menu items to add
            if (iCommandID == nCommandID)
            {
                CString     strMsg;
                CString     strName;

                try
                {
                    strName = pwszName;
                    strMsg.Format(_T("Item %s was executed"), strName);
                    AfxMessageBox(strMsg);
                }  // try
                catch (CException * pe)
                {
                    pe->Delete();
                }  // catch:  CException
            }  // if:  command ID found
            break;

        case CLUADMEX_OT_RESOURCE:
        case CLUADMEX_OT_RESOURCETYPE:
            pwsz = g_rgpwszContextMenuItems[IstrResTypeName()];

            for (iCommandID = 0 ; *pwsz != L'\0' ; iCommandID++)
            {
                pwszName = pwsz;
                pwszStatusBarText = pwszName + (wcslen(pwszName) + 1);
                if (iCommandID == nCommandID)
                    break;
                pwsz = pwszStatusBarText + (wcslen(pwszStatusBarText) + 1);
            }  // while:  more menu items to add
            if (iCommandID == nCommandID)
            {
                CString     strMsg;
                CString     strName;

                try
                {
                    strName = pwszName;
                    strMsg.Format(_T("Item %s was executed"), strName);
                    AfxMessageBox(strMsg);
                }  // try
                catch (CException * pe)
                {
                    pe->Delete();
                }  // catch:  CException
            }  // if:  command ID found
            break;

        default:
            hr = E_NOTIMPL;
            break;

    } // switch:

Cleanup:

    piData->Release();
    m_piData = NULL;
    return hr;

}  //*** CExtObject::InvokeCommand()
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetUIInfo
//
//  Routine Description:
//      Get info about displaying UI.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetUIInfo(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    // Save info about all types of objects.
    {
        IGetClusterUIInfo * pi;

        hr = piData->QueryInterface(IID_IGetClusterUIInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_lcid = pi->GetLocale();
        m_hfont = pi->GetFont();
        m_hicon = pi->GetIcon();

        pi->Release();
    }  // Save info about all types of objects

    return hr;

}  //*** CExtObject::HrGetUIInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrSaveData
//
//  Routine Description:
//      Save data from the object so that it can be used for the life
//      of the object.
//
//  Arguments:
//      piData          IUnkown pointer from which to obtain interfaces
//                          for obtaining data describing the object.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrSaveData(IUnknown * piData)
{
    HRESULT         hr  = NOERROR;

    ASSERT(piData != NULL);

    if (piData != m_piData)
    {
        if (m_piData != NULL)
            m_piData->Release();
        m_piData = piData;
    }  // if:  different data interface pointer

    // Save info about all types of objects.
    {
        IGetClusterDataInfo *   pi;

        hr = piData->QueryInterface(IID_IGetClusterDataInfo, (LPVOID *) &pi);
        if (hr != NOERROR)
            return hr;

        m_hcluster = pi->GetClusterHandle();
        m_cobj = pi->GetObjectCount();
        if (Cobj() != 1)
            hr = E_NOTIMPL;
        else
            hr = HrGetClusterName(pi);

        pi->Release();
        if (hr != NOERROR)
            return hr;
    }  // Save info about all types of objects

    // Save info about this object.
    hr = HrGetObjectInfo();
    if (hr != NOERROR)
        return hr;

    return hr;

}  //*** CExtObject::HrSaveData()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectInfo
//
//  Routine Description:
//      Get information about the object.
//
//  Arguments:
//      None.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_OUTOFMEMORY   Error allocating memory.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectInfo(void)
{
    HRESULT                     hr  = NOERROR;
    IGetClusterObjectInfo *     piGcoi;
    CLUADMEX_OBJECT_TYPE        cot = CLUADMEX_OT_NONE;
    CException                  exc(FALSE /*bAutoDelete*/);
    const CString *             pstrResTypeName = NULL;

    ASSERT(PiData() != NULL);

    // Get object info.
    {
        // Get an IGetClusterObjectInfo interface pointer.
        hr = PiData()->QueryInterface(IID_IGetClusterObjectInfo, (LPVOID *) &piGcoi);
        if (hr != NOERROR)
            return hr;

        // Read the object data.
        try
        {
            // Delete the previous object data.
            delete m_podObjData;
            m_podObjData = NULL;

            // Get the type of the object.
            cot = piGcoi->GetObjectType(0);
            switch (cot)
            {
                case CLUADMEX_OT_CLUSTER:
                    m_podObjData = new CObjData;
                    if ( m_podObjData == NULL )
                    {
                        AfxThrowMemoryException();
                    }
                    break;

                case CLUADMEX_OT_RESOURCE:
                    {
                        IGetClusterResourceInfo *   pi;

                        m_podObjData = new CResData;
                        if ( m_podObjData == NULL )
                        {
                            AfxThrowMemoryException();
                        }

                        // Get an IGetClusterResourceInfo interface pointer.
                        hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &pi);
                        if (hr != NOERROR)
                        {
                            throw &exc;
                        }

                        PrdResDataRW()->m_hresource = pi->GetResourceHandle(0);
                        ASSERT(PrdResDataRW()->m_hresource != NULL);
                        if (PrdResDataRW()->m_hresource == NULL)
                        {
                            hr = E_INVALIDARG;
                        }
                        else
                        {
                            hr = HrGetResourceTypeName(pi);
                        }

                        pi->Release();
                        if (hr != NOERROR)
                        {
                            throw &exc;
                        }

                        pstrResTypeName = &PrdResDataRW()->m_strResTypeName;
                    }  // if:  object is a resource
                    break;

                case CLUADMEX_OT_RESOURCETYPE:
                    m_podObjData = new CObjData;
                    if ( m_podObjData == NULL )
                    {
                        AfxThrowMemoryException();
                    }
                    pstrResTypeName = &PodObjDataRW()->m_strName;
                    break;

                default:
                    hr = E_NOTIMPL;
                    throw &exc;

            }  // switch:  object type

            PodObjDataRW()->m_cot = cot;
            hr = HrGetObjectName(piGcoi);

        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        } // catch: CMemoryException
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException

        piGcoi->Release();
        if (hr != NOERROR)
        {
            return hr;
        }

    }  // Get object info

    // If this is a resource or resource type, see if we know about this type.
    if (((cot == CLUADMEX_OT_RESOURCE)
            || (cot == CLUADMEX_OT_RESOURCETYPE))
        && (hr == NOERROR))
    {
        LPCWSTR pwszResTypeName = NULL;

        // Find the resource type name in our list.
        // Save the index for use in other arrays.
        for (m_istrResTypeName = 0, pwszResTypeName = g_wszResourceTypeNames
                ; *pwszResTypeName != L'\0'
                ; m_istrResTypeName++, pwszResTypeName += wcslen(pwszResTypeName) + 1
                )
        {
            if (pstrResTypeName->CompareNoCase(pwszResTypeName) == 0)
            {
                break;
            }
        }  // for:  each resource type in the list

        if (*pwszResTypeName == L'\0')
        {
            hr = E_NOTIMPL;
        }

    }  // See if we know about this resource type

    return hr;

}  //*** CExtObject::HrGetObjectInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetClusterName
//
//  Routine Description:
//      Get the name of the cluster.
//
//  Arguments:
//      piData          IGetClusterDataInfo interface pointer for getting
//                          the object name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterName(
    IN OUT IGetClusterDataInfo *    pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;
    BSTR        bstr        = NULL;

    ASSERT(pi != NULL);

    hr = pi->GetClusterName(NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    bstr = SysAllocStringLen( NULL, cchName );
    if ( bstr != NULL )
    {
        try
        {
            hr = pi->GetClusterName(bstr, &cchName);
            if (hr == NOERROR)
            {
                pwszName = new WCHAR[cchName];
                hr = StringCchCopyNW( pwszName, cchName, bstr, SysStringLen( bstr ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }
            m_strClusterName = pwszName;
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        }  // catch:  CMemoryException
    } // if: ( bstr != NULL )
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    SysFreeString( bstr );
    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetClusterName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetObjectName
//
//  Routine Description:
//      Get the name of the object.
//
//  Arguments:
//      piData          IGetClusterObjectInfo interface pointer for getting
//                          the object name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetObjectName(
    IN OUT IGetClusterObjectInfo *  pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;
    BSTR        bstr        = NULL;

    ASSERT(pi != NULL);

    hr = pi->GetObjectName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    bstr = SysAllocStringLen( NULL, cchName );
    if ( bstr != NULL )
    {
        try
        {
            hr = pi->GetObjectName(0, bstr, &cchName);
            if (hr == NOERROR)
            {
                pwszName = new WCHAR[cchName];
                hr = StringCchCopyNW( pwszName, cchName, bstr, SysStringLen( bstr ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }

            PodObjDataRW()->m_strName = pwszName;
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        }  // catch:  CMemoryException
    } // if: ( bstr != NULL )
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    SysFreeString( bstr );
    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetObjectName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetClusterVersion
//
//  Routine Description:
//      Get the version of the cluster.
//
//  Arguments:
//      ppCvi   [OUT]   holds the Cluster version info.
//
//  Return Value:
//      NOERROR         Data retrieved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from GetClusterInformation()
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetClusterVersion(
    OUT LPCLUSTERVERSIONINFO *ppCvi
    )
{
    ASSERT(ppCvi != NULL);

    HRESULT hr = E_FAIL;

    if (ppCvi != NULL)
    {
        if (m_pCvi == NULL)
        {
            LPWSTR      pwszName    = NULL;
            DWORD       cchName     = 128;
            CWaitCursor wc;

            try
            {
                pwszName = new WCHAR[cchName];
                m_pCvi = new CLUSTERVERSIONINFO;

                m_pCvi->dwVersionInfoSize = sizeof( CLUSTERVERSIONINFO );

                hr = GetClusterInformation(Hcluster(), pwszName, &cchName, m_pCvi);
                if (hr == ERROR_MORE_DATA)
                {
                    delete [] pwszName;
                    cchName++;
                    pwszName = new WCHAR[cchName];
                    hr = GetClusterInformation(Hcluster(), pwszName, &cchName, m_pCvi);
                }  // if:  buffer is too small

                delete [] pwszName;
                *ppCvi = m_pCvi;
            }  // try
            catch (CException *)
            {
                delete [] pwszName;
                delete m_pCvi;
                m_pCvi = NULL;
                throw;
            }  // catch:  CException
        }
        else
        {
            *ppCvi = m_pCvi;
            hr = S_OK;
        }
    }

    return hr;

}  //*** CExtObject::HrGetClusterVersion()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::HrGetResourceTypeName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      piData          IGetClusterResourceInfo interface pointer for getting
//                          the resource type name.
//
//  Return Value:
//      NOERROR         Data saved successfully.
//      E_NOTIMPL       Not implemented for this type of data.
//      Any error codes from IUnknown::QueryInterface(), HrGetObjectName(),
//      or HrGetResourceName().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CExtObject::HrGetResourceTypeName(
    IN OUT IGetClusterResourceInfo *    pi
    )
{
    HRESULT     hr          = NOERROR;
    WCHAR *     pwszName    = NULL;
    LONG        cchName;
    BSTR        bstr        = NULL;

    ASSERT(pi != NULL);

    hr = pi->GetResourceTypeName(0, NULL, &cchName);
    if (hr != NOERROR)
        return hr;

    bstr = SysAllocStringLen( NULL, cchName );
    if ( bstr != NULL )
    {
        try
        {
            hr = pi->GetResourceTypeName(0, bstr, &cchName);
            if (hr == NOERROR)
            {
                pwszName = new WCHAR[cchName];
                hr = StringCchCopyNW( pwszName, cchName, bstr, SysStringLen( bstr ) );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
            }

            PrdResDataRW()->m_strResTypeName = pwszName;
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
            hr = E_OUTOFMEMORY;
        }  // catch:  CMemoryException
    } // if: ( bstr != NULL )
    else
    {
        hr = E_OUTOFMEMORY;
    }

Cleanup:

    SysFreeString( bstr );
    delete [] pwszName;
    return hr;

}  //*** CExtObject::HrGetResourceTypeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BGetResourceNetworkName
//
//  Routine Description:
//      Get the name of the resource's type.
//
//  Arguments:
//      lpszNetName     [OUT] String in which to return the network name resource name.
//      pcchNetName     [IN OUT] Points to a variable that specifies the
//                          maximum size, in characters, of the buffer.  This
//                          value shold be large enough to contain
//                          MAX_COMPUTERNAME_LENGTH + 1 characters.  Upon
//                          return it contains the actual number of characters
//                          copied.
//
//  Return Value:
//      TRUE        Resource is dependent on a network name resource.
//      FALSE       Resource is NOT dependent on a network name resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BGetResourceNetworkName(
    OUT WCHAR *     lpszNetName,
    IN OUT DWORD *  pcchNetName
    )
{
    BOOL                        bSuccess    = TRUE;
    HRESULT                     hr          = S_OK;
    IGetClusterResourceInfo *   piGcri      = NULL;
    BSTR                        bstr        = NULL;
    DWORD                       cchNetName;

    ASSERT(PiData() != NULL);

    if (   ( lpszNetName == NULL )
        || ( pcchNetName == NULL ) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Get an IGetClusterResourceInfo interface pointer.
    {
        hr = PiData()->QueryInterface(IID_IGetClusterResourceInfo, (LPVOID *) &piGcri);
        if (hr != NOERROR)
        {
            goto Cleanup;
        }  // if:  error getting the interface
    }  // Get an IGetClusterResourceInfo interface pointer

    bstr = SysAllocStringLen( NULL, *pcchNetName );
    if ( bstr == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Get the resource network name.
    cchNetName = *pcchNetName;
    bSuccess = piGcri->GetResourceNetworkName(0, bstr, &cchNetName);
    if ( bSuccess == TRUE )
    {
        hr = StringCchCopyNW( lpszNetName, *pcchNetName, bstr, SysStringLen( bstr ) );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }

Cleanup:

    SysFreeString( bstr );
    if ( piGcri != NULL )
    {
        piGcri->Release();
    }

    if ( hr != S_OK )
    {
        SetLastError( hr );
        if ( FAILED( hr ) )
        {
            bSuccess = FALSE;
        }
    }

    return bSuccess;

}  //*** CExtObject::BGetResourceNetworkName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionMixed
//
//  Routine Description:
//      Is the cluster of mixed version?  Meaning that a rolling upgrade is
//      is in progress and not all nodes are up to the current version.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is mixed version
//      FALSE       Cluster is homogonous
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionMixed(
    void
    )
{
    BOOL                    bRet = FALSE;
    LPCLUSTERVERSIONINFO    pCvi;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        bRet = pCvi->dwFlags & CLUSTER_VERSION_FLAG_MIXED_MODE;
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionMixed()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT4Sp3
//
//  Routine Description:
//      Is the cluster version NT4Sp3?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT4Sp3
//      FALSE       Cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT4Sp3(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT4Sp3()

#endif//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT4Sp4
//
//  Routine Description:
//      Is the cluster version a pure NT4Sp4 cluster
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT4Sp4
//      FALSE       Cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT4Sp4()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterVersionNT5
//
//  Routine Description:
//      Is the cluster version a pure NT5 version?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Cluster is version NT5
//      FALSE       Cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION) &&
            !(BIsClusterVersionMixed()))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterVersionNT5()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster
//or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT4Sp3
//
//  Routine Description:
//      Is the highest cluster version NT4Sp3?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT4Sp3
//      FALSE       highest cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT4Sp3(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT4Sp3()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT4Sp4
//
//  Routine Description:
//      Is the highest cluster version NT4Sp4?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT4Sp4
//      FALSE       highest cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT4Sp4()

#endif //SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster or a  pure sp3 cluster


/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterHighestVersionNT5
//
//  Routine Description:
//      Is the highest cluster version NT5?  Is the node with the
//      highest version in the cluster an nt 5 node.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        highest cluster is version NT5
//      FALSE       highest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterHighestVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4SP4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterHighestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT4Sp3
//
//  Routine Description:
//      Is the Lowest cluster version NT4Sp3? Is the node with the lowest
//      version an nt4 sp3 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT4Sp3
//      FALSE       Lowest cluster is not version NT4Sp3
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT4Sp3(
    void
    )
{

    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT4Sp3()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT4Sp4
//
//  Routine Description:
//      Is the Lowest cluster version NT4Sp4?Is the node with the lowest
//      version an nt4 sp4 node.
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT4Sp4
//      FALSE       Lowest cluster is not version NT4Sp4
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT4Sp4(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT4Sp4()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsClusterLowestVersionNT5
//
//  Routine Description:
//      Is the Lowest cluster version NT5?Is the node with the lowest
//      version an nt5 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT5
//      FALSE       Lowest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsClusterLowestVersionNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsAnyNodeVersionLowerThanNT5
//
//  Routine Description:
//      Is the Lowest cluster version NT5?Is the node with the lowest
//      version an nt5 node
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        Lowest cluster is version NT5
//      FALSE       Lowest cluster is not version NT5
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsAnyNodeVersionLowerThanNT5(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) < NT5_MAJOR_VERSION)
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsClusterLowestVersionNT5()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT5ClusterMember
//
//  Routine Description:
//      Is NT5 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT5 is a cluster member
//      FALSE       NT5 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT5ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT5_MAJOR_VERSION)
            || (CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterLowestVersion) == NT4SP4_MAJOR_VERSION))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT5ClusterMember()

#if 0
//SS: cant tell whether a cluster is a mixed mode sp4 and sp3 cluster
//or a  pure sp3 cluster
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT4Sp3ClusterMember
//
//  Routine Description:
//      Is NT4Sp3 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT4Sp3 is a cluster member
//      FALSE       NT4Sp3 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT4Sp3ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4_MAJOR_VERSION))
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT4Sp3ClusterMember()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CExtObject::BIsNT4Sp4ClusterMember
//
//  Routine Description:
//      Is NT4Sp4 a cluster member?
//
//  Arguments:
//      none.
//
//  Return Value:
//      TRUE        NT4Sp4 is a cluster member
//      FALSE       NT4Sp4 is not a cluster member
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CExtObject::BIsNT4Sp4ClusterMember(
    void
    )
{
    LPCLUSTERVERSIONINFO    pCvi;
    BOOL                    bRet = FALSE;

    if (SUCCEEDED(HrGetClusterVersion(&pCvi)))
    {
        if ((CLUSTER_GET_MAJOR_VERSION(pCvi->dwClusterHighestVersion) == NT4SP4_MAJOR_VERSION)) 
        {
            bRet = TRUE;
        }
    }

    return bRet;

}  //*** CExtObject::BIsNT4Sp4ClusterMember()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\editacl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      EditAcl.cpp
//
//  Abstract:
//      Implementation of ACL editor methods.
//
//  Author:
//      David Potter (davidp)   October 9, 1996
//          From \nt\private\window\shell\lmui\ntshrui\acl.cxx
//          by BruceFo
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <lmerr.h>

extern "C"
{
#include <sedapi.h>
}

#include "EditAcl.h"
#include "AclHelp.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


enum SED_PERM_TYPE{
    SED_AUDITS,
    SED_ACCESSES,
    SED_OWNER
};

enum MAP_DIRECTION 
{
    SPECIFIC_TO_GENERIC = 0,
    GENERIC_TO_SPECIFIC = 1
};

const DWORD LOCAL_ACCOUNTS_FILTERED = 2L;
const BOOL bIsFile = 0;
 
//#define MAPBITS
BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction);
BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction);
BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE pAce);
BOOL MapGenericBitsInAce(PACCESS_ALLOWED_ACE pAce);


typedef
DWORD
(*SedDiscretionaryAclEditorType)(
        HWND                         Owner,
        HANDLE                       Instance,
        LPWSTR                       Server,
        PSED_OBJECT_TYPE_DESCRIPTOR  ObjectType,
        PSED_APPLICATION_ACCESSES    ApplicationAccesses,
        LPWSTR                       ObjectName,
        PSED_FUNC_APPLY_SEC_CALLBACK ApplySecurityCallbackRoutine,
        ULONG                        CallbackContext,
        PSECURITY_DESCRIPTOR         SecurityDescriptor,
        BOOLEAN                      CouldntReadDacl,
        BOOLEAN                      CantWriteDacl,
        LPDWORD                      SEDStatusReturn,
        DWORD                        Flags
        );

// NOTE: the SedDiscretionaryAclEditor string is used in GetProcAddress to
// get the correct entrypoint. Since GetProcAddress is not UNICODE, this string
// must be ANSI.
#define ACLEDIT_DLL_STRING                  TEXT("acledit.dll")
#define ACLEDIT_HELPFILENAME                TEXT("ntshrui.hlp")
#define SEDDISCRETIONARYACLEDITOR_STRING    ("SedDiscretionaryAclEditor")

//
// Declare the callback routine based on typedef in sedapi.h.
//

DWORD
SedCallback(
    HWND                    hwndParent,
    HANDLE                  hInstance,
    ULONG                   ulCallbackContext,
    PSECURITY_DESCRIPTOR    pSecDesc,
    PSECURITY_DESCRIPTOR    pSecDescNewObjects,
    BOOLEAN                 fApplyToSubContainers,
    BOOLEAN                 fApplyToSubObjects,
    LPDWORD                 StatusReturn
    );

//
// Structure for callback function's usage. A pointer to this is passed as
// ulCallbackContext. The callback functions sets bSecDescModified to TRUE
// and makes a copy of the security descriptor. The caller of EditShareAcl
// is responsible for deleting the memory in pSecDesc if bSecDescModified is
// TRUE. This flag will be FALSE if the user hit CANCEL in the ACL editor.
//
struct SHARE_CALLBACK_INFO
{
    BOOL                    bSecDescModified;
    PSECURITY_DESCRIPTOR    pSecDesc;
    LPCTSTR                 pszClusterNameNode;
};

//
// Local function prototypes
//

VOID
InitializeShareGenericMapping(
    IN OUT PGENERIC_MAPPING pSHAREGenericMapping
    );

PWSTR
GetResourceString(
    IN DWORD dwId
    );

PWSTR
NewDup(
    IN const WCHAR* psz
    );

//
// The following two arrays define the permission names for NT Files.  Note
// that each index in one array corresponds to the index in the other array.
// The second array will be modifed to contain a string pointer pointing to
// a loaded string corresponding to the IDS_* in the first array.
//

DWORD g_dwSharePermNames[] =
{
    IDS_ACLEDIT_PERM_GEN_NO_ACCESS,
    IDS_ACLEDIT_PERM_GEN_READ,
    IDS_ACLEDIT_PERM_GEN_MODIFY,
    IDS_ACLEDIT_PERM_GEN_ALL
};

SED_APPLICATION_ACCESS g_SedAppAccessSharePerms[] =
{
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_NO_ACCESS, 0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_READ,      0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_MODIFY,    0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_ALL,       0, NULL }
/*
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_NO_ACCESS, 0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_READ,      0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_MODIFY,    0, NULL },
    { SED_DESC_TYPE_RESOURCE, FILE_PERM_GEN_ALL,       0, NULL }
*/
};


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
//
//  Function:   EditShareAcl
//
//  Synopsis:   Invokes the generic ACL editor, specifically for NT shares
//
//  Arguments:  [hwndParent] - Parent window handle
//              [pszServerName] - Name of server on which the object resides.
//              [pszShareName] - Fully qualified name of resource we will
//                  edit, basically a share name.
//              [pSecDesc] - The initial security descriptor. If NULL, we will
//                  create a default that is "World all" access.
//              [pbSecDescModified] - Set to TRUE if the security descriptor
//                  was modified (i.e., the user hit "OK"), or FALSE if not
//                  (i.e., the user hit "Cancel")
//              [ppSecDesc] - *ppSecDesc points to a new security descriptor
//                  if *pbSecDescModified is TRUE. This memory must be freed
//                  by the caller.
//
//  History:
//        ChuckC   10-Aug-1992  Created. Culled from NTFS ACL code.
//        Yi-HsinS 09-Oct-1992  Added ulHelpContextBase
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

LONG
EditShareAcl(
    IN HWND                     hwndParent,
    IN LPCTSTR                  pszServerName,
    IN LPCTSTR                  pszShareName,
    IN LPCTSTR                  pszClusterNameNode,
    IN PSECURITY_DESCRIPTOR     pSecDesc,
    OUT BOOL *                  pbSecDescModified,
    OUT PSECURITY_DESCRIPTOR *  ppSecDesc
    )
{
    ASSERT(pszShareName != NULL);
    ASSERT(pszClusterNameNode != NULL);
    TRACE(_T("EditShareAcl, share %ws\n"), pszShareName);

    ASSERT((pSecDesc == NULL) || IsValidSecurityDescriptor(pSecDesc));
    ASSERT(pbSecDescModified != NULL);
    ASSERT(ppSecDesc != NULL);

    *pbSecDescModified = FALSE;

    LONG    err = 0 ;
    PWSTR   pszPermName;
    BOOL    bCreatedDefaultSecDesc = FALSE;
    UINT    idx;

    do // error breakout
    {
        /*
         * if pSecDesc is NULL, this is new file share or a file share with no
         * security descriptor.
         * we go and create a new (default) security descriptor.
         */
        if ( pSecDesc == NULL )
        {
            TRACE(_T("Security Descriptor is NULL.  Grant everyone Full Control\n") );
            LONG err = CreateDefaultSecDesc( &pSecDesc );
            if (err != NERR_Success)
            {
                err = GetLastError();
                TRACE(_T("CreateDefaultSecDesc failed, 0x%08lx\n"), err);
                break;
            }
            TRACE(_T("CreateDefaultSecDesc descriptor = 0x%08lx\n"), pSecDesc);
            bCreatedDefaultSecDesc = TRUE;
            
        }
        ASSERT(IsValidSecurityDescriptor(pSecDesc));

        /* Retrieve the resource strings appropriate for the type of object we
         * are looking at
         */

        CString strTypeName;
        CString strDefaultPermName;

        try
        {
            strTypeName.LoadString(IDS_ACLEDIT_TITLE);
            strDefaultPermName.LoadString(IDS_ACLEDIT_PERM_GEN_ALL);
        }  // try
        catch (CMemoryException * pme)
        {
            pme->Delete();
        }

        /*
         * other misc stuff we need pass to security editor
         */
        SED_OBJECT_TYPE_DESCRIPTOR sedObjDesc ;
        SED_HELP_INFO sedHelpInfo ;
        GENERIC_MAPPING SHAREGenericMapping ;

        // setup mappings
        InitializeShareGenericMapping( &SHAREGenericMapping ) ;

        WCHAR szHelpFile[50] = ACLEDIT_HELPFILENAME;
        sedHelpInfo.pszHelpFileName = szHelpFile;

        sedHelpInfo.aulHelpContext[HC_MAIN_DLG] =                HC_UI_SHELL_BASE + HC_NTSHAREPERMS ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_DLG] =            HC_UI_SHELL_BASE + HC_SHAREADDUSER ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] = HC_UI_SHELL_BASE + HC_SHAREADDUSER_GLOBALGROUP ;
        sedHelpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =     HC_UI_SHELL_BASE + HC_SHAREADDUSER_FINDUSER ;

        // These are not used, set to zero
        sedHelpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG]          = 0 ;
        sedHelpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] = 0 ;

        // setup the object description
        sedObjDesc.Revision                    = SED_REVISION1 ;
        sedObjDesc.IsContainer                 = FALSE ;
        sedObjDesc.AllowNewObjectPerms         = FALSE ;
        sedObjDesc.MapSpecificPermsToGeneric   = TRUE ;
        sedObjDesc.GenericMapping              = &SHAREGenericMapping ;
        sedObjDesc.GenericMappingNewObjects    = &SHAREGenericMapping ;
        sedObjDesc.ObjectTypeName              = (LPWSTR) (LPCWSTR) strTypeName ;
        sedObjDesc.HelpInfo                    = &sedHelpInfo ;
        sedObjDesc.SpecialObjectAccessTitle    = NULL ;

        /* Now we need to load the global arrays with the permission names
         * from the resource file.
         */
        UINT cArrayItems  = ARRAYLEN(g_SedAppAccessSharePerms);
        PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessSharePerms ;

        /* Loop through each permission title retrieving the text from the
         * resource file and setting the pointer in the array.
         */

        for ( idx = 0 ; idx < cArrayItems ; idx++ )
        {
            pszPermName = GetResourceString(g_dwSharePermNames[ idx ]) ;
            if ( pszPermName == NULL )
            {
                TRACE(_T("GetResourceString failed\n"));
                break ;
            }
            aSedAppAccess[ idx ].PermissionTitle = pszPermName;
        }
        if ( idx < cArrayItems )
        {
            TRACE(_T("failed to get all share permission names\n"));
            break ;
        }

        SED_APPLICATION_ACCESSES sedAppAccesses ;
        sedAppAccesses.Count           = cArrayItems ;
        sedAppAccesses.AccessGroup     = aSedAppAccess ;
        sedAppAccesses.DefaultPermName = (LPWSTR) (LPCWSTR) strDefaultPermName;

        /*
         * pass this along so when the call back function is called,
         * we can set it.
         */
        SHARE_CALLBACK_INFO callbackinfo ;
        callbackinfo.pSecDesc           = NULL;
        callbackinfo.bSecDescModified   = FALSE;
        callbackinfo.pszClusterNameNode = pszClusterNameNode;

        //
        // Now, load up the ACL editor and invoke it. We don't keep it around
        // because our DLL is loaded whenever the system is, so we don't want
        // the netui*.dll's hanging around as well...
        //

        HINSTANCE hInstanceAclEditor = NULL;
        SedDiscretionaryAclEditorType pAclEditor = NULL;

        hInstanceAclEditor = LoadLibrary(ACLEDIT_DLL_STRING);


        if ( hInstanceAclEditor == NULL )
        {
            err = GetLastError();
            TRACE(_T("LoadLibrary of acledit.dll failed, 0x%08lx\n"), err);
            break;
        }

        pAclEditor = (SedDiscretionaryAclEditorType) GetProcAddress(
                                                        hInstanceAclEditor,
                                                        SEDDISCRETIONARYACLEDITOR_STRING
                                                        );
        if ( pAclEditor == NULL )
        {
            err = GetLastError();
            TRACE(_T("GetProcAddress of SedDiscretionaryAclEditorType failed, 0x%08lx\n"), err);
            break;
        }

#ifdef MAPBITS
        MapBitsInSD( pSecDesc, SPECIFIC_TO_GENERIC );
#endif

        DWORD dwSedReturnStatus ;

        ASSERT(pAclEditor != NULL);
        err = (*pAclEditor)(
                        hwndParent,
                        AfxGetInstanceHandle(),
                        (LPTSTR) pszServerName,
                        &sedObjDesc,
                        &sedAppAccesses,
                        (LPTSTR) pszShareName,
                        SedCallback,
                        (ULONG) &callbackinfo,
                        pSecDesc,
                        FALSE, // always can read
                        FALSE, // if we can read, we can write
                        (LPDWORD) &dwSedReturnStatus,
                        0
                        );


        if (pSecDesc != NULL)
        {
#ifdef MAPBITS
            MapBitsInSD( pSecDesc, GENERIC_TO_SPECIFIC );
#endif
            ASSERT(IsValidSecurityDescriptor(pSecDesc));
        }  // if:  no security descriptor returned

        if (!FreeLibrary(hInstanceAclEditor))
        {
            LONG err2 = GetLastError();
            TRACE(_T("FreeLibrary of acledit.dll failed, 0x%08lx\n"), err2);
            // not fatal: continue...
        }

        if (0 != err)
        {
            TRACE(_T("SedDiscretionaryAclEditor failed, 0x%08lx\n"), err);
            break ;
        }

        *pbSecDescModified = callbackinfo.bSecDescModified ;

        if (*pbSecDescModified)
        {
            *ppSecDesc = callbackinfo.pSecDesc;
#ifdef MAPBITS
            MapBitsInSD( *ppSecDesc, GENERIC_TO_SPECIFIC );
#endif
            TRACE(_T("After calling acl editor, *ppSecDesc = 0x%08lx\n"), *ppSecDesc);
            ASSERT(IsValidSecurityDescriptor(*ppSecDesc));
        }

    } while (FALSE) ;

    //
    // Free memory...
    //

    UINT cArrayItems  = ARRAYLEN(g_SedAppAccessSharePerms);
    PSED_APPLICATION_ACCESS aSedAppAccess = g_SedAppAccessSharePerms ;
    for ( UINT i = 0 ; i < cArrayItems ; i++ )
    {
        pszPermName = aSedAppAccess[i].PermissionTitle;
        if ( pszPermName == NULL )
        {
            // if we hit a NULL, that's it!
            break ;
        }

        delete[] pszPermName;
    }

    if (bCreatedDefaultSecDesc)
    {
        DeleteDefaultSecDesc(pSecDesc);
    }

    ASSERT(!*pbSecDescModified || IsValidSecurityDescriptor(*ppSecDesc));

    if (0 != err)
    {
        CString     strCaption;
        CString     strMsg;

        try
        {
            strCaption.LoadString(IDS_MSGTITLE);
            strMsg.LoadString(IDS_NOACLEDITOR);
            MessageBox(hwndParent, strMsg, strCaption, MB_OK | MB_ICONSTOP);
        }  // try
        catch (CException * pe)
        {
            pe->Delete();
        };
    }

    return err;

}  //*** EditShareAcl



//////////////////////////////////////////////////////////////////////////////
//++
//
//  BLocalAccountInSD
//
//  Description:
//      Determines if any ACEs for local accounts are in DACL stored in
//      Security Descriptor (pSD) after the ACL editor has been called
//
//      Added this function in order to prevent users from selecting local
//      accounts in permissions dialog.
//      Rod Sharper 04/29/97
//
//  Arguments:
//      pSD                 - Security Descriptor to be checked.
//      pszClusterNameNode  - 
//
//  Return Values:
//      TRUE if at least one ACE was removed from the DACL, False otherwise.
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL BLocalAccountsInSD(PSECURITY_DESCRIPTOR pSD, LPCTSTR pszClusterNameNode)
{
    PACL                    paclDACL            = NULL;
    BOOL                    bHasDACL            = FALSE;
    BOOL                    bDaclDefaulted      = FALSE;
    BOOL                    bLocalAccountInACL  = FALSE;
    BOOL                    bRtn                = FALSE;

    ACL_SIZE_INFORMATION    asiAclSize;
    DWORD                   dwBufLength;
    DWORD                   dwACL_Index = 0L;
    ACCESS_ALLOWED_ACE *    paaAllowedAce;
    TCHAR                   szUserName[128];
    TCHAR                   szDomainName[128];
    DWORD                   cbUser  = 128;
    DWORD                   cbDomain    = 128;
    SID_NAME_USE            SidType;
    PUCHAR                  pnSubAuthorityCount;
    PULONG                  pnSubAuthority0;
    PULONG                  pnSubAuthority1;

    bRtn = IsValidSecurityDescriptor(pSD);
    ASSERT(bRtn);
    if ( bRtn == FALSE )
    {
        goto Cleanup;
    }

    bRtn = GetSecurityDescriptorDacl(
                                    pSD,
                                    (LPBOOL)&bHasDACL,
                                    (PACL *)&paclDACL,
                                    (LPBOOL)&bDaclDefaulted);
    ASSERT(bRtn);
    if ( bRtn == FALSE )
    {
        goto Cleanup;
    }
 
    if ( paclDACL == NULL )
    {
        goto Cleanup;
    }

    bRtn = IsValidAcl(paclDACL);
    ASSERT(bRtn);
    if ( bRtn == FALSE )
    {
        goto Cleanup;
    }

    dwBufLength = sizeof(asiAclSize);

    bRtn = GetAclInformation(
                            paclDACL,
                            (LPVOID)&asiAclSize,
                            (DWORD)dwBufLength,
                            (ACL_INFORMATION_CLASS) AclSizeInformation
                            );
    ASSERT(bRtn);
    if ( bRtn == FALSE )
    {
        goto Cleanup;
    }

    // Search the ACL for local account ACEs 
    //
    PSID pSID;
    while ( dwACL_Index < asiAclSize.AceCount )
    {
        if (!GetAce(paclDACL, dwACL_Index, (LPVOID *)&paaAllowedAce))
        {
            ASSERT(FALSE);
            goto Cleanup; 
        }
        if((((PACE_HEADER)paaAllowedAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE)
        {
            //
            //Get SID from ACE
            //

            pSID=(PSID)&((PACCESS_ALLOWED_ACE)paaAllowedAce)->SidStart;
    
            cbUser      = 128;
            cbDomain    = 128;
            if (LookupAccountSid(NULL,
                                 pSID,
                                 szUserName,
                                 &cbUser,
                                 szDomainName,
                                 &cbDomain,
                                 &SidType
                                 ))
            {
                if ( ClRtlStrNICmp( szDomainName, _T("BUILTIN"), RTL_NUMBER_OF( szDomainName ) ) == 0 )
                {
                    pnSubAuthorityCount = GetSidSubAuthorityCount( pSID );
                    if ( (pnSubAuthorityCount != NULL) && (*pnSubAuthorityCount == 2) )
                    {
                        // Check to see if this is the local Administrators group.
                        pnSubAuthority0 = GetSidSubAuthority( pSID, 0 );
                        pnSubAuthority1 = GetSidSubAuthority( pSID, 1 );
                        if (   (pnSubAuthority0 == NULL)
                            || (pnSubAuthority1 == NULL)
                            || (   (*pnSubAuthority0 != SECURITY_BUILTIN_DOMAIN_RID)
                                && (*pnSubAuthority1 != SECURITY_BUILTIN_DOMAIN_RID))
                            || (   (*pnSubAuthority0 != DOMAIN_ALIAS_RID_ADMINS)
                                && (*pnSubAuthority1 != DOMAIN_ALIAS_RID_ADMINS)))
                        {
                            bLocalAccountInACL = TRUE;
                            break;
                        }  // if:  not the local Administrators group
                    }  // if:  exactly 2 sub-authorities
                    else
                    {
                        bLocalAccountInACL = TRUE;
                        break;
                    }  // else:  unexpected # of sub-authorities
                }  // if:  built-in user or group
                else if (  ( ClRtlStrNICmp(szDomainName, pszClusterNameNode, RTL_NUMBER_OF( szDomainName ) ) == 0 )
                        && ( SidType != SidTypeDomain ) )
                {
                    // The domain name is the name of the node on which the
                    // cluster name resource is online, so this is a local
                    // user or group.
                    bLocalAccountInACL = TRUE;
                    break;
                }  // else if:  domain is cluster name resource node and not a Domain SID
            }  // if:  LookupAccountSid succeeded
            else
            {
                // If LookupAccountSid failed, assume that the SID is for
                // a user or group that is local to a machine to which we
                // don't have access.
                bLocalAccountInACL = TRUE;
                break;
            }  // else:  LookupAccountSid failed
        }
        dwACL_Index++;
    }

Cleanup:

    return bLocalAccountInACL;

}  //*** BLocalAccountsInSD


//+-------------------------------------------------------------------------
//
//  Function:   SedCallback
//
//  Synopsis:   Security Editor callback for the SHARE ACL Editor
//
//  Arguments:  See sedapi.h
//
//  History:
//        ChuckC   10-Aug-1992  Created
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

DWORD
SedCallback(
    HWND                    hwndParent,
    HANDLE                  hInstance,
    ULONG                   ulCallbackContext,
    PSECURITY_DESCRIPTOR    pSecDesc,
    PSECURITY_DESCRIPTOR    pSecDescNewObjects,
    BOOLEAN                 fApplyToSubContainers,
    BOOLEAN                 fApplyToSubObjects,
    LPDWORD                 StatusReturn
    )
{
    DWORD                   nStatus = NOERROR;
    SHARE_CALLBACK_INFO *   pCallbackInfo = (SHARE_CALLBACK_INFO *)ulCallbackContext;

    TRACE(_T("SedCallback, got pSecDesc = 0x%08lx\n"), pSecDesc);

    ASSERT(pCallbackInfo != NULL);
    ASSERT(IsValidSecurityDescriptor(pSecDesc));

    if ( BLocalAccountsInSD(pSecDesc, pCallbackInfo->pszClusterNameNode) )
    {
        CString strMsg;
        strMsg.LoadString(IDS_LOCAL_ACCOUNTS_SPECIFIED);
        AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);
        nStatus = LOCAL_ACCOUNTS_FILTERED;
        goto Cleanup
    }  // if:  local users or groups were specified


    ASSERT(pCallbackInfo != NULL);

    delete[] (BYTE*)pCallbackInfo->pSecDesc;
    pCallbackInfo->pSecDesc         = CopySecurityDescriptor(pSecDesc);
    pCallbackInfo->bSecDescModified = TRUE;

    ASSERT(IsValidSecurityDescriptor(pCallbackInfo->pSecDesc));
    TRACE(_T("SedCallback, return pSecDesc = 0x%08lx\n"), pCallbackInfo->pSecDesc);

Cleanup:

    return nStatus;

}  //*** SedCallback


//+-------------------------------------------------------------------------
//
//  Function:   InitializeShareGenericMapping
//
//  Synopsis:   Initializes the passed generic mapping structure for shares.
//
//  Arguments:  [pSHAREGenericMapping] - Pointer to GENERIC_MAPPING to be init.
//
//  History:
//        ChuckC   10-Aug-1992  Created. Culled from NTFS ACL code.
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
InitializeShareGenericMapping(
    IN OUT PGENERIC_MAPPING pSHAREGenericMapping
    )
{
    TRACE(_T("InitializeShareGenericMapping\n"));
 
    pSHAREGenericMapping->GenericRead    = GENERIC_READ;
    pSHAREGenericMapping->GenericWrite   = GENERIC_WRITE;
    pSHAREGenericMapping->GenericExecute = GENERIC_EXECUTE;
    pSHAREGenericMapping->GenericAll     = GENERIC_ALL;

}  //*** InitializeShareGenericMapping


//+-------------------------------------------------------------------------
//
//  Function:   CreateDefaultSecDesc
//
//  Synopsis:   Create a default ACL for either a new share or for
//              a share that doesn't exist.
//
//  Arguments:  [ppSecDesc] - *ppSecDesc points to a "world all" access
//                  security descriptor on exit. Caller is responsible for
//                  freeing it.
//
//  Returns:    NERR_Success if OK, api error otherwise.
//
//  History:
//        ChuckC   10-Aug-1992  Created. Culled from NTFS ACL code.
//        BruceFo  4-Apr-95     Stole and used in ntshrui.dll
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

LONG
CreateDefaultSecDesc(
    OUT PSECURITY_DESCRIPTOR* ppSecDesc
    )
{
    TRACE(_T("CreateDefaultSecDesc\n"));

    ASSERT(ppSecDesc != NULL) ;
    ASSERT(*ppSecDesc == NULL) ;

    LONG                    err = NERR_Success;
    PSECURITY_DESCRIPTOR    pSecDesc = NULL;
    PACL                    pAcl = NULL;
    DWORD                   cbAcl;
    PSID                    pSid = NULL;

    *ppSecDesc = NULL;

    // First, create a world SID. Next, create an access allowed
    // ACE with "Generic All" access with the world SID. Put the ACE in
    // the ACL and the ACL in the security descriptor.

    SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;

    if (!AllocateAndInitializeSid(
                &IDAuthorityWorld,
                1,
                SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0,
                &pSid))
    {
        err = GetLastError();
        TRACE(_T("AllocateAndInitializeSid failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    ASSERT(IsValidSid(pSid));

    cbAcl = sizeof(ACL)
          + (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD))
          + GetLengthSid(pSid)
          ;

    try
    {
        pAcl = (PACL) new BYTE[cbAcl];
    }  // try
    catch (CMemoryException * pme)
    {
        err = ERROR_OUTOFMEMORY;
        TRACE(_T("new ACL failed\n"));
        pme->Delete();
        goto Cleanup;
    }  // catch:  CMemoryException

    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION2))
    {
        err = GetLastError();
        TRACE(_T("InitializeAcl failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    if (!AddAccessAllowedAce(
                pAcl,
                ACL_REVISION2,
                FILE_PERM_ALL,
                pSid))
    {
        err = GetLastError();
        TRACE(_T("AddAccessAllowedAce failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    ASSERT(IsValidAcl(pAcl));

    try
    {
        pSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
    }  // try
    catch (CMemoryException * pme)
    {
        err = ERROR_OUTOFMEMORY;
        TRACE(_T("new SECURITY_DESCRIPTOR failed\n"));
        pme->Delete();
        goto Cleanup;
    }  // catch:  CMemoryException

    if (!InitializeSecurityDescriptor(
                pSecDesc,
                SECURITY_DESCRIPTOR_REVISION1))
    {
        err = GetLastError();
        TRACE(_T("InitializeSecurityDescriptor failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    if (!SetSecurityDescriptorDacl(
                pSecDesc,
                TRUE,
                pAcl,
                FALSE))
    {
        err = GetLastError();
        TRACE(_T("SetSecurityDescriptorDacl failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    ASSERT(IsValidSecurityDescriptor(pSecDesc));

    // Make the security descriptor self-relative

    DWORD dwLen = GetSecurityDescriptorLength(pSecDesc);
    TRACE(_T("SECURITY_DESCRIPTOR length = %d\n"), dwLen);

    PSECURITY_DESCRIPTOR pSelfSecDesc = NULL;
    try
    {
        pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[dwLen];
    }  // try
    catch (CMemoryException * pme)
    {
        err = ERROR_OUTOFMEMORY;
        TRACE(_T("new SECURITY_DESCRIPTOR (2) failed\n"));
        pme->Delete();
        goto Cleanup;
    }  // catch:  CMemoryException

    DWORD cbSelfSecDesc = dwLen;
    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        err = GetLastError();
        TRACE(_T("MakeSelfRelativeSD failed, 0x%08lx\n"), err);
        goto Cleanup;
    }

    ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

    //
    // all done: set the security descriptor
    //

    *ppSecDesc = pSelfSecDesc;

Cleanup:

    if (NULL != pSid)
    {
        FreeSid(pSid);
    }
    delete[] (BYTE*)pAcl;
    delete[] (BYTE*)pSecDesc;

    ASSERT(IsValidSecurityDescriptor(*ppSecDesc));

    return err;

}  //*** CreateDefaultSecDesc


//+-------------------------------------------------------------------------
//
//  Function:   DeleteDefaultSecDesc
//
//  Synopsis:   Delete a security descriptor that was created by
//              CreateDefaultSecDesc
//
//  Arguments:  [pSecDesc] - security descriptor to delete
//
//  Returns:    nothing
//
//  History:
//        BruceFo  4-Apr-95     Created
//        DavidP   10-Oct-1996  Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

VOID
DeleteDefaultSecDesc(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    TRACE(_T("DeleteDefaultSecDesc\n"));

    delete[] (BYTE*)pSecDesc;

}  //*** DeleteDefaultSecDesc


//+-------------------------------------------------------------------------
//
//  Member:     CopySecurityDescriptor, public
//
//  Synopsis:   Copy an NT security descriptor. The security descriptor must
//              be in self-relative (not absolute) form. Delete the result
//              using "delete[] (BYTE*)pSecDesc".
//
//  History:    19-Apr-95   BruceFo     Created
//              10-Oct-1996 DavidP      Modified for use with CLUADMIN
//
//--------------------------------------------------------------------------

PSECURITY_DESCRIPTOR
CopySecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSecDesc
    )
{
    TRACE(_T("CopySecurityDescriptor, pSecDesc = 0x%08lx\n"), pSecDesc);

    ASSERT(IsValidSecurityDescriptor(pSecDesc));

    size_t                  cbLen = GetSecurityDescriptorLength(pSecDesc);
    size_t                  cbSelfSecDesc = cbLen;
    PSECURITY_DESCRIPTOR    pSelfSecDesc = NULL;

    if ( pSecDesc == NULL )
    {
        goto Cleanup;
    }

    try
    {
        pSelfSecDesc = (PSECURITY_DESCRIPTOR) new BYTE[ cbLen ];
    }
    catch (CMemoryException * pme)
    {
        TRACE(_T("new SECURITY_DESCRIPTOR (2) failed\n"));
        pme->Delete();
        return NULL;    // actually, should probably return an error
    }  // catch:  CMemoryException

    if (!MakeSelfRelativeSD(pSecDesc, pSelfSecDesc, &cbSelfSecDesc))
    {
        TRACE(_T("MakeSelfRelativeSD failed, 0x%08lx\n"), GetLastError());

        // assume it failed because it was already self-relative
        CopyMemory( pSelfSecDesc, pSecDesc, cbLen );
    }

    ASSERT(IsValidSecurityDescriptor(pSelfSecDesc));

Cleanup:

    return pSelfSecDesc;

}  //*** CopySecurityDescriptor


//+---------------------------------------------------------------------------
//
//  Function:   GetResourceString
//
//  Synopsis:   Load a resource string, are return a "new"ed copy
//
//  Arguments:  [dwId] -- a resource string ID
//
//  Returns:    new memory copy of a string
//
//  History:    5-Apr-95    BruceFo Created
//              10-Oct-1996 DavidP  Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
GetResourceString(
    IN DWORD dwId
    )
{
    CString str;
    PWSTR   pwsz = NULL;

    if (str.LoadString(dwId))
    {
        pwsz = NewDup(str);
    }

    return pwsz;

}  //*** GetResourceString


//+---------------------------------------------------------------------------
//
//  Function:   NewDup
//
//  Synopsis:   Duplicate a string using '::new'
//
//  History:    28-Dec-94   BruceFo   Created
//              10-Oct-1996 DavidP    Modified for CLUADMIN
//
//----------------------------------------------------------------------------

PWSTR
NewDup(
    IN const WCHAR* psz
    )
{
    PWSTR   pszRet = NULL;
    size_t  cch;
    HRESULT hr;

    if ( psz == NULL )
    {
        TRACE(_T("Illegal string to duplicate: NULL\n"));
        goto Cleanup;
    }

    cch = wcslen( psz ) + 1;
    try
    {
        pszRet = new WCHAR[ cch ];
        if ( pszRet == NULL )
        {
            TRACE( _T("OUT OF MEMORY\n") );
            goto Cleanup;
        }
    }
    catch (CMemoryException * pme)
    {
        TRACE(_T("OUT OF MEMORY\n"));
        pme->Delete();
        pszRet = NULL;
        goto Cleanup;
    }  // catch:  CMemoryException

    hr = StringCchCopyW( pszRet, cch, psz );
    ASSERT( SUCCEEDED( hr ) );

Cleanup:

    return pszRet;

}  //*** NewDup

//+-------------------------------------------------------------------------
//
//  Function:   MapBitsInSD
//
//  Synopsis:   Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//              Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC

//
//  Arguments:  [pSecDesc] - SECURITY_DESCIRPTOR to be modified
//              [direction] - indicates whether bits are mapped from specific to generic 
//                            or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) April 12, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInSD(PSECURITY_DESCRIPTOR pSecDesc, MAP_DIRECTION direction)
{

    PACL    paclDACL        = NULL;
    BOOL    bHasDACL        = FALSE;
    BOOL    bDaclDefaulted  = FALSE;
    BOOL    bRtn            = FALSE;

    if (!IsValidSecurityDescriptor(pSecDesc))
    {
        goto Cleanup;
    }


    if (!GetSecurityDescriptorDacl(pSecDesc,
                 (LPBOOL)&bHasDACL,
                 (PACL *)&paclDACL,
                 (LPBOOL)&bDaclDefaulted
                 ))
    {
        goto Cleanup;
    }

 
    if (paclDACL)
    {
        bRtn = MapBitsInACL(paclDACL, direction);
    }

Cleanup:

    return bRtn;

} //*** MapBitsInSD


//+-------------------------------------------------------------------------
//
//  Function:   MapBitsInACL
//
//  Synopsis:   Maps Specific bits to Generic bit when MAP_DIRECTION is SPECIFIC_TO_GENERIC 
//              Maps Generic bits to Specific bit when MAP_DIRECTION is GENERIC_TO_SPECIFIC
//
//
//  Arguments:  [paclACL] - ACL (Access Control List) to be modified
//              [direction] - indicates whether bits are mapped from specific to generic 
//                            or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) May 02, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapBitsInACL(PACL paclACL, MAP_DIRECTION direction)
{
    ACL_SIZE_INFORMATION    asiAclSize;
    BOOL                    bRtn = FALSE;
    DWORD                   dwBufLength;
    DWORD                   dwACL_Index;
    ACCESS_ALLOWED_ACE *    paaAllowedAce;

    if (!IsValidAcl(paclACL))
    {
        goto Cleanup; 
    }

    dwBufLength = sizeof(asiAclSize);

    if (!GetAclInformation(paclACL,
             (LPVOID)&asiAclSize,
             (DWORD)dwBufLength,
             (ACL_INFORMATION_CLASS)AclSizeInformation))
    {
        goto Cleanup; 
    }

    for (dwACL_Index = 0; dwACL_Index < asiAclSize.AceCount;  dwACL_Index++)
    {
        if (!GetAce(paclACL, dwACL_Index, (LPVOID *) &paaAllowedAce))
        {
            goto Cleanup; 
        }

        if ( direction == SPECIFIC_TO_GENERIC )
        {
            bRtn = MapSpecificBitsInAce( paaAllowedAce );
        }
        else if ( direction == GENERIC_TO_SPECIFIC )
        {
            bRtn = MapGenericBitsInAce( paaAllowedAce );
        }
        else
        {
            bRtn = FALSE;
        }
    } // for: each ACE

Cleanup:

    return bRtn;

} //*** MapBitsInACL


//+-------------------------------------------------------------------------
//
//  Function:   MapSpecificBitsInAce  
//
//  Synopsis:   Maps specific bits in ACE to generic bits
//
//  Arguments:  [paaAllowedAce] - ACE (Access Control Entry) to be modified
//              [direction]     - indicates whether bits are mapped from specific to generic 
//                                or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) May 02, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapSpecificBitsInAce(PACCESS_ALLOWED_ACE paaAllowedAce)
{
    ACCESS_MASK amMask = paaAllowedAce->Mask;
    BOOL bRtn = FALSE;

    DWORD dwGenericBits;
    DWORD dwSpecificBits;

    dwSpecificBits            = (amMask & SPECIFIC_RIGHTS_ALL);
    dwGenericBits             = 0;

    switch( dwSpecificBits )
    {
        case CLUSAPI_READ_ACCESS:
            dwGenericBits = GENERIC_READ;   // GENERIC_READ  == 0x80000000L 
            bRtn = TRUE;
            break;

        case CLUSAPI_CHANGE_ACCESS:
            dwGenericBits = GENERIC_WRITE;  // GENERIC_WRITE == 0x40000000L 
            bRtn = TRUE;
            break;
        
        case CLUSAPI_NO_ACCESS:
            dwGenericBits = GENERIC_EXECUTE;// GENERIC_EXECUTE == 0x20000000L 
            bRtn = TRUE;
            break;
        
        case CLUSAPI_ALL_ACCESS:
            dwGenericBits = GENERIC_ALL;    // GENERIC_ALL   == 0x10000000L
            bRtn = TRUE;
            break;
        
        default:
            dwGenericBits = 0x00000000L;    // Invalid,assign no rights. 
            bRtn = FALSE;
            break;
    } // switch: on specific bits

    amMask = dwGenericBits;
    paaAllowedAce->Mask = amMask;

    return bRtn;

} //*** MapSpecificBitsInAce

//+-------------------------------------------------------------------------
//
//  Function:   MapGenericBitsInAce  
//
//  Synopsis:   Maps generic bits in ACE to specific bits
//
//  Arguments:  [paaAllowedAce] - ACE (Access Control Entry) to be modified
//              [direction]     - indicates whether bits are mapped from specific to generic 
//                                or generic to specific.
//  Author:
//      Roderick Sharper (rodsh) May 02, 1997
//
//  History:
//
//--------------------------------------------------------------------------

BOOL MapGenericBitsInAce  (PACCESS_ALLOWED_ACE paaAllowedAce)
{
    #define GENERIC_RIGHTS_ALL_THE_BITS  0xF0000000L

    ACCESS_MASK amMask = paaAllowedAce->Mask;
    BOOL bRtn = FALSE;

    DWORD dwGenericBits;
    DWORD dwSpecificBits;

    dwSpecificBits            = 0;
    dwGenericBits             = (amMask & GENERIC_RIGHTS_ALL_THE_BITS);

    switch( dwGenericBits )
    {
        case GENERIC_ALL:
            dwSpecificBits = CLUSAPI_ALL_ACCESS;    // CLUSAPI_ALL_ACCESS       == 3 
            bRtn = TRUE;
            break;
                                
        case GENERIC_EXECUTE:
            dwSpecificBits = CLUSAPI_NO_ACCESS;     // CLUSAPI_NO_ACCESS        == 4
            bRtn = TRUE;
            break;

        case GENERIC_WRITE:
            dwSpecificBits = CLUSAPI_CHANGE_ACCESS; // CLUSAPI_CHANGE_ACCESS    == 2
            bRtn = TRUE;
            break;
                                
        case GENERIC_READ:
            dwSpecificBits = CLUSAPI_READ_ACCESS;   // CLUSAPI_READ_ACCESS      == 1
            bRtn = TRUE;
            break;
        
        default:
            dwSpecificBits = 0x00000000L;           // Invalid, assign no rights. 
            bRtn = FALSE;
            break;
    } // switch: on generic bits

    amMask = dwSpecificBits;
    paaAllowedAce->Mask = amMask;

    return bRtn;

} //*** MapGenericBitsInAce
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\fsadv.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		FSAdv.cpp
//
//	Abstract:
//		Implementation of the CFileShareAdvancedDlg classes.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "FSAdv.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareAdvancedDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareAdvancedDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CFileShareAdvancedDlg)
	ON_BN_CLICKED(IDC_FILESHR_ADV_NORMAL_SHARE, OnChangedChoice)
	ON_BN_CLICKED(IDC_FILESHR_ADV_DFS_ROOT, OnChangedChoice)
	ON_BN_CLICKED(IDC_FILESHR_ADV_SHARE_SUBDIRS, OnChangedChoice)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::CFileShareAdvancedDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		bShareSubDirs		[IN] Default value for the Share subdirectories radio button.
//		bHideSubDirShare	[IN] Default value for the Hide subdirectory shares checkbox.
//		bIsDfsRoot			[IN] Default value for the DFS Root radio button
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareAdvancedDlg::CFileShareAdvancedDlg(
	BOOL bShareSubDirs,
	BOOL bHideSubDirShares,
	BOOL bIsDfsRoot,
	CWnd * pParent /*=NULL*/
	)
	: CBaseDialog(IDD, g_aHelpIDs_IDD_FILESHR_ADVANCED, pParent)
{
	//{{AFX_DATA_INIT(CFileShareAdvancedDlg)
	m_bShareSubDirs = bShareSubDirs;
	m_bHideSubDirShares = bHideSubDirShares;
	m_bIsDfsRoot = bIsDfsRoot;
	//}}AFX_DATA_INIT

	// Can't both share subdirs and be a DFS root.
	ASSERT(!(bShareSubDirs && bIsDfsRoot));

	if (m_bIsDfsRoot)
	{
		m_nChoice = 1;
		m_bHideSubDirShares = FALSE;
	} // if:  DFS root
	else if (m_bShareSubDirs)
		m_nChoice = 2;
	else
	{
		m_nChoice = 0;
		m_bHideSubDirShares = FALSE;
	} // else:  normal share

} //*** CFileShareAdvancedDlg::CFileShareAdvancedDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareAdvancedDlg::DoDataExchange(CDataExchange * pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFileShareAdvancedDlg)
	DDX_Control(pDX, IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES, m_chkHideSubDirShares);
	DDX_Control(pDX, IDC_FILESHR_ADV_SHARE_SUBDIRS, m_rbShareSubDirs);
	DDX_Radio(pDX, IDC_FILESHR_ADV_NORMAL_SHARE, m_nChoice);
	DDX_Check(pDX, IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES, m_bHideSubDirShares);
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (m_nChoice == 1)
		{
			m_bIsDfsRoot = TRUE;
			m_bShareSubDirs = FALSE;
			m_bHideSubDirShares = FALSE;
		} // if:  DFS root radio button selected
		else if (m_nChoice == 2)
		{
			m_bIsDfsRoot = FALSE;
			m_bShareSubDirs = TRUE;
		} // else if:  share subdirs radio button selected
		else
		{
			m_bIsDfsRoot = FALSE;
			m_bShareSubDirs = FALSE;
			m_bHideSubDirShares = FALSE;
		} // else:  normal radio button selected
	} // if:  saving data from dialog
	else
	{
		if (m_nChoice == 2)
			m_chkHideSubDirShares.EnableWindow (TRUE);
		else
			m_chkHideSubDirShares.EnableWindow (FALSE);
	} // else:  setting data to dialog

} //*** CFileShareAdvancedDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareAdvancedDlg::OnChangedChoice
//
//	Routine Description:
//		Handler for the BN_CLICKED message on the DFS root or Share
//		subdirectories radio button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareAdvancedDlg::OnChangedChoice(void)
{
	if (m_rbShareSubDirs.GetCheck() == BST_CHECKED)
		m_chkHideSubDirShares.EnableWindow (TRUE);
	else
		m_chkHideSubDirShares.EnableWindow (FALSE);

} //*** CFileShareAdvancedDlg::OnChangedChoice()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\extobj.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ExtObj.cpp
//
//	Abstract:
//		Definition of the CExtObject class, which implements the
//		extension interfaces required by a Microsoft Windows NT Cluster
//		Administrator Extension DLL.
//
//	Implementation File:
//		ExtObj.cpp
//
//	Author:
//		David Potter (davidp)	August 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTOBJ_H_
#define _EXTOBJ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>	// for CLUADMEX_DATA and interfaces
#endif

#ifndef __extobj_idl_h__
#include "ExtObjID.h"
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage and CPageList
#endif

//#define _DEMO_CTX_MENUS

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CExtObject;
class CObjData;
class CResData;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// class CObjData
/////////////////////////////////////////////////////////////////////////////

class CObjData
{
public:
	CString					m_strName;
	CLUADMEX_OBJECT_TYPE	m_cot;

	virtual ~CObjData(void) { }

};  //*** CObjData

/////////////////////////////////////////////////////////////////////////////
// class CResData
/////////////////////////////////////////////////////////////////////////////

class CResData : public CObjData
{
public:
	HRESOURCE	m_hresource;
	CString		m_strResTypeName;

};  //*** CResData

/////////////////////////////////////////////////////////////////////////////
// class CExtObject
/////////////////////////////////////////////////////////////////////////////

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.

class CExtObject :
	public IWEExtendPropertySheet,
	public IWEExtendWizard,
#ifdef _DEMO_CTX_MENUS
	public IWEExtendContextMenu,
	public IWEInvokeCommand,
#endif
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CExtObject, &CLSID_CoCluAdmEx>
{
public:
	CExtObject(void);
BEGIN_COM_MAP(CExtObject)
	COM_INTERFACE_ENTRY(IWEExtendPropertySheet)
	COM_INTERFACE_ENTRY(IWEExtendWizard)
#ifdef _DEMO_CTX_MENUS
	COM_INTERFACE_ENTRY(IWEExtendContextMenu)
	COM_INTERFACE_ENTRY(IWEInvokeCommand)
#endif
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CExtObject)
// Remove the comment from the line above if you don't want your object to
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CExtObject, _T("CLUADMEX.Standard"), _T("CLUADMEX.Standard"), IDS_CLUADMEX_DESC, THREADFLAGS_APARTMENT)

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IWEExtendPropertySheet
public:
	STDMETHOD(CreatePropertySheetPages)(
					IN IUnknown *					piData,
					IN IWCPropertySheetCallback *	piCallback
					);

// IWEExtendWizard
public:
	STDMETHOD(CreateWizardPages)(
					IN IUnknown *			piData,
					IN IWCWizardCallback *	piCallback
					);

#ifdef _DEMO_CTX_MENUS
// IWEExtendContextMenu
public:
	STDMETHOD(AddContextMenuItems)(
					IN IUnknown *				piData,
					IN IWCContextMenuCallback *	piCallback
					);

// IWEInvokeCommand
	STDMETHOD(InvokeCommand)(
					IN ULONG					nCommandID,
					IN IUnknown *				piData
					);
#endif

// Attributes
protected:
	IUnknown *					m_piData;
	IWCWizardCallback *			m_piWizardCallback;
	BOOL						m_bWizard;
	DWORD						m_istrResTypeName;

	// IGetClusterDataInfo data
	CString						m_strClusterName;
	HCLUSTER					m_hcluster;
	LCID						m_lcid;
	HFONT						m_hfont;
	HICON						m_hicon;
	LONG						m_cobj;

	CObjData *					m_podObjData;

	CObjData *					PodObjDataRW(void) const		{ return m_podObjData; }
	CResData *					PrdResDataRW(void) const		{ return (CResData *) m_podObjData; }

public:
	IUnknown *					PiData(void) const				{ return m_piData; }
	IWCWizardCallback *			PiWizardCallback(void) const	{ return m_piWizardCallback; }
	BOOL						BWizard(void) const				{ return m_bWizard; }
	DWORD						IstrResTypeName(void) const		{ return m_istrResTypeName; }

	// IGetClusterDataInfo data
	const CString &				StrClusterName(void) const		{ return m_strClusterName; }
	HCLUSTER					Hcluster(void) const			{ return m_hcluster; }
	LCID						Lcid(void) const				{ return m_lcid; }
	HFONT						Hfont(void) const				{ return m_hfont; }
	HICON						Hicon(void) const				{ return m_hicon; }
	LONG						Cobj(void) const				{ return m_cobj; }

	const CResData &			RrdResData(void) const			{ return (const CResData &) *m_podObjData; }
	const CObjData *			PodObjData(void) const			{ return m_podObjData; }
	const CResData *			PrdResData(void) const			{ return (CResData *) m_podObjData; }

	HRESULT						HrGetUIInfo(IUnknown * piData);
	HRESULT						HrSaveData(IUnknown * piData);
	HRESULT						HrGetObjectInfo(void);
	HRESULT						HrGetClusterName(IN OUT IGetClusterDataInfo * pi);
	HRESULT						HrGetObjectName(IN OUT IGetClusterObjectInfo * pi);
	HRESULT						HrGetResourceTypeName(IN OUT IGetClusterResourceInfo * pi);
	HRESULT						HrGetClusterVersion(OUT LPCLUSTERVERSIONINFO *ppCvi);
	BOOL						BGetResourceNetworkName(OUT WCHAR * lpszNetName, IN OUT DWORD * pcchNetName);
	BOOL						BIsClusterVersionMixed(void);
	BOOL						BIsClusterVersionNT4Sp3(void);
	BOOL						BIsClusterVersionNT4Sp4(void);
	//BOOL						BIsClusterVersionNT4(void);
	BOOL						BIsClusterVersionNT5(void);
	//BOOL						BIsClusterHighestVersionNT4Sp3(void);
	//BOOL						BIsClusterHighestVersionNT4Sp4(void);
	BOOL						BIsClusterHighestVersionNT5(void);
	BOOL						BIsClusterLowestVersionNT4Sp3(void);
	BOOL						BIsClusterLowestVersionNT4Sp4(void);
	BOOL						BIsClusterLowestVersionNT5(void);
	BOOL						BIsNT5ClusterMember(void);
	//BOOL						BIsNT4Sp4ClusterMember(void);
	//BOOL						BIsNT4Sp3ClusterMember(void);
    BOOL                        BIsAnyNodeVersionLowerThanNT5(void);

// Implementation
protected:
	virtual ~CExtObject(void);

	CPageList					m_lpg;
	LPCLUSTERVERSIONINFO		m_pCvi;

	CPageList &					Lpg(void)						{ return m_lpg; }

};  //*** class CExtObject

/////////////////////////////////////////////////////////////////////////////


#endif // _EXTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\fscache.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      FSCache.cpp
//
//  Description:
//      Definition of the CFileShareCachingDlg class.
//
//  Implementation File:
//      FSCache.cpp
//
//  Author:
//      David Potter    (DavidP)    13-MAR-2001
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareCachingDlg;

/////////////////////////////////////////////////////////////////////////////
// CFileShareCachingDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareCachingDlg : public CDialog
{
// Construction
public:
    CFileShareCachingDlg(
          DWORD     dwFlagsIn
        , CWnd *    pParent = NULL
        );

// Dialog Data
    //{{AFX_DATA(CFileShareCachingDlg)
    enum { IDD = IDD_FILESHR_CACHE_SETTINGS };
    CComboBox   m_cboCacheOptions;
    CStatic     m_staticHint;
    BOOL        m_fAllowCaching;
    CString     m_strHint;
    //}}AFX_DATA
    DWORD       m_dwFlags;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFileShareCachingDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CFileShareCachingDlg)
    afx_msg void OnCbnSelchangeCacheOptions();
    afx_msg void OnBnClickedAllowCaching();
    afx_msg void OnBnClickedHelp();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfoIn);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL GetCachedFlag( DWORD dwFlagsIn, DWORD dwFlagToCheckIn );
    void SetCachedFlag( DWORD * pdwFlagsInout, DWORD dwNewFlagIn );

}; //*** class CFileShareCachingDlg

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\fsadv.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		FSAdv.cpp
//
//	Abstract:
//		Definition of the CFileShareAdvancedDlg class.
//
//	Implementation File:
//		FSAdv.cpp
//
//	Author:
//		Sivaprasad Padisetty (sivapad))	February 2, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _FSADV_H_
#define _FSADV_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareAdvancedDlg;

/////////////////////////////////////////////////////////////////////////////
// CFileShareAdvancedDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareAdvancedDlg : public CBaseDialog
{
// Construction
public:
	CFileShareAdvancedDlg(
		BOOL bShareSubDirs,
		BOOL bHideSubDirShares,
		BOOL bIsDfsRoot,
		CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFileShareAdvancedDlg)
	enum { IDD = IDD_FILESHR_ADVANCED };
	CButton	m_chkHideSubDirShares;
	CButton	m_rbShareSubDirs;
	int	m_nChoice;
	BOOL	m_bHideSubDirShares;
	//}}AFX_DATA
	BOOL	m_bShareSubDirs;
	BOOL	m_bIsDfsRoot;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileShareAdvancedDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFileShareAdvancedDlg)
	afx_msg void OnChangedChoice();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CFileShareAdvancedDlg

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _FSADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\fscache.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2001 Microsoft Corporation
//
//  Module Name:
//      FSCache.cpp
//
//  Description:
//      Implementation of the CFileShareCachingDlg classes.
//
//  Maintained By:
//      David Potter    (DavidP)    12-MAR-2001
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "FSCache.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareCachingDlg property page
/////////////////////////////////////////////////////////////////////////////

//const LPSTR CACHE_HELPFILENAME  = "offlinefolders.chm";
//const LPSTR CACHE_HELP_TOPIC    = "csc_and_shares.htm";
const LPSTR CACHE_HELPFILENAME  = "mscsconcepts.chm";
const LPSTR CACHE_HELP_TOPIC    = "cluad_pr_100.htm";

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CFileShareCachingDlg, CDialog )
    //{{AFX_MSG_MAP(CFileShareCachingDlg)
    ON_CBN_SELCHANGE(IDC_FILESHR_CACHE_OPTIONS, OnCbnSelchangeCacheOptions)
    ON_BN_CLICKED(IDC_FILESHR_CACHE_ALLOW_CACHING, OnBnClickedAllowCaching)
    ON_BN_CLICKED(IDC_FILESHR_CACHE_CS_HELP, OnBnClickedHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::CFileShareCachingDlg
//
//  Description:
//      Constructor.
//
//  Arguments:
//      dwFlagsIn   -- Cache flags.
//      pParentIn   -- Parent window.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareCachingDlg::CFileShareCachingDlg(
      DWORD     dwFlagsIn
    , CWnd *    pParentIn
    )
    : CDialog( CFileShareCachingDlg::IDD, pParentIn )
    , m_dwFlags( dwFlagsIn )
{
    //{{AFX_DATA_INIT(CFileShareCachingDlg)
    m_fAllowCaching = FALSE;
    m_strHint = _T("");
    //}}AFX_DATA_INIT

    m_fAllowCaching = ! GetCachedFlag( m_dwFlags, CSC_CACHE_NONE );

} //*** CFileShareCachingDlg::CFileShareCachingDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::DoDataExchange
//
//  Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::DoDataExchange(
    CDataExchange * pDX
    )
{
    CDialog::DoDataExchange( pDX );
    //{{AFX_DATA_MAP(CFileShareCachingDlg)
    DDX_Control(pDX, IDC_FILESHR_CACHE_OPTIONS, m_cboCacheOptions);
    DDX_Control(pDX, IDC_FILESHR_CACHE_HINT, m_staticHint);
    DDX_Check(pDX, IDC_FILESHR_CACHE_ALLOW_CACHING, m_fAllowCaching);
    DDX_Text(pDX, IDC_FILESHR_CACHE_HINT, m_strHint);
    //}}AFX_DATA_MAP

} //*** CFileShareCachingDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareCachingDlg::OnInitDialog( void )
{
    CDialog::OnInitDialog();

    CString strText;
    int     nIndex;

    //
    // Add the various caching options to the combo box.
    // Save the string ID in the item data for easy recognition of the
    // contents of the selected item.
    // If the given cache value is set, select the item and put its hint in
    // the hint field.
    //

    // Add the manual sharing string.
    VERIFY( strText.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_MANUAL_REINT ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel( nIndex ) );
        VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
    }

    // Add the automatic workgroup sharing string.
    VERIFY( strText.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_AUTOMATIC_WORKGROUP_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_AUTO_REINT ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel (nIndex));
        VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT ) );
    }

    // Add the automatic application sharing string.
    VERIFY( strText.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE ) );
    nIndex = m_cboCacheOptions.AddString( strText );
    ASSERT( ( nIndex != CB_ERR ) && ( nIndex != CB_ERRSPACE ) );
    if ( ( nIndex == CB_ERR ) || ( nIndex == CB_ERRSPACE ) )
    {
        goto Cleanup;
    }
    VERIFY( CB_ERR != m_cboCacheOptions.SetItemData( nIndex, IDS_CSC_AUTOMATIC_APPLICATION_SHARE ) );
    if ( GetCachedFlag( m_dwFlags, CSC_CACHE_VDO ) )
    {
        VERIFY( CB_ERR != m_cboCacheOptions.SetCurSel( nIndex ) );
        VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT ) );
    }

    // Disable able the caching options combo box if caching is not allowed
    if ( ! m_fAllowCaching )
    {
        m_cboCacheOptions.EnableWindow( FALSE );
        m_strHint = L"";
    }

Cleanup:

    UpdateData( FALSE );

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE

} //*** CFileShareCachingDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnOK( void )
{
    DWORD   dwNewFlag = 0;

    if ( ! m_fAllowCaching )
    {
        dwNewFlag = CSC_CACHE_NONE;
    }
    else
    {
        int nIndex = m_cboCacheOptions.GetCurSel();
        ASSERT( nIndex != CB_ERR  );
        if ( nIndex != CB_ERR )
        {
            DWORD   dwData = (DWORD) m_cboCacheOptions.GetItemData( nIndex );

            switch ( dwData )
            {
                case IDS_CSC_MANUAL_WORKGROUP_SHARE:
                    dwNewFlag = CSC_CACHE_MANUAL_REINT;
                    break;

                case IDS_CSC_AUTOMATIC_WORKGROUP_SHARE:
                    dwNewFlag = CSC_CACHE_AUTO_REINT;
                    break;

                case IDS_CSC_AUTOMATIC_APPLICATION_SHARE:
                    dwNewFlag = CSC_CACHE_VDO;
                    break;

                default:
                    ASSERT( 0 );
                    break;
            } // switch: item data
        } // if: option is selected
    } // else: caching is allowed

    SetCachedFlag( &m_dwFlags, dwNewFlag );

    CDialog::OnOK();

} //*** CFileShareCachingDlg::OnOK()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnCbnSelchangeCacheOptions
//
//  Description:
//      Handler for the CBN_SELCHANGE message on the options combobox.
//      Change the hint control when the option has changed.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnCbnSelchangeCacheOptions( void )
{
    int nIndex = m_cboCacheOptions.GetCurSel();

    ASSERT( nIndex != CB_ERR );

    if ( nIndex != CB_ERR )
    {
        DWORD   dwData = (DWORD) m_cboCacheOptions.GetItemData( nIndex );

        switch ( dwData )
        {
            case IDS_CSC_MANUAL_WORKGROUP_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
                break;

            case IDS_CSC_AUTOMATIC_WORKGROUP_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT ) );
                break;

            case IDS_CSC_AUTOMATIC_APPLICATION_SHARE:
                VERIFY( m_strHint.LoadString( IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT ) );
                break;

            default:
                ASSERT( 0 );
                break;
        } // switch: item data
        UpdateData( FALSE );
    } // if: something is selected

} //*** CFileShareCachingDlg::OnCbnSelchangeCacheOptions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnBnClickedAllowCaching
//
//  Description:
//      Handler for the BN_CLICKED message on the Allow Caching checkbox.
//      Enable or disable controls and load a hint if enabled.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnBnClickedAllowCaching( void )
{
    UpdateData( TRUE );
    if ( m_fAllowCaching )
    {
        CString strText;
        int     nIndex;

        m_staticHint.EnableWindow( TRUE );
        m_cboCacheOptions.EnableWindow (TRUE);
        VERIFY( strText.LoadString ( IDS_CSC_MANUAL_WORKGROUP_SHARE ) );
        nIndex = m_cboCacheOptions.SelectString( -1, strText );
        ASSERT( CB_ERR != nIndex );
        if ( CB_ERR != nIndex )
        {
            VERIFY( m_strHint.LoadString( IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT ) );
            UpdateData( FALSE );
        }
    }
    else
    {
        m_staticHint.EnableWindow( FALSE );
        m_cboCacheOptions.SetCurSel( -1 );
        m_cboCacheOptions.EnableWindow( FALSE );
        m_strHint = L"";
        UpdateData( FALSE );
    }

} //*** CFileShareCachingDlg::OnBnClickedAllowCaching()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnBnClickedHelp
//
//  Description:
//      Handler for the BN_CLICKED message on the Help pushbutton.
//      Display HTML help.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareCachingDlg::OnBnClickedHelp( void )
{
    ::HtmlHelpA(
              m_hWnd
            , CACHE_HELPFILENAME
            , HH_DISPLAY_TOPIC
            , (ULONG_PTR) CACHE_HELP_TOPIC
            );

} //*** CFileShareCachingDlg::OnBnClickedHelp()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::OnHelpInfo
//
//  Description:
//      MFC message handler for help.
//      Display HTML help.
//
//  Arguments:
//      pHelpInfoIn     --
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareCachingDlg::OnHelpInfo(
    HELPINFO *  pHelpInfoIn
    )
{
    ASSERT( pHelpInfoIn != NULL );

    if (    ( pHelpInfoIn != NULL )
        &&  ( pHelpInfoIn->iContextType == HELPINFO_WINDOW ) )
    {
        ::HtmlHelpA(
                  m_hWnd
                , CACHE_HELPFILENAME
                , HH_DISPLAY_TOPIC
                , (ULONG_PTR) CACHE_HELP_TOPIC
                );
    }

    return CDialog::OnHelpInfo( pHelpInfoIn );

} //*** CFileShareCachingDlg::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::GetCachedFlag
//
//  Description:
//      Get the current state of the specified flag in the specified flags mask.
//
//  Arguments:
//      dwFlagsIn           -- Flags to check.
//      dwFlagsToCheckIn    -- Flag to look for.
//
//
//  Return Values:
//      TRUE    -- Flag is set.
//      FALSE   -- Flag is not set.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
BOOL
CFileShareCachingDlg::GetCachedFlag(
      DWORD dwFlagsIn
    , DWORD dwFlagToCheckIn
    )
{
    return (dwFlagsIn & CSC_MASK) == dwFlagToCheckIn;

} //*** CFileShareCachingDlg::GetCachedFlag()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareCachingDlg::GetCachedFlag
//
//  Description:
//      Set the specified flag in the specified flags mask.
//
//  Arguments:
//      pdwFlagsInout   -- Flags mask to modify.
//      dwNewFlagIn     -- Flags to set.
//
//  Return Values:
//      TRUE    -- Flag is set.
//      FALSE   -- Flag is not set.
//
//--
/////////////////////////////////////////////////////////////////////////////
inline
void
CFileShareCachingDlg::SetCachedFlag(
      DWORD *   pdwFlagsInout
    , DWORD     dwNewFlagIn
    )
{
    *pdwFlagsInout &= ~CSC_MASK;
    *pdwFlagsInout |= dwNewFlagIn;

} //*** CFileShareCachingDlg::SetCachedFlag()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\genapp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		GenApp.h
//
//	Abstract:
//		Definition of the CGenericAppParamsPage class, which implements the
//		Parameters page for Generic Application resources.
//
//	Implementation File:
//		GenApp.cpp
//
//	Author:
//		David Potter (davidp)	June 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENAPP_H_
#define _GENAPP_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericAppParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericAppParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericAppParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericAppParamsPage)

// Construction
public:
	CGenericAppParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericAppParamsPage)
	enum { IDD = IDD_PP_GENAPP_PARAMETERS };
	CEdit	m_editCurrentDirectory;
	CButton	m_ckbUseNetworkName;
	CEdit	m_editCommandLine;
	CString	m_strCommandLine;
	CString	m_strCurrentDirectory;
	BOOL	m_bInteractWithDesktop;
	BOOL	m_bUseNetworkName;
	//}}AFX_DATA
	CString	m_strPrevCommandLine;
	CString	m_strPrevCurrentDirectory;
	BOOL	m_bPrevInteractWithDesktop;
	BOOL	m_bPrevUseNetworkName;

protected:
	enum
	{
		epropCommandLine,
		epropCurrentDirectory,
		epropInteractWithDesktop,
		epropUseNetworkName,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericAppParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericAppParamsPage)
	afx_msg void OnChangeRequired();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericAppParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\genapp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenApp.cpp
//
//	Abstract:
//		Implementation of the CGenericAppParamsPage class.
//
//	Author:
//		David Potter (davidp)	June 5, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenApp.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericAppParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericAppParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericAppParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericAppParamsPage)
	ON_EN_CHANGE(IDC_PP_GENAPP_PARAMS_COMMAND_LINE, OnChangeRequired)
	ON_EN_CHANGE(IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, OnChangeRequired)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::CGenericAppParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericAppParamsPage::CGenericAppParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS)
{
	//{{AFX_DATA_INIT(CGenericAppParamsPage)
	m_strCommandLine = _T("");
	m_strCurrentDirectory = _T("");
	m_bInteractWithDesktop = FALSE;
	m_bUseNetworkName = FALSE;
	//}}AFX_DATA_INIT

	m_bInteractWithDesktop = FALSE;
	m_bUseNetworkName = FALSE;

	// Setup the property array.
	{
		m_rgProps[epropCommandLine].Set(REGPARAM_GENAPP_COMMAND_LINE, m_strCommandLine, m_strPrevCommandLine);
		m_rgProps[epropCurrentDirectory].Set(REGPARAM_GENAPP_CURRENT_DIRECTORY, m_strCurrentDirectory, m_strPrevCurrentDirectory);
		m_rgProps[epropInteractWithDesktop].Set(REGPARAM_GENAPP_INTERACT_WITH_DESKTOP, m_bInteractWithDesktop, m_bPrevInteractWithDesktop);
		m_rgProps[epropUseNetworkName].Set(REGPARAM_GENAPP_USE_NETWORK_NAME, m_bUseNetworkName, m_bPrevUseNetworkName);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENAPP_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENAPP_PARAMETERS;

}  //*** CGenericAppParamsPage::CGenericAppParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericAppParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		//{{AFX_DATA_MAP(CGenericAppParamsPage)
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, m_editCurrentDirectory);
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, m_ckbUseNetworkName);
		DDX_Control(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, m_editCommandLine);
		DDX_Text(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, m_strCommandLine);
		DDX_Text(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, m_strCurrentDirectory);
		DDX_Check(pDX, IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP, m_bInteractWithDesktop);
		DDX_Check(pDX, IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME, m_bUseNetworkName);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_GENAPP_PARAMS_COMMAND_LINE, IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, m_strCommandLine);
			DDV_RequiredText(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, m_strCurrentDirectory);
			DDV_Path(pDX, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY, IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, m_strCurrentDirectory);
		}  // if:  Back button not pressed
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericAppParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericAppParamsPage::OnInitDialog(void)
{
	// Get a default value for the current directory if it hasn't been set yet.
	if (m_strCurrentDirectory.GetLength() == 0)
		ConstructDefaultDirectory(m_strCurrentDirectory, IDS_DEFAULT_GENAPP_CURRENT_DIR);

	// Call the base class.
	CBasePropertyPage::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGenericAppParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericAppParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If there is no network name, hide the UseNetworkName control.
	{
		WCHAR	wszNetName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD	nSize = sizeof(wszNetName) / sizeof(WCHAR);
		BOOL	bNetNameExists;

		bNetNameExists = Peo()->BGetResourceNetworkName(
									wszNetName,
									&nSize
									);
		m_ckbUseNetworkName.EnableWindow(bNetNameExists);
	}  // If there is no network name, hide the UseNetworkName control

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if ((m_strCommandLine.GetLength() == 0)
				|| (m_strCurrentDirectory.GetLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericAppParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericAppParamsPage::OnChangeRequired
//
//	Routine Description:
//		Handler for the EN_CHANGE message on required controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericAppParamsPage::OnChangeRequired(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if ((m_editCommandLine.GetWindowTextLength() == 0)
				|| (m_editCurrentDirectory.GetWindowTextLength() == 0))
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CGenericAppParamsPage::OnChangeRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\genscript.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2000 Microsoft Corporation
//
//	Module Name:
//		GenScript.cpp
//
//	Abstract:
//		Implementation of the CGenericScriptParamsPage class.
//
//	Author:
//		Geoffrey Pease (GPease) 31-JAN-2000
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenScript.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"	// for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericScriptParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericScriptParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericScriptParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericScriptParamsPage)
	ON_EN_CHANGE(IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, OnChangeRequired)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::CGenericScriptParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericScriptParamsPage::CGenericScriptParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS)
{
	//{{AFX_DATA_INIT(CGenericScriptParamsPage)
	m_strScriptFilepath = _T("");
	//}}AFX_DATA_INIT

	// Setup the property array.
	{
		m_rgProps[epropScriptFilepath].Set(REGPARAM_GENSCRIPT_SCRIPT_FILEPATH, m_strScriptFilepath, m_strPrevScriptFilepath);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENSCRIPT_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENSCRIPT_PARAMETERS;

}  //*** CGenericScriptParamsPage::CGenericScriptParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericScriptParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		//{{AFX_DATA_MAP(CGenericScriptParamsPage)
		DDX_Control(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, m_editScriptFilepath);
		DDX_Text(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, m_strScriptFilepath);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
		{
			DDV_RequiredText(pDX, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH, IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL, m_strScriptFilepath);
		}  // if:  Back button not pressed
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericScriptParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericScriptParamsPage::OnInitDialog(void)
{
	// Call the base class.
	CBasePropertyPage::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CGenericScriptParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericScriptParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if (m_strScriptFilepath.GetLength() == 0)
        {
            EnableNext(FALSE);
        }
		else
        {
			EnableNext(TRUE);
        }
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericScriptParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericScriptParamsPage::OnChangeRequired
//
//	Routine Description:
//		Handler for the EN_CHANGE message on required controls.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericScriptParamsPage::OnChangeRequired(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if (m_editScriptFilepath.GetWindowTextLength() == 0)
        {
			EnableNext(FALSE);
        }
		else
        {
			EnableNext(TRUE);
        }
	}  // if:  in a wizard

}  //*** CGenericScriptParamsPage::OnChangeRequired()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\genscript.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 2000 Microsoft Corporation
//
//	Module Name:
//		GenScript.h
//
//	Abstract:
//		Definition of the CGenericScriptParamsPage class, which implements the
//		parameters page for Generic Script resources.
//
//	Implementation File:
//		GenApp.cpp
//
//	Author:
//		Geoffrey Pease (GPease) 31-JAN-2000
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENSCRIPT_H_
#define _GENSCRIPT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericScriptParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericScriptParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericScriptParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericScriptParamsPage)

// Construction
public:
	CGenericScriptParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericScriptParamsPage)
	enum { IDD = IDD_PP_GENAPP_PARAMETERS };
	CEdit	m_editScriptFilepath;
	CString	m_strScriptFilepath;
	//}}AFX_DATA
	CString	m_strPrevScriptFilepath;

protected:
	enum
	{
		epropScriptFilepath,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericScriptParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericScriptParamsPage)
	afx_msg void OnChangeRequired();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericScriptParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENSCRIPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\gensvc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenSvc.cpp
//
//	Abstract:
//		Definition of the CGenericSvcParamsPage class, which implements the
//		Parameters page for Generic Service resources.
//
//	Implementation File:
//		GenSvc.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _GENSVC_H_
#define _GENSVC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CGenericSvcParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CGenericSvcParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CGenericSvcParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CGenericSvcParamsPage)

// Construction
public:
	CGenericSvcParamsPage(void);

// Dialog Data
	//{{AFX_DATA(CGenericSvcParamsPage)
	enum { IDD = IDD_PP_GENSVC_PARAMETERS };
	CButton	m_ckbUseNetworkName;
	CEdit	m_editServiceName;
	CString	m_strServiceName;
	CString	m_strCommandLine;
	BOOL	m_bUseNetworkName;
	//}}AFX_DATA
	CString	m_strPrevServiceName;
	CString	m_strPrevCommandLine;
	BOOL	m_bPrevUseNetworkName;

protected:
	enum
	{
		epropServiceName,
		epropCommandLine,
		epropUseNetworkName,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenericSvcParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual void		DisplaySetPropsError(IN DWORD dwStatus) const;

	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGenericSvcParamsPage)
	afx_msg void OnChangeServiceName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CGenericSvcParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _GENSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\helpdata.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.h
//
//	Abstract:
//		Definitions for data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _HELPDATA_H_
#define _HELPDATA_H_

#include "HelpArr.h"

/////////////////////////////////////////////////////////////////////////////

#endif // _HELPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\helpdata.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		HelpData.cpp
//
//	Abstract:
//		Data required for implementing help.
//
//	Author:
//		David Potter (davidp)	February 19, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"

// Define help IDs.
#include "HelpIDs.h"

// Declare arrays.  If we don't do this the arrays don't get instantiated
// in the executable image.
#include "HelpArr.h"

// Define the arrays.
#define INITHELPARRAYS
#include "HelpArr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\gensvc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		GenSvc.cpp
//
//	Abstract:
//		Implementation of the CGenericSvcParamsPage class.
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "GenSvc.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenericSvcParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CGenericSvcParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CGenericSvcParamsPage, CBasePropertyPage)
	//{{AFX_MSG_MAP(CGenericSvcParamsPage)
	ON_EN_CHANGE(IDC_PP_GENSVC_PARAMS_SERVICE_NAME, OnChangeServiceName)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_PP_GENSVC_PARAMS_COMMAND_LINE, CBasePropertyPage::OnChangeCtrl)
	ON_BN_CLICKED(IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::CGenericSvcParamsPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGenericSvcParamsPage::CGenericSvcParamsPage(void)
	: CBasePropertyPage(g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS, g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS)
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CGenericSvcParamsPage)
	m_strServiceName = _T("");
	m_strCommandLine = _T("");
	m_bUseNetworkName = FALSE;
	//}}AFX_DATA_INIT

	m_bPrevUseNetworkName = FALSE;

	// Setup the property array.
	{
		m_rgProps[epropServiceName].Set(REGPARAM_GENSVC_SERVICE_NAME, m_strServiceName, m_strPrevServiceName);
		m_rgProps[epropCommandLine].Set(REGPARAM_GENSVC_COMMAND_LINE, m_strCommandLine, m_strPrevCommandLine);
		m_rgProps[epropUseNetworkName].Set(REGPARAM_GENSVC_USE_NETWORK_NAME, m_bUseNetworkName, m_bPrevUseNetworkName);
	}  // Setup the property array

	m_iddPropertyPage = IDD_PP_GENSVC_PARAMETERS;
	m_iddWizardPage = IDD_WIZ_GENSVC_PARAMETERS;

}  //*** CGenericSvcParamsPage::CGenericSvcParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::DoDataExchange(CDataExchange * pDX)
{
	if (!pDX->m_bSaveAndValidate || !BSaved())
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

		// TODO: Modify the following lines to represent the data displayed on this page.
		//{{AFX_DATA_MAP(CGenericSvcParamsPage)
		DDX_Control(pDX, IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, m_ckbUseNetworkName);
		DDX_Control(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, m_editServiceName);
		DDX_Text(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, m_strServiceName);
		DDX_Text(pDX, IDC_PP_GENSVC_PARAMS_COMMAND_LINE, m_strCommandLine);
		DDX_Check(pDX, IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME, m_bUseNetworkName);
		//}}AFX_DATA_MAP

		if (!BBackPressed())
			DDV_RequiredText(pDX, IDC_PP_GENSVC_PARAMS_SERVICE_NAME, IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, m_strServiceName);
	}  // if:  not saving or haven't saved yet

	CBasePropertyPage::DoDataExchange(pDX);

}  //*** CGenericSvcParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CGenericSvcParamsPage::OnSetActive(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// If there is no network name, hide the UseNetworkName control.
	{
		WCHAR	wszNetName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD	nSize = sizeof(wszNetName) / sizeof(WCHAR);
		BOOL	bNetNameExists;

		bNetNameExists = Peo()->BGetResourceNetworkName(
									wszNetName,
									&nSize
									);
		m_ckbUseNetworkName.EnableWindow(bNetNameExists);
	}  // If there is no network name, hide the UseNetworkName control

	// Enable/disable the Next/Finish button.
	if (BWizard())
	{
		if (m_strServiceName.GetLength() == 0)
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  enable/disable the Next button

	return CBasePropertyPage::OnSetActive();

}  //*** CGenericSvcParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::OnChangeSignature
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Service Name edit control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::OnChangeServiceName(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	OnChangeCtrl();

	if (BWizard())
	{
		if (m_editServiceName.GetWindowTextLength() == 0)
			EnableNext(FALSE);
		else
			EnableNext(TRUE);
	}  // if:  in a wizard

}  //*** CGenericSvcParamsPage::OnChangeServiceName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CGenericSvcParamsPage::DisplaySetPropsError
//
//	Routine Description:
//		Display an error caused by setting or validating properties.
//
//	Arguments:
//		dwStatus	[IN] Status to display error on.
//
//	Return Value:
//		dwStatus	ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
void CGenericSvcParamsPage::DisplaySetPropsError(IN DWORD dwStatus) const
{
	CString		strMsg;

	if (dwStatus == ERROR_NOT_SUPPORTED)
		strMsg.FormatMessage(IDS_INVALID_GENERIC_SERVICE, m_strServiceName);
	else
		FormatError(strMsg, dwStatus);

	AfxMessageBox(strMsg, MB_OK | MB_ICONSTOP);

}  //*** CGenericSvcParamsPage::DisplaySetPropsError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\helpids.h ===
#define IDH_CLUSNAME                            700000000
#define IDH_FILESHR_ADV_DFS_ROOT                700000051
#define IDH_FILESHR_ADV_HIDE_SUBDIR_SHARES      700000053
#define IDH_FILESHR_ADV_NORMAL_SHARE            700000050
#define IDH_FILESHR_ADV_SHARE_SUBDIRS           700000052
#define IDH_FILESHR_CACHE_ALLOW_CACHING         0
#define IDH_FILESHR_CACHE_OPTIONS               0
#define IDH_FILESHR_CACHE_HINT                  0
#define IDH_PP_DISKS_PARAMS_DISK                700000100
#define IDH_PP_FILESHR_PARAMS_ADVANCED          700000133
#define IDH_PP_FILESHR_PARAMS_MAX_USERS         700000131
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB  700000129
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP   700000128
#define IDH_PP_FILESHR_PARAMS_MAX_USERS_RB      700000130
#define IDH_PP_FILESHR_PARAMS_PATH              700000126
#define IDH_PP_FILESHR_PARAMS_PERMISSIONS       700000132
#define IDH_PP_FILESHR_PARAMS_REMARK            700000127
#define IDH_PP_FILESHR_PARAMS_SHARE_NAME        700000125
#define IDH_PP_FILESHR_PARAMS_CACHING           700000302
#define IDH_PP_GENAPP_PARAMS_COMMAND_LINE       700000150
#define IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY  700000151
#define IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP  700000152
#define IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME   700000153
#define IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH  700000154
#define IDH_PP_GENSVC_PARAMS_COMMAND_LINE       700000176
#define IDH_PP_GENSVC_PARAMS_SERVICE_NAME       700000175
#define IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME   700000177
#define IDH_PP_IPADDR_PARAMS_ADDRESS            700000200
#define IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS     700000203
#define IDH_PP_IPADDR_PARAMS_NETWORK            700000202
#define IDH_PP_IPADDR_PARAMS_SUBNET_MASK        700000201
#define IDH_PP_NETNAME_PARAMS_NAME              700000225
#define IDH_PP_NETNAME_PARAMS_RENAME            700000226
#define IDH_PP_NETNAME_PARAMS_REQDNS            700000303
#define IDH_PP_NETNAME_PARAMS_REQKER            700000304
#define IDH_PP_NETNAME_PARAMS_STATUSNET         700000305
#define IDH_PP_NETNAME_PARAMS_STATUSDNS         700000306
#define IDH_PP_NETNAME_PARAMS_STATUSKER         700000307
#define IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR        700000250
#define IDH_PP_PRTSPOOL_PARAMS_TIMEOUT          700000251
#define IDH_PP_REGREPL_PARAMS_ADD               700000276
#define IDH_PP_REGREPL_PARAMS_LIST              700000275
#define IDH_PP_REGREPL_PARAMS_MODIFY            700000277
#define IDH_PP_REGREPL_PARAMS_REMOVE            700000278
#define IDH_REGKEY                              700000025
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\helparr.h ===
#define IDH_DISABLEHELP ((DWORD)-1)

#ifdef INITHELPARRAYS


const DWORD g_aHelpIDs_IDD_EDIT_CLUSTER_NAME[]=
{
    IDC_CLUSNAME_TEXT, IDH_DISABLEHELP,
    IDC_CLUSNAME_LABEL, IDH_CLUSNAME,
    IDC_CLUSNAME,IDH_CLUSNAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_EDIT_REGKEY[]=
{
    IDC_REGKEY_LABEL, IDH_REGKEY,
    IDC_REGKEY,IDH_REGKEY,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FILESHR_ADVANCED[]=
{
    IDC_FILESHR_ADV_NORMAL_SHARE,IDH_FILESHR_ADV_NORMAL_SHARE,
    IDC_FILESHR_ADV_DFS_ROOT,IDH_FILESHR_ADV_DFS_ROOT,
    IDC_FILESHR_ADV_SHARE_SUBDIRS,IDH_FILESHR_ADV_SHARE_SUBDIRS,
    IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES,IDH_FILESHR_ADV_HIDE_SUBDIR_SHARES,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FILESHR_CACHE_SETTINGS[]=
{
    IDC_FILESHR_CACHE_ALLOW_CACHING_GROUP,IDH_FILESHR_CACHE_ALLOW_CACHING,
    IDC_FILESHR_CACHE_ALLOW_CACHING,IDH_FILESHR_CACHE_ALLOW_CACHING,
    IDC_FILESHR_CACHE_SETTINGS_LABEL,IDH_FILESHR_CACHE_OPTIONS,
    IDC_FILESHR_CACHE_OPTIONS,IDH_FILESHR_CACHE_OPTIONS,
    IDC_FILESHR_CACHE_HINT,IDH_FILESHR_CACHE_HINT,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_DISKS_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_DISKS_PARAMS_DISK_LABEL, IDH_PP_DISKS_PARAMS_DISK,
    IDC_PP_DISKS_PARAMS_DISK,IDH_PP_DISKS_PARAMS_DISK,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME,IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_PATH_LABEL, IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_PATH,IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_REMARK_LABEL, IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_REMARK,IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP, IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS,IDH_PP_FILESHR_PARAMS_MAX_USERS,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_END, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_PERMISSIONS,IDH_PP_FILESHR_PARAMS_PERMISSIONS,
    IDC_PP_FILESHR_PARAMS_ADVANCED,IDH_PP_FILESHR_PARAMS_ADVANCED,
    IDC_PP_FILESHR_PARAMS_CACHING,IDH_PP_FILESHR_PARAMS_CACHING,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE,IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,
    IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME,IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP, 
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME,IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE,IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME,IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_ADDRESS,IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK,IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_NETWORK,IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS,IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS[]=
{
    IDC_PP_ICON,                                IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_NAME_LABEL,           IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_NAME,                 IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_CORE_TEXT,            IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_CORE_TEXT2,           IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_RENAME,               IDH_PP_NETNAME_PARAMS_RENAME,
    IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS,         IDH_PP_NETNAME_PARAMS_REQDNS,
    IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS,    IDH_PP_NETNAME_PARAMS_REQKER,
    IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS,       IDH_PP_NETNAME_PARAMS_STATUSNET,
    IDC_PP_NETNAME_PARAMS_STATUS_DNS,           IDH_PP_NETNAME_PARAMS_STATUSDNS,
    IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS,      IDH_PP_NETNAME_PARAMS_STATUSKER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR,IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1, IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT,IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_NOTE, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_LIST,IDH_PP_REGREPL_PARAMS_LIST,
    IDC_PP_REGREPL_PARAMS_ADD,IDH_PP_REGREPL_PARAMS_ADD,
    IDC_PP_REGREPL_PARAMS_MODIFY,IDH_PP_REGREPL_PARAMS_MODIFY,
    IDC_PP_REGREPL_PARAMS_REMOVE,IDH_PP_REGREPL_PARAMS_REMOVE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_DISKS_PARAMS_DISK_LABEL, IDH_PP_DISKS_PARAMS_DISK,
    IDC_PP_DISKS_PARAMS_DISK,IDH_PP_DISKS_PARAMS_DISK,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_SHARE_NAME,IDH_PP_FILESHR_PARAMS_SHARE_NAME,
    IDC_PP_FILESHR_PARAMS_PATH_LABEL, IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_PATH,IDH_PP_FILESHR_PARAMS_PATH,
    IDC_PP_FILESHR_PARAMS_REMARK_LABEL, IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_REMARK,IDH_PP_FILESHR_PARAMS_REMARK,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP, IDH_PP_FILESHR_PARAMS_MAX_USERS_GROUP,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_RB,IDH_PP_FILESHR_PARAMS_MAX_USERS_RB,
    IDC_PP_FILESHR_PARAMS_MAX_USERS,IDH_PP_FILESHR_PARAMS_MAX_USERS,
    IDC_PP_FILESHR_PARAMS_MAX_USERS_END, IDH_DISABLEHELP,
    IDC_PP_FILESHR_PARAMS_PERMISSIONS,IDH_PP_FILESHR_PARAMS_PERMISSIONS,
    IDC_PP_FILESHR_PARAMS_ADVANCED,IDH_PP_FILESHR_PARAMS_ADVANCED,
    IDC_PP_FILESHR_PARAMS_CACHING,IDH_PP_FILESHR_PARAMS_CACHING,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_COMMAND_LINE,IDH_PP_GENAPP_PARAMS_COMMAND_LINE,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL, IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,IDH_PP_GENAPP_PARAMS_CURRENT_DIRECTORY,
    IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,IDH_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP,
    IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME,IDH_PP_GENAPP_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,IDH_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP, 
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL, IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_SERVICE_NAME,IDH_PP_GENSVC_PARAMS_SERVICE_NAME,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL, IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_COMMAND_LINE,IDH_PP_GENSVC_PARAMS_COMMAND_LINE,
    IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME,IDH_PP_GENSVC_PARAMS_USE_NETWORK_NAME,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_ADDRESS,IDH_PP_IPADDR_PARAMS_ADDRESS,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_SUBNET_MASK,IDH_PP_IPADDR_PARAMS_SUBNET_MASK,
    IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_NETWORK,IDH_PP_IPADDR_PARAMS_NETWORK,
    IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS,IDH_PP_IPADDR_PARAMS_ENABLE_NETBIOS,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_NETNAME_PARAMS_NAME_LABEL, IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_NAME,IDH_PP_NETNAME_PARAMS_NAME,
    IDC_PP_NETNAME_PARAMS_RENAME,IDH_PP_NETNAME_PARAMS_RENAME,
    IDC_PP_NETNAME_PARAMS_CORE_TEXT, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR,IDH_PP_PRTSPOOL_PARAMS_SPOOL_DIR,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1, IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT,IDH_PP_PRTSPOOL_PARAMS_TIMEOUT,
    IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2, IDH_DISABLEHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS[]=
{
    IDC_PP_ICON, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_NOTE, IDH_DISABLEHELP,
    IDC_PP_REGREPL_PARAMS_LIST,IDH_PP_REGREPL_PARAMS_LIST,
    IDC_PP_REGREPL_PARAMS_ADD,IDH_PP_REGREPL_PARAMS_ADD,
    IDC_PP_REGREPL_PARAMS_MODIFY,IDH_PP_REGREPL_PARAMS_MODIFY,
    IDC_PP_REGREPL_PARAMS_REMOVE,IDH_PP_REGREPL_PARAMS_REMOVE,
    0, 0
};


#else

extern const DWORD g_aHelpIDs_IDD_PP_DISKS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENAPP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENSCRIPT_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_GENSVC_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_DISKS_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENAPP_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENSCRIPT_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_GENSVC_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS[];
extern const DWORD g_aHelpIDs_IDD_EDIT_REGKEY[];
extern const DWORD g_aHelpIDs_IDD_EDIT_CLUSTER_NAME[];
extern const DWORD g_aHelpIDs_IDD_FILESHR_ADVANCED[];
extern const DWORD g_aHelpIDs_IDD_FILESHR_CACHE_SETTINGS[];

#endif // INITHELPARRAYS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\proplsts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      PropLstS.cpp
//
//  Abstract:
//      Stub for implementation of property list classes.
//
//  Author:
//      David Potter (davidp)	February 24, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <PropListSrc.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\netname.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      NetName.cpp
//
//  Abstract:
//      Implementation of the CNetworkNameParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "NetName.h"
#include "DDxDDv.h"
#include "ExcOper.h"
#include "ClusName.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetworkNameParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CNetworkNameParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CNetworkNameParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CNetworkNameParamsPage)
    ON_EN_CHANGE(IDC_PP_NETNAME_PARAMS_NAME, OnChangeName)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_RENAME, OnRename)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, CBasePropertyPage::OnChangeCtrl)
    ON_BN_CLICKED(IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, CBasePropertyPage::OnChangeCtrl)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::CNetworkNameParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkNameParamsPage::CNetworkNameParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_NETNAME_PARAMETERS, g_aHelpIDs_IDD_WIZ_NETNAME_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CNetworkNameParamsPage)
    m_strName = _T("");
    m_strPrevName = _T("");
    m_nRequireDNS = BST_UNCHECKED;
    m_nRequireKerberos = BST_UNCHECKED;
    m_dwNetBIOSStatus = 0;
    m_dwDNSStatus = 0;
    m_dwKerberosStatus = 0;
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropName].Set(REGPARAM_NETNAME_NAME, m_strName, m_strPrevName);
        m_rgProps[epropRequireDNS].Set(REGPARAM_NETNAME_REQUIRE_DNS, m_nRequireDNS, m_nPrevRequireDNS);
        m_rgProps[epropRequireKerberos].Set(REGPARAM_NETNAME_REQUIRE_KERBEROS, m_nRequireKerberos, m_nPrevRequireKerberos);
        m_rgProps[epropStatusNetBIOS].Set(REGPARAM_NETNAME_STATUS_NETBIOS, m_dwNetBIOSStatus, m_dwPrevNetBIOSStatus);
        m_rgProps[epropStatusDNS].Set(REGPARAM_NETNAME_STATUS_DNS, m_dwDNSStatus, m_dwPrevDNSStatus);
        m_rgProps[epropStatusKerberos].Set(REGPARAM_NETNAME_STATUS_KERBEROS, m_dwKerberosStatus, m_dwPrevKerberosStatus);
    }  // Setup the property array

    m_dwFlags = 0;

    m_iddPropertyPage = IDD_PP_NETNAME_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_NETNAME_PARAMETERS;

}  //*** CNetworkNameParamsPage::CNetworkNameParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CNetworkNameParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     hr;
    CWaitCursor wc;
    DWORD   sc;
    DWORD   cbReturned;

    // Call the base class method.
    // This populates the m_rgProps struct.
    hr = CBasePropertyPage::HrInit(peo);   

    if (!FAILED(hr))
    {
        m_strPrevName = m_strName;
        
        // Read the flags for this resource.
        sc = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,
                        CLUSCTL_RESOURCE_GET_FLAGS,
                        NULL,
                        NULL,
                        &m_dwFlags,
                        sizeof(m_dwFlags),
                        &cbReturned
                        );
        if (sc != ERROR_SUCCESS)
        {
            CNTException nte(sc, NULL, NULL, FALSE /*bAutoDelete*/);
            nte.ReportError();
            nte.Delete();
        }  // if:  error retrieving data
        else
        {
            ASSERT(cbReturned == sizeof(m_dwFlags));
        }  // else:  data retrieved successfully
    }  // if: base class init was successful

    return hr;

}  //*** CNetworkNameParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::DoDataExchange(CDataExchange * pDX)
{
    DWORD       scError;
    BOOL        bError;

    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        CWaitCursor wc;
        CString     strNetName;

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CNetworkNameParamsPage)
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_NAME_LABEL, m_staticName);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_RENAME, m_pbRename);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CORE_TEXT, m_staticCore);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_NAME, m_editName);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, m_cbRequireDNS);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, m_cbRequireKerberos);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS, m_editNetBIOSStatus);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_DNS, m_editDNSStatus);
        DDX_Control(pDX, IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS, m_editKerberosStatus);

        //
        // Get the status of the checkboxes.
        //
        DDX_Check(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS, m_nRequireDNS);
        DDX_Check(pDX, IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS, m_nRequireKerberos);
        //}}AFX_DATA_MAP

        bError = FALSE;

        if (pDX->m_bSaveAndValidate && !BBackPressed())
        {
            CLRTL_NAME_STATUS cnStatus;
            CString     strMsg;
            UINT        idsError;

            //
            // Get the name from the control into a temp variable
            //
            DDX_Text(pDX, IDC_PP_NETNAME_PARAMS_NAME, strNetName);
            DDV_RequiredText(pDX, IDC_PP_NETNAME_PARAMS_NAME, IDC_PP_NETNAME_PARAMS_NAME_LABEL, strNetName);
            DDV_MaxChars(pDX, strNetName, MAX_CLUSTERNAME_LENGTH);

            //
            // if turning off Kerb, warn the user about what they are about to do
            //
            if ( ( m_nRequireKerberos == 0 ) && ( m_nPrevRequireKerberos == 1 ) ) {
                strMsg.LoadString(IDS_WARNING_DISABLING_KERBEROS);

                int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                if ( id == IDNO )
                {
                    strMsg.Empty();
                    pDX->Fail();
                    bError = TRUE;
                }
            }

            //
            // validate the name if it changed
            //
            if ( (m_strName != strNetName ) &&
                 (! ClRtlIsNetNameValid(strNetName, &cnStatus, FALSE /*CheckIfExists*/)) )
            {
                switch (cnStatus)
                {
                    case NetNameTooLong:
                        idsError = IDS_INVALID_NETWORK_NAME_TOO_LONG;
                        break;
                    case NetNameInvalidChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_CHARS;
                        break;
                    case NetNameInUse:
                        idsError = IDS_INVALID_NETWORK_NAME_IN_USE;
                        break;
                    case NetNameDNSNonRFCChars:
                        idsError = IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS;
                        break;
                    case NetNameSystemError:
                    {
                        scError = GetLastError();
                        CNTException nte(scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strNetName);
                        nte.ReportError();
                        pDX->Fail();
                    }
                    default:
                        idsError = IDS_INVALID_NETWORK_NAME;
                        break;
                }  // switch:  cnStatus

                strMsg.LoadString(idsError);
                if ( idsError == IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS )
                {
                    int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                    if ( id == IDNO )
                    {
                        strMsg.Empty();
                        pDX->Fail();
                        bError = TRUE;
                    }
                }
                else
                {
                    AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                    strMsg.Empty(); // exception prep
                    pDX->Fail();
                    bError = TRUE;
                }
            } // if: ((m_strName != strNetName) && (! ClRtlIsNetNameValid(strNetName, &cnStatus, FALSE)) )
            
            //
            // Everything was validated - apply all of the changes.
            //
            if( FALSE == bError )
            {
                m_strName = strNetName;
            }
            
        }// if:  (pDX->m_bSaveAndValidate && !BBackPressed())
        else  // if: populating controls
        {
            CString m_strStatus;

            //
            // Populate the controls with data from the member variables.
            //
            DDX_Text(pDX, IDC_PP_NETNAME_PARAMS_NAME, m_strName);

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwNetBIOSStatus, m_dwNetBIOSStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS, m_strStatus );

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwDNSStatus, m_dwDNSStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_DNS, m_strStatus );

            m_strStatus.Format( _T("%d (0x%08x)"), m_dwKerberosStatus, m_dwKerberosStatus );
            DDX_Text( pDX, IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS, m_strStatus );
        }
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CNetworkNameParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    // Set up the checkboxes.
    m_cbRequireDNS.EnableWindow( TRUE );
    m_cbRequireKerberos.EnableWindow( TRUE );

    // 
    // Make sure we're not dealing with a non-Whistler Cluster.  If we are then
    // disable both checkboxes (the props didn't exist back then - don't set them).
    //
    CheckForDownlevelCluster();
    
    // If this is a core resource, set the name control to be read-only
    // and enable the Core Resource static control.
    if (BCore())
    {
        WINDOWPLACEMENT wpLabel;
        WINDOWPLACEMENT wpName;
        WINDOWPLACEMENT wpButton;
        WINDOWPLACEMENT wpText;
        WINDOWPLACEMENT wpCheckDNS;
        WINDOWPLACEMENT wpCheckKerberos;
        CRect           rectName;
        CRect           rectText;
        RECT *          prect;
        LONG            nHeight;

        // Get the placement of the controls.
        m_editName.GetWindowPlacement(&wpName);
        m_staticCore.GetWindowPlacement(&wpText);
        m_staticName.GetWindowPlacement(&wpLabel);
        m_pbRename.GetWindowPlacement(&wpButton);
        m_cbRequireDNS.GetWindowPlacement(&wpCheckDNS);
        m_cbRequireKerberos.GetWindowPlacement(&wpCheckKerberos);
        
        // Get the positions of the edit control and text control.
        rectName = wpName.rcNormalPosition;
        rectText = wpText.rcNormalPosition;

        // Move the name control to where the text control is.
        prect = &wpName.rcNormalPosition;
        *prect = rectText;
        nHeight = rectName.bottom - rectName.top;
        prect->left = rectName.left;
        prect->right = rectName.right;
        prect->bottom = prect->top + nHeight;
        m_editName.SetWindowPlacement(&wpName);

        // Move the text control to where the name control was.
        prect = &wpText.rcNormalPosition;
        *prect = rectName;
        nHeight = rectText.bottom - rectText.top;
        prect->left = rectText.left;
        prect->right = rectText.right;
        prect->bottom = prect->top + nHeight;
        m_staticCore.SetWindowPlacement(&wpText);

        // Move the name label control to be next to the name edit control.
        prect = &wpLabel.rcNormalPosition;
        nHeight = prect->bottom - prect->top;
        prect->top = wpName.rcNormalPosition.top + 2;
        prect->bottom = prect->top + nHeight;
        m_staticName.SetWindowPlacement(&wpLabel);

        // Move the button control to be next to the name edit control.
        prect = &wpButton.rcNormalPosition;
        nHeight = prect->bottom - prect->top;
        prect->top = wpName.rcNormalPosition.top;
        prect->bottom = prect->top + nHeight;
        m_pbRename.SetWindowPlacement(&wpButton);

        // Move the Require DNS checkbox down.
        prect = &wpCheckDNS.rcNormalPosition;
        nHeight = prect->bottom - prect->top;

        // Move us down by the height of the now displayed static text.
        prect->top = prect->top + (wpText.rcNormalPosition.bottom - wpText.rcNormalPosition.top);
        prect->top = prect->top + rectText.top - rectName.bottom;
        prect->bottom = prect->top + nHeight;
        m_cbRequireDNS.SetWindowPlacement(&wpCheckDNS);
        
        // Move the Require Kerberos checkbox down.
        prect = &wpCheckKerberos.rcNormalPosition;
        nHeight = prect->bottom - prect->top;

        // Move us down by the height of the now displayed static text.
        prect->top = prect->top + (wpText.rcNormalPosition.bottom - wpText.rcNormalPosition.top);
        prect->top = prect->top + rectText.top - rectName.bottom;
        prect->bottom = prect->top + nHeight;
        m_cbRequireKerberos.SetWindowPlacement(&wpCheckKerberos);

        // Prevent the name edit control from being editable and
        // Show the text and the button.
        m_editName.SetReadOnly(TRUE);
        m_staticCore.ShowWindow(SW_SHOW);
        m_pbRename.ShowWindow(SW_SHOW);
        m_pbRename.EnableWindow( TRUE );       
    }
    else // if: core resource (show static text & move other controls down)
    {
        m_editName.SetReadOnly(FALSE);
        m_staticCore.ShowWindow(SW_HIDE);
        m_pbRename.ShowWindow(SW_HIDE);
        m_pbRename.EnableWindow( FALSE );
    }  // else:  not core resource

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CNetworkNameParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strName.GetLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CNetworkNameParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CNetworkNameParamsPage::BApplyChanges(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;
    BOOL        bSuccess = TRUE;

    // Save data.
    if (BCore())
    {
        DWORD       scStatus;

        //
        // If this is the core Network Name (Cluster Name) we should set the name via
        // the SetClusterName API. If that succeeds then we'll set the other properties.
        //
        if ( m_strName != m_strPrevName )
        {
            scStatus = SetClusterName(Hcluster(), m_strName);
            if (scStatus != ERROR_SUCCESS)
            {
                if (scStatus == ERROR_RESOURCE_PROPERTIES_STORED)
                {
                    TCHAR           szError[1024];
                    CNTException    nte(scStatus, NULL, m_strName, NULL, FALSE /*bAutoDelete*/);
                    nte.FormatErrorMessage(szError, sizeof(szError) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
                    nte.Delete();
                    AfxMessageBox(szError);
                }  // if:  properties stored
                else
                {
                    CNTException    nte(scStatus, IDS_ERROR_SETTING_CLUSTER_NAME, m_strName, NULL, FALSE /*bAutoDelete*/);
                    nte.ReportError();
                    nte.Delete();
                    bSuccess = FALSE;
                }  // else:  other error occurred
            }  // if:  error setting the cluster name
          
            if ( bSuccess ) 
            {
                //
                // By setting the prev value equal to the current value the BSetPrivateProps
                // function will skip this prop when constructing it's list of props to set.
                //
                m_strPrevName = m_strName;
            }
        } // if: name has changed

        //
        // Now set the other private properties.
        //
        if ( bSuccess == TRUE ) 
        {
            bSuccess = BSetPrivateProps();
        }
    }  // if:  core resource
    else
    {   
        bSuccess = BSetPrivateProps();
    }

    //
    // If we applied the changes then clear the require kerberos check if
    // the checkbox was disabled.  Don't make this dependent upon the require
    // DNS checkbox state as the dependency may change in the future.
    //
    if( ( bSuccess == TRUE ) &&
        ( m_cbRequireKerberos.IsWindowEnabled() == FALSE ) )
    {
        m_cbRequireKerberos.SetCheck( BST_UNCHECKED );
    }

    return bSuccess;

}  //*** CNetworkNameParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnChangeName
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Name edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::OnChangeName(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_editName.GetWindowTextLength() == 0)
        {
            EnableNext(FALSE);
        }
        else
        {
            EnableNext(TRUE);
        }
    }  // if:  in a wizard

}  //*** CNetworkNameParamsPage::OnChangeName()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::OnRename
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Rename push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::OnRename(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CChangeClusterNameDlg   dlg(this);

    ASSERT(BCore());

    dlg.m_strClusName = m_strName;
    if (dlg.DoModal() == IDOK)
    {
        if (m_strName != dlg.m_strClusName)
        {
            OnChangeCtrl();
            m_strName = dlg.m_strClusName;
            UpdateData(FALSE /*bSaveAndValidate*/);
        }  // if:  the name changed
    }  // if:  user accepted change

}  //*** CNetworkNameParamsPage::OnRename()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CNetworkNameParamsPage::CheckForDownlevelCluster
//
//  Routine Description:
//      If determine whether the cluster we're connected to is pre-Whistler.
//      If it is then disable the buttons.  If an error occurs display a
//      message box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CNetworkNameParamsPage::CheckForDownlevelCluster(void)
{
    CLUSTERVERSIONINFO cvi;
    DWORD sc;
    DWORD scErr;
    DWORD cchName;

    //
    // Determine whether we're talking to a pre-Whistler cluster.
    // If so, disable the Require DNS & Kerberos checkboxes.
    //
    memset( &cvi, 0, sizeof( cvi ) );

    cvi.dwVersionInfoSize = sizeof( cvi );

    cchName = 0;
    sc = GetClusterInformation( Hcluster(), NULL, &cchName, &cvi );
    scErr = GetLastError();

    if( ERROR_SUCCESS != sc )
    {
        //
        // API failed.  Pop up a message box.
        //
        TCHAR           szError[1024];
        CNTException    nte(scErr, IDS_ERROR_GETTING_CLUSTER_INFORMATION, m_strName, NULL, FALSE /*bAutoDelete*/);
        nte.FormatErrorMessage(szError, sizeof(szError) / sizeof(TCHAR), NULL, FALSE /*bIncludeID*/);
        nte.ReportError();
        nte.Delete();

        //
        // We can't be sure that we're on a down-level cluster (chances are that we're not),
        // so leave the checkboxes enabled - the worst that will happen is that some extra props 
        // will be added that are ignored by the resource.
        //
    }
    else
    {
        if( CLUSTER_GET_MAJOR_VERSION( cvi.dwClusterHighestVersion ) < NT5_MAJOR_VERSION )     // Less than Win2k.
        {
            //
            // We're on a pre-Win2k Cluster where the DNS & Kerberos setting make no
            // sense.  So, disable the checkboxes to indicate that the settings
            // are unavailable.  We'd like to only enable these on Win2k SP3 and later,
            // but there's no reliable way to determine SP levels in the cluster (nodes 
            // may be down).
            //
            m_cbRequireKerberos.EnableWindow( FALSE );
            m_cbRequireDNS.EnableWindow( FALSE );
        }
    }

}  //*** CNetworkNameParamsPage::CheckForDownlevelCluster()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\prtspool.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      PrtSpool.cpp
//
//  Abstract:
//      Implementation of the CPrintSpoolerParamsPage class.
//
//  Author:
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "ExtObj.h"
#include "PrtSpool.h"
#include "DDxDDv.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPrintSpoolerParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CPrintSpoolerParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CPrintSpoolerParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CPrintSpoolerParamsPage)
    ON_EN_CHANGE(IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, OnChangeSpoolDir)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_EN_CHANGE(IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::CPrintSpoolerParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CPrintSpoolerParamsPage::CPrintSpoolerParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_PRTSPOOL_PARAMETERS, g_aHelpIDs_IDD_WIZ_PRTSPOOL_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CPrintSpoolerParamsPage)
    m_strSpoolDir = _T("");
    m_nJobCompletionTimeout = 0;
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropSpoolDir].Set(REGPARAM_PRTSPOOL_DEFAULT_SPOOL_DIR, m_strSpoolDir, m_strPrevSpoolDir);
        m_rgProps[epropTimeout].Set(REGPARAM_PRTSPOOL_TIMEOUT, m_nJobCompletionTimeout, m_nPrevJobCompletionTimeout);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_PRTSPOOL_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_PRTSPOOL_PARAMETERS;

}  //*** CPrintSpoolerParamsPage::CPrintSpoolerParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CPrintSpoolerParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if (FAILED(_hr))
            break;

        if (BWizard())
            m_nJobCompletionTimeout = 160;
        else
        {
            // Convert the job completion timeout to seconds.
            m_nPrevJobCompletionTimeout = m_nJobCompletionTimeout;
            m_nJobCompletionTimeout = (m_nJobCompletionTimeout + 999) / 1000;
        }  // else:  not creating new resource
    } while ( 0 );

    return _hr;

}  //*** CPrintSpoolerParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPrintSpoolerParamsPage::DoDataExchange(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CPrintSpoolerParamsPage)
        DDX_Control(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, m_editSpoolDir);
        DDX_Text(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, m_strSpoolDir);
        DDX_Text(pDX, IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, m_nJobCompletionTimeout);
        //}}AFX_DATA_MAP

        if (!BBackPressed())
        {
            DDX_Number(pDX, IDC_PP_PRTSPOOL_PARAMS_TIMEOUT, m_nJobCompletionTimeout, 0, 0x7fffffff / 1000);
        }

        if (pDX->m_bSaveAndValidate && !BBackPressed())
        {
            DDV_RequiredText(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, m_strSpoolDir);
            DDV_MaxChars(pDX, m_strSpoolDir, MAX_PATH);
            DDV_Path(pDX, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR, IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL, m_strSpoolDir);
        }  // if:  saving data from dialog and back button not pressed
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CPrintSpoolerParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get a default value for the spool directory if it hasn't been set yet.
    if (m_strSpoolDir.GetLength() == 0)
    {
        ConstructDefaultDirectory(m_strSpoolDir, IDS_DEFAULT_SPOOL_DIR);
    }

    // Call the base class.
    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editSpoolDir.SetLimitText(MAX_PATH);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CPrintSpoolerParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if (m_strSpoolDir.GetLength() == 0)
        {
            EnableNext(FALSE);
        }
        else
        {
            EnableNext(TRUE);
        }
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CPrintSpoolerParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CPrintSpoolerParamsPage::BApplyChanges(void)
{
    BOOL    bSuccess;
    CWaitCursor wc;

    // Convert the job completion timeout from seconds to milliseconds.
    m_nJobCompletionTimeout *= 1000;

    // Call the base class method.
    bSuccess = CBasePropertyPage::BApplyChanges();

    // Convert the job completion timeout back to seconds.
    if (bSuccess)
        m_nPrevJobCompletionTimeout = m_nJobCompletionTimeout;
    m_nJobCompletionTimeout /= 1000;

    return bSuccess;

}  //*** CPrintSpoolerParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CPrintSpoolerParamsPage::OnChangeSpoolDir
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Spool Folder edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CPrintSpoolerParamsPage::OnChangeSpoolDir(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if (m_editSpoolDir.GetWindowTextLength() == 0)
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CPrintSpoolerParamsPage::OnChangeSpoolDir()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\ipaddr.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      IpAddr.cpp
//
//  Abstract:
//      Implementation of the CIpAddrParamsPage class.
//
//  Author:
//      David Potter (davidp)   June 5, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <clusapi.h>
#include <clusudef.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "IpAddr.h"
#include "DDxDDv.h"
#include "HelpData.h"
#include "PropList.h"
#include "AdmNetUtils.h"    // for BIsValidxxx net utility functions

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Need this because MFC is incompatible with IE4/5
#ifndef IPM_ISBLANK
#define IPM_ISBLANK (WM_USER+105)
#endif

/////////////////////////////////////////////////////////////////////////////
// CIpAddrParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CIpAddrParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CIpAddrParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CIpAddrParamsPage)
    ON_EN_CHANGE(IDC_PP_IPADDR_PARAMS_SUBNET_MASK, OnChangeSubnetMask)
    ON_EN_CHANGE(IDC_PP_IPADDR_PARAMS_ADDRESS, OnChangeIPAddress)
    ON_EN_KILLFOCUS(IDC_PP_IPADDR_PARAMS_ADDRESS, OnKillFocusIPAddress)
    ON_CBN_SELCHANGE(IDC_PP_IPADDR_PARAMS_NETWORK, OnChangeRequiredFields)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_BN_CLICKED(IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::CIpAddrParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIpAddrParamsPage::CIpAddrParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_IPADDR_PARAMETERS, g_aHelpIDs_IDD_WIZ_IPADDR_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CIpAddrParamsPage)
    m_strIPAddress = _T("");
    m_strSubnetMask = _T("");
    m_strNetwork = _T("");
    m_bEnableNetBIOS = TRUE;
    //}}AFX_DATA_INIT

    // Setup the property array.
    {
        m_rgProps[epropNetwork].Set(REGPARAM_IPADDR_NETWORK, m_strNetwork, m_strPrevNetwork);
        m_rgProps[epropAddress].Set(REGPARAM_IPADDR_ADDRESS, m_strIPAddress, m_strPrevIPAddress);
        m_rgProps[epropSubnetMask].Set(REGPARAM_IPADDR_SUBNET_MASK, m_strSubnetMask, m_strPrevSubnetMask);
        m_rgProps[epropEnableNetBIOS].Set(REGPARAM_IPADDR_ENABLE_NETBIOS, m_bEnableNetBIOS, m_bPrevEnableNetBIOS);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_IPADDR_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_IPADDR_PARAMETERS;

    m_bIsSubnetUpdatedManually = FALSE;
    m_bIsIPAddressModified = TRUE;

}  //*** CIpAddrParamsPage::CIpAddrParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::~CIpAddrParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CIpAddrParamsPage::~CIpAddrParamsPage(void)
{
    ClearNetworkObjectList();

}  //*** CIpAddrParamsPage::CIpAddrParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CIpAddrParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr;
    CWaitCursor _wc;

    do
    {
        // Call the base class method.
        _hr = CBasePropertyPage::HrInit(peo);
        if (FAILED(_hr))
            break;

        //
        // Initialize common controls.
        //
        {
#ifndef ICC_INTERNET_CLASSES
#define ICC_INTERNET_CLASSES 0x00000800
#endif
            static BOOL g_bInitializedCommonControls = FALSE;
            static INITCOMMONCONTROLSEX g_icce =
            {
                sizeof(g_icce),
                ICC_WIN95_CLASSES | ICC_INTERNET_CLASSES
            };

            if (!g_bInitializedCommonControls)
            {
                BOOL bSuccess;
                bSuccess = InitCommonControlsEx(&g_icce);
                _ASSERTE(bSuccess);
                g_bInitializedCommonControls = TRUE;
            } // if:  common controls not initialized yet
        } // Initialize common controls
    } while ( 0 );

    return _hr;

}  //*** CIpAddrParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::DoDataExchange(CDataExchange * pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        CString strMsg;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CIpAddrParamsPage)
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_chkEnableNetBIOS);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, m_cboxNetworks);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_editSubnetMask);
        DDX_Control(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_editIPAddress);
        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
        DDX_CBString(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, m_strNetwork);
        DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
        //}}AFX_DATA_MAP

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_NETWORK, IDC_PP_IPADDR_PARAMS_NETWORK_LABEL, m_strNetwork);
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL, m_strIPAddress);
                DDV_RequiredText(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL, m_strSubnetMask);

                if (!BIsValidIpAddress(m_strIPAddress))
                {
                    strMsg.FormatMessage(IDS_INVALID_IP_ADDRESS, m_strIPAddress);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid address

                //
                // Make sure we process the IP address.
                // If we don't call it here, and the user pressed a tab button
                // while sitting in the IP address field, the EN_KILLFOCUS
                // message won't get processed until after this method returns.
                //
                if (   (m_strSubnetMask.GetLength() == 0)
                    || (m_editSubnetMask.SendMessage(IPM_ISBLANK, 0, 0)) )
                {
                    OnKillFocusIPAddress();
                } // if:  subnet mask not specified

                if (!BIsValidSubnetMask(m_strSubnetMask))
                {
                    strMsg.FormatMessage(IDS_INVALID_SUBNET_MASK, m_strSubnetMask);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid subnet mask

                if (!BIsValidIpAddressAndSubnetMask(m_strIPAddress, m_strSubnetMask))
                {
                    strMsg.FormatMessage(IDS_INVALID_ADDRESS_AND_SUBNET_MASK, m_strIPAddress, m_strSubnetMask);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_ADDRESS, m_strIPAddress);
                    strMsg.Empty();
                    pDX->Fail();
                }  // if:  invalid address-mask combination

                if (BIsSubnetUpdatedManually())
                {
                    int id = AfxMessageBox(IDS_IP_SUBNET_CANT_BE_VALIDATED, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
                    if (id != IDYES)
                    {
                        DDX_Text(pDX, IDC_PP_IPADDR_PARAMS_SUBNET_MASK, m_strSubnetMask);
                        pDX->Fail();
                    }  // if:  subnet mask not valid
                }  // if:  subnet mask has been updated manually

                //
                // If there are Network Name resources dependent on this resource
                // and the EnableNetBIOS checkbox is unchecked, display a warning.
                //
                if (Peo()->BIsAnyNodeVersionLowerThanNT5() && !m_bEnableNetBIOS)
                {
                    if (BIsNetNameProvider())
                    {
                        m_chkEnableNetBIOS.SetCheck(BST_CHECKED);
                        AfxMessageBox(IDS_IP_PROVIDES_FOR_NETNAME, MB_ICONEXCLAMATION);
                        DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
                        pDX->Fail();
                    } // if:  resource provides for net name resource
                    else
                    {
                        int id = AfxMessageBox(IDS_NETNAMES_MAY_NOT_WORK, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
                        if (id != IDYES)
                        {
                            m_chkEnableNetBIOS.SetCheck(BST_CHECKED);
                            DDX_Check(pDX, IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS, m_bEnableNetBIOS);
                            pDX->Fail();
                        } // if:  user didn't continue
                    } // else:  resource doesn't provide for net name resource
                } // if:  in NT4 Sp3 or Sp4 cluster with and no NetBIOS support
            }  // if:  Back button not pressed
        }  // if:  saving data
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CIpAddrParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::OnInitDialog(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Collect networks and fill the combobox.
    {
        POSITION            pos;
        CNetworkObject *    pno;
        int                 inet;

        CollectNetworks();

        pos = m_lnetobjNetworks.GetHeadPosition();
        while (pos != NULL)
        {
            pno = m_lnetobjNetworks.GetNext(pos);
            ASSERT(pno != NULL);
            inet = m_cboxNetworks.AddString(pno->m_strName);
            ASSERT(inet != CB_ERR);
            m_cboxNetworks.SetItemDataPtr(inet, pno);
        }  // while:  more items in the list

        // Default to the first one if creating a new resource.
        if (BWizard())
        {
            if (m_lnetobjNetworks.GetCount() != 0)
            {
                pos = m_lnetobjNetworks.GetHeadPosition();
                pno = m_lnetobjNetworks.GetNext(pos);
                ASSERT(pno != NULL);
                m_strNetwork = pno->m_strName;
            }  // if:  list is not empty
        }  // if:  creating new resource

        // Set the current selection.
        UpdateData(FALSE /*bSaveAndValidate*/);
    }  // Fill the combobox

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CIpAddrParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE notification message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::OnSetActive(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if ((m_strIPAddress.GetLength() == 0)
                || (m_strSubnetMask.GetLength() == 0)
                || (m_strNetwork.GetLength() == 0))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CIpAddrParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeRequiredFields
//
//  Routine Description:
//      Handler for the EN_CHANGE message on required fields.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeRequiredFields(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if ((m_editIPAddress.GetWindowTextLength() == 0)
                || (m_editSubnetMask.GetWindowTextLength() == 0)
                || (m_cboxNetworks.GetCurSel() == CB_ERR))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  in a wizard

}  //*** CIpAddrParamsPage::OnChangeRequiredFields()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeSubnetMask
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Subnet Mask field.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeSubnetMask(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeRequiredFields();
    m_bIsSubnetUpdatedManually = TRUE;

}  //*** CIpAddrParamsPage::OnChangeSubnetMask()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnChangeIPAddress
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the IP Address field.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnChangeIPAddress(void) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeRequiredFields();
    m_bIsIPAddressModified = TRUE;

}  //*** CIpAddrParamsPage::OnChangeIPAddress
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::OnKillFocusIPAddress
//
//  Routine Description:
//      Handler for the EN_KILLFOCUS command notification on
//      IDC_PP_IPADDR_PARAMS_ADDRESS.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::OnKillFocusIPAddress(void)
{
    if ( m_bIsIPAddressModified != FALSE )
    {
        CString             strAddress;
        CNetworkObject *    pno;

        m_editIPAddress.GetWindowText(strAddress);

        if (strAddress.GetLength() == 0)
        {
            m_editIPAddress.SetSel(0, 0, FALSE);
        } // if:  empty string
        else if (!BIsValidIpAddress(strAddress))
        {
        } // else if:  invalid address
        else
        {
            pno = PnoNetworkFromIpAddress(strAddress);
            if (pno != NULL)
            {
                SelectNetwork(pno);
            } // if:  network found
            else
            {
    //          m_editSubnetMask.SetWindowText(_T(""));
            } // else:  network not found
        } // else:  valid address

        m_bIsIPAddressModified = FALSE;
    } // if:  the IP Address field has been modified

} //*** CIpAddrParamsPage::OnKillFocusIPAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::CollectNetworks
//
//  Routine Description:
//      Collect the networks in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::CollectNetworks(void)
{
    DWORD                   dwStatus;
    DWORD                   inet;
    CLUSTER_NETWORK_ROLE    nRole;
    DWORD                   nType;
    DWORD                   cchNameCurrent;
    DWORD                   cchName = 256;
    LPWSTR                  pszName = NULL;
    LPWSTR                  psz;
    HCLUSENUM               hclusenum = NULL;
    HNETWORK                hnetwork = NULL;
    CClusPropList           cpl;
    CNetworkObject *        pno = NULL;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Clear the existing list.
    ClearNetworkObjectList();

    try
    {
        // Open an enumerator.
        hclusenum = ClusterOpenEnum(Hcluster(), CLUSTER_ENUM_NETWORK);
        if (hclusenum != NULL)
        {
            // Allocate a name buffer.
            pszName = new WCHAR[cchName];
            if ( pszName == NULL )
                goto Cleanup;

            for (inet = 0 ; ; inet++)
            {
                // Get the next network name.
                cchNameCurrent = cchName;
                dwStatus = ClusterEnum(hclusenum, inet, &nType, pszName, &cchNameCurrent);
                if (dwStatus == ERROR_MORE_DATA)
                {
                    delete [] pszName;
                    cchName = ++cchNameCurrent;
                    pszName = new WCHAR[cchNameCurrent];
                    if ( pszName == NULL )
                        goto Cleanup;
                    dwStatus = ClusterEnum(hclusenum, inet, &nType, pszName, &cchNameCurrent);
                }  // if:  buffer is too small
                if (dwStatus == ERROR_NO_MORE_ITEMS)
                    break;

                // Open the network.
                if (hnetwork != NULL)
                    CloseClusterNetwork(hnetwork);
                hnetwork = OpenClusterNetwork(Hcluster(), pszName);
                if (hnetwork == NULL)
                    continue;

                // Get properties on the network.
                dwStatus = cpl.ScGetNetworkProperties(hnetwork, CLUSCTL_NETWORK_GET_COMMON_PROPERTIES);
                if (dwStatus != ERROR_SUCCESS)
                    continue;

                // Find the Role property.
                dwStatus = ResUtilFindDwordProperty(
                                        cpl.PbPropList(),
                                        static_cast< DWORD >( cpl.CbPropList() ),
                                        CLUSREG_NAME_NET_ROLE,
                                        (DWORD *) &nRole
                                        );
                if (dwStatus != ERROR_SUCCESS)
                    continue;

                // If this network is used for client access, add it to the list.
                if (nRole & ClusterNetworkRoleClientAccess)
                {
                    // Allocate a network object and store common properties.
                    pno = new CNetworkObject;
                    if ( pno == NULL )
                        goto Cleanup;
                    pno->m_strName = pszName;
                    pno->m_nRole = nRole;

                    // Get read-only common properties.
                    dwStatus = cpl.ScGetNetworkProperties(hnetwork, CLUSCTL_NETWORK_GET_RO_COMMON_PROPERTIES);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting read-only common properties

                    // Get the address property.
                    dwStatus = ResUtilFindSzProperty(
                                            cpl.PbPropList(),
                                            static_cast< DWORD >( cpl.CbPropList() ),
                                            CLUSREG_NAME_NET_ADDRESS,
                                            &psz
                                            );
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property
                    pno->m_strAddress = psz;

                    // Get the address mask property.
                    dwStatus = ResUtilFindSzProperty(
                                            cpl.PbPropList(),
                                            static_cast< DWORD >( cpl.CbPropList() ),
                                            CLUSREG_NAME_NET_ADDRESS_MASK,
                                            &psz
                                            );
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property
                    pno->m_strAddressMask = psz;

                    // Convert the strings to numbers.
                    dwStatus = ClRtlTcpipStringToAddress(pno->m_strAddress, &pno->m_nAddress);
                    if (dwStatus == ERROR_SUCCESS)
                        dwStatus = ClRtlTcpipStringToAddress(pno->m_strAddressMask, &pno->m_nAddressMask);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        delete pno;
                        pno = NULL;
                        continue;
                    }  // if:  error getting property

                    // Add the network to the list.
                    m_lnetobjNetworks.AddTail(pno);
                    pno = NULL;
                }  // if:  network is used for client access
            }  // for:  each network
        }  // if:  enumerator opened successful
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

Cleanup:
    delete pno;
    delete [] pszName;
    if (hclusenum != NULL)
        ClusterCloseEnum(hclusenum);
    if (hnetwork != NULL)
        CloseClusterNetwork(hnetwork);

}  //*** CIpAddrParamsPage::CollectNetworks()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::ClearNetworkObjectList
//
//  Routine Description:
//      Remove all the entries in the network object list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::ClearNetworkObjectList(void)
{
    POSITION            pos;
    CNetworkObject *    pno;

    pos = m_lnetobjNetworks.GetHeadPosition();
    while (pos != NULL)
    {
        pno = m_lnetobjNetworks.GetNext(pos);
        ASSERT(pno != NULL);
        delete pno;
    }  // while:  more items in the list

    m_lnetobjNetworks.RemoveAll();

}  //*** CIpAddrParamsPage::ClearNetworkObjectList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::PnoNetworkFromIpAddress
//
//  Routine Description:
//      Find the network for the specified IP address.
//
//  Arguments:
//      pszAddress      [IN] IP address to match.
//
//  Return Value:
//      NULL            No matching network found.
//      pno             Network that supports the specfied IP address.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetworkObject * CIpAddrParamsPage::PnoNetworkFromIpAddress(IN LPCWSTR pszAddress)
{
    DWORD               dwStatus;
    DWORD               nAddress;
    POSITION            pos;
    CNetworkObject *    pno;

    // Convert the address to a number.
    dwStatus = ClRtlTcpipStringToAddress(pszAddress, &nAddress);
    if (dwStatus != ERROR_SUCCESS)
        return NULL;

    // Search the list for a matching address.
    pos = m_lnetobjNetworks.GetHeadPosition();
    while (pos != NULL)
    {
        pno = m_lnetobjNetworks.GetNext(pos);
        ASSERT(pno != NULL);

        if (ClRtlAreTcpipAddressesOnSameSubnet(nAddress, pno->m_nAddress, pno->m_nAddressMask))
            return pno;
    }  // while:  more items in the list

    return NULL;

}  //*** CIpAddrParamsPage::PnoNetworkFromIpAddress()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::SelectNetwork
//
//  Routine Description:
//      Select the specified network in the network combobox, and set the
//      subnet mask in the subnet mask edit control.
//
//  Arguments:
//      pno         [IN] Network object structure for network to select.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CIpAddrParamsPage::SelectNetwork(IN CNetworkObject * pno)
{
    int     inet;
    CString strSubnetMask;

    ASSERT(pno != NULL);

    // Find the proper item in the checkbox.
    inet = m_cboxNetworks.FindStringExact(-1, pno->m_strName);
    if (inet != CB_ERR)
    {
        m_cboxNetworks.SetCurSel(inet);
        m_editSubnetMask.GetWindowText(strSubnetMask);
        if (strSubnetMask != pno->m_strAddressMask)
            m_editSubnetMask.SetWindowText(pno->m_strAddressMask);
        m_bIsSubnetUpdatedManually = FALSE;
        m_strSubnetMask = pno->m_strAddressMask;
        m_strNetwork = pno->m_strName;
    }  // if:  match found

}  //*** CIpAddrParamsPage::SelectNetwork()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CIpAddrParamsPage::BIsNetNameProvider
//
//  Routine Description:
//      Determine if a network name resource is dependent on this resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CIpAddrParamsPage::BIsNetNameProvider(void)
{
    DWORD                       dwStatus = ERROR_SUCCESS;
    BOOL                        bIsNetNameProvider = FALSE;
    HRESENUM                    hresenum;
    HRESOURCE                   hres = NULL;
    DWORD                       ires;
    DWORD                       dwType;
    DWORD                       cchName;
    DWORD                       cchNameSize;
    DWORD                       cbResType;
    DWORD                       cbResTypeSize;
    LPWSTR                      pszName = NULL;
    LPWSTR                      pszResType = NULL;

    // Open the provides-for enumerator.
    hresenum = ClusterResourceOpenEnum(
                        Peo()->PrdResData()->m_hresource,
                        CLUSTER_RESOURCE_ENUM_PROVIDES
                        );
    if (hresenum == NULL)
        return NULL;

    // Allocate a default size name and type buffer.
    cchNameSize = 512;
    pszName = new WCHAR[cchNameSize];
    if ( pszName == NULL )
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }
    cbResTypeSize = 256;
    pszResType = new WCHAR[cbResTypeSize / 2];
    if ( pszResType == NULL )
    {
        dwStatus = ERROR_OUTOFMEMORY;
        goto Cleanup;
    }

    for (ires = 0 ; ; ires++)
    {
        // Get the name of the next resource.
        cchName = cchNameSize;
        dwStatus = ClusterResourceEnum(
                            hresenum,
                            ires,
                            &dwType,
                            pszName,
                            &cchName
                            );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pszName;
            cchNameSize = cchName;
            pszName = new WCHAR[cchNameSize];
            if ( pszName == NULL )
            {
                dwStatus = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            dwStatus = ClusterResourceEnum(
                                hresenum,
                                ires,
                                &dwType,
                                pszName,
                                &cchName
                                );
        }  // if:  name buffer too small
        if (dwStatus != ERROR_SUCCESS)
            break;

        // Open the resource.
        hres = OpenClusterResource(Hcluster(), pszName);
        if (hres == NULL)
        {
            dwStatus = GetLastError();
            break;
        }  // if:  error opening the resource

        // Get the type of the resource.
        dwStatus = ClusterResourceControl(
                            hres,
                            NULL,
                            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                            NULL,
                            0,
                            pszResType,
                            cbResTypeSize,
                            &cbResType
                            );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pszResType;
            cbResTypeSize = cbResType;
            pszResType = new WCHAR[cbResTypeSize / 2];
            if ( pszResType == NULL )
            {
                dwStatus = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
            dwStatus = ClusterResourceControl(
                                hres,
                                NULL,
                                CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                                NULL,
                                0,
                                pszResType,
                                cbResTypeSize,
                                &cbResType
                                );
        }  // if:  resource type buffer too small
        if (dwStatus != ERROR_SUCCESS)
            break;

        // If this is a Network Name resource, we're done.
        if ( ClRtlStrNICmp( pszResType, CLUS_RESTYPE_NAME_NETNAME, RTL_NUMBER_OF( CLUS_RESTYPE_NAME_NETNAME ) ) == 0 )
        {
            bIsNetNameProvider = TRUE;
            break;
        }  // if:  resource is a Network Name

        // Not storage-class resource.
        CloseClusterResource(hres);
        hres = NULL;
    }  // for each resource on which we are dependent

Cleanup:
    // Handle errors.
    if ( hres != NULL )
    {
        CloseClusterResource(hres);
        hres = NULL;
    }  // if:  error getting resource

    ClusterResourceCloseEnum(hresenum);
    delete [] pszName;
    delete [] pszResType;

    return bIsNetNameProvider;

}  //*** CIpAddrParamsPage::BIsNetNameProvider()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\prtspool.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      PrtSpool.h
//
//  Abstract:
//      Definition of the CPrintSpoolerParamsPage class, which implements the
//      Parameters page for Print Spooler resources.
//
//  Implementation File:
//      PrtSpool.cpp
//
//  Author:
//      David Potter (davidp)   October 17, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _PRTSPOOL_H_
#define _PRTSPOOL_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CPrintSpoolerParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPrintSpoolerParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CPrintSpoolerParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CPrintSpoolerParamsPage)

// Construction
public:
    CPrintSpoolerParamsPage(void);

    // Second phase construction.
    virtual HRESULT     HrInit(IN OUT CExtObject * peo);

// Dialog Data
    //{{AFX_DATA(CPrintSpoolerParamsPage)
    enum { IDD = IDD_PP_PRTSPOOL_PARAMETERS };
    CEdit   m_editSpoolDir;
    CString m_strSpoolDir;
    DWORD   m_nJobCompletionTimeout;
    //}}AFX_DATA
    CString m_strPrevSpoolDir;
    DWORD   m_nPrevJobCompletionTimeout;

protected:
    enum
    {
        epropSpoolDir,
        epropTimeout,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPrintSpoolerParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual BOOL        BApplyChanges(void);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPrintSpoolerParamsPage)
    afx_msg void OnChangeSpoolDir();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CPrintSpoolerParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _PRTSPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\netname.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      NetName.h
//
//  Abstract:
//      Definition of the CNetworkNameParamsPage class, which implements the
//      Parameters page for Network Name resources.
//
//  Implementation File:
//      NetName.cpp
//
//  Author:
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _NETNAME_H_
#define _NETNAME_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CNetworkNameParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CNetworkNameParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CNetworkNameParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CNetworkNameParamsPage)

// Construction
public:
    CNetworkNameParamsPage(void);

    // Second phase construction.
    virtual HRESULT     HrInit(IN OUT CExtObject * peo);

// Dialog Data
    //{{AFX_DATA(CNetworkNameParamsPage)
    enum { IDD = IDD_PP_NETNAME_PARAMETERS };
    CStatic m_staticName;
    CButton m_pbRename;
    CStatic m_staticCore;
    CEdit   m_editName;
    CString m_strName;

    CButton m_cbRequireDNS;
    int     m_nRequireDNS;

    CButton m_cbRequireKerberos;
    int     m_nRequireKerberos;
    
    CEdit   m_editNetBIOSStatus;
    DWORD   m_dwNetBIOSStatus;
    
    CEdit   m_editDNSStatus;
    DWORD   m_dwDNSStatus;

    CEdit   m_editKerberosStatus;
    DWORD   m_dwKerberosStatus;
    
    //}}AFX_DATA

    CString m_strPrevName;
    int     m_nPrevRequireDNS;
    int     m_nPrevRequireKerberos;
    DWORD   m_dwPrevNetBIOSStatus;
    DWORD   m_dwPrevDNSStatus;
    DWORD   m_dwPrevKerberosStatus;

protected:
    enum
    {
        epropName = 0,
        epropRequireDNS,
        epropRequireKerberos,
        epropStatusNetBIOS,
        epropStatusDNS,
        epropStatusKerberos,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CNetworkNameParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    virtual BOOL        BApplyChanges(void);

protected:
    virtual const   CObjectProperty *   Pprops(void) const  { return m_rgProps; }
    virtual DWORD   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }

    virtual void CheckForDownlevelCluster();
// Implementation
protected:
    DWORD   m_dwFlags;

    BOOL    BCore(void) const   { return (m_dwFlags & CLUS_FLAG_CORE) != 0; }

    // Generated message map functions
    //{{AFX_MSG(CNetworkNameParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeName();
    afx_msg void OnRename();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CNetworkNameParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _NETNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\ipaddr.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		IpAddr.h
//
//	Abstract:
//		Definition of the CIpAddrParamsPage class, which implements the
//		Parameters page for IP Address resources.
//
//	Implementation File:
//		IpAddr.cpp
//
//	Author:
//		David Potter (davidp)	June 28, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _IPADDR_H_
#define _IPADDR_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CNetworkObject;
class CIpAddrEdit;
class CIpAddrParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CNetworkObject
/////////////////////////////////////////////////////////////////////////////

struct CNetworkObject
{
	CString					m_strName;
	CLUSTER_NETWORK_ROLE	m_nRole;
	CString					m_strAddress;
	CString					m_strAddressMask;

	DWORD					m_nAddress;
	DWORD					m_nAddressMask;

};  //*** struct CNetworkObject

typedef CList< CNetworkObject*, CNetworkObject* > CNetObjectList;


/////////////////////////////////////////////////////////////////////////////
// class CIpAddrParamsPage
/////////////////////////////////////////////////////////////////////////////

class CIpAddrParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CIpAddrParamsPage)

// Construction
public:
	CIpAddrParamsPage(void);
	~CIpAddrParamsPage(void);

	// Second phase construction.
	virtual HRESULT		HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CIpAddrParamsPage)
	enum { IDD = IDD_PP_IPADDR_PARAMETERS };
	CButton	m_chkEnableNetBIOS;
	CComboBox	m_cboxNetworks;
	CEdit	m_editSubnetMask;
	CEdit	m_editIPAddress;
	CString	m_strIPAddress;
	CString	m_strSubnetMask;
	CString	m_strNetwork;
	BOOL	m_bEnableNetBIOS;
	//}}AFX_DATA
	CString	m_strPrevIPAddress;
	CString	m_strPrevSubnetMask;
	CString	m_strPrevNetwork;
	BOOL	m_bPrevEnableNetBIOS;
	CNetObjectList	m_lnetobjNetworks;

	CNetworkObject *	PnoNetworkFromIpAddress(IN LPCWSTR pszAddress);
	void				SelectNetwork(IN CNetworkObject * pno);

	BOOL				m_bIsSubnetUpdatedManually;
	BOOL				BIsSubnetUpdatedManually(void) const	{ return m_bIsSubnetUpdatedManually; }

	BOOL				m_bIsIPAddressModified;
	BOOL				BIsIPAddressModified(void) const	{ return m_bIsIPAddressModified; }

protected:
	enum
	{
		epropNetwork,
		epropAddress,
		epropSubnetMask,
		epropEnableNetBIOS,
		epropMAX
	};

	CObjectProperty		m_rgProps[epropMAX];

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CIpAddrParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	virtual const CObjectProperty *	Pprops(void) const	{ return m_rgProps; }
	virtual DWORD					Cprops(void) const	{ return sizeof(m_rgProps) / sizeof(CObjectProperty); }

// Implementation
protected:
	void				CollectNetworks(void);
	void				ClearNetworkObjectList(void);
	BOOL				BIsNetNameProvider(void);

	// Generated message map functions
	//{{AFX_MSG(CIpAddrParamsPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeSubnetMask();
	afx_msg void OnKillFocusIPAddress();
	afx_msg void OnChangeRequiredFields();
	afx_msg void OnChangeIPAddress();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CIpAddrParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _IPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\regexts.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegExtS.cpp
//
//	Abstract:
//		Stub for implementation of extension registration classes.
//
//	Author:
//		David Potter (davidp)	May 16, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegExt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\regkey.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegKey.h
//
//	Abstract:
//		Definition of the CEditRegKeyDlg class, which implements a dialog
//		allowing the user to enter or modify a registry key.
//
//	Implementation File:
//		RegKey.cpp
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGKEY_H_
#define _REGKEY_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#include "BaseDlg.h"	// for CBaseDialog
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CEditRegKeyDlg;

/////////////////////////////////////////////////////////////////////////////
// CEditRegKeyDlg dialog
/////////////////////////////////////////////////////////////////////////////

class CEditRegKeyDlg : public CBaseDialog
{
// Construction
public:
	CEditRegKeyDlg(CWnd * pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditRegKeyDlg)
	enum { IDD = IDD_EDIT_REGKEY };
	CButton	m_pbOK;
	CEdit	m_editRegKey;
	CString	m_strRegKey;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditRegKeyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditRegKeyDlg)
	afx_msg void OnChangeRegKey();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CEditRegKeyDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\regkey.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		RegKey.cpp
//
//	Abstract:
//		Implementation of the CEditRegKeyDlg class.
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "RegKey.h"
#include "HelpData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditRegKeyDlg dialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CEditRegKeyDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CEditRegKeyDlg)
	ON_EN_CHANGE(IDC_REGKEY, OnChangeRegKey)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::CEditRegKeyDlg
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParent			[IN] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CEditRegKeyDlg::CEditRegKeyDlg(CWnd * pParent /*=NULL*/)
	: CBaseDialog(IDD, g_aHelpIDs_IDD_EDIT_REGKEY, pParent)
{
	//{{AFX_DATA_INIT(CEditRegKeyDlg)
	m_strRegKey = _T("");
	//}}AFX_DATA_INIT

}  //*** CEditRegKeyDlg::CEditRegKeyDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEditRegKeyDlg::DoDataExchange(CDataExchange * pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditRegKeyDlg)
	DDX_Control(pDX, IDOK, m_pbOK);
	DDX_Control(pDX, IDC_REGKEY, m_editRegKey);
	DDX_Text(pDX, IDC_REGKEY, m_strRegKey);
	//}}AFX_DATA_MAP

}  //*** CEditRegKeyDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CEditRegKeyDlg::OnInitDialog(void)
{
	CBaseDialog::OnInitDialog();

	if (m_strRegKey.GetLength() == 0)
		m_pbOK.EnableWindow(FALSE);

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CEditRegKeyDlg::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CEditRegKeyDlg::OnChangeRegKey
//
//	Routine Description:
//		Handler for the EN_CHANGE message on the Name edit control.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CEditRegKeyDlg::OnChangeRegKey(void)
{
	BOOL	bEnable;

	bEnable = (m_editRegKey.GetWindowTextLength() > 0);
	m_pbOK.EnableWindow(bEnable);

}  //*** CEditRegKeyDlg::OnChangeRegKey()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\regrepl.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      RegRepl.cpp
//
//  Abstract:
//      Implementation of the CRegReplParamsPage class.
//
//  Author:
//      David Potter (davidp)   February 23, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmX.h"
#include "RegRepl.h"
#include "RegKey.h"
#include "ExtObj.h"
#include "HelpData.h"   // for g_rghelpmap*

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegReplParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CRegReplParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CRegReplParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CRegReplParamsPage)
    ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_ADD, OnAdd)
    ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_MODIFY, OnModify)
    ON_BN_CLICKED(IDC_PP_REGREPL_PARAMS_REMOVE, OnRemove)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_PP_REGREPL_PARAMS_LIST, OnItemChanged)
    ON_NOTIFY(NM_DBLCLK, IDC_PP_REGREPL_PARAMS_LIST, OnDblClkList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::CRegReplParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRegReplParamsPage::CRegReplParamsPage(void)
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_REGREPL_PARAMETERS, g_aHelpIDs_IDD_WIZ_REGREPL_PARAMETERS)
{
    //{{AFX_DATA_INIT(CRegReplParamsPage)
    //}}AFX_DATA_INIT

    m_pwszRegKeys = NULL;

    m_iddPropertyPage = IDD_PP_REGREPL_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_REGREPL_PARAMETERS;

}  //*** CRegReplParamsPage::CRegReplParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::~CRegReplParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CRegReplParamsPage::~CRegReplParamsPage(void)
{
    delete [] m_pwszRegKeys;

}  //*** CRegReplParamsPage::~CRegReplParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::HrInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      peo         [IN OUT] Pointer to the extension object.
//                      property sheet.
//
//  Return Value:
//      S_OK        Page initialized successfully.
//      hr          Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CRegReplParamsPage::HrInit(IN OUT CExtObject * peo)
{
    HRESULT     _hr = S_OK;
    DWORD       _sc;
    CWaitCursor _wc;

    // Call the base class method.
    _hr = CBasePropertyPage::HrInit(peo);
    if (FAILED(_hr))
    {
        goto Cleanup;
    }

    ASSERT(m_pwszRegKeys == NULL);

    // Read the list of registry keys to replicate.
    _sc = ScReadRegKeys();
    if (_sc != ERROR_SUCCESS)
    {
        CString     strPrompt;
        CString     strError;
        CString     strMsg;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        strPrompt.LoadString(IDS_ERROR_READING_REGKEYS);
        FormatError(strError, _sc);
        strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
        AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
    }  // if:  error eading registry keys

Cleanup:

    return _hr;

}  //*** CRegReplParamsPage::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::DoDataExchange(CDataExchange* pDX)
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        //{{AFX_DATA_MAP(CRegReplParamsPage)
        DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_REMOVE, m_pbRemove);
        DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_MODIFY, m_pbModify);
        DDX_Control(pDX, IDC_PP_REGREPL_PARAMS_LIST, m_lcRegKeys);
        //}}AFX_DATA_MAP
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CRegReplParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    // Add the column.
    {
        CString     strColumn;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        strColumn.LoadString(IDS_COLTEXT_REGKEY);
        m_lcRegKeys.InsertColumn(0, strColumn, LVCFMT_LEFT, 300);
    }  // Add the column

    // Display the list of registry keys.
    FillList();

    // Enable/disable the Modify and Remove buttons.
    {
        UINT    cSelected = m_lcRegKeys.GetSelectedCount();

        // If there is an item selected, enable the Modify and Remove buttons.
        m_pbModify.EnableWindow((cSelected > 0) ? TRUE : FALSE);
        m_pbRemove.EnableWindow((cSelected > 0) ? TRUE : FALSE);
    }  // Enable/disable the Modify and Remove buttons

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CRegReplParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::OnSetActive(void)
{
    if (BWizard())
    {
        EnableNext(TRUE);
    }

    return CBasePropertyPage::OnSetActive();

}  //*** CRegReplParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRegReplParamsPage::BApplyChanges(void)
{
    DWORD       dwStatus    = ERROR_SUCCESS;
    CWaitCursor wc;

    // Add new items.
    {
        int     iitem;
        CString strItem;
        LPCWSTR pwszRegKeys;
        DWORD   cbReturned;

        for ( iitem = -1
                ; (iitem = m_lcRegKeys.GetNextItem(iitem, LVNI_ALL)) != -1
                ; )
        {
            strItem = m_lcRegKeys.GetItemText(iitem, 0);
            pwszRegKeys = PwszRegKeys();
            while (*pwszRegKeys != L'\0')
            {
                if (strItem.CompareNoCase(pwszRegKeys) == 0)
                    break;
                pwszRegKeys += wcslen(pwszRegKeys) + 1;
            }  // while:  more items in the list

            if (*pwszRegKeys == L'\0')
            {
                dwStatus = ClusterResourceControl(
                                Peo()->PrdResData()->m_hresource,
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT,
                                (PVOID) (LPCWSTR) strItem,
                                (strItem.GetLength() + 1) * sizeof(WCHAR),
                                NULL,   // OutBuffer
                                0,      // OutBufferSize
                                &cbReturned // BytesReturned
                                );
                if ((dwStatus != ERROR_SUCCESS) && (dwStatus != ERROR_ALREADY_EXISTS))
                {
                    CString     strPrompt;
                    CString     strError;
                    CString     strMsg;

                    {
                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                        strPrompt.FormatMessage(IDS_ERROR_ADDING_REGKEY, strItem);
                    }

                    FormatError(strError, dwStatus);
                    strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    return FALSE;
                }  // if:  error adding the item
            }  // if:  found a new one
        }  // for:  each item in the list
    }  // Add new items

    // Remove deleted items.
    {
        int         iitem;
        CString     strItem;
        LPCWSTR     pwszRegKeys = PwszRegKeys();
        DWORD       cbReturned;

        while (*pwszRegKeys != L'\0')
        {
            for ( iitem = -1
                    ; (iitem = m_lcRegKeys.GetNextItem(iitem, LVNI_ALL)) != -1
                    ; )
            {
                strItem = m_lcRegKeys.GetItemText(iitem, 0);
                if (strItem.CompareNoCase(pwszRegKeys) == 0)
                    break;
            }  // for:  all items in the list

            if (iitem == -1)
            {
                dwStatus = ClusterResourceControl(
                                Peo()->PrdResData()->m_hresource,
                                NULL,   // hNode
                                CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
                                (PVOID) pwszRegKeys,
                                static_cast< DWORD >( (wcslen(pwszRegKeys) + 1) * sizeof(WCHAR) ),
                                NULL,   // OutBuffer
                                0,      // OutBufferSize
                                &cbReturned // BytesReturned
                                );
                if (dwStatus != ERROR_SUCCESS)
                {
                    CString     strPrompt;
                    CString     strError;
                    CString     strMsg;

                    {
                        AFX_MANAGE_STATE(AfxGetStaticModuleState());
                        strPrompt.FormatMessage(IDS_ERROR_DELETING_REGKEY, strItem);
                    }

                    FormatError(strError, dwStatus);
                    strMsg.Format(_T("%s\n\n%s"), strPrompt, strError);
                    AfxMessageBox(strMsg, MB_OK | MB_ICONEXCLAMATION);
                    return FALSE;
                }  // if:  error adding the item
            }  // if:  key was deleted

            pwszRegKeys += wcslen(pwszRegKeys) + 1;
        }  // while:  more strings
    }  // Remove deleted items

    // Re-read the keys.
    ScReadRegKeys();
    FillList();

    return CBasePropertyPage::BApplyChanges();

}  //*** CRegReplParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnAdd
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Add button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnAdd(void)
{
    INT_PTR         idReturn;
    CEditRegKeyDlg  dlg(this);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    idReturn = dlg.DoModal();
    if (idReturn == IDOK)
    {
        m_lcRegKeys.InsertItem(m_lcRegKeys.GetItemCount(), dlg.m_strRegKey);
        m_lcRegKeys.SetFocus();
        SetModified(TRUE);
    }  // if:  user accepted the dialog

}  //*** CRegReplParamsPage::OnAdd()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnModify
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Modify button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnModify(void)
{
    int             iSelectedItem;
    INT_PTR         idReturn;
    CEditRegKeyDlg  dlg(this);

    // Set the text in the dialog to the text of the selected item.
    iSelectedItem = m_lcRegKeys.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(iSelectedItem != -1);
    dlg.m_strRegKey = m_lcRegKeys.GetItemText(iSelectedItem, 0);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Display the dialog.
    idReturn = dlg.DoModal();
    if (idReturn == IDOK)
    {
        m_lcRegKeys.SetItemText(iSelectedItem, 0, dlg.m_strRegKey);
        m_lcRegKeys.SetFocus();
        SetModified(TRUE);
    }  // if:  user accepted the dialog

}  //*** CRegReplParamsPage::OnModify()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnRemove
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Remove button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnRemove(void)
{
    int             iSelectedItem;

    iSelectedItem = m_lcRegKeys.GetNextItem(-1, LVNI_SELECTED);
    ASSERT(iSelectedItem != -1);
    m_lcRegKeys.DeleteItem(iSelectedItem);
    SetModified(TRUE);

}  //*** CRegReplParamsPage::OnRemove()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnItemChanged
//
//  Routine Description:
//      Handler for the LVN_ITEM_CHANGED message on the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the selection changed, enable/disable the Properties button.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                    || (pNMListView->uNewState & LVIS_SELECTED)))
    {
        UINT    cSelected = m_lcRegKeys.GetSelectedCount();

        // If there is an item selected, enable the Modify and Remove buttons.
        m_pbModify.EnableWindow((cSelected > 0) ? TRUE : FALSE);
        m_pbRemove.EnableWindow((cSelected > 0) ? TRUE : FALSE);
    }  // if:  selection changed

    *pResult = 0;

}  //*** CRegReplParamsPage::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::OnDblClkList
//
//  Routine Description:
//      Handler for the NM_DBLCLK message on the list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::OnDblClkList(NMHDR * pNMHDR, LRESULT * pResult)
{
    OnModify();
    *pResult = 0;

}  //*** CRegReplParamsPage::OnDblClkList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::ScReadRegKeys
//
//  Routine Description:
//      Read the registry keys.
//
//  Arguments:
//      None.
//
//  Return Value:
//      ERROR_SUCCESS   Registry keys read successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CRegReplParamsPage::ScReadRegKeys(void)
{
    DWORD               dwStatus        = ERROR_SUCCESS;
    DWORD               cbRegKeys       = 256;
    LPWSTR              pwszRegKeys     = NULL;
    CWaitCursor         wc;
    CMemoryException    me(FALSE /*bAutoDelete*/, 0 /*nResourceID*/);

    // Read the list of registry keys to replicate.
    try
    {
        // Get registry keys.
        pwszRegKeys = new WCHAR[cbRegKeys / sizeof(WCHAR)];
        if (pwszRegKeys == NULL)
        {
            throw &me;
        } // if: error allocating key name buffer
        dwStatus = ClusterResourceControl(
                        Peo()->PrdResData()->m_hresource,
                        NULL,   // hNode
                        CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
                        NULL,   // lpInBuffer
                        0,      // nInBufferSize
                        pwszRegKeys,
                        cbRegKeys,
                        &cbRegKeys
                        );
        if (dwStatus == ERROR_MORE_DATA)
        {
            delete [] pwszRegKeys;
            ASSERT(cbRegKeys == (cbRegKeys / sizeof(WCHAR)) * sizeof(WCHAR));
            pwszRegKeys = new WCHAR[cbRegKeys / sizeof(WCHAR)];
            if (pwszRegKeys == NULL)
            {
                throw &me;
            } // if: error allocating key name buffer
            dwStatus = ClusterResourceControl(
                            Peo()->PrdResData()->m_hresource,
                            NULL,   // hNode
                            CLUSCTL_RESOURCE_GET_REGISTRY_CHECKPOINTS,
                            NULL,   // lpInBuffer
                            0,      // nInBufferSize
                            pwszRegKeys,
                            cbRegKeys,
                            &cbRegKeys
                            );
        }  // if:  buffer too small
    }  // try
    catch (CMemoryException * pme)
    {
        pme->ReportError();
        pme->Delete();
        return ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if ((dwStatus != ERROR_SUCCESS) || (cbRegKeys == 0))
    {
        *pwszRegKeys = L'\0';
    }

    delete [] m_pwszRegKeys;
    m_pwszRegKeys = pwszRegKeys;

    return dwStatus;

}  //*** CRegReplParamsPage::ScReadRegKeys()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRegReplParamsPage::FillList
//
//  Routine Description:
//      Fill the list control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRegReplParamsPage::FillList(void)
{
    m_lcRegKeys.DeleteAllItems();

    if (PwszRegKeys() != NULL)
    {
        int     iitem;
        int     iitemRet;
        LPCWSTR pwszRegKeys = PwszRegKeys();

        for (iitem = 0 ; *pwszRegKeys != L'\0' ; iitem++)
        {
            iitemRet = m_lcRegKeys.InsertItem(iitem, pwszRegKeys);
            ASSERT(iitemRet == iitem);
            pwszRegKeys += wcslen(pwszRegKeys) + 1;
        }  // while:  more strings in the list
    }  // if:  there are any keys to display

}  //*** CRegReplParamsPage::FillList()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbshare.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      SmbShare.cpp
//
//  Abstract:
//      Implementation of the CFileShareParamsPage classes.
//
//  Author:
//      David Potter (davidp)   June 28, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <lmcons.h>
#include <lmaccess.h>
#include <clusudef.h>
#include "CluAdmX.h"
#include "ExtObj.h"
#include "SmbShare.h"
#include "DDxDDv.h"
#include "PropList.h"
#include "HelpData.h"
#include "FSAdv.h"
#include "FSCache.h"
#include "ExcOper.h"
#include <sddl.h>

#include "SmbSSht.h"
#include "AclUtils.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareParamsPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFileShareParamsPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareParamsPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CFileShareParamsPage)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_SHARE_NAME, OnChangeRequiredField)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_PATH, OnChangeRequiredField)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB, OnBnClickedMaxUsers)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_MAX_USERS_RB, OnBnClickedMaxUsers)
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_MAX_USERS, OnEnChangeMaxUsers)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_PERMISSIONS, OnBnClickedPermissions)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_ADVANCED, OnBnClickedAdvanced)
    ON_BN_CLICKED(IDC_PP_FILESHR_PARAMS_CACHING, OnBnClickedCaching)
    //}}AFX_MSG_MAP
    // TODO: Modify the following lines to represent the data displayed on this page.
    ON_EN_CHANGE(IDC_PP_FILESHR_PARAMS_REMARK, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::CFileShareParamsPage
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareParamsPage::CFileShareParamsPage( void )
    : CBasePropertyPage(g_aHelpIDs_IDD_PP_FILESHR_PARAMETERS, g_aHelpIDs_IDD_WIZ_FILESHR_PARAMETERS)
{
    // TODO: Modify the following lines to represent the data displayed on this page.
    //{{AFX_DATA_INIT(CFileShareParamsPage)
    m_strShareName = _T("");
    m_strPath = _T("");
    m_strRemark = _T("");
    //}}AFX_DATA_INIT

    m_psec      = NULL;
    m_psecNT4   = NULL;
    m_psecNT5   = NULL;
    m_psecPrev  = NULL;

    m_dwMaxUsers = (DWORD) -1;
    m_bShareSubDirs = FALSE;
    m_bPrevShareSubDirs = FALSE;
    m_bHideSubDirShares = FALSE;
    m_bPrevHideSubDirShares = FALSE;
    m_bIsDfsRoot = FALSE;
    m_bPrevIsDfsRoot = FALSE;

    // Setup the property array.
    {
        m_rgProps[epropShareName].Set(REGPARAM_FILESHR_SHARE_NAME, m_strShareName, m_strPrevShareName);
        m_rgProps[epropPath].Set(REGPARAM_FILESHR_PATH, m_strPath, m_strPrevPath);
        m_rgProps[epropRemark].Set(REGPARAM_FILESHR_REMARK, m_strRemark, m_strPrevRemark);
        m_rgProps[epropMaxUsers].Set(REGPARAM_FILESHR_MAX_USERS, m_dwMaxUsers, m_dwPrevMaxUsers);
        m_rgProps[epropShareSubDirs].Set(REGPARAM_FILESHR_SHARE_SUBDIRS, m_bShareSubDirs, m_bPrevShareSubDirs, CObjectProperty::opfNew);
        m_rgProps[epropHideSubDirShares].Set(REGPARAM_FILESHR_HIDE_SUBDIR_SHARES, m_bHideSubDirShares, m_bPrevHideSubDirShares, CObjectProperty::opfNew);
        m_rgProps[epropIsDfsRoot].Set(REGPARAM_FILESHR_IS_DFS_ROOT, m_bIsDfsRoot, m_bPrevIsDfsRoot, CObjectProperty::opfNew);
        m_rgProps[epropCSCCache].Set(REGPARAM_FILESHR_CSC_CACHE, m_dwCSCCache, m_dwPrevCSCCache, CObjectProperty::opfNew);
    }  // Setup the property array

    m_iddPropertyPage = IDD_PP_FILESHR_PARAMETERS;
    m_iddWizardPage = IDD_WIZ_FILESHR_PARAMETERS;

}  //*** CFileShareParamsPage::CFileShareParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::~CFileShareParamsPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareParamsPage::~CFileShareParamsPage(
    void
    )
{
    ::LocalFree(m_psec);
    ::LocalFree(m_psecNT4);
    ::LocalFree(m_psecNT5);
    ::LocalFree(m_psecPrev);

}  //*** CFileShareParamsPage::~CFileShareParamsPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::ScParseUnknownProperty
//
//  Routine Description:
//      Parse a property that is not in the array of automatically-parsed
//      properties.
//
//  Arguments:
//      pwszName        [IN] Name of the property.
//      rvalue          [IN] CLUSPROP property value.
//      cbBuf           [IN] Total size of the value buffer.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CFileShareParamsPage::ScParseUnknownProperty(
    IN LPCWSTR                          pwszName,
    IN const CLUSPROP_BUFFER_HELPER &   rvalue,
    IN DWORD                            cbBuf
    )
{
    ASSERT(pwszName != NULL);
    ASSERT(rvalue.pb != NULL);

    DWORD   sc = ERROR_SUCCESS;

    if ( ClRtlStrNICmp( pwszName, REGPARAM_FILESHR_SD, RTL_NUMBER_OF( REGPARAM_FILESHR_SD ) ) == 0 )
    {
        sc = ScConvertPropertyToSD(rvalue, cbBuf, &m_psecNT5);
    }  // if:  new security descriptor

    if (sc == ERROR_SUCCESS)
    {
        if ( ClRtlStrNICmp( pwszName, REGPARAM_FILESHR_SECURITY, RTL_NUMBER_OF( REGPARAM_FILESHR_SECURITY ) ) == 0 )
        {
            sc = ScConvertPropertyToSD(rvalue, cbBuf, &m_psecNT4);
        }  // if:  old security descriptor
    } // if:

    return sc;

}  //*** CFileShareParamsPage::ScParseUnknownProperty()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareParamsPage::DoDataExchange(
    CDataExchange * pDX
    )
{
    if (!pDX->m_bSaveAndValidate || !BSaved())
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // TODO: Modify the following lines to represent the data displayed on this page.
        //{{AFX_DATA_MAP(CFileShareParamsPage)
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_PERMISSIONS, m_pbPermissions);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_SPIN, m_spinMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_RB, m_rbMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB, m_rbMaxUsersAllowed);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_editMaxUsers);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_REMARK, m_editRemark);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_PATH, m_editPath);
        DDX_Control(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, m_editShareName);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, m_strShareName);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_PATH, m_strPath);
        DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_REMARK, m_strRemark);
        //}}AFX_DATA_MAP

#ifndef UDM_SETRANGE32
#define UDM_SETRANGE32 (WM_USER+111)
#endif
#ifndef UD_MAXVAL32
#define UD_MAXVAL32 0x7fffffff
#endif

        if (pDX->m_bSaveAndValidate)
        {
            if (!BBackPressed())
            {
                DDV_MaxChars(pDX, m_strShareName, NNLEN);
                DDV_MaxChars(pDX, m_strPath, MAX_PATH);
                DDV_MaxChars(pDX, m_strRemark, MAXCOMMENTSZ);
                DDV_RequiredText(pDX, IDC_PP_FILESHR_PARAMS_SHARE_NAME, IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL, m_strShareName);
                DDV_RequiredText(pDX, IDC_PP_FILESHR_PARAMS_PATH, IDC_PP_FILESHR_PARAMS_PATH_LABEL, m_strPath);
            }  // if:  Back button not pressed

            // Get the max # users.
            if (m_rbMaxUsersAllowed.GetCheck() == BST_CHECKED)
                m_dwMaxUsers = (DWORD) -1;
            else if (BBackPressed())
                DDX_Text(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers);
            else
#ifdef UD32
                DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL32, FALSE /*bSigned*/);
#else
                DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL, FALSE /*bSigned*/);
#endif
        }  // if:  saving data from dialog
        else
        {
#ifdef UD32
            DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL32, FALSE /*bSigned*/);
#else
            DDX_Number(pDX, IDC_PP_FILESHR_PARAMS_MAX_USERS, m_dwMaxUsers, 1, UD_MAXVAL, FALSE /*bSigned*/);
#endif
            if (m_dwMaxUsers == (DWORD) -1)
            {
                m_rbMaxUsersAllowed.SetCheck(BST_CHECKED);
                m_rbMaxUsers.SetCheck(BST_UNCHECKED);
                m_editMaxUsers.SetWindowText(_T(""));
            }  // if:  unlimited specified
            else
            {
                m_rbMaxUsersAllowed.SetCheck(BST_UNCHECKED);
                m_rbMaxUsers.SetCheck(BST_CHECKED);
            }  // else:  a maximum was specified

        }  // else:  setting data to dialog
    }  // if:  not saving or haven't saved yet

    CBasePropertyPage::DoDataExchange(pDX);

}  //*** CFileShareParamsPage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        We need the focus to be set for us.
//      FALSE       We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::OnInitDialog(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editShareName.SetLimitText(NNLEN);
    m_editPath.SetLimitText(MAX_PATH);
    m_editRemark.SetLimitText(MAXCOMMENTSZ);

    // Set the spin control limits.
#ifdef UD32
    m_spinMaxUsers.SendMessage(UDM_SETRANGE32, 1, UD_MAXVAL32);
#else
    m_spinMaxUsers.SetRange(1, UD_MAXVAL);
#endif

    m_pbPermissions.EnableWindow(TRUE);

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CFileShareParamsPage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::OnSetActive(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Enable/disable the Next/Finish button.
    if (BWizard())
    {
        if ((m_strShareName.GetLength() == 0) || (m_strPath.GetLength() == 0))
            EnableNext(FALSE);
        else
            EnableNext(TRUE);
    }  // if:  enable/disable the Next button

    return CBasePropertyPage::OnSetActive();

}  //*** CFileShareParamsPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::BApplyChanges
//
//  Routine Description:
//      Apply changes made on the page.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareParamsPage::BApplyChanges(
    void
    )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWaitCursor wc;

    return CBasePropertyPage::BApplyChanges();

}  //*** CFileShareParamsPage::BApplyChanges()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::BBuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//      bNoNewProps [IN] TRUE = exclude properties marked with opfNew.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CFileShareParamsPage::BBuildPropList(
    IN OUT CClusPropList &  rcpl,
    IN BOOL                 bNoNewProps     // = FALSE
    )
{
    BOOL    bSuccess = FALSE;
    DWORD   sc = ERROR_SUCCESS;

    //
    //  Call the base class method.
    //

    bSuccess = CBasePropertyPage::BBuildPropList(rcpl, bNoNewProps);
    if (bSuccess)
    {

        //
        //  We are creating the file share resource when we are a wizard page.  So when we
        //  are creating a file share resource and the security descriptor is NULL then
        //  we need to create an SD that has everyone read only.
        //

        if ((Peo()->BWizard()) && (m_psec == NULL))
        {
            sc = ScCreateDefaultSD(&m_psec);
        } // if:

        if (sc == ERROR_SUCCESS)
        {
            if (!bNoNewProps)
            {
                rcpl.ScAddProp(
                        REGPARAM_FILESHR_SD,
                        (LPBYTE) m_psec,
                        (m_psec == NULL ? 0 : ::GetSecurityDescriptorLength(m_psec)),
                        (LPBYTE) m_psecPrev,
                        (m_psecPrev == NULL ? 0 : ::GetSecurityDescriptorLength(m_psecPrev))
                        );
            }

            PSECURITY_DESCRIPTOR    psd = ::ClRtlConvertFileShareSDToNT4Format(m_psec);

            rcpl.ScAddProp(
                    REGPARAM_FILESHR_SECURITY,
                    (LPBYTE) psd,
                    (psd == NULL ? 0 : ::GetSecurityDescriptorLength(psd)),
                    (LPBYTE) m_psecPrev,
                    (m_psecPrev == NULL ? 0 : ::GetSecurityDescriptorLength(m_psecPrev))
                    );

            ::LocalFree(psd);
        } // if:
        else
        {
            bSuccess = FALSE;
        } // else:
    } // if:  rest of property list build successfully

    return bSuccess;

}  //*** CFileShareParamsPage::BBuildPropList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnChangeRequiredField
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Share name or Path edit
//      controls.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnChangeRequiredField(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (BWizard())
    {
        if ((m_editShareName.GetWindowTextLength() == 0)
                || (m_editPath.GetWindowTextLength() == 0))
        {
            EnableNext(FALSE);
        }
        else
        {
            EnableNext(TRUE);
        }
    }  // if:  in a wizard

}  //*** CFileShareParamsPage::OnChangeRequiredField()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedMaxUsers
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Max Users radio buttons.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedMaxUsers(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetModified(TRUE);

    if (m_rbMaxUsersAllowed.GetCheck() == BST_CHECKED)
    {
        m_editMaxUsers.SetWindowText(_T(""));
    }
    else
    {
        m_editMaxUsers.SetFocus();
    }

}  //*** CFileShareParamsPage::OnBnClickedMaxUsers()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnEnChangeMaxUsers
//
//  Routine Description:
//      Handler for the EN_CHANGE message on the Max Users edit control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnEnChangeMaxUsers(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    OnChangeCtrl();

    if (m_editMaxUsers.m_hWnd != NULL)
    {
        if (m_editMaxUsers.GetWindowTextLength() == 0)
        {
            m_rbMaxUsersAllowed.SetCheck(BST_CHECKED);
            m_rbMaxUsers.SetCheck(BST_UNCHECKED);
        }  // if:  maximum # users has not been specified
        else
        {
            m_rbMaxUsersAllowed.SetCheck(BST_UNCHECKED);
            m_rbMaxUsers.SetCheck(BST_CHECKED);
        }  // if:  maximum # users has been specified
    }  // if:  control variables have been initialized

}  //*** CFileShareParamsPage::OnEnChangeMaxUsers()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedPermissions
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Permissions push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedPermissions(void)
{
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT hr = S_OK;
    INT_PTR nRet = 0;
    CString strNode;
    CString strShareName;

    //
    //  Get the node on which the Cluster Name resource is online.
    //

    if ( BGetClusterNetworkNameNode( strNode ) == FALSE )
    {
        return;
    } // if:

    CWaitCursor wc;

    try
    {
        m_editShareName.GetWindowText( strShareName );
        m_strCaption.Format(
            IDS_ACLEDIT_PERMISSIONS,
            (LPCTSTR) strShareName,
            (LPCTSTR) Peo()->RrdResData().m_strName
            );

        CFileShareSecuritySheet fsSecurity( this, m_strCaption );

        hr = fsSecurity.HrInit( this, Peo(), strNode, strShareName );
        if ( SUCCEEDED( hr ) )
        {
            nRet = fsSecurity.DoModal();
            m_strCaption.Empty();
        } // if:
    }  // try:
    catch ( CMemoryException * pme )
    {
        pme->Delete();
    } // catch: MFC memory exception...

}  //*** CFileShareParamsPage::OnBnClickedPermissions()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedAdvanced
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Advanced push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedAdvanced(void)
{
    CFileShareAdvancedDlg dlg(m_bShareSubDirs, m_bHideSubDirShares, m_bIsDfsRoot, this);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (dlg.DoModal() == IDOK)
    {
        if (   (m_bHideSubDirShares != dlg.m_bHideSubDirShares)
            || (m_bShareSubDirs != dlg.m_bShareSubDirs)
            || (m_bIsDfsRoot != dlg.m_bIsDfsRoot))
        {
            m_bHideSubDirShares = dlg.m_bHideSubDirShares;
            m_bShareSubDirs = dlg.m_bShareSubDirs;
            m_bIsDfsRoot = dlg.m_bIsDfsRoot;

            SetModified(TRUE);
        } // if:  data changed
    }  // if:  user accepted the dialog

}  //*** CFileShareParamsPage::OnBnClickedAdvanced()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::OnBnClickedCaching
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Caching push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CFileShareParamsPage::OnBnClickedCaching(void)
{
    CFileShareCachingDlg dlg(m_dwCSCCache, this);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (dlg.DoModal() == IDOK)
    {
        if (m_dwCSCCache != dlg.m_dwFlags)
        {
            m_dwCSCCache = dlg.m_dwFlags;

            SetModified(TRUE);
        } // if:  data changed
    }  // if:  user accepted the dialog

}  //*** CFileShareParamsPage::OnBnClickedCaching()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::SetSecurityDescriptor
//
//  Routine Description:
//      Save the passed in descriptor into m_psec.
//
//  Arguments:
//      psec        [IN] new security descriptor
//
//  Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CFileShareParamsPage::SetSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR psec
    )
{
    ASSERT( psec != NULL );
    AFX_MANAGE_STATE( AfxGetStaticModuleState() );

    HRESULT hr = S_OK;
    DWORD   sc = ERROR_SUCCESS;

    try
    {
        if ( psec != NULL )
        {
            ASSERT( IsValidSecurityDescriptor( psec ) );
            if ( IsValidSecurityDescriptor( psec ) )
            {
                LocalFree( m_psecPrev );
                m_psecPrev = NULL;
                if ( m_psec == NULL )
                {
                    m_psecPrev = NULL;
                } // if: no previous value
                else
                {
                    m_psecPrev = ::ClRtlCopySecurityDescriptor( m_psec );
                    if ( m_psecPrev == NULL )
                    {
                        sc = GetLastError();            // Get the last error
                        hr = HRESULT_FROM_WIN32( sc );  // Convert to HRESULT
                        goto Cleanup;
                    } // if: error copying the security descriptor
                } // else: previous value exists

                LocalFree( m_psec );
                m_psec = NULL;

                m_psec = ::ClRtlCopySecurityDescriptor( psec );
                if ( m_psec == NULL )
                {
                    sc = GetLastError();            // Get the last error
                    hr = HRESULT_FROM_WIN32( sc );  // Convert to HRESULT
                    goto Cleanup;
                } // if: error copying the security descriptor

                SetModified( TRUE );
                hr = S_OK;
            } // if: security descriptor is valid
        } // if: non-NULL security descriptor specified
        else
        {
            TRACE( _T("CFileShareParamsPage::SetSecurityDescriptor() - ACLUI handed us back a NULL SD!\r") );
            hr = E_UNEXPECTED;
        }
    } // try:
    catch ( ... )
    {
        hr = E_FAIL;
    } // catch: everything...

Cleanup:

    return hr;

}  //*** CFileShareParamsPage::SetSecurityDescriptor()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::ScConvertPropertyToSD
//
//  Routine Description:
//      Convert the property into an SD.
//
//  Arguments:
//      rvalue          [IN] CLUSPROP property value.
//      cbBuf           [IN] Total size of the value buffer.
//      ppsec           [IN] SD to save the property to.
//
//  Return Value:
//      none.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CFileShareParamsPage::ScConvertPropertyToSD(
    IN const CLUSPROP_BUFFER_HELPER &   rvalue,
    IN DWORD                            cbBuf,
    IN PSECURITY_DESCRIPTOR             *ppsec
    )
{
    ASSERT(rvalue.pSyntax->wFormat == CLUSPROP_FORMAT_BINARY);
    ASSERT(cbBuf >= sizeof(*rvalue.pBinaryValue) + ALIGN_CLUSPROP(rvalue.pValue->cbLength));
    ASSERT(ppsec);

    DWORD   sc = ERROR_SUCCESS;

    if ((ppsec != NULL) && (rvalue.pBinaryValue->cbLength != 0))
    {
        *ppsec = ::LocalAlloc(LMEM_ZEROINIT, rvalue.pBinaryValue->cbLength);
        if (*ppsec == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ::CopyMemory(*ppsec, rvalue.pBinaryValue->rgb, rvalue.pBinaryValue->cbLength);

        ASSERT(::IsValidSecurityDescriptor(*ppsec));

        if (!::IsValidSecurityDescriptor(*ppsec))
        {
            ::LocalFree(*ppsec);
            *ppsec = NULL;
        }  // if:  invalid security descriptor
    }  // if:  security descriptor specified
    else
    {
        if ( ppsec != NULL )
        {
            ::LocalFree(*ppsec);
            *ppsec = NULL;
        }
    }  // else:  no security descriptor specified

    return sc;

}  //*** CFileShareParamsPage::ScConvertPropertyToSD()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::Psec
//
//  Routine Description:
//      Return the SD for the FileShare.  Since we may have two different
//      SDs we have to choose one and go with it...  Since AclUi can use
//      the NT4 one without change it's OK to use it as is if the NT5 one
//      is not present...
//
//  Arguments:
//      none.
//
//  Return Value:
//      The SD...
//
//  Exceptions Thrown:
//
//--
/////////////////////////////////////////////////////////////////////////////
const PSECURITY_DESCRIPTOR CFileShareParamsPage::Psec(
    void
    )
{
    //
    //  If we are in the wizard and m_psec is still NULL then the permissions
    //  button was clicked and we need a proper default SD to hand to ACLUI...
    //

    if ((Peo()->BWizard()) && (m_psec == NULL))
    {
        DWORD   sc;

        sc = ScCreateDefaultSD(&m_psec);
        if (sc == ERROR_SUCCESS)
        {
            ASSERT(m_psec != NULL);
            ASSERT(m_psecPre == NULL);
        } // if:
        else
        {
            //
            //  If this fails then there really isn't anything much to do...
            //  ACLUI will show everyone FULL control...
            //

            ASSERT(m_psec == NULL);
            ASSERT(m_psecPre == NULL);
        } // else:
    } // if:
    else
    {
        if (m_psec == NULL)
        {
            //
            //  try the NT5 one first...
            //

            if (m_psecNT5 != NULL)
            {
                m_psec = ::ClRtlCopySecurityDescriptor(m_psecNT5);
                if ( m_psec == NULL )
                {
                    goto Cleanup;
                } // if: error copying the security descriptor
            } // if: we have an NT5 SD...
            else
            {
                if (m_psecNT4 != NULL)
                {
                    m_psec = ::ClRtlCopySecurityDescriptor(m_psecNT4);
                    if ( m_psec == NULL )
                    {
                        goto Cleanup;
                    } // if: error copying the security descriptor
                } // if: we have an NT4 SD...
            } // else: we don't have an NT5 SD...

            //
            //  Set current values as the previous values to track changes.
            //

            m_psecPrev = ::ClRtlCopySecurityDescriptor(m_psec);
        } // if: we have an SD...
    } // else:

Cleanup:

    return m_psec;

}  //*** CFileShareParamsPage::Psec()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CFileShareParamsPage::ScCreateDefaultSD
//
//  Routine Description:
//      When we are creating a new file share resource we need to create a
//      default SD that has everyone read only in its ACL.
//
//  Arguments:
//      ppSecOut
//
//  Return Value:
//      ERROR_SUCCESS
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD
CFileShareParamsPage::ScCreateDefaultSD(
    PSECURITY_DESCRIPTOR *  ppSecOut
    )
{
    ASSERT( ppSecOut != NULL );

    BOOL                    fRet = TRUE;
    DWORD                   sc = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pSec = NULL;

    //
    //  Create a default SD and hand it out...
    //

    fRet = ConvertStringSecurityDescriptorToSecurityDescriptorW(
          L"D:(A;;GRGX;;;WD)"
        , SDDL_REVISION_1
        , &pSec
        , NULL
        );
    if ( fRet )
    {
        sc = ERROR_SUCCESS;
        *ppSecOut = pSec;
    } // if:
    else
    {
        sc = GetLastError();
        TRACE( _T( "CFileShareParamsPage::ScCreateDefaultSD() - ConvertStringSecurityDescriptorToSecurityDescriptorW() failed. (sc = %#08x)\r" ), sc );
    } // else:

    return sc;

}  //*** CFileShareParamsPage::ScCreateDefaultSD()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CluAdmEx.rc
//
#define IDD_PP_DISKS_PARAMETERS         120
#define IDD_PP_GENAPP_PARAMETERS        121
#define IDD_PP_GENSVC_PARAMETERS        122
#define IDD_PP_NETNAME_PARAMETERS       123
#define IDD_PP_FILESHR_PARAMETERS       124
#define IDD_PP_FILESHR_SECURITY         125
#define IDD_PP_IPADDR_PARAMETERS        126
#define IDD_PP_PRTSPOOL_PARAMETERS      127
#define IDD_PP_REGREPL_PARAMETERS       128
#define IDD_PP_GENSCRIPT_PARAMETERS     129
#define IDD_WIZ_DISKS_PARAMETERS        140
#define IDD_WIZ_GENAPP_PARAMETERS       141
#define IDD_WIZ_GENSVC_PARAMETERS       142
#define IDD_WIZ_IPADDR_PARAMETERS       143
#define IDD_WIZ_NETNAME_PARAMETERS      144
#define IDD_WIZ_FILESHR_PARAMETERS      145
#define IDD_WIZ_PRTSPOOL_PARAMETERS     146
#define IDD_WIZ_REGREPL_PARAMETERS      147
#define IDD_WIZ_GENSCRIPT_PARAMETERS    148
#define IDD_EDIT_REGKEY                 160
#define IDD_EDIT_CLUSTER_NAME           161
#define IDD_FILESHR_ADVANCED            162
#define IDD_FILESHR_CACHE_SETTINGS      163
#define IDI_ICON_FILEMGMT               500
#define IDC_PP_ICON                     1000
#define IDC_PP_TITLE                    1001
#define IDC_PP_NODE_PARAM_GROUP         1002
#define IDC_PP_NODES_LABEL              1003
#define IDC_PP_NODES                    1004
#define IDC_PP_GENAPP_PARAMS_IMAGE_NAME_LABEL 1010
#define IDC_PP_GENAPP_PARAMS_IMAGE_NAME 1011
#define IDC_PP_GENAPP_PARAMS_COMMAND_LINE_LABEL 1012
#define IDC_PP_GENAPP_PARAMS_COMMAND_LINE 1013
#define IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY_LABEL 1014
#define IDC_PP_GENAPP_PARAMS_CURRENT_DIRECTORY 1015
#define IDC_PP_GENAPP_PARAMS_INTERACT_WITH_DESKTOP 1016
#define IDC_PP_GENAPP_PARAMS_USE_NETWORK_NAME 1017
#define IDC_PP_GENSVC_PARAMS_SERVICE_NAME_LABEL 1020
#define IDC_PP_GENSVC_PARAMS_SERVICE_NAME 1021
#define IDC_PP_GENSVC_PARAMS_COMMAND_LINE_LABEL 1022
#define IDC_PP_GENSVC_PARAMS_COMMAND_LINE 1023
#define IDC_PP_GENSVC_PARAMS_USE_NETWORK_NAME 1024
#define IDC_PP_NETNAME_PARAMS_NAME_LABEL 1030
#define IDC_PP_NETNAME_PARAMS_NAME      1031
#define IDC_PP_NETNAME_PARAMS_RENAME    1032
#define IDC_PP_NETNAME_PARAMS_CORE_TEXT 1033
#define IDC_PP_NETNAME_PARAMS_CORE_TEXT2 1034
#define IDC_PP_NETNAME_PARAMS_CHECKBOX_DNS 1035
#define IDC_PP_NETNAME_PARAMS_CHECKBOX_KERBEROS 1036
#define IDC_PP_NETNAME_PARAMS_STATUS_NETBIOS 1037
#define IDC_PP_NETNAME_PARAMS_STATUS_DNS 1038
#define IDC_PP_NETNAME_PARAMS_STATUS_KERBEROS 1039
#define IDC_PP_DISKS_PARAMS_DISK_LABEL  1040
#define IDC_PP_DISKS_PARAMS_DISK        1041
#define IDC_PP_FILESHR_PARAMS_SHARE_NAME_LABEL 1050
#define IDC_PP_FILESHR_PARAMS_SHARE_NAME 1051
#define IDC_PP_FILESHR_PARAMS_PATH_LABEL 1052
#define IDC_PP_FILESHR_PARAMS_PATH      1053
#define IDC_PP_FILESHR_PARAMS_REMARK_LABEL 1054
#define IDC_PP_FILESHR_PARAMS_REMARK    1055
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_GROUP 1056
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_ALLOWED_RB 1057
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_RB 1058
#define IDC_PP_FILESHR_PARAMS_MAX_USERS 1059
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_SPIN 1060
#define IDC_PP_FILESHR_PARAMS_MAX_USERS_END 1061
#define IDC_PP_FILESHR_PARAMS_PERMISSIONS 1062
#define IDC_PP_FILESHR_PARAMS_ADVANCED  1063
#define IDC_PP_FILESHR_PARAMS_CACHING   1064
#define IDC_PP_IPADDR_PARAMS_NETWORK    1070
#define IDC_PP_IPADDR_PARAMS_NETWORK_LABEL 1071
#define IDC_PP_IPADDR_PARAMS_ADDRESS_LABEL 1072
#define IDC_PP_IPADDR_PARAMS_ADDRESS    1073
#define IDC_PP_IPADDR_PARAMS_SUBNET_MASK_LABEL 1075
#define IDC_PP_IPADDR_PARAMS_SUBNET_MASK 1076
#define IDC_PP_IPADDR_PARAMS_ENABLE_NETBIOS 1077
#define IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR_LABEL 1100
#define IDC_PP_PRTSPOOL_PARAMS_SPOOL_DIR 1101
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL1 1102
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT  1103
#define IDC_PP_PRTSPOOL_PARAMS_TIMEOUT_LABEL2 1104
#define IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR_LABEL 1105
#define IDC_PP_PRTSPOOL_PARAMS_DRIVER_DIR 1106
#define IDC_PP_REGREPL_PARAMS_NOTE      1110
#define IDC_PP_REGREPL_PARAMS_LIST      1111
#define IDC_PP_REGREPL_PARAMS_ADD       1112
#define IDC_PP_REGREPL_PARAMS_REMOVE    1113
#define IDC_PP_REGREPL_PARAMS_MODIFY    1114
#define IDC_REGKEY_LABEL                1120
#define IDC_REGKEY                      1121
#define IDC_CLUSNAME_TEXT               1130
#define IDC_CLUSNAME_LABEL              1131
#define IDC_CLUSNAME                    1132
#define IDC_FILESHR_ADV_NORMAL_SHARE    1150
#define IDC_FILESHR_ADV_DFS_ROOT        1151
#define IDC_FILESHR_ADV_SHARE_SUBDIRS   1152
#define IDC_FILESHR_ADV_HIDE_SUBDIR_SHARES 1153
#define IDC_FILESHR_CACHE_ALLOW_CACHING_GROUP   1160
#define IDC_FILESHR_CACHE_ALLOW_CACHING         1161
#define IDC_FILESHR_CACHE_SETTINGS_LABEL        1162
#define IDC_FILESHR_CACHE_OPTIONS               1163
#define IDC_FILESHR_CACHE_HINT                  1164
#define IDC_FILESHR_CACHE_CS_HELP               1165
#define IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH 1188
#define IDC_PP_GENSCRIPT_PARAMS_SCRIPTFILEPATH_LABEL 1189
#define IDS_CLUADMEX_DESC               30500
#define IDS_ACLEDIT_PERM_GEN_NO_ACCESS  30501
#define IDS_ACLEDIT_PERM_GEN_READ       30502
#define IDS_ACLEDIT_PERM_GEN_MODIFY     30503
#define IDS_ACLEDIT_PERM_GEN_ALL        30504
#define IDS_ACLEDIT_TITLE               30505
#define IDS_MSGTITLE                    30506
#define IDS_MENU_WHATS_THIS             30507
#define IDS_COLTEXT_REGKEY              30508
#define IDS_DEFAULT_SPOOL_DIR           30509
#define IDS_DEFAULT_GENAPP_CURRENT_DIR  30510
#define IDS_RESCLASS_UNKNOWN            30750
#define IDS_RESCLASS_STORAGE            30751
#define IDS_RESCLASS_RESERVED_1         30752
#define IDS_RESCLASS_RESERVED_2         30752
#define IDS_CSC_MANUAL_WORKGROUP_SHARE              30800
#define IDS_CSC_MANUAL_WORKGROUP_SHARE_HINT         30801
#define IDS_CSC_AUTOMATIC_WORKGROUP_SHARE           30802
#define IDS_CSC_AUTOMATIC_WORKGROUP_SHARE_HINT      30803
#define IDS_CSC_AUTOMATIC_APPLICATION_SHARE         30804
#define IDS_CSC_AUTOMATIC_APPLICATION_SHARE_HINT    30805
#define IDS_ERROR_MSG_ID                31100
#define IDS_APPLY_PARAM_CHANGES_ERROR   31101
#define IDS_NOACLEDITOR                 31103
#define IDS_INVALID_NETWORK_NAME        31104
#define IDS_INVALID_NETWORK_NAME_TOO_LONG 31105
#define IDS_INVALID_NETWORK_NAME_INVALID_CHARS 31106
#define IDS_INVALID_NETWORK_NAME_IN_USE 31107
#define IDS_ERROR_ADDING_REGKEY         31108
#define IDS_ERROR_DELETING_REGKEY       31109
#define IDS_ERROR_READING_REGKEYS       31110
#define IDS_GET_AVAILABLE_DISKS_ERROR   31111
#define IDS_GET_DISK_INFO_ERROR         31112
#define IDS_ERROR_SETTING_CLUSTER_NAME  31113
#define IDS_INVALID_GENERIC_SERVICE     31114
#define IDS_LOCAL_ACCOUNTS_SPECIFIED_SMB 31115
#define IDS_INVALID_IP_ADDRESS          31116
#define IDS_INVALID_SUBNET_MASK         31117
#define IDS_INVALID_ADDRESS_AND_SUBNET_MASK 31118
#define IDS_IP_SUBNET_CANT_BE_VALIDATED 31119
#define IDS_IP_ADDRESS_IN_USE           31120
#define IDS_ACLEDIT_PERMISSIONS         31121
#define IDS_IP_PROVIDES_FOR_NETNAME     31122
#define IDS_NETNAMES_MAY_NOT_WORK       31123
#define IDS_LOCAL_ACCOUNTS_SPECIFIED_CLUS 31124
#define IDS_SYS_ACCOUNT_NOT_SPECIFIED   31125
#define IDS_ADMIN_ACCOUNT_NOT_SPECIFIED 31126
#define IDS_ERROR_SETTING_PROPERTIES    31127
#define IDS_ERROR_VALIDATING_PROPERTIES 31128
#define IDS_ERROR_CONSTRUCTING_DEF_DIR  31129
#define IDS_ERROR_VALIDATING_NETWORK_NAME 31130
#define IDS_REQUIRED_DEPENDENCY_NOT_FOUND 31131
#define IDS_ERROR_GETTING_PROPERTIES    31132
#define IDS_ERROR_VALIDATING_CLUSTER_SECURITY_DESCRIPTOR 31133
#define IDS_ERROR_GET_RESOURCE_FLAGS    31134
#define IDS_NETSERVICE_ACCOUNT_NOT_SPECIFIED 31135
#define IDS_ERROR_GET_CLASS_INFO        31136
#define IDS_INVALID_NETWORK_NAME_INVALID_DNS_CHARS 31137
#define IDS_ERROR_GETTING_CLUSTER_INFORMATION 31138
#define IDS_WARNING_DISABLING_KERBEROS  31139
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        154
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1190
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\regrepl.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		RegRepl.h
//
//	Abstract:
//		Definition of the CRegReplParamsPage class, which implements the
//		Registry Replication page for Generic Application and Generic
//		Service resources.
//
//	Implementation File:
//		RegRepl.cpp
//
//	Author:
//		David Potter (davidp)	February 23, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _REGREPL_H_
#define _REGREPL_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// CRegReplParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CRegReplParamsPage : public CBasePropertyPage
{
	DECLARE_DYNCREATE(CRegReplParamsPage)

// Construction
public:
	CRegReplParamsPage(void);
	~CRegReplParamsPage(void);

	// Second phase construction.
	virtual HRESULT	HrInit(IN OUT CExtObject * peo);

// Dialog Data
	//{{AFX_DATA(CRegReplParamsPage)
	enum { IDD = IDD_PP_REGREPL_PARAMETERS };
	CButton	m_pbRemove;
	CButton	m_pbModify;
	CListCtrl	m_lcRegKeys;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRegReplParamsPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL		BApplyChanges(void);

// Implementation
protected:
	LPWSTR				m_pwszRegKeys;

	LPCWSTR				PwszRegKeys(void) const		{ return m_pwszRegKeys; }
	DWORD				ScReadRegKeys(void);
	void				FillList(void);

	// Generated message map functions
	//{{AFX_MSG(CRegReplParamsPage)
	afx_msg void OnAdd();
	afx_msg void OnModify();
	afx_msg void OnRemove();
	virtual BOOL OnInitDialog();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CRegReplParamsPage

/////////////////////////////////////////////////////////////////////////////

#endif // _REGREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbshare.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      SmbShare.h
//
//  Description:
//      Definition of the CFileShareParamsPage classes, which implement
//      the Parameters page for the File Share resource.
//      Share resources.
//
//  Implementation File:
//      SmbShare.cpp
//
//  Maintained By:
//      David Potter (davidp)   June 28, 1996
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSHARE_H_
#define _SMBSHARE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"   // for CBasePropertyPage
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CFileShareParamsPage dialog
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage : public CBasePropertyPage
{
    DECLARE_DYNCREATE(CFileShareParamsPage)

// Construction
public:
    CFileShareParamsPage(void);
    virtual ~CFileShareParamsPage(void);

// Dialog Data
    //{{AFX_DATA(CFileShareParamsPage)
    enum { IDD = IDD_PP_FILESHR_PARAMETERS };
    CButton m_pbPermissions;
    CSpinButtonCtrl m_spinMaxUsers;
    CButton m_rbMaxUsers;
    CButton m_rbMaxUsersAllowed;
    CEdit   m_editMaxUsers;
    CEdit   m_editRemark;
    CEdit   m_editPath;
    CEdit   m_editShareName;
    CString m_strShareName;
    CString m_strPath;
    CString m_strRemark;
    DWORD   m_dwCSCCache;
    //}}AFX_DATA
    CString m_strPrevShareName;
    CString m_strPrevPath;
    CString m_strPrevRemark;
    DWORD   m_dwMaxUsers;
    BOOL    m_bShareSubDirs;
    BOOL    m_bHideSubDirShares;
    BOOL    m_bIsDfsRoot;
    DWORD   m_dwPrevMaxUsers;
    BOOL    m_bPrevShareSubDirs;
    BOOL    m_bPrevHideSubDirShares;
    BOOL    m_bPrevIsDfsRoot;
    DWORD   m_dwPrevCSCCache;

    const   PSECURITY_DESCRIPTOR    Psec(void);
            HRESULT                 SetSecurityDescriptor( IN PSECURITY_DESCRIPTOR psec );

protected:
    enum
    {
        epropShareName,
        epropPath,
        epropRemark,
        epropMaxUsers,
        epropShareSubDirs,
        epropHideSubDirShares,
        epropIsDfsRoot,
        epropCSCCache,
        epropMAX
    };

    CObjectProperty     m_rgProps[epropMAX];

// Overrides
public:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CFileShareParamsPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

protected:
    virtual DWORD       ScParseUnknownProperty(
                            IN LPCWSTR                          pwszName,
                            IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                            IN DWORD                            cbBuf
                            );
    virtual BOOL        BApplyChanges(void);
    virtual BOOL        BBuildPropList(IN OUT CClusPropList & rcpl, IN BOOL bNoNewProps = FALSE);
    DWORD               ScConvertPropertyToSD(
                            IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                            IN DWORD                            cbBuf,
                            IN PSECURITY_DESCRIPTOR             *ppsec
                            );

    virtual const CObjectProperty * Pprops(void) const  { return m_rgProps; }
    virtual DWORD                   Cprops(void) const  { return sizeof(m_rgProps) / sizeof(CObjectProperty); }
    DWORD                           ScCreateDefaultSD(PSECURITY_DESCRIPTOR *  ppSecOut);

// Implementation
protected:
    CString                 m_strCaption;
    PSECURITY_DESCRIPTOR    m_psecNT4;
    PSECURITY_DESCRIPTOR    m_psecNT5;
    PSECURITY_DESCRIPTOR    m_psec;
    PSECURITY_DESCRIPTOR    m_psecPrev;

    // Generated message map functions
    //{{AFX_MSG(CFileShareParamsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeRequiredField();
    afx_msg void OnBnClickedMaxUsers();
    afx_msg void OnEnChangeMaxUsers();
    afx_msg void OnBnClickedPermissions();
    afx_msg void OnBnClickedAdvanced();
    afx_msg void OnBnClickedCaching();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CFileShareParamsPage

#endif // _SMBSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	CluAdmEx.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbspage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSPage.h
//
//	Abstract:
//		CClusterFileShareSecurityPage class declaration.  This class will encapsulate
//		the cluster file share security page.
//
//	Implementation File:
//		ClusPage.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSPAGE_H_
#define _SMBSPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"
#endif //_BASEPAGE_H_

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "ExtObj.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityPage;
class CFileShareSecuritySheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityInformation security information
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityInformation : public CSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );

public:
	CClusterFileShareSecurityInformation( void );
	virtual ~CClusterFileShareSecurityInformation( void );

	HRESULT	HrInit( IN CClusterFileShareSecurityPage * pcsp, IN CString const & strServer, IN CString const & strNode );

protected:
	CClusterFileShareSecurityPage*	m_pcsp;

	CClusterFileShareSecurityPage*	Pcsp( void ) const { return m_pcsp; };
};

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityPage security property page wrapper
/////////////////////////////////////////////////////////////////////////////

class CClusterFileShareSecurityPage : public CBasePropertyPage
{
public:
	CClusterFileShareSecurityPage( void );
	~CClusterFileShareSecurityPage( void );

			HRESULT						HrInit(
											IN CExtObject *					peo,
											IN CFileShareSecuritySheet *	pss,
											IN CString const & 				strServer
											);
	const	HPROPSHEETPAGE				GetHPage( void ) const		{ return m_hpage; };
			CFileShareSecuritySheet*	Pss( void ) const			{ return m_pss; };

protected:
	CFileShareSecuritySheet*							m_pss;
	HPROPSHEETPAGE										m_hpage;
	HKEY												m_hkey;
	CComObject<CClusterFileShareSecurityInformation>*	m_psecinfo;
};

#endif //_SMBSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbspage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSPage.cpp
//
//	Abstract:
//		CClusterFileShareSecurityPage class implementation.  This class will encapsulate
//		the cluster file share security page.
//
//	Author:
//		Galen Barbee	(galenb)	February 11, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "SmbSPage.h"
#include "AclUtils.h"
#include <clusudef.h>
#include "SmbShare.h"
#include "SmbSSht.h"

static GENERIC_MAPPING ShareMap =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

static SI_ACCESS siFileShareAccesses[] =
{
	{ &GUID_NULL, FILE_ALL_ACCESS,             				MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_ALL),    	SI_ACCESS_GENERAL },
	{ &GUID_NULL, FILE_GENERIC_WRITE | DELETE, 				MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_MODIFY),	SI_ACCESS_GENERAL },
	{ &GUID_NULL, FILE_GENERIC_READ | FILE_GENERIC_EXECUTE, MAKEINTRESOURCE(IDS_ACLEDIT_PERM_GEN_READ), 	SI_ACCESS_GENERAL }
};

/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityInformation security page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation
//
//	Routine Description:
//		Default contructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation(
	void
	)
{
	m_pShareMap		= &ShareMap;
	m_psiAccess		= (SI_ACCESS *) &siFileShareAccesses;
	m_nAccessElems	= ARRAYSIZE( siFileShareAccesses );
	m_nDefAccess	= 2;   // FILE_GEN_READ
	m_dwFlags		=   SI_EDIT_PERMS
						| SI_NO_ACL_PROTECT
						//| SI_UGOP_PROVIDED
						;

}  //*** CClusterFileShareSecurityInformation::CClusterFileShareSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation(
	void
	)
{
}  //*** CClusterFileShareSecurityInformation::~CClusterFileShareSecurityInformation()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::GetSecurity
//
//	Routine Description:
//		Give the security descriptor to the common UI.
//
//	Arguments:
//		RequestedInformation	[IN]
//		ppSecurityDescriptor	[IN, OUT] get the security descriptor
//		fDefault				[IN]
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterFileShareSecurityInformation::GetSecurity(
	IN SECURITY_INFORMATION RequestedInformation,
	IN OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
	IN BOOL fDefault
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	try
	{
		if ( ppSecurityDescriptor != NULL )
		{
			*ppSecurityDescriptor = ::ClRtlCopySecurityDescriptor( Pcsp()->Pss()->Ppp()->Psec() );
			hr = S_OK;
		}
	}
	catch ( ... )
	{
		TRACE( _T("CClusterFileShareSecurityInformation::GetSecurity() - Unknown error occurred.\n") );
	}

	return hr;

}  //*** CClusterFileShareSecurityInformation::GetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityInformation::SetSecurity
//
//	Routine Description:
//		Save the passed in descriptor
//
//	Arguments:
//		RequestedInformation	[IN]
//		ppSecurityDescriptor	[IN] the new security descriptor
//		fDefault				[IN]
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CClusterFileShareSecurityInformation::SetSecurity(
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	try
	{
		hr = CSecurityInformation::SetSecurity( SecurityInformation, pSecurityDescriptor );
		if ( hr == S_OK )
		{
			hr = Pcsp()->Pss()->Ppp()->SetSecurityDescriptor( pSecurityDescriptor );
		}
	}
	catch( ... )
	{
		;
	}

	return hr;

}  //*** CClusterFileShareSecurityInformation::SetSecurity()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareParamsPage::HrInit
//
//	Routine Description:
//		Initialize the object
//
//	Arguments:
//		pcsp		[IN] back pointer to the parent property page
//		strServer	[IN] cluster name
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterFileShareSecurityInformation::HrInit(
	CClusterFileShareSecurityPage * pcsp,
	IN CString const & 				strServer,
	IN CString const & 				strNode
	)
{
	ASSERT( pcsp != NULL );
	ASSERT( strServer.GetLength() > 0 );
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	m_pcsp						= pcsp;
	m_strServer					= strServer;
	m_strNode					= strNode;
	m_nLocalSIDErrorMessageID 	= IDS_LOCAL_ACCOUNTS_SPECIFIED_SMB;

	return S_OK;

}  //*** CClusterFileShareSecurityInformation::HrInit()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterFileShareSecurityPage security property page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::CClusterFileShareSecurityPage
//
//	Routine Description:
//		Default contructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityPage::CClusterFileShareSecurityPage( void )
	: m_hpage( 0 )
	, m_hkey( 0 )
	, m_psecinfo( NULL )
	, m_pss( NULL )
{
//	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

}  //*** CClusterFileShareSecurityPage::CClusterFileShareSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage
//
//	Routine Description:
//		Destructor
//
//	Arguments:
//		none
//
//	Return Value:
//		none
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage( void )
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	m_psecinfo->Release();

}  //*** CClusterFileShareSecurityPage::~CClusterFileShareSecurityPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CClusterFileShareSecurityPage::HrInit
//
//	Routine Description:
//
//
//	Arguments:
//
//
//	Return Value:
//
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CClusterFileShareSecurityPage::HrInit(
	IN CExtObject *					peo,
	IN CFileShareSecuritySheet *	pss,
	IN CString const & 				strNode
	)
{
	ASSERT( peo != NULL );
	ASSERT( pss != NULL );
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	HRESULT	hr = E_FAIL;

	if ( ( pss != NULL ) && ( peo != NULL ) )
	{
		m_peo = peo;
		m_pss = pss;

		hr = CComObject<CClusterFileShareSecurityInformation>::CreateInstance( &m_psecinfo );
		if ( SUCCEEDED( hr ) )
		{
			m_psecinfo->AddRef();

			m_hkey = GetClusterKey( Hcluster(), KEY_ALL_ACCESS );
			if ( m_hkey != NULL )
			{
				m_hpage = CreateClusterSecurityPage( m_psecinfo );
				if ( m_hpage != NULL )
				{
					CString	strServer;

					strServer.Format( _T( "\\\\%s" ), Peo()->StrClusterName() );

					hr = m_psecinfo->HrInit( this, strServer, strNode );
				}
				else
				{
					hr = E_FAIL;
				}
			}
			else
			{
				DWORD sc = ::GetLastError();
				hr = HRESULT_FROM_WIN32( sc );
			}
		}
	}

	return hr;

}  //*** CClusterFileShareSecurityPage::HrInit()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbssht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSSht.h
//
//	Abstract:
//
//	Implementation File:
//		SmbSSht.cpp
//
//	Author:
//		Galen Barbee	(galenb)	February 12, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _SMBSSHT_H_
#define _SMBSSHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef __cluadmex_h__
#include <CluAdmEx.h>
#endif

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePropertyPage
#endif

#ifndef _ACLBASE_H_
#include "AclBase.h"
#endif //_ACLBASE_H_

#include "SmbSPage.h"

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CFileShareParamsPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CFileShareSecuritySheet property sheet
/////////////////////////////////////////////////////////////////////////////

class CFileShareSecuritySheet : public CPropertySheet
{
// Construction
public:
	CFileShareSecuritySheet(
		IN CWnd *			pParent,
		IN CString const &	strCaption
		);

	virtual ~CFileShareSecuritySheet(void);

	HRESULT HrInit(
		IN CFileShareParamsPage*	ppp,
		IN CExtObject*				peo,
		IN CString const &			strNode,
		IN CString const &			strShareName
		);

		CFileShareParamsPage*	Ppp( void ) const { return m_ppp; };

// Dialog Data
	//{{AFX_DATA(CFileShareSecuritySheet)
	enum { IDD = IDD_PP_FILESHR_SECURITY };
	//}}AFX_DATA

//	PSECURITY_DESCRIPTOR	m_psec;
//	PSECURITY_DESCRIPTOR	m_psecPrev;

// Overrides
public:
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFileShareSecuritySheet)
	public:
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual void BuildPropPageArray( void );

#ifdef _DEBUG
	virtual void AssertValid( void ) const;
#endif

	// Implementation
protected:
//	BOOL			m_bSecurityChanged;
	CExtObject *					m_peo;
	CFileShareParamsPage*			m_ppp;
	CString							m_strShareName;
	CString							m_strNodeName;
	CClusterFileShareSecurityPage	m_page;

	// Generated message map functions
	//{{AFX_MSG(CFileShareSecuritySheet)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CExtObject *	Peo(void) const					{ return m_peo; }

};  //*** class CFileShareSecuritySheet

/////////////////////////////////////////////////////////////////////////////

#endif // _SMBSSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\aclhelp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       helpids.h
//
//  Contents:   Help context identifiers
//
//  History:    13-Sep-95 BruceFo  Created
//
//--------------------------------------------------------------------------

#define HC_OK                       1
#define HC_CANCEL                   2
#define HC_SHARE_SHARENAME          3
#define HC_SHARE_COMMENT            4
#define HC_SHARE_MAXIMUM            5
#define HC_SHARE_ALLOW              6
#define HC_SHARE_ALLOW_VALUE        7
#define HC_SHARE_PERMISSIONS        8
#define HC_SHARE_NOTSHARED          9
#define HC_SHARE_SHAREDAS           10
#define HC_SHARE_SHARENAME_COMBO    11
#define HC_SHARE_REMOVE             12
#define HC_SHARE_NEWSHARE           13
#define HC_SHARE_LIMIT              14

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

// The following are help ids for the ACL editor

// stolen from \nt\private\net\ui\common\h\uihelp.h
#define HC_UI_BASE              7000
#define HC_UI_SHELL_BASE        (HC_UI_BASE+10000)

// stolen from \nt\private\net\ui\shellui\h\helpnums.h
#define HC_NTSHAREPERMS              11 // Main share perm dialog
// The following four have to be consecutive
#define HC_SHAREADDUSER              12 // Share perm add dlg
#define HC_SHAREADDUSER_LOCALGROUP   13 // Share perm add->Members
#define HC_SHAREADDUSER_GLOBALGROUP  14 // Share perm add->Members
#define HC_SHAREADDUSER_FINDUSER     15 // Share perm add->FindUser
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\tracetag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		TraceTag.h
//
//	Abstract:
//		Dummy header file because we don't support trace tags in DLLs.
//
//	Author:
//		David Potter (davidp)	October 10, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _TRACETAG_H_
#define _TRACETAG_H_

class CTraceTag
{
public:
	CTraceTag(IN LPCTSTR pszSubsystem, IN LPCTSTR pszName, IN UINT uiFlagsDefault = NULL) {}

};  //*** class CTraceTag

 //			Expand to ";", <tab>, one "/" followed by another "/"
 //			(which is //).
 //			NOTE: This means the Trace statements have to be on ONE line.
 //			If you need multiple line Trace statements, enclose them in
 //			a #ifdef _DEBUG block.
 #define	Trace					;	/##/
#ifdef _DEBUG
 inline void TraceError(IN OUT CException & rexcept)		{ }
 inline void TraceError(IN LPCTSTR pszModule, IN DWORD sc)	{ }
 inline void TraceMenu(IN OUT CTraceTag & rtag, IN const CMenu * pmenu, IN LPCTSTR pszPrefix) { }
 inline void InitAllTraceTags(void)							{ }
 inline void CleanupAllTraceTags(void)						{ }
#else
 #define TraceError(_rexcept)
 #define TraceMenu(_rtag, _pmenu, _pszPrefix)
 #define InitAllTraceTags()
 #define CleanupAllTraceTags()
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\about.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		About.cpp
//
//	Abstract:
//		Implementation of the CAboutDlg class.
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "About.h"
#include "VerInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::CAboutDlg
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CAboutDlg::CAboutDlg(void) : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	m_strWarning = _T("");
	m_strProductTitle = _T("");
	m_strFileTitle = _T("");
	m_strVersion = _T("");
	m_strCopyright = _T("");
	//}}AFX_DATA_INIT

}  //*** CAboutDlg::CAboutDlg()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	DDX_Control(pDX, IDC_ABOUT_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_ABOUT_VERSION, m_staticVersion);
	DDX_Control(pDX, IDC_ABOUT_FILE_TITLE, m_staticFileTitle);
	DDX_Control(pDX, IDC_ABOUT_PRODUCT_TITLE, m_staticProductTitle);
	DDX_Control(pDX, IDC_ABOUT_WARNING, m_staticWarning);
	DDX_Control(pDX, IDC_ABOUT_COPYRIGHT, m_staticCopyright);
	DDX_Text(pDX, IDC_ABOUT_WARNING, m_strWarning);
	DDX_Text(pDX, IDC_ABOUT_PRODUCT_TITLE, m_strProductTitle);
	DDX_Text(pDX, IDC_ABOUT_FILE_TITLE, m_strFileTitle);
	DDX_Text(pDX, IDC_ABOUT_VERSION, m_strVersion);
	DDX_Text(pDX, IDC_ABOUT_COPYRIGHT, m_strCopyright);
	//}}AFX_DATA_MAP

}  //*** CAboutDlg::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CAboutDlg::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CAboutDlg::OnInitDialog(void)
{
	// Get the version info.
	try
	{
		CVersionInfo	verinfo;

		// Get the warning text.
		m_strWarning.LoadString(IDS_ABOUT_WARNING);

		// Initialize the version info.
		verinfo.Init();

		// Get strings from the version resource.
		m_strProductTitle = verinfo.PszQueryValue(_T("ProductName"));
		m_strFileTitle = verinfo.PszQueryValue(_T("FileDescription"));
		m_strCopyright = verinfo.PszQueryValue(_T("LegalCopyright"));

		// Get the version display string.
		verinfo.QueryFileVersionDisplayString(m_strVersion);
	}  // try
	catch (...)
	{
		// Who cares if an exception is thrown.  We're just displaying the about box.
	}  // catch:  anything

	// Call the base class method.
	CDialog::OnInitDialog();

	// Create fonts.
//	BCreateFont(m_fontProductTitle, 16, TRUE /*bBold*/);
//	BCreateFont(m_fontCopyright, 14, TRUE /*bBold*/);
//	BCreateFont(m_fontWarning, 4, FALSE /*bBold*/);

//	m_staticProductTitle.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticFileTitle.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticVersion.SetFont(&m_fontProductTitle, FALSE /*bRedraw*/);
//	m_staticCopyright.SetFont(&m_fontCopyright, FALSE /*bRedraw*/);
//	m_staticWarning.SetFont(&m_fontWarning, FALSE /*bRedraw*/);

	// Set the icon to the big cluster picture.
	{
		HICON	hicon;

		// Create huge image list.
		VERIFY(m_ilImages.Create(
					(int) 64,		// cx
					64,				// cy
					TRUE,			// bMask
					1,				// nInitial
					4				// nGrow
					));
		m_ilImages.SetBkColor(::GetSysColor(COLOR_WINDOW));

		// Load the images into the large image list.
		CClusterAdminApp::LoadImageIntoList(&m_ilImages, IDB_CLUSTER_64);

		hicon = m_ilImages.ExtractIcon(0);
		if (hicon != NULL)
			m_staticIcon.SetIcon(hicon);
	}  // Set the icon to the big cluster picture

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CAboutDlg::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\smbssht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998-1999 Microsoft Corporation
//
//	Module Name:
//		SmbSSht.cpp
//
//	Abstract:
//		Implementation of the CFileShareSecuritySheet class.
//
//	Author:
//		Galen Barbee	(galenb)	February 12, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "SmbSSht.h"
#include "AclUtils.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileShareSecuritySheet property page
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CFileShareSecuritySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CFileShareSecuritySheet)
	//}}AFX_MSG_MAP
	// TODO: Modify the following lines to represent the data displayed on this page.
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::CFileShareSecuritySheet
//
//	Routine Description:
//		constructor.
//
//	Arguments:
//		pParent			[IN]
//		strCaption		[IN]
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareSecuritySheet::CFileShareSecuritySheet(
	IN CWnd *			pParent,
	IN CString const &	strCaption
	) : CPropertySheet( strCaption, pParent ),
		m_peo( NULL ),
		m_ppp( NULL )
{
	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_INIT(CFileShareSecuritySheet)
	//}}AFX_DATA_INIT

}  //*** CFileShareSecuritySheet::CFileShareSecuritySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::~CFileShareSecuritySheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CFileShareSecuritySheet::~CFileShareSecuritySheet(
	void
	)
{
}  //*** CFileShareSecuritySheet::~CFileShareSecuritySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::HrInit
//
//	Routine Description:
//
//
//	Arguments:
//		ppp				[IN]
//		peo				[IN]
//		strNodeName		[IN]
//		strShareName	[IN]
//
//	Return Value:
//		hr
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CFileShareSecuritySheet::HrInit(
	IN CFileShareParamsPage*	ppp,
	IN CExtObject*				peo,
	IN CString const&			strNodeName,
	IN CString const&			strShareName
	)
{
	ASSERT( ppp != NULL );
	ASSERT( peo != NULL );

	HRESULT _hr = S_FALSE;

	if ( ( peo != NULL ) && ( ppp != NULL ) )
	{
		m_ppp			= ppp;
		m_peo			= peo;
		m_strNodeName	= strNodeName;
		m_strShareName	= strShareName;

		_hr = m_page.HrInit( peo, this, strNodeName );
	}

	return _hr;

}  //*** CFileShareSecuritySheet::HrInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareSecuritySheet::DoDataExchange(
	CDataExchange * pDX
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	// TODO: Modify the following lines to represent the data displayed on this page.
	//{{AFX_DATA_MAP(CFileShareSecuritySheet)
	//}}AFX_DATA_MAP

	CPropertySheet::DoDataExchange( pDX );

}  //*** CFileShareSecuritySheet::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		We need the focus to be set for us.
//		FALSE		We already set the focus to the proper control.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
CFileShareSecuritySheet::OnInitDialog(
	void
	)
{
	AFX_MANAGE_STATE( AfxGetStaticModuleState() );

	CPropertySheet::OnInitDialog();

	return TRUE;	// return TRUE unless you set the focus to a control
					// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CFileShareSecuritySheet::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::BuildPropPageArray
//
//	Routine Description:
//		Overridden from CPropertySheet.  Puts the security hpage into the
//		PROPSHEETHEADER before calling ::PropertySheet().
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void
CFileShareSecuritySheet::BuildPropPageArray(
	void
	)
{
	// delete existing prop page array
	delete[] (PROPSHEETPAGE*) m_psh.ppsp;						// delete any old PROPSHEETPAGEs
	m_psh.ppsp = NULL;

	// build new PROPSHEETPAGE array and coerce to an HPROPSHEETPAGE
	m_psh.phpage = (HPROPSHEETPAGE *) new PROPSHEETPAGE[1];

	m_psh.dwFlags	   &= ~PSH_PROPSHEETPAGE;					// ensure that the hpage is used
	m_psh.phpage[0]		= m_page.GetHPage();					// assign the hpage
	m_psh.nPages		= 1;

}  //*** CFileShareSecuritySheet::BuildPropPageArray()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CFileShareSecuritySheet::AssertValid
//
//	Routine Description:
//		Overridden from CPropertySheet.  Couldn't have an assertion that
//		the PROPSHEETHEADER was using phpage instead of pspp...
//		CPropertyPage::AssertValid() required that the flag PSH_PROPSHHETPAGE
//		be set.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void
CFileShareSecuritySheet::AssertValid(
	void
	) const
{
	CWnd::AssertValid();

	// NB: MFC is built using _WIN32_IE set to 0x0300.  Until MFC moves up
	// we cannot do the following checks because they don't align then
	// _WIN32_IE is set to 0x0400.
#if	( _WIN32_IE == 0x0300 )
		m_pages.AssertValid();
		ASSERT( m_psh.dwSize == sizeof( PROPSHEETHEADER ) );
#endif

}  //*** CFileShareSecuritySheet::AssertValid()
#endif	// _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmex\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#ifndef _UNICODE
#define _UNICODE            // Microsoft Windows NT Cluster Administrator
                            //   Extension DLLs need to be Unicode
                            //   applications.
#endif

// Choose which threading model you want by commenting or uncommenting
// the proper constant definition.  If you want multi-threading
// (i.e. "both"), comment both definitions out.  Also change the
// THREADFLAGS_xxx set in the DECLARE_REGISTRY macro invokation in ExtObj.h
//#define _ATL_SINGLE_THREADED
#define _ATL_APARTMENT_THREADED

// Link against the Microsoft Windows NT Cluster API library.
#pragma comment(lib, "clusapi.lib")

// Link against the Cluster Administrator Extensions library.
#pragma comment(lib, "cluadmex.lib")

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)     // unreferenced formal parameters
#pragma warning(disable : 4702)     // unreachable code
#pragma warning(disable : 4711)     // function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

// Need to include this for WM_COMMANDHELP.  Unfortunately, both afxpriv.h and
// atlconv.h define some of the same macros.  Since we are using ATL, we'll use
// the ATL versions.
#define __AFXCONV_H__
#include <afxpriv.h>
#undef __AFXCONV_H__
#undef DEVMODEW2A
#undef DEVMODEA2W
#undef TEXTMETRICW2A
#undef TEXTMETRICA2W

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <commctrl.h>

#ifndef _CLUSTER_API_
#include <clusapi.h>    // for cluster definitions
#endif

#include <resapi.h>

#ifndef _CLUSRTL_INCLUDED_
#include "clusrtl.h"
#endif

#ifndef _CLUSUDEF_H_
#include "clusudef.h"
#endif

#include <htmlhelp.h>
#include <lmshare.h>

#include <StrSafe.h>

/////////////////////////////////////////////////////////////////////////////
// Common Types
/////////////////////////////////////////////////////////////////////////////

typedef UINT    IDS;
typedef UINT    IDD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\about.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		About.h
//
//	Abstract:
//		Definition of the CAboutDlg class.
//
//	Implementation File:
//		About.cpp
//
//	Author:
//		David Potter (davidp)	October 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ABOUT_H_
#define _ABOUT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CAboutDlg;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg:
/////////////////////////////////////////////////////////////////////////////

class CAboutDlg : public CDialog
{
public:
	CAboutDlg(void);

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CStatic	m_staticIcon;
	CStatic	m_staticVersion;
	CStatic	m_staticFileTitle;
	CStatic	m_staticProductTitle;
	CStatic	m_staticWarning;
	CStatic	m_staticCopyright;
	CString	m_strWarning;
	CString	m_strProductTitle;
	CString	m_strFileTitle;
	CString	m_strVersion;
	CString	m_strCopyright;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CFont		m_fontProductTitle;
	CFont		m_fontCopyright;
	CFont		m_fontWarning;
    CImageList	m_ilImages;

	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CAboutDlg

/////////////////////////////////////////////////////////////////////////////

#endif // _ABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\actgrp.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ActGrp.h
//
//	Abstract:
//		Definition of the CActiveGroups class.
//
//	Implementation File:
//		ActGrp.cpp
//
//	Author:
//		David Potter (davidp)	November 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _ACTGRP_H_
#define _ACTGRP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CActiveGroups;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNode;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _TREEITEM_
#include "ClusItem.h"	// for CClusterItem
#endif

/////////////////////////////////////////////////////////////////////////////
// CActiveGroups command target
/////////////////////////////////////////////////////////////////////////////

class CActiveGroups : public CClusterItem
{
	DECLARE_DYNCREATE(CActiveGroups)

// Construction
public:
	CActiveGroups(void);			// protected constructor used by dynamic creation

	void					Init(
								IN OUT CClusterDoc *	pdoc,
								IN LPCTSTR				lpszName,
								IN OUT CClusterNode *	pciNode
								);

// Attributes
protected:
	CClusterNode *			m_pciNode;

public:
	CClusterNode *			PciNode(void) const			{ return m_pciNode; }

// Operations

// Overrides
public:
	virtual void			Cleanup(void);

	// Drag & Drop
	virtual BOOL			BCanBeDropTarget(IN const CClusterItem * pci) const;
	virtual void			DropItem(IN OUT CClusterItem * pci);

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActiveGroups)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CActiveGroups(void) { Cleanup(); }

public:
	// Generated message map functions
	//{{AFX_MSG(CActiveGroups)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CActiveGroups

/////////////////////////////////////////////////////////////////////////////

#endif // _ACTGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\actgrp.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		ActGrp.cpp
//
//	Abstract:
//		Implementation of the CActiveGroups class.
//
//	Author:
//		David Potter (davidp)	November 24, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ActGrp.h"
#include "Group.h"
#include "Node.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CActiveGroups
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CActiveGroups, CClusterItem)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CActiveGroups, CClusterItem)
	//{{AFX_MSG_MAP(CActiveGroups)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::CActiveGroups
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CActiveGroups::CActiveGroups(void) : CClusterItem(NULL, IDS_ITEMTYPE_CONTAINER)
{
	m_pciNode = NULL;
	m_bDocObj = FALSE;

}  //*** CActiveGroups::CActiveGroups()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::Cleanup
//
//	Routine Description:
//		Cleanup the item.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//	Exceptions Thrown:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::Cleanup(void)
{
	// If we have been initialized, release our pointer to the node.
	if (PciNode() != NULL)
	{
		PciNode()->Release();
		m_pciNode = NULL;
	}  // if:  there is an owner

}  //*** CActiveGroups::Cleanup()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::Init
//
//	Routine Description:
//		Initialize the item.
//
//	Arguments:
//		pdoc		[IN OUT] Document to which this item belongs.
//		lpszName	[IN] Name of the item.
//		pciNode		[IN OUT] Node to which this container belongs.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::Init(
	IN OUT CClusterDoc *	pdoc,
	IN LPCTSTR				lpszName,
	IN OUT CClusterNode *	pciNode
	)
{
	// Call the base class method.
	CClusterItem::Init(pdoc, lpszName);

	// Add a reference to the node.
	ASSERT(pciNode != NULL);
	ASSERT(m_pciNode == NULL);
	m_pciNode = pciNode;
	m_pciNode->AddRef();

}  //*** CActiveGroups::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::BCanBeDropTarget
//
//	Routine Description:
//		Determine if the specified item can be dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item to be dropped on this item.
//
//	Return Value:
//		TRUE		Can be drop target.
//		FALSE		Can NOT be drop target.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CActiveGroups::BCanBeDropTarget(IN const CClusterItem * pci) const
{
	ASSERT(PciNode() != NULL);
	return PciNode()->BCanBeDropTarget(pci);

}  //*** CActiveGroups::BCanBeDropTarget()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CActiveGroups::DropItem
//
//	Routine Description:
//		Process an item being dropped on this item.
//
//	Arguments:
//		pci			[IN OUT] Item dropped on this item.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CActiveGroups::DropItem(IN OUT CClusterItem * pci)
{
	ASSERT(PciNode() != NULL);
	PciNode()->DropItem(pci);

}  //*** CActiveGroups::DropItem()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barf.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Barf.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure classes.
//		BARF allows API call failures to be simulated automatically to
//		ensure full code test coverage.
//
//	Implementation File:
//		Barf.cpp
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARF_H_
#define _BARF_H_

// Only process the rest of this file if BARF is to be implemented in the
// including module.
//#ifndef _NO_BARF_DEFINITIONS_
//#define _USING_BARF_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarf;
class CBarfSuspend;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CTraceTag;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define BARF_REG_SECTION		_T("Debug\\BARF")
#define BARF_REG_SECTION_FMT	BARF_REG_SECTION _T("\\%s")

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	CBarf
//
//	Purpose:
//		Basic Artificial Resource Failure class.  Contains the BARF
//		information for a class of calls
//
//		The constructor initializes a bunch of parameters.  CBarfDialog
//		(a friend class) adjusts the various flags.  The only public API
//		is FFail().  This method determines if the next call should generate
//		an artificial failure or not.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG

typedef void (*PFNBARFPOSTUPDATE)(void);

class CBarf : public CObject
{
	friend class CBarfSuspend;
	friend class CBarfDialog;
	friend void  InitBarf(void);
	friend void  CleanupBarf(void);
	friend void  EnableBarf(BOOL);
	friend void  BarfAll(void);
	friend void  DoBarfDialog(void);

public:
	CBarf(IN LPCTSTR pszName);

protected:
	void Init(void);

// Attributes
protected:
	LPCTSTR			m_pszName;

	BOOL			m_bDisabled;
	BOOL			m_bContinuous;
	DWORD			m_nFail;
	DWORD			m_nCurrent;
	DWORD			m_nCurrentSave;
	DWORD			m_nBarfAll;

public:
	LPCTSTR			PszName(void) const					{ return m_pszName; }
	BOOL			BDisabled(void) const				{ return m_bDisabled; }
	BOOL			BContinuous(void) const				{ return m_bContinuous; }
	DWORD			NFail(void) const					{ return m_nFail; }
	DWORD			NCurrent(void) const				{ return m_nCurrent; }
	DWORD			NCurrentSave(void) const			{ return m_nCurrentSave; }
	DWORD			NBarfAll(void) const				{ return m_nBarfAll; }

// Operations
public:
	BOOL			BFail(void);

// Implementation
public:
	static PVOID	PvSpecialMem(void)					{ return s_pvSpecialMem; }

protected:
	static CBarf *  s_pbarfFirst;
	CBarf *			m_pbarfNext;

	static LONG     s_nSuspend;
	static BOOL     s_bGlobalEnable;

	// Routine for use by the BARF dialog so that it can be
	// automatically updated with results of the BARF run.
	static PFNBARFPOSTUPDATE	s_pfnPostUpdate;
	static void					SetPostUpdateFn(IN PFNBARFPOSTUPDATE pfn)	{ ASSERT(pfn != NULL); s_pfnPostUpdate = pfn; }
	static void					ClearPostUpdateFn(void)						{ ASSERT(s_pfnPostUpdate != NULL); s_pfnPostUpdate = NULL; }
	static PFNBARFPOSTUPDATE	PfnPostUpdate(void)							{ return s_pfnPostUpdate; }

	// Pointer for use by the memory subsystem so that the BARF
	// dialog can be ignored.
	static PVOID				s_pvSpecialMem;
	static void					SetSpecialMem(IN PVOID pv)					{ ASSERT(pv != NULL); s_pvSpecialMem = pv; }

};  //*** class CBarf

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfSuspend
//
//	Purpose:
//		Temporarily suspends BARF counters.  This is especially useful
//		from within BARF code.
//
//	Usage:
//		Create an object on the stack. Counting will be
//		suspended while the object exist.
//
//		For example:
//
//		void Foo(void)
//		{
//			DoFuncA();		// BARF counters are enabled
//
//			{
//				CBarfSuspend bs;
//
//				DoFuncB();	// BARF counters are suspended
//			}
//
//			DoFuncC();		// BARF counters are enabled again
//		}
//
//		NOTE:	This is mostly for use within the DEBUG subsystem
//				to avoid testing the DEBUG code against BARF.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef	_DEBUG

class CBarfSuspend
{
private:
	static	CRITICAL_SECTION	s_critsec;
	static	BOOL				s_bCritSecValid;

protected:
	static	PCRITICAL_SECTION	Pcritsec(void)		{ return &s_critsec; }
	static	BOOL				BCritSecValid(void)	{ return s_bCritSecValid; }

public:
	CBarfSuspend(void);
	~CBarfSuspend(void);

	// for initialization only.
	static	void		Init(void);
	static	void		Cleanup(void);

};  //*** class CBarfSuspend

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 extern BOOL g_bFailOnNextBarf;

 void EnableBarf(IN BOOL bEnable);
 inline void FailOnNextBarf(void)		{ g_bFailOnNextBarf = TRUE; }
 void InitBarf(void);
 void CleanupBarf(void);

 extern CTraceTag g_tagBarf;

#else

 inline void EnableBarf(IN BOOL bEnable)	{ }
 inline void FailOnNextBarf(void)			{ }
 inline void InitBarf(void)					{ }
 inline void CleanupBarf(void)				{ }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

//#endif // _NO_BARF_DEFINITIONS_
#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barf.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Barf.cpp
//
//	Abstract:
//		Implementation of the Basic Artifical Resource Failure classes.
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef	_USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG	// The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

BOOL		g_bFailOnNextBarf	= FALSE;

CTraceTag	g_tagBarf(_T("Debug"), _T("BARF Failures"), CTraceTag::tfDebug);


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarf
/////////////////////////////////////////////////////////////////////////////

BOOL				CBarf::s_bGlobalEnable	= TRUE;
LONG				CBarf::s_nSuspend		= 0;
CBarf *				CBarf::s_pbarfFirst		= NULL;
PFNBARFPOSTUPDATE	CBarf::s_pfnPostUpdate	= NULL;
PVOID				CBarf::s_pvSpecialMem	= NULL;


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarf::CBarf
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pszName			[IN] Name of the set of APIs to BARF.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarf::CBarf(IN LPCTSTR pszName)
{
	ASSERT(pszName != NULL);

	m_pszName = pszName;

	m_bDisabled = FALSE;
	m_bContinuous = FALSE;
	m_nFail = 0;
	m_nCurrent = 0;

	m_pbarfNext = s_pbarfFirst;
	s_pbarfFirst = this;

}  //*** CBarf::CBarf()


/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarf::Init
//
//	Routine Description:
//		Initializes the BARF counters instance by giving it its name and
//		giving it a startup value (from the registry if possible).
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarf::Init(void)
{
	CString		strSection;
	CString		strValue;

	strSection.Format(BARF_REG_SECTION_FMT, m_pszName);

	m_bDisabled = AfxGetApp()->GetProfileInt(strSection, _T("Disabled"), FALSE);
	m_bContinuous = AfxGetApp()->GetProfileInt(strSection, _T("Continuous"), FALSE);
	m_nFail = AfxGetApp()->GetProfileInt(strSection, _T("Fail"), 0);

}  //*** CBarf::Init()

/////////////////////////////////////////////////////////////////////////////
//
//	CBarf::BFail
//
//	Routine Description:
//		Determines if the next call should artificially fail.
//		Typical usage of this method is:
//			BOOL BARFFoo( void )
//			{
//				if (barfMyApi.BFail())
//					return FALSE;
//				else
//					return Foo();
//			}
//
//	Return value:
//		bFail	TRUE indicates the call should be made to
//				artificially fail.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CBarf::BFail(void)
{
	BOOL	bFail	= FALSE;

	// If BARF is suspended, don't artificially fail.
	// Otherwise, check the counters.
	if (s_nSuspend == 0)
	{
		// Increment the call count.
		m_nCurrent++;

		// Call the post-update routine to allow UI to be updated.
		if (PfnPostUpdate())
			((*PfnPostUpdate())());

		// If not disable and not globally disabled, keep checking.
		if (!m_bDisabled && s_bGlobalEnable)
		{
			// If in continuous fail mode, check to see if the counters
			// are above the specified range.  Otherwise check to see if
			// the counter is exactly the same as what was specified.
			if (m_bContinuous)
			{
				if (m_nCurrent >= m_nFail)
					bFail = TRUE;
			}  // if:  in continuous fail mode
			else
			{
				if (m_nCurrent == m_nFail)
					bFail = TRUE;
			}  // else:  not in continuous fail mode

			// If this API set was marked to fail on the next (this) call,
			// fail the call and reset the marker.
			if (g_bFailOnNextBarf)
			{
				bFail = TRUE;
				g_bFailOnNextBarf = FALSE;
			}  // if:  counters marked to fail on next (this) call
		}  // if:  not disabled and globally enabled
	}  // if:  not suspended

	return bFail;
	
}  //*** CBarf::BFail()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfSuspend
/////////////////////////////////////////////////////////////////////////////

CRITICAL_SECTION	CBarfSuspend::s_critsec;
BOOL				CBarfSuspend::s_bCritSecValid = FALSE;

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::CBarfSuspend
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfSuspend::CBarfSuspend(void)
{
	if (BCritSecValid())
		EnterCriticalSection(Pcritsec());

	CBarf::s_nSuspend++;

	if (BCritSecValid())
		LeaveCriticalSection(Pcritsec());

}  //*** CBarfSuspend::CBarfSuspend()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::~CBarfSuspend
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfSuspend::~CBarfSuspend(void)
{
	if (BCritSecValid())
		EnterCriticalSection(Pcritsec());

	CBarf::s_nSuspend--;
	ASSERT(CBarf::s_nSuspend >= 0);

	if (BCritSecValid())
		LeaveCriticalSection(Pcritsec());

}  //*** CBarfSuspend::~CBarfSuspend()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::Init
//
//	Routine Description:
//		Initialize the class.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfSuspend::Init(void)
{
	InitializeCriticalSection(Pcritsec());
	s_bCritSecValid = TRUE;

}  //*** CBarfSuspend::Init()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBarfSuspend::Cleanup
//
//	Routine Description:
//		Initialize the class.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfSuspend::Cleanup(void)
{
	if (BCritSecValid())
	{
		DeleteCriticalSection(Pcritsec());
		s_bCritSecValid = FALSE;
	}  // if:  critical section is valid

}  //*** CBarfSuspend::Cleanup()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//	InitBarf
//
//	Routine Description:
//		Initializes all BARF counters in the BARF list.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void InitBarf(void)
{
	CBarf *	pbarf;

	// Loop through the BARF counter list.
	for (pbarf = CBarf::s_pbarfFirst ; pbarf != NULL ; pbarf = pbarf->m_pbarfNext)
		pbarf->Init();

	CBarfSuspend::Init();

}  //*** InitBarf()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CleanupBarf
//
//	Routine Description:
//		Cleanup after BARF.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CleanupBarf(void)
{
	CBarfSuspend::Cleanup();

}  //*** CleanupBarf()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	EnableBarf
//
//	Routine Description:
//		Allows user code to enable/disable BARF for sections of code.
//
//	Arguments:
//		bEnable		[IN] TRUE = enable BARF, FALSE = disable BARF.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void EnableBarf(IN BOOL bEnable)
{
	if (bEnable)
		Trace(g_tagBarf, _T("Artificial Failures enabled"));
	else
		Trace(g_tagBarf, _T("Artificial Failures disabled"));

	CBarf::s_bGlobalEnable = bEnable;

}  //*** EnableBarf()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barfclus.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Implementation File:
//		BarfClus.cpp
//
//	Author:
//		David Potter (davidp)	April 14, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFCLUS_H_
#define _BARFCLUS_H_

// Only process the rest of this file if BARF is to be implemented in the
// including module.
#ifndef _NO_BARF_DEFINITIONS_
#define _USING_BARF_

#ifdef _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Cluster Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseCluster
#define		CloseCluster(_hCluster) BARFCloseCluster(_hCluster)
BOOL		BARFCloseCluster(HCLUSTER hCluster);

#undef		CloseClusterNotifyPort
#define		CloseClusterNotifyPort(_hChange) BARFCloseClusterNotifyPort(_hChange)
BOOL		BARFCloseClusterNotifyPort(HCHANGE hChange);

#undef		ClusterCloseEnum
#define		ClusterCloseEnum(_hClusEnum) BARFClusterCloseEnum(_hClusEnum)
DWORD		BARFClusterCloseEnum(HCLUSENUM hClusEnum);

#undef		ClusterEnum
#define		ClusterEnum(_hClusEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterEnum(_hClusEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterEnum(HCLUSENUM hClusEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterOpenEnum
#define		ClusterOpenEnum(_hCluster, _dwType) BARFClusterOpenEnum(_hCluster, _dwType)
HCLUSENUM	BARFClusterOpenEnum(HCLUSTER hCluster, DWORD dwType);

#undef		ClusterResourceTypeControl
#define		ClusterResourceTypeControl(_hCluster, _lpszResourceTypeName, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterResourceTypeControl(_hCluster, _lpszResourceTypeName, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterResourceTypeControl(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		CreateClusterNotifyPort
#define		CreateClusterNotifyPort(_hChange, _hCluster, _dwFilter, _dwNotifyKey) BARFCreateClusterNotifyPort(_hChange, _hCluster, _dwFilter, _dwNotifyKey)
HCHANGE		BARFCreateClusterNotifyPort(HCHANGE hChange, HCLUSTER hCluster, DWORD dwFilter, DWORD_PTR dwNotifyKey);

#undef		CreateClusterResourceType
#define		CreateClusterResourceType(_hCluster, _lpszResourceTypeName, _lpszDisplayName, _lpszResourceTypeDll, _dwLooksAlivePollInterval, _dwIsAlivePollInterval) BARFCreateClusterResourceType(_hCluster, _lpszResourceTypeName, _lpszDisplayName, _lpszResourceTypeDll, _dwLooksAlivePollInterval, _dwIsAlivePollInterval)
DWORD		BARFCreateClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName, LPCWSTR lpszDisplayName, LPCWSTR lpszResourceTypeDll, DWORD dwLooksAlivePollInterval, DWORD dwIsAlivePollInterval);

#undef		DeleteClusterResourceType
#define		DeleteClusterResourceType(_hCluster, _lpszResourceTypeName) BARFDeleteClusterResourceType(_hCluster, _lpszResourceTypeName)
DWORD		BARFDeleteClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName);

#undef		GetClusterInformation
#define		GetClusterInformation(_hCluster, _lpszClusterName, _lpcchClusterName, _lpClusterInfo) BARFGetClusterInformation(_hCluster, _lpszClusterName, _lpcchClusterName, _lpClusterInfo)
DWORD		BARFGetClusterInformation(HCLUSTER hCluster, LPWSTR lpszClusterName, LPDWORD lpcchClusterName, LPCLUSTERVERSIONINFO lpClusterInfo);

#undef		GetClusterNotify
#define		GetClusterNotify(_hChange, _lpdwNotifyKey, _lpdwFilterType, _lpszName, _lpcchName, _dwMilliseconds) BARFGetClusterNotify(_hChange, _lpdwNotifyKey, _lpdwFilterType, _lpszName, _lpcchName, _dwMilliseconds)
DWORD		BARFGetClusterNotify(HCHANGE hChange, DWORD_PTR *lpdwNotifyKey, LPDWORD lpdwFilterType, LPWSTR lpszName, LPDWORD lpcchName, DWORD dwMilliseconds);

#undef		GetClusterQuorumResource
#define		GetClusterQuorumResource(_hCluster, _lpszResourceName, _lpcbResourceName, _lpszDeviceName, _lpcbDeviceName, _lpdwMaxQuorumLogSize) BARFGetClusterQuorumResource(_hCluster, _lpszResourceName, _lpcbResourceName, _lpszDeviceName, _lpcbDeviceName, _lpdwMaxQuorumLogSize)
DWORD		BARFGetClusterQuorumResource(HCLUSTER hCluster, LPWSTR lpszResourceName, LPDWORD lpcbResourceName, LPWSTR lpszDeviceName, LPDWORD lpcbDeviceName, LPDWORD lpdwMaxQuorumLogSize);

#undef		OpenCluster
#define		OpenCluster(_lpszClusterName) BARFOpenCluster(_lpszClusterName)
HCLUSTER	BARFOpenCluster(LPCWSTR lpszClusterName);

#undef		RegisterClusterNotify
#define		RegisterClusterNotify(_hChange, _dwFilter, _hObject, _dwNotifyKey) BARFRegisterClusterNotify(_hChange, _dwFilter, _hObject, _dwNotifyKey)
DWORD		BARFRegisterClusterNotify(HCHANGE hChange, DWORD dwFilter, HANDLE hObject, DWORD_PTR dwNotifyKey);

#undef		SetClusterName
#define		SetClusterName(_hCluster, _lpszNewClusterName) BARFSetClusterName(_hCluster, _lpszNewClusterName)
DWORD		BARFSetClusterName(HCLUSTER hCluster, LPCWSTR lpszNewClusterName);

#undef		SetClusterQuorumResource
#define		SetClusterQuorumResource(_hResource, _lpszDeviceName, _dwMazQuoLogSize) BARFSetClusterQuorumResource(_hResource, _lpszDeviceName, _dwMazQuoLogSize)
DWORD		BARFSetClusterQuorumResource(HRESOURCE hResource, LPCWSTR lpszDeviceName, DWORD dwMaxQuoLogSize);

/////////////////////////////////////////////////////////////////////////////
// Node Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseClusterNode
#define		CloseClusterNode(_hNode) BARFCloseClusterNode(_hNode)
BOOL		BARFCloseClusterNode(HNODE hNode);

#undef		ClusterNodeControl
#define		ClusterNodeControl(_hNode, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNodeControl(_hNode, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNodeControl(HNODE hNode, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		EvictClusterNode
#define		EvictClusterNode(_hNode) BARFEvictClusterNode(_hNode)
DWORD		BARFEvictClusterNode(HNODE hNode);

#undef		GetClusterNodeId
#define		GetClusterNodeId(_hNode, _lpszNodeId, _lpcchNodeId) BARFGetClusterNodeId(_hNode, _lpszNodeId, _lpcchNodeId)
DWORD		BARFGetClusterNodeId(HNODE hNode, LPWSTR lpszNodeId, LPDWORD lpcchNodeId);

#undef		GetClusterNodeState
#define		GetClusterNodeState(_hNode) BARFGetClusterNodeState(_hNode)
CLUSTER_NODE_STATE BARFGetClusterNodeState(HNODE hNode);

#undef		OpenClusterNode
#define		OpenClusterNode(_hCluster, _lpszNodeName) BARFOpenClusterNode(_hCluster, _lpszNodeName)
HNODE		BARFOpenClusterNode(HCLUSTER hCluster, LPCWSTR lpszNodeName);

#undef		PauseClusterNode
#define		PauseClusterNode(_hNode) BARFPauseClusterNode(_hNode)
DWORD		BARFPauseClusterNode(HNODE hNode);

#undef		ResumeClusterNode
#define		ResumeClusterNode(_hNode) BARFResumeClusterNode(_hNode)
DWORD		BARFResumeClusterNode(HNODE hNode);

/////////////////////////////////////////////////////////////////////////////
// Group Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		CloseClusterGroup
#define		CloseClusterGroup(_hGroup) BARFCloseClusterGroup(_hGroup)
BOOL		BARFCloseClusterGroup(HGROUP hGroup);

#undef		ClusterGroupCloseEnum
#define		ClusterGroupCloseEnum(_hGroupEnum) BARFClusterGroupCloseEnum(_hGroupEnum)
DWORD		BARFClusterGroupCloseEnum(HGROUPENUM hGroupEnum);

#undef		ClusterGroupControl
#define		ClusterGroupControl(_hGroup, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterGroupControl(_hGroup, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterGroupControl(HGROUP hGroup, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		ClusterGroupEnum
#define		ClusterGroupEnum(_hGroupEnum, _dwIndex, _lpdwType, _lpszResourceName, _lpcchName) BARFClusterGroupEnum(_hGroupEnum, _dwIndex, _lpdwType, _lpszResourceName, _lpcchName)
DWORD		BARFClusterGroupEnum(HGROUPENUM hGroupEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszResourceName, LPDWORD lpcchName);

#undef		ClusterGroupOpenEnum
#define		ClusterGroupOpenEnum(_hGroup, _dwType) BARFClusterGroupOpenEnum(_hGroup, _dwType)
HGROUPENUM	BARFClusterGroupOpenEnum(HGROUP hGroup, DWORD dwType);

#undef		CreateClusterGroup
#define		CreateClusterGroup(_hCluster, _lpszGroupName) BARFCreateClusterGroup(_hCluster, _lpszGroupName)
HGROUP		BARFCreateClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName);

#undef		DeleteClusterGroup
#define		DeleteClusterGroup(_hGroup) BARFDeleteClusterGroup(_hGroup)
DWORD		BARFDeleteClusterGroup(HGROUP hGroup);

#undef		GetClusterGroupState
#define		GetClusterGroupState(_hGroup, _lpszNodeName, _lpcchNodeName) BARFGetClusterGroupState(_hGroup, _lpszNodeName, _lpcchNodeName)
CLUSTER_GROUP_STATE BARFGetClusterGroupState(HGROUP hGroup, LPWSTR lpszNodeName, LPDWORD lpcchNodeName);

#undef		MoveClusterGroup
#define		MoveClusterGroup(_hGroup, _hDestinationNode) BARFMoveClusterGroup(_hGroup, _hDestinationNode)
DWORD		BARFMoveClusterGroup(HGROUP hGroup, HNODE hDestinationNode);

#undef		OfflineClusterGroup
#define		OfflineClusterGroup(_hGroup) BARFOfflineClusterGroup(_hGroup)
DWORD		BARFOfflineClusterGroup(HGROUP hGroup);

#undef		OnlineClusterGroup
#define		OnlineClusterGroup(_hGroup, _hDestinationNode) BARFOnlineClusterGroup(_hGroup, _hDestinationNode)
DWORD		BARFOnlineClusterGroup(HGROUP hGroup, HNODE hDestinationNode);

#undef		OpenClusterGroup
#define		OpenClusterGroup(_hCluster, _lpszGroupName) BARFOpenClusterGroup(_hCluster, _lpszGroupName)
HGROUP		BARFOpenClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName);

#undef		SetClusterGroupName
#define		SetClusterGroupName(_hGroup, _lpszGroupName) BARFSetClusterGroupName(_hGroup, _lpszGroupName)
DWORD		BARFSetClusterGroupName(HGROUP hGroup, LPCWSTR lpszGroupName);

#undef		SetClusterGroupNodeList
#define		SetClusterGroupNodeList(_hGroup, _cNodeCount, _phNodeList) BARFSetClusterGroupNodeList(_hGroup, _cNodeCount, _phNodeList)
DWORD		BARFSetClusterGroupNodeList(HGROUP hGroup, DWORD cNodeCount, HNODE phNodeList[]);

/////////////////////////////////////////////////////////////////////////////
// Resource Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		AddClusterResourceDependency
#define		AddClusterResourceDependency(_hResource, _hDependsOn) BARFAddClusterResourceDependency(_hResource, _hDependsOn)
DWORD		BARFAddClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn);

#undef		AddClusterResourceNode
#define		AddClusterResourceNode(_hResource, _hNode) BARFAddClusterResourceNode(_hResource, _hNode)
DWORD		BARFAddClusterResourceNode(HRESOURCE hResource, HNODE hNode);

#undef		CanResourceBeDependent
#define		CanResourceBeDependent(_hResource, _hResourceDependent) BARFCanResourceBeDependent(_hResource, _hResourceDependent)
BOOL		BARFCanResourceBeDependent(HRESOURCE hResource, HRESOURCE hResourceDependent);

#undef		ChangeClusterResourceGroup
#define		ChangeClusterResourceGroup(_hResource, _hGroup) BARFChangeClusterResourceGroup(_hResource, _hGroup)
DWORD		BARFChangeClusterResourceGroup(HRESOURCE hResource, HGROUP hGroup);

#undef		CloseClusterResource
#define		CloseClusterResource(_hResource) BARFCloseClusterResource(_hResource)
BOOL		BARFCloseClusterResource(HRESOURCE hResource);

#undef		ClusterResourceCloseEnum
#define		ClusterResourceCloseEnum(_hResEnum) BARFClusterResourceCloseEnum(_hResEnum)
DWORD		BARFClusterResourceCloseEnum(HRESENUM hResEnum);

#undef		ClusterResourceControl
#define		ClusterResourceControl(_hResource, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterResourceControl(_hResource, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterResourceControl(HRESOURCE hResource, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

#undef		ClusterResourceEnum
#define		ClusterResourceEnum(_hResEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterResourceEnum(_hResEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterResourceEnum(HRESENUM hResEnum, DWORD dwIndex, LPDWORD lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterResourceOpenEnum
#define		ClusterResourceOpenEnum(_hResource, _dwType) BARFClusterResourceOpenEnum(_hResource, _dwType)
HRESENUM	BARFClusterResourceOpenEnum(HRESOURCE hResource, DWORD dwType);

#undef		CreateClusterResource
#define		CreateClusterResource(_hGroup, _lpszResourceName, _lpszResourceType, _dwFlags) BARFCreateClusterResource(_hGroup, _lpszResourceName, _lpszResourceType, _dwFlags)
HRESOURCE	BARFCreateClusterResource(HGROUP hGroup, LPCWSTR lpszResourceName, LPCWSTR lpszResourceType, DWORD dwFlags);

#undef		DeleteClusterResource
#define		DeleteClusterResource(_hResource) BARFDeleteClusterResource(_hResource)
DWORD		BARFDeleteClusterResource(HRESOURCE hResource);

#undef		FailClusterResource
#define		FailClusterResource(_hResource) BARFFailClusterResource(_hResource)
DWORD		BARFFailClusterResource(HRESOURCE hResource);

#undef		GetClusterResourceNetworkName
#define		GetClusterResourceNetworkName(_hResource, _lpBuffer, _nSize) BARFGetClusterResourceNetworkName(_hResource, _lpBuffer, _nSize)
BOOL		BARFGetClusterResourceNetworkName(HRESOURCE hResource, LPWSTR lpBuffer, LPDWORD nSize);

#undef		GetClusterResourceState
#define		GetClusterResourceState(_hResource, _lpszNodeName, _lpcchNodeName, _lpszGroupName, _lpcchGroupName) BARFGetClusterResourceState(_hResource, _lpszNodeName, _lpcchNodeName, _lpszGroupName, _lpcchGroupName)
CLUSTER_RESOURCE_STATE BARFGetClusterResourceState(HRESOURCE hResource, LPWSTR lpszNodeName, LPDWORD lpcchNodeName, LPWSTR lpszGroupName, LPDWORD lpcchGroupName);

#undef		OfflineClusterResource
#define		OfflineClusterResource(_hResource) BARFOfflineClusterResource(_hResource)
DWORD		BARFOfflineClusterResource(HRESOURCE hResource);

#undef		OnlineClusterResource
#define		OnlineClusterResource(_hResource) BARFOnlineClusterResource(_hResource)
DWORD		BARFOnlineClusterResource(HRESOURCE hResource);

#undef		OpenClusterResource
#define		OpenClusterResource(_hCluster, _lpszResourceName) BARFOpenClusterResource(_hCluster, _lpszResourceName)
HRESOURCE	BARFOpenClusterResource(HCLUSTER hCluster, LPCWSTR lpszResourceName);

#undef		RemoveClusterResourceNode
#define		RemoveClusterResourceNode(_hResource, _hNode) BARFRemoveClusterResourceNode(_hResource, _hNode)
DWORD		BARFRemoveClusterResourceNode(HRESOURCE hResource, HNODE hNode);

#undef		RemoveClusterResourceDependency
#define		RemoveClusterResourceDependency(_hResource, _hDependsOn) BARFRemoveClusterResourceDependency(_hResource, _hDependsOn)
DWORD		BARFRemoveClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn);

#undef		SetClusterResourceName
#define		SetClusterResourceName(_hResource, _lpszResourceName) BARFSetClusterResourceName(_hResource, _lpszResourceName)
DWORD		BARFSetClusterResourceName(HRESOURCE hResource, LPCWSTR lpszResourceName);

/////////////////////////////////////////////////////////////////////////////
// Network Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		OpenClusterNetwork
#define		OpenClusterNetwork(_hCluster, _lpszNetworkName) BARFOpenClusterNetwork(_hCluster, _lpszNetworkName)
HNETWORK	BARFOpenClusterNetwork(HCLUSTER hCluster, LPCWSTR lpszNetworkName);

#undef		CloseClusterNetwork
#define		CloseClusterNetwork(_hNetwork) BARFCloseClusterNetwork(_hNetwork)
BOOL		BARFCloseClusterNetwork(HNETWORK hNetwork);

#undef		ClusterNetworkOpenEnum
#define		ClusterNetworkOpenEnum(_hNetwork, _dwType) BARFClusterNetworkOpenEnum(_hNetwork, _dwType)
HNETWORKENUM BARFClusterNetworkOpenEnum(HNETWORK hNetwork, DWORD dwType);

#undef		ClusterNetworkEnum
#define		ClusterNetworkEnum(_hNetworkEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName) BARFClusterNetworkEnum(_hNetworkEnum, _dwIndex, _lpdwType, _lpszName, _lpcchName)
DWORD		BARFClusterNetworkEnum(HNETWORKENUM hNetworkEnum, DWORD dwIndex, DWORD * lpdwType, LPWSTR lpszName, LPDWORD lpcchName);

#undef		ClusterNetworkCloseEnum
#define		ClusterNetworkCloseEnum(_hNetworkEnum) BARFClusterNetworkCloseEnum(_hNetworkEnum)
DWORD		BARFClusterNetworkCloseEnum(HNETWORKENUM hNetworkEnum);

#undef		GetClusterNetworkState
#define		GetClusterNetworkState(_hNetwork) BARFGetClusterNetworkState(_hNetwork)
CLUSTER_NETWORK_STATE BARFGetClusterNetworkState(HNETWORK hNetwork);

#undef		SetClusterNetworkName
#define		SetClusterNetworkName(_hNetwork, _lpszName) BARFSetClusterNetworkName(_hNetwork, _lpszName)
DWORD		BARFSetClusterNetworkName(HNETWORK hNetwork, LPCWSTR lpszName);

#undef		ClusterNetworkControl
#define		ClusterNetworkControl(_hNetwork, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNetworkControl(_hNetwork, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNetworkControl(HNETWORK hNetwork, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

/////////////////////////////////////////////////////////////////////////////
// Network Interface Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		OpenClusterNetInterface
#define		OpenClusterNetInterface(_hCluster, _lpszInterfaceName) BARFOpenClusterNetInterface(_hCluster, _lpszInterfaceName)
HNETINTERFACE BARFOpenClusterNetInterface(HCLUSTER hCluster, LPCWSTR lpszInterfaceName);

#undef		GetClusterNetInterface
#define		GetClusterNetInterface(_hCluster, _lpszNodeName, _lpszNetworkName, _lpszNetInterfaceName, _lpcchNetInterfaceName) BARFGetClusterNetInterface(_hCluster, _lpszNodeName, _lpszNetworkName, _lpszNetInterfaceName, _lpcchNetInterfaceName)
HNETINTERFACE BARFGetClusterNetInterface(HCLUSTER hCluster, LPCWSTR lpszNodeName, LPCWSTR lpszNetworkName, LPWSTR lpszNetInterfaceName, DWORD * lpcchNetInterfaceName);

#undef		CloseClusterNetInterface
#define		CloseClusterNetInterface(_hNetInterface) BARFCloseClusterNetInterface(_hNetInterface)
BOOL		BARFCloseClusterNetInterface(HNETINTERFACE hNetInterface);

#undef		GetClusterNetInterfaceState
#define		GetClusterNetInterfaceState(_hNetInterface) BARFGetClusterNetInterfaceState(_hNetInterface)
CLUSTER_NETINTERFACE_STATE BARFGetClusterNetInterfaceState(HNETINTERFACE hNetInterface);

#undef		ClusterNetInterfaceControl
#define		ClusterNetInterfaceControl(_hNetInterface, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned) BARFClusterNetInterfaceControl(_hNetInterface, _hHostNode, _dwControlCode, _lpInBuffer, _nInBufferSize, _lpOutBuffer, _nOutBufferSize, _lpBytesReturned)
DWORD		BARFClusterNetInterfaceControl(HNETINTERFACE hNetInterface, HNODE hHostNode, DWORD dwControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned);

/////////////////////////////////////////////////////////////////////////////
// Cluster Database Management Functions
/////////////////////////////////////////////////////////////////////////////

#undef		ClusterRegCloseKey
#define		ClusterRegCloseKey(_hKey) BARFClusterRegCloseKey(_hKey)
LONG		BARFClusterRegCloseKey(HKEY hKey);

#undef		ClusterRegCreateKey
#define		ClusterRegCreateKey(_hKey, _lpszSubKey, _dwOptions, _samDesired, _lpSecurityAttributes, _phkResult, _lpdwDisposition) BARFClusterRegCreateKey(_hKey, _lpszSubKey, _dwOptions, _samDesired, _lpSecurityAttributes, _phkResult, _lpdwDisposition)
LONG		BARFClusterRegCreateKey(HKEY hKey, LPCWSTR lpszSubKey, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

#undef		ClusterRegDeleteKey
#define		ClusterRegDeleteKey(_hKey, _lpszSubKey) BARFClusterRegDeleteKey(_hKey, _lpszSubKey)
LONG		BARFClusterRegDeleteKey(HKEY hKey, LPCWSTR lpszSubKey);

#undef		ClusterRegDeleteValue
#define		ClusterRegDeleteValue(_hKey, _lpszValueName) BARFClusterRegDeleteValue(_hKey, _lpszValueName)
DWORD		BARFClusterRegDeleteValue(HKEY hKey, LPCWSTR lpszValueName);

#undef		ClusterRegEnumKey
#define		ClusterRegEnumKey(_hKey, _dwIndex, _lpszName, _lpcchName, _lpftLastWriteTime) BARFClusterRegEnumKey(_hKey, _dwIndex, _lpszName, _lpcchName, _lpftLastWriteTime)
LONG		BARFClusterRegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpszName, LPDWORD lpcchName, PFILETIME lpftLastWriteTime);

#undef		ClusterRegEnumValue
#define		ClusterRegEnumValue(_hKey, _dwIndex, _lpszValueName, _lpcchValueName, _lpdwType, _lpbData, _lpcbData) BARFClusterRegEnumValue(_hKey, _dwIndex, _lpszValueName, _lpcchValueName, _lpdwType, _lpbData, _lpcbData)
DWORD		BARFClusterRegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcchValueName, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData);

#undef		ClusterRegGetKeySecurity
#define		ClusterRegGetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor, _lpcbSecurityDescriptor) BARFClusterRegGetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor, _lpcbSecurityDescriptor)
LONG		BARFClusterRegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor);

#undef		ClusterRegOpenKey
#define		ClusterRegOpenKey(_hKey, _lpszSubKey, _samDesired, _phkResult) BARFClusterRegOpenKey(_hKey, _lpszSubKey, _samDesired, _phkResult)
LONG		BARFClusterRegOpenKey(HKEY hKey, LPCWSTR lpszSubKey, REGSAM samDesired, PHKEY phkResult);

#undef		ClusterRegQueryInfoKey
#define		ClusterRegQueryInfoKey(_hKey, _lpcSubKeys, _lpcbMaxSubKeyLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime) BARFClusterRegQueryInfoKey(_hKey, _lpcSubKeys, _lpcbMaxSubKeyLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime)
LONG		BARFClusterRegQueryInfoKey(HKEY hKey, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);

#undef		ClusterRegQueryValue
#define		ClusterRegQueryValue(_hKey, _lpszValueName, _lpdwValueType, _lpbData, _lpcbData) BARFClusterRegQueryValue(_hKey, _lpszValueName, _lpdwValueType, _lpbData, _lpcbData)
LONG		BARFClusterRegQueryValue(HKEY hKey, LPCWSTR lpszValueName, LPDWORD lpdwValueType, LPBYTE lpbData, LPDWORD lpcbData);

#undef		ClusterRegSetKeySecurity
#define		ClusterRegSetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor) BARFClusterRegSetKeySecurity(_hKey, _SecurityInformation, _pSecurityDescriptor)
LONG		BARFClusterRegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

#undef		ClusterRegSetValue
#define		ClusterRegSetValue(_hKey, _lpszValueName, _dwType, _lpbData, _cbData) BARFClusterRegSetValue(_hKey, _lpszValueName, _dwType, _lpbData, _cbData)
DWORD		BARFClusterRegSetValue(HKEY hKey, LPCWSTR lpszValueName, DWORD dwType, CONST BYTE * lpbData, DWORD cbData);

#undef		GetClusterGroupKey
#define		GetClusterGroupKey(_hGroup, _samDesired) BARFGetClusterGroupKey(_hGroup, _samDesired)
HKEY		BARFGetClusterGroupKey(HGROUP hGroup, REGSAM samDesired);

#undef		GetClusterKey
#define		GetClusterKey(_hCluster, _samDesired) BARFGetClusterKey(_hCluster, _samDesired)
HKEY		BARFGetClusterKey(HCLUSTER hCluster, REGSAM samDesired);

#undef		GetClusterNodeKey
#define		GetClusterNodeKey(_hNode, _samDesired) BARFGetClusterNodeKey(_hNode, _samDesired)
HKEY		BARFGetClusterNodeKey(HNODE hNode, REGSAM samDesired);

#undef		GetClusterResourceKey
#define		GetClusterResourceKey(_hResource, _samDesired) BARFGetClusterResourceKey(_hResource, _samDesired)
HKEY		BARFGetClusterResourceKey(HRESOURCE hResource, REGSAM samDesired);

#undef		GetClusterResourceTypeKey
#define		GetClusterResourceTypeKey(_hCluster, _lpszTypeName, _samDesired) BARFGetClusterResourceTypeKey(_hCluster, _lpszTypeName, _samDesired)
HKEY		BARFGetClusterResourceTypeKey(HCLUSTER hCluster, LPCWSTR lpszTypeName, REGSAM samDesired);

#undef		GetClusterNetworkKey
#define		GetClusterNetworkKey(_hNetwork, _samDesired) BARFGetClusterNetworkKey(_hNetwork, _samDesired)
HKEY		BARFGetClusterNetworkKey(HNETWORK hNetwork, REGSAM samDesired);

#undef		GetClusterNetInterfaceKey
#define		GetClusterNetInterfaceKey(_hNetInterface, _samDesired) BARFGetClusterNetInterfaceKey(_hNetInterface, _samDesired)
HKEY		BARFGetClusterNetInterfaceKey(HNETINTERFACE hNetInterface, REGSAM samDesired);

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _NO_BARF_DEFINITIONS_
#endif // _BARF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barfdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BarfDlg.cpp
//
//  Abstract:
//      Implementation of the Basic Artifical Resource Failure dialog classes.
//
//  Author:
//      David Potter (davidp)   April 11, 1997
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#define _RESOURCE_H_

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "BarfDlg.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef  _USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG   // The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CTraceTag   g_tagBarfDialog(_T("Debug"), _T("BARF Dialog"), 0);


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfDialog
/////////////////////////////////////////////////////////////////////////////

CBarfDialog *   CBarfDialog::s_pdlg     = NULL;
HICON           CBarfDialog::s_hicon    = NULL;

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBarfDialog, CDialog)
    //{{AFX_MSG_MAP(CBarfDialog)
    ON_BN_CLICKED(IDC_BS_RESET_CURRENT_COUNT, OnResetCurrentCount)
    ON_BN_CLICKED(IDC_BS_RESET_ALL_COUNTS, OnResetAllCounts)
    ON_BN_CLICKED(IDC_BS_GLOBAL_ENABLE, OnGlobalEnable)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_BS_CATEGORIES_LIST, OnItemChanged)
    ON_BN_CLICKED(IDC_BS_CONTINUOUS, OnStatusChange)
    ON_BN_CLICKED(IDC_BS_DISABLE, OnStatusChange)
    ON_EN_CHANGE(IDC_BS_FAIL_AT, OnStatusChange)
    ON_WM_CLOSE()
    //}}AFX_MSG_MAP
    ON_COMMAND(IDCANCEL, OnCancel)
    ON_MESSAGE(WM_USER+5, OnBarfUpdate)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::CBarfDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfDialog::CBarfDialog(void)
{
    //{{AFX_DATA_INIT(CBarfDialog)
    m_nFailAt = 0;
    m_bContinuous = FALSE;
    m_bDisable = FALSE;
    m_bGlobalEnable = FALSE;
    //}}AFX_DATA_INIT

    Trace(g_tagBarfDialog, _T("CBarfDialog::CBarfDialog"));

    m_pbarfSelected = NULL;

}  //*** CBarfDialog::CBarfDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::Create
//
//  Routine Description:
//      Modeless dialog creation method.
//
//  Arguments:
//      pParentWnd      [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfDialog::Create(
    IN OUT CWnd * pParentWnd //=NULL
    )
{
    Trace(g_tagBarfDialog, _T("CBarfDialog::Create"));

    return CDialog::Create(IDD, pParentWnd);

}  //*** CBarfDialog::Create()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBarfDialog)
    DDX_Control(pDX, IDC_BS_GLOBAL_ENABLE, m_ckbGlobalEnable);
    DDX_Control(pDX, IDC_BS_DISABLE, m_ckbDisable);
    DDX_Control(pDX, IDC_BS_CONTINUOUS, m_ckbContinuous);
    DDX_Control(pDX, IDC_BS_CATEGORIES_LIST, m_lcCategories);
    DDX_Text(pDX, IDC_BS_FAIL_AT, m_nFailAt);
    DDX_Check(pDX, IDC_BS_CONTINUOUS, m_bContinuous);
    DDX_Check(pDX, IDC_BS_DISABLE, m_bDisable);
    DDX_Check(pDX, IDC_BS_GLOBAL_ENABLE, m_bGlobalEnable);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
    }  // if:  saving data from the dialog
    else
    {
        int     ili;
        CBarf * pbarf;
        CString str;

        ili = m_lcCategories.GetNextItem(-1, LVNI_SELECTED);
        if (ili == -1)
            ili = m_lcCategories.GetNextItem(-1, LVNI_FOCUSED);
        if (ili != -1)
        {
            pbarf = (CBarf *) m_lcCategories.GetItemData(ili);

            // Set the current count.
            str.Format(_T("%d"), pbarf->NCurrent());
            VERIFY(m_lcCategories.SetItemText(ili, 1, str));

            // Set the failure point.
            str.Format(_T("%d"), pbarf->NFail());
            VERIFY(m_lcCategories.SetItemText(ili, 2, str));
        }  // if:  there is an item with focus

    }  // else:  setting data to the dialog

}  //*** CBarfDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBarfDialog::OnInitDialog(void)
{
    // Call the base class.
    CDialog::OnInitDialog();

    ASSERT(Pdlg() == NULL);
    s_pdlg = this;

    // Set the post update function to point to our static function.
    CBarf::SetPostUpdateFn(&PostUpdate);
    CBarf::SetSpecialMem(Pdlg());

    // Add the columns to the list control.
    {
        m_lcCategories.InsertColumn(0, _T("Category"), LVCFMT_LEFT, 100);
        m_lcCategories.InsertColumn(1, _T("Count"), LVCFMT_LEFT, 50);
        m_lcCategories.InsertColumn(2, _T("Fail At"), LVCFMT_LEFT, 50);
    }  // Add the columns to the list control

    // Set-up the dialog based on the real values...
    FillList();
    OnUpdate();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBarfDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnClose
//
//  Routine Description:
//      Handler method for the WM_CLOSE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnClose(void)
{
    CDialog::OnClose();
    DestroyWindow();

}  //*** CBarfDialog::OnClose()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnCancel
//
//  Routine Description:
//      Handler method for the WM_COMMAND message when IDCANCEL is sent.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnCancel(void)
{
    CDialog::OnCancel();
    DestroyWindow();

}  //*** CBarfDialog::OnCancel()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::PostNcDestroy
//
//  Routine Description:
//      Processing after non-client has been destroyed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::PostNcDestroy(void)
{
    CDialog::PostNcDestroy();
    delete this;
    CBarf::ClearPostUpdateFn();
    s_pdlg = NULL;

}  //*** CBarfDialog::PostNcDestroy()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::FillList
//
//  Routine Description:
//      Loads the list of failure categories.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::FillList(void)
{
    int             ili;
    int             iliReturn;
    CString         str;
    CBarf *         pbarf   = CBarf::s_pbarfFirst;
    CBarfSuspend    bs;

    m_lcCategories.DeleteAllItems();

    for (ili = 0 ; pbarf != NULL ; ili++)
    {
        // Insert the item.
        iliReturn = m_lcCategories.InsertItem(ili, pbarf->PszName());
        ASSERT(iliReturn != -1);

        // Set the current count.
        str.Format(_T("%d"), pbarf->NCurrent());
        VERIFY(m_lcCategories.SetItemText(iliReturn, 1, str));

        // Set the failure point.
        str.Format(_T("%d"), pbarf->NFail());
        VERIFY(m_lcCategories.SetItemText(iliReturn, 2, str));

        // Set the pointer in the entry so we can retrieve it later.
        VERIFY(m_lcCategories.SetItemData(iliReturn, (DWORD) pbarf));

        // Advance to the next entry
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    // If no known selection yet, get the current selection.
    if (m_pbarfSelected == NULL)
    {
        ili = m_lcCategories.GetNextItem(-1, LVNI_SELECTED);
        if (ili == -1)
            ili = 0;
        m_pbarfSelected = (CBarf *) m_lcCategories.GetItemData(ili);
        if (m_pbarfSelected != NULL)
            OnUpdate();
    }  // if:  no know selection

    // Select the proper item.
    {
        LV_FINDINFO lvfi = { LVFI_PARAM, NULL, (DWORD) m_pbarfSelected };

        ili = m_lcCategories.FindItem(&lvfi);
        if (ili != -1)
            m_lcCategories.SetItemState(ili, LVIS_SELECTED, LVIS_SELECTED);
    }  // Select the proper item

}  //*** CBarfDialog::FillList()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnUpdate
//
//  Routine Description:
//      Updates the displayed counts to their TRUE values.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnUpdate(void)
{
    Trace(g_tagBarfDialog, _T("Updating the counts."));

    ASSERT(m_pbarfSelected != NULL);

    m_bContinuous = m_pbarfSelected->BContinuous();
    m_bDisable = m_pbarfSelected->BDisabled();
    m_nFailAt = m_pbarfSelected->NFail();
    
    m_bGlobalEnable = CBarf::s_bGlobalEnable;

    UpdateData(FALSE /*bSaveAndValidate*/);

}  //*** CBarfDialog::OnUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnGlobalEnable
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Global Enable
//      checkbox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnGlobalEnable(void)
{
    ASSERT(m_ckbGlobalEnable.m_hWnd != NULL);
    CBarf::s_bGlobalEnable = m_ckbGlobalEnable.GetCheck() == BST_CHECKED;

}  //*** CBarfDialog::OnGlobalEnable()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetCurrentCount
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Reset Current
//      Count button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnResetCurrentCount(void)
{
    int         ili;
    CBarf *     pbarf;

    ASSERT(m_lcCategories.m_hWnd != NULL);

    // Get the selected item.
    ili = m_lcCategories.GetNextItem(-1, LVIS_SELECTED);
    ASSERT(ili != -1);
    pbarf = (CBarf *) m_lcCategories.GetItemData(ili);
    ASSERT(pbarf != NULL);
    ASSERT(pbarf == m_pbarfSelected);

    // Reset the count.
    pbarf->m_nCurrent = 0;

    OnStatusChange();

}  //*** CBarfDialog::OnResetCurrentCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetAllCounts
//
//  Routine Description:
//      Handler function for the BN_CLICKED message on the Reset All
//      Counts button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnResetAllCounts(void)
{
    CBarf *     pbarf = CBarf::s_pbarfFirst;

    Trace(g_tagBarfDialog, _T("Resetting ALL current counts."));

    while (pbarf != NULL)
    {
        pbarf->m_nCurrent = 0;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    FillList();

}  //*** CBarfDialog::OnResetAllCounts()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnResetAllCounts
//
//  Routine Description:
//      Handler function for the LVN_ITEMCHANGED message from the list control.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnItemChanged(NMHDR * pNMHDR, LRESULT * pResult)
{
    NM_LISTVIEW * pNMListView = (NM_LISTVIEW *) pNMHDR;

    // If the item just became unselected or selected, change the checkboxes to match.
    if ((pNMListView->uChanged & LVIF_STATE)
            && ((pNMListView->uOldState & LVIS_SELECTED)
                || (pNMListView->uNewState & LVIS_SELECTED)))
    {
        // Handle a selection change.
        m_pbarfSelected = (CBarf *) pNMListView->lParam;
        OnStatusChange();
    }  // if:  item received the focus

    *pResult = 0;

}  //*** CBarfDialog::OnItemChanged()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnStatusChange
//
//  Routine Description:
//      Adjusts the C== object when the status of the currently selected
//      item changes.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::OnStatusChange(void)
{
    ASSERT(m_pbarfSelected != NULL);

    UpdateData(TRUE /*bSaveAndValidate*/);

    m_pbarfSelected->m_bContinuous = m_bContinuous;
    m_pbarfSelected->m_bDisabled = m_bDisable;
    m_pbarfSelected->m_nFail = m_nFailAt;

    UpdateData(FALSE /*bSaveAndValidate*/);

}  //*** CBarfDialog::OnStatusChange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::OnBarfUpdate
//
//  Routine Description:
//      Handler for the WM_USER message.
//      Processes barf notifications.
//
//  Arguments:
//      wparam      1st parameter.
//      lparam      2nd parameter.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBarfDialog::OnBarfUpdate(WPARAM wparam, LPARAM lparam)
{
    OnUpdate();
    return 0;

}  //*** CBarfDialog::OnBarfUpdate()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfDialog::PostUpdate
//
//  Routine Description:
//      Static function so that CBarf::BFail can post updates to us.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfDialog::PostUpdate(void)
{
    // If this function gets called, there should be BARF dialog.
    ASSERT(Pdlg() != NULL);

    if (Pdlg() != NULL)
        ::PostMessage(Pdlg()->m_hWnd, WM_USER+5, NULL, NULL);

}  //*** CBarfDialog::PostUpdate()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CBarfAllDialog
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBarfAllDialog, CDialog)
    //{{AFX_MSG_MAP(CBarfAllDialog)
    ON_BN_CLICKED(IDC_BAS_MENU_ITEM, OnMenuItem)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::CBarfAllDialog
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd      [IN OUT] Parent window for the dialog.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBarfAllDialog::CBarfAllDialog(
    IN OUT CWnd * pParentWnd //=NULL
    )
    : CDialog(IDD, pParentWnd)
{
    //{{AFX_DATA_INIT(CBarfAllDialog)
    //}}AFX_DATA_INIT

    m_hwndBarf = NULL;
    m_wmBarf = 0;
    m_wparamBarf = 0;
    m_lparamBarf = 0;

}  //*** CBarfAllDialog::CBarfAllDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBarfAllDialog)
    DDX_Control(pDX, IDC_BAS_LPARAM, m_editLparam);
    DDX_Control(pDX, IDC_BAS_WPARAM, m_editWparam);
    DDX_Control(pDX, IDC_BAS_WM, m_editWm);
    DDX_Control(pDX, IDC_BAS_HWND, m_editHwnd);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_BAS_HWND, (DWORD &) m_hwndBarf);
    DDX_Text(pDX, IDC_BAS_WM, m_wmBarf);
    DDX_Text(pDX, IDC_BAS_WPARAM, m_wparamBarf);
    DDX_Text(pDX, IDC_BAS_LPARAM, m_lparamBarf);

}  //*** CBarfAllDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Focus needs to be set.
//      FALSE   Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBarfAllDialog::OnInitDialog(void)
{
    // Call the base class.
    CDialog::OnInitDialog();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBarfAllDialog::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnOK
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the OK button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::OnOK(void)
{
    if (m_hwndBarf == NULL)
        m_hwndBarf = AfxGetMainWnd()->m_hWnd;

    CDialog::OnOK();

}  //*** CBarfAllDialog::OnDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBarfAllDialog::OnMenuItem
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Menu Item button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBarfAllDialog::OnMenuItem(void)
{
    m_editHwnd.SetWindowText(_T("0"));
    m_editWm.SetWindowText(_T("273")); // WM_COMMAND
    m_editLparam.SetWindowText(_T("0"));
    m_editWparam.SetWindowText(_T("0"));

}  //*** CBarfAllDialog::OnMenuItem()


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BarfAll
//
//  Routine Description:
//      Exercises all possible single failures.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void BarfAll(void)
{
    CBarf *         pbarf;
    CBarfAllDialog  dlg(AfxGetMainWnd());
    ID              id;
    CString         str;

    // First, pick-up the message to test.

    id = dlg.DoModal();

    if (id != IDOK)
    {
        Trace(g_tagAlways, _T("BarfAll() -  operation cancelled."));
        return;
    }  // if:  BarfAll cancelled

    Trace(g_tagAlways,
        _T("BarfAll with hwnd = %#08lX, wm = 0x%4x, wparam = %d, lparam = %d"),
        dlg.HwndBarf(), dlg.WmBarf(), dlg.WparamBarf(), dlg.LparamBarf());

    // Now, find out how many counts of each resource...
    
    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        pbarf->m_nCurrentSave = pbarf->m_nCurrent;
        pbarf->m_nCurrent = 0;
        pbarf->m_nFail = 0;
        pbarf->m_bContinuous = FALSE;
        pbarf->m_bDisabled = FALSE;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries
    if (CBarfDialog::Pdlg())
        CBarfDialog::Pdlg()->OnUpdate();

    str = _T("BarfAll Test pass.");
    Trace(g_tagAlways, str);
    SendMessage(dlg.HwndBarf(), dlg.WmBarf(),
                        dlg.WparamBarf(), dlg.LparamBarf());

    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        pbarf->m_nBarfAll = pbarf->m_nCurrentSave;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more entries in the list
    MessageBox(dlg.HwndBarf(), str, _T("BARF Status"), MB_OK | MB_ICONEXCLAMATION);

    // Finally, THE big loop...
    
    pbarf = CBarf::s_pbarfFirst;
    while (pbarf != NULL)
    {
        for (pbarf->m_nFail = 1
                ; pbarf->m_nFail <= pbarf->m_nBarfAll
                ; pbarf->m_nFail++)
        {
//          CBarfMemory::Mark();
            pbarf->m_nCurrent = 0;
            if (CBarfDialog::Pdlg())
                CBarfDialog::Pdlg()->OnUpdate();

            str.Format(_T("BarfAll on resource %s, call # %d of %d"),
                        pbarf->m_pszName, pbarf->m_nFail, pbarf->m_nBarfAll);
            Trace(g_tagAlways, str);
            SendMessage(dlg.HwndBarf(), dlg.WmBarf(),
                        dlg.WparamBarf(), dlg.LparamBarf());

//          CBarfMemory::DumpMarked();
//          ValidateMemory();
            str += _T("\nContinue?");
            if (MessageBox(dlg.HwndBarf(), str, _T("BARF: Pass Complete."), MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                break;
        }  // for:  while the failure count is less than the BARF All count

        pbarf->m_nFail = 0;
        pbarf->m_nCurrent = pbarf->m_nCurrentSave;
        pbarf = pbarf->m_pbarfNext;
    }  // while:  more BARF entries

    if (CBarfDialog::Pdlg())
        CBarfDialog::Pdlg()->OnUpdate();

}  //*** BarfAll()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DoBarfDialog
//
//  Routine Description:
//      Launches the Barf Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DoBarfDialog( void )
{
    if ( CBarf::s_pbarfFirst == NULL )
    {
        AfxMessageBox( _T("No BARF counters defined yet."), MB_OK );
    }  // if:  no counters defined yet
    else if ( CBarfDialog::Pdlg() )
    {
        BringWindowToTop( CBarfDialog::Pdlg()->m_hWnd );
        if ( IsIconic( CBarfDialog::Pdlg()->m_hWnd ) )
        {
            SendMessage( CBarfDialog::Pdlg()->m_hWnd, WM_SYSCOMMAND, SC_RESTORE,  NULL );
        } // if: window is currently minimized
    }  // if:  there is already a dialog up
    else
    {
        CBarfDialog *   pdlg = NULL;

        try
        {
            pdlg = new CBarfDialog;
            if ( pdlg == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the dialog
            pdlg->Create( AfxGetMainWnd() );
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
    }  // else:  no dialog up yet

}  //*** DoBarfDialog()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barfdlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfDlg.h
//
//	Abstract:
//		Definition of the Basic Artifical Resource Failure dialog classes.
//
//	Implementation File:
//		BarfDlg.cpp
//
//	Author:
//		David Potter (davidp)	April 11, 1997
//
//	Revision History:
//
//	Notes:
//		This file compiles only in _DEBUG mode.
//
//		To implement a new BARF type, declare a global instance of CBarf:
//			CBarf g_barfMyApi(_T("My API"));
//
//		To bring up the BARF dialog:
//			DoBarfDialog();
//		This brings up a modeless dialog with the BARF settings.
//
//		A few functions are provided for special circumstances.
//		Usage of these should be fairly limited:
//			BarfAll(void);		Top Secret -> NYI.
//			EnableBarf(BOOL);	Allows you to disable/reenable BARF.
//			FailOnNextBarf;		Force the next failable call to fail.
//
//		NOTE:	Your code calls the standard APIs (e.g. LoadIcon) and the
//				BARF files do the rest.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BARFDLG_H_
#define _BARFDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarfDialog;
class CBarfAllDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBarf;

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfDialog
//
//	Purpose:
//		Implements the BARF Settings dialog
//
//	Usage:
//		Use the constructor, then Create().
//		Update() is called by CBarf::BFail() to indicate
//		one of the current counts has changed.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef	_DEBUG

class CBarfDialog : public CDialog
{
// Construction
public:
	CBarfDialog(void);
	BOOL Create(CWnd * pParentWnd = NULL);

// Dialog Data
	//{{AFX_DATA(CBarfDialog)
	enum { IDD = IDD_BARF_SETTINGS };
	CButton	m_ckbGlobalEnable;
	CButton	m_ckbDisable;
	CButton	m_ckbContinuous;
	CListCtrl	m_lcCategories;
	DWORD	m_nFailAt;
	BOOL	m_bContinuous;
	BOOL	m_bDisable;
	BOOL	m_bGlobalEnable;
	//}}AFX_DATA
//	CButton	m_ckbGlobalEnable;
//	CButton	m_ckbDisable;
//	CButton	m_ckbContinuous;
//	CListCtrl	m_lcCategories;
//	DWORD	m_nFailAt;
//	BOOL	m_bContinuous;
//	BOOL	m_bDisable;
//	BOOL	m_bGlobalEnable;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBarfDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
protected:

private:
	static	CBarfDialog *	s_pdlg;
	static	HICON			s_hicon;

protected:
	CBarf *				m_pbarfSelected;

	// Generated message map functions
	//{{AFX_MSG(CBarfDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnResetCurrentCount();
	afx_msg void OnResetAllCounts();
	afx_msg void OnGlobalEnable();
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnStatusChange();
	afx_msg void OnClose();
	//}}AFX_MSG
	virtual void OnCancel();
	afx_msg LRESULT OnBarfUpdate(WPARAM wparam, LPARAM lparam);
	DECLARE_MESSAGE_MAP()

//	virtual	LRESULT		LDlgProc(UINT, WPARAM, LPARAM);

//	void				GetSelection(void);
//	void				OnGlobalEnable(void);
//	void				OnResetAllCounts(void);
//	void				OnSelectionChange(void);
//	void				OnStatusChange(IN BOOL bReset);

//	void				FormatBarfString(CBarf *, CString * pstr);
	void				FillList(void);

	static	void		PostUpdate(void);

public:
	static CBarfDialog *	Pdlg()	{ return s_pdlg; }
	void					OnUpdate(void);

};  //*** class CBarfDialog

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//
//	class CBarfAllDialog
//
//	Purpose:
//		Implements the Barf Everything dialog.
//
//	Usage:
//		Similar to most Modal dialogs: Construct, then do dlg.DoModal()
//		In addition, the methods Hwnd(), Wm(), Wparam() and Lparam()
//		can be called when the dialog is dismissed (only if DoModal()
//		returns IDOK).
//
/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG

class CBarfAllDialog : public CDialog
{
// Construction
public:
	CBarfAllDialog(IN OUT CWnd * pParent);

protected:
// Dialog Data
	//{{AFX_DATA(CBarfAllDialog)
	enum { IDD = IDD_BARF_ALL_SETTINGS };
	CEdit	m_editLparam;
	CEdit	m_editWparam;
	CEdit	m_editWm;
	CEdit	m_editHwnd;
	//}}AFX_DATA
	HWND		m_hwndBarf;
	UINT		m_wmBarf;
	WPARAM		m_wparamBarf;
	LPARAM		m_lparamBarf;

public:
	HWND		HwndBarf(void)		{ return m_hwndBarf; }
	UINT		WmBarf(void)		{ return m_wmBarf; }
	WPARAM		WparamBarf(void)	{ return m_wparamBarf; }
	LPARAM		LparamBarf(void)	{ return m_lparamBarf; }


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBarfAllDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBarfAllDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnMenuItem();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

//	virtual	void		OnButton(ID id);
//	virtual	void		OnOK(void);

};  //*** class CBarfAllDialog

#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Global Functions and Data
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG

 void DoBarfDialog(void);
 void BarfAll(void);

#else

 inline void DoBarfDialog(void)	{ }
 inline void BarfAll(void)		{ }

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////

#endif // _BARFDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basecmdt.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseCmdT.cpp
//
//	Abstract:
//		Implementation of the CBaseCmdTarget class.
//
//	Author:
//		David Potter (davidp)	December 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseCmdT.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBaseCmdTarget
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseCmdTarget, CCmdTarget)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBaseCmdTarget, CCmdTarget)
	//{{AFX_MSG_MAP(CBaseCmdTarget)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\barfclus.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BarfClus.cpp
//
//	Abstract:
//		Implementation of the Basic Artifical Resource Failure entry points
//		for CLUSAPI functions.
//
//	Author:
//		David Potter (davidp)	April 14, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define _NO_BARF_DEFINITIONS_

#include "Barf.h"
#include "BarfClus.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef	_USING_BARF_
 #error BARF failures should be disabled!
#endif

#ifdef _DEBUG	// The entire file!

#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

CBarf	g_barfClusApi(_T("CLUSAPI Calls"));

/////////////////////////////////////////////////////////////////////////////
// Cluster Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseCluster(HCLUSTER hCluster)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseCluster()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseCluster(hCluster);

}  //*** BARFCloseCluster()

BOOL BARFCloseClusterNotifyPort(HCHANGE hChange)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNotifyPort()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNotifyPort(hChange);

}  //*** BARFCloseClusterNotifyPort()

DWORD BARFClusterCloseEnum(HCLUSENUM hClusEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterCloseEnum(hClusEnum);

}  //*** BARFClusterCloseEnum()

DWORD BARFClusterEnum(
	HCLUSENUM hClusEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
//	if (g_barfClusApi.BFail())
//	{
//		Trace(g_tagBarf, _T("ClusterEnum()"));
//		return ERROR_INVALID_FUNCTION;
//	}  // if:  BARF failure
//	else
		return ClusterEnum(hClusEnum, dwIndex, lpdwType, lpszName, lpcchName);

}  //*** BARFClusterEnum()

HCLUSENUM BARFClusterOpenEnum(HCLUSTER hCluster, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterOpenEnum(hCluster, dwType);

}  //*** BARFClusterOpenEnum()

DWORD BARFClusterResourceTypeControl(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceTypeName,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceTypeControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceTypeControl(
					hCluster,
					lpszResourceTypeName,
					hHostNode,
					dwControlCode,
					lpInBuffer,
					nInBufferSize,
					lpOutBuffer,
					nOutBufferSize,
					lpBytesReturned
					);

}  //*** BARFClusterResourceTypeControl()

HCHANGE BARFCreateClusterNotifyPort(
	HCHANGE hChange,
	HCLUSTER hCluster,
	DWORD dwFilter,
	DWORD_PTR dwNotifyKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterNotifyPort()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterNotifyPort(
					hChange,
					hCluster,
					dwFilter,
					dwNotifyKey
					);

}  //*** BARFCreateClusterNotifyPort()

DWORD BARFCreateClusterResourceType(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceTypeName,
	LPCWSTR lpszDisplayName,
	LPCWSTR lpszResourceTypeDll,
	DWORD dwLooksAlivePollInterval,
	DWORD dwIsAlivePollInterval
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterResourceType()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return CreateClusterResourceType(
					hCluster,
					lpszResourceTypeName,
					lpszDisplayName,
					lpszDisplayName,
					dwLooksAlivePollInterval,
					dwIsAlivePollInterval
					);

}  //*** BARFCreateClusterResourceType()

DWORD BARFDeleteClusterResourceType(HCLUSTER hCluster, LPCWSTR lpszResourceTypeName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterResourceType()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return DeleteClusterResourceType(
					hCluster,
					lpszResourceTypeName
					);

}  //*** BARFDeleteClusterResourceType()

DWORD BARFGetClusterInformation(
	HCLUSTER hCluster,
	LPWSTR lpszClusterName,
	LPDWORD lpcchClusterName,
	LPCLUSTERVERSIONINFO lpClusterInfo
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterInformation()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterInformation(
					hCluster,
					lpszClusterName,
					lpcchClusterName,
					lpClusterInfo
					);

}  //*** BARFGetClusterInformation()

DWORD BARFGetClusterNotify(
	HCHANGE hChange,
	DWORD_PTR *lpdwNotifyKey,
	LPDWORD lpdwFilterType,
	LPWSTR lpszName,
	LPDWORD lpcchName,
	DWORD dwMilliseconds
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNotify()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterNotify(
					hChange,
					lpdwNotifyKey,
					lpdwFilterType,
					lpszName,
					lpcchName,
					dwMilliseconds
					);

}  //*** BARFGetClusterNotify()

DWORD BARFGetClusterQuorumResource(
	HCLUSTER hCluster,
	LPWSTR lpszResourceName,
	LPDWORD lpcbResourceName,
	LPWSTR lpszDeviceName,
	LPDWORD lpcbDeviceName,
	LPDWORD lpdwMaxQuorumLogSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterQuorumResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterQuorumResource(
					hCluster,
					lpszResourceName,
					lpcbResourceName,
					lpszDeviceName,
					lpcbDeviceName,
					lpdwMaxQuorumLogSize
					);

}  //*** BARFGetClusterQuorumResource()

HCLUSTER BARFOpenCluster(LPCWSTR lpszClusterName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenCluster()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenCluster(lpszClusterName);

}  //*** BARFOpenCluster()

DWORD BARFRegisterClusterNotify(
	HCHANGE hChange,
	DWORD dwFilter,
	HANDLE hObject,
	DWORD_PTR dwNotifyKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RegisterClusterNotify()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RegisterClusterNotify(
						hChange,
						dwFilter,
						hObject,
						dwNotifyKey
						);

}  //*** BARFRegisterClusterNotify()

DWORD BARFSetClusterName(HCLUSTER hCluster, LPCWSTR lpszNewClusterName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterName(hCluster, lpszNewClusterName);

}  //*** BARFSetClusterName()

DWORD BARFSetClusterQuorumResource(
	HRESOURCE hResource,
	LPCWSTR lpszDeviceName,
	DWORD dwMaxQuoLogSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterQuorumResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterQuorumResource(
						hResource,
						lpszDeviceName,
						dwMaxQuoLogSize
						);

}  //*** BARFSetClusterQuorumResource()

/////////////////////////////////////////////////////////////////////////////
// Node Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNode()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNode(hNode);

}  //*** BARFCloseClusterNode()

DWORD BARFClusterNodeControl(
	HNODE hNode,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNodeControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNodeControl(
						hNode,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNodeControl()

DWORD BARFEvictClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("EvictClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return EvictClusterNode(hNode);

}  //*** BARFEvictClusterNode()

DWORD BARFGetClusterNodeId(HNODE hNode, LPWSTR lpszNodeId, LPDWORD lpcchNodeId)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeId()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return GetClusterNodeId(hNode, lpszNodeId, lpcchNodeId);

}  //*** BARFGetClusterNodeId()

CLUSTER_NODE_STATE BARFGetClusterNodeState(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNodeStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNodeState(hNode);

}  //*** BARFGetClusterNodeState()

HNODE BARFOpenClusterNode(HCLUSTER hCluster, LPCWSTR lpszNodeName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNode()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNode(hCluster, lpszNodeName);

}  //*** BARFOpenClusterNode()

DWORD BARFPauseClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("PauseClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return PauseClusterNode(hNode);

}  //*** BARFPauseClusterNode()

DWORD BARFResumeClusterNode(HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ResumeClusterNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ResumeClusterNode(hNode);

}  //*** BARFResumeClusterNode()

/////////////////////////////////////////////////////////////////////////////
// Group Management Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BARFCloseClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterGroup(hGroup);

}  //*** BARFCloseClusterGroup()

DWORD BARFClusterGroupCloseEnum(HGROUPENUM hGroupEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupCloseEnum(hGroupEnum);

}  //*** BARFClusterGroupCloseEnum()

DWORD BARFClusterGroupControl(
	HGROUP hGroup,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupControl(
						hGroup,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterGroupControl()

DWORD BARFClusterGroupEnum(
	HGROUPENUM hGroupEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszResourceName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterGroupEnum(
						hGroupEnum,
						dwIndex,
						lpdwType,
						lpszResourceName,
						lpcchName
						);

}  //*** BARFClusterGroupEnum()

HGROUPENUM BARFClusterGroupOpenEnum(HGROUP hGroup, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterGroupOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterGroupOpenEnum(hGroup, dwType);

}  //*** BARFClusterGroupOpenEnum()

HGROUP BARFCreateClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterGroup(hCluster, lpszGroupName);

}  //*** BARFCreateClusterGroup()

DWORD BARFDeleteClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return DeleteClusterGroup(hGroup);

}  //*** BARFDeleteClusterGroup()

CLUSTER_GROUP_STATE BARFGetClusterGroupState(
	HGROUP hGroup,
	LPWSTR lpszNodeName,
	LPDWORD lpcchNodeName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterGroupState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterGroupStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterGroupState(
						hGroup,
						lpszNodeName,
						lpcchNodeName
						);

}  //*** BARFGetClusterGroupState()

DWORD BARFMoveClusterGroup(HGROUP hGroup, HNODE hDestinationNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("MoveClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return MoveClusterGroup(hGroup, hDestinationNode);

}  //*** BARFMoveClusterGroup()

DWORD BARFOfflineClusterGroup(HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OfflineClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OfflineClusterGroup(hGroup);

}  //*** BARFOfflineClusterGroup()

DWORD BARFOnlineClusterGroup(HGROUP hGroup, HNODE hDestinationNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OnlineClusterGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OnlineClusterGroup(hGroup, hDestinationNode);

}  //*** BARFOnlineClusterGroup()

HGROUP BARFOpenClusterGroup(HCLUSTER hCluster, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterGroup()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterGroup(hCluster, lpszGroupName);

}  //*** BARFOpenClusterGroup()

DWORD BARFSetClusterGroupName(HGROUP hGroup, LPCWSTR lpszGroupName)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterGroupName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterGroupName(hGroup, lpszGroupName);

}  //*** BARFSetClusterGroupName()

DWORD BARFSetClusterGroupNodeList(
	HGROUP hGroup,
	DWORD cNodeCount,
	HNODE phNodeList[]
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterGroupNodeList()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterGroupNodeList(
						hGroup,
						cNodeCount,
						phNodeList
						);

}  //*** BARFSetClusterGroupNodeList()

/////////////////////////////////////////////////////////////////////////////
// Resource Management Functions
/////////////////////////////////////////////////////////////////////////////

DWORD BARFAddClusterResourceDependency(HRESOURCE hResource, HRESOURCE hDependsOn)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("AddClusterResourceDependency()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return AddClusterResourceDependency(hResource, hDependsOn);

}  //*** BARFAddClusterResourceDependency()

DWORD BARFAddClusterResourceNode(HRESOURCE hResource, HNODE hNode)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("AddClusterResourceNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return AddClusterResourceNode(hResource, hNode);

}  //*** BARFAddClusterResourceNode()

BOOL BARFCanResourceBeDependent(HRESOURCE hResource, HRESOURCE hResourceDependent)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CanResourceBeDependent()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CanResourceBeDependent(hResource, hResourceDependent);

}  //*** BARFCanResourceBeDependent()

DWORD BARFChangeClusterResourceGroup(HRESOURCE hResource, HGROUP hGroup)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ChangeClusterResourceGroup()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ChangeClusterResourceGroup(hResource, hGroup);

}  //*** BARFChangeClusterResourceGroup()

BOOL BARFCloseClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterResource(hResource);

}  //*** BARFCloseClusterResource()

DWORD BARFClusterResourceCloseEnum(HRESENUM hResEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceCloseEnum(hResEnum);

}  //*** BARFClusterResourceCloseEnum()

DWORD BARFClusterResourceControl(
	HRESOURCE hResource,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceControl(
						hResource,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterResourceControl()

DWORD BARFClusterResourceEnum(
	HRESENUM hResEnum,
	DWORD dwIndex,
	LPDWORD lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterResourceEnum(
						hResEnum,
						dwIndex,
						lpdwType,
						lpszName,
						lpcchName
						);

}  //*** BARFClusterResourceEnum()

HRESENUM BARFClusterResourceOpenEnum(HRESOURCE hResource, DWORD dwType)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterResourceOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterResourceOpenEnum(hResource, dwType);

}  //*** BARFClusterResourceOpenEnum()

HRESOURCE BARFCreateClusterResource(
	HGROUP hGroup,
	LPCWSTR lpszResourceName,
	LPCWSTR lpszResourceType,
	DWORD dwFlags
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CreateClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return CreateClusterResource(
						hGroup,
						lpszResourceName,
						lpszResourceType,
						dwFlags
						);

}  //*** BARFCreateClusterResource()

DWORD BARFDeleteClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("DeleteClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return DeleteClusterResource(hResource);

}  //*** BARFDeleteClusterResource()

DWORD BARFFailClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("FailClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return FailClusterResource(hResource);

}  //*** BARFFailClusterResource()

BOOL BARFGetClusterResourceNetworkName(
	HRESOURCE hResource,
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceNetworkName()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceNetworkName(
						hResource,
						lpBuffer,
						nSize
						);

}  //*** BARFGetClusterResourceNetworkName()

CLUSTER_RESOURCE_STATE BARFGetClusterResourceState(
	HRESOURCE hResource,
	LPWSTR lpszNodeName,
	LPDWORD lpcchNodeName,
	LPWSTR lpszGroupName,
	LPDWORD lpcchGroupName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceNetworkName()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterResourceStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterResourceState(
						hResource,
						lpszNodeName,
						lpcchNodeName,
						lpszGroupName,
						lpcchGroupName
						);

}  //*** BARFGetClusterResourceState()

DWORD BARFOfflineClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OfflineClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OfflineClusterResource(hResource);

}  //*** BARFOfflineClusterResource()

DWORD BARFOnlineClusterResource(HRESOURCE hResource)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OnlineClusterResource()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return OnlineClusterResource(hResource);

}  //*** BARFOnlineClusterResource()

HRESOURCE BARFOpenClusterResource(
	HCLUSTER hCluster,
	LPCWSTR lpszResourceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterResource()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterResource(hCluster, lpszResourceName);

}  //*** BARFOpenClusterResource()

DWORD BARFRemoveClusterResourceNode(
	HRESOURCE hResource,
	HNODE hNode
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RemoveClusterResourceNode()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RemoveClusterResourceNode(hResource, hNode);

}  //*** BARFRemoveClusterResourceNode()

DWORD BARFRemoveClusterResourceDependency(
	HRESOURCE hResource,
	HRESOURCE hDependsOn
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("RemoveClusterResourceDependency()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return RemoveClusterResourceDependency(hResource, hDependsOn);

}  //*** BARFRemoveClusterResourceDependency()

DWORD BARFSetClusterResourceName(
	HRESOURCE hResource,
	LPCWSTR lpszResourceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterResourceName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterResourceName(hResource, lpszResourceName);

}  //*** BARFSetClusterResourceName()

/////////////////////////////////////////////////////////////////////////////
// Network Management Functions
/////////////////////////////////////////////////////////////////////////////

HNETWORK BARFOpenClusterNetwork(
	HCLUSTER hCluster,
	LPCWSTR lpszNetworkName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNetwork()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNetwork(hCluster, lpszNetworkName);

}  //*** BARFOpenClusterNetwork()

BOOL BARFCloseClusterNetwork(HNETWORK hNetwork)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNetwork()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNetwork(hNetwork);

}  //*** BARFOpenClusterNetwork()

HNETWORKENUM BARFClusterNetworkOpenEnum(
	HNETWORK hNetwork,
	DWORD dwType
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkOpenEnum()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return ClusterNetworkOpenEnum(hNetwork, dwType);

}  //*** BARFClusterNetworkOpenEnum()

DWORD BARFClusterNetworkEnum(
	HNETWORKENUM hNetworkEnum,
	DWORD dwIndex,
	DWORD * lpdwType,
	LPWSTR lpszName,
	LPDWORD lpcchName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkEnum(
						hNetworkEnum,
						dwIndex,
						lpdwType,
						lpszName,
						lpcchName
						);

}  //*** BARFClusterNetworkEnum()

DWORD BARFClusterNetworkCloseEnum(HNETWORKENUM hNetworkEnum)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkCloseEnum()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkCloseEnum(hNetworkEnum);

}  //*** BARFClusterNetworkCloseEnum()

CLUSTER_NETWORK_STATE BARFGetClusterNetworkState(HNETWORK hNetwork)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetworkState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNetworkStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNetworkState(hNetwork);

}  //*** BARFGetClusterNetworkState()

DWORD BARFSetClusterNetworkName(
	HNETWORK hNetwork,
	LPCWSTR lpszName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("SetClusterNetworkName()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return SetClusterNetworkName(hNetwork, lpszName);

}  //*** BARFSetClusterNetworkName()

DWORD BARFClusterNetworkControl(
	HNETWORK hNetwork,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetworkControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetworkControl(
						hNetwork,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNetworkControl()

/////////////////////////////////////////////////////////////////////////////
// Network Interface Management Functions
/////////////////////////////////////////////////////////////////////////////

HNETINTERFACE BARFOpenClusterNetInterface(
	HCLUSTER hCluster,
	LPCWSTR lpszInterfaceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("OpenClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return OpenClusterNetInterface(hCluster, lpszInterfaceName);

}  //*** BARFOpenClusterNetInterface()

DWORD BARFGetClusterNetInterface(
	HCLUSTER hCluster,
	LPCWSTR lpszNodeName,
	LPCWSTR lpszNetworkName,
	LPWSTR lpszNetInterfaceName,
	DWORD * lpcchNetInterfaceName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetInterface(
							hCluster,
							lpszNodeName,
							lpszNetworkName,
							lpszNetInterfaceName,
							lpcchNetInterfaceName
							);

}  //*** BARFGetClusterNetInterface()

BOOL BARFCloseClusterNetInterface(HNETINTERFACE hNetInterface)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("CloseClusterNetInterface()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return FALSE;
	}  // if:  BARF failure
	else
		return CloseClusterNetInterface(hNetInterface);

}  //*** BARFCloseClusterNetInterface()

CLUSTER_NETINTERFACE_STATE BARFGetClusterNetInterfaceState(HNETINTERFACE hNetInterface)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterfaceState()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return ClusterNetInterfaceStateUnknown;
	}  // if:  BARF failure
	else
		return GetClusterNetInterfaceState(hNetInterface);

}  //*** BARFGetClusterNetInterfaceState()

DWORD BARFClusterNetInterfaceControl(
	HNETINTERFACE hNetInterface,
	HNODE hHostNode,
	DWORD dwControlCode,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesReturned
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterNetInterfaceControl()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterNetInterfaceControl(
						hNetInterface,
						hHostNode,
						dwControlCode,
						lpInBuffer,
						nInBufferSize,
						lpOutBuffer,
						nOutBufferSize,
						lpBytesReturned
						);

}  //*** BARFClusterNetInterfaceControl()

/////////////////////////////////////////////////////////////////////////////
// Cluster Database Management Functions
/////////////////////////////////////////////////////////////////////////////

LONG BARFClusterRegCloseKey(HKEY hKey)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegCloseKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegCloseKey(hKey);

}  //*** BARFClusterRegCloseKey()

LONG BARFClusterRegCreateKey(
	HKEY hKey,
	LPCWSTR lpszSubKey,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegCreateKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegCreateKey(
						hKey,
						lpszSubKey,
						dwOptions,
						samDesired,
						lpSecurityAttributes,
						phkResult,
						lpdwDisposition
						);

}  //*** BARFClusterRegCreateKey()

LONG BARFClusterRegDeleteKey(
	HKEY hKey,
	LPCWSTR lpszSubKey
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegDeleteKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegDeleteKey(hKey, lpszSubKey);

}  //*** BARFClusterRegDeleteKey()

DWORD BARFClusterRegDeleteValue(
	HKEY hKey,
	LPCWSTR lpszValueName
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegDeleteValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegDeleteValue(hKey, lpszValueName);

}  //*** BARFClusterRegDeleteValue()

LONG BARFClusterRegEnumKey(
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpszName,
	LPDWORD lpcchName,
	PFILETIME lpftLastWriteTime
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegEnumKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegEnumKey(
						hKey,
						dwIndex,
						lpszName,
						lpcchName,
						lpftLastWriteTime
						);

}  //*** BARFClusterRegEnumKey()

DWORD BARFClusterRegEnumValue(
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpszValueName,
	LPDWORD lpcchValueName,
	LPDWORD lpdwType,
	LPBYTE lpbData,
	LPDWORD lpcbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegEnumValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegEnumValue(
						hKey,
						dwIndex,
						lpszValueName,
						lpcchValueName,
						lpdwType,
						lpbData,
						lpcbData
						);

}  //*** BARFClusterRegEnumValue()

LONG BARFClusterRegGetKeySecurity(
	HKEY hKey,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	LPDWORD lpcbSecurityDescriptor
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegGetKeySecurity()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegGetKeySecurity(
						hKey,
						SecurityInformation,
						pSecurityDescriptor,
						lpcbSecurityDescriptor
						);

}  //*** BARFClusterRegGetKeySecurity()

LONG BARFClusterRegOpenKey(
	HKEY hKey,
	LPCWSTR lpszSubKey,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegOpenKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegOpenKey(
						hKey,
						lpszSubKey,
						samDesired,
						phkResult
						);

}  //*** BARFClusterRegOpenKey()

LONG BARFClusterRegQueryInfoKey(
	HKEY hKey,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegQueryInfoKey()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegQueryInfoKey(
						hKey,
						lpcSubKeys,
						lpcbMaxSubKeyLen,
						lpcValues,
						lpcbMaxValueNameLen,
						lpcbMaxValueLen,
						lpcbSecurityDescriptor,
						lpftLastWriteTime
						);

}  //*** BARFClusterRegQueryInfoKey()

LONG BARFClusterRegQueryValue(
	HKEY hKey,
	LPCWSTR lpszValueName,
	LPDWORD lpdwValueType,
	LPBYTE lpbData,
	LPDWORD lpcbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegQueryValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegQueryValue(
						hKey,
						lpszValueName,
						lpdwValueType,
						lpbData,
						lpcbData
						);

}  //*** BARFClusterRegQueryValue()

LONG BARFClusterRegSetKeySecurity(
	HKEY hKey,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegSetKeySecurity()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegSetKeySecurity(
						hKey,
						SecurityInformation,
						pSecurityDescriptor
						);

}  //*** BARFClusterRegSetKeySecurity()

DWORD BARFClusterRegSetValue(
	HKEY hKey,
	LPCWSTR lpszValueName,
	DWORD dwType,
	CONST BYTE * lpbData,
	DWORD cbData
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("ClusterRegSetValue()"));
		return ERROR_INVALID_FUNCTION;
	}  // if:  BARF failure
	else
		return ClusterRegSetValue(
						hKey,
						lpszValueName,
						dwType,
						lpbData,
						cbData
						);

}  //*** BARFClusterRegSetValue()

HKEY BARFGetClusterGroupKey(
	HGROUP hGroup,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterGroupKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterGroupKey(hGroup, samDesired);

}  //*** BARFGetClusterGroupKey()

HKEY BARFGetClusterKey(
	HCLUSTER hCluster,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterKey(hCluster, samDesired);

}  //*** BARFGetClusterKey()

HKEY BARFGetClusterNodeKey(
	HNODE hNode,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNodeKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNodeKey(hNode, samDesired);

}  //*** BARFGetClusterNodeKey()

HKEY BARFGetClusterResourceKey(
	HRESOURCE hResource,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceKey(hResource, samDesired);

}  //*** BARFGetClusterResourceKey()

HKEY BARFGetClusterResourceTypeKey(
	HCLUSTER hCluster,
	LPCWSTR lpszTypeName,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterResourceTypeKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterResourceTypeKey(hCluster, lpszTypeName, samDesired);

}  //*** BARFGetClusterResourceTypeKey()

HKEY BARFGetClusterNetworkKey(
	HNETWORK hNetwork,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetworkKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetworkKey(hNetwork, samDesired);

}  //*** BARFGetClusterNetworkKey()

HKEY BARFGetClusterNetInterfaceKey(
	HNETINTERFACE hNetInterface,
	REGSAM samDesired
	)
{
	if (g_barfClusApi.BFail())
	{
		Trace(g_tagBarf, _T("GetClusterNetInterfaceKey()"));
		SetLastError(ERROR_INVALID_FUNCTION);
		return NULL;
	}  // if:  BARF failure
	else
		return GetClusterNetInterfaceKey(hNetInterface, samDesired);

}  //*** BARFGetClusterNetInterfaceKey()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basedlg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1998 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.cpp
//
//	Abstract:
//		Implementation of the CBaseDialog class.
//
//	Author:
//		David Potter (davidp)	February 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseDlg.h"
#include "TraceTag.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagBaseDlg(_T("UI"), _T("BASE DIALOG"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog class
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseDialog, CDialog)

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog Message Map

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialog)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pdwHelpMap			[IN] Control to help ID map.
//		lpszTemplateName	[IN] Dialog template name.
//		pParentWnd			[IN OUT] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN LPCTSTR			lpszTemplateName,
	IN const DWORD *	pdwHelpMap,
	IN OUT CWnd *		pParentWnd
	)
	: CDialog(lpszTemplateName, pParentWnd)
	, m_dlghelp(pdwHelpMap, 0) // no help mask in this case
{
}  //*** CBaseDialog::CBaseDialog(LPCTSTR, CWnd*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::CBaseDialog
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		pParentWnd		[IN OUT] Parent window for the dialog.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseDialog::CBaseDialog(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN OUT CWnd *		pParentWnd
	)
	: CDialog(idd, pParentWnd)
	, m_dlghelp(pdwHelpMap, idd)
{
	//{{AFX_DATA_INIT(CBaseDialog)
	//}}AFX_DATA_INIT

}  //*** CBaseDialog::CBaseDialog(UINT, CWnd*)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::DoDataExchange(CDataExchange * pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBaseDialog)
	//}}AFX_DATA_MAP

}  //*** CBaseDialog::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseDialog::OnContextMenu(CWnd * pWnd, CPoint point)
{
	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBaseDialog::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseDialog::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CDialog::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBaseDialog::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseDialog::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseDialog::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	lProcessed;

	lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!lProcessed)
		lProcessed = CDialog::OnCommandHelp(wParam, lParam);

	return lProcessed;

}  //*** CBaseDialog::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basecmdt.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseCmdT.h
//
//	Abstract:
//		Definition of the CBaseCmdTarget class.
//
//	Implementation File:
//		BaseCmdT.cpp
//
//	Author:
//		David Potter (davidp)	December 11, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASECMDT_H_
#define _BASECMDT_H_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseCmdTarget;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBaseCmdTarget command target
/////////////////////////////////////////////////////////////////////////////

class CBaseCmdTarget : public CCmdTarget
{
	DECLARE_DYNCREATE(CBaseCmdTarget)

// Construction
public:
	CBaseCmdTarget(void) { m_nReferenceCount = 0; }	// protected constructor used by dynamic creation

// Attributes
protected:
	ULONG				m_nReferenceCount;

public:
	ULONG				NReferenceCount(void) const	{ return m_nReferenceCount; }

// Operations
public:
	ULONG				AddRef(void)
	{
		return ++m_nReferenceCount;
	}
	ULONG				Release(void)
	{
		ULONG	nReferenceCount;

		ASSERT(m_nReferenceCount != 0);

		nReferenceCount = --m_nReferenceCount;
		if (m_nReferenceCount == 0)
			delete this;

		return nReferenceCount;
	}

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseCmdTarget)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBaseCmdTarget)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

};  //*** class CBaseCmdTarget

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//	Global Variables
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

#endif // _BASECMDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basepage.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.cpp
//
//	Abstract:
//		Implementation of the CBasePage class.
//
//	Author:
//		David Potter (davidp)	May 15, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePage.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePage, CPropertyPage)

/////////////////////////////////////////////////////////////////////////////
// CBasePage Message Map

BEGIN_MESSAGE_MAP(CBasePage, CPropertyPage)
	//{{AFX_MSG_MAP(CBasePage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	ON_MESSAGE(WM_COMMANDHELP, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CBasePage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePage::CBasePage(void)
{
	CommonConstruct();

}  //*** CBasePage::CBasePage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CBasePage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePage::CBasePage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CPropertyPage(idd, nIDCaption)
	, m_dlghelp(pdwHelpMap, idd)
{
	//{{AFX_DATA_INIT(CBasePage)
	//}}AFX_DATA_INIT

	CommonConstruct();

}  //*** CBasePage::CBasePage(UINT, UINT)

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::CommonConstruct
//
//	Routine Description:
//		Common construction code.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::CommonConstruct(void)
{
	m_bReadOnly = FALSE;

}  //*** CBasePage::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::BInit
//
//	Routine Description:
//		Initialize the page.
//
//	Arguments:
//		psht		[IN OUT] Property sheet to which this page belongs.
//
//	Return Value:
//		TRUE		Page initialized successfully.
//		FALSE		Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::BInit(IN OUT CBaseSheet * psht)
{
	ASSERT_VALID(psht);

	m_psht = psht;

	// Don't display a help button.
	m_psp.dwFlags &= ~PSP_HASHELP;

	return TRUE;

}  //*** CBasePage::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::DoDataExchange
//
//	Routine Description:
//		Do data exchange between the dialog and the class.
//
//	Arguments:
//		pDX		[IN OUT] Data exchange object 
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::DoDataExchange(CDataExchange * pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBasePage)
	//}}AFX_DATA_MAP
	DDX_Control(pDX, IDC_PP_ICON, m_staticIcon);
	DDX_Control(pDX, IDC_PP_TITLE, m_staticTitle);

	if (!pDX->m_bSaveAndValidate)
	{
		// Set the title.
		DDX_Text(pDX, IDC_PP_TITLE, (CString &) Psht()->StrObjTitle());
	}  // if:  not saving data

}  //*** CBasePage::DoDataExchange()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnInitDialog(void)
{
	BOOL	bFocusNotSetYet;

	bFocusNotSetYet = CPropertyPage::OnInitDialog();

	// Display an icon for the object.
	if (Psht()->Hicon() != NULL)
		m_staticIcon.SetIcon(Psht()->Hicon());

	return bFocusNotSetYet;	// return TRUE unless you set the focus to a control
							// EXCEPTION: OCX Property Pages should return FALSE

}  //*** CBasePage::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnSetActive
//
//	Routine Description:
//		Handler for when the PSM_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnSetActive(void)
{
	return CPropertyPage::OnSetActive();

}  //*** CBasePage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnKillActive
//
//	Routine Description:
//		Handler for the PSM_KILLACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page focus successfully killed.
//		FALSE	Error killing page focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnKillActive(void)
{
	return CPropertyPage::OnKillActive();

}  //*** CBasePage::OnKillActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnApply
//
//	Routine Description:
//		Handler for the PSM_APPLY message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnApply(void)
{
	ASSERT(!BReadOnly());
	return CPropertyPage::OnApply();

}  //*** CBasePage::OnApply()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnChangeCtrl
//
//	Routine Description:
//		Handler for the messages sent when a control is changed.  This
//		method can be specified in a message map if all that needs to be
//		done is enable the Apply button.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::OnChangeCtrl(void)
{
	SetModified(TRUE);

}  //*** CBasePage::OnChangeCtrl()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::SetObjectTitle
//
//	Routine Description:
//		Set the title control on the page.
//
//	Arguments:
//		rstrTitle	[IN] Title string.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::SetObjectTitle(IN const CString & rstrTitle)
{
	Psht()->SetObjectTitle(rstrTitle);
	if (m_hWnd != NULL)
		m_staticTitle.SetWindowText(rstrTitle);

}  //*** CBasePage::SetObjectTitle()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnContextMenu
//
//	Routine Description:
//		Handler for the WM_CONTEXTMENU message.
//
//	Arguments:
//		pWnd	Window in which user clicked the right mouse button.
//		point	Position of the cursor, in screen coordinates.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePage::OnContextMenu(CWnd * pWnd, CPoint point)
{
	m_dlghelp.OnContextMenu(pWnd, point);

}  //*** CBasePage::OnContextMenu()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnHelpInfo
//
//	Routine Description:
//		Handler for the WM_HELPINFO message.
//
//	Arguments:
//		pHelpInfo	Structure containing info about displaying help.
//
//	Return Value:
//		TRUE		Help processed.
//		FALSE		Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePage::OnHelpInfo(HELPINFO * pHelpInfo)
{
	BOOL	bProcessed;

	bProcessed = m_dlghelp.OnHelpInfo(pHelpInfo);
	if (!bProcessed)
		bProcessed = CPropertyPage::OnHelpInfo(pHelpInfo);
	return bProcessed;

}  //*** CBasePage::OnHelpInfo()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePage::OnCommandHelp
//
//	Routine Description:
//		Handler for the WM_COMMANDHELP message.
//
//	Arguments:
//		wParam		[IN] WPARAM.
//		lParam		[IN] LPARAM.
//
//	Return Value:
//		TRUE	Help processed.
//		FALSE	Help not processed.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBasePage::OnCommandHelp(WPARAM wParam, LPARAM lParam)
{
	LRESULT	lProcessed;

	lProcessed = m_dlghelp.OnCommandHelp(wParam, lParam);
	if (!lProcessed)
		lProcessed = CPropertyPage::OnCommandHelp(wParam, lParam);

	return lProcessed;

}  //*** CBasePage::OnCommandHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\baseppag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePPag.cpp
//
//	Abstract:
//		Implementation of the CBasePropertyPage class.
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePPag.h"
#include "ClusItem.h"

#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBasePropertyPage, CBasePage)

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage Message Map

BEGIN_MESSAGE_MAP(CBasePropertyPage, CBasePage)
	//{{AFX_MSG_MAP(CBasePropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(void)
{
}  //*** CBasePropertyPage::CBasePropertyPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBasePropertyPage::CBasePropertyPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage::CBasePropertyPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CBasePage(idd, pdwHelpMap, nIDCaption)
{
	//{{AFX_DATA_INIT(CBasePage)
	//}}AFX_DATA_INIT

}  //*** CBasePropertyPage::CBasePropertyPage(UINT, UINT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\baseppag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePPag.h
//
//	Abstract:
//		Definition of the CBasePropertyPage class.
//
//	Implementation File:
//		BasePPag.cpp
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPPAG_H_
#define _BASEPPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePage
#endif

#ifndef _BASEPSHT_H_
#include "BasePsht.h"	// for CBasePropertySheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CBasePropertyPage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePropertyPage : public CBasePage
{
	DECLARE_DYNCREATE(CBasePropertyPage)

// Construction
public:
	CBasePropertyPage(void);
	CBasePropertyPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

// Dialog Data
	//{{AFX_DATA(CBasePropertyPage)
	enum { IDD = 0 };
	//}}AFX_DATA

// Attributes
protected:
	CBasePropertySheet *	Ppsht(void) const	{ return (CBasePropertySheet *) Psht(); }
	CClusterItem *			Pci(void) const		{ ASSERT_VALID(m_psht); return Ppsht()->Pci(); }

// Operations

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertyPage)
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CBasePropertyPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertyPage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPPAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basedlg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		BaseDlg.h
//
//	Abstract:
//		Definition of the CBaseDialog class.
//
//	Implementation File:
//		BaseDlg.cpp
//
//	Author:
//		David Potter (davidp)	February 5, 1997
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEDLG_H_
#define _BASEDLG_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseDialog dialog
/////////////////////////////////////////////////////////////////////////////

class CBaseDialog : public CDialog
{
	DECLARE_DYNCREATE(CBaseDialog)

// Construction
public:
	CBaseDialog(void) { }
	CBaseDialog(
		IN LPCTSTR			lpszTemplateName,
		IN const DWORD *	pdwHelpMap,
		IN OUT CWnd *		pParentWnd = NULL
		);
	CBaseDialog(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN OUT CWnd *		pParentWnd = NULL
		);

// Dialog Data
	//{{AFX_DATA(CBaseDialog)
	enum { IDD = 0 };
	//}}AFX_DATA

// Attributes

// Operations
public:
	void			SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp		m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBaseDialog)
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseDialog

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basepage.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePage.h
//
//	Abstract:
//		Definition of the CBasePage class.
//
//	Implementation File:
//		BasePage.cpp
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#define _BASEPAGE_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePage;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"	// for CBaseSheet
#endif

#ifndef _DLGHELP_H_
#include "DlgHelp.h"	// for CDialogHelp
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePage dialog
/////////////////////////////////////////////////////////////////////////////

class CBasePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CBasePage)

// Construction
public:
	CBasePage(void);
	CBasePage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

	void					CommonConstruct(void);
	virtual	BOOL			BInit(IN OUT CBaseSheet * psht);

// Dialog Data
	//{{AFX_DATA(CBasePage)
	enum { IDD = 0 };
	//}}AFX_DATA
	CStatic	m_staticIcon;
	CStatic	m_staticTitle;

// Attributes
protected:
	CBaseSheet *			m_psht;
	BOOL					m_bReadOnly;

	CBaseSheet *			Psht(void) const		{ return m_psht; }
	BOOL					BReadOnly(void) const	{ return m_bReadOnly || Psht()->BReadOnly(); }

// Operations
public:
	void					SetHelpMask(IN DWORD dwMask)	{ m_dlghelp.SetHelpMask(dwMask); }
	void					SetObjectTitle(IN const CString & rstrTitle);

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBasePage)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CDialogHelp				m_dlghelp;

	// Generated message map functions
	//{{AFX_MSG(CBasePage)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	virtual afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnChangeCtrl();
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basesht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseSht.cpp
//
//	Abstract:
//		Implementation of the CBaseSheet class.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "BaseSht.h"
#include "TraceTag.h"
#include "ExtDll.h"
#include "ExcOper.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag	g_tagBaseSheet(_T("UI"), _T("BASE SHEET"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CBaseSheet, CPropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBaseSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CBaseSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CBaseSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::CBaseSheet(
	IN OUT CWnd *	pParentWnd,
	IN UINT			iSelectPage
	)
{
	CommonConstruct();
	m_pParentWnd = pParentWnd;

}  //*** CBaseSheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CBaseSheet
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		nIDCaption	[IN] String resource ID for the caption for the wizard.
//		pParentWnd	[IN OUT] Parent window for this property sheet.
//		iSelectPage	[IN] Page to show first.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::CBaseSheet(
	IN UINT			nIDCaption,
	IN OUT CWnd *	pParentWnd,
	IN UINT			iSelectPage
	)
	: CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	CommonConstruct();

}  //*** CBaseSheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::CommonConstruct
//
//	Routine Description:
//		Common Constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseSheet::CommonConstruct(void)
{
	m_bReadOnly = FALSE;
	m_hicon = NULL;
	m_strObjTitle.Empty();

}  //*** CBaseSheet::CommonConstruct()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::~CBaseSheet
//
//	Routine Description:
//		Destructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseSheet::~CBaseSheet(void)
{
	CommonConstruct();

}  //*** CBaseSheet::~CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::BInit
//
//	Routine Description:
//		Initialize the property sheet.
//
//	Arguments:
//		iimgIcon	[IN] Index in the large image list for the image to use
//					  as the icon on each page.
//
//	Return Value:
//		TRUE		Property sheet initialized successfully.
//		FALSE		Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheet::BInit(IN IIMG iimgIcon)
{
	BOOL		bSuccess	= TRUE;
	CWaitCursor	wc;

	try
	{
		// Extract the icon to use in the upper left corner.
		m_hicon = GetClusterAdminApp()->PilLargeImages()->ExtractIcon(iimgIcon);
	}  // try
	catch (CException * pe)
	{
		pe->ReportError();
		pe->Delete();
		bSuccess = FALSE;
	}  // catch:  anything

	return bSuccess;

}  //*** CBaseSheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseSheet::OnInitDialog
//
//	Routine Description:
//		Handler for the WM_INITDIALOG message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE		Focus not set yet.
//		FALSE		Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseSheet::OnInitDialog(void)
{
	BOOL	bFocusNotSet;
	HWND	hTabControl = NULL;

	// Call the base class method.
	bFocusNotSet = CPropertySheet::OnInitDialog();

	// Display the context help button on the title bar.
	ModifyStyle(0, WS_SYSMENU);
	ModifyStyleEx(0, WS_EX_CONTEXTHELP);

	//
	// Turn off the Multiline style so that we get the arrows ( <- -> ) instead of multiple rows of tabs.
	// There is a problem when extension pages that have long
	hTabControl = PropSheet_GetTabControl( *this );
	if ( hTabControl != 0 )
	{
		CTabCtrl	tc;

		if ( tc.Attach( hTabControl ) )
		{
			tc.ModifyStyle( TCS_MULTILINE, 0 );
		}

		tc.Detach();
	}

	return bFocusNotSet;

}  //*** CBaseSheet::OnInitDialog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basepsht.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BasePSht.cpp
//
//  Abstract:
//      Implementation of the CBasePropertySheet class.
//
//  Author:
//      David Potter (davidp)   August 31, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BasePSht.h"
#include "ClusItem.h"
#include "TraceTag.h"
#include "BasePPag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagBasePropSheet(_T("UI"), _T("BASE PROP SHEET"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CBasePropertySheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CBasePropertySheet, CBaseSheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CBasePropertySheet, CBaseSheet)
    //{{AFX_MSG_MAP(CBasePropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::CBasePropertySheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheet::CBasePropertySheet(
    IN OUT CWnd *   pParentWnd,
    IN UINT         iSelectPage
    )
    :
    CBaseSheet(pParentWnd, iSelectPage)
{
    m_pci = NULL;

}  //*** CBasePropertySheet::CBaseSheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::~CBasePropertySheet
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertySheet::~CBasePropertySheet(void)
{
    if (m_pci != NULL)
        m_pci->Release();

}  //*** CBasePropertySheet::~CBasePropertySheet()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    ASSERT_VALID(pci);

    // Call the base class method.
    if (!CBaseSheet::BInit(iimgIcon))
        return FALSE;

    ASSERT(m_pci == NULL);
    m_pci = pci;
    pci->AddRef();

    try
    {
        // Set the object title.
        m_strObjTitle = Pci()->PszTitle();

        // Set the property sheet caption.
        SetCaption(StrObjTitle());

        // Add non-extension pages.
        {
            CBasePropertyPage **    ppages  = Ppages();
            int                     cpages  = Cpages();
            int                     ipage;

            ASSERT(ppages != NULL);
            ASSERT(cpages != 0);

            for (ipage = 0 ; ipage < cpages ; ipage++)
            {
                ASSERT_VALID(ppages[ipage]);
                ppages[ipage]->BInit(this);
                AddPage(ppages[ipage]);
            }  // for:  each page
        }  // Add non-extension pages

        // Add extension pages.
        AddExtensionPages(Pci()->PlstrExtensions(), Pci());

    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        bSuccess = FALSE;
    }  // catch:  anything

    return bSuccess;

}  //*** CBasePropertySheet::BInit()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::DoModal
//
//  Routine Description:
//      Display a modal property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      id          Control the user pressed to dismiss the sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
INT_PTR CBasePropertySheet::DoModal(void)
{
    INT_PTR id      = IDCANCEL;

    // Don't display a help button.
    m_psh.dwFlags &= ~PSH_HASHELP;

    // Display the property sheet.
    id = CBaseSheet::DoModal();

    // Update the state.
    Trace(g_tagBasePropSheet, _T("DoModal: Calling UpdateState()"));
    Pci()->UpdateState();

    return id;

}  //*** CBasePropertySheet::DoModal()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      plstrExtensions [IN] List of extension names (CLSIDs).
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheet::AddExtensionPages(
    IN const CStringList *  plstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID(pci);

    // Add extension pages.
    if ((plstrExtensions != NULL)
            && (plstrExtensions->GetCount() > 0))
    {
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        try
        {
            Ext().CreatePropertySheetPages(
                    this,
                    *plstrExtensions,
                    pci,
                    NULL,
                    Hicon()
                    );
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException
        catch (...)
        {
        }  // catch:  anything
    }  // Add extension pages

}  //*** CBasePropertySheet::AddExtensionPages()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::HrAddPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      hpage       [IN OUT] Page to be added.
//
//  Return Value:
//      TRUE        Page added successfully.
//      FALSE       Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBasePropertySheet::HrAddPage(IN OUT HPROPSHEETPAGE hpage)
{
    HRESULT     hr = ERROR_SUCCESS;

    ASSERT(hpage != NULL);
    if (hpage == NULL)
        return FALSE;

    // Add the page to the end of the list.
    try
    {
        Lhpage().AddTail(hpage);
    }  // try
    catch (...)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  anything

    return hr;

}  //*** CBasePropertySheet::HrAddPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBasePropertySheet::OnInitDialog(void)
{
    BOOL    bFocusNotSet;

    bFocusNotSet = CBaseSheet::OnInitDialog();

    // Add all the extension pages.
    {
        POSITION        pos;
        HPROPSHEETPAGE  hpage;

        pos = Lhpage().GetHeadPosition();
        while (pos != NULL)
        {
            hpage = (HPROPSHEETPAGE) Lhpage().GetNext(pos);
            SendMessage(PSM_ADDPAGE, 0, (LPARAM) hpage);
        }  // while:  more pages to add
    }  // Add all the extension pages

    return bFocusNotSet;

}  //*** CBasePropertySheet::OnInitDialog()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBasePropertySheet::SetCaption
//
//  Routine Description:
//      Set the caption for the property sheet.
//
//  Arguments:
//      pszTitle    [IN] String to be included in the caption.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBasePropertySheet::SetCaption(IN LPCTSTR pszTitle)
{
    CString strCaption;

    ASSERT(pszTitle != NULL);

    try
    {
        strCaption.FormatMessage(IDS_PROPSHEET_CAPTION, pszTitle);
        SetTitle(strCaption);
    }  // try
    catch (CException * pe)
    {
        // Ignore the error.
        pe->Delete();
    }  // catch:  CException

}  //*** CBasePropertySheet::SetCaption()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basepsht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BasePSht.cpp
//
//	Abstract:
//		Definition of the CBasePropertySheet class.
//
//	Author:
//		David Potter (davidp)	August 31, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPSHT_H_
#define _BASEPSHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"	// for CBaseSheet, CHpageList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// CBasePropertySheet
/////////////////////////////////////////////////////////////////////////////

class CBasePropertySheet : public CBaseSheet
{
	DECLARE_DYNAMIC(CBasePropertySheet)

// Construction
public:
	CBasePropertySheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	virtual ~CBasePropertySheet(void);
	virtual BOOL					BInit(
										IN OUT CClusterItem *	pciCluster,
										IN IIMG					iimgIcon
										);

// Attributes

// Operations

// Overrides
public:
	virtual INT_PTR         		DoModal(void);
	virtual void					AddExtensionPages(
										IN const CStringList *	plstrExtensions,
										IN OUT CClusterItem *	pci
										);
	virtual HRESULT					HrAddPage(IN OUT HPROPSHEETPAGE hpage);
	virtual CBasePropertyPage **	Ppages(void)	= 0;
	virtual int						Cpages(void)	= 0;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBasePropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:
	CClusterItem *					m_pci;
	CHpageList						m_lhpage;

public:
	CClusterItem *					Pci(void) const			{ return m_pci; }
	CHpageList &					Lhpage(void)			{ return m_lhpage; }
	void							SetCaption(IN LPCTSTR pszTitle);

	// Generated message map functions
	//{{AFX_MSG(CBasePropertySheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBasePropertySheet

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEPSHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basesht.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseSht.cpp
//
//	Abstract:
//		Definition of the CBaseSheet class.
//
//	Author:
//		David Potter (davidp)	May 14, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#define _BASESHT_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _EXTDLL_H_
#include "ExtDll.h"		// for CExtensions
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseSheet;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CBasePropertyPage;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

typedef CList<HANDLE, HANDLE> CHpageList;

/////////////////////////////////////////////////////////////////////////////
// CBaseSheet
/////////////////////////////////////////////////////////////////////////////

class CBaseSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CBaseSheet)

// Construction
public:
	CBaseSheet(
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	CBaseSheet(
		IN UINT			nIDCaption,
		IN OUT CWnd *	pParentWnd = NULL,
		IN UINT			iSelectPage = 0
		);
	BOOL				BInit(IN IIMG iimgIcon);

protected:
	void				CommonConstruct(void);

// Attributes

// Operations
public:
	void				SetPfGetResNetName(PFGETRESOURCENETWORKNAME pfGetResNetName, PVOID pvContext)
	{
		Ext().SetPfGetResNetName(pfGetResNetName, pvContext);
	}

// Overrides
public:
	virtual void		AddExtensionPages(
							IN const CStringList *	plstrExtensions,
							IN OUT CClusterItem *	pci
							) = 0;
	virtual HRESULT		HrAddPage(IN OUT HPROPSHEETPAGE hpage) = 0;

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseSheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CBaseSheet(void);

protected:
	BOOL				m_bReadOnly;
	HICON				m_hicon;
	CString				m_strObjTitle;

	CExtensions			m_ext;

public:
	BOOL				BReadOnly(void) const					{ return m_bReadOnly; }
	void				SetReadOnly(IN BOOL bReadOnly = TRUE)	{ m_bReadOnly = bReadOnly; }
	HICON				Hicon(void) const						{ return m_hicon; }
	const CString &		StrObjTitle(void) const					{ return m_strObjTitle; }
	void				SetObjectTitle(IN const CString & rstrTitle)
	{
		m_strObjTitle = rstrTitle;
	}

	CExtensions &		Ext(void)								{ return m_ext; }

	// Generated message map functions
	//{{AFX_MSG(CBaseSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseSheet

/////////////////////////////////////////////////////////////////////////////

#endif // _BASESHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basewiz.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseWiz.h
//
//  Abstract:
//      Definition of the CBaseWizard class.
//
//  Implementation File:
//      BaseWiz.cpp
//
//  Author:
//      David Potter (davidp)   July 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWIZ_H_
#define _BASEWIZ_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASESHT_H_
#include "BaseSht.h"    // for CBaseSheet
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

struct CWizPage;
class CBaseWizard;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage;
class CClusterItem;

/////////////////////////////////////////////////////////////////////////////
// CWizPage
/////////////////////////////////////////////////////////////////////////////

struct CWizPage
{
    CBaseWizardPage *   m_pwpage;
    DWORD               m_dwWizButtons;

};  //*** struct CWizPage

/////////////////////////////////////////////////////////////////////////////
// CBaseWizard
/////////////////////////////////////////////////////////////////////////////

class CBaseWizard : public CBaseSheet
{
    DECLARE_DYNAMIC(CBaseWizard)

// Construction
public:
    CBaseWizard(
        IN UINT         nIDCaption,
        IN OUT CWnd *   pParentWnd  = NULL,
        IN UINT         iSelectPage = 0
        );
    virtual                 ~CBaseWizard( void )
    {
    } //*** ~CBaseWizard( )

    BOOL                    BInit( IN IIMG iimgIcon );

// Attributes
    CWizPage *              PwizpgFromPwpage( IN const CBaseWizardPage & rwpage );

// Operations
public:
    void                    LoadExtensions( IN OUT CClusterItem * pci );
    void                    SetWizardButtons( IN const CBaseWizardPage & rwpage );
    void                    SetWizardButtons( DWORD dwFlags )
    {
        CBaseSheet::SetWizardButtons( dwFlags );
    } //*** SetWizardButtons( )

    void                    EnableNext(
                                IN const CBaseWizardPage &  rwpage,
                                IN BOOL bEnable = TRUE
                                );

// Overrides
public:
    virtual INT_PTR         DoModal( void );
    virtual void            AddExtensionPages(
                                IN const CStringList *  plstrExtensions,
                                IN OUT CClusterItem *   pci
                                );
    virtual HRESULT         HrAddPage( IN OUT HPROPSHEETPAGE hpage );
    virtual void            OnWizardFinish( void );
    virtual void            OnCancel( void );
    virtual CWizPage *      Ppages( void )    = 0;
    virtual int             Cpages( void )    = 0;

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBaseWizard)
    public:
    virtual BOOL OnInitDialog();
    //}}AFX_VIRTUAL

// Implementation
protected:
    CClusterItem *          m_pci;
    CHpageList              m_lhpage;
    BOOL                    m_bNeedToLoadExtensions;

public:
    CClusterItem *          Pci( void ) const                   { return m_pci; }
    CHpageList &            Lhpage( void )                      { return m_lhpage; }
    BOOL                    BNeedToLoadExtensions( void ) const { return m_bNeedToLoadExtensions; }

    // Generated message map functions
protected:
    //{{AFX_MSG(CBaseWizard)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};  //*** class CBaseWizard

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basewiz.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      BaseWiz.cpp
//
//  Description:
//      Implementation of the CBaseWizard class.
//
//  Maintained By:
//      David Potter (davidp)   July 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseWiz.h"
#include "BaseWPag.h"
#include "ClusItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseWizard
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC( CBaseWizard, CBaseSheet )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CBaseWizard, CBaseSheet )
    //{{AFX_MSG_MAP(CBaseWizard)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::CBaseWizard
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      nIDCaption  [IN] String resource ID for the caption for the wizard.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizard::CBaseWizard(
    IN UINT         nIDCaption,
    IN OUT CWnd *   pParentWnd,
    IN UINT         iSelectPage
    )
    : CBaseSheet( nIDCaption, pParentWnd, iSelectPage )
{
    m_pci = NULL;
    m_bNeedToLoadExtensions = TRUE;

}  //*** CBaseWizard::CBaseWizard( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::BInit
//
//  Routine Description:
//      Initialize the wizard.
//
//  Arguments:
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE    Wizard initialized successfully.
//      FALSE   Wizard not initialized successfully.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizard::BInit( IN IIMG iimgIcon )
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    // Call the base class method.
    if ( ! CBaseSheet::BInit( iimgIcon ) )
    {
        return FALSE;
    } // if

    // Make this sheet a wizard.
    SetWizardMode( );

    // Add non-extension pages.
    try
    {
        // Add non-extension pages.
        {
            CWizPage *  ppages  = Ppages( );
            int         cpages  = Cpages( );
            int         ipage;

            ASSERT( ppages != NULL );
            ASSERT( cpages != 0 );

            for ( ipage = 0 ; ipage < cpages ; ipage++ )
            {
                ASSERT_VALID( ppages[ ipage ].m_pwpage );
                ppages[ ipage ].m_pwpage->BInit( this );
                AddPage( ppages[ ipage ].m_pwpage );
            }  // for:  each page
        }  // Add non-extension pages

    }  // try
    catch ( CException * pe )
    {
        pe->ReportError( );
        pe->Delete( );
        bSuccess = FALSE;
    }  // catch:  anything

    return bSuccess;

}  //*** CBaseWizard::BInit( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::DoModal
//
//  Routine Description:
//      Display a modal wizard.  Calls OnWizardFinish( ) or OnCancel( ) based
//      on what the user pressed to dismiss the wizard.
//
//  Arguments:
//      None.
//
//  Return Value:
//      id          Control the user pressed to dismiss the wizard.
//
//--
/////////////////////////////////////////////////////////////////////////////
INT_PTR CBaseWizard::DoModal( void )
{
    INT_PTR     id;

    // Don't display a help button.
    m_psh.dwFlags &= ~PSH_HASHELP;

    // Display the property sheet.
    id = CBaseSheet::DoModal( );
    if ( id == ID_WIZFINISH )
    {
        OnWizardFinish( );
    } // if
    else if ( id == IDCANCEL )
    {
        OnCancel( );
    } // else

    return id;

}  //*** CBaseWizard::DoModal( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizard::OnInitDialog( void )
{
    BOOL    bFocusNotSet;

    // Call the base class method.
    bFocusNotSet = CBaseSheet::OnInitDialog( );

    // Remove the system menu.
    ModifyStyle( WS_SYSMENU, 0 );

    return bFocusNotSet;

}  //*** CBaseWizard::OnInitDialog( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnWizardFinish
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Finish button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::OnWizardFinish( void )
{
}  //*** CBaseWizard::OnWizardFinish( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::OnCancel
//
//  Routine Description:
//      Called after the wizard has been dismissed when the Cancel button
//      has been pressed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::OnCancel( void )
{
}  //*** CBaseWizard::OnCancel( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::LoadExtensions
//
//  Routine Description:
//      Load extensions to the wizard.  Unload existing extension pages
//      if necessary.
//
//  Arguments:
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::LoadExtensions(
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID( pci );

    if ( BNeedToLoadExtensions( ) )
    {
        // Remove previous extensions.
        {
            POSITION    pos;

            pos = Lhpage( ).GetHeadPosition( );
            while ( pos != NULL )
            {
                SendMessage( PSM_REMOVEPAGE, 0, (LPARAM) Lhpage( ).GetNext( pos ) );
            } // while
            Lhpage( ).RemoveAll( );
        }  // Remove previous extensions

        // Add extension pages.
        m_pci = pci;
        AddExtensionPages( Pci( )->PlstrExtensions( ), Pci( ) );
        m_bNeedToLoadExtensions = FALSE;

        // Set the last page's wizard button setting.
        {
            CWizPage *  pwizpg = &Ppages( )[ Cpages( ) - 1 ];

            if ( Lhpage( ).GetCount( ) == 0 )
            {
                pwizpg->m_dwWizButtons &= ~PSWIZB_NEXT;
                pwizpg->m_dwWizButtons |= PSWIZB_FINISH;
            }  // if:  no pages added
            else
            {
                pwizpg->m_dwWizButtons |= PSWIZB_NEXT;
                pwizpg->m_dwWizButtons &= ~PSWIZB_FINISH;
            }  // else:  some pages were added
        }  // Set the last page's wizard button setting
    }  // if:  extensions need to be loaded

}  //*** CBaseWizard::LoadExtensions( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::AddExtensionPages
//
//  Routine Description:
//      Add extension pages to the sheet.
//
//  Arguments:
//      plstrExtensions [IN] List of extension names (CLSIDs).
//      pci             [IN OUT] Cluster item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::AddExtensionPages(
    IN const CStringList *  plstrExtensions,
    IN OUT CClusterItem *   pci
    )
{
    ASSERT_VALID( pci );

    // Add extension pages.
    if ( ( plstrExtensions != NULL )
      && ( plstrExtensions->GetCount( ) > 0 ) )
    {
        // Enclose the loading of the extension in a try/catch block so
        // that the loading of the extension won't prevent all pages
        // from being displayed.
        try
        {
            Ext( ).CreateWizardPages(
                    this,
                    *plstrExtensions,
                    pci,
                    NULL,
                    Hicon( )
                    );
        }  // try
        catch ( CException * pe )
        {
            pe->ReportError( );
            pe->Delete( );
        }  // catch:  CException
        catch ( ... )
        {
        }  // catch:  anything
    }  // Add extension pages

}  //*** CBaseWizard::AddExtensionPages( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::SetWizardButtons
//
//  Routine Description:
//      Set the wizard buttons based on which page is asking.
//
//  Arguments:
//      rwpage      [IN] Page to set the buttons for.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::SetWizardButtons( IN const CBaseWizardPage & rwpage )
{
    CWizPage *  pwizpg;

    pwizpg = PwizpgFromPwpage( rwpage );
    if ( pwizpg != NULL )
    {
        SetWizardButtons( pwizpg->m_dwWizButtons );
    } // if: page was found

}  //*** CBaseWizard::SetWizardButtons( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::EnableNext
//
//  Routine Description:
//      Enables or disables the NEXT or FINISH button.
//
//  Arguments:
//      bEnable     [IN] TRUE = enable the button, FALSE = disable the button.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CBaseWizard::EnableNext(
    IN const CBaseWizardPage &  rwpage,
    IN BOOL                     bEnable /*=TRUE*/
    )
{
    DWORD   dwWizButtons;
    CWizPage *  pwizpg;

    pwizpg = PwizpgFromPwpage( rwpage );
    if ( pwizpg != NULL )
    {
        dwWizButtons = pwizpg->m_dwWizButtons;
        if ( ! bEnable )
        {
            dwWizButtons &= ~( PSWIZB_NEXT | PSWIZB_FINISH );
            if ( pwizpg->m_dwWizButtons & PSWIZB_FINISH )
            {
                dwWizButtons |= PSWIZB_DISABLEDFINISH;
            } // if
        }  // if:  disabling the button

        SetWizardButtons( dwWizButtons );
    } // if: page was found

}  //*** CBaseWizard::EnableNext( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::PwizpgFromPwpage
//
//  Routine Description:
//      Find the CWizPage entry for the specified CBaseWizardPage.
//
//  Arguments:
//      rwpage      [IN] Page to search for.
//
//  Return Value:
//      pwizpg      Entry in the Ppages( ) array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CWizPage * CBaseWizard::PwizpgFromPwpage( IN const CBaseWizardPage & rwpage )
{
    int         cwizpg = Cpages( );
    CWizPage *  pwizpg = Ppages( );

    while ( cwizpg-- > 0 )
    {
        if ( pwizpg->m_pwpage == &rwpage )
        {
            return pwizpg;
        } // if
        pwizpg++;
    }  // while:  more pages in the list

    return NULL;

}  //*** CBaseWizard::PwizpgFromPwpage( )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CBaseWizard::HrAddPage
//
//  Routine Description:
//      Add an extension page.
//
//  Arguments:
//      hpage       [IN OUT] Page to be added.
//
//  Return Value:
//      S_OK        Page added successfully.
//      S_FALSE     Page not added.
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT CBaseWizard::HrAddPage( IN OUT HPROPSHEETPAGE hpage )
{
    HRESULT     hr = S_OK;

    ASSERT( hpage != NULL );
    if ( hpage == NULL )
    {
        return S_FALSE;
    } // if

    // Add the page to the wizard.
    try
    {
        // Add the page to the wizard.
        SendMessage( PSM_ADDPAGE, 0, (LPARAM) hpage );

        // Add the page to the end of the list.
        Lhpage( ).AddTail( hpage );
    }  // try
    catch ( CMemoryException * pme )
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        pme->Delete( );
    }  // catch:  anything

    return hr;

}  //*** CBaseWizard::HrAddPage( )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basewpag.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseWPag.h
//
//	Abstract:
//		Definition of the CBaseWizardPage class.
//
//	Implementation File:
//		BaseWPag.cpp
//
//	Author:
//		David Potter (davidp)	July 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEWPAG_H_
#define _BASEWPAG_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _BASEPAGE_H_
#include "BasePage.h"	// for CBasePage
#endif

#ifndef _BASEWIZ_H_
#include "BaseWiz.h"	// for CBaseWizard
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage;

/////////////////////////////////////////////////////////////////////////////
// CBaseWizardPage property page
/////////////////////////////////////////////////////////////////////////////

class CBaseWizardPage : public CBasePage
{
	DECLARE_DYNCREATE(CBaseWizardPage)

// Construction
public:
	CBaseWizardPage(void);
	CBaseWizardPage(
		IN UINT				idd,
		IN const DWORD *	pdwHelpMap,
		IN UINT				nIDCaption = 0
		);

// Dialog Data
	//{{AFX_DATA(CBaseWizardPage)
	enum { IDD = 0 };
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CBaseWizardPage)
	public:
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardBack();
	virtual LRESULT OnWizardNext();
	virtual BOOL OnWizardFinish();
	//}}AFX_VIRTUAL

	virtual BOOL	BApplyChanges(void);

// Implementation
protected:
	BOOL			m_bBackPressed;

	BOOL			BBackPressed(void) const	{ return m_bBackPressed; }
	CBaseWizard *	Pwiz(void) const			{ ASSERT_KINDOF(CBaseWizard, Psht()); return (CBaseWizard *) Psht(); }
	void			EnableNext(IN BOOL bEnable = TRUE)	{ ASSERT_VALID(Pwiz()); Pwiz()->EnableNext(*this, bEnable); }

	// Generated message map functions
	//{{AFX_MSG(CBaseWizardPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  //*** class CBaseWizardPage

/////////////////////////////////////////////////////////////////////////////

#endif // _BASEWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\basewpag.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		BaseWPag.cpp
//
//	Abstract:
//		Implementation of the CBaseWizardPage class.
//
//	Author:
//		David Potter (davidp)	July 23, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BaseWPag.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CBaseWizardPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CBaseWizardPage, CBasePage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CBaseWizardPage, CBasePage)
	//{{AFX_MSG_MAP(CBaseWizardPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::CBaseWizardPage
//
//	Routine Description:
//		Default constructor.
//
//	Arguments:
//		None.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizardPage::CBaseWizardPage(void)
{
	m_bBackPressed = FALSE;

}  //*** CBaseWizardPage::CBaseWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::CBaseWizardPage
//
//	Routine Description:
//		Constructor.
//
//	Arguments:
//		idd				[IN] Dialog template resource ID.
//		pdwHelpMap		[IN] Control to help ID map.
//		nIDCaption		[IN] Caption string resource ID.
//
//	Return Value:
//		None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBaseWizardPage::CBaseWizardPage(
	IN UINT				idd,
	IN const DWORD *	pdwHelpMap,
	IN UINT				nIDCaption
	)
	: CBasePage(idd, pdwHelpMap, nIDCaption)
{
	//{{AFX_DATA_INIT(CBaseWizardPage)
	//}}AFX_DATA_INIT

	m_bBackPressed = FALSE;

}  //*** CBaseWizardPage::CBaseWizardPage()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnSetActive
//
//	Routine Description:
//		Handler for the PSN_SETACTIVE message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully initialized.
//		FALSE	Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::OnSetActive(void)
{
	BOOL	bSuccess;

	Pwiz()->SetWizardButtons(*this);

	m_bBackPressed = FALSE;

	bSuccess = CBasePage::OnSetActive();
	if (bSuccess)
		m_staticTitle.SetWindowText(Pwiz()->StrObjTitle());

	return bSuccess;

}  //*** CBaseWizardPage::OnSetActive()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardBack
//
//	Routine Description:
//		Handler for the PSN_WIZBACK message.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseWizardPage::OnWizardBack(void)
{
	LRESULT		lResult;

	lResult = CBasePage::OnWizardBack();
	if (lResult != -1)
		m_bBackPressed = TRUE;

	return lResult;

}  //*** CBaseWizardPage::OnWizardBack()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardNext
//
//	Routine Description:
//		Handler for when the PSN_WIZNEXT message is sent.
//
//	Arguments:
//		None.
//
//	Return Value:
//		-1		Don't change the page.
//		0		Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CBaseWizardPage::OnWizardNext(void)
{
	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return -1;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return -1;

	return CBasePage::OnWizardNext();

}  //*** CBaseWizardPage::OnWizardNext()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::OnWizardFinish
//
//	Routine Description:
//		Handler for when the PSN_WIZFINISH message is sent.
//
//	Arguments:
//		None.
//
//	Return Value:
//		FALSE	Don't change the page.
//		TRUE	Change the page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::OnWizardFinish(void)
{
	CWaitCursor	wc;

	// Update the data in the class from the page.
	if (!UpdateData(TRUE /*bSaveAndValidate*/))
		return FALSE;

	// Save the data in the sheet.
	if (!BApplyChanges())
		return FALSE;

	return CBasePage::OnWizardFinish();

}  //*** CBaseWizardPage::OnWizardFinish()

/////////////////////////////////////////////////////////////////////////////
//++
//
//	CBaseWizardPage::BApplyChanges
//
//	Routine Description:
//		Apply changes made on the page.
//
//	Arguments:
//		None.
//
//	Return Value:
//		TRUE	Page successfully applied.
//		FALSE	Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CBaseWizardPage::BApplyChanges(void)
{
	return TRUE;

}  //*** CBaseWizardPage::BApplyChanges()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\bitmap.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1997 Microsoft Corporation
//
//	Module Name:
//		Bitmap.h
//
//	Abstract:
//		Definition of the CMyBitmap class.
//
//	Implementation File:
//		Bitmap.cpp
//
//	Author:
//		David Potter (davidp)	June 12, 1996
//
//	Revision History:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _BITMAP_H_
#define _BITMAP_H_

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CMyBitmap;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

#define nMaxSavedSystemPaletteEntries		256

/////////////////////////////////////////////////////////////////////////////
// CMyBitmap
/////////////////////////////////////////////////////////////////////////////

class CMyBitmap
{
public:
//	static	int			s_rgnColorWindowNormal[16];
//	static	int			s_rgnColorWindowHighlighted[16];
//	static	int			s_rgnColorButtonNormal[16];
//	static	int			s_rgnColorButtonHighlighted[16];

	static PALETTEENTRY	s_rgpeSavedSystemPalette[];
	int					m_nSavedSystemPalette;

private:
	HINSTANCE		m_hinst;

	BITMAPINFO *	m_pbiNormal;
	BITMAPINFO *	m_pbiHighlighted;
	BYTE *			m_pbBitmap;

	int				m_dx;
	int				m_dy;

	int				m_nColors;
	CB				m_cbColorTable;
	CB				m_cbBitmapInfo;
	CB				m_cbImageSize;
	HPALETTE		m_hPalette;
	BOOL			m_bCustomPalette;

protected:
	HINSTANCE		Hinst(void) const			{ return m_hinst; }
	BITMAPINFO *	PbiNormal(void) const		{ return m_pbiNormal;}
	BITMAPINFO *	PbiHighlighted(void) const	{ return m_pbiHighlighted; }
	BYTE *			PbBitmap(void) const		{ return m_pbBitmap; }

	void			LoadColors(int * pnColor, BITMAPINFO * pbi);

	int				NColorsFromBitCount(int nBitCount) const;

	CB				CbColorTable(void) const	{ return m_cbColorTable; }
	CB				CbBitmapInfo(void) const	{ return m_cbBitmapInfo; }
	CB				CbImageSize(void) const		{ return m_cbImageSize; }
	HPALETTE		HPalette(void) const		{ return m_hPalette; }
	BOOL			BCustomPalette(void) const	{ return m_bCustomPalette; }

	void			LoadBitmapResource(ID idBitmap, HINSTANCE hinst, LANGID langid);

	void			SaveSystemPalette(void);
	void			CreatePalette(void);
	void			CreatePALColorMapping(void);

public:
	CMyBitmap(void);
	virtual ~CMyBitmap(void);

	int				Dx(void) const				{ return m_dx; }
	int				Dy(void) const				{ return m_dy; }

	int				NColors(void) const			{ return m_nColors; }

	void			SetHinst(HINSTANCE hinst)	{ ASSERT(hinst != NULL); m_hinst = hinst; }
	void			SetCustomPalette(BOOL bCustomPalette)		{ m_bCustomPalette = bCustomPalette; }

	void			Load(ID idBitmap);

	virtual	void	Paint(HDC hdc, RECT * prc, BOOL bSelected);

	void			LoadColors(int * pnColorNormal, int * pnColorHighlighted);
	void			LoadColors(int * pnColorNormal);

	RGBQUAD			RgbQuadColorNormal(int nColor) const
	{
		ASSERT(nColor >= 0 && nColor < NColors());
		return PbiNormal()->bmiColors[nColor];
	}
	void			SetRgbQuadColorNormal(RGBQUAD rgbQuad, int nColor)
	{
		ASSERT(nColor >= 0 && nColor < NColors());
		PbiNormal()->bmiColors[nColor] = rgbQuad;
	}

};  //*** class CMyBitmap

/////////////////////////////////////////////////////////////////////////////

#endif // _BITMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cadmtype.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		CadmType.h
//
//	Abstract:
//		Type definitions for the Cluster Administrator program.
//
//	Author:
//		David Potter (davidp)	May 2, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CADMTYPE_H_
#define _CADMTYPE_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Common Pragmas
/////////////////////////////////////////////////////////////////////////////

#pragma warning(disable : 4100)		// unreferenced formal parameters
#pragma warning(disable : 4702)		// unreachable code
#pragma warning(disable : 4711)		// function selected for automatic inline expansion

/////////////////////////////////////////////////////////////////////////////
// Cluster API type definitions.
/////////////////////////////////////////////////////////////////////////////

typedef	DWORD	ClusEnumType;

/////////////////////////////////////////////////////////////////////////////
// UI type definitions.
/////////////////////////////////////////////////////////////////////////////

typedef UINT	ID;
typedef UINT	IDM;
typedef UINT	IDS;
typedef IDS		COLID;
typedef DWORD	SC;
typedef int		CB;
typedef int		CCH;
typedef UINT	IIMG;

/////////////////////////////////////////////////////////////////////////////
// String Definitions
/////////////////////////////////////////////////////////////////////////////

#define CP_ANSI		1252

/////////////////////////////////////////////////////////////////////////////

#endif // _CADMTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\casvc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      CASvc.h
//
//  Description:
//      Definition of helper functions for accessing and controlling
//      services.
//
//  Maintained By:
//      David Potter (davidp)   December 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CASVC_H_
#define _CASVC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

HCLUSTER
HOpenCluster(
    LPCTSTR pszClusterIn
    );

BOOL
BCanServiceBeStarted(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

BOOL
BIsServiceInstalled(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

BOOL
BIsServiceRunning(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

HRESULT
HrStartService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

HRESULT
HrStopService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    );

/////////////////////////////////////////////////////////////////////////////

#endif // _CASVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\bitmap.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      Bitmap.cpp
//
//  Abstract:
//      Implementation of the CMyBitmap class.
//
//  Author:
//      David Potter (davidp)   June 12, 1996
//
//  Revision History:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Bitmap.h"
#include "TraceTag.h"
#include "ExcOper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagBitmap(_T("Bitmap"), _T("Bitmap"));
CTraceTag g_tagLoadBitmapResource(_T("Bitmap"), _T("LoadBitmapResource"));
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyBitmap
/////////////////////////////////////////////////////////////////////////////

// Array used for restoring the System Palette when a using a Custom Palette Bitmap.
PALETTEENTRY CMyBitmap::s_rgpeSavedSystemPalette[nMaxSavedSystemPaletteEntries];

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::CMyBitmap
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//--
/////////////////////////////////////////////////////////////////////////////
CMyBitmap::CMyBitmap(void)
{
    m_hinst = NULL;

    m_pbiNormal = NULL;
    m_pbiHighlighted = NULL;
    m_pbBitmap = NULL;
    m_hPalette = NULL;
    m_nSavedSystemPalette = 0;
    SetCustomPalette(FALSE);

}  //*** CMyBitmap::CMyBitmap()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::~CMyBitmap
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//--
/////////////////////////////////////////////////////////////////////////////
CMyBitmap::~CMyBitmap(void)
{
    delete [] (PBYTE) PbiNormal();
    delete [] (PBYTE) PbiHighlighted();
    delete [] (PBYTE) PbBitmap();

    // If we saved the System Palette Entries, we have a Palette, and the
    // number of colors for the Palette() is enough to restore the System
    // Palette entries...
    if (m_nSavedSystemPalette
            && (HPalette() != NULL)
            && (NColors() >= m_nSavedSystemPalette))
    {
        HDC         hdcScreen;
        UINT        nRestoredEntries;
        HPALETTE    hOldPalette;

        Trace(g_tagBitmap, _T("Restoring Screen Palette HPalette()=0x%x..."), HPalette());
        Trace(g_tagBitmap, _T("Restoring Screen Palette Entries=%d"), m_nSavedSystemPalette);

        // Restore the System Palette Entries
        nRestoredEntries = ::SetPaletteEntries(HPalette(), 0, m_nSavedSystemPalette, s_rgpeSavedSystemPalette);

        Trace(g_tagBitmap, _T("Restored Screen Palette Entries=%d"), nRestoredEntries);

        // Get the Screen's HDC
        hdcScreen = ::GetDC(NULL);

        // Select the Palette into the Screen's HDC
        hOldPalette = ::SelectPalette(hdcScreen, HPalette(), FALSE);

        // Unrealize the Palette to insure all the colors are forced into the System Palette
        ::UnrealizeObject(HPalette());

        // Force the local Palette's colors into the System Palette.
        ::RealizePalette(hdcScreen);

        // Release the Screen's HDC
        ::ReleaseDC(NULL, hdcScreen);

        // Invalidate the Screen completely so all windows are redrawn.
        ::InvalidateRect(NULL, NULL, TRUE);
    }

    // Destroy the Handle to the locally created Custom Palette.
    if (HPalette() != NULL)
        ::DeleteObject(HPalette());

}  //*** CMyBitmap::~CMyBitmap()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::Load
//
//  Purpose:
//      Loads a bitmap from the resource into memory.
//
//  Arguments:
//      idBitmap    id of the resource to load
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by LoadBitmapResource, CreatePallette,
//      CreatePALColorMapping, or new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::Load(ID idBitmap)
{
    // Load the Bitmap Header Information, Color Mapping Information, and the Bitmap Image.
    LoadBitmapResource(
                idBitmap,
                Hinst(),
                MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
                );

    ASSERT(PbiNormal() != NULL);
    ASSERT(PbBitmap() != NULL);

    // Start by initializing some internal variables...
    m_dx = PbiNormal()->bmiHeader.biWidth;
    m_dy = PbiNormal()->bmiHeader.biHeight;

    ASSERT(PbiHighlighted() == NULL);

    if (BCustomPalette())
    {
        Trace(g_tagBitmap, _T("Load() - Creating Logical Palette"));

        // Save the System Palette Entries for use in the Destructor.
        SaveSystemPalette();

        // Create a Global HPalette() for use in the Paint() routine.
        CreatePalette();

        // Re-create the PbiNormal() for DIB_PAL_COLORS in the Paint() routine.
        CreatePALColorMapping();

    }  // if:  using a custom pallette
    else
    {
        // Create and Initialize the PbiHighlighted() for 16 color bitmaps.
        ASSERT(NColors() <= 16);

        Trace(g_tagBitmap, _T("Load() - Allocating PbiHighlighted()"));

        m_pbiHighlighted = (BITMAPINFO *) new BYTE[CbBitmapInfo()];
        if (m_pbiHighlighted != NULL)
        {
            ::CopyMemory(PbiHighlighted(), PbiNormal(), CbBitmapInfo());
        } // if: bitmapinfo allocated successfully

    }  // else:  not using a custom pallette

}  //*** CMyBitmap::Load()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::LoadBitmapResource
//
//  Purpose:
//      Load a bitmap resource into the CMyBitmap class.  This includes loading (a) bitmap
//      header information, (b) color mapping table, and (c) the actual bitmap.
//
//  Arguments:
//      idbBitmap   Resource id of the bitmap to load.
//      hinst       Handle to the Module Instance
//      langid      Language specific resource (possibly different bitmaps for localized strings [Japanese, etc.])
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      GetLastError from FindResourceEx, LoadResource, LockResource, 
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadBitmapResource(ID idbBitmap, HINSTANCE hinst, LANGID langid)
{
    HRSRC               hrsrc = NULL;
    HGLOBAL             hglbl = NULL;
    LPBITMAPINFO        pBitmapInfo = NULL;
    LPBITMAPINFOHEADER  pBitmapInfoHeader = NULL;
    LPRGBQUAD           pRgbQuad = NULL;
    CB                  cbBitmapData;
    BYTE *              pbImageBits;

    Trace(g_tagLoadBitmapResource, _T("LoadBitmapResource(%d) - Entering"), idbBitmap);

    ASSERT(idbBitmap != NULL);

    if (hinst == NULL)
        hinst = AfxGetApp()->m_hInstance;

    // We need to find the bitmap data which includes (a) header info, (b) color, and (c) the bitmap.
    hrsrc = ::FindResourceEx(hinst, RT_BITMAP, MAKEINTRESOURCE(idbBitmap), langid);
    if (hrsrc == NULL)
    {
        DWORD   dwError = ::GetLastError();
        CString strError;

        if (dwError == ERROR_RESOURCE_NAME_NOT_FOUND)
            strError.Format(_T("Bitmap Resource %d Not Found.  NT Error %d Loading Bitmap [Lang=%d, SubLang=%d]"),
                    idbBitmap, dwError, PRIMARYLANGID(langid), SUBLANGID(langid));
        else
            strError.Format(_T("NT Error %d Attempting to Load Bitmap Resource %d [Lang=%d, SubLang=%d]"),
                    dwError, idbBitmap, PRIMARYLANGID(langid), SUBLANGID(langid));
        Trace(g_tagAlways, _T("LoadBitmapResource() - Error '%s'"), strError);
        ThrowStaticException(dwError);
    }  // if:  error finding the resource

    hglbl = ::LoadResource(hinst, hrsrc);
    if (hglbl == NULL)
        ThrowStaticException(::GetLastError());

    pBitmapInfo = (LPBITMAPINFO) ::LockResource(hglbl);
    if (pBitmapInfo == NULL)
        ThrowStaticException(::GetLastError());

    cbBitmapData = ::SizeofResource(hinst, hrsrc);
    ASSERT(cbBitmapData != 0);

    Trace(g_tagLoadBitmapResource, _T("Bitmap Location = 0x%x"), pBitmapInfo);
    Trace(g_tagLoadBitmapResource, _T("Bitmap Data Size = %d bytes"), cbBitmapData);

    pBitmapInfoHeader = (LPBITMAPINFOHEADER) &pBitmapInfo->bmiHeader;
    ASSERT(pBitmapInfoHeader != NULL);
    Trace(g_tagLoadBitmapResource, _T("Bitmap Info Header = 0x%x"), pBitmapInfoHeader);

    ASSERT(pBitmapInfoHeader->biSize == sizeof(BITMAPINFOHEADER));

    Trace(g_tagLoadBitmapResource, _T("biSize=%d"), pBitmapInfoHeader->biSize);
    Trace(g_tagLoadBitmapResource, _T("biWidth=%d"), pBitmapInfoHeader->biWidth);       // Width in Pixels
    Trace(g_tagLoadBitmapResource, _T("biHeight=%d"), pBitmapInfoHeader->biHeight); // Height in Pixels
    Trace(g_tagLoadBitmapResource, _T("biPlanes=%d"), pBitmapInfoHeader->biPlanes);
    Trace(g_tagLoadBitmapResource, _T("biBitCount=%d"), pBitmapInfoHeader->biBitCount);
    Trace(g_tagLoadBitmapResource, _T("biCompression=%d"), pBitmapInfoHeader->biCompression);
    Trace(g_tagLoadBitmapResource, _T("biSizeImage=%d"), pBitmapInfoHeader->biSizeImage);
    Trace(g_tagLoadBitmapResource, _T("biXPelsPerMeter=%d"), pBitmapInfoHeader->biXPelsPerMeter);
    Trace(g_tagLoadBitmapResource, _T("biYPelsPerMeter=%d"), pBitmapInfoHeader->biYPelsPerMeter);
    Trace(g_tagLoadBitmapResource, _T("biClrUsed=%d"), pBitmapInfoHeader->biClrUsed);
    Trace(g_tagLoadBitmapResource, _T("biClrImportant=%d"), pBitmapInfoHeader->biClrImportant);

    pRgbQuad = (LPRGBQUAD) &pBitmapInfo->bmiColors;
    ASSERT(pRgbQuad != NULL);
    Trace(g_tagLoadBitmapResource, _T("Bitmap Rgb Quad = 0x%x"), pRgbQuad);

    m_nColors = NColorsFromBitCount(pBitmapInfoHeader->biBitCount);
    m_cbColorTable = m_nColors * sizeof(RGBQUAD);
    m_cbBitmapInfo = sizeof(BITMAPINFOHEADER) + CbColorTable();

    Trace(g_tagLoadBitmapResource, _T("NColors()=%d"), NColors());
    Trace(g_tagLoadBitmapResource, _T("CbColorTable()=%d"), CbColorTable());
    Trace(g_tagLoadBitmapResource, _T("CbBitmapInfo()=%d"), CbBitmapInfo());

    ASSERT(PbiNormal() == NULL);

    // Allocate the Normal Bitmap Information
    m_pbiNormal = (LPBITMAPINFO) new BYTE[CbBitmapInfo()];
    if (m_pbiNormal == NULL)
    {
        return;
    } // if: error allocating the bitmapinfo structure

    // Fill PbiNormal() with the Loaded Resource (a) Bitmap Information and Color Mapping Table.
    ::CopyMemory(PbiNormal(), pBitmapInfo, CbBitmapInfo());

    m_cbImageSize = pBitmapInfoHeader->biSizeImage;
    if ((m_cbImageSize == 0) && (pBitmapInfoHeader->biCompression == BI_RGB))
        m_cbImageSize = cbBitmapData - CbBitmapInfo();

    Trace(g_tagLoadBitmapResource, _T("Allocating Bitmap of size CbImageSize()=%d"), CbImageSize());

    ASSERT(cbBitmapData == CbBitmapInfo() + CbImageSize());
    ASSERT(PbBitmap() == NULL);

    // Allocate memory for the Bitmap Image
    m_pbBitmap = new BYTE[CbImageSize()];
    if (m_pbBitmap == NULL)
    {
        return;
    } // if: error allocating the bitmap image

    pbImageBits = (BYTE *) pBitmapInfo + CbBitmapInfo();

    Trace(g_tagLoadBitmapResource, _T("Bitmap Location pbImageBits=0x%x"), pbImageBits);

    // Copy the Image Bits into the allocated memory.
    ::CopyMemory(PbBitmap(), pbImageBits, CbImageSize());

}  //*** CMyBitmap::LoadBitmapResource()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::NColorsFromBitCount
//
//  Purpose:
//      Compute the number of colors given the number of bits to represent color.
//
//  Arguments:
//      nBitCount       The number of bits used for color representation.
//
//  Return Value:
//      nColors         Number of colors represented with nBitCount bits.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CMyBitmap::NColorsFromBitCount(int nBitCount) const
{
    int         nColors;

    switch (nBitCount)
    {
        default:
            nColors = 0;
            break;

        case 1:
            nColors = 2;
            break;

        case 4:
            nColors = 16;
            break;

        case 8:
            nColors = 256;
            break;
    }

    return nColors;

}  //*** CMyBitmap::NColorsFromBitCount()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::SaveSystemPalette
//
//  Purpose:
//      To save the System Palette Colors for use when a Custom Palette overwrites
//      the System Palette entries.  The Saved System Palette (s_rgpeSavedSystemPalette)
//      is used in the CMyBitmap's destructor.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::SaveSystemPalette(void)
{
    HDC         hdcScreen;
    int         nPaletteEntries;
    int         nSavedEntries;

    // Get the Screen's HDC
    hdcScreen = ::GetDC(NULL);
    if (hdcScreen == NULL)
    {
        return;
    } // if: couldn't get the screen DC

    // Can only save the System Palette Colors when the Device's RC_PALETTE bit is set.
    if (::GetDeviceCaps(hdcScreen, RASTERCAPS) & RC_PALETTE)
    {
        // Get the Number of System Palette Entries
        nPaletteEntries = ::GetDeviceCaps(hdcScreen, SIZEPALETTE);

        Trace(g_tagBitmap, _T("SaveSystemPalette() - nPaletteEntries=%d"), nPaletteEntries);

        if ((nPaletteEntries > 0)
                && (nPaletteEntries <= nMaxSavedSystemPaletteEntries))
        {
            // Get the Current System Palette Entries
            nSavedEntries = ::GetSystemPaletteEntries(hdcScreen, 0, nPaletteEntries, s_rgpeSavedSystemPalette);

            // Set the number of Saved System Palette Entries list for use in OnDestroy().
            if (nSavedEntries == nPaletteEntries)
            {
                Trace(g_tagBitmap, _T("SaveSystemPalette() - Saved System Palette Entries=%d"), nPaletteEntries);
                m_nSavedSystemPalette = nPaletteEntries;
            }
        }
    }

    // Release the Screen's HDC
    ::ReleaseDC(NULL, hdcScreen);

}  //*** CMyBitmap::SaveSystemPalette()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::CreatePalette
//
//  Purpose:
//      Create a logical palette from the color mapping table embedded in the
//      bitmap resource.
//
//  Arguments:
//      None.
//
//  Return Values:
//      None.
//
//  Exceptions Thrown:
//      GetLastError from CreatePalette.
//      Any exceptions thrown by new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::CreatePalette(void)
{
    LPLOGPALETTE        pLogicalPalette = NULL;
    CB                  cbLogicalPalette;
    int                 nColor;
    LPPALETTEENTRY      pPaletteEntry;

    Trace(g_tagBitmap, _T("CreatePalette() - Entering"));

    try
    {
        // Compute the size of the logical palette.
        cbLogicalPalette = sizeof(LOGPALETTE) + (NColors() * sizeof(PALETTEENTRY));

        Trace(g_tagBitmap, _T("CreatePalette() - cbLogicalPalette=%d"), cbLogicalPalette);

        // Allocate the Logical Palette Memory
        pLogicalPalette = (LPLOGPALETTE) new BYTE[cbLogicalPalette];
        if (pLogicalPalette == NULL)
        {
            ThrowStaticException(GetLastError());
            return;
        } // if: error allocating the Logical Palette Memory

        ASSERT(pLogicalPalette != NULL);
        ASSERT(PbiNormal() != NULL);

        pLogicalPalette->palVersion = 0x300;            // Windows 3.0
        pLogicalPalette->palNumEntries = (WORD) NColors();

        // Fill the Logical Palette's Color Information
        for (nColor=0; nColor<NColors(); nColor++)
        {
            pPaletteEntry = &(pLogicalPalette->palPalEntry[nColor]);

            pPaletteEntry->peRed = PbiNormal()->bmiColors[nColor].rgbRed;
            pPaletteEntry->peGreen = PbiNormal()->bmiColors[nColor].rgbGreen;
            pPaletteEntry->peBlue = PbiNormal()->bmiColors[nColor].rgbBlue;
            pPaletteEntry->peFlags = 0;
        }

        // Create the NT Palette for use in the Paint Routine.
        m_hPalette = ::CreatePalette(pLogicalPalette);
        if (m_hPalette == NULL)
        {
            ThrowStaticException(::GetLastError());
        }

        ASSERT(HPalette() != NULL);

        delete [] (PBYTE) pLogicalPalette;
    }  // try
    catch (CException *)
    {
        delete [] (PBYTE) pLogicalPalette;
        throw;
    }  // catch:  anything

}  //*** CMyBitmap::CreatePalette()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::CreatePALColorMapping
//
//  Purpose:
//      Given BITMAPINFO in PbiNormal(), recreate the PbiNormal() into a
//      DIB_PAL_COLORS format.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by new.
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::CreatePALColorMapping(void)
{
    LPBITMAPINFO            pNewBitmapInfo = NULL;
    CB                      cbNewBitmapInfo;
    CB                      cbNewBitmapHeaderInfo;
    BYTE *                  pbColorTable;
    WORD                    wColor;

    ASSERT(PbiNormal() != NULL);
    ASSERT(PbiNormal()->bmiHeader.biSize == sizeof(BITMAPINFOHEADER));
//  ASSERT(PbiNormal()->bmiHeader.biClrUsed == (UINT) NColors());

    try
    {
        Trace(g_tagBitmap, _T("CreatePALColorMapping() - Entering"));

        cbNewBitmapHeaderInfo = sizeof(BITMAPINFOHEADER);

        Trace(g_tagBitmap, _T("CreatePALColorMapping() - cbNewBitmapHeaderInfo=%d"), cbNewBitmapHeaderInfo);

        // New Bitmap Info is the Info Header plus the Color mapping information.
        cbNewBitmapInfo = cbNewBitmapHeaderInfo + (NColors() * sizeof(WORD));

        Trace(g_tagBitmap, _T("CreatePALColorMapping() - cbNewBitmapInfo=%d"), cbNewBitmapInfo);

        // Allocate the New Bitmap Information
        pNewBitmapInfo = (LPBITMAPINFO) new BYTE[cbNewBitmapInfo];

        ASSERT(pNewBitmapInfo != NULL);
        if (pNewBitmapInfo == NULL)
        {
            ThrowStaticException(GetLastError());
            return;
        } // if: error allocating the new bitmapinfo structure

        Trace(g_tagBitmap, _T("CreatePALColorMapping() - New Bitmap Info Location=0x%x"), pNewBitmapInfo);

        // Copy the Header Information to the allocated memory.
        ::CopyMemory(pNewBitmapInfo, PbiNormal(), cbNewBitmapHeaderInfo);

        // Create the Color Lookup Table.
        pbColorTable = (BYTE *) (pNewBitmapInfo) + cbNewBitmapHeaderInfo;

        ASSERT(pbColorTable + (NColors() * sizeof(WORD)) == (BYTE *) (pNewBitmapInfo) + cbNewBitmapInfo);

        Trace(g_tagBitmap, _T("CreatePALColorMapping() - Filling %d Color Table at Location 0x%x"), NColors(), pbColorTable);

        // Fill the PAL Color Lookup Table
        for (wColor = 0 ; wColor < NColors() ; wColor++)
        {
            ::CopyMemory(pbColorTable, &wColor, sizeof(WORD));
            pbColorTable += sizeof(WORD);
        }

        delete [] (PBYTE) PbiNormal();
        m_pbiNormal = pNewBitmapInfo;
        m_cbBitmapInfo = cbNewBitmapInfo;
        pNewBitmapInfo = NULL;
    }  // try
    catch (CException *)
    {
        delete [] pNewBitmapInfo;
        throw;
    }  // catch:  anything

}  //*** CMyBitmap::CreatePALColorMapping()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::Paint
//
//  Purpose:
//      Paints a sub-bitmap
//
//  Parameters:
//      hdc         HDC to paint
//      prect       Where to position the bitmap:
//                      Only the upperleft corner is used
//      bHighlighted    Used to select the color map to use.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::Paint(HDC hdc, RECT * prect, BOOL bHighlighted)
{
    LPBITMAPINFO            pBitmapInfo;
    UINT                    nColorUse;
    HPALETTE                hOldPalette = NULL;

    ASSERT(hdc != NULL);
    ASSERT(prect != NULL);

    Trace(g_tagBitmap, _T("bHighlighted = %d"), bHighlighted);

#ifdef _DEBUG
    {
        int             nPlanes;
        int             nBitsPerPixel;
        int             nBitCount;

        nPlanes = ::GetDeviceCaps(hdc, PLANES);
        nBitsPerPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
        nBitCount = nPlanes * nBitsPerPixel;

        Trace(g_tagBitmap, _T("Paint() - nPlanes=%d"), nPlanes);
        Trace(g_tagBitmap, _T("Paint() - nBitsPerPixel=%d"), nBitsPerPixel);
        Trace(g_tagBitmap, _T("Paint() - nBitCount=%u"), nBitCount);
    }
#endif

    try
    {
        if (BCustomPalette())
        {
            ASSERT(PbiNormal() != NULL);
            ASSERT(HPalette() != NULL);

            // Select the Custom Palette into the HDC about to be drawn...
            hOldPalette = ::SelectPalette(hdc, HPalette(), FALSE);              // FALSE causes the current Screen Palette to be Overwritten
            if (hOldPalette == NULL)
                ThrowStaticException(::GetLastError());

            // Force the Palette colors into the System Palette
            if (::RealizePalette(hdc) == GDI_ERROR)
                ThrowStaticException(::GetLastError());

            pBitmapInfo = PbiNormal();
            nColorUse = DIB_PAL_COLORS;

#ifdef NEVER
            pBitmapInfo = PbiNormal();
            nColorUse = DIB_RGB_COLORS;
#endif
        }  // if:  using a custom palette
        else
        {
            ASSERT(NColors() <= 16);
            ASSERT(PbiNormal() != NULL);
            ASSERT(PbiHighlighted() != NULL);
            pBitmapInfo = (bHighlighted ? PbiHighlighted() : PbiNormal());
            nColorUse = DIB_RGB_COLORS;
        }  // else:  not using a custom palette

        ::SetDIBitsToDevice(
                    hdc,
                    (int) prect->left,                      // X coordinate on screen.
                    (int) prect->top,                       // Y coordinate on screen.
                    (DWORD) Dx(),                           // cx to paint
                    (DWORD) Dy(),                           // cy to paint
                                                            // Note: (0,0) of the DIB is lower-left corner!?!
                    0,                                      // In pbi, xLeft to paint
                    0,                                      // In pbi, yLower to paint
                    0,                                      // Start scan line
                    Dy(),                                   // Number of scan lines
                    PbBitmap(),                             // The buffer description
                    pBitmapInfo,                            // Bitmap Information
                    nColorUse                               // DIB_RGB_COLORS or DIB_PAL_COLORS
                    );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

}  //*** CMyBitmap::Paint()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::LoadColors
//
//  Purpose:
//      Loads the color maps based on the system settings
//
//  Arguments:
//      pnColorNormal & pnColorHighlighted
//          Arrays of 16 elements:
//              -1          Do not remap this color
//              COLOR_xxx   Remap this color to the system color.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColorNormal, int * pnColorHighlighted)
{
    LoadColors(pnColorNormal, PbiNormal());
    LoadColors(pnColorHighlighted, PbiHighlighted());

}  //*** CMyBitmap::LoadColors(pnColorNormal, pnColorHighlighted)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::LoadColors
//
//  Purpose:
//      Similar to above LoadColors except only the PbiNormal() colors are altered.
//
//  Arguments:
//      pnColorNormal       Array of color mapping table.
//
//  Returns:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColorNormal)
{
    LoadColors(pnColorNormal, PbiNormal());

}  //*** CMyBitmap::LoadColors(pnColorNormal)

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CMyBitmap::LoadColors
//
//  Purpose:
//      Loads one color map based on the system settings
//
//  Arguments:
//      pnColor
//          Arrays of 16 elements:
//              -1          Do not remap this color
//              COLOR_xxx   Remap this color to the system color.
//      pbi
//      BITMAPINFO structure to adjust
//
//--
/////////////////////////////////////////////////////////////////////////////
void CMyBitmap::LoadColors(int * pnColor, BITMAPINFO * pbi)
{
    int         inColor;
    COLORREF    cr;

    ASSERT(pbi != NULL);
    ASSERT(pbi->bmiHeader.biBitCount <= 4);
    ASSERT(NColors() <= 16);
    ASSERT(BCustomPalette() == FALSE);

    for (inColor = 0; inColor < 16; inColor++)
    {
        if (pnColor[inColor] == -1)
            continue;

        cr = GetSysColor(pnColor[inColor]);
        pbi->bmiColors[inColor].rgbRed = GetRValue(cr);
        pbi->bmiColors[inColor].rgbGreen = GetGValue(cr);
        pbi->bmiColors[inColor].rgbBlue = GetBValue(cr);
    }

}  //*** CMyBitmap::LoadColors(pnColor, pbi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cluadmin.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CluAdmin.h
//
//  Abstract:
//      Definition of the CClusterAdminApp class, which is the main
//      application class for the CLUADMIN application.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _CLUADMIN_H_
#define _CLUADMIN_H_

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#ifndef _UNICODE
    #error _UNICODE *must* be defined!
#endif

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"   // main symbols
#define _RESOURCE_H_
#endif

#ifndef _BARFCLUS_H_
#include "BarfClus.h"   // for BARF overrides of CLUSAPIs
#endif

#include "Notify.h"     // for CClusterNotifyContext, CClusterNotifyKeyList

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminApp;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CRecentClusterList;
class CCluAdminCommandLineInfo;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

enum ImageListIndex
{
    IMGLI_FOLDER = 0,
    IMGLI_CLUSTER,
    IMGLI_CLUSTER_UNKNOWN,
    IMGLI_NODE,
    IMGLI_NODE_DOWN,
    IMGLI_NODE_PAUSED,
    IMGLI_NODE_UNKNOWN,
    IMGLI_GROUP,
    IMGLI_GROUP_PARTIALLY_ONLINE,
    IMGLI_GROUP_PENDING,
    IMGLI_GROUP_OFFLINE,
    IMGLI_GROUP_FAILED,
    IMGLI_GROUP_UNKNOWN,
    IMGLI_RES,
    IMGLI_RES_OFFLINE,
    IMGLI_RES_PENDING,
    IMGLI_RES_FAILED,
    IMGLI_RES_UNKNOWN,
    IMGLI_RESTYPE,
    IMGLI_RESTYPE_UNKNOWN,
    IMGLI_NETWORK,
    IMGLI_NETWORK_PARTITIONED,
    IMGLI_NETWORK_DOWN,
    IMGLI_NETWORK_UNKNOWN,
    IMGLI_NETIFACE,
    IMGLI_NETIFACE_UNREACHABLE,
    IMGLI_NETIFACE_FAILED,
    IMGLI_NETIFACE_UNKNOWN,

    IMGLI_MAX
};

/////////////////////////////////////////////////////////////////////////////
// CClusterAdminApp:
// See CluAdmin.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

class CClusterAdminApp : public CWinApp
{
    DECLARE_DYNAMIC( CClusterAdminApp );

public:
    CClusterAdminApp( void );

    CRecentClusterList *    PrclRecentClusterList( void)    { return (CRecentClusterList *) m_pRecentFileList; }

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterAdminApp)
    public:
    virtual BOOL InitInstance();
    virtual BOOL OnIdle(IN LONG lCount);
    virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
    virtual int ExitInstance();
    virtual void AddToRecentFileList(LPCTSTR lpszPathName);
    //}}AFX_VIRTUAL

// Implementation
#ifdef _CLUADMIN_USE_OLE_
    COleTemplateServer      m_server;
        // Server object for document creation
#endif

protected:
    CMultiDocTemplate *     m_pDocTemplate;
    CImageList              m_ilSmallImages;
    CImageList              m_ilLargeImages;
    HCHANGE                 m_hchangeNotifyPort;
    LCID                    m_lcid;
    CClusterNotifyKeyList   m_cnkl;
    CClusterNotifyContext   m_cnctx;
    CClusterNotifyList      m_cnlNotifications;
    CWinThread *            m_wtNotifyThread;
    HCLUSTER                m_hOpenedCluster;
    ULONG                   m_nIdleCount;

    // Indices of images in the image list.
    UINT                    m_rgiimg[IMGLI_MAX];

    IUnknown *              m_punkClusCfgClient;

    BOOL                    BInitNotifyThread(void);
    static UINT AFX_CDECL   NotifyThreadProc(LPVOID pParam);

    CClusterNotifyContext * Pcnctx(void)                        { return &m_cnctx; }
    CWinThread *            WtNotifyThread(void) const          { return m_wtNotifyThread; }

    BOOL                    ProcessShellCommand(IN OUT CCluAdminCommandLineInfo & rCmdInfo);
    void                    InitGlobalImageList(void);

public:
    CMultiDocTemplate *     PdocTemplate(void) const            { return m_pDocTemplate; }
    CImageList *            PilSmallImages(void)                { return &m_ilSmallImages; }
    CImageList *            PilLargeImages(void)                { return &m_ilLargeImages; }
    HCHANGE                 HchangeNotifyPort(void) const       { return m_hchangeNotifyPort; }
    LCID                    Lcid(void) const                    { return m_lcid; }
    CClusterNotifyKeyList & Cnkl(void)                          { return m_cnkl; }
    CClusterNotifyList &    Cnl( void )                         { return m_cnlNotifications; }
    HCLUSTER                HOpenedCluster(void) const          { return m_hOpenedCluster; }

    // Indices of images in the image list.
    UINT                    Iimg(ImageListIndex imgli)          { return m_rgiimg[imgli]; }

    void                    LoadImageIntoList(
                                IN OUT CImageList * pil,
                                IN ID               idbImage,
                                IN UINT             imgli
                                );
    static void             LoadImageIntoList(
                                IN OUT CImageList * pil,
                                IN ID               idbImage,
                                OUT UINT *          piimg   = NULL
                                );

    void                    SaveConnections(void);
    afx_msg LRESULT         OnRestoreDesktop(WPARAM wparam, LPARAM lparam);
    afx_msg LRESULT         OnClusterNotify(WPARAM wparam, LPARAM lparam);

    //{{AFX_MSG(CClusterAdminApp)
    afx_msg void OnAppAbout();
    afx_msg void OnFileOpen();
    afx_msg void OnFileNewCluster();
    afx_msg void OnWindowCloseAll();
    afx_msg void OnUpdateWindowCloseAll(CCmdUI* pCmdUI);
    //}}AFX_MSG
#ifdef _DEBUG
    afx_msg void OnTraceSettings();
    afx_msg void OnBarfSettings();
    afx_msg void OnBarfAllSettings();
#endif
    DECLARE_MESSAGE_MAP()

}; //*** class CClusterAdminApp

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

BOOL BCreateFont(OUT CFont & rfont, IN int nPoints, IN BOOL bBold);
void NewNodeWizard( LPCTSTR pcszName, BOOL fIgnoreErrors = FALSE );
void GetClusterInformation( HCLUSTER hClusterIn, CString& rstrNameOut, PCLUSTERVERSIONINFO pcviOut = NULL );
CString StrGetClusterName( HCLUSTER hClusterIn );

inline CClusterAdminApp * GetClusterAdminApp(void)
{
    ASSERT_KINDOF(CClusterAdminApp, AfxGetApp());
    return (CClusterAdminApp *) AfxGetApp();
}

inline CFrameWnd * PframeMain(void)
{
    return (CFrameWnd *) AfxGetMainWnd();
}

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusdoc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusDoc.cpp
//
//  Abstract:
//      Implementation of the CClusterDoc class.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <ClAdmWiz.h>
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusDoc.h"
#include "Cluster.h"
#include "ExcOper.h"
#include "Notify.h"
#include "TraceTag.h"
#include "ListView.h"
#include "TreeView.h"
#include "GrpWiz.h"
#include "ResWiz.h"
#include "SplitFrm.h"
#include "YesToAll.h"
#include "ActGrp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagDoc(_T("Document"), _T("DOC"), 0);
CTraceTag   g_tagDocMenu(_T("Menu"), _T("DOC"), 0);
CTraceTag   g_tagDocNotify(_T("Notify"), _T("DOC NOTIFY"), 0);
CTraceTag   g_tagDocRegNotify(_T("Notify"), _T("DOC REG NOTIFY"), 0);
CTraceTag   g_tagDocRefresh(_T("Document"), _T("REFRESH"), 0);
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterDoc
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterDoc, CDocument)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterDoc, CDocument)
    //{{AFX_MSG_MAP(CClusterDoc)
    ON_COMMAND(ID_FILE_NEW_GROUP, OnCmdNewGroup)
    ON_COMMAND(ID_FILE_NEW_RESOURCE, OnCmdNewResource)
    ON_COMMAND(ID_FILE_NEW_NODE, OnCmdNewNode)
    ON_COMMAND(ID_FILE_CONFIG_APP, OnCmdConfigApp)
    ON_COMMAND(ID_VIEW_REFRESH, OnCmdRefresh)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::CClusterDoc
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterDoc::CClusterDoc(void)
{
    m_hcluster = NULL;
    m_hkeyCluster = NULL;
    m_pciCluster = NULL;
    m_ptiCluster = NULL;

    m_hmenuCluster = NULL;
    m_hmenuNode = NULL;
    m_hmenuGroup = NULL;
    m_hmenuResource = NULL;
    m_hmenuResType = NULL;
    m_hmenuNetwork = NULL;
    m_hmenuNetIFace = NULL;
    m_hmenuCurrent = NULL;
    m_idmCurrentMenu = 0;

    m_bUpdateFrameNumber = TRUE;
    m_bInitializing = TRUE;
    m_bIgnoreErrors = FALSE;

    m_bClusterAvailable = FALSE;

    EnableAutomation();

}  //*** CClusterDoc::CClusterDoc

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::~CClusterDoc
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterDoc::~CClusterDoc(void)
{
    // Destroy any menus we loaded.
    if (m_hmenuCluster != NULL)
        DestroyMenu(m_hmenuCluster);
    if (m_hmenuNode != NULL)
        DestroyMenu(m_hmenuNode);
    if (m_hmenuGroup != NULL)
        DestroyMenu(m_hmenuGroup);
    if (m_hmenuResource != NULL)
        DestroyMenu(m_hmenuResource);
    if (m_hmenuResType != NULL)
        DestroyMenu(m_hmenuResType);
    if (m_hmenuNetwork != NULL)
        DestroyMenu(m_hmenuNetwork);
    if (m_hmenuNetIFace != NULL)
        DestroyMenu(m_hmenuNetIFace);

    delete m_pciCluster;

}  //*** CClusterDoc::~CClusterDoc

/////////////////////////////////////////////////////////////////////////////
// CClusterDoc diagnostics

#ifdef _DEBUG
void CClusterDoc::AssertValid(void) const
{
    CDocument::AssertValid();
}

void CClusterDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnOpenDocument
//
//  Routine Description:
//      Open a cluster.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster to open.
//
//  Return Value:
//      TRUE            Cluster opened successfully.
//      FALSE           Failed to open the cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
    BOOL        bSuccess    = TRUE;
    CWaitCursor wc;

    ASSERT(Hcluster() == NULL);
    ASSERT(HkeyCluster() == NULL);

    // There better be a cluster name.
    ASSERT(lpszPathName != NULL);
    ASSERT(*lpszPathName != _T('\0'));

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_OPENING_CONNECTION, lpszPathName);
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    // If the application is minimized, don't display message boxes
    // on errors.
    m_bIgnoreErrors = AfxGetMainWnd()->IsIconic() == TRUE;

    try
    {
        OnOpenDocumentWorker(lpszPathName);
    }  // try
    catch (CNTException * cnte)
    {
        //
        // GPotts - 6/28/2001 - BUG 410912
        //
        // OnOpenDocumentWorker ends up calling HOpenCluster, which could return
        // a NULL hCluster handle and sets LastError = 0, the reason being that
        // the node that we're trying to open is not configured or not installed, 
        // but the call to GetNodeClusterState succeeded.
        // HOpenCluster already displays a dialog indicating this.  A CNTException
        // is thrown with a value of ERROR_SUCCESS - without the code below we'd
        // throw a messagebox up with a zero value when the real reason has already
        // been explained in a messagebox from HOpenCluster. 
        //
        if ( cnte->Sc() != ERROR_SUCCESS && !m_bIgnoreErrors )
        {
            cnte->ReportError();
        }
        cnte->Delete();

        // Close the cluster handle and the cluster key.
        CloseClusterKeyAndHandle( FALSE );

        m_bClusterAvailable = FALSE;
        bSuccess = FALSE;
    }
    catch (CException * pe)
    {
        if (!m_bIgnoreErrors)
        {
            pe->ReportError();
        }
        pe->Delete();

        // Close the cluster handle and the cluster key.
        CloseClusterKeyAndHandle( FALSE );

        m_bClusterAvailable = FALSE;
        bSuccess = FALSE;
    }  // catch:  CException

    // Reset the message on the status bar.
    PframeMain()->SetMessageText(AFX_IDS_IDLEMESSAGE);
    PframeMain()->UpdateWindow();

    m_bInitializing = FALSE;

    return bSuccess;

}  //*** CClusterDoc::OnOpenDocument

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnOpenDocumentWorker
//
//  Routine Description:
//      Worker function for opening a cluster.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster to open.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CString::operator=(), CCluster::new(),
//      CCluster::Init(), BuildBaseHierarchy(), or CollectClusterItems().
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnOpenDocumentWorker(LPCTSTR lpszPathName)
{
    // Set the node name to the path name.
    m_strNode = lpszPathName;

    // Delete the contents to start out with an empty document.
    DeleteContents();

    m_bClusterAvailable = TRUE;

    // Create a new cluster object.
    m_pciCluster = new CCluster;
    if ( m_pciCluster == NULL )
    {
        AfxThrowMemoryException();
    } // if: error allocating the cluster object
    PciCluster()->AddRef();
    PciCluster()->Init(this, lpszPathName, GetClusterAdminApp()->HOpenedCluster());

    // Build the base hierarchy.
    BuildBaseHierarchy();

    // Collect the items in the cluster and build the hierarchy.
    CollectClusterItems();

    // Collect network priority list.
    PciCluster()->CollectNetworkPriority(NULL);

    // Open new windows if there were more open when we exited.
    {
        int         iwin;
        int         cwin;
        CString     strSection;

        strSection = REGPARAM_CONNECTIONS _T("\\") + StrNode();
        cwin = AfxGetApp()->GetProfileInt(strSection, REGPARAM_WINDOW_COUNT, 1);
        for (iwin = 1 ; iwin < cwin ; iwin++)
            AfxGetMainWnd()->PostMessage(WM_COMMAND, ID_WINDOW_NEW, NULL);
    }  // Open new windows if there were more open when we exited

    // Initialize the frame window.
    {
        POSITION            pos;
        CView *             pview;
        CSplitterFrame *    pframe;

        pos = GetFirstViewPosition();
        pview = GetNextView(pos);
        ASSERT_VALID(pview);
        pframe = (CSplitterFrame *) pview->GetParentFrame();
        ASSERT_KINDOF(CSplitterFrame, pframe);
        pframe->InitFrame(this);
    }  // Initialize the frame window

}  //*** CClusterDoc::OnOpenDocumentWorker

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCloseDocument
//
//  Routine Description:
//      Close a cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCloseDocument(void)
{
    TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("OnCloseDocument menu: "));
    m_bUpdateFrameNumber = FALSE;
    CDocument::OnCloseDocument();
    TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("Post-OnCloseDocument menu: "));

}  //*** CClusterDoc::OnCloseDocument

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::SaveSettings
//
//  Routine Description:
//      Save settings so they can be restored later.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::SaveSettings(void)
{
    int         cwin = 0;
    POSITION    pos;
    CView *     pview;
    CString     strSection;

    try
    {
        // Save the number of windows open on this document.
        strSection = REGPARAM_CONNECTIONS _T("\\") + StrNode();
        pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
                cwin++;
        }  // while:  more views in the list
        AfxGetApp()->WriteProfileInt(strSection, REGPARAM_WINDOW_COUNT, cwin);
    }  // try
    catch (CException * pe)
    {
        pe->Delete();
    }  // catch:  CException

}  //*** CClusterDoc::SaveSettings

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::BuildBaseHierarchy
//
//  Routine Description:
//      Build the base hierarchy.  This hierarchy consists of tree items
//      for the hierarchy and list items for what is displayed in the list
//      view but does not contain any items for specific objects, other
//      than the cluster itself.
//
//  Arguments:
//      None.
//
//  Return Value:
//      dwStatus    Status of the operation: 0 if successful, !0 otherwise.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::BuildBaseHierarchy(void)
{
    ASSERT_VALID(PciCluster());
    ASSERT(PtiCluster() == NULL);

    // Create the root cluster item.
    {
        ASSERT_VALID(PciCluster());
        PciCluster()->ReadItem();
        m_ptiCluster = new CTreeItem(NULL, PciCluster());
        if ( m_ptiCluster == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating tree item
        m_ptiCluster->AddRef();
        ASSERT_VALID(PtiCluster());
        PciCluster()->AddTreeItem(PtiCluster());
        PtiCluster()->Init();
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      PtiCluster()->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        PtiCluster()->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);
    }  // Create the root cluster item

    // Add the Groups container item under the cluster.
    {
        CTreeItem * ptiGroups;

        // Create the Groups container item.
        ptiGroups = PtiCluster()->PtiAddChild(IDS_TREEITEM_GROUPS);
        ASSERT_VALID(ptiGroups);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiGroups->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
        ptiGroups->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

    }  // Add the Groups container item under the cluster

    // Add the Resources container item under the cluster.
    {
        CTreeItem * ptiResources;

        // Create the Resources container item.
        ptiResources = PtiCluster()->PtiAddChild(IDS_TREEITEM_RESOURCES);
        ASSERT_VALID(ptiResources);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiResources->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_GROUP, COLI_WIDTH_GROUP);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
        ptiResources->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

    }  // Add the Resources container item under the cluster

    // Add the Cluster Configuration container item under the cluster.
    {
        CTreeItem * ptiClusCfg;

        // Create the Cluster Configuration container item.
        ptiClusCfg = PtiCluster()->PtiAddChild(IDS_TREEITEM_CLUSTER_CONFIG);
        ASSERT_VALID(ptiClusCfg);
        ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//      ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
        ptiClusCfg->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        // Add the Resources Types container item under the Cluster Configuration container.
        {
            CTreeItem * ptiResTypes;

            // Create the Resources Types container item.
            ptiResTypes = ptiClusCfg->PtiAddChild(IDS_TREEITEM_RESTYPES);
            ASSERT_VALID(ptiResTypes);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_DISPLAY_NAME, COLI_WIDTH_DISPLAY_NAME);
//          ptiResTypes->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiResTypes->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_RESDLL, COLI_WIDTH_RESDLL);
            ptiResTypes->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Resources Types container item under the Cluster Configuration container

        // Add the Networks container item under the Cluster Configuration container.
        {
            CTreeItem * ptiNetworks;

            // Create the Networks container item.
            ptiNetworks = ptiClusCfg->PtiAddChild(IDS_TREEITEM_NETWORKS);
            ASSERT_VALID(ptiNetworks);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiNetworks->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_ROLE, COLI_WIDTH_NET_ROLE);
//          ptiNetworks->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_MASK, COLI_WIDTH_NET_MASK);
            ptiNetworks->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Networks container item under the Cluster Configuration container

        // Add the Network Interfaces container item under the Cluster Configuration container.
        {
            CTreeItem * ptiNetworkInterfacess;

            // Create the Network Interfaces container item.
            ptiNetworkInterfacess = ptiClusCfg->PtiAddChild(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetworkInterfacess);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//          ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetworkInterfacess->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Add the Network Interfaces container item under the Cluster Configuration container

    }  // Add the Cluster Configuration container item under the cluster

}  //*** CClusterDoc::BuildBaseHierarchy

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::CollectClusterItems
//
//  Routine Description:
//      Collect items in the cluster.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException        Status from ClusterOpenEnum or ClusterEnum.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::CollectClusterItems(void)
{
    DWORD           dwStatus;
    HCLUSENUM       hclusenum;
    ClusEnumType    cet;
    int             ienum;
    LPWSTR          pwszName = NULL;
    DWORD           cchName;
    DWORD           cchmacName;

    // Open the enumeration.
    hclusenum = ClusterOpenEnum(
                        Hcluster(),
                        ( CLUSTER_ENUM_NODE
                        | CLUSTER_ENUM_GROUP
                        | CLUSTER_ENUM_RESOURCE
                        | CLUSTER_ENUM_RESTYPE
                        | CLUSTER_ENUM_NETWORK
                        | CLUSTER_ENUM_NETINTERFACE
                        )
                        );
    if (hclusenum == NULL)
        ThrowStaticException(GetLastError(), IDS_OPEN_CLUSTER_ENUM_ERROR, StrName());

    try
    {
        // Allocate a buffer for object names.
        cchmacName = 128;
        pwszName = new WCHAR[cchmacName];
        if ( pwszName == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the name buffer

        // Loop through the enumeration and add each item to the appropriate list.
        for (ienum = 0 ; ; ienum++)
        {
            cchName = cchmacName;
            dwStatus = ClusterEnum(hclusenum, ienum, &cet, pwszName, &cchName);
            if (dwStatus == ERROR_MORE_DATA)
            {
                Trace(g_tagDoc, _T("OnOpenDocument() - name buffer too small.  Expanding from %d to %d"), cchmacName, cchName);
                delete [] pwszName;
                pwszName = NULL;
                cchmacName = cchName + 1;
                pwszName = new WCHAR[cchmacName];
                if ( pwszName == NULL )
                {
                    AfxThrowMemoryException();
                } // if: error allocating the name buffer
                cchName = cchmacName;
                dwStatus = ClusterEnum(hclusenum, ienum, &cet, pwszName, &cchName);
            }  // if:  name buffer was too small
            if (dwStatus == ERROR_NO_MORE_ITEMS)
                break;
            else if (dwStatus != ERROR_SUCCESS)
                ThrowStaticException(dwStatus, IDS_ENUM_CLUSTER_ERROR, StrName());

            switch (cet)
            {
                case CLUSTER_ENUM_NODE:
                    PciAddNewNode(pwszName);
                    break;

                case CLUSTER_ENUM_GROUP:
                    PciAddNewGroup(pwszName);
                    break;

                case CLUSTER_ENUM_RESOURCE:
                    PciAddNewResource(pwszName);
                    break;

                case CLUSTER_ENUM_RESTYPE:
                    PciAddNewResourceType(pwszName);
                    break;

                case CLUSTER_ENUM_NETWORK:
                    PciAddNewNetwork(pwszName);
                    break;

                case CLUSTER_ENUM_NETINTERFACE:
                    PciAddNewNetInterface(pwszName);
                    break;

                default:
                    Trace(g_tagDoc, _T("OnOpenDocument() - Unknown cluster enumeration type '%d'"), cet);
                    ASSERT(0);
                    break;

            }  // switch:  cet
        }  // for:  each item enumerated

        // Initialize all the cluster items.
        InitNodes();
        InitGroups();
        InitResourceTypes();
        InitResources();
        InitNetworks();
        InitNetInterfaces();

        // Deallocate our name buffer.
        delete [] pwszName;

        // Close the enumerator.
        ClusterCloseEnum(hclusenum);

    }  // try
    catch (CException *)
    {
        delete [] pwszName;
        ClusterCloseEnum(hclusenum);
        throw;
    }  // catch:  any exception

}  //*** CClusterDoc::CollectClusterItems

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNode
//
//  Routine Description:
//      Add a new node to the list of nodes.
//
//  Arguments:
//      pszName     [IN] Name of the node.
//
//  Return Value:
//      pci         Cluster item for the new node.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNode * CClusterDoc::PciAddNewNode(IN LPCTSTR pszName)
{
    CClusterNode *  pciNewNode = NULL;
    CClusterNode *  pciRetNode = NULL;
    CClusterNode *  pciOldNode = NULL;
    CActiveGroups * pciActiveGroups = NULL;
    CTreeItem *     ptiActiveGroups = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT_VALID(PtiCluster());
    ASSERT(LpciNodes().PciNodeFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NODE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNode = LpciNodes().PciNodeFromName(pszName);
        if (pciOldNode != NULL)
        {
            pciOldNode->Delete();
            pciOldNode = NULL;
        }  // if:  already an item with that name

        // Allocate a new node.
        pciNewNode = new CClusterNode;
        if ( pciNewNode == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the node

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNode->AddRef();

        // Initialize the node.
        pciNewNode->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNode;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_FILE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewNode;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT node not found
        else
        {
            delete pciNewNode;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNode;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNode == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the node to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;

            posPci = LpciNodes().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNode = (CClusterNode *) LpciNodes().GetNext(posPci);
                ASSERT_VALID(pciOldNode);
                if (pciOldNode->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNodes().InsertBefore(posCurPci, pciNewNode);
                    break;
                }  // if:  new node before this node
                pciOldNode = NULL;
            }  // while:  more items in the list
            if (pciOldNode == NULL)
                LpciNodes().AddTail(pciNewNode);
        }  // Add the node to the list

        // Save this node as a return value now that we have added it to the list
        pciRetNode = pciNewNode;
        pciNewNode = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiNode;
            CTreeItem *     ptiChild;

            ptiNode = PtiCluster()->PtiAddChildBefore(pciOldNode, pciRetNode);
            ASSERT_VALID(ptiNode);
            ptiNode->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);

            // Add the Active Groups container under the node.
            {
                CString     strName;

                // Create the Active Groups container cluster item.
                strName.LoadString(IDS_TREEITEM_ACTIVEGROUPS);
                pciActiveGroups = new CActiveGroups;
                if ( pciActiveGroups == NULL )
                {
                    AfxThrowMemoryException();
                } // if: Error allocating the active groups objct
                pciActiveGroups->Init(this, strName, pciRetNode);

                // Add the tree item for the container.
                ptiActiveGroups = ptiNode->PtiAddChild(pciActiveGroups, TRUE /*bTakeOwnership*/);
                ASSERT_VALID(ptiActiveGroups);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//              ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
                ptiActiveGroups->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

            }  // Add the Active Groups container under the node.

            // Add the Active Resources container under the node.
            {
                ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_ACTIVERESOURCES);
                ASSERT_VALID(ptiChild);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//              ptiChild->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_GROUP, COLI_WIDTH_GROUP);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

            }  // Add the Active Resources container under the node.

            // Add the Network Interfaces container under the node.
            {
                ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_NETIFACES);
                ASSERT_VALID(ptiChild);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//              ptiChild->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
                ptiChild->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);
            }  // Add the Network Interfaces container under the node

            // Add the Physical Devices container under the node.
            {
//              ptiChild = ptiNode->PtiAddChild(IDS_TREEITEM_PHYSDEVS);
//              ASSERT_VALID(ptiChild);
//              AddDefaultColumns(ptiChild);

            }  // Add the Physical Devices container under the node.
        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        // If the Active Groups container has been created, clean up the
        // reference to the node object we are creating.  If the tree
        // item hasn't been created yet, we still own the cluster item,
        // so delete that as well.
        if (pciActiveGroups != NULL)
        {
            pciActiveGroups->Cleanup();
            if (ptiActiveGroups == NULL)
                delete pciActiveGroups;
        }  // if:  Active Groups container created
        delete pciNewNode;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNode != NULL)
        pciRetNode->Release();

    return pciRetNode;

}  //*** CClusterDoc::PciAddNewNode

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewGroup
//
//  Routine Description:
//      Add a new group to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the group.
//
//  Return Value:
//      pci         Cluster item for the new group.
//
//--
/////////////////////////////////////////////////////////////////////////////
CGroup * CClusterDoc::PciAddNewGroup(IN LPCTSTR pszName)
{
    CGroup *    pciNewGroup = NULL;
    CGroup *    pciRetGroup = NULL;
    CGroup *    pciOldGroup = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_GROUP, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldGroup = LpciGroups().PciGroupFromName(pszName);
        if (pciOldGroup != NULL)
        {
            Trace(g_tagGroup, _T("Deleting existing group '%s' (%x) before adding new instance"), pszName, pciOldGroup);
            pciOldGroup->Delete();
            pciOldGroup = NULL;
        }  // if:  already an item with that name

        // Allocate a new group.
        pciNewGroup = new CGroup;
        if ( pciNewGroup == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the group object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewGroup->AddRef();

        // Initialize the group and add it to the list.
        pciNewGroup->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewGroup;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_GROUP_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewGroup;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT group not found
        else
        {
            delete pciNewGroup;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewGroup;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewGroup == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the group to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;

            posPci = LpciGroups().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldGroup = (CGroup *) LpciGroups().GetNext(posPci);
                ASSERT_VALID(pciOldGroup);
                if (pciOldGroup->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciGroups().InsertBefore(posCurPci, pciNewGroup);
                    break;
                }  // if:  new group before this group
                pciOldGroup = NULL;
            }  // while:  more items in the list
            if (pciOldGroup == NULL)
                LpciGroups().AddTail(pciNewGroup);
        }  // Add the group to the list

        // Save this group as a return value now that we have added it to the list
        pciRetGroup = pciNewGroup;
        pciNewGroup = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiGroups;
            CTreeItem *     ptiGroup;

            // Find the Groups container tree item.
            ptiGroups = PtiCluster()->PtiChildFromName(IDS_TREEITEM_GROUPS);
            ASSERT_VALID(ptiGroups);

            // Add the item before the found item we inserted it into in the groups list.
            ptiGroup = ptiGroups->PtiAddChildBefore(pciOldGroup, pciRetGroup);
            ASSERT_VALID(ptiGroup);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//          ptiGroup->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_OWNER, COLI_WIDTH_OWNER);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_RESTYPE, COLI_WIDTH_RESTYPE);
            ptiGroup->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewGroup;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetGroup != NULL)
        pciRetGroup->Release();

    return pciRetGroup;

}  //*** CClusterDoc::PciAddNewGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewResource
//
//  Routine Description:
//      Add a new resource to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the resource.
//
//  Return Value:
//      pci         Cluster item for the new resource.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResource * CClusterDoc::PciAddNewResource(IN LPCTSTR pszName)
{
    CResource * pciNewRes = NULL;
    CResource * pciRetRes = NULL;
    CResource * pciOldRes = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_RESOURCE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldRes = LpciResources().PciResFromName(pszName);
        if (pciOldRes != NULL)
        {
            if (pciOldRes->BInitializing())
                return pciOldRes;
            Trace(g_tagResource, _T("Deleting existing resource '%s' (%x) before adding new instance"), pszName, pciOldRes);
            pciOldRes->Delete();
            pciOldRes = NULL;
        }  // if:  already an item with that name

        // Allocate a new resource.
        pciNewRes = new CResource;
        if ( pciNewRes == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewRes->AddRef();

        // Initialize the resource and add it to the list.
        pciNewRes->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        //DebugBreak();
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewRes;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_RESOURCE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewRes;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT resource not found
        else
        {
            delete pciNewRes;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        //DebugBreak();
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewRes;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewRes == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the resource to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;
            
            pciOldRes   = NULL;
            posPci = LpciResources().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldRes = (CResource *) LpciResources().GetNext(posPci);
                ASSERT_VALID(pciOldRes);
                if (pciOldRes->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciResources().InsertBefore(posCurPci, pciNewRes);
                    break;
                }  // if:  new resource before this resource
                pciOldRes = NULL;
            }  // while:  more items in the list
            if (pciOldRes == NULL)
                LpciResources().AddTail(pciNewRes);
        }  // Add the resource to the list

        // Save this resource as a return value now that we have added it to the list
        pciRetRes = pciNewRes;
        pciNewRes = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiResources;

            // Find the Resources container tree item.
            ptiResources = PtiCluster()->PtiChildFromName(IDS_TREEITEM_RESOURCES);
            ASSERT_VALID(ptiResources);

            // Add the item to the list of children.
            VERIFY(ptiResources->PliAddChild(pciRetRes) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewRes;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetRes != NULL)
        pciRetRes->Release();

    return pciRetRes;

}  //*** CClusterDoc::PciAddNewResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewResourceType
//
//  Routine Description:
//      Add a new resource type to the list of groups.
//
//  Arguments:
//      pszName     [IN] Name of the resource type.
//
//  Return Value:
//      pci         Cluster item for the new resource type.
//
//--
/////////////////////////////////////////////////////////////////////////////
CResourceType * CClusterDoc::PciAddNewResourceType(IN LPCTSTR pszName)
{
    CResourceType * pciNewResType = NULL;
    CResourceType * pciRetResType = NULL;
    CResourceType * pciOldResType = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciResourceTypes().PciResTypeFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_RESTYPE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldResType = LpciResourceTypes().PciResTypeFromName(pszName);
        if (pciOldResType != NULL)
        {
            pciOldResType->Delete();
            pciOldResType = NULL;
        }  // if:  already an item with that name

        // Allocate a new resource type.
        pciNewResType = new CResourceType;
        if ( pciNewResType == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the resource type object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewResType->AddRef();

        // Initialize the resource type and add it to the list.
        pciNewResType->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        //DebugBreak();
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewResType;
            throw;
        }  // if:  RPC call failed error
        else if (pnte->Sc() != ERROR_FILE_NOT_FOUND)
        {
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                delete pciNewResType;
                throw;
            }  // if:  user doesn't want to ignore error
        }  // else if:  error is NOT resource type not found
        else
        {
            delete pciNewResType;
            pnte->Delete();
            return NULL;
        }  // else:  object not found
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        //DebugBreak();

        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewResType;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewResType == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the resource type to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;

            pciOldResType = NULL;
            posPci = LpciResourceTypes().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldResType = (CResourceType *) LpciResourceTypes().GetNext(posPci);
                ASSERT_VALID(pciOldResType);
                if (pciOldResType->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciResourceTypes().InsertBefore(posCurPci, pciNewResType);
                    break;
                }  // if:  new resource type before this resource type
                pciOldResType = NULL;
            }  // while:  more items in the list
            if (pciOldResType == NULL)
                LpciResourceTypes().AddTail(pciNewResType);
        }  // Add the resource type to the list

        // Save this resource type as a return value now that we have added it to the list
        pciRetResType = pciNewResType;
        pciNewResType = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiResTypes;

            // Find the Resource Types container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiResTypes = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_RESTYPES);
            ASSERT_VALID(ptiResTypes);

            // Add the item to the list of children.
            VERIFY(ptiResTypes->PliAddChild(pciRetResType) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewResType;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetResType != NULL)
        pciRetResType->Release();

    return pciRetResType;

}  //*** CClusterDoc::PciAddNewResourceType

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNetwork
//
//  Routine Description:
//      Add a new network to the list of networks.
//
//  Arguments:
//      pszName     [IN] Name of the networks.
//
//  Return Value:
//      pci         Cluster item for the new network.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetwork * CClusterDoc::PciAddNewNetwork(IN LPCTSTR pszName)
{
    CNetwork *  pciNewNetwork = NULL;
    CNetwork *  pciRetNetwork = NULL;
    CNetwork *  pciOldNetwork = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciNetworks().PciNetworkFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NETWORK, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNetwork = LpciNetworks().PciNetworkFromName(pszName);
        if (pciOldNetwork != NULL)
        {
            Trace(g_tagNetwork, _T("Deleting existing network '%s' (%x) before adding new instance"), pszName, pciOldNetwork);
            pciOldNetwork->Delete();
            pciOldNetwork = NULL;
        }  // if:  already an item with that name

        // Allocate a new network.
        pciNewNetwork = new CNetwork;
        if ( pciNewNetwork == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the network object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNetwork->AddRef();

        // Initialize the network.
        pciNewNetwork->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNetwork;
            throw;
        }  // if:  RPC call failed error
        ID id = IdProcessNewObjectError(pnte);
        if (id == IDNO)
        {
            delete pciNewNetwork;
            throw;
        }  // if:  user doesn't want to ignore error
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNetwork;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNetwork == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the network to the list.
        {
            POSITION    posPci;
            POSITION    posCurPci;

            posPci = LpciNetworks().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNetwork = (CNetwork *) LpciNetworks().GetNext(posPci);
                ASSERT_VALID(pciOldNetwork);
                if (pciOldNetwork->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNetworks().InsertBefore(posCurPci, pciNewNetwork);
                    break;
                }  // if:  new network before this network
                pciOldNetwork = NULL;
            }  // while:  more items in the list
            if (pciOldNetwork == NULL)
                LpciNetworks().AddTail(pciNewNetwork);
        }  // Add the network to the list

        // Save this network as a return value now that we have added it to the list
        pciRetNetwork = pciNewNetwork;
        pciNewNetwork = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiNetworks;
            CTreeItem *     ptiNetwork;

            // Find the Networks container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiNetworks = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_NETWORKS);
            ASSERT_VALID(ptiNetworks);

            // Add the item before the found item we inserted it into in the networks list.
            ptiNetwork = ptiNetworks->PtiAddChildBefore(pciOldNetwork, pciRetNetwork);
            ASSERT_VALID(ptiNetwork);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_NODE, COLI_WIDTH_NODE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_NETWORK, COLI_WIDTH_NETWORK);
//          ptiNetwork->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_STATE, COLI_WIDTH_STATE);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_ADAPTER, COLI_WIDTH_NET_ADAPTER);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_ADDRESS, COLI_WIDTH_NET_ADDRESS);
            ptiNetwork->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewNetwork;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNetwork != NULL)
        pciRetNetwork->Release();

    return pciRetNetwork;

}  //*** CClusterDoc::PciAddNewNetwork

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::PciAddNewNetInterface
//
//  Routine Description:
//      Add a new network interfaces to the list of network interfaces.
//
//  Arguments:
//      pszName     [IN] Name of the network interface.
//
//  Return Value:
//      pci         Cluster item for the new network interface.
//
//--
/////////////////////////////////////////////////////////////////////////////
CNetInterface * CClusterDoc::PciAddNewNetInterface(IN LPCTSTR pszName)
{
    CNetInterface * pciNewNetIFace = NULL;
    CNetInterface * pciRetNetIFace = NULL;
    CNetInterface * pciOldNetIFace = NULL;

    ASSERT(pszName != NULL);
    ASSERT(*pszName != NULL);
    ASSERT(LpciNetInterfaces().PciNetInterfaceFromName(pszName) == NULL);

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage(IDS_SB_ADDING_NETIFACE, pszName, StrNode());
        PframeMain()->SetMessageText(strStatusBarText);
        PframeMain()->UpdateWindow();
    }  // Display a message on the status bar

    try
    {
        // If there is an item with that name, delete it.
        pciOldNetIFace = LpciNetInterfaces().PciNetInterfaceFromName(pszName);
        if (pciOldNetIFace != NULL)
        {
            pciOldNetIFace->Delete();
            pciOldNetIFace = NULL;
        }  // if:  already an item with that name

        // Allocate a new network interface.
        pciNewNetIFace = new CNetInterface;
        if ( pciNewNetIFace == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the net interface object

        // Add a reference while we are working on it to prevent a delete
        // notification from taking us out.
        pciNewNetIFace->AddRef();

        // Initialize the network interface.
        pciNewNetIFace->Init(this, pszName);
    }  // try
    catch (CNTException * pnte)
    {
        if (pnte->Sc() == RPC_S_CALL_FAILED)
        {
            if (!m_bIgnoreErrors)
                pnte->ReportError();
            delete pciNewNetIFace;
            throw;
        }  // if:  RPC call failed error
        ID id = IdProcessNewObjectError(pnte);
        if (id == IDNO)
        {
            delete pciNewNetIFace;
            throw;
        }  // if:  user doesn't want to ignore error
        pnte->Delete();
    }  // catch:  CNTException
    catch (CException * pe)
    {
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
        {
            delete pciNewNetIFace;
            throw;
        }  // if:  user doesn't want to ignore error
        pe->Delete();
        if (pciNewNetIFace == NULL)
            return NULL;
    }  // catch:  CException

    try
    {
        // Add the network interface to the list.
        {
            POSITION        posPci;
            POSITION        posCurPci;

            pciOldNetIFace = NULL;
            posPci = LpciNetInterfaces().GetHeadPosition();
            while (posPci != NULL)
            {
                posCurPci = posPci;
                pciOldNetIFace = (CNetInterface *) LpciNetInterfaces().GetNext(posPci);
                ASSERT_VALID(pciOldNetIFace);
                if (pciOldNetIFace->StrName().CompareNoCase(pszName) > 0)
                {
                    LpciNetInterfaces().InsertBefore(posCurPci, pciNewNetIFace);
                    break;
                }  // if:  new network interfaces before this network interface
                pciOldNetIFace = NULL;
            }  // while:  more items in the list
            if (pciOldNetIFace == NULL)
                LpciNetInterfaces().AddTail(pciNewNetIFace);
        }  // Add the network interface to the list

        // Save this network interface as a return value now that we have added it to the list
        pciRetNetIFace = pciNewNetIFace;
        pciNewNetIFace = NULL;

        // Insert the item in the tree.
        {
            CTreeItem *     ptiClusCfg;
            CTreeItem *     ptiNetIFaces;

            // Find the Network Interfaces container tree item.
            ptiClusCfg = PtiCluster()->PtiChildFromName(IDS_TREEITEM_CLUSTER_CONFIG);
            ASSERT_VALID(ptiClusCfg);
            ptiNetIFaces = ptiClusCfg->PtiChildFromName(IDS_TREEITEM_NETIFACES);
            ASSERT_VALID(ptiNetIFaces);

            // Add the item to the list of children.
            VERIFY(ptiNetIFaces->PliAddChild(pciRetNetIFace) != NULL);

        }  // Insert the item in the tree
    }  // try
    catch (CException * pe)
    {
        delete pciNewNetIFace;
        ID id = IdProcessNewObjectError(pe);
        if (id == IDNO)
            throw;
        pe->Delete();
    }  // catch:  CException

    if (pciRetNetIFace != NULL)
        pciRetNetIFace->Release();

    return pciRetNetIFace;

}  //*** CClusterDoc::PciAddNewNetInterface

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNodes
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNodes(void)
{
    POSITION        pos;
    CClusterNode *  pci;
    CNodeList &     rlpci = LpciNodes();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CClusterNode *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                strStatusBarText.FormatMessage(IDS_SB_READING_NODE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNodes

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitGroups
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitGroups(void)
{
    POSITION        pos;
    CGroup *        pci;
    CGroupList &    rlpci = LpciGroups();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CGroup *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                strStatusBarText.FormatMessage(IDS_SB_READING_GROUP, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitGroups

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitResources
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitResources(void)
{
    POSITION        pos;
    CResource *     pci;
    CResourceList & rlpci = LpciResources();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CResource *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_RESOURCE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitResources

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitResourceTypes
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitResourceTypes(void)
{
    POSITION            pos;
    CResourceType *     pci;
    CResourceTypeList & rlpci = LpciResourceTypes();
    CString             strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CResourceType *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_RESTYPE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitResourceTypes

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNetworks
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNetworks(void)
{
    POSITION        pos;
    CNetwork *      pci;
    CNetworkList &  rlpci = LpciNetworks();
    CString         strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CNetwork *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_NETWORK, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNetworks

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::InitNetInterfaces
//
//  Routine Description:
//      Read item data.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::InitNetInterfaces(void)
{
    POSITION            pos;
    CNetInterface *     pci;
    CNetInterfaceList & rlpci = LpciNetInterfaces();
    CString             strStatusBarText;

    pos = rlpci.GetHeadPosition();
    while (pos != NULL)
    {
        pci = (CNetInterface *) rlpci.GetNext(pos);
        pci->AddRef();
        try
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage(IDS_SB_READING_NETIFACE, pci->StrName(), StrNode());
                PframeMain()->SetMessageText(strStatusBarText);
                PframeMain()->UpdateWindow();
            }  // Display a message on the status bar

            pci->ReadItem();
        }  // try
        catch (CNTException * pnte)
        {
            strStatusBarText.Empty();
            if (pnte->Sc() == RPC_S_CALL_FAILED)
            {
                if (!m_bIgnoreErrors)
                    pnte->ReportError();
                pci->Release();
                throw;
            }  // if:  RPC call failed
            ID id = IdProcessNewObjectError(pnte);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pnte->Delete();
        }  // catch:  CNTException
        catch (CException * pe)
        {
            strStatusBarText.Empty();
            ID id = IdProcessNewObjectError(pe);
            if (id == IDNO)
            {
                pci->Release();
                throw;
            }  // if:  don't ignore the error
            pe->Delete();
        }  // catch:  CException
        pci->Release();
    }  // while:  more items in the list

}  //*** CClusterDoc::InitNetInterfaces

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::IdProcessNewObjectError
//
//  Routine Description:
//      Processes errors that occur when adding a new object.  If this
//      occurs during initialization and errors have not already been set
//      to be ignored, display the YesToAll dialog.  If not during
//      initialization, add it to the error message queue to be displayed
//      later.
//
//  Arguments:
//      pe          [IN OUT] Exception object to process.
//
//  Return Value:
//      IDYES               Ignore error.
//      IDNO                Cancel the object creation.
//      IDC_YTA_YESTOALL    Ignore this error and all succeeding ones.
//
//--
/////////////////////////////////////////////////////////////////////////////
ID CClusterDoc::IdProcessNewObjectError(IN OUT CException * pe)
{
    ID id = IDYES;

    ASSERT(pe != NULL);

    if (m_bInitializing)
    {
        if (!m_bIgnoreErrors)
        {
            TCHAR   szErrorMsg[2048];

            CYesToAllDialog dlg(szErrorMsg);
            pe->GetErrorMessage(szErrorMsg, sizeof(szErrorMsg) / sizeof(TCHAR));
            id =  (ID)dlg.DoModal();
            if (id == IDC_YTA_YESTOALL)
                m_bIgnoreErrors = TRUE;
        }  // if:  not ignoring errors
    }  // if:  initializing the connection
    else
    {
        if (!m_bIgnoreErrors)
            pe->ReportError();
    }  // else:  called for a notification

    return id;

}  //*** CClusterDoc::IdProcessNewObjectError

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::AddDefaultColumns
//
//  Routine Description:
//      Add default columns to the item.
//
//  Arguments:
//      pti         [IN OUT] Pointer to the item to add the columns to.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::AddDefaultColumns(IN OUT CTreeItem * pti)
{
    ASSERT_VALID(pti);

    pti->DeleteAllColumns();
    pti->PcoliAddColumn(IDS_COLTEXT_NAME, COLI_WIDTH_NAME);
//  pti->PcoliAddColumn(IDS_COLTEXT_TYPE, COLI_WIDTH_TYPE);
    pti->PcoliAddColumn(IDS_COLTEXT_DESCRIPTION, COLI_WIDTH_DESCRIPTION);

}  //*** CClusterDoc::AddDefaultColumns

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::DeleteContents
//
//  Routine Description:
//      Delete the contents of the document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::DeleteContents(void)
{
    // Select the root item in all views.
    // This is done so that selection is done right up front when all data
    // is still available.
    if (PtiCluster() != NULL)
        PtiCluster()->SelectInAllViews();

    // Delete the tree hierarchy.
    if (m_ptiCluster != NULL)
    {
        // Delete the tree.
        m_ptiCluster->Delete();
        m_ptiCluster->Release();
        m_ptiCluster = NULL;
    }  // if:  there is a hierarchy

    // Delete all the lists.
    DeleteAllItemData(LpciResources());
    DeleteAllItemData(LpciGroups());
    DeleteAllItemData(LpciNetInterfaces());
    DeleteAllItemData(LpciNetworks());
    DeleteAllItemData(LpciNodes());
    DeleteAllItemData(LpciResourceTypes());
    LpciResources().RemoveAll();
    LpciGroups().RemoveAll();
    LpciNetInterfaces().RemoveAll();
    LpciNetworks().RemoveAll();
    LpciNodes().RemoveAll();
    LpciResourceTypes().RemoveAll();

    // Delete the top cluster item.
    if (m_pciCluster != NULL)
    {
        m_pciCluster->Delete();
        m_pciCluster->Release();
        m_pciCluster = NULL;
    }  // if:  there is a cluster item

    // Close the cluster handle and the cluster key.
    CloseClusterKeyAndHandle( FALSE );

    CDocument::DeleteContents();

    UpdateAllViews(NULL);

    // If there are any items left to be deleted, let's delete them now.
    {
        POSITION        pos;
        POSITION        posBeingChecked;
        CClusterItem *  pci;

        pos = LpciToBeDeleted().GetHeadPosition();
        while (pos != NULL)
        {
            posBeingChecked = pos;
            pci = LpciToBeDeleted().GetNext(pos);
            ASSERT_VALID(pci);

            ASSERT(pci->NReferenceCount() == 1);
            if (pci->NReferenceCount() == 1)
                LpciToBeDeleted().RemoveAt(posBeingChecked);
        }  // while:  more items in the list
        ASSERT(LpciToBeDeleted().GetCount() == 0);
    }  // Delete items in To Be Deleted list

}  //*** CClusterDoc::DeleteContents

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::SetPathName
//
//  Routine Description:
//      Set the name of the document.
//
//  Arguments:
//      lpszPathName    [IN] Name of the cluster.
//      bAddToMRU       [IN] TRUE = add to Most Recently Used list.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::SetPathName(IN LPCTSTR lpszPathName, IN BOOL bAddToMRU)
{
    CString     strTitle;

    m_strPathName = lpszPathName;
    ASSERT(!m_strPathName.IsEmpty());       // must be set to something
    m_bEmbedded = FALSE;
    ASSERT_VALID(this);

    // Set the document title to the cluster name.
    strTitle.FormatMessage(IDS_WINDOW_TITLE_FORMAT, m_strName, lpszPathName);
    SetTitle(strTitle);

    // add it to the file MRU list
    if (bAddToMRU)
        AfxGetApp()->AddToRecentFileList(m_strPathName);

    // Set the node name to the path name.
    m_strNode = lpszPathName;

    ASSERT_VALID(this);

}  //*** CClusterDoc::SetPathName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::UpdateTitle
//
//  Routine Description:
//      Update the title of the document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::UpdateTitle(void)
{
    CString     strTitle;

    ASSERT_VALID(PciCluster());
    ASSERT_VALID(this);

    // Set the document title to the cluster name.
    m_strName = PciCluster()->StrName();
    strTitle.FormatMessage(IDS_WINDOW_TITLE_FORMAT, m_strName, m_strPathName);
    SetTitle(strTitle);

}  //*** CClusterDoc::UpdateTitle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnChangedViewList
//
//  Routine Description:
//      Called when the list of view changes by either having a view added
//      or removed.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnChangedViewList(void)
{
    ASSERT_VALID(this);

    // Notify all frames to re-calculate their frame number.
    if (m_bUpdateFrameNumber)
    {
        POSITION            pos;
        CView *             pview;
        CSplitterFrame *    pframe;

        pos = GetFirstViewPosition();
        while (pos != NULL)
        {
            pview = GetNextView(pos);
            ASSERT_VALID(pview);
            if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
            {
                pframe = (CSplitterFrame *) pview->GetParentFrame();
                ASSERT_VALID(pframe);
                pframe->CalculateFrameNumber();
            }  // if:  tree view
        }  // while:  more views on the document
    }  // if:  updating frame numbers

    // Call the base class method.
    CDocument::OnChangedViewList();

}  //*** CClusterDoc::OnChangedViewList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnSelChanged
//
//  Routine Description:
//      Called by one of the cluster views when selection changes.
//      Changes the menu if the object type changed.
//
//  Arguments:
//      pciSelected     [IN] Currently selected item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnSelChanged(IN CClusterItem * pciSelected)
{
    IDM     idmNewMenu;
    HMENU * phmenu;
    IDS     idsType;

    // Get the type of object being selected
    if (pciSelected == NULL)
        idsType = 0;
    else
    {
        ASSERT_VALID(pciSelected);
        idsType = pciSelected->IdsType();
    }  // else:  an item was selected

    // Get the ID of the menu required by the selected item.
    switch (idsType)
    {
        case IDS_ITEMTYPE_CLUSTER:
            idmNewMenu = IDM_CLUSTER;
            phmenu = &m_hmenuCluster;
            break;

        case IDS_ITEMTYPE_NODE:
            idmNewMenu = IDM_NODE;
            phmenu = &m_hmenuNode;
            break;

        case IDS_ITEMTYPE_GROUP:
            idmNewMenu = IDM_GROUP;
            phmenu = &m_hmenuGroup;
            break;

        case IDS_ITEMTYPE_RESOURCE:
            idmNewMenu = IDM_RESOURCE;
            phmenu = &m_hmenuResource;
            break;

        case IDS_ITEMTYPE_RESTYPE:
            idmNewMenu = IDM_RESTYPE;
            phmenu = &m_hmenuResType;
            break;

        case IDS_ITEMTYPE_NETWORK:
            idmNewMenu = IDM_NETWORK;
            phmenu = &m_hmenuNetwork;
            break;

        case IDS_ITEMTYPE_NETIFACE:
            idmNewMenu = IDM_NETIFACE;
            phmenu = &m_hmenuNetIFace;
            break;

        default:
            idmNewMenu = 0;
            phmenu = NULL;
            break;

    }  // switch:  pciSelected->IdsType()

    // If the menu ID changed, load the new one.
    if (m_idmCurrentMenu != idmNewMenu)
    {
        if (idmNewMenu == 0)
            m_hmenuCurrent = NULL;
        else
        {
            if (*phmenu == NULL)
                *phmenu = ::LoadMenu(AfxGetResourceHandle(), MAKEINTRESOURCE(idmNewMenu));
            m_hmenuCurrent = *phmenu;
        }  // else:  special menu required by item

        m_idmCurrentMenu = idmNewMenu;
    }  // if:  menu ID changed

    // Update the menu bar and redisplay it.
    if (((CMDIFrameWnd *) AfxGetMainWnd())->MDIGetActive() != NULL)
    {
#ifdef _DEBUG
        if (g_tagDocMenu.BAny())
        {
            TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("OnSelChanged menu: "));
            {
                CMDIFrameWnd *  pFrame = (CMDIFrameWnd *) AfxGetMainWnd();
                CMenu           menuDefault;

                menuDefault.Attach(pFrame->m_hMenuDefault);
                TraceMenu(g_tagDocMenu, &menuDefault, _T("Frame default menu before OnSelChanged: "));
                menuDefault.Detach();
            }  // trace default menu
        }  // if:  tag is active
#endif

        ((CFrameWnd *) AfxGetMainWnd())->OnUpdateFrameMenu(NULL);
        AfxGetMainWnd()->DrawMenuBar();

        TraceMenu(g_tagDocMenu, AfxGetMainWnd()->GetMenu(), _T("Post-OnSelChanged menu: "));
    }  // if:  active window present

}  //*** CClusterDoc::OnSelChanged

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::GetDefaultMenu
//
//  Routine Description:
//      Returns the menu to use.  Overridden to allow us to use multiple menus
//      with the same type of document.
//
//  Arguments:
//      None.
//
//  Return Value:
//      hmenu       The currently selected menu, or NULL for no default.
//
//--
/////////////////////////////////////////////////////////////////////////////
HMENU CClusterDoc::GetDefaultMenu(void)
{
    return m_hmenuCurrent;

}  //*** CClusterDoc::GetDefaultMenu

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdRefresh
//
//  Routine Description:
//      Processes the ID_VIEW_REFRESH menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdRefresh(void)
{
    CWaitCursor     wc;

    try
    {
        Trace(g_tagDocRefresh, _T("(%s) Deleting old contents"), StrNode());

        {
            POSITION            pos;
            CSplitterFrame *    pframe;
            CView *             pview;

            // Get the active child frame window.
            pframe = (CSplitterFrame *) ((CFrameWnd *) AfxGetMainWnd())->GetActiveFrame();
            if ((pframe->IsKindOf(RUNTIME_CLASS(CSplitterFrame)))
                    && (pframe->PviewList()->PtiParent() != NULL))
            {
                // Tell the view to save its column information.
                pframe->PviewList()->SaveColumns();
            }  //  if:  MDI window exists

            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                pview = GetNextView(pos);
                if (pview->IsKindOf(RUNTIME_CLASS(CClusterTreeView)))
                {
                    // Save the current selection
                    ((CClusterTreeView *) pview)->SaveCurrentSelection();
                }  // if:  this is a tree view
            }  // while:  more views
        }  // Save the column information

        DeleteContents();

        Trace(g_tagDocRefresh, _T("(%s) %d items still to be deleted"), StrNode(), LpciToBeDeleted().GetCount());

        Trace(g_tagDocRefresh, _T("(%s) Creating new cluster object"), StrNode());

        m_bClusterAvailable = TRUE;
        m_bInitializing = TRUE;

        // Create a new cluster object.
        m_pciCluster = new CCluster;
        if ( m_pciCluster == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the cluster object
        PciCluster()->AddRef();
        PciCluster()->Init(this, GetPathName());

        Trace(g_tagDocRefresh, _T("(%s) Building base hierarchy"), StrNode());

        // Build the base hierarchy.
        BuildBaseHierarchy();

        Trace(g_tagDocRefresh, _T("(%s) Collecting cluster items"), StrNode());

        // Collect the items in the cluster and build the hierarchy.
        CollectClusterItems();
        PciCluster()->CollectNetworkPriority(NULL);

        Trace(g_tagDocRefresh, _T("(%s) Re-initializing the views"), StrNode());

        // Re-initialize the views.
        {
            POSITION    pos;
            CView *     pview;

            pos = GetFirstViewPosition();
            while (pos != NULL)
            {
                pview = GetNextView(pos);
                ASSERT_VALID(pview);
                pview->OnInitialUpdate();
            }  // while:  more items in the list
        }  // Re-initialize the views
    }  // try
    catch (CException * pe)
    {
        if (!m_bIgnoreErrors)
            pe->ReportError();
        pe->Delete();

        // Close the cluster handle and the cluster key.
        CloseClusterKeyAndHandle( TRUE );   // TRUE forces the Cluster handle to be closed.

        m_bClusterAvailable = FALSE;
    }  // catch:  CException

    // Reset the message on the status bar.
    PframeMain()->SetMessageText(AFX_IDS_IDLEMESSAGE);
    PframeMain()->UpdateWindow();

    m_bInitializing = FALSE;

#ifdef GC_DEBUG
    gcCollect();
#endif

}  //*** CClusterDoc::OnCmdRefresh

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewGroup
//
//  Routine Description:
//      Processes the ID_FILE_NEW_GROUP menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewGroup(void)
{
    CCreateGroupWizard  wiz(this, AfxGetMainWnd());

    if (wiz.BInit())
    {
        if (wiz.DoModal() == ID_WIZFINISH)
        {
            CString     strMsg;

            strMsg.FormatMessage(IDS_CREATED_GROUP, wiz.StrName());
            AfxMessageBox(strMsg, MB_ICONINFORMATION);
        }  // if:  user pressed the FINISH button
    }  // if:  wizard initialized successfully

}  //*** CClusterDoc::OnCmdNewGroup

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewResource
//
//  Routine Description:
//      Processes the ID_FILE_NEW_RESOURCE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewResource(void)
{
    CCreateResourceWizard   wiz(this, AfxGetMainWnd());

    if (wiz.BInit())
    {
        if (wiz.DoModal() == ID_WIZFINISH)
        {
            CString     strMsg;

            strMsg.FormatMessage(IDS_CREATED_RESOURCE, wiz.StrName());
            AfxMessageBox(strMsg, MB_ICONINFORMATION);
        }  // if:  user pressed the FINISH button
    }  // if:  wizard initialized successfully

}  //*** CClusterDoc::OnCmdNewResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdNewNode
//
//  Routine Description:
//      Processes the ID_FILE_NEW_NODE menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdNewNode( void )
{
    NewNodeWizard( StrGetClusterName( Hcluster() ), m_bIgnoreErrors );
}  //*** CClusterDoc::OnCmdNewNode

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnCmdConfigApp
//
//  Routine Description:
//      Processes the ID_FILE_CONFIG_APP menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::OnCmdConfigApp(void)
{
    HRESULT                     hr;
    IClusterApplicationWizard * piWiz;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            __uuidof(ClusAppWiz),
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(IClusterApplicationWizard),
            (LPVOID *) &piWiz
            );
    if (FAILED(hr))
    {
        CNTException nte(hr, (IDS) 0);
        if (!m_bIgnoreErrors)
            nte.ReportError();
        return;
    }  // if:  error getting the interface pointer

    // Display the wizard.
    hr = piWiz->DoModalWizard(AfxGetMainWnd()->m_hWnd,
                              (ULONG_PTR)Hcluster(),
                              NULL);
    piWiz->Release();

    // Handle any errors.
    if (FAILED(hr))
    {
        CNTException nte(hr, (IDS) 0);
        if (!m_bIgnoreErrors)
            nte.ReportError();
    }  // if:  error from the wizard

}  //*** CClusterDoc::OnCmdConfigApp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterDoc::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    ASSERT( pnotify != NULL );

    BOOL            bOldIgnoreErrors = m_bIgnoreErrors;
    CClusterItem *  pciClusterItemPtr = NULL;

    m_bIgnoreErrors = TRUE;

    try
    {
        switch ( pnotify->m_dwFilterType )
        {
            case CLUSTER_CHANGE_CLUSTER_STATE:
                {
                    m_bClusterAvailable = FALSE;

                    // Update the state of all objects in the cluster.
                    ASSERT_VALID( PtiCluster() );
                    PtiCluster()->UpdateAllStatesInTree();
                    try
                    {
                        CString     strMsg;
                        ASSERT( pnotify->m_strName.GetLength() > 0 );
                        strMsg.FormatMessage( IDS_CLUSTER_NOT_AVAILABLE, pnotify->m_strName );
                        AfxMessageBox( strMsg, MB_ICONINFORMATION );
                    }  // try
                    catch ( CException * pe )
                    {
                        pe->Delete();
                    }  // catch:  CException
                    break;
                }

            case CLUSTER_CHANGE_CLUSTER_PROPERTY:
                {
                    ASSERT_VALID( PciCluster() );
                    Trace( g_tagDocNotify, _T("(%s) - Cluster properties changed - new name is '%s'"), StrNode(), pnotify->m_strName );
                    PciCluster()->ReadItem();
                    PciCluster()->CollectNetworkPriority( NULL );
                    break;
                }

            case CLUSTER_CHANGE_NODE_ADDED:
                {
                    CClusterNode *  pciNode;
                    Trace( g_tagNodeNotify, _T("(%s) - Adding node '%s'"), m_strPathName, pnotify->m_strName );
                    pciNode = PciAddNewNode( pnotify->m_strName );
                    if ( pciNode != NULL )
                    {
                        ASSERT_VALID( pciNode );
                        pciNode->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNode;
                        pciNode->ReadItem();
                    }  // if:  node was added
                    break;
                }

            case CLUSTER_CHANGE_GROUP_ADDED:
                {
                    CGroup *    pciGroup;
                    Trace( g_tagGroupNotify, _T("(%s) - Adding group '%s'"), m_strPathName, pnotify->m_strName );
                    pciGroup = PciAddNewGroup( pnotify->m_strName );
                    if ( pciGroup != NULL )
                    {
                        ASSERT_VALID( pciGroup );
                        pciGroup->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciGroup;
                        pciGroup->ReadItem();
                    } // if:  group was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_ADDED:
                {
                    CResource * pciRes;
                    Trace( g_tagResNotify, _T("(%s) - Adding resource '%s'"), m_strPathName, pnotify->m_strName );
                    pciRes = PciAddNewResource( pnotify->m_strName );
                    if (pciRes != NULL)
                    {
                        ASSERT_VALID( pciRes );
                        pciRes->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciRes;
                        if ( ! pciRes->BInitializing() )
                        {
                            pciRes->ReadItem();
                        } // if: not initializing the resource
                    } // if:  resource was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_ADDED:
                {
                    CResourceType * pciResType;
                    Trace( g_tagResTypeNotify, _T("(%s) - Adding resource Type '%s'"), m_strPathName, pnotify->m_strName );
                    pciResType = PciAddNewResourceType( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        pciResType->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciResType;
                        pciResType->ReadItem();
                    } // if:  resource type was added
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_DELETED:
                {
                    ASSERT( pnotify->m_strName.GetLength() > 0 );
                    CResourceType * pciResType = LpciResourceTypes().PciResTypeFromName( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        Trace( g_tagResTypeNotify, _T("(%s) - Resource Type '%s' deleted"), m_strPathName, pnotify->m_strName );
                        pciResType->Delete();
                    }  // if:  resource type was found
                    else
                    {
                        Trace( g_tagDocNotify, _T("(%s) - Resource Type '%s' deleted (NOT FOUND)"), m_strPathName, pnotify->m_strName );
                    } // else: resource type not found
                    break;
                }

            case CLUSTER_CHANGE_RESOURCE_TYPE_PROPERTY:
                {
                    ASSERT( pnotify->m_strName.GetLength() > 0 );
                    CResourceType * pciResType = LpciResourceTypes().PciResTypeFromName( pnotify->m_strName );
                    if ( pciResType != NULL )
                    {
                        ASSERT_VALID( pciResType );
                        Trace( g_tagResTypeNotify, _T("(%s) - Resource Type '%s' property change"), m_strPathName, pnotify->m_strName );
                        pciResType->ReadItem();
                    } // if:  resource type was found
                    else
                    {
                        Trace( g_tagDocNotify, _T("(%s) - Resource Type '%s' deleted (NOT FOUND)"), m_strPathName, pnotify->m_strName );
                    } // else: resource type not found
                    break;
                }

            case CLUSTER_CHANGE_NETWORK_ADDED:
                {
                    CNetwork *  pciNetwork;
                    Trace( g_tagNetNotify, _T("(%s) - Adding network '%s'"), m_strPathName, pnotify->m_strName );
                    pciNetwork = PciAddNewNetwork( pnotify->m_strName );
                    if ( pciNetwork != NULL )
                    {
                        ASSERT_VALID( pciNetwork );
                        pciNetwork->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNetwork;
                        pciNetwork->ReadItem();
                    } // if:  network was added
                    break;
                }

            case CLUSTER_CHANGE_NETINTERFACE_ADDED:
                {
                    CNetInterface * pciNetIFace;
                    Trace( g_tagNetIFaceNotify, _T("(%s) - Adding network interface '%s'"), m_strPathName, pnotify->m_strName );
                    pciNetIFace = PciAddNewNetInterface( pnotify->m_strName );
                    if ( pciNetIFace != NULL )
                    {
                        ASSERT_VALID( pciNetIFace );
                        pciNetIFace->AddRef();
                        // For calling Release later. This is done so that
                        // release is called even if ReadItem below throws an exception.
                        pciClusterItemPtr = pciNetIFace;
                        pciNetIFace->ReadItem();
                    } // if:  network interface was added
                    break;
                }

            case CLUSTER_CHANGE_QUORUM_STATE:
                Trace( g_tagDocNotify, _T("(%s) - Quorum state changed (%s)"), m_strPathName, pnotify->m_strName );
                break;

            case CLUSTER_CHANGE_REGISTRY_NAME:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry namespace '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            case CLUSTER_CHANGE_REGISTRY_ATTRIBUTES:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry atributes for '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            case CLUSTER_CHANGE_REGISTRY_VALUE:
                Trace( g_tagDocRegNotify, _T("(%s) - Registry value '%s' changed"), m_strPathName, pnotify->m_strName );
                ProcessRegNotification( pnotify );
                break;

            default:
                Trace( g_tagDocNotify, _T("(%s) - Unknown notification (%x) for '%s'"), m_strPathName, pnotify->m_dwFilterType, pnotify->m_strName );
        } // switch:  dwFilterType
    } // try
    catch ( CException * pe )
    {
        // Don't display anything on notification errors.
        // If it's really a problem, the user will see it when
        // refreshing the view.
        if ( ! m_bIgnoreErrors )
        {
            pe->ReportError();
        } // if: not ignoring errors
        pe->Delete();
    } // catch:  CException

    if ( pciClusterItemPtr != NULL )
    {
        pciClusterItemPtr->Release();
    } // if: cluster item pointer not released yet

    m_bIgnoreErrors = bOldIgnoreErrors;

    // Reset the message on the status bar.
    {
        CFrameWnd * pframe = PframeMain( );
        if ( pframe != NULL )
        {
            pframe->SetMessageText(AFX_IDS_IDLEMESSAGE);
            pframe->UpdateWindow();
        } // if: main frame window is available
    }

    delete pnotify;
    return 0;

} //*** CClusterDoc::OnClusterNotify

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::ProcessRegNotification
//
//  Routine Description:
//      Process registry notifications for the document.
//
//  Arguments:
//      pnotify     [IN] Object describing the notification.
//
//  Return Value:
//      pci         Cluster item that cares about the notification.
//      NULL        Unknown object.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::ProcessRegNotification(IN const CClusterNotify * pnotify)
{
    CCluster *  pci             = NULL;
    HKEY        hkey            = NULL;
    CString     strRootKeyName;

#define RESTYPE_KEY_NAME_PREFIX CLUSREG_KEYNAME_RESOURCE_TYPES _T("\\")

    try
    {
        // If there is no key name, update the cluster item.
        if (pnotify->m_strName.GetLength() == 0)
            pci = PciCluster();
        else
        {
            // Find the root key name.
            strRootKeyName = pnotify->m_strName.SpanExcluding(_T("\\"));

            // If the root key name is the same as the notification name
            // and it is for one of the object type keys, reread the lists
            // of extensions for that one type of object.
            if (strRootKeyName == pnotify->m_strName)
            {
                POSITION    pos;

                // Find the object based on its type.
                if (strRootKeyName == CLUSREG_KEYNAME_NODES)
                {
                    PciCluster()->ReadNodeExtensions();
                    pos = LpciNodes().GetHeadPosition();
                    while (pos != NULL)
                        ((CClusterNode *) LpciNodes().GetNext(pos))->ReadExtensions();
                }  // if:  node registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_GROUPS)
                {
                    PciCluster()->ReadGroupExtensions();
                    pos = LpciGroups().GetHeadPosition();
                    while (pos != NULL)
                        ((CGroup *) LpciGroups().GetNext(pos))->ReadExtensions();
                }  // else if:  group registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_RESOURCES)
                {
                    PciCluster()->ReadResourceExtensions();
                    pos = LpciResources().GetHeadPosition();
                    while (pos != NULL)
                        ((CResource *) LpciResources().GetNext(pos))->ReadExtensions();
                }  // else if:  resource registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_RESOURCE_TYPES)
                {
                    PciCluster()->ReadResTypeExtensions();
                    pos = LpciResourceTypes().GetHeadPosition();
                    while (pos != NULL)
                        ((CResourceType *) LpciResourceTypes().GetNext(pos))->ReadExtensions();
                    pos = LpciResources().GetHeadPosition();
                    while (pos != NULL)
                        ((CResource *) LpciResources().GetNext(pos))->ReadExtensions();
                }  // else if:  resource type registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_NETWORKS)
                {
                    PciCluster()->ReadNetworkExtensions();
                    pos = LpciNetworks().GetHeadPosition();
                    while (pos != NULL)
                        ((CNetwork *) LpciNetworks().GetNext(pos))->ReadExtensions();
                }  // else if:  network registry notification
                else if (strRootKeyName == CLUSREG_KEYNAME_NETINTERFACES)
                {
                    PciCluster()->ReadNetInterfaceExtensions();
                    pos = LpciNetInterfaces().GetHeadPosition();
                    while (pos != NULL)
                        ((CNetInterface *) LpciNetInterfaces().GetNext(pos))->ReadExtensions();
                }  // else if:  network interface registry notification
            }  // if:  root name and full name are the same
            else if ( ClRtlStrNICmp( pnotify->m_strName, RESTYPE_KEY_NAME_PREFIX, RTL_NUMBER_OF( RESTYPE_KEY_NAME_PREFIX ) ) == 0 )
            {
                int             idxSlash = pnotify->m_strName.Find(_T('\\'));
                CString         strResTypeName;
                CResource *     pciRes;
                CResourceType * pciResType;
                POSITION        pos;

                strResTypeName = pnotify->m_strName.Mid(
                                          idxSlash + 1
                                        , static_cast< int >( _tcslen( pnotify->m_strName ) - _tcslen( RESTYPE_KEY_NAME_PREFIX ) )
                                        );

                // Re-read the resource type extensions.
                pos = LpciResourceTypes().GetHeadPosition();
                while (pos != NULL)
                {
                    pciResType = (CResourceType *) LpciResourceTypes().GetNext(pos);
                    if (pciResType->StrName().CompareNoCase(strResTypeName) == 0)
                    {
                        pciResType->ReadExtensions();
                        break;
                    } // if: found the resource type
                } // while: more resource types

                // Re-read the resource extensions.
                pos = LpciResources().GetHeadPosition();
                while (pos != NULL)
                {
                    pciRes = (CResource *) LpciResources().GetNext(pos);
                    if (pciRes->StrResourceType() == strResTypeName)
                    {
                        pciRes->ReadExtensions();
                    } // if: found a resource of that type
                } // while: more resources
            } // else if: single resource type changed

            pci = PciCluster();
        } // else:  not the cluster object

        // If the cluster object can process it, have it re-read its info
        if (pci != NULL)
        {
            pci->MarkAsChanged();
            pci->ReadClusterExtensions();
        }  // if:  cluster object changed
    }  // try
    catch (...)
    {
    }

    if (hkey != NULL)
    {
        ::ClusterRegCloseKey(hkey);
    }

}  //*** CClusterDoc::ProcessRegNotification

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterDoc::CloseClusterKeyAndHandle
//
//  Routine Description:
//      Clean up routine that closes the cluster key and cluster handle.
//
//  Arguments:
//      bForce: 
//              TRUE forces the cluster handle to be closed.
//
//              FALSE (default) verifies that the AdminApp has a different
//                    cluster handle. 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterDoc::CloseClusterKeyAndHandle( BOOL bForce /* FALSE */ )
{
    if (HkeyCluster() != NULL)
    {
        ClusterRegCloseKey(HkeyCluster());
        m_hkeyCluster = NULL;
    }  // if:  cluster registry key is open

    if ( Hcluster() != NULL )
    {
        //
        // If bForce is TRUE or we have a different Hcluster() handle
        // 
        if ( bForce || (Hcluster() != GetClusterAdminApp()->HOpenedCluster()) ) 
        {
            CloseCluster(Hcluster());
            m_hcluster = NULL;
        }  // if:  cluster is open
    }

} // *** CClusterDoc::CloseClusterKeyAndHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\casvc.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CASvc.cpp
//
//  Description:
//      Implementation of helper functions for accessing and controlling
//      services.
//
//  Maintained By:
//      David Potter (davidp)   December 23, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <winsvc.h>
#include "resource.h"
#define _RESOURCE_H_
#include "CASvc.h"
#include "ConstDef.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "CluAdmin.h"
#include <FileMgmt.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag   g_tagService( _T("Service"), _T("SERVICE"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HOpenCluster
//
//  Description:
//      Open a cluster.  If it fails, ask if the cluster service should be
//      started.
//
//  Arguments:
//      pszClusterIn    -- Name of cluster.
//
//  Return Values:
//      hCluster        -- Cluster handle or NULL.
//
//--
/////////////////////////////////////////////////////////////////////////////
HCLUSTER
HOpenCluster(
    IN LPCTSTR  pszClusterIn
    )
{
    HCLUSTER    hCluster        = NULL;
    HRESULT     hr;
    DWORD       dwStatus;
    DWORD       dwClusterState;
    LPTSTR      pszRealCluster;
    TCHAR       szRealClusterName[ MAX_PATH ];
    CString     strMsg;
    CFrameWnd * pframeMain;

    ASSERT( pszClusterIn != NULL );

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    if ( _tcscmp( pszClusterIn, _T(".") ) == 0 )
    {
        DWORD   nSize = sizeof( szRealClusterName ) / sizeof( TCHAR );
        pszRealCluster = NULL;
        GetComputerName( szRealClusterName, &nSize );
    } // if: connecting to the local machine
    else
    {
        pszRealCluster = (LPTSTR) pszClusterIn;
        hr = StringCchCopy( szRealClusterName, RTL_NUMBER_OF( szRealClusterName ), pszClusterIn );
        if ( FAILED( hr ) )
        {
            CNTException nte( hr, 0, NULL, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
            goto Cleanup;
        }
    } // else: not connecting to the local machine

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_OPENING_CONNECTION, szRealClusterName );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Encapsulate wait cursor class.
    {
        CWaitCursor wc;

        Trace( g_tagService, _T("HOpenCluster() - Getting node cluster state on '%s'"), szRealClusterName );

        // Get the cluster state of the node.
        dwStatus = GetNodeClusterState( pszRealCluster, &dwClusterState );
        if ( dwStatus != ERROR_SUCCESS )
        {
            CNTException nte( dwStatus, IDS_CANNOT_START_CLUSTER_SERVICE, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError( MB_OK | MB_ICONSTOP );
            goto Cleanup;
        }

        Trace( g_tagService, _T("HOpenCluster() - Node cluster state on '%s' is 0x%08.8x"), szRealClusterName, dwClusterState );

    } // Encapsulate wait cursor class

    // Check to see make sure that clustering is installed and configured
    // on the specified node.
    if ( ( dwClusterState == ClusterStateNotInstalled )
      || ( dwClusterState == ClusterStateNotConfigured ) )
    {
        strMsg.FormatMessage( IDS_CLUSTER_NOT_INSTALLED_OR_CONFIGURED, szRealClusterName );
        AfxMessageBox( strMsg, MB_OK | MB_ICONSTOP );
        goto Cleanup;
    } // if: clustering not installed or configured

    // If the cluster service is not running, ask if it should be started.
    if ( dwClusterState == ClusterStateNotRunning )
    {
        ID      id;

        // Ask the user if the cluster service should be started.
        strMsg.FormatMessage( IDS_START_CLUSTER_SERVICE, szRealClusterName );
        id = AfxMessageBox( strMsg, MB_YESNO | MB_ICONEXCLAMATION );
        if ( id == IDYES )
        {
            // Display a message on the status bar.
            {
                CString     strStatusBarText;
                strStatusBarText.FormatMessage( IDS_SB_STARTING_CLUSTER_SERVICE, szRealClusterName );
                pframeMain->SetMessageText( strStatusBarText );
                pframeMain->UpdateWindow();
            } // Display a message on the status bar

            // Encapsulate wait cursor class.
            {
                CWaitCursor wc;

                // Start the service.
                hr = HrStartService( CLUSTER_SERVICE_NAME, szRealClusterName );
                if ( ! FAILED( hr ) && ( hr != S_FALSE ) )
                {
                    if ( hr == S_OK )
                    {
                        // Wait a second.  This is required to make sure that the
                        // cluster service is running and ready to receive RPC
                        // connections.
                        Sleep( 1000 );
                    } // if: user didn't cancel the start operation
                } // if: service started successfully
                else
                {
                    CNTException nte( hr, IDS_CANNOT_START_CLUSTER_SERVICE, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );
                    nte.ReportError();
                    goto Cleanup;
                } // else: failed to start the service

            } // Encapsulate wait cursor class
        } // if: user approved starting the service

    } // if: cluster service not running

    // Encapsulate wait cursor class.
    {
        CWaitCursor wc;

        // Display a message on the status bar.
        {
            CString     strStatusBarText;
            strStatusBarText.FormatMessage( IDS_SB_OPENING_CONNECTION, szRealClusterName );
            pframeMain->SetMessageText( strStatusBarText );
            pframeMain->UpdateWindow();
        } // Display a message on the status bar

        Trace( g_tagService, _T("HOpenCluster() - Opening the cluster on '%s'"), szRealClusterName );

        // Open the cluster.
        hCluster = OpenCluster( pszRealCluster );
        if ( hCluster == NULL )
        {
            CNTException nte( GetLastError(), IDS_OPEN_NODE_ERROR, szRealClusterName, NULL, FALSE /*bAutoDelete*/ );

            dwStatus = nte.Sc();
            nte.ReportError();
            goto Cleanup;
        } // if: error opening the cluster

    } // Encapsulate wait cursor class

Cleanup:
    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    if ( dwStatus != ERROR_SUCCESS )
    {
        SetLastError( dwStatus );
    } // if: error occurred

    return hCluster;

} //*** HOpenCluster()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BCanServiceBeStarted
//
//  Description:
//      Find out if a service can be started on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      TRUE            -- Service can be started on the specified node.
//      FALSE           -- Service can not be started on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BCanServiceBeStarted(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL            bCanBeStarted   = FALSE;
    DWORD           dwStatus        = ERROR_SUCCESS;
    SC_HANDLE       hSCManager      = NULL;
    SC_HANDLE       hService        = NULL;
    SERVICE_STATUS  ssServiceStatus;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BCanServiceBeStarted() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BCanServiceBeStarted() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        if ( dwStatus != ERROR_SERVICE_DOES_NOT_EXIST )
        {
            bCanBeStarted = TRUE;
        } // if: error not Service Does Not Exist
        goto Cleanup;
    } // if: error opening the service

    // Query the service status.
    if ( QueryServiceStatus( hService, &ssServiceStatus ) )
    {
        if ( ssServiceStatus.dwCurrentState == SERVICE_STOPPED )
        {
            bCanBeStarted = TRUE;
        } // if: service is stopped
    } // if: service status queried successfully
    else
    {
        dwStatus = GetLastError();
    } // if: error querying service status

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bCanBeStarted;

} //*** BCanServiceBeStarted()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BIsServiceInstalled
//
//  Routine Description:
//      Find out if a service is installed on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Value:
//      TRUE            -- Service is running on the specified node.
//      FALSE           -- Service is not running on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BIsServiceInstalled(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL        bInstalled  = FALSE;
    DWORD       dwStatus    = ERROR_SUCCESS;
    SC_HANDLE   hSCManager  = NULL;
    SC_HANDLE   hService    = NULL;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceInstalled() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceInstalled() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        if ( dwStatus != ERROR_SERVICE_DOES_NOT_EXIST )
        {
            bInstalled = TRUE;
        } // if: error not Service Does Not Exist
    } // if: error opening the service
    else
    {
        bInstalled = TRUE;
    } // else: service opened successfully

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bInstalled;

} //*** BIsServiceInstalled()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BIsServiceRunning
//
//  Description:
//      Find out if a service is running on a specified node or not.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      TRUE            -- Service is running on the specified node.
//      FALSE           -- Service is not running on the specified node.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL
BIsServiceRunning(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    BOOL            bRunning    = FALSE;
    DWORD           dwStatus    = ERROR_SUCCESS;
    SC_HANDLE       hSCManager  = NULL;
    SC_HANDLE       hService    = NULL;
    SERVICE_STATUS  ssServiceStatus;

    // Open the Service Control Manager.
    hSCManager = OpenSCManager( pszNodeIn, NULL /*lpDatabaseName*/, GENERIC_READ );
    if ( hSCManager == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceRunning() - Cannot access service control manager on node '%s'!  Error: %u."), pszNodeIn, dwStatus );
        goto Cleanup;
    } // if: error opening the Service Control Manager

    // Open the service.
    hService = OpenService( hSCManager, pszServiceNameIn, SERVICE_ALL_ACCESS );
    if ( hService == NULL )
    {
        dwStatus = GetLastError();
        Trace( g_tagService, _T("BIsServiceRunning() - Cannot open service %s. Error: %u."), pszServiceNameIn, dwStatus );
        goto Cleanup;
    } // if: error opening the service

    // Query the service status.
    if ( QueryServiceStatus( hService, &ssServiceStatus ) )
    {
        if ( ssServiceStatus.dwCurrentState == SERVICE_RUNNING )
        {
            bRunning = TRUE;
        } // if: service is running
    } // if: service status queried successfully

Cleanup:
    if ( hService != NULL )
    {
        CloseServiceHandle( hService );
    }

    if ( hSCManager != NULL )
    {
        CloseServiceHandle( hSCManager );
    }

    SetLastError( dwStatus );

    return bRunning;

} //*** BIsServiceRunning()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrStartService
//
//  Description:
//      Start a service on a specified node.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      S_OK                -- Service started successfully.
//      Any errors returned by SVCMGMT_IStartStopHelper::StartServiceHelper().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrStartService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    HRESULT                     hr              = S_OK;
    ISvcMgmtStartStopHelper *   psmssh          = NULL;
    BSTR                        bstrNode        = NULL;
    BSTR                        bstrServiceName = NULL;
    CFrameWnd *                 pframeMain;

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_STARTING_SERVICE, pszServiceNameIn, pszNodeIn );
        Trace( g_tagService, _T("HrStartService() - Starting the '%s' service on node '%s'."), pszServiceNameIn, pszNodeIn );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Make BSTRs for the arguments.
    bstrNode = SysAllocString( pszNodeIn );
    if ( bstrNode == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    bstrServiceName = SysAllocString( pszServiceNameIn );
    if ( bstrServiceName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create the service management object.
    hr = CoCreateInstance(
                CLSID_SvcMgmt,
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof( ISvcMgmtStartStopHelper ),
                reinterpret_cast< void ** >( &psmssh )
                );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStartService() - Error creating IStartStopHelper interface.  Error: %u."), hr );
        goto Cleanup;
    }

    // Start the service.
    hr = psmssh->StartServiceHelper( AfxGetMainWnd()->m_hWnd, bstrNode, bstrServiceName, 0, NULL );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStartService() - Error from IStartStopHelper::StartServiceHelper() to start the '%s' service on node '%s'.  Error: %u."), pszServiceNameIn, pszNodeIn, hr );
        goto Cleanup;
    }

Cleanup:
    if ( bstrNode != NULL )
    {
        SysFreeString( bstrNode );
    }
    if ( bstrServiceName != NULL )
    {
        SysFreeString( bstrServiceName );
    }
    if ( psmssh != NULL )
    {
        psmssh->Release();
    }

    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    return hr;

} //*** HrStartService()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  HrStopService
//
//  Description:
//      Stop a service on a specified node.
//
//  Arguments:
//      pszServiceNameIn    -- Name of service.
//      pszNodeIn           -- Name of node.
//
//  Return Values:
//      S_OK                -- Service stopped successfully.
//      Any errors returned by SVCMGMT_IStartStopHelper::ControlServiceHelper().
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT
HrStopService(
    LPCTSTR pszServiceNameIn,
    LPCTSTR pszNodeIn
    )
{
    HRESULT                     hr              = S_OK;
    ISvcMgmtStartStopHelper *   psmssh          = NULL;
    BSTR                        bstrNode        = NULL;
    BSTR                        bstrServiceName = NULL;
    CFrameWnd *                 pframeMain;

    pframeMain = PframeMain();
    ASSERT( pframeMain != NULL );

    // Display a message on the status bar.
    {
        CString     strStatusBarText;
        strStatusBarText.FormatMessage( IDS_SB_STOPPING_SERVICE, pszServiceNameIn, pszNodeIn );
        Trace( g_tagService, _T("HrStopService() - Stopping the '%s' service on node '%s'."), pszServiceNameIn, pszNodeIn );
        pframeMain->SetMessageText( strStatusBarText );
        pframeMain->UpdateWindow();
    } // Display a message on the status bar

    // Make BSTRs for the arguments.
    bstrNode = SysAllocString( pszNodeIn );
    if ( bstrNode == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    bstrServiceName = SysAllocString( pszServiceNameIn );
    if ( bstrServiceName == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create the service management object.
    hr = CoCreateInstance(
                CLSID_SvcMgmt,
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof( ISvcMgmtStartStopHelper ),
                reinterpret_cast< void ** >( &psmssh )
                );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStopService() - Error creating IStartStopHelper interface.  Error: %u."), hr );
        goto Cleanup;
    }

    // Start the service.
    hr = psmssh->ControlServiceHelper( AfxGetMainWnd()->m_hWnd, bstrNode, bstrServiceName, SERVICE_CONTROL_STOP );
    if ( FAILED( hr ) )
    {
        Trace( g_tagService, _T("HrStopService() - Error from IStartStopHelper::ControlServiceHelper() to stop the '%s' service on node '%s'.  Error: %u."), pszServiceNameIn, pszNodeIn, hr );
        goto Cleanup;
    }

Cleanup:
    if ( bstrNode != NULL )
    {
        SysFreeString( bstrNode );
    }
    if ( bstrServiceName != NULL )
    {
        SysFreeString( bstrServiceName );
    }
    if ( psmssh != NULL )
    {
        psmssh->Release();
    }

    // Reset the message on the status bar.
    pframeMain->SetMessageText( AFX_IDS_IDLEMESSAGE );
    pframeMain->UpdateWindow();

    return hr;

} //*** HrStopService()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\cluadmin.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      CluAdmin.cpp
//
//  Abstract:
//      Implementation of the CClusterAdminApp class.
//      Defines the class behaviors for the application.
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "CASvc.h"
#include "MainFrm.h"
#include "SplitFrm.h"
#include "ClusDoc.h"
#include "TreeView.h"
#include "OpenClus.h"
#include "ClusMru.h"
#include "ExcOper.h"
#include "Notify.h"
#include "TraceTag.h"
#include "TraceDlg.h"
#include "Barf.h"
#include "BarfDlg.h"
#include "About.h"
#include "CmdLine.h"
#include "VerInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

static LPCTSTR  g_pszProfileName = _T("Cluster Administrator");

#ifdef _DEBUG
CTraceTag   g_tagApp( _T("App"), _T("APP"), 0 );
CTraceTag   g_tagAppMenu( _T("Menu"), _T("APP"), 0 );
CTraceTag   g_tagAppNotify( _T("Notify"), _T("APP NOTIFY"), 0 );
CTraceTag   g_tagNotifyThread( _T("Notify"), _T("NOTIFY THREAD"), 0 );
CTraceTag   g_tagNotifyThreadReg( _T("Notify"), _T("NOTIFY THREAD (REG)"), 0 );
#endif


/////////////////////////////////////////////////////////////////////////////
// CClusterAdminApp
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// The one and only CClusterAdminApp object

CClusterAdminApp theApp;

IMPLEMENT_DYNAMIC( CClusterNotifyContext, CObject );
IMPLEMENT_DYNAMIC( CClusterAdminApp, CWinApp );

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CClusterAdminApp, CWinApp )
    //{{AFX_MSG_MAP(CClusterAdminApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    ON_COMMAND(ID_FILE_NEW_CLUSTER, OnFileNewCluster)
    ON_COMMAND(ID_WINDOW_CLOSE_ALL, OnWindowCloseAll)
    ON_UPDATE_COMMAND_UI(ID_WINDOW_CLOSE_ALL, OnUpdateWindowCloseAll)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
#ifdef _DEBUG
    ON_COMMAND(ID_DEBUG_TRACE_SETTINGS, OnTraceSettings)
    ON_COMMAND(ID_DEBUG_BARF_SETTINGS, OnBarfSettings)
    ON_COMMAND(ID_DEBUG_BARF_ALL, OnBarfAllSettings)
#endif // _DEBUG
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::CClusterAdminApp
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterAdminApp::CClusterAdminApp( void )
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
    m_pDocTemplate = NULL;
    m_hchangeNotifyPort = NULL;
    m_lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), SORT_DEFAULT );
    m_hOpenedCluster = NULL;
    m_nIdleCount = 0;

    m_punkClusCfgClient = NULL;

    FillMemory( m_rgiimg, sizeof( m_rgiimg ), 0xFF );

} //*** CClusterAdminApp::CClusterAdminApp

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::InitInstance
//
//  Routine Description:
//      Initialize this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Application successfully initialized.
//      FALSE       Failed to initialize the application.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::InitInstance( void )
{
    BOOL                        bSuccess    = FALSE;
    CMainFrame *                pMainFrame  = NULL;
    CCluAdminCommandLineInfo    cmdInfo;
    HRESULT                     hr;
    size_t                      cch;

    // CG: The following block was added by the Splash Screen component.
    {
//      CCluAdminCommandLineInfo cmdInfo;
//      ParseCommandLine(cmdInfo);
    }

    // Initialize OLE libraries
    if ( ! AfxOleInit() )
    {
        AfxMessageBox( IDP_OLE_INIT_FAILED );
        goto Cleanup;
    }

    if ( CoInitializeSecurity(
                    NULL,
                    -1,
                    NULL,
                    NULL,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,
                    EOAC_NONE,
                    0
                    ) != S_OK )
    {
        goto Cleanup;
    } // if:

    // Construct the help path.
    {
        TCHAR   szPath[ _MAX_PATH ];
        TCHAR   szDrive[ _MAX_PATH ];
        TCHAR   szDir[ _MAX_DIR ];
        size_t  cchPath;

        VERIFY( ::GetSystemWindowsDirectory( szPath, _MAX_PATH ) );
        cchPath = _tcslen( szPath );
        if ( szPath[ cchPath - 1 ] != _T('\\') )
        {
            szPath[ cchPath++ ] = _T('\\');
            szPath[ cchPath ] = _T('\0');
        } // if: no backslash on the end of the path
        hr = StringCchCopy( &szPath[ cchPath ], RTL_NUMBER_OF( szPath ) - cchPath, _T("Help\\") );
        ASSERT( SUCCEEDED( hr ) );
        _tsplitpath( szPath, szDrive, szDir, NULL, NULL );
        _tmakepath( szPath, szDrive, szDir, _T("cluadmin"), _T(".hlp") );
        free( (void *) m_pszHelpFilePath );
        BOOL bEnable;
        bEnable = AfxEnableMemoryTracking( FALSE );
        m_pszHelpFilePath = _tcsdup( szPath );
        AfxEnableMemoryTracking( bEnable );
    }  // Construct the help path

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    SetRegistryKey( IDS_REGKEY_COMPANY );           // Set the registry key for the program.

    //
    // Override the profile name because we don't want to localize it.
    //
    free( (void *) m_pszProfileName );
    cch = _tcslen( g_pszProfileName ) + 1;
    m_pszProfileName = (LPTSTR) malloc( cch * sizeof( *m_pszProfileName ) );
    if ( m_pszProfileName == NULL )
    {
        goto MemoryError;
    } // if: error allocating the profile name buffer
    hr = StringCchCopy( const_cast< LPTSTR >( m_pszProfileName ), cch, g_pszProfileName );
    ASSERT( SUCCEEDED( hr ) );

    InitAllTraceTags();                         // Initialize all trace tags.
    InitBarf();                                 // Initialize Basic Artificial Resource Failure system.

    // Load version information.
#if 0
    {
        CVersionInfo    verinfo;
        DWORD           dwValue;

        // Initialize the version info.
        verinfo.Init();

        // Get the Locale ID.
        if ( verinfo.BQueryValue( _T("\\VarFileInfo\\Translation"), dwValue ) )
        {
            m_lcid = MAKELCID( dwValue, SORT_DEFAULT );
        } // if: locale ID is available
    }  // Load version information
#else
    // Get the locale ID from the system to support MUI.
    m_lcid = GetUserDefaultLCID();
#endif

    // Initialize global CImageList
    InitGlobalImageList();

#ifdef _AFXDLL
    Enable3dControls();             // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif

    LoadStdProfileSettings( 0 );    // Load standard INI file options (including MRU)

    // Create cluster MRU.
    m_pRecentFileList = new CRecentClusterList( 0, _T("Recent Cluster List"), _T("Cluster%d"), 4 );
    if ( m_pRecentFileList == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    m_pRecentFileList->ReadList();

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    m_pDocTemplate = new CMultiDocTemplate(
                        IDR_CLUADMTYPE,
                        RUNTIME_CLASS( CClusterDoc ),
                        RUNTIME_CLASS( CSplitterFrame ), // custom MDI child frame
                        RUNTIME_CLASS( CClusterTreeView )
                        );
    if ( m_pDocTemplate == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    AddDocTemplate( m_pDocTemplate );

    // create main MDI Frame window
    pMainFrame = new CMainFrame;
    if ( pMainFrame == NULL )
    {
        goto MemoryError;
    } // if: error allocating memory
    ASSERT( pMainFrame != NULL );
    if ( ! pMainFrame->LoadFrame( IDR_MAINFRAME ) )
    {
        goto Cleanup;
    }  // if:  error loading the frame
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
//  cmdInfo.m_nShellCommand = CCommandLineInfo::FileNothing;    // Don't want to do a FileNew.
    ParseCommandLine( cmdInfo );

    // If no commands were specified on the command line, restore the desktop.
    if ( cmdInfo.m_nShellCommand == CCommandLineInfo::FileNothing )
    {
        pMainFrame->PostMessage( WM_CAM_RESTORE_DESKTOP, cmdInfo.m_bReconnect );
    } // if: no commands specified on the command line

    // Create the cluster notification thread.
    if ( ! BInitNotifyThread() )
    {
        goto Cleanup;
    } // if: error creating the cluster notification thread

    // The main window has been initialized, so show and update it.
    {
        WINDOWPLACEMENT wp;

        // Set the placement of the window.
        if ( ReadWindowPlacement( &wp, REGPARAM_SETTINGS, 0 ) )
        {
            pMainFrame->SetWindowPlacement( &wp );
            m_nCmdShow = wp.showCmd; // set the show command.
        }  // if:  read from profile

        // Activate and update the frame window.
        pMainFrame->ActivateFrame( m_nCmdShow );
        pMainFrame->UpdateWindow();
    }  // The main window has been initialized, so show and update it

    // Dispatch commands specified on the command line
    if ( ! ProcessShellCommand( cmdInfo ) )
    {
        goto Cleanup;
    } // if: error processing the command line

    TraceMenu( g_tagAppMenu, AfxGetMainWnd()->GetMenu(), _T("InitInstance menu: ") );

    bSuccess = TRUE;

Cleanup:
    if ( m_pMainWnd != pMainFrame )
    {
        delete pMainFrame;
    } // if: main frame windows allocated but not saved yet
    return bSuccess;

MemoryError:
    CNTException    nte(
                        ERROR_NOT_ENOUGH_MEMORY,
                        0,              // idsOperation
                        NULL,           // pszOperArg1
                        NULL,           // pszOperArg2
                        FALSE           // bAutoDelete
                        );
    nte.ReportError();
    nte.Delete();
    goto Cleanup;

} //*** CClusterAdminApp::InitInstance

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnIdle
//
//  Routine Description:
//      Process the command line or shell command.
//
//  Arguments:
//      LONG    [IN]    Number of time we have been called before the next
//                      message arrives in the queue
//
//  Return Value:
//      TRUE if more idle processing
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::OnIdle(IN LONG lCount)
{
    BOOL bMore = CWinApp::OnIdle(lCount);

    //
    // Since the MFC framework processing many messages lCount was never getting
    // higher than 1.  Since this work should not be done everytime we are idle
    // I added my own counter that determines when the work is done.
    //
    if ((++m_nIdleCount % 200) == 0)
    {
        POSITION        posDoc;                 // position in the documents collection
        POSITION        posDel;                 // position in the to be deleted list
        POSITION        posRemove;              // position in the to be deleted list to remove
        CClusterDoc *   pdoc;
        CClusterItem *  pitem;
        CWaitCursor     cw;

        posDoc = PdocTemplate()->GetFirstDocPosition();
        while (posDoc != NULL)
        {
            pdoc = (CClusterDoc *) PdocTemplate()->GetNextDoc(posDoc);
            ASSERT_VALID(pdoc);
            try
            {
                posDel = pdoc->LpciToBeDeleted().GetHeadPosition();
                while (posDel != NULL)
                {
                    posRemove = posDel;         // save posDel to posRemove since the next call is going to inc posDel
                    pitem = (CClusterItem *) pdoc->LpciToBeDeleted().GetNext(posDel);
                    ASSERT_VALID(pitem);
                    if ((pitem != NULL) && ( pitem->NReferenceCount() == 1))
                    {
                        pdoc->LpciToBeDeleted().RemoveAt(posRemove);    // the saved position posRemove
                    } // if: the list's refence is the only one
                } // while:  more items in the to be deleted list
            }
            catch (CException * pe)
            {
                pe->Delete();
            }  // catch:  CException
        }  // while:  more items in the list

        m_nIdleCount = 0;
        bMore = FALSE;      // don't want any more calls until some new messages are received
    } // if: every 200th time...

    return bMore;

} //*** CClusterAdminApp::OnIdle

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::ProcessShellCommand
//
//  Routine Description:
//      Process the command line or shell command.
//
//  Arguments:
//      rCmdInfo    [IN OUT] Command line info.
//
//  Return Value:
//      0           Error.
//      !0          No error.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::ProcessShellCommand(IN OUT CCluAdminCommandLineInfo & rCmdInfo)
{
    BOOL    bSuccess = TRUE;

    if (rCmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen)
    {
        POSITION    pos;

        try
        {
            pos = rCmdInfo.LstrClusters().GetHeadPosition();
            while (pos != NULL)
            {
                OpenDocumentFile(rCmdInfo.LstrClusters().GetNext(pos));
            }  // while:  more clusters in the list
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            bSuccess = FALSE;
        }  // catch:  CException
    }  // if:  we are opening clusters
    else
        bSuccess = CWinApp::ProcessShellCommand(rCmdInfo);

    return bSuccess;

} //*** CClusterAdminApp::ProcessShellCommand

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::ExitInstance
//
//  Routine Description:
//      Exit this instance of the application.
//
//  Arguments:
//      None.
//
//  Return Value:
//      0       No errors.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClusterAdminApp::ExitInstance(void)
{
    // Close the notification port.
    if (HchangeNotifyPort() != NULL)
    {
        ::CloseClusterNotifyPort(HchangeNotifyPort());
        m_hchangeNotifyPort = NULL;

        // Allow the notification port threads to clean themselves up.
        ::Sleep(100);
    }  // if:  notification port is open

    // Delete all the items in the notification key list.
    DeleteAllItemData( Cnkl() );
    Cnkl().RemoveAll();

    // Delete all the items in the notification list.
    m_cnlNotifications.RemoveAll();

    CleanupAllTraceTags();                          // Cleanup trace tags.
    CleanupBarf();                                  // Cleanup Basic Artificial Resource Failure system.

    // Release the ClusCfg client object.
    if ( m_punkClusCfgClient != NULL )
    {
        m_punkClusCfgClient->Release();
    }

    return CWinApp::ExitInstance();

} //*** CClusterAdminApp::ExitInstance

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::InitGlobalImageList
//
//  Routine Description:
//      Initialize the global image list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::InitGlobalImageList(void)
{
    // Create small image list.
    VERIFY(PilSmallImages()->Create(
                (int) 16,       // cx
                16,             // cy
                TRUE,           // bMask
                17,             // nInitial
                4               // nGrow
                ));

    PilSmallImages()->SetBkColor(::GetSysColor(COLOR_WINDOW));

    // Load the images into the small image list.
    LoadImageIntoList(PilSmallImages(), IDB_FOLDER_16, IMGLI_FOLDER);
    LoadImageIntoList(PilSmallImages(), IDB_CLUSTER_16, IMGLI_CLUSTER);
    LoadImageIntoList(PilSmallImages(), IDB_CLUSTER_UNKNOWN_16, IMGLI_CLUSTER_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_16, IMGLI_NODE);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_DOWN_16, IMGLI_NODE_DOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_PAUSED_16, IMGLI_NODE_PAUSED);
    LoadImageIntoList(PilSmallImages(), IDB_NODE_UNKNOWN_16, IMGLI_NODE_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_16, IMGLI_GROUP);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_PARTIAL_ONLINE_16, IMGLI_GROUP_PARTIALLY_ONLINE);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_PENDING_16, IMGLI_GROUP_PENDING);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_OFFLINE_16, IMGLI_GROUP_OFFLINE);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_FAILED_16, IMGLI_GROUP_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_GROUP_UNKNOWN_16, IMGLI_GROUP_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_RES_16, IMGLI_RES);
    LoadImageIntoList(PilSmallImages(), IDB_RES_OFFLINE_16, IMGLI_RES_OFFLINE);
    LoadImageIntoList(PilSmallImages(), IDB_RES_PENDING_16, IMGLI_RES_PENDING);
    LoadImageIntoList(PilSmallImages(), IDB_RES_FAILED_16, IMGLI_RES_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_RES_UNKNOWN_16, IMGLI_RES_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_RESTYPE_16, IMGLI_RESTYPE);
    LoadImageIntoList(PilSmallImages(), IDB_RESTYPE_UNKNOWN_16, IMGLI_RESTYPE_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_16, IMGLI_NETWORK);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_PARTITIONED_16, IMGLI_NETWORK_PARTITIONED);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_DOWN_16, IMGLI_NETWORK_DOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETWORK_UNKNOWN_16, IMGLI_NETWORK_UNKNOWN);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_16, IMGLI_NETIFACE);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_UNREACHABLE_16, IMGLI_NETIFACE_UNREACHABLE);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_FAILED_16, IMGLI_NETIFACE_FAILED);
    LoadImageIntoList(PilSmallImages(), IDB_NETIFACE_UNKNOWN_16, IMGLI_NETIFACE_UNKNOWN);

    // Create large image list.
    VERIFY(PilLargeImages()->Create(
                (int) 32,       // cx
                32,             // cy
                TRUE,           // bMask
                17,             // nInitial
                4               // nGrow
                ));
    PilLargeImages()->SetBkColor(::GetSysColor(COLOR_WINDOW));

    // Load the images into the large image list.
    LoadImageIntoList(PilLargeImages(), IDB_FOLDER_32, IMGLI_FOLDER);
    LoadImageIntoList(PilLargeImages(), IDB_CLUSTER_32, IMGLI_CLUSTER);
    LoadImageIntoList(PilLargeImages(), IDB_CLUSTER_UNKNOWN_32, IMGLI_CLUSTER_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_32, IMGLI_NODE);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_DOWN_32, IMGLI_NODE_DOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_PAUSED_32, IMGLI_NODE_PAUSED);
    LoadImageIntoList(PilLargeImages(), IDB_NODE_UNKNOWN_32, IMGLI_NODE_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_32, IMGLI_GROUP);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_PARTIAL_ONLINE_32, IMGLI_GROUP_PARTIALLY_ONLINE);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_PENDING_32, IMGLI_GROUP_PENDING);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_OFFLINE_32, IMGLI_GROUP_OFFLINE);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_FAILED_32, IMGLI_GROUP_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_GROUP_UNKNOWN_32, IMGLI_GROUP_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_RES_32, IMGLI_RES);
    LoadImageIntoList(PilLargeImages(), IDB_RES_OFFLINE_32, IMGLI_RES_OFFLINE);
    LoadImageIntoList(PilLargeImages(), IDB_RES_PENDING_32, IMGLI_RES_PENDING);
    LoadImageIntoList(PilLargeImages(), IDB_RES_FAILED_32, IMGLI_RES_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_RES_UNKNOWN_32, IMGLI_RES_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_RESTYPE_32, IMGLI_RESTYPE);
    LoadImageIntoList(PilLargeImages(), IDB_RESTYPE_UNKNOWN_32, IMGLI_RESTYPE_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_32, IMGLI_NETWORK);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_PARTITIONED_32, IMGLI_NETWORK_PARTITIONED);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_DOWN_32, IMGLI_NETWORK_DOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETWORK_UNKNOWN_32, IMGLI_NETWORK_UNKNOWN);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_32, IMGLI_NETIFACE);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_UNREACHABLE_32, IMGLI_NETIFACE_UNREACHABLE);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_FAILED_32, IMGLI_NETIFACE_FAILED);
    LoadImageIntoList(PilLargeImages(), IDB_NETIFACE_UNKNOWN_32, IMGLI_NETIFACE_UNKNOWN);

} //*** CClusterAdminApp::InitGlobalImageList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::LoadImageIntoList
//
//  Routine Description:
//      Load images into an image list.
//
//  Arguments:
//      pil         [IN OUT] Image list into which to load the image.
//      idbImage    [IN] Resource ID for the image bitmap.
//      imgli       [IN] Index into the index array.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::LoadImageIntoList(
    IN OUT CImageList * pil,
    IN ID               idbImage,
    IN UINT             imgli
    )
{
    CBitmap     bm;
    UINT        iimg;

    LoadImageIntoList(pil, idbImage, &iimg);
    if (m_rgiimg[imgli] == (UINT) -1)
        m_rgiimg[imgli] = iimg;
#ifdef DEBUG
    else
        ASSERT(m_rgiimg[imgli] == iimg);
#endif

} //*** CClusterAdminApp::LoadImageIntoList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  static
//  CClusterAdminApp::LoadImageIntoList
//
//  Routine Description:
//      Load images into an image list.
//
//  Arguments:
//      pil         [IN OUT] Image list into which to load the image.
//      idbImage    [IN] Resource ID for the image bitmap.
//      piimg       [OUT] Pointer to image index.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::LoadImageIntoList(
    IN OUT CImageList * pil,
    IN ID               idbImage,
    OUT UINT *          piimg
    )
{
    CBitmap     bm;
    UINT        iimg;
    COLORREF    crMaskColor = RGB(255,0,255);

    ASSERT(pil != NULL);
    ASSERT(idbImage != 0);

    if (piimg == NULL)
        piimg = &iimg;

    bm.LoadBitmap(idbImage);
    *piimg = pil->Add(&bm, crMaskColor);

} //*** CClusterAdminApp::LoadImageIntoList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnRestoreDesktop
//
//  Routine Description:
//      Handler for the WM_CAM_RESTORE_DESKTOP message.
//      Restores the desktop from the saved parameters.
//
//  Arguments:
//      wparam      TRUE = reconnect, FALSE, don't reconnect.
//      lparam      Unused.
//
//  Return Value:
//      0
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterAdminApp::OnRestoreDesktop(WPARAM wparam, LPARAM lparam)
{
    CString     strConnections;
    WPARAM      bReconnect = wparam;

    if (bReconnect)
    {
        // Read the connections the user had last time they exited.
        try
        {
            strConnections = GetProfileString(REGPARAM_CONNECTIONS, REGPARAM_CONNECTIONS);
        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
        }  // catch:  CException

        // If there were any connections, restore them.
        if (strConnections.GetLength() > 0)
        {
            LPTSTR          pszConnections;
            LPTSTR          pszConnection;
            TCHAR           szSep[]         = _T(",");

            ASSERT(m_pMainWnd != NULL);

            try
            {
                pszConnections = strConnections.GetBuffer(1);
                pszConnection = _tcstok(pszConnections, szSep);
                while (pszConnection != NULL)
                {
                    // Open a connection to this cluster.
                    OpenDocumentFile(pszConnection);

                    // Find the next connection.
                    pszConnection = _tcstok(NULL, szSep);
                }  // while:  more connections
            }  // try
            catch (CException * pe)
            {
                pe->ReportError();
                pe->Delete();
            } // catch:  CException
            strConnections.ReleaseBuffer();
        }  // if:  connections saved previously
        else
            bReconnect = FALSE;
    }  // if:  reconnect is desired

    if (!bReconnect)
    {
        CWaitCursor wc;
        Sleep(1500);
    }  // if:  not reconnecting

    // If there were no previous connections and we are not minimized, do a standard file open.
    if (!bReconnect && !AfxGetMainWnd()->IsIconic())
        OnFileOpen();

    // Otherwise, restore the desktop.

    return 0;

} //*** CClusterAdminApp::OnRestoreDesktop

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::SaveConnections
//
//  Routine Description:
//      Save the current connections so they can be restored later.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::SaveConnections(void)
{
    POSITION        pos;
    CClusterDoc *   pdoc;
    CString         strConnections;
    TCHAR           szSep[]         = _T("\0");

    pos = PdocTemplate()->GetFirstDocPosition();
    while (pos != NULL)
    {
        pdoc = (CClusterDoc *) PdocTemplate()->GetNextDoc(pos);
        ASSERT_VALID(pdoc);
        try
        {
            strConnections += szSep + pdoc->StrNode();
            szSep[0] = _T(',');  // Subsequent connections are preceded by a separator
        }
        catch (CException * pe)
        {
            pe->Delete();
        }  // catch:  CException

        // Save connection-specific settings as well.
        pdoc->SaveSettings();
    }  // while:  more items in the list
    WriteProfileString(REGPARAM_CONNECTIONS, REGPARAM_CONNECTIONS, strConnections);

} //*** CClusterAdminApp::SaveConnections

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnFileOpen
//
//  Routine Description:
//      Prompt the user for the name of a cluster or server and then open it.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnFileOpen(void)
{
    COpenClusterDialog  dlg;
    ID                  idDlgStatus;
    CDocument *         pdoc     = NULL;
    HCLUSTER            hCluster = NULL;
    DWORD               scLastError = 0;
    CString             strClusterName;

    do
    {
        idDlgStatus = (ID) dlg.DoModal();
        if ( idDlgStatus != IDOK )
        {
            break;
        }

        switch ( dlg.m_nAction )
        {
            case OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER:
                OnFileNewCluster();
                break;

            case OPEN_CLUSTER_DLG_ADD_NODES:
            case OPEN_CLUSTER_DLG_OPEN_CONNECTION:
                if ( hCluster != NULL )
                {
                    CloseCluster( hCluster );
                } // if: previous cluster opened
                hCluster = HOpenCluster( dlg.m_strName );
                if ( hCluster == NULL )
                {
                    scLastError = GetLastError();
                    if( scLastError != ERROR_SUCCESS )
                    {
                        //
                        // GPotts - 6/22/2001 - BUG 410912
                        //
                        // HOpenCluster could return NULL and last error = 0 if GetNodeClusterState
                        // returned either ClusterStateNotInstalled or ClusterStateNotConfigured. 
                        //
                        CNTException    nte( scLastError, IDS_OPEN_CLUSTER_ERROR, dlg.m_strName );
                        nte.ReportError();
                    } // if: last error != 0
                }  // if:  error opening the cluster
                else
                {
                    Trace( g_tagApp, _T("OnFileOpen() - Opening the cluster document on '%s'"), dlg.m_strName );
                    m_hOpenedCluster = hCluster;
                    pdoc = OpenDocumentFile( dlg.m_strName );
                    strClusterName = StrGetClusterName( hCluster );
                    m_hOpenedCluster = NULL;
                    hCluster = NULL;
                }  // else:  cluster opened successfully

                if ( ( pdoc != NULL ) && ( dlg.m_nAction == OPEN_CLUSTER_DLG_ADD_NODES ) )
                {
                    NewNodeWizard(
                        strClusterName,
                        FALSE           // fIgnoreErrors
                        );
                } // if: add a node to the cluster
                break;
        } // switch: dialog action
    }  while ( ( pdoc == NULL )
            && ( dlg.m_nAction != OPEN_CLUSTER_DLG_CREATE_NEW_CLUSTER ) );

    if ( hCluster != NULL )
    {
        CloseCluster( hCluster );
    }

} //*** CClusterAdminApp::OnFileOpen

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OpenDocumentFile
//
//  Routine Description:
//      Open a cluster.
//
//  Arguments:
//      lpszFileName    The name of the cluster or a server in that cluster.
//
//  Return Value:
//      NULL            Invalid cluster or server name.
//      pOpenDocument   The document instance for the open cluster.
//
//--
/////////////////////////////////////////////////////////////////////////////
CDocument * CClusterAdminApp::OpenDocumentFile(LPCTSTR lpszFileName)
{
    // find the highest confidence
    CDocTemplate::Confidence    bestMatch = CDocTemplate::noAttempt;
    CDocTemplate *              pBestTemplate = NULL;
    CDocument *                 pOpenDocument = NULL;

    {
        ASSERT_KINDOF(CDocTemplate, m_pDocTemplate);

        CDocTemplate::Confidence    match;
        ASSERT(pOpenDocument == NULL);
        match = m_pDocTemplate->MatchDocType(lpszFileName, pOpenDocument);
        if (match > bestMatch)
        {
            bestMatch = match;
            pBestTemplate = m_pDocTemplate;
        }
    }

    if (pOpenDocument != NULL)
    {
        POSITION    pos = pOpenDocument->GetFirstViewPosition();
        if (pos != NULL)
        {
            CView *     pView = pOpenDocument->GetNextView(pos); // get first one
            ASSERT_VALID(pView);
            CFrameWnd * pFrame = pView->GetParentFrame();
            if (pFrame != NULL)
                pFrame->ActivateFrame();
            else
                Trace(g_tagApp, _T("Error: Can not find a frame for document to activate."));
            CFrameWnd * pAppFrame;
            if (pFrame != (pAppFrame = (CFrameWnd*)AfxGetApp()->m_pMainWnd))
            {
                ASSERT_KINDOF(CFrameWnd, pAppFrame);
                pAppFrame->ActivateFrame();
            }
        }
        else
        {
            Trace(g_tagApp, _T("Error: Can not find a view for document to activate."));
        }
        return pOpenDocument;
    }

    if (pBestTemplate == NULL)
    {
        TCHAR szMsg[1024];
        AfxLoadString(AFX_IDP_FAILED_TO_OPEN_DOC, szMsg, sizeof(szMsg)/sizeof(szMsg[0]));
        AfxMessageBox(szMsg);
        return NULL;
    }

    return pBestTemplate->OpenDocumentFile(lpszFileName);

} //*** CClusterAdminApp::OpenDocumentFile

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::AddToRecentFileList
//
//  Routine Description:
//      Adds a file to the Most Recently Used file list.  Overridden to
//      prevent the cluster name from being fully qualified as a file.
//
//  Arguments:
//      lpszPathName    [IN] The path of the file.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::AddToRecentFileList(LPCTSTR lpszPathName)
{
    ASSERT_VALID(this);
    ASSERT(lpszPathName != NULL);
    ASSERT(AfxIsValidString(lpszPathName));

    if (m_pRecentFileList != NULL)
    {
        // Don't fully qualify the path name.
        m_pRecentFileList->Add(lpszPathName);
    }

} //*** CClusterAdminApp::AddToRecentFileList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnFileNewCluster
//
//  Routine Description:
//      Processes the ID_FILE_NEW_CLUSTER menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnFileNewCluster( void )
{
    HRESULT                         hr = S_OK;
    IClusCfgCreateClusterWizard *   piWiz;
    VARIANT_BOOL                    fCommitted = VARIANT_FALSE;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            CLSID_ClusCfgCreateClusterWizard,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IClusCfgCreateClusterWizard,
            (LPVOID *) &piWiz
            );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
        return;
    }  // if:  error getting the interface pointer

    // Display the wizard.
    hr = piWiz->ShowWizard( HandleToLong( AfxGetMainWnd()->m_hWnd ), &fCommitted );
    if ( FAILED( hr ) )
    {
        CNTException nte( hr, IDS_CREATE_CLUSTER_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
        nte.ReportError();
    } // if: error adding cluster nodes

    if ( fCommitted == VARIANT_TRUE )
    {
        BSTR bstrClusterName;
        hr = piWiz->get_ClusterName( &bstrClusterName );
        if ( FAILED( hr ) )
        {
            CNTException nte( hr, IDS_CREATE_CLUSTER_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
        else
        {
            if ( hr == S_OK )
            {
                HCLUSTER hCluster;

                ASSERT( bstrClusterName != NULL );

                // Open the cluster with the cluster name specified by the
                // wizard.  If it not successful, translate this to a NetBIOS
                // name in case that is more reliable.
                hCluster = OpenCluster( bstrClusterName );
                if ( hCluster == NULL )
                {
                    WCHAR   szClusterNetBIOSName[ MAX_COMPUTERNAME_LENGTH + 1 ];
                    DWORD   nSize = sizeof( szClusterNetBIOSName ) / sizeof( szClusterNetBIOSName[ 0 ] );

                    DnsHostnameToComputerName( bstrClusterName, szClusterNetBIOSName, &nSize );
                    SysFreeString( bstrClusterName );
                    bstrClusterName = SysAllocString( szClusterNetBIOSName );
                }
                else
                {
                    CloseCluster( hCluster );
                }
                OpenDocumentFile( bstrClusterName );
            } // if: retrieved cluster name successfully
            SysFreeString( bstrClusterName );
        } // else: retrieving cluster name didn't fail
    } // if: user didn't cancel the wizard

    piWiz->Release();

} //*** CClusterAdminApp::OnFileNewCluster

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnAppAbout
//
//  Routine Description:
//      Displays the about box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnAppAbout(void)
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();

} //*** CClusterAdminApp::OnAppAbout

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnUpdateWindowCloseAll
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_WINDOW_CLOSE_ALL
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnUpdateWindowCloseAll(CCmdUI * pCmdUI)
{
    pCmdUI->Enable(m_pDocTemplate->GetFirstDocPosition() != NULL);

} //*** CClusterAdminApp::OnUpdateWindowCloseAll

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnWindowCloseAll
//
//  Routine Description:
//      Processes the ID_WINDOW_CLOSE_ALL menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnWindowCloseAll(void)
{
    CloseAllDocuments(FALSE /*bEndSession*/);

} //*** CClusterAdminApp::OnWindowCloseAll

#ifdef _DEBUG
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnTraceSettings
//
//  Routine Description:
//      Displays the Trace Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnTraceSettings(void)
{
    CTraceDialog    dlgTraceSettings;
    dlgTraceSettings.DoModal();

} //*** CClusterAdminApp::OnTraceSettings

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnBarfSettings
//
//  Routine Description:
//      Displays the BARF Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnBarfSettings(void)
{
    DoBarfDialog();

} //*** CClusterAdminApp::OnBarfSettings

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnBarfAllSettings
//
//  Routine Description:
//      Displays the BARF All Settings dialog.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterAdminApp::OnBarfAllSettings(void)
{
    BarfAll();

} //*** CClusterAdminApp::OnBarfAllSettings

#endif // _DEBUG

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications.
//
//  Arguments:
//      wparam      WPARAM.
//      lparam      LPARAM
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterAdminApp::OnClusterNotify( WPARAM wparam, LPARAM lparam )
{
    CClusterNotify *    pnotify = NULL;
    BOOL                fHandled;
#if 0
    BOOL                fWindowRepaintsStopped = FALSE;
#endif

    ASSERT( m_cnlNotifications.IsEmpty() == FALSE );

    // Process notifications until the list is empty.
    while ( m_cnlNotifications.IsEmpty() == FALSE )
    {
#if 0
        // If the number of notifications waiting to be processed exceeds
        // a certain threshold, turn off window repaints on the main window.
        if (    ( fWindowRepaintsStopped == FALSE )
            &&  ( m_cnlNotifications.GetCount() > 5 )
            )
        {
            fWindowRepaintsStopped = AfxGetMainWnd()->LockWindowUpdate();
        } // if: too many notifications in the list
#endif

        // Get the next notification.
        pnotify = m_cnlNotifications.Remove();
        ASSERT( pnotify != NULL );
        ASSERT( pnotify->m_dwNotifyKey != 0 );
        if ( pnotify == NULL )
        {
            // This should NEVER happen.
            break;
        } // if: no notification returned

        fHandled = FALSE;

        //
        // If this is a normal notify message, send it to the object
        // that registered it.
        //
        if ( pnotify->m_emt == CClusterNotify::EMessageType::mtNotify )
        {

            // Send change notifications to the object that registered it.
            if ( pnotify->m_pcnk != NULL )
            {
                // Find the notification key in our list of keys.  If it is not
                // found, ignore it.  Otherwise, ask the object that registered
                // the notification to handle it.
                if ( Cnkl().Find( pnotify->m_pcnk ) != NULL )
                {
                    switch ( pnotify->m_pcnk->m_cnkt )
                    {
                        case cnktDoc:
                            ASSERT_VALID( pnotify->m_pcnk->m_pdoc );
                            pnotify->m_pcnk->m_pdoc->OnClusterNotify( pnotify );
                            pnotify = NULL;
                            break;

                        case cnktClusterItem:
                            ASSERT_VALID( pnotify->m_pcnk->m_pci );
                            ASSERT_VALID( pnotify->m_pcnk->m_pci->Pdoc() );
                            pnotify->m_pcnk->m_pci->OnClusterNotify( pnotify );
                            pnotify = NULL;
                            break;
                    }  // switch:  notification key type
                }  // if:  notification key found in the list
            } // if: non-NULL object pointer

            // Notification not handled.
            if ( fHandled == FALSE )
            {
                Trace( g_tagError, _T("*** Unhandled notification: key %08.8x, filter %x (%s) - '%s'"), pnotify->m_dwNotifyKey, pnotify->m_dwFilterType, PszNotificationName( pnotify->m_dwFilterType ), pnotify->m_strName );
            }
        } // if: normal notify message
        else if ( pnotify->m_emt == CClusterNotify::EMessageType::mtRefresh )
        {
            //
            // This is a refresh notify message.  Refresh all connections.
            //
            POSITION        pos;
            CClusterDoc *   pdoc;

            pos = PdocTemplate()->GetFirstDocPosition();
            while ( pos != NULL )
            {
                pdoc = (CClusterDoc *) PdocTemplate()->GetNextDoc(pos);
                ASSERT_VALID(pdoc);
                try
                {
                    pdoc->OnCmdRefresh();
                }
                catch ( CException * pe )
                {
                    pe->Delete();
                }  // catch:  CException
            } // while: more documents in the list
        } // else if: refresh notify message

        delete pnotify;
        pnotify = NULL;

    } // while: more notifications

#if 0
    // If we stopped window repaints, turn them on again.
    if ( fWindowRepaintsStopped )
    {
        AfxGetMainWnd()->UnlockWindowUpdate();
    } // if: we stopped window repaints
#endif

    delete pnotify;
    return 0;

} //*** CClusterAdminApp::OnClusterNotify

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::BInitNotifyThread
//
//  Routine Description:
//      Initialize the cluster notification thread.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Thread initialized successfully.
//      FALSE       Thread NOT initialized successfully.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterAdminApp::BInitNotifyThread(void)
{
    try
    {
        // Create the notification port.
        m_hchangeNotifyPort = ::CreateClusterNotifyPort(
                                    (HCHANGE) INVALID_HANDLE_VALUE,     // hChange
                                    (HCLUSTER) INVALID_HANDLE_VALUE,    // hCluster
                                    0,                                  // dwFilter
                                    0                                   // dwNotifyKey
                                    );
        if (HchangeNotifyPort() == NULL)
        {
            ThrowStaticException(GetLastError());
        }

        // Construct the context object.
        Pcnctx()->m_hchangeNotifyPort = HchangeNotifyPort();
        Pcnctx()->m_hwndFrame = m_pMainWnd->m_hWnd;
        Pcnctx()->m_pcnlList = &Cnl();

        // Begin the thread.
        m_wtNotifyThread = AfxBeginThread(NotifyThreadProc, Pcnctx());
        if (WtNotifyThread() == NULL)
        {
            ThrowStaticException(GetLastError());
        }
    }  // try
    catch (CException * pe)
    {
        // Close the notify port.
        if (HchangeNotifyPort() != NULL)
        {
            ::CloseClusterNotifyPort(HchangeNotifyPort());
            m_hchangeNotifyPort = NULL;
        }  // if:  notify port is open

        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return TRUE;

} //*** CClusterAdminApp::BInitNotifyThread

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterAdminApp::NotifyThreadProc (static)
//
//  Routine Description:
//      Notification thread procedure.
//
//  Arguments:
//      pParam      [IN OUT] Thread procedure parameter -- a notification
//                    context object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
UINT AFX_CDECL CClusterAdminApp::NotifyThreadProc(LPVOID pParam)
{
    DWORD                           dwStatus;
    WCHAR*                          pwszName;
    DWORD                           cchName;
    DWORD                           cchBuffer;
    DWORD_PTR                       dwNotifyKey;
    DWORD                           dwFilterType;
    DWORD                           nTimeout;
    BOOL                            fQueueIsFull = FALSE;
    CClusterNotify *                pnotify = NULL;
    CClusterNotifyContext *         pnctx   = (CClusterNotifyContext *) pParam;
    CClusterNotify::EMessageType    emt = CClusterNotify::EMessageType::mtNotify;

    ASSERT( pParam != NULL );
    ASSERT_KINDOF( CClusterNotifyContext, pnctx );
    ASSERT( pnctx->m_hchangeNotifyPort != NULL );
    ASSERT( pnctx->m_hwndFrame != NULL );

    //
    // Allocate a buffer that should be large enough for most notifications.
    // If it isn't, it will be reallocated in the loop below.
    //
    cchBuffer = 1024;
    pwszName = new WCHAR[ 1024 ];
    ASSERT( pwszName != NULL );
    if ( pwszName == NULL )
    {
        AfxThrowMemoryException();
    } // if: memory exception

    //
    // Default to waiting an infinite amount of time for the next notification
    // to be delivered.  We will change this if we ever get too many
    // notifications in the queue.
    //
    nTimeout = INFINITE;

    for (;;)
    {
        //
        // Get the next notification.
        // Wait for one if there isn't one waiting for us.
        //
        cchName = cchBuffer;
        dwStatus = GetClusterNotify(
                        pnctx->m_hchangeNotifyPort,
                        &dwNotifyKey,
                        &dwFilterType,
                        pwszName,
                        &cchName,
                        nTimeout
                        );
                        
        if ( dwStatus == ERROR_INVALID_HANDLE )
        {
            //
            // The notification port was closed.

            break;
        } // if: invalid handle error

        if ( dwStatus == ERROR_MORE_DATA )
        {
            //
            // The name buffer was too small.
            // Allocate a new one.
            //

            cchName++;              // Add one for NULL
            
            ASSERT( cchName > cchBuffer ); 
            
            cchBuffer = cchName;

            // Reallocate the name buffer.
            delete [] pwszName;
            pwszName = new WCHAR[ cchBuffer ];
            ASSERT( pwszName != NULL );
            if ( pwszName == NULL )
            {
                AfxThrowMemoryException();
            } // if: memory exception

            // Loop around and try again.
            continue;
        } // if: buffer too small

        if ( dwStatus == WAIT_TIMEOUT )
        {
            //
            // The call to GetClusterNotify timed out.  This will only happen
            // if we detected that there were too many notifications in the
            // queue and stopped saving them.  Send a refresh message to the
            // main window and reset the timeout to INFINITE so that
            // we will wait until there is another event to get.
            //
            nTimeout = INFINITE;
            emt = CClusterNotify::EMessageType::mtRefresh;
            fQueueIsFull = FALSE;
        } // if: GetClusterNotify timed out
        else if ( dwStatus != ERROR_SUCCESS )
        {
            // Some other failure occurred getting the notification.
            TraceError(_T("CClusterAdminApp::NotifyThreadProc() %s"), dwStatus);
            continue;
        }  // else if: error getting notification

        //
        // If we have exceeded the max queue size threshold, don't send this
        // notification to the main UI thread.  Instead change the timeout
        // value so that we will just keep getting notifications off the
        // queue until there aren't anymore.  Once that has happened,
        // we will send a refresh event to the main UI thread and it will
        // refresh all the connections.
        //
        if (    ( emt == CClusterNotify::EMessageType::mtNotify )
            &&  ( pnctx->m_pcnlList->GetCount() > 500 )
            )
        {
            nTimeout = 2000;
            fQueueIsFull = TRUE;
        } // if: queue is full

        if ( fQueueIsFull == FALSE )
        {
            //
            // Package the notification info up to send to the main UI thread.
            //

            try
            {
                // Allocate the notification object and initialize it.
                pnotify = new CClusterNotify( emt, dwNotifyKey, dwFilterType, pwszName );
                ASSERT( pnotify != NULL );
                if ( pnotify == NULL )
                {
                    // Failed to allocate, so ignore this notification.
                    continue;
                } // if: error allocating and initialize the notify object

#ifdef _DEBUG
                if ( emt == CClusterNotify::EMessageType::mtNotify )
                {
                    TCHAR *     pszTracePrefix;
                    CTraceTag * ptag;

                    pszTracePrefix = _T("");
                    if (   ( dwNotifyKey == NULL )
                        || ( dwNotifyKey == 0xfeeefeee )
                        || ( dwNotifyKey == 0xbaadf00d ) )
                    {
                        ptag = &g_tagError;
                        pszTracePrefix = _T("*** NOTIFY THREAD ");
                    }  // if:  bad notification key
                    else if ( dwFilterType & (CLUSTER_CHANGE_REGISTRY_NAME | CLUSTER_CHANGE_REGISTRY_ATTRIBUTES | CLUSTER_CHANGE_REGISTRY_VALUE) )
                    {
                        ptag = &g_tagNotifyThreadReg;
                    }
                    else
                    {
                        ptag = &g_tagNotifyThread;
                    }
                    Trace( *ptag, _T("%sNotification - key %08.8x, filter %x (%s), %s"), pszTracePrefix, dwNotifyKey, dwFilterType, PszNotificationName(dwFilterType), pnotify->m_strName );
                } // if: normal notification
#endif

                // Add the item to the list.
                // The pointer is NULL upon return.
                pnctx->m_pcnlList->Add( &pnotify );

                // Release the list lock.

                // Post a message to the main window to tell the main thread
                // there is new information in the list.
                if ( ! ::PostMessage( pnctx->m_hwndFrame, WM_CAM_CLUSTER_NOTIFY, NULL, NULL ) )
                {
                } // if: PostMessage failed

                emt = CClusterNotify::EMessageType::mtNotify;
                fQueueIsFull = FALSE;

            } // try
            catch ( ... )
            {
                if ( pnotify != NULL )
                {
                    delete pnotify;
                    pnotify = NULL;
                } // if: notification record allocated
            } // catch: any exception
        } // if: notification queue is not full
    }  // forever: get notifications until the notification port is closed

    delete [] pwszName;
    delete pnotify;

    return 0;

} //*** CClusterAdminApp::NotifyThreadProc


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  BCreateFont
//
//  Routine Description:
//      Create a font.
//
//  Arguments:
//      rfont       [OUT] Font to create.
//      nPoints     [IN] Point size.
//      bBold       [IN] Flag specifying whether font is bold or not.
//
//  Return Value:
//      TRUE        Font created successfully.
//      FALSE       Error creating font.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL BCreateFont(OUT CFont & rfont, IN int nPoints, IN BOOL bBold)
{
    return rfont.CreateFont(
                    -nPoints,                           // nHeight
                    0,                                  // nWidth
                    0,                                  // nEscapement
                    0,                                  // nOrientation
                    (bBold ? FW_BOLD : FW_DONTCARE),    // nWeight
                    FALSE,                              // bItalic
                    FALSE,                              // bUnderline
                    FALSE,                              // cStrikeout
                    ANSI_CHARSET,                       // nCharSet
                    OUT_DEFAULT_PRECIS,                 // nOutPrecision
                    CLIP_DEFAULT_PRECIS,                // nClipPrecision
                    DEFAULT_QUALITY,                    // nQuality
                    DEFAULT_PITCH | FF_DONTCARE,        // nPitchAndFamily
                    _T("MS Shell Dlg")                  // lpszFaceName
                    );

} //*** BCreateFont

/////////////////////////////////////////////////////////////////////////////
//++
//
//  NewNodeWizard
//
//  Routine Description:
//      Invoke the Add Nodes to Cluster Wizard.
//
//  Arguments:
//      pcszName        -- Name of cluster to add nodes to.
//      fIgnoreErrors   -- TRUE = don't display error messages.
//                          Defaults to FALSE.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void NewNodeWizard(
    LPCTSTR pcszName,
    BOOL    fIgnoreErrors   // = FALSE
    )
{
    HRESULT                     hr = S_OK;
    IClusCfgAddNodesWizard *    piWiz = NULL;
    BSTR                        bstrConnectName = NULL;
    VARIANT_BOOL                fCommitted = VARIANT_FALSE;

    // Get an interface pointer for the wizard.
    hr = CoCreateInstance(
            CLSID_ClusCfgAddNodesWizard,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IClusCfgAddNodesWizard,
            (void **) &piWiz
            );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_CREATE_CLUSCFGWIZ_OBJ_ERROR, NULL, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
        return;
    } // if: error getting the interface pointer

    // Specify the name of the cluster we are going to add a node to.
    bstrConnectName = SysAllocString( pcszName );
    if ( bstrConnectName == NULL )
    {
        AfxThrowMemoryException();
    }
    hr = piWiz->put_ClusterName( bstrConnectName );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
    } // if: error setting the cluster name

    // Display the wizard.
    hr = piWiz->ShowWizard( HandleToLong( AfxGetMainWnd()->m_hWnd ), &fCommitted );
    if ( FAILED( hr ) )
    {
        if ( ! fIgnoreErrors )
        {
            CNTException nte( hr, IDS_ADD_NODES_TO_CLUSTER_ERROR, bstrConnectName, NULL, FALSE /*bAutoDelete*/ );
            nte.ReportError();
        }
    } // if: error adding cluster nodes

    SysFreeString( bstrConnectName );
    piWiz->Release();

}  //*** NewNodeWizard


/////////////////////////////////////////////////////////////////////////////
//++
//
//  GetClusterInformation
//
//  Routine Description:
//      Given a cluster handle, retrieve the cluster's hostname label and
//      version information.
//
//  Arguments:
//      hClusterIn
//          Handle to the cluster; must not be null.
//
//      rstrNameOut
//          On return, the cluster's hostname label.
//
//      pcviOut
//          Address for cluster's version info on return; can be null if 
//          the caller doesn't care.
//
//  Return Value:
//      None.
//
//  Remarks:
//      Throws an exception on failure.
//
//--
/////////////////////////////////////////////////////////////////////////////
void GetClusterInformation( HCLUSTER hClusterIn, CString& rstrNameOut, PCLUSTERVERSIONINFO pcviOut )
{
    DWORD       cchName = MAX_CLUSTERNAME_LENGTH; // Just a guess for the first try.
    DWORD       cchNameStash = cchName;
    CString     strClusterName;
    DWORD       scClusterInfo = ERROR_SUCCESS;

    ASSERT( hClusterIn != NULL );
    if ( pcviOut != NULL )
    {
        pcviOut->dwVersionInfoSize = sizeof( *pcviOut );
    }

    scClusterInfo = GetClusterInformation( hClusterIn, strClusterName.GetBuffer( cchName ), &cchName, pcviOut );
    strClusterName.ReleaseBuffer( cchNameStash );
    if ( scClusterInfo == ERROR_MORE_DATA )
    {
        cchNameStash = ++cchName; // KLUDGE: ++ because GetClusterInformation is STOOPID.
        scClusterInfo = GetClusterInformation( hClusterIn, strClusterName.GetBuffer( cchName ), &cchName, pcviOut );
        strClusterName.ReleaseBuffer( cchNameStash );
    }

    if ( scClusterInfo != ERROR_SUCCESS )
    {
        ThrowStaticException( scClusterInfo );
    }

    rstrNameOut = strClusterName;

} //*** GetClusterInformation

/////////////////////////////////////////////////////////////////////////////
//++
//
//  StrGetClusterName
//
//  Routine Description:
//      Given a cluster handle, retrieve the cluster's FQDN if possible,
//      or its IP address if not.
//
//  Arguments:
//      hClusterIn
//          Handle to the cluster; must not be null.
//
//  Return Value:
//      The cluster's FQDN or its IP address.
//
//  Remarks:
//      Throws an exception on failure.  To retrieve just the cluster's
//      hostname label, use GetClusterInformation
//
//--
/////////////////////////////////////////////////////////////////////////////
CString StrGetClusterName( HCLUSTER hClusterIn )
{
    CString strClusterName;
    DWORD   cchName = DNS_MAX_NAME_LENGTH;
    DWORD   sc = ERROR_SUCCESS;

    ASSERT( hClusterIn != NULL );

    //
    //  First, try to get the FQDN.
    //
    {
        DWORD cbFQDN = cchName * sizeof( TCHAR );
        DWORD cbBytesRequired = 0;
        sc = ClusterControl(
                hClusterIn,
                NULL,
                CLUSCTL_CLUSTER_GET_FQDN,
                NULL,
                NULL,
                strClusterName.GetBuffer( cchName ),
                cbFQDN,
                &cbBytesRequired
                );
        strClusterName.ReleaseBuffer( cchName );
        if ( sc == ERROR_MORE_DATA )
        {
            cchName = ( cbBytesRequired / sizeof( TCHAR ) ) + 1;
            cbFQDN = cchName * sizeof( TCHAR );
            sc = ClusterControl(
                    hClusterIn,
                    NULL,
                    CLUSCTL_CLUSTER_GET_FQDN,
                    NULL,
                    NULL,
                    strClusterName.GetBuffer( cchName ),
                    cbFQDN,
                    &cbBytesRequired
                    );
            strClusterName.ReleaseBuffer( cchName );
        }
    }

    //
    //  If ClusterControl returned ERROR_INVALID_FUNCTION, it's probably Win2k, so
    //  make do with just the hostname label; if it failed for some other reason,
    //  try to get the IP address.
    //
    if ( sc == ERROR_INVALID_FUNCTION )
    {
        GetClusterInformation( hClusterIn, strClusterName, NULL );
    }
    else if ( sc != ERROR_SUCCESS )
    {
        HRESOURCE hIPResource = NULL;
        CClusPropList           cpl;
        CLUSPROP_BUFFER_HELPER  cpbh;

        sc = ResUtilGetCoreClusterResources( hClusterIn, NULL, &hIPResource, NULL );
        if ( sc != ERROR_SUCCESS )
            ThrowStaticException( sc );

        sc = cpl.ScGetResourceProperties( hIPResource, CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES );
        if ( sc != ERROR_SUCCESS )
            ThrowStaticException( sc );

        sc = cpl.ScMoveToPropertyByName( L"Address" );
        if ( sc != ERROR_SUCCESS )
            ThrowStaticException( sc );

        cpbh = cpl.CbhCurrentValue();
        ASSERT( cpbh.pSyntax->dw == CLUSPROP_SYNTAX_LIST_VALUE_SZ );

        strClusterName = cpbh.pStringValue->sz;
    }

    return strClusterName;

} //*** StrGetClusterName
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusitem.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c ) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusItem.cpp
//
//  Description:
//      Implementation of the CClusterItem class.
//
//  Maintained By:
//      David Potter (davidp )   May 6, 1996
//
//  Revision History:
//
//  Modified to fix bugs associated with open/close state of m_hkey.
//  m_hkey will be closed upon destruction of CClusterItem.
//  Roderick Sharper March 23, 1997.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CluAdmin.h"
#include "ConstDef.h"
#include "ClusItem.h"
#include "ClusDoc.h"
#include "ExcOper.h"
#include "TraceTag.h"
#include "TreeItem.inl"
#include "PropList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
CTraceTag g_tagClusItemCreate( _T("Create"), _T("CLUSTER ITEM CREATE"), 0 );
CTraceTag g_tagClusItemDelete( _T("Delete"), _T("CLUSTER ITEM DELETE"), 0 );
CTraceTag g_tagClusItemNotify( _T("Notify"), _T("CLUSTER ITEM NOTIFY"), 0 );
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterItemList
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItemList::PciFromName
//
//  Routine Description:
//      Find a cluster item in the list by its name.
//
//  Arguments:
//      pszName     [IN] Name of item to look for.
//      ppos        [OUT] Position of the item in the list.
//
//  Return Value:
//      pci         Cluster item corresponding the the specified name.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem * CClusterItemList::PciFromName(
    IN LPCTSTR      pszName,
    OUT POSITION *  ppos    // = NULL
   )
{
    POSITION        posPci;
    POSITION        posCurPci;
    CClusterItem *  pci = NULL;

    ASSERT( pszName != NULL );

    posPci = GetHeadPosition();
    while ( posPci != NULL )
    {
        posCurPci = posPci;
        pci = GetNext( posPci );
        ASSERT_VALID( pci );

        if ( pci->StrName().CompareNoCase( pszName ) == 0 )
        {
            if ( ppos != NULL )
            {
                *ppos = posCurPci;
            } // if
            break;
        }  // if:  found a match

        pci = NULL;
    }  // while:  more resources in the list

    return pci;

}  //*** CClusterItemList::PciFromName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItemList::RemoveAll
//
//  Routine Description:
//      Remove all items from the list, decrementing the reference count
//      on each one first.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Note:
//      This routine is not virtual, so calls to the base class will
//      not go through this routine.  Also, it does not call the base
//      class method.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef NEVER
void CClusterItemList::RemoveAll( void )
{
    ASSERT_VALID( this );

    // destroy elements
    CNode * pNode;
    for ( pNode = m_pNodeHead ; pNode != NULL ; pNode = pNode->pNext )
    {
//      ((CClusterItem *) pNode->data)->Release();
        DestructElements( (CClusterItem**) &pNode->data, 1 );
    }  // for:  each node in the list

    // Call the base class method.
    CObList::RemoveAll();

}  //*** CClusterItemList::RemoveAll
#endif


//***************************************************************************


/////////////////////////////////////////////////////////////////////////////
// CClusterItem
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE( CClusterItem, CBaseCmdTarget )

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP( CClusterItem, CBaseCmdTarget )
    //{{AFX_MSG_MAP(CClusterItem)
    ON_UPDATE_COMMAND_UI(ID_FILE_RENAME, OnUpdateRename)
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_FILE_PROPERTIES, OnCmdProperties)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CClusterItem
//
//  Routine Description:
//      Default constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::CClusterItem( void )
{
    CommonConstruct();

}  //*** CClusterItem::CClusterItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CClusterItem
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pstrName        [IN] Name of the item.
//      idsType         [IN] Type ID of the item.
//      pstrDescription [IN] Description of the item.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::CClusterItem(
    IN const CString *  pstrName,
    IN IDS              idsType,
    IN const CString *  pstrDescription
    )
{
    CommonConstruct();

    if ( pstrName != NULL )
    {
        m_strName = *pstrName;
    } // if

    if ( idsType == 0 )
    {
        idsType = IDS_ITEMTYPE_CONTAINER;
    } // if
    m_idsType = idsType;
    m_strType.LoadString( IdsType() );

    if ( pstrDescription != NULL )
    {
        m_strDescription = *pstrDescription;
    } // if

    Trace( g_tagClusItemCreate, _T("CClusterItem() - Creating '%s' (%s )"), m_strName, m_strType );

}  //*** CClusterItem::CClusterItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::CommonConstruct
//
//  Routine Description:
//      Common construction.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::CommonConstruct( void )
{
    m_hkey = NULL;
    m_idsType = IDS_ITEMTYPE_CONTAINER;
    m_strType.LoadString( IDS_ITEMTYPE_CONTAINER );
    m_iimgObjectType = 0;
    m_iimgState = GetClusterAdminApp()->Iimg( IMGLI_FOLDER );
    m_pdoc = NULL;
    m_idmPopupMenu = 0;
    m_bDocObj = TRUE;
    m_bChanged = FALSE;
    m_bReadOnly = FALSE;
    m_pcnk = NULL;

}  //*** CClusterItem::CommonConstruct

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::~CClusterItem
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterItem::~CClusterItem( void )
{
    Trace( g_tagClusItemDelete, _T("~CClusterItem() - Deleting cluster item '%s'"), StrName() );

    // Empty the lists.
    DeleteAllItemData( LptiBackPointers() );
    DeleteAllItemData( LpliBackPointers() );
    LptiBackPointers().RemoveAll();
    LpliBackPointers().RemoveAll();

    // Close the registry key.
    if ( Hkey() != NULL )
    {
        ClusterRegCloseKey( Hkey() );
        m_hkey = NULL;
    } // if

    // Remove the notification key and delete it.
    if ( BDocObj() )
    {
        POSITION    pos;

        pos = GetClusterAdminApp()->Cnkl().Find( m_pcnk );
        if ( pos != NULL )
        {
            GetClusterAdminApp()->Cnkl().RemoveAt( pos );
        } // if
        Trace( g_tagClusItemNotify, _T("~CClusterItem() - Deleting notification key (%08.8x ) for '%s'"), m_pcnk, StrName() );
        delete m_pcnk;
        m_pcnk = NULL;
    }  // if:  object resides in the document

    Trace( g_tagClusItemDelete, _T("~CClusterItem() - Done deleting cluster item '%s'"), StrName() );

}  //*** CClusterItem::~CClusterItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::Delete
//
//  Routine Description:
//      Delete the item.  If the item still has references, add it to the
//      document's pending delete list.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::Delete( void )
{
    // Add a reference so that we don't delete ourselves while
    // still doing cleanup.
    AddRef();

    // Cleanup this object.
    Cleanup();

    // Remove the item from all lists and views.
    CClusterItem::RemoveItem();

    // If there are still references to this object, add it to the delete
    // pending list.  Check for greater than 1 because we added a reference
    // at the beginning of this method.
    if ( ( Pdoc() != NULL ) && ( NReferenceCount() > 1 ) )
    {
        if ( Pdoc()->LpciToBeDeleted().Find( this ) == NULL )
        {
            Pdoc()->LpciToBeDeleted().AddTail( this );
        } // if
    }  // if:  object still has references to it

    // Release the reference we added at the beginning.  This will
    // cause the object to be deleted if we were the last reference.
    Release();

}  //*** CClusterItem::Delete

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::Init
//
//  Routine Description:
//      Initialize the item.
//
//  Arguments:
//      pdoc        [IN OUT] Document to which this item belongs.
//      lpszName    [IN] Name of the item.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CNotifyKey::new() or
//      CNotifyKeyList::AddTail().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::Init( IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName )
{
    ASSERT_VALID( pdoc );
    ASSERT( lpszName != NULL );

    // Save parameters.
    m_pdoc = pdoc;
    m_strName = lpszName;

    Trace( g_tagClusItemCreate, _T("Init() - Initializing '%s' (%s )"), m_strName, m_strType );

    // Find the notification key for this item in the document's list.
    // If one is not found, allocate one.
    if ( BDocObj() )
    {
        POSITION            pos;
        CClusterNotifyKey * pcnk    = NULL;

        pos = GetClusterAdminApp()->Cnkl().GetHeadPosition();
        while ( pos != NULL )
        {
            pcnk = GetClusterAdminApp()->Cnkl().GetNext( pos );
            if ( ( pcnk->m_cnkt == cnktClusterItem )
              && ( pcnk->m_pci == this )
               )
                break;
            pcnk = NULL;
        }  // while:  more items in the list

        // If a key was not found, allocate a new one.
        if ( pcnk == NULL )
        {
            pcnk = new CClusterNotifyKey( this, lpszName );
            if ( pcnk == NULL )
            {
                ThrowStaticException( GetLastError() );
            } // if: error allocating the notify key
            try
            {
                GetClusterAdminApp()->Cnkl().AddTail( pcnk );
                Trace( g_tagClusItemNotify, _T("Init() - Creating notification key (%08.8x ) for '%s'"), pcnk, StrName() );
            }  // try
            catch ( ... )
            {
                delete pcnk;
                throw;
            }  // catch:  anything
        }  // if:  key wasn't found

        m_pcnk = pcnk;
    }  // if:  object resides in the document

}  //*** CClusterItem::Init

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::PlstrExtensions
//
//  Routine Description:
//      Return the list of admin extensions.
//
//  Arguments:
//      None.
//
//  Return Value:
//      plstr       List of extensions.
//      NULL        No extension associated with this object.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
const CStringList * CClusterItem::PlstrExtensions( void ) const
{
    return NULL;

}  //*** CClusterItem::PlstrExtensions

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveItem
//
//  Routine Description:
//      Remove the item from all lists and views.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveItem( void )
{
    // Remove the item from each tree item.
    {
        POSITION    posPti;
        CTreeItem * pti;

        posPti = LptiBackPointers().GetHeadPosition();
        while ( posPti != NULL )
        {
            pti = LptiBackPointers().GetNext( posPti );
            ASSERT_VALID( pti );
            ASSERT_VALID( pti->PtiParent() );
            Trace( g_tagClusItemDelete, _T("RemoveItem() - Deleting tree item backptr from '%s' in '%s' - %d left"), StrName(), pti->PtiParent()->StrName(), LptiBackPointers().GetCount() - 1 );
            pti->RemoveItem();
        }  // while:  more items in the list
    }  // Remove the item from each tree item

    // Remove the item from each list item.
    {
        POSITION    posPli;
        CListItem * pli;

        posPli = LpliBackPointers().GetHeadPosition();
        while ( posPli != NULL )
        {
            pli = LpliBackPointers().GetNext( posPli );
            ASSERT_VALID( pli );
            ASSERT_VALID( pli->PtiParent() );
            Trace( g_tagClusItemDelete, _T("RemoveItem() - Deleting list item backptr from '%s' in '%s' - %d left"), StrName(), pli->PtiParent()->StrName(), LpliBackPointers().GetCount() - 1 );
            pli->PtiParent()->RemoveChild( pli->Pci() );
        }  // while:  more items in the list
    }  // Remove the item from each tree item

}  //*** CClusterItem::RemoveItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteItem
//
//  Routine Description:
//      Write the item parameters to the cluster database.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteItem( void )
{
}  //*** CClusterItem::WriteItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwParseProperties
//
//  Routine Description:
//      Parse the properties of the resource.  This is in a separate function
//      from BInit so that the optimizer can do a better job.
//
//  Arguments:
//      rcpl            [IN] Cluster property list to parse.
//
//  Return Value:
//      ERROR_SUCCESS   Properties were parsed successfully.
//
//  Exceptions Thrown:
//      Any exceptions from CString::operator=().
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwParseProperties( IN const CClusPropList & rcpl )
{
    DWORD                           cProps;
    DWORD                           cprop;
    DWORD                           cbProps;
    const CObjectProperty *         pprop;
    CLUSPROP_BUFFER_HELPER          props;
    CLUSPROP_PROPERTY_NAME const *  pName;

    ASSERT( rcpl.PbPropList() != NULL );

    props.pb = rcpl.PbPropList();
    cbProps = static_cast< DWORD >( rcpl.CbPropList() );

    // Loop through each property.
    for ( cProps = *(props.pdw++ ) ; cProps > 0 ; cProps-- )
    {
        pName = props.pName;
        ASSERT( pName->Syntax.dw == CLUSPROP_SYNTAX_NAME );
        props.pb += sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength );

        // Decrement the counter by the size of the name.
        ASSERT( cbProps > sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength ) );
        cbProps -= sizeof( *pName ) + ALIGN_CLUSPROP( pName->cbLength );

        ASSERT( cbProps > sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength ) );

        // Parse known properties.
        for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
        {
            if ( ClRtlStrNICmp( pName->sz, pprop->m_pwszName, pName->cbLength / sizeof( WCHAR ) ) == 0 )
            {
                ASSERT( props.pSyntax->wFormat == pprop->m_propFormat );
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                        ASSERT( ( props.pValue->cbLength == ( wcslen( props.pStringValue->sz ) + 1 ) * sizeof( WCHAR ) )
                             || ( (props.pValue->cbLength == 0 ) && ( props.pStringValue->sz[ 0 ] == L'\0' ) ) );
                        *pprop->m_valuePrev.pstr = props.pStringValue->sz;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                    case CLUSPROP_FORMAT_LONG:
                        ASSERT( props.pValue->cbLength == sizeof( DWORD ) );
                        *pprop->m_valuePrev.pdw = props.pDwordValue->dw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        *pprop->m_valuePrev.ppb = props.pBinaryValue->rgb;
                        *pprop->m_valuePrev.pcb = props.pBinaryValue->cbLength;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                }  // switch:  property format

                // Exit the loop since we found the parameter.
                break;
            }  // if:  found a match
        }  // for:  each property

        // If the property wasn't known, ask the derived class to parse it.
        if ( cprop == 0 )
        {
            DWORD       dwStatus;

            dwStatus = DwParseUnknownProperty( pName->sz, props, cbProps );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  property not parsed

        // Advance the buffer pointer past the value in the value list.
        while ( ( props.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK )
             && ( cbProps > 0 ) )
        {
            ASSERT( cbProps > sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength ) );
            cbProps -= sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength );
            props.pb += sizeof( *props.pValue ) + ALIGN_CLUSPROP( props.pValue->cbLength );
        }  // while:  more values in the list

        // Advance the buffer pointer past the value list endmark.
        ASSERT( cbProps >= sizeof( *props.pSyntax ) );
        cbProps -= sizeof( *props.pSyntax );
        props.pb += sizeof( *props.pSyntax ); // endmark
    }  // for:  each property

    return ERROR_SUCCESS;

}  //*** CClusterItem::DwParseProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::SetCommonProperties
//
//  Routine Description:
//      Set the common properties for this object in the cluster database.
//
//  Arguments:
//      bValidateOnly   [IN] Only validate the data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by WriteItem().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::SetCommonProperties( IN BOOL bValidateOnly )
{
    DWORD           dwStatus    = ERROR_SUCCESS;
    CClusPropList   cpl;
    CWaitCursor     wc;

    // Save data.
    {
        // Build the property list and set the data.
        try
        {
            BuildPropList( cpl );
            dwStatus = DwSetCommonProperties( cpl, bValidateOnly );
        }  // try
        catch ( CMemoryException * pme )
        {
            pme->Delete();
            dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        }  // catch:  CMemoryException

        // Handle errors.
        if ( dwStatus != ERROR_SUCCESS )
        {
            if ( dwStatus != ERROR_RESOURCE_PROPERTIES_STORED )
            {
                ThrowStaticException( dwStatus, IDS_APPLY_PARAM_CHANGES_ERROR );
            } // if
        }  // if:  error setting properties

        if ( ! bValidateOnly && ( dwStatus == ERROR_SUCCESS ) )
        {
            DWORD                   cprop;
            const CObjectProperty * pprop;

            // Save new values as previous values.

            for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
            {
                switch ( pprop->m_propFormat )
                {
                    case CLUSPROP_FORMAT_SZ:
                        ASSERT( pprop->m_value.pstr != NULL );
                        ASSERT( pprop->m_valuePrev.pstr != NULL );
                        *pprop->m_valuePrev.pstr = *pprop->m_value.pstr;
                        break;
                    case CLUSPROP_FORMAT_DWORD:
                        ASSERT( pprop->m_value.pdw != NULL );
                        ASSERT( pprop->m_valuePrev.pdw != NULL );
                        *pprop->m_valuePrev.pdw = *pprop->m_value.pdw;
                        break;
                    case CLUSPROP_FORMAT_BINARY:
                    case CLUSPROP_FORMAT_MULTI_SZ:
                        ASSERT( pprop->m_value.ppb != NULL );
                        ASSERT( *pprop->m_value.ppb != NULL );
                        ASSERT( pprop->m_value.pcb != NULL );
                        ASSERT( pprop->m_valuePrev.ppb != NULL );
                        ASSERT( *pprop->m_valuePrev.ppb != NULL );
                        ASSERT( pprop->m_valuePrev.pcb != NULL );
                        delete [] *pprop->m_valuePrev.ppb;
                        *pprop->m_valuePrev.ppb = new BYTE[ *pprop->m_value.pcb ];
                        if ( *pprop->m_valuePrev.ppb == NULL )
                        {
                            ThrowStaticException( GetLastError() );
                        } // if: error allocating data buffer
                        CopyMemory( *pprop->m_valuePrev.ppb, *pprop->m_value.ppb, *pprop->m_value.pcb );
                        *pprop->m_valuePrev.pcb = *pprop->m_value.pcb;
                        break;
                    default:
                        ASSERT( 0 );  // don't know how to deal with this type
                }  // switch:  property format
            }  // for:  each property
        }  // if:  not just validating and properties set successfully

        if ( dwStatus == ERROR_RESOURCE_PROPERTIES_STORED )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // Save data

}  //*** CClusterItem::SetCommonProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BuildPropList
//
//  Routine Description:
//      Build the property list.
//
//  Arguments:
//      rcpl        [IN OUT] Cluster property list.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      Any exceptions thrown by CClusPropList::ScAddProp().
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::BuildPropList(
    IN OUT CClusPropList & rcpl
    )
{
    DWORD                   cprop;
    const CObjectProperty * pprop;

    for ( pprop = Pprops(), cprop = Cprops() ; cprop > 0 ; pprop++, cprop-- )
    {
        switch ( pprop->m_propFormat )
        {
            case CLUSPROP_FORMAT_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pstr,
                        *pprop->m_valuePrev.pstr
                        );
                break;
            case CLUSPROP_FORMAT_DWORD:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.pdw,
                        *pprop->m_valuePrev.pdw
                        );
                break;
            case CLUSPROP_FORMAT_BINARY:
            case CLUSPROP_FORMAT_MULTI_SZ:
                rcpl.ScAddProp(
                        pprop->m_pwszName,
                        *pprop->m_value.ppb,
                        *pprop->m_value.pcb,
                        *pprop->m_valuePrev.ppb,
                        *pprop->m_valuePrev.pcb
                        );
                break;
            default:
                ASSERT( 0 );  // don't know how to deal with this type
                return;
        }  // switch:  property format
    }  // for:  each property

}  //*** CClusterItem::BuildPropList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::UpdateState
//
//  Routine Description:
//      Update the current state of the item.
//      Default implementation.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::UpdateState( void )
{
    // Update the state of all the tree items pointing to us.
    {
        POSITION    pos;
        CTreeItem * pti;

        pos = LptiBackPointers().GetHeadPosition();
        while ( pos != NULL )
        {
            pti = LptiBackPointers().GetNext( pos );
            ASSERT_VALID( pti );
            pti->UpdateUIState();
        }  // while:  more items in the list
    }  // Update the state of all the tree items pointing to us

    // Update the state of all the list items pointing to us.
    {
        POSITION    pos;
        CListItem * pli;

        pos = LpliBackPointers().GetHeadPosition();
        while ( pos != NULL )
        {
            pli = LpliBackPointers().GetNext( pos );
            ASSERT_VALID( pli );
            pli->UpdateUIState();
        }  // while:  more items in the list
    }  // Update the state of all the tree items pointing to us

}  //*** CClusterItem::UpdateState

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [OUT] String in which to return the value.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT CString &   rstrValue
    )
{
    DWORD       dwStatus;
    LPWSTR      pwszValue   = NULL;
    DWORD       dwValueLen;
    DWORD       dwValueType;
    HKEY        hkey        = NULL;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    rstrValue.Empty();

    try
    {
        // Open a new key if needed.
        if ( pszKeyName != NULL )
        {
            dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_READ, &hkey );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  need to open a subkey
        else
        {
            hkey = Hkey();
        } // else

        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_SZ );

            // Allocate enough space for the data.
            pwszValue = rstrValue.GetBuffer( dwValueLen / sizeof( WCHAR ) );
            ASSERT( pwszValue != NULL );
            dwValueLen += 1 * sizeof( WCHAR );    // Don't forget the final null-terminator.

            // Read the value.
            dwStatus = ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE ) pwszValue,
                            &dwValueLen
                            );
            if ( dwStatus == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_SZ );
            }  // if:  value read successfully
            rstrValue.ReleaseBuffer();
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, CString& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_MULTI_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rlstrValue      [OUT] String list in which to return the values.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    OUT CStringList &   rlstrValue
    )
{
    DWORD               dwStatus;
    LPWSTR              pwszValue   = NULL;
    LPWSTR              pwszCurValue;
    DWORD               dwValueLen;
    DWORD               dwValueType;
    HKEY                hkey        = NULL;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    rlstrValue.RemoveAll();

    try
    {
        // Open a new key if needed.
        if ( pszKeyName != NULL )
        {
            dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_READ, &hkey );
            if ( dwStatus != ERROR_SUCCESS )
            {
                return dwStatus;
            } // if
        }  // if:  need to open a subkey
        else
        {
            hkey = Hkey();
        }

        // Get the size of the value.
        dwValueLen = 0;
        dwStatus = ClusterRegQueryValue(
                        hkey,
                        pszValueName,
                        &dwValueType,
                        NULL,
                        &dwValueLen
                        );
        if ( ( dwStatus == ERROR_SUCCESS ) || ( dwStatus == ERROR_MORE_DATA ) )
        {
            ASSERT( dwValueType == REG_MULTI_SZ );

            // Allocate enough space for the data.
            dwValueLen += 1 * sizeof( WCHAR );    // Don't forget the final null-terminator.
            pwszValue = new WCHAR[ dwValueLen / sizeof( WCHAR ) ];
            if ( pwszValue == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating the value

            // Read the value.
            dwStatus = ClusterRegQueryValue(
                            hkey,
                            pszValueName,
                            &dwValueType,
                            (LPBYTE) pwszValue,
                            &dwValueLen
                            );
            if ( dwStatus == ERROR_SUCCESS )
            {
                ASSERT( dwValueType == REG_MULTI_SZ );

                // Add each string from the value into the string list.
                for ( pwszCurValue = pwszValue
                        ; *pwszCurValue != L'\0'
                        ; pwszCurValue += wcslen( pwszCurValue ) + 1
                        )
                {
                    rlstrValue.AddTail( pwszCurValue );
                } // for
            }  // if:  read the value successfully
        }  // if:  got the size successfully
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    delete [] pwszValue;
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, CStringList& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pdwValue        [OUT] DWORD in which to return the value.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT DWORD *     pdwValue
    )
{
    DWORD       dwStatus;
    DWORD       dwValue;
    DWORD       dwValueLen;
    DWORD       dwValueType;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( pdwValue != NULL );
    ASSERT( Hkey() != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_READ, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            return dwStatus;
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Read the value.
    dwValueLen = sizeof( dwValue );
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    (LPBYTE) &dwValue,
                    &dwValueLen
                    );
    if ( dwStatus == ERROR_SUCCESS )
    {
        ASSERT( dwValueType == REG_DWORD );
        ASSERT( dwValueLen == sizeof( dwValue ) );
        *pdwValue = dwValue;
    }  // if:  value read successfully

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, DWORD* )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pdwValue        [OUT] DWORD in which to return the value.
//      dwDefault       [IN] Default value if parameter not set.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT DWORD *     pdwValue,
    IN DWORD        dwDefault
    )
{
    DWORD       dwStatus;
    CWaitCursor wc;

    // Read the value.
    dwStatus = DwReadValue( pszValueName, pszKeyName, pdwValue );
    if ( dwStatus == ERROR_FILE_NOT_FOUND )
    {
        *pdwValue = dwDefault;
        dwStatus = ERROR_SUCCESS;
    }  // if:  value not set

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, DWORD*, DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DwReadValue
//
//  Routine Description:
//      Read a REG_BINARY value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to read.
//      pszKeyName      [IN] Name of the key where the value resides.
//      ppbValue        [OUT] Pointer in which to return the data.  Caller
//                          is responsible for deallocating the data.
//
//  Return Value:
//      dwStatus    ERROR_SUCCESS = success, !0 = failure
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD CClusterItem::DwReadValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    OUT LPBYTE *    ppbValue
    )
{
    DWORD               dwStatus;
    DWORD               dwValueLen;
    DWORD               dwValueType;
    LPBYTE              pbValue     = NULL;
    HKEY                hkey;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( ppbValue != NULL );
    ASSERT( Hkey() != NULL );

    delete [] *ppbValue;
    *ppbValue = NULL;

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_READ, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            return dwStatus;
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Get the length of the value.
    dwValueLen = 0;
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    NULL,
                    &dwValueLen
                    );
    if ( ( dwStatus != ERROR_SUCCESS )
      && ( dwStatus != ERROR_MORE_DATA ) )
    {
        if ( pszKeyName != NULL )
        {
            ClusterRegCloseKey( hkey );
        } // if
        return dwStatus;
    }  // if:  error getting the length

    ASSERT( dwValueType == REG_BINARY );

    // Allocate a buffer,
    try
    {
        pbValue = new BYTE[ dwValueLen ];
        if ( pbValue == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating the buffer
    }  // try
    catch ( CMemoryException * )
    {
        if ( pszKeyName != NULL )
        {
            ClusterRegCloseKey( hkey );
        } // if
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
        return dwStatus;
    }  // catch:  CMemoryException

    // Read the value.
    dwStatus = ClusterRegQueryValue(
                    hkey,
                    pszValueName,
                    &dwValueType,
                    pbValue,
                    &dwValueLen
                    );
    if ( dwStatus == ERROR_SUCCESS )
    {
        *ppbValue = pbValue;
    } // if
    else
    {
        delete [] pbValue;
    } // else

    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if

    return dwStatus;

}  //*** CClusterItem::DwReadValue( LPCTSTR, LPBYTE* )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    IN const CString &  rstrValue
    )
{
    DWORD       dwStatus;
    HKEY            hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_SZ,
                    (CONST BYTE *) (LPCTSTR) rstrValue,
                    ( rstrValue.GetLength() + 1 ) * sizeof( WCHAR )
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, CString& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_MULTI_SZ value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rlstrValue      [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//      Any exceptions thrown by new.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR              pszValueName,
    IN LPCTSTR              pszKeyName,
    IN const CStringList &  rlstrValue
    )
{
    DWORD       dwStatus;
    LPWSTR      pwszValue   = NULL;
    LPWSTR      pwszCurValue;
    POSITION    posStr;
    DWORD       cbValueLen;
    HKEY        hkey;
    HRESULT     hr;
    size_t      cchValue;
    size_t      cch;
    size_t      cchLeft;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    // Get the size of the value.
    posStr = rlstrValue.GetHeadPosition();
    cbValueLen = 0;
    while ( posStr != NULL )
    {
        cbValueLen += ( rlstrValue.GetNext( posStr ).GetLength() + 1 ) * sizeof( TCHAR );
    }  // while:  more items in the list
    cbValueLen += 1 * sizeof( WCHAR );    // Extra NULL at the end.

    // Allocate the value buffer.
    cchValue = cbValueLen / sizeof( *pwszValue );
    pwszValue = new WCHAR[ cchValue ];
    if ( pwszValue == NULL )
    {
        ThrowStaticException( GetLastError() );
        return;
    } // if

    // Copy the strings to the values.
    posStr = rlstrValue.GetHeadPosition();
    for ( pwszCurValue = pwszValue, cchLeft = cchValue ; posStr != NULL ; pwszCurValue += cch, cchLeft -= cch )
    {
        hr = StringCchCopyW( pwszCurValue, cchLeft, rlstrValue.GetNext( posStr ) );
        ASSERT( SUCCEEDED( hr ) );
        cch = wcslen( pwszCurValue ) + 1;
    }  // for:  each item in the list
    pwszCurValue[0] = L'\0';

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            delete [] pwszValue;
            ThrowStaticException( dwStatus );
        }  // if:  error opening the key
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_MULTI_SZ,
                    (CONST BYTE *) pwszValue,
                    cbValueLen - ( 1 * sizeof( WCHAR ) )
                    );
    delete [] pwszValue;
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, CStringList& )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_DWORD value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      dwValue         [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName,
    IN DWORD        dwValue
    )
{
    DWORD       dwStatus;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    }

    // Write the value.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_DWORD,
                    (CONST BYTE *) &dwValue,
                    sizeof( dwValue )
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::WriteValue( LPCTSTR, DWORD )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::WriteValue
//
//  Routine Description:
//      Write a REG_BINARY value for this item if it hasn't changed.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to write.
//      pszKeyName      [IN] Name of the key where the value resides.
//      pbValue         [IN] Value data.
//      cbValue         [IN] Size of value data.
//      ppbPrevValue    [IN OUT] Previous value.
//      cbPrevValue     [IN] Size of the previous data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::WriteValue(
    IN LPCTSTR          pszValueName,
    IN LPCTSTR          pszKeyName,
    IN const LPBYTE     pbValue,
    IN DWORD            cbValue,
    IN OUT LPBYTE *     ppbPrevValue,
    IN DWORD            cbPrevValue
    )
{
    DWORD               dwStatus;
    LPBYTE              pbPrevValue = NULL;
    HKEY                hkey;
    CWaitCursor         wc;

    ASSERT( pszValueName != NULL );
    ASSERT( pbValue != NULL );
    ASSERT( ppbPrevValue != NULL );
    ASSERT( cbValue > 0 );
    ASSERT( Hkey() != NULL );

    // See if the data has changed.
    if ( cbValue == cbPrevValue )
    {
        DWORD       ib;

        for ( ib = 0 ; ib < cbValue ; ib++ )
        {
            if ( pbValue[ ib ] != (*ppbPrevValue )[ ib ] )
            {
                break;
            } // if
        }  // for:  each byte in the value
        if ( ib == cbValue )
        {
            return;
        } // if
    }  // if:  lengths are the same

    // Allocate a new buffer for the previous data pointer.
    pbPrevValue = new BYTE[ cbValue ];
    if ( pbPrevValue == NULL )
    {
        ThrowStaticException( GetLastError() );
        return;
    } // if: error allocating previous data buffer
    CopyMemory( pbPrevValue, pbValue, cbValue );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            delete [] pbPrevValue;
            ThrowStaticException( dwStatus );
            return;
        }  // if:  error opening the key
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Write the value if it hasn't changed.
    dwStatus = ClusterRegSetValue(
                    hkey,
                    pszValueName,
                    REG_BINARY,
                    pbValue,
                    cbValue
                    );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus == ERROR_SUCCESS )
    {
        delete [] *ppbPrevValue;
        *ppbPrevValue = pbPrevValue;
    }  // if:  set was successful
    else
    {
        delete [] pbPrevValue;
        ThrowStaticException( dwStatus );
    }  // else:  error setting the value

}  //*** CClusterItem::WriteValue( LPCTSTR, const LPBYTE )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::DeleteValue
//
//  Routine Description:
//      Delete the value for this item.
//
//  Arguments:
//      pszValueName    [IN] Name of the value to delete.
//      pszKeyName      [IN] Name of the key where the value resides.
//      rstrValue       [IN] Value data.
//
//  Return Value:
//      None.
//
//  Exceptions Thrown:
//      CNTException( dwStatus )
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::DeleteValue(
    IN LPCTSTR      pszValueName,
    IN LPCTSTR      pszKeyName
    )
{
    DWORD       dwStatus;
    HKEY        hkey;
    CWaitCursor wc;

    ASSERT( pszValueName != NULL );
    ASSERT( Hkey() != NULL );

    // Open a new key if needed.
    if ( pszKeyName != NULL )
    {
        dwStatus = ClusterRegOpenKey( Hkey(), pszKeyName, KEY_ALL_ACCESS, &hkey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            ThrowStaticException( dwStatus );
        } // if
    }  // if:  need to open a subkey
    else
    {
        hkey = Hkey();
    } // else

    // Delete the value.
    dwStatus = ClusterRegDeleteValue( hkey, pszValueName );
    if ( pszKeyName != NULL )
    {
        ClusterRegCloseKey( hkey );
    } // if
    if ( dwStatus != ERROR_SUCCESS )
    {
        ThrowStaticException( dwStatus );
    } // if

}  //*** CClusterItem::DeleteValue( LPCTSTR )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDifferent
//
//  Routine Description:
//      Compare two string lists.
//
//  Arguments:
//      rlstr1      [IN] First string list.
//      rlstr2      [IN] Second string list.
//
//  Return Value:
//      TRUE        Lists are different.
//      FALSE       Lists are the same.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDifferent(
    IN const CStringList &  rlstr1,
    IN const CStringList &  rlstr2
    )
{
    BOOL    bDifferent;

    if ( rlstr1.GetCount() == rlstr2.GetCount() )
    {
        POSITION    posStr;

        bDifferent = FALSE;
        posStr = rlstr1.GetHeadPosition();
        while ( posStr != NULL )
        {
            if ( rlstr2.Find( rlstr1.GetNext( posStr ) ) == 0 )
            {
                bDifferent = TRUE;
                break;
            }  // if:  string wasn't found
        }  // while:  more items in the list
    }  // if:  lists are the same size
    else
    {
        bDifferent = TRUE;
    } // else

    return bDifferent;

}  //*** CClusterItem::BDifferent

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDifferentOrdered
//
//  Routine Description:
//      Compare two string lists.
//
//  Arguments:
//      rlstr1      [IN] First string list.
//      rlstr2      [IN] Second string list.
//
//  Return Value:
//      TRUE        Lists are different.
//      FALSE       Lists are the same.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDifferentOrdered(
    IN const CStringList &  rlstr1,
    IN const CStringList &  rlstr2
    )
{
    BOOL    bDifferent;

    if ( rlstr1.GetCount() == rlstr2.GetCount() )
    {
        POSITION    posStr1;
        POSITION    posStr2;

        bDifferent = FALSE;
        posStr1 = rlstr1.GetHeadPosition();
        posStr2 = rlstr2.GetHeadPosition();
        while ( posStr1 != NULL )
        {
            if ( posStr2 == NULL )
            {
                bDifferent = TRUE;
                break;
            }  // if:  fewer strings in second list
            if ( rlstr1.GetNext( posStr1 ) != rlstr2.GetNext( posStr2 ) )
            {
                bDifferent = TRUE;
                break;
            }  // if:  strings are different
        }  // while:  more items in the list
        if ( posStr2 != NULL )
        {
            bDifferent = TRUE;
        } // if
    }  // if:  lists are the same size
    else
    {
        bDifferent = TRUE;
    } // else

    return bDifferent;

}  //*** CClusterItem::BDifferentOrdered

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BGetColumnData
//
//  Routine Description:
//      Returns a string with the column data for a
//
//  Arguments:
//      colid           [IN] Column ID.
//      rstrText        [OUT] String in which to return the text for the column.
//
//  Return Value:
//      TRUE        Column data returned.
//      FALSE       Column ID not recognized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BGetColumnData( IN COLID colid, OUT CString & rstrText )
{
    BOOL    bSuccess;

    switch ( colid )
    {
        case IDS_COLTEXT_NAME:
            rstrText = StrName();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_TYPE:
            rstrText = StrType();
            bSuccess = TRUE;
            break;
        case IDS_COLTEXT_DESCRIPTION:
            rstrText = StrDescription();
            bSuccess = TRUE;
            break;
        default:
            bSuccess = FALSE;
            rstrText = _T("");
            break;
    }  // switch:  colid

    return bSuccess;

}  //*** CClusterItem::BGetColumnData

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::GetTreeName
//
//  Routine Description:
//      Returns a string to be used in a tree control.
//
//  Arguments:
//      rstrName    [OUT] String in which to return the name.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
#ifdef _DISPLAY_STATE_TEXT_IN_TREE
void CClusterItem::GetTreeName( OUT CString & rstrName ) const
{
    rstrName = StrName();

}  //*** CClusterItem::GetTreeName
#endif

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::PmenuPopup
//
//  Routine Description:
//      Returns a popup menu.
//
//  Arguments:
//      None.
//
//  Return Value:
//      pmenu       A popup menu for the item.
//
//--
/////////////////////////////////////////////////////////////////////////////
CMenu * CClusterItem::PmenuPopup( void )
{
    CMenu * pmenu   = NULL;

    if ( IdmPopupMenu() != NULL )
    {
        // Update the state of the item before we construct its menu.
        UpdateState();

        // Load the menu.
        pmenu = new CMenu;
        if ( pmenu == NULL )
        {
            return NULL;
        } // if
        if ( ! pmenu->LoadMenu( IdmPopupMenu() ) )
        {
            delete pmenu;
            pmenu = NULL;
        }  // if:  error loading the menu
    }  // if:  there is a menu for this item

    return pmenu;

}  //*** CClusterItem::PmenuPopup

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::AddTreeItem
//
//  Routine Description:
//      Add a tree item to the list item back pointer list.
//
//  Arguments:
//      pti         [IN] Tree item to add.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::AddTreeItem( CTreeItem * pti )
{
    POSITION    pos;

    ASSERT_VALID( pti );

    // Find the item in the list.
    pos = LptiBackPointers().Find( pti );

    // If it wasn't found, add it.
    if ( pos == NULL )
    {
        LptiBackPointers().AddTail( pti );
        Trace( g_tagClusItemCreate, _T("AddTreeItem() - Adding tree item backptr from '%s' in '%s' - %d in list"), StrName(), ( pti->PtiParent() == NULL ? _T("<ROOT>") : pti->PtiParent()->StrName() ), LptiBackPointers().GetCount() );
    }  // if:  item found in list

}  //*** CClusterItem::AddTreeItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::AddListItem
//
//  Routine Description:
//      Add a list item to the list item back pointer list.
//
//  Arguments:
//      pli         [IN] List item to add.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::AddListItem( CListItem * pli )
{
    POSITION    pos;

    ASSERT_VALID( pli );

    // Find the item in the list.
    pos = LpliBackPointers().Find( pli );

    // If it wasn't found, add it.
    if ( pos == NULL )
    {
        LpliBackPointers().AddTail( pli );
        Trace( g_tagClusItemCreate, _T("AddListItem() - Adding list item backptr from '%s' in '%s' - %d in list"), StrName(), ( pli->PtiParent() == NULL ? _T("<ROOT>") : pli->PtiParent()->StrName() ), LpliBackPointers().GetCount() );
    }  // if:  item found in list

}  //*** CClusterItem::AddListItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveTreeItem
//
//  Routine Description:
//      Remove a tree item from the tree item back pointer list.
//
//  Arguments:
//      pti         [IN] Tree item to remove.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveTreeItem( CTreeItem * pti )
{
    POSITION    pos;

    ASSERT_VALID( pti );

    // Find the item in the list.
    pos = LptiBackPointers().Find( pti );

    // If it was found, remove it.
    if ( pos != NULL )
    {
        LptiBackPointers().RemoveAt( pos );
        Trace( g_tagClusItemDelete, _T("RemoveTreeItem() - Deleting tree item backptr from '%s' in '%s' - %d left"), StrName(), ( pti->PtiParent() == NULL ? _T("<ROOT>") : pti->PtiParent()->StrName() ), LptiBackPointers().GetCount() );
    }  // if:  item found in list

}  //*** CClusterItem::RemoveTreeItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::RemoveListItem
//
//  Routine Description:
//      Remove a list item from the list item back pointer list.
//
//  Arguments:
//      pli         [IN] List item to remove.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::RemoveListItem( CListItem * pli )
{
    POSITION    pos;

    ASSERT_VALID( pli );

    // Find the item in the list.
    pos = LpliBackPointers().Find( pli );

    // If it was found, remove it.
    if ( pos != NULL )
    {
        LpliBackPointers().RemoveAt( pos );
        Trace( g_tagClusItemDelete, _T("RemoveListItem() - Deleting list item backptr from '%s' in '%s' - %d left"), StrName(), ( pli->PtiParent() == NULL ? _T("<ROOT>") : pli->PtiParent()->StrName() ), LpliBackPointers().GetCount() );
    }  // if:  item found in list

}  //*** CClusterItem::RemoveListItem

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CResource::CClusterItem
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_RENAME
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnUpdateRename( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( BCanBeEdited() );

}  //*** CClusterItem::OnUpdateRename

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnUpdateProperties
//
//  Routine Description:
//      Determines whether menu items corresponding to ID_FILE_PROPERTIES
//      should be enabled or not.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnUpdateProperties( CCmdUI * pCmdUI )
{
    pCmdUI->Enable( FALSE );

}  //*** CClusterItem::OnUpdateProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnCmdProperties
//
//  Routine Description:
//      Processes the ID_FILE_PROPERTIES menu command.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterItem::OnCmdProperties( void )
{
    BDisplayProperties();

}  //*** CClusterItem::OnCmdProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::BDisplayProperties
//
//  Routine Description:
//      Display properties for the object.
//
//  Arguments:
//      bReadOnly   [IN] Don't allow edits to the object properties.
//
//  Return Value:
//      TRUE    OK pressed.
//      FALSE   OK not pressed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterItem::BDisplayProperties( IN BOOL bReadOnly )
{
    AfxMessageBox( TEXT("Properties are not available."), MB_OK | MB_ICONWARNING );
    return FALSE;

}  //*** CClusterItem::BDisplayProperties

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterItem::OnClusterNotify
//
//  Routine Description:
//      Handler for the WM_CAM_CLUSTER_NOTIFY message.
//      Processes cluster notifications for this object.
//
//  Arguments:
//      pnotify     [IN OUT] Object describing the notification.
//
//  Return Value:
//      Value returned from the application method.
//
//--
/////////////////////////////////////////////////////////////////////////////
LRESULT CClusterItem::OnClusterNotify( IN OUT CClusterNotify * pnotify )
{
    return 0;

}  //*** CClusterItem::OnClusterNotify


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DestructElements
//
//  Routine Description:
//      Destroys CClusterItem* elements.
//
//  Arguments:
//      pElements   Array of pointers to elements to destruct.
//      nCount      Number of elements to destruct.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////

template<>
void AFXAPI DestructElements( CClusterItem ** pElements, INT_PTR nCount )
{
    ASSERT( nCount == 0
         || AfxIsValidAddress( pElements, nCount * sizeof( CClusterItem * ) ) );

    // call the destructor(s )
    for ( ; nCount--; pElements++ )
    {
        ASSERT_VALID( *pElements );
        (*pElements)->Release();
    }  // for:  each item in the array

}  //*** DestructElements( CClusterItem** )

/////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteAllItemData
//
//  Routine Description:
//      Deletes all item data in a CList.
//
//  Arguments:
//      rlp     [IN OUT] List whose data is to be deleted.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void DeleteAllItemData( IN OUT CClusterItemList & rlp )
{
    POSITION        pos;
    CClusterItem *  pci;

    // Delete all the items in the Contained list.
    pos = rlp.GetHeadPosition();
    while ( pos != NULL )
    {
        pci = rlp.GetNext( pos );
        ASSERT_VALID( pci );
//      Trace( g_tagClusItemDelete, _T("DeleteAllItemData(rlpci ) - Deleting cluster item '%s'"), pci->StrName() );
        pci->Delete();
    }  // while:  more items in the list

}  //*** DeleteAllItemData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusitem.inl ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ClusItem.inl
//
//	Abstract:
//		Inline function implementations for the CClusterItem class.
//
//	Author:
//		David Potter (davidp)	May 9, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_INL_
#define _CLUSITEM_INL_

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#include "ClusItem.h"	// for CClusterItem
#endif

#ifndef _CLUSDOC_H_
#include "ClusDoc.h"	// for CClusterDoc
#endif

/////////////////////////////////////////////////////////////////////////////
// Inline Function Definitions
/////////////////////////////////////////////////////////////////////////////

inline HCLUSTER CClusterItem::Hcluster(void) const
{
	ASSERT_VALID(Pdoc());
	return Pdoc()->Hcluster();

}  //*** CClusterItem::Hcluster()

inline HKEY CClusterItem::HkeyCluster(void) const
{
	ASSERT_VALID(Pdoc());
	return Pdoc()->HkeyCluster();

}  //*** CClusterItem::HkeyCluster()

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSITEM_INL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusdoc.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusDoc.h
//
//  Abstract:
//      Definition of the CClusterDoc class.
//
//  Implementation File:
//      ClusDoc.cpp
//
//  Author:
//      David Potter (davidp)   May 1, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSDOC_H_
#define _CLUSDOC_H_

/////////////////////////////////////////////////////////////////////////////
// Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _NODE_H_
#include "Node.h"       // for CNodeList
#endif

#ifndef _GROUP_H_
#include "Group.h"      // for CGroupList
#endif

#ifndef _RES_H_
#include "Res.h"        // for CResourceList
#endif

#ifndef _RESTYPE_H_
#include "ResType.h"    // for CResourceTypeList
#endif

#ifndef _NETWORK_H_
#include "Network.h"    // for CNetworkList
#endif

#ifndef _NETIFACE_H_
#include "NetIFace.h"   // for CNetInterfaceList
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"   // for CTreeItem
#endif

#ifndef _NOTIFY_H_
#include "Notify.h"     // for CClusterNotifyKeyList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterNotify;

/////////////////////////////////////////////////////////////////////////////
// Type Definitions
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// class CClusterDoc
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc : public CDocument
{
    friend class CCluster;
    friend class CClusterTreeView;
    friend class CClusterListView;
    friend class CCreateResourceWizard;

protected: // create from serialization only
    CClusterDoc(void);
    DECLARE_DYNCREATE(CClusterDoc)

// Attributes
protected:
    CString             m_strName;
    CString             m_strNode;
    HCLUSTER            m_hcluster;
    HKEY                m_hkeyCluster;
    CCluster *          m_pciCluster;
    CTreeItem *         m_ptiCluster;

    CNodeList           m_lpciNodes;
    CGroupList          m_lpciGroups;
    CResourceList       m_lpciResources;
    CResourceTypeList   m_lpciResourceTypes;
    CNetworkList        m_lpciNetworks;
    CNetInterfaceList   m_lpciNetInterfaces;

    CClusterItemList    m_lpciToBeDeleted;

    BOOL                m_bClusterAvailable;

public:
    const CString &     StrName(void) const     { return m_strName; }
    const CString &     StrNode(void) const     { return m_strNode; }
    HCLUSTER            Hcluster(void) const    { return m_hcluster; }
    HKEY                HkeyCluster(void) const { return m_hkeyCluster; }
    CCluster *          PciCluster(void) const  { return m_pciCluster; }
    CTreeItem *         PtiCluster(void) const  { return m_ptiCluster; }

    CNodeList &         LpciNodes(void)         { return m_lpciNodes; }
    CGroupList &        LpciGroups(void)        { return m_lpciGroups; }
    CResourceTypeList & LpciResourceTypes(void) { return m_lpciResourceTypes; }
    CResourceList &     LpciResources(void)     { return m_lpciResources; }
    CNetworkList &      LpciNetworks(void)      { return m_lpciNetworks; }
    CNetInterfaceList & LpciNetInterfaces(void) { return m_lpciNetInterfaces; }

    CClusterItemList &  LpciToBeDeleted(void)   { return m_lpciToBeDeleted; }

    BOOL                BClusterAvailable(void) const   { return m_bClusterAvailable; }

// Operations
public:
    void                UpdateTitle(void);
    void                Refresh(void)           { OnCmdRefresh(); }

// Overrides
public:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterDoc)
    public:
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
    virtual void DeleteContents();
    virtual void OnCloseDocument();
    virtual void OnChangedViewList();
    //}}AFX_VIRTUAL

    void                OnSelChanged(IN CClusterItem * pciSelected);
    LRESULT             OnClusterNotify(IN OUT CClusterNotify * pnotify);
    void                SaveSettings(void);

// Implementation
public:
    virtual ~CClusterDoc(void);
#ifdef _DEBUG
    virtual void        AssertValid(void) const;
    virtual void        Dump(CDumpContext& dc) const;
#endif

protected:
    void                OnOpenDocumentWorker(LPCTSTR lpszPathName);
    void                BuildBaseHierarchy(void);
    void                CollectClusterItems(void) ;
    ID                  IdProcessNewObjectError(IN OUT CException * pe);
    void                AddDefaultColumns(IN OUT CTreeItem * pti);

    CClusterNode *      PciAddNewNode(IN LPCTSTR pszName);
    CGroup *            PciAddNewGroup(IN LPCTSTR pszName);
    CResource *         PciAddNewResource(IN LPCTSTR pszName);
    CResourceType *     PciAddNewResourceType(IN LPCTSTR pszName);
    CNetwork *          PciAddNewNetwork(IN LPCTSTR pszName);
    CNetInterface *     PciAddNewNetInterface(IN LPCTSTR pszName);

    void                InitNodes(void);
    void                InitGroups(void);
    void                InitResources(void);
    void                InitResourceTypes(void);
    void                InitNetworks(void);
    void                InitNetInterfaces(void);

    BOOL                m_bUpdateFrameNumber;
    BOOL                m_bInitializing;
    BOOL                m_bIgnoreErrors;

    // This menu stuff allows the menu to change depending on what
    // kind of object is currently selected.
    HMENU               m_hmenuCluster;
    HMENU               m_hmenuNode;
    HMENU               m_hmenuGroup;
    HMENU               m_hmenuResource;
    HMENU               m_hmenuResType;
    HMENU               m_hmenuNetwork;
    HMENU               m_hmenuNetIFace;
    HMENU               m_hmenuCurrent;
    IDM                 m_idmCurrentMenu;
    virtual HMENU       GetDefaultMenu(void);

    void                ProcessRegNotification(IN const CClusterNotify * pnotify);

// Generated message map functions
protected:
    //{{AFX_MSG(CClusterDoc)
    afx_msg void OnCmdNewGroup();
    afx_msg void OnCmdNewResource();
    afx_msg void OnCmdNewNode();
    afx_msg void OnCmdConfigApp();
    //}}AFX_MSG

public:
    afx_msg void OnCmdRefresh();

protected:
    DECLARE_MESSAGE_MAP()

// Cleanup functions
private:
    void CloseClusterKeyAndHandle( BOOL bForce = FALSE );

};  //*** class CClusterDoc

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusmru.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996 Microsoft Corporation
//
//	Module Name:
//		ClusMru.h
//
//	Abstract:
//		Definition of the CRecentClusterList class.
//
//	Author:
//		David Potter (davidp)	May 3, 1996
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSMRU_H_
#define _CLUSMRU_H_

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

/////////////////////////////////////////////////////////////////////////////
//	Include Files
/////////////////////////////////////////////////////////////////////////////

#if _MFC_VER < 0x0410
#ifndef __AFXPRIV_H__
#include "afxpriv.h"
#endif
#else
#ifndef __AFXADV_H__
#include "afxadv.h"
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// CRecentClusterList:
// See ClusMru.cpp for the implementation of this class
//

class CRecentClusterList : public CRecentFileList
{
public:
	// Constructors
	CRecentClusterList(
			UINT	nStart,
			LPCTSTR	lpszSection,
			LPCTSTR	lpszEntryFormat,
			int		nSize,
			int		nMaxDispLen = AFX_ABBREV_FILENAME_LEN
			)
		: CRecentFileList(nStart, lpszSection, lpszEntryFormat, nSize, nMaxDispLen) { }

	// Operations
	virtual void Add(LPCTSTR lpszPathName);
	BOOL GetDisplayName(CString& strName, int nIndex,
		LPCTSTR lpszCurDir, int nCurDir, BOOL bAtLeastName = TRUE) const;
	virtual void UpdateMenu(CCmdUI* pCmdUI);

};  //*** class CRecentClusterList

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSMRU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusitem.h ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1997 Microsoft Corporation
//
//  Module Name:
//      ClusItem.h
//
//  Abstract:
//      Definition of the CClusterItem class.
//
//  Implementation File:
//      ClusItem.cpp
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _CLUSITEM_H_
#define _CLUSITEM_H_

/////////////////////////////////////////////////////////////////////////////
//  Include Files
/////////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#include "resource.h"
#define _RESOURCE_H_
#endif

#ifndef _BASECMDT_H_
#include "BaseCmdT.h"   // for CBaseCmdTarget
#endif

#ifndef _TREEITEM_H_
#include "TreeItem.h"   // for CTreeItemList;
#endif

#ifndef _LISTITEM_H_
#include "ListItem.h"   // for CListItemList
#endif

/////////////////////////////////////////////////////////////////////////////
// Forward Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterItem;
class CClusterItemList;

/////////////////////////////////////////////////////////////////////////////
// External Class Declarations
/////////////////////////////////////////////////////////////////////////////

class CClusterDoc;
class CClusterNotify;
class CClusterNotifyKey;
class CClusPropList;
class CObjectProperty;
#ifdef _DEBUG
class CTraceTag;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterItem command target
/////////////////////////////////////////////////////////////////////////////

class CClusterItem : public CBaseCmdTarget
{
    DECLARE_DYNCREATE(CClusterItem)

// Construction
public:
    CClusterItem(void);         // protected constructor used by dynamic creation
    CClusterItem(
        IN const CString *  pstrName,
        IN IDS              idsType = IDS_ITEMTYPE_CONTAINER,
        IN const CString *  pstrDescription = NULL
        );
    void                Init(IN OUT CClusterDoc * pdoc, IN LPCTSTR lpszName);

protected:
    void                CommonConstruct(void);

// Attributes
protected:
    HKEY                m_hkey;
    CString             m_strName;
    CString             m_strType;
    CString             m_strDescription;
    IDS                 m_idsType;
    UINT                m_iimgObjectType;
    UINT                m_iimgState;

    CClusterDoc *       m_pdoc;
    IDM                 m_idmPopupMenu;
    BOOL                m_bDocObj;
    BOOL                m_bChanged;
    BOOL                m_bReadOnly;

    IDM                 IdmPopupMenu(void) const    { return m_idmPopupMenu; }

public:
    HKEY                Hkey(void) const            { return m_hkey; }
    const CString &     StrName(void) const         { return m_strName; }
    const CString &     StrType(void) const         { return m_strType; }
    const CString &     StrDescription(void) const  { return m_strDescription; }
    IDS                 IdsType(void) const         { return m_idsType; }
    UINT                IimgObjectType(void) const  { return m_iimgObjectType; }
    UINT                IimgState(void) const       { return m_iimgState; }

    CClusterDoc *       Pdoc(void) const            { return m_pdoc; }
    BOOL                BDocObj(void) const         { return m_bDocObj; }
    BOOL                BChanged(void) const        { return m_bChanged; }
    BOOL                BReadOnly(void) const       { return m_bReadOnly; }

    void                MarkAsChanged(IN BOOL bChanged = TRUE)  { m_bChanged = bChanged; }

#ifndef _DISPLAY_STATE_TEXT_IN_TREE
    void                GetTreeName(OUT CString & rstrName) const { rstrName = StrName(); }
#endif

    // Inline functions defined in ClusItem.inl because they reference
    // CClusterDoc, which isn't defined yet when this class is being defined.
    HCLUSTER            Hcluster(void) const;
    HKEY                HkeyCluster(void) const;

// Operations
public:
    void                Delete(void);
    void                RemoveItem(void);

    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT CString & rstrValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT CStringList & rlstrValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT DWORD * pdwValue);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT DWORD * pdwValue, IN DWORD dwDefault);
    DWORD               DwReadValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, OUT LPBYTE * ppbValue);

    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT CString & rstrValue)
                            { return DwReadValue(pszValueName, NULL, rstrValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT CStringList & rlstrValue)
                            { return DwReadValue(pszValueName, NULL, rlstrValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT DWORD * pdwValue)
                            { return DwReadValue(pszValueName, NULL, pdwValue); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT DWORD * pdwValue, IN DWORD dwDefault)
                            { return DwReadValue(pszValueName, NULL, pdwValue, dwDefault); }
    DWORD               DwReadValue(IN LPCTSTR pszValueName, OUT LPBYTE * ppbValue)
                            { return DwReadValue(pszValueName, NULL, ppbValue); }

    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN const CString & rstrValue);
    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN const CStringList & rlstrValue);
    void                WriteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName, IN DWORD dwValue);
    void                WriteValue(
                                IN LPCTSTR          pszValueName,
                                IN LPCTSTR          pszKeyName, 
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue
                                );

    void                WriteValue(IN LPCTSTR pszValueName, IN const CString & rstrValue)
                            { WriteValue(pszValueName, NULL, rstrValue); }
    void                WriteValue(IN LPCTSTR pszValueName, IN const CStringList & rlstrValue)
                            { WriteValue(pszValueName, NULL, rlstrValue); }
    void                WriteValue(IN LPCTSTR pszValueName, IN DWORD dwValue)
                            { WriteValue(pszValueName, NULL, dwValue); }
    void                WriteValue(
                                IN LPCTSTR          pszValueName,
                                IN const LPBYTE     pbValue,
                                IN DWORD            cbValue,
                                IN OUT LPBYTE *     ppbPrevValue,
                                IN DWORD            cbPrevValue
                                )
                            { WriteValue(pszValueName, NULL, pbValue, cbValue, ppbPrevValue, cbPrevValue); }

    void                DeleteValue(IN LPCTSTR pszValueName, IN LPCTSTR pszKeyName = NULL);

    CMenu *             PmenuPopup(void);

    BOOL                BDifferent(IN const CStringList & rlstr1, IN const CStringList & rlstr2);
    BOOL                BDifferentOrdered(IN const CStringList & rlstr1, IN const CStringList & rlstr2);

// Overrides
public:
    virtual LPCTSTR     PszTitle(void) const        { return m_strName; }
    virtual void        Cleanup(void)               { return; }
    virtual void        ReadItem(void)              { return; }
    virtual void        WriteItem(void);
    virtual void        UpdateState(void);
    virtual void        Rename(IN LPCTSTR pszName)  { return; }
    virtual BOOL        BGetColumnData(IN COLID colid, OUT CString & rstrText);
    virtual BOOL        BCanBeEdited(void) const    { return FALSE; }
    virtual void        OnBeginLabelEdit(IN OUT CEdit * pedit) { return; }
    virtual BOOL        BDisplayProperties(IN BOOL bReadOnly = FALSE);
    virtual BOOL        BIsLabelEditValueValid(IN LPCTSTR pszName) { return TRUE; }

    // Drag & Drop
    virtual BOOL        BCanBeDragged(void) const   { return FALSE; }
    virtual BOOL        BCanBeDropTarget(IN const CClusterItem * pci) const { return FALSE; }
    virtual void        DropItem(IN OUT CClusterItem * pci)
    {
    }

    virtual const CStringList * PlstrExtensions(void) const;

#ifdef _DISPLAY_STATE_TEXT_IN_TREE
    virtual void        GetTreeName(OUT CString & rstrName) const;
#endif

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CClusterItem)
    //}}AFX_VIRTUAL

    virtual LRESULT     OnClusterNotify(IN OUT CClusterNotify * pnotify);

protected:
    virtual const CObjectProperty * Pprops(void) const  { return NULL; }
    virtual DWORD                   Cprops(void) const  { return 0; }
    virtual DWORD                   DwParseProperties(IN const CClusPropList & rcpl);
    virtual DWORD                   DwParseUnknownProperty(
                                        IN LPCWSTR                          pwszName,
                                        IN const CLUSPROP_BUFFER_HELPER &   rvalue,
                                        IN DWORD                            cbBuf
                                        )       { return ERROR_SUCCESS; }
    virtual void                    SetCommonProperties(IN BOOL bValidateOnly = FALSE);
    virtual void                    BuildPropList(IN OUT CClusPropList & rcpl);
    virtual DWORD                   DwSetCommonProperties(IN const CClusPropList & rcpl, IN BOOL bValidateOnly = FALSE)
                                        { ASSERT(0); return ERROR_INVALID_FUNCTION; }

// Implementation
public:
    virtual ~CClusterItem(void);

protected:
    CClusterNotifyKey * m_pcnk;
    CTreeItemList       m_lptiBackPointers;
    CListItemList       m_lpliBackPointers;

public:
    const CClusterNotifyKey *   Pcnk(void) const    { return m_pcnk; }
    CTreeItemList &     LptiBackPointers(void)      { return m_lptiBackPointers; }
    CListItemList &     LpliBackPointers(void)      { return m_lpliBackPointers; }
    void                AddTreeItem(CTreeItem * pti);
    void                AddListItem(CListItem * pli);
    void                RemoveTreeItem(CTreeItem * pti);
    void                RemoveListItem(CListItem * pli);

#undef afx_msg
#define afx_msg virtual

    // Generated message map functions
    //{{AFX_MSG(CClusterItem)
    afx_msg void OnUpdateRename(CCmdUI* pCmdUI);
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnCmdProperties();
    //}}AFX_MSG

#undef afx_msg
#define afx_msg

    DECLARE_MESSAGE_MAP()

};  //*** class CClusterItem

/////////////////////////////////////////////////////////////////////////////
// CClusterItemList
//
// Every time an item is added to or removed from the list, its reference
// count is updated.
/////////////////////////////////////////////////////////////////////////////

//class CClusterItemList : public CTypedPtrList<CObList, CClusterItem *>
class CClusterItemList : public CList<CClusterItem *, CClusterItem *>
{
public:
// Operations
    CClusterItem *  PciFromName(
                        IN LPCTSTR      pszName,
                        OUT POSITION *  ppos = NULL
                        );

    // add before head or after tail
    POSITION AddHead(CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::AddHead(newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }
    POSITION AddTail(CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::AddTail(newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }

    // inserting before or after a given position
    POSITION InsertBefore(POSITION position, CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::InsertBefore(position, newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }
    POSITION InsertAfter(POSITION position, CClusterItem * newElement)
    {
        ASSERT_VALID(newElement);
        POSITION pos = CList<CClusterItem *,CClusterItem *>::InsertAfter(position, newElement);
        if (pos != NULL)
            newElement->AddRef();
        return pos;
    }

//  void RemoveAll(void);

};  //*** class CClusterItemList

/////////////////////////////////////////////////////////////////////////////
// Global Functions
/////////////////////////////////////////////////////////////////////////////

template<>
void AFXAPI DestructElements(CClusterItem ** pElements, INT_PTR nCount);
void DeleteAllItemData(IN OUT CClusterItemList & rlp);

/////////////////////////////////////////////////////////////////////////////
//  Global Variables
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
extern CTraceTag g_tagClusItemCreate;
extern CTraceTag g_tagClusItemDelete;
extern CTraceTag g_tagClusItemNotify;
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // _CLUSITEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusmru.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusMru.cpp
//
//  Abstract:
//      Implementation of the CRecentClusterList class.
//
//  Author:
//      David Potter (davidp)   May 3, 1996
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusMru.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRecentClusterList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRecentClusterList::Add
//
//  Routine Description:
//      Add an item to the list of recently used cluster names.
//      Implemented to remove file-ness of base class' method.
//
//  Arguments:
//      pszPathName     Name of the cluster or server to add.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRecentClusterList::Add(LPCTSTR pszPathName)
{
    ASSERT(m_arrNames != NULL);
    ASSERT(pszPathName != NULL);
    ASSERT(AfxIsValidString(pszPathName));

    int idxMRU;
    // update the MRU list, if an existing MRU string matches file name
    for (idxMRU = 0; idxMRU < m_nSize-1; idxMRU++)
    {
        if (ClRtlStrICmp(m_arrNames[idxMRU], pszPathName) == 0)
        {
            break;      // iMRU will point to matching entry
        }
    }
    // move MRU strings before this one down
    for (; idxMRU > 0; idxMRU--)
    {
        ASSERT(idxMRU > 0);
        ASSERT(idxMRU < m_nSize);
        m_arrNames[idxMRU] = m_arrNames[idxMRU-1];
    }
    // place this one at the beginning
    m_arrNames[0] = pszPathName;

}  //*** CRecentClusterList::Add

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRecentClusterList::GetDisplayName
//
//  Routine Description:
//      Get the display name of a particular item.
//      Implemented to remove file-ness of base class' method.
//
//  Arguments:
//      strName         [OUT] String in which to return the display name.
//      nIndex          [IN] Index of item in array.
//      pszCurDir       [IN] Must be NULL.
//      nCurDir         [IN] Must be 0.
//      bAtLeastName    [IN] Not used.
//
//  Return Value:
//      TRUE    - Display name returned.
//      FALSE   - Display name not returned.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CRecentClusterList::GetDisplayName(
    CString &   strName,
    int         nIndex,
    LPCTSTR     pszCurDir,
    int         nCurDir,
    BOOL        bAtLeastName
    ) const
{
    BOOL    bSuccess = FALSE;

    ASSERT(pszCurDir == NULL);
    ASSERT(nCurDir == 0);

    UNREFERENCED_PARAMETER( pszCurDir );
    UNREFERENCED_PARAMETER( nCurDir );
    UNREFERENCED_PARAMETER( bAtLeastName );

    if (m_arrNames[nIndex].IsEmpty())
    {
        goto Cleanup;
    }

    strName = m_arrNames[nIndex];
    bSuccess = TRUE;

Cleanup:

    return bSuccess;

}  //*** CRecentClusterList::GetDisplayName

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CRecentClusterList::UpdateMenu
//
//  Routine Description:
//      Update the menu with the MRU items.
//      Implemented to remove file-ness of base class' method and to use
//      our version of GetDisplayName, since it isn't virtual.
//
//  Arguments:
//      pCmdUI      [IN OUT] Command routing object.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CRecentClusterList::UpdateMenu(CCmdUI * pCmdUI)
{
    ASSERT(m_arrNames != NULL);

    CMenu * pMenu = pCmdUI->m_pMenu;
    CString strName;
    CString strTemp;

    if (m_strOriginal.IsEmpty() && pMenu != NULL)
    {
        pMenu->GetMenuString(pCmdUI->m_nID, m_strOriginal, MF_BYCOMMAND);
    }

    if (m_arrNames[0].IsEmpty())
    {
        // no MRU files
        if (!m_strOriginal.IsEmpty())
        {
            pCmdUI->SetText(m_strOriginal);
        }
        pCmdUI->Enable(FALSE);
        goto Cleanup;
    }

    if (pCmdUI->m_pMenu == NULL)
    {
        goto Cleanup;
    }

    for (int iMRU = 0; iMRU < m_nSize; iMRU++)
    {
        pCmdUI->m_pMenu->DeleteMenu(pCmdUI->m_nID + iMRU, MF_BYCOMMAND);
    }

    for (iMRU = 0; iMRU < m_nSize; iMRU++)
    {
        if (!GetDisplayName(strName, iMRU, NULL, 0))
        {
            break;
        }

        // double up any '&' characters so they are not underlined
        LPCTSTR lpszSrc = strName;
        LPTSTR lpszDest = strTemp.GetBuffer(strName.GetLength()*2);
        while (*lpszSrc != 0)
        {
            if (*lpszSrc == '&')
            {
                *lpszDest++ = '&';
            }
            if (_istlead(*lpszSrc))
            {
                *lpszDest++ = *lpszSrc++;
            }
            *lpszDest++ = *lpszSrc++;
        }
        *lpszDest = 0;
        strTemp.ReleaseBuffer();

        // insert mnemonic + the file name
        TCHAR szBuf[10];
        HRESULT hr = StringCchPrintf( szBuf, RTL_NUMBER_OF( szBuf ), _T("&%d "), (iMRU+1+m_nStart) % 10 );
        ASSERT( SUCCEEDED( hr ) );
        pCmdUI->m_pMenu->InsertMenu(pCmdUI->m_nIndex++,
            MF_STRING | MF_BYPOSITION, pCmdUI->m_nID++,
            CString(szBuf) + strTemp);
    }

    // update end menu count
    pCmdUI->m_nIndex--; // point to last menu added
    pCmdUI->m_nIndexMax = pCmdUI->m_pMenu->GetMenuItemCount();

    pCmdUI->m_bEnableChanged = TRUE;    // all the added items are enabled

Cleanup:

    return;

}  //*** CRecentFileList::UpdateMenu
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\cluster\admin\cluadmin\clusprop.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2002 Microsoft Corporation
//
//  Module Name:
//      ClusProp.cpp
//
//  Abstract:
//      Implementation of the cluster property sheet and pages.
//
//  Author:
//      David Potter (davidp)   May 13, 1996
//
//  Revision History:
//      George Potts (gpotts)   May 31, 2001
//          Partial rewrite of CClusterQuorumPage.
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClusProp.h"
#include "Cluster.h"
#include "Res.h"
#include "ClusDoc.h"
#include "ClusItem.inl"
//#include "EditAcl.h"
#include "DDxDDv.h"
#include "ExcOper.h"
#include "HelpData.h"   // g_rghelpmapClusterGeneral
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClusterPropSheet
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CClusterPropSheet, CBasePropertySheet)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterPropSheet, CBasePropertySheet)
    //{{AFX_MSG_MAP(CClusterPropSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::CClusterPropSheet
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      pParentWnd  [IN OUT] Parent window for this property sheet.
//      iSelectPage [IN] Page to show first.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterPropSheet::CClusterPropSheet(
    IN OUT CWnd *       pParentWnd,
    IN UINT             iSelectPage
    )
    : CBasePropertySheet(pParentWnd, iSelectPage)
{
    m_rgpages[0] = &PageGeneral();
    m_rgpages[1] = &PageQuorum();
    m_rgpages[2] = &PageNetPriority();

}  //*** CClusterPropSheet::CClusterPropSheet

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::BInit
//
//  Routine Description:
//      Initialize the property sheet.
//
//  Arguments:
//      pci         [IN OUT] Cluster item whose properties are to be displayed.
//      iimgIcon    [IN] Index in the large image list for the image to use
//                    as the icon on each page.
//
//  Return Value:
//      TRUE        Property sheet initialized successfully.
//      FALSE       Error initializing property sheet.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterPropSheet::BInit(
    IN OUT CClusterItem *   pci,
    IN IIMG                 iimgIcon
    )
{
    BOOL    bSuccess = FALSE;

    // Call the base class method.
    if (!CBasePropertySheet::BInit(pci, iimgIcon))
    {
        goto Cleanup;
    }

    // Set the read-only flag if the handles are invalid.
    if (    (PciCluster()->Hcluster() == NULL)
        ||  (PciCluster()->Hkey() == NULL))
    {
        m_bReadOnly = TRUE;
    }

    bSuccess = TRUE;

Cleanup:

    return bSuccess;

}  //*** CClusterPropSheet::BInit

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::Ppages
//
//  Routine Description:
//      Returns the array of pages to add to the property sheet.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Page array.
//
//--
/////////////////////////////////////////////////////////////////////////////
CBasePropertyPage ** CClusterPropSheet::Ppages(void)
{
    return m_rgpages;

}  //*** CClusterPropSheet::Ppages

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterPropSheet::Cpages
//
//  Routine Description:
//      Returns the count of pages in the array.
//
//  Arguments:
//      None.
//
//  Return Value:
//      Count of pages in the array.
//
//--
/////////////////////////////////////////////////////////////////////////////
int CClusterPropSheet::Cpages(void)
{
    return RTL_NUMBER_OF( m_rgpages );

}  //*** CClusterPropSheet::Cpages


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterGeneralPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterGeneralPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterGeneralPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterGeneralPage)
//  ON_BN_CLICKED(IDC_PP_CLUS_PERMISSIONS, OnBnClickedPermissions)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_CLUS_NAME, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_CLUS_DESC, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::CClusterGeneralPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterGeneralPage::CClusterGeneralPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_GENERAL)
{
    //{{AFX_DATA_INIT(CClusterGeneralPage)
    m_strName = _T("");
    m_strDesc = _T("");
    m_strVendorID = _T("");
    m_strVersion = _T("");
    //}}AFX_DATA_INIT

//  m_bSecurityChanged = FALSE;

}  //*** CClusterGeneralPage::CClusterGeneralPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::~CClusterGeneralPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterGeneralPage::~CClusterGeneralPage(void)
{
}  //*** CClusterGeneralPage::~CClusterGeneralPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL        bSuccess;
    CWaitCursor wc;

    ASSERT_KINDOF(CClusterPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    try
    {
        m_strName = PciCluster()->StrName();
        m_strDesc = PciCluster()->StrDescription();
        m_strVendorID = PciCluster()->Cvi().szVendorId;
        m_strVersion.Format( IDS_OP_VERSION_NUMBER_FORMAT, PciCluster()->Cvi().MajorVersion );
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        m_bReadOnly = TRUE;
    }  // catch:  CException

    return bSuccess;

}  //*** CClusterGeneralPage::BInit

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterGeneralPage::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;
    CString     strClusName;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterGeneralPage)
    DDX_Control(pDX, IDC_PP_CLUS_NAME, m_editName);
    DDX_Control(pDX, IDC_PP_CLUS_DESC, m_editDesc);
    DDX_Text(pDX, IDC_PP_CLUS_DESC, m_strDesc);
    DDX_Text(pDX, IDC_PP_CLUS_VENDOR_ID, m_strVendorID);
    DDX_Text(pDX, IDC_PP_CLUS_VERSION, m_strVersion);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if ( ! BReadOnly() )
        {
            CLRTL_NAME_STATUS cnStatus;

            //
            // Get the name from the control into a temp variable
            //
            DDX_Text(pDX, IDC_PP_CLUS_NAME, strClusName);
            DDV_RequiredText(pDX, IDC_PP_CLUS_NAME, IDC_PP_CLUS_NAME_LABEL, strClusName);

            if ( strClusName != m_strName )
            {
                if ( !ClRtlIsNetNameValid(strClusName, &cnStatus, FALSE /*CheckIfExists*/) )
                {
                    CString     strMsg;
                    UINT        idsError;

                    switch (cnStatus)
                    {
                        case NetNameTooLong:
                            idsError = IDS_INVALID_CLUSTER_NAME_TOO_LONG;
                            break;
                        case NetNameInvalidChars:
                            idsError = IDS_INVALID_CLUSTER_NAME_INVALID_CHARS;
                            break;
                        case NetNameInUse:
                            idsError = IDS_INVALID_CLUSTER_NAME_IN_USE;
                            break;
                        case NetNameDNSNonRFCChars:
                            idsError = IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS;
                            break;
                        case NetNameSystemError:
                        {
                            DWORD scError = GetLastError();
                            CNTException nte(scError, IDS_ERROR_VALIDATING_NETWORK_NAME, (LPCWSTR) strClusName);
                            nte.ReportError();
                            pDX->Fail();
                        }
                        default:
                            idsError = IDS_INVALID_CLUSTER_NAME;
                            break;
                    }  // switch:  cnStatus

                    strMsg.LoadString(idsError);

                    if ( idsError == IDS_INVALID_CLUSTER_NAME_INVALID_DNS_CHARS )
                    {
                        int id = AfxMessageBox(strMsg, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION );

                        if ( id == IDNO )                   
                        {
                            strMsg.Empty();
                            pDX->Fail();
                        }
                    }
                    else                
                    {
                        AfxMessageBox(strMsg, MB_ICONEXCLAMATION);
                        strMsg.Empty(); // exception prep
                        pDX->Fail();
                    }

                }  // if: an invalid network name was specified

                m_strName = strClusName;

            } // if: cluster name has changed

        } // if: not read only
    }  // if:  getting data from the dialog
    else
    {
        //
        // populate the control with data from the member variable
        //
        DDX_Text(pDX, IDC_PP_CLUS_NAME, m_strName);
    }  // else:  setting data to the dialog

}  //*** CClusterGeneralPage::DoDataExchange

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // Set limits on the edit controls.
    m_editName.SetLimitText(MAX_CLUSTERNAME_LENGTH);

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_editName.SetReadOnly(TRUE);
        m_editDesc.SetReadOnly(TRUE);
    }  // if:  sheet is read-only

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterGeneralPage::OnInitDialog

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnSetActive
//
//  Routine Description:
//      Handler for the PSN_SETACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully initialized.
//      FALSE   Page not initialized.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnSetActive(void)
{
    return CBasePropertyPage::OnSetActive();

}  //*** CClusterGeneralPage::OnSetActive

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnKillActive
//
//  Routine Description:
//      Handler for the PSN_KILLACTIVE message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page focus successfully killed.
//      FALSE   Error killing page focus.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnKillActive(void)
{
    return CBasePropertyPage::OnKillActive();

}  //*** CClusterGeneralPage::OnKillActive

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterGeneralPage::OnApply(void)
{
    // Set the data from the page in the cluster item.
    try
    {
        CWaitCursor wc;

        PciCluster()->SetDescription(m_strDesc);
        PciCluster()->SetName(m_strName);
    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        return FALSE;
    }  // catch:  CException

    return CBasePropertyPage::OnApply();

}  //*** CClusterGeneralPage::OnApply
/*
/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterGeneralPage::OnBnClickedPermissions
//
//  Routine Description:
//      Handler for the BN_CLICKED message on the Permissions push button.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterGeneralPage::OnBnClickedPermissions(void)
{
    LONG                    lResult;
    BOOL                    bSecDescModified;
    PSECURITY_DESCRIPTOR    psec = NULL;
    CString                 strServer;
    CResource *             pciRes = NULL;
    CWaitCursor             wc;

    // Find the cluster name resource.
    {
        POSITION    pos;

        pos = PciCluster()->Pdoc()->LpciResources().GetHeadPosition();
        while (pos != NULL)
        {
            pciRes = (CResource *) PciCluster()->Pdoc()->LpciResources().GetNext(pos);
            ASSERT_VALID(pciRes);

            if (   (pciRes->StrRealResourceType().CompareNoCase(CLUS_RESTYPE_NAME_NETNAME))
                && pciRes->BCore() )
            {
                break;
            }
            pciRes = NULL;
        }  // while:  more resources in the list
        ASSERT(pciRes != NULL);
    }  // Find the cluster name resource

    strServer.Format(_T("\\\\%s"), PciCluster()->StrName());

    lResult = EditClusterAcl(
                    m_hWnd,
                    strServer,
                    PciCluster()->StrName(),
                    pciRes->StrOwner(),
                    m_psec,
                    &bSecDescModified,
                    &psec
                    );

    if (bSecDescModified)
    {
        delete [] m_psec;
        m_psec = psec;
        m_bSecurityChanged = TRUE;
        SetModified(TRUE);
    }  // if:  data changed

}  //*** CClusterGeneralPage::OnBnClickedPermissions
*/

//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterQuorumPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterQuorumPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterQuorumPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterQuorumPage)
    ON_CBN_DBLCLK(IDC_PP_CLUS_QUORUM_RESOURCE, OnDblClkQuorumResource)
    ON_CBN_SELCHANGE(IDC_PP_CLUS_QUORUM_RESOURCE, OnChangeQuorumResource)
    ON_CBN_SELCHANGE(IDC_PP_CLUS_QUORUM_PARTITION, OnChangePartition)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_PP_CLUS_QUORUM_ROOT_PATH, CBasePropertyPage::OnChangeCtrl)
    ON_EN_CHANGE(IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, CBasePropertyPage::OnChangeCtrl)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::CClusterQuorumPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterQuorumPage::CClusterQuorumPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_QUORUM)
{
    //{{AFX_DATA_INIT(CClusterQuorumPage)
    m_nMaxLogSize = 0;
    //}}AFX_DATA_INIT

    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    m_bControlsInitialized = FALSE;

    m_nSavedLogSize = 0;

}  //*** CClusterQuorumPage::CClusterQuorumPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::~CClusterQuorumPage
//
//  Routine Description:
//      Destructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterQuorumPage::~CClusterQuorumPage(void)
{
    delete [] m_pbDiskInfo;

}  //*** CClusterQuorumPage::~CClusterQuorumPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnDestroy(void)
{
    // If the controls have been initialized, clear the resource combobox.
    if ( BControlsInitialized() )
    {
        ClearResourceList();
        ClearPartitionList();
    }

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = NULL;
    m_cbDiskInfo = 0;

    // Call the base class method.
    CBasePropertyPage::OnDestroy();

}  //*** CClusterQuorumPage::OnDestroy

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::BInit
//
//  Routine Description:
//      Initialize the page.
//
//  Arguments:
//      psht        [IN OUT] Property sheet to which this page belongs.
//
//  Return Value:
//      TRUE        Page initialized successfully.
//      FALSE       Page failed to initialize.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::BInit(IN OUT CBaseSheet * psht)
{
    BOOL        bSuccess;
    CWaitCursor wc;
    CResource * pciRes = NULL;

    ASSERT_KINDOF(CClusterPropSheet, psht);

    bSuccess = CBasePropertyPage::BInit(psht);

    try
    {
        // Get the current quorum resource.
        m_strQuorumResource = PciCluster()->StrQuorumResource();

        pciRes = (CResource *) PciCluster()->Pdoc()->LpciResources().PciResFromName( m_strQuorumResource );
        ASSERT_VALID( pciRes );

        SplitRootPath(  
                        pciRes, 
                        m_strPartition.GetBuffer( _MAX_PATH ),
                        _MAX_PATH,
                        m_strRootPath.GetBuffer( _MAX_PATH ),
                        _MAX_PATH
                     );

        m_strPartition.ReleaseBuffer();
        m_strRootPath.ReleaseBuffer();

        m_nMaxLogSize = (PciCluster()->NMaxQuorumLogSize() + 1023) / 1024;

        m_strSavedResource = m_strQuorumResource; 
        m_strSavedPartition = m_strPartition;
        m_strSavedRootPath = m_strRootPath;
        m_nSavedLogSize = m_nMaxLogSize;

    }  // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
        m_bReadOnly = TRUE;

    }  // catch:  CException

    return bSuccess;

}  //*** CClusterQuorumPage::BInit

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::DoDataExchange(CDataExchange * pDX)
{
    CWaitCursor wc;

    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterQuorumPage)
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_editMaxLogSize);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, m_editRootPath);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_PARTITION, m_cboxPartition);
    DDX_Control(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, m_cboxQuorumResource);
    DDX_CBString(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, m_strQuorumResource);
    DDX_CBString(pDX, IDC_PP_CLUS_QUORUM_PARTITION, m_strPartition);
    DDX_Text(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, m_strRootPath);
    DDX_Text(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_nMaxLogSize);
    //}}AFX_DATA_MAP

    if ( m_bControlsInitialized == FALSE )
    {
        FillResourceList();
        m_bControlsInitialized = TRUE;
    }

    if (pDX->m_bSaveAndValidate || !BReadOnly())
    {
        DDX_Number(pDX, IDC_PP_CLUS_QUORUM_MAX_LOG_SIZE, m_nMaxLogSize, 1, 0xffffffff / 1024);
    }

    if (pDX->m_bSaveAndValidate)
    {
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_RESOURCE, IDC_PP_CLUS_QUORUM_RESOURCE_LABEL, m_strQuorumResource);
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_PARTITION, IDC_PP_CLUS_QUORUM_PARTITION_LABEL, m_strPartition);
        DDV_RequiredText(pDX, IDC_PP_CLUS_QUORUM_ROOT_PATH, IDC_PP_CLUS_QUORUM_ROOT_PATH_LABEL, m_strRootPath);
    }  // if:  getting data from the dialog

}  //*** CClusterQuorumPage::DoDataExchange

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::OnInitDialog(void)
{
    // Call the base class method.
    CBasePropertyPage::OnInitDialog();

    // If read-only, set all controls to be either disabled or read-only.
    if (BReadOnly())
    {
        m_cboxQuorumResource.EnableWindow(FALSE);
        m_cboxPartition.EnableWindow(FALSE);
        m_editRootPath.SetReadOnly();
        m_editMaxLogSize.SetReadOnly();
    }  // if:  sheet is read-only
    else
    {
        m_editRootPath.SetLimitText( _MAX_PATH );
    }

    return FALSE;   // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterQuorumPage::OnInitDialog

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::OnApply(void)
{
    CWaitCursor             wc;
    CString                 strQuorumPath;
    CString                 strTemp;
    CString *               pstrPartition = NULL;
    CResource *             pciRes = NULL;
    int                     nSelected;
    int                     nCount;
    SResourceItemData *     prid = NULL;
    CLUSTER_RESOURCE_STATE  crs = ClusterResourceStateUnknown;
    BOOL                    bSuccess = FALSE;

    //
    // Get the currently selected resource from the combo box.
    //
    nSelected = m_cboxQuorumResource.GetCurSel();
    nCount = m_cboxQuorumResource.GetCount();

    if ( nSelected != CB_ERR && 0 < nCount )
    {
        prid = (SResourceItemData *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
        ASSERT( prid != NULL );
        
        pciRes = prid->pciRes; 
        ASSERT_VALID( pciRes );
        ASSERT_KINDOF( CResource, pciRes );
    }

    nCount = m_cboxPartition.GetCurSel();
    pstrPartition = (CString *) m_cboxPartition.GetItemDataPtr( nCount ); 

    if ( pstrPartition == NULL )
    {
        // No partition was selected - bring this up before asking to bring the resource online
        AfxMessageBox( IDS_SELECT_QUORUM_RESOURCE_PARTITION_ERROR, MB_OK | MB_ICONEXCLAMATION );
        goto Cleanup;
    }

    //
    // Return TRUE if everything matches - nothing changed, so don't do anything.  We get
    // an OnApply for both Apply and OK buttons, so they may have hit apply then OK.
    //
    if (( m_strSavedResource == m_strQuorumResource ) &&
        ( m_strSavedPartition == *pstrPartition ) &&
        ( m_strSavedRootPath == m_strRootPath ) &&
        ( m_nSavedLogSize == m_nMaxLogSize )   )
    {
        bSuccess = TRUE;
        goto Cleanup;
    }
    else // debug message boxes
    {
#ifdef _DEBUG
        if ( m_strSavedResource != m_strQuorumResource ) 
        {
            MessageBox( m_strSavedResource + "  " + m_strQuorumResource, L"Resource", MB_OK );
        }
    
        if ( m_strSavedPartition != *pstrPartition ) 
        {
            MessageBox( m_strSavedPartition + "  " + *pstrPartition, L"Partition", MB_OK );
        }
    
        if ( m_strSavedRootPath != m_strRootPath ) 
        {
            MessageBox( m_strSavedRootPath + "  " + m_strRootPath, L"RootPath", MB_OK );
        }
    
        if ( m_nSavedLogSize != m_nMaxLogSize ) 
        {
            CString Temp;
            Temp.Format( L"MaxLogSize: %d %d", m_nSavedLogSize, m_nMaxLogSize );
            MessageBox( Temp, L"LogSize", MB_OK );
        }
#endif // _DEBUG
    }

    //
    // If we successfully retrieved a resource make sure it's online.
    //
    if ( pciRes != NULL )
    {
        crs = pciRes->Crs();
    
        if ( ClusterResourceOnline != crs )
        {
            //
            // Prompt the user whether or not they'd like to online the resource.
            //
            strTemp.FormatMessage( IDS_ONLINE_QUORUM_RESOURCE_PROMPT, pciRes->StrName() );
            if ( AfxMessageBox( strTemp, MB_YESNO | MB_ICONQUESTION ) == IDYES )
            {
                CWaitForResourceOnlineDlg  dlg( pciRes, AfxGetMainWnd() );
                pciRes->OnCmdBringOnline();
        
                dlg.DoModal();
                
                crs = pciRes->Crs();
            }
            else
            {
                goto Cleanup;
            }
        } // if: resource !online 

    } // if: pciRes !NULL
    else
    {
        // No resource was selected - this should never happen. 
        AfxMessageBox( IDS_SELECT_QUORUM_RESOURCE_ERROR, MB_OK | MB_ICONEXCLAMATION );
        goto Cleanup;
    }
    
    // Set the data from the page in the cluster item.
    if ( crs == ClusterResourceOnline )
    {
        try {
            strTemp = *pstrPartition;

            if ( !m_strRootPath.IsEmpty() )
            {
                //
                // Concatenate the strings before calling SetQuorumResource, but make sure that 
                // there is only one backslash between them.
                //
                if ( strTemp.Right( 1 ) != _T("\\") && m_strRootPath.Left( 1 ) != _T("\\") )
                {
                    strTemp += _T('\\');
                }
                else if ( strTemp.Right( 1 ) == _T("\\") && m_strRootPath.Left( 1 ) == _T("\\") )
                {
                    strTemp.TrimRight( _T("\\") );
                }
            } // if: neither string is empty
    
            strQuorumPath.Format( _T("%s%s"), strTemp, m_strRootPath );

            PciCluster()->SetQuorumResource(
                                m_strQuorumResource,
                                strQuorumPath,
                                (m_nMaxLogSize * 1024)
                                );

            m_strSavedResource = m_strQuorumResource;
            m_strSavedPartition = *pstrPartition;
            m_strSavedRootPath = m_strRootPath;
            m_nSavedLogSize = m_nMaxLogSize;

        }  // try
        catch (CException * pe)
        {
            pe->ReportError();
            pe->Delete();
            strQuorumPath.Empty();
            goto Cleanup;
        }  // catch:  CException

    } // if: the resource is online

    bSuccess = CBasePropertyPage::OnApply();

Cleanup:

    return bSuccess;

}  //*** CClusterQuorumPage::OnApply

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnDblClkQuorumResource
//
//  Routine Description:
//      Handler for the CBN_DBLCLK message on the Quorum Resource combo box.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnDblClkQuorumResource(void)
{
    int         nSelected;
    CResource * pciRes;

    // Get the selected resource.
    nSelected = m_cboxQuorumResource.GetCurSel();
    ASSERT(nSelected != CB_ERR);

    // Get the resource object.
    pciRes = (CResource *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
    ASSERT_VALID(pciRes);
    ASSERT_KINDOF(CResource, pciRes);

    // Display properties for the resource.
    pciRes->OnCmdProperties();

}  //*** CClusterQuorumPage::OnDblClkQuorumResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnChangeQuorumResource
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Quorum Resource combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnChangeQuorumResource(void)
{
    int                     nSelected;
    CResource *             pciRes;
    CString *               pstrPartition = NULL;
    SResourceItemData *     prid = NULL;

    OnChangeCtrl();

    // First, save the root path as it appears on the screen.
    m_editRootPath.GetLine( 0, m_strRootPath.GetBuffer( _MAX_PATH ) );
    m_strRootPath.ReleaseBuffer();

    // Get the selected resource.
    nSelected = m_cboxQuorumResource.GetCurSel();
    ASSERT(nSelected != CB_ERR);

    // Get the item data object.
    prid = (SResourceItemData *) m_cboxQuorumResource.GetItemDataPtr(nSelected);
    ASSERT( prid != NULL );

    // Get the resource object.
    pciRes = prid->pciRes;
    ASSERT_VALID( pciRes );
    ASSERT_KINDOF( CResource, pciRes );

    // Set the partition object to the remembered value.
    FillPartitionList( pciRes );
    m_cboxPartition.SetCurSel( prid->nIndex );

    UpdateData(TRUE /*bSaveAndValidate*/);

}  //*** CClusterQuorumPage::OnChangeQuorumResource

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::ClearResourceList
//
//  Routine Description:
//      Clear the resource list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::ClearResourceList(void)
{
    int                 cItems;
    int                 iItem;
    CResource *         pciRes = NULL;
    SResourceItemData * prid = NULL;

    cItems = m_cboxQuorumResource.GetCount();
    for (iItem = 0 ; iItem < cItems ; iItem++)
    {
        prid = (SResourceItemData *) m_cboxQuorumResource.GetItemDataPtr(iItem);
        ASSERT( prid != NULL );

        pciRes = prid->pciRes;
        ASSERT_VALID(pciRes);
        ASSERT_KINDOF(CResource, pciRes);
        pciRes->Release();

        delete prid;
    }  // for:  each item in the list

    m_cboxQuorumResource.ResetContent();

}  //*** CClusterQuorumPage::ClearResourceList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::FillResourceList
//
//  Routine Description:
//      Fill the quorum resource combobox with all resources and select
//      the quorum resource.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::FillResourceList(void)
{
    POSITION            pos;
    int                 nIndex;
    CResource *         pciRes;
    CResource *         pciSelected = NULL;
    int                 nSelectedIndex = 0;
    SResourceItemData * prid = NULL;
    CWaitCursor         wc;

    // Clear the list.
    ClearResourceList();

    pos = PciCluster()->Pdoc()->LpciResources().GetHeadPosition();
    while (pos != NULL)
    {
        // Get the next resource.
        pciRes = (CResource *) PciCluster()->Pdoc()->LpciResources().GetNext(pos);
        ASSERT_VALID(pciRes);
        ASSERT_KINDOF(CResource, pciRes);

        // If it is quorum capable, add it to the list.
        try
        {
            prid = NULL;

            // We up the ref count here and if an exception occurs we Release it.
            // If it's a resource that we don't want to list we simple Release in the else.
            pciRes->AddRef();

            //
            // If the resource is not online we can not set it to be the quorum because
            // the service won't allow us to.  Instead we require that the user online
            // the resource beforehand.  (The quorum must ALWAYS be online when the 
            // service is running.)
            //
            if ( (pciRes->BQuorumCapable()) && (pciRes->Crs() == ClusterResourceOnline) )
            {
                // Allocate a new rpid for the data item.
                prid = new SResourceItemData;
                if ( prid == NULL )
                {
                    AfxThrowMemoryException();
                }

                prid->pciRes = pciRes;
                prid->nIndex = 0;

                nIndex = m_cboxQuorumResource.AddString( pciRes->StrName() );
                ASSERT(nIndex != CB_ERR);

                // Add a data item to correspond with the string
                m_cboxQuorumResource.SetItemDataPtr( nIndex, prid );
                prid = NULL;

                if ( m_strQuorumResource.CompareNoCase( pciRes->StrName() ) == 0 )
                {
                    pciSelected = pciRes;
                    nSelectedIndex = nIndex;
                }

            }  // if:  resource can be a quorum resource
            else
            {
                pciRes->Release();
            }

        }  // try
        catch ( ... )
        {
            // Since an error occurred - make sure we release the resource.
            pciRes->Release();
            delete prid;

            throw; 

        } // catch: anything

    }  // while:  more items in the list

    // Check if the currently selected device is in the list of quorum capable resources.
    // If so select it and fill in the partition table accordingly.
    if ( pciSelected != NULL )
    {
        int nPartitionIndex;

        // Select the quorum resource in the drop down.
        VERIFY( m_cboxQuorumResource.SetCurSel( nSelectedIndex ) != CB_ERR );
        FillPartitionList( pciSelected );
        
        //
        // Select the current quorum partition in it's drop down.
        // If we can't find it in the list simply leave the selection as 
        // the first partition (default behavior from FillPartitionList).
        //
        nPartitionIndex = m_cboxPartition.FindString( -1, m_strSavedPartition );

        if( CB_ERR != nPartitionIndex )
        {
            VERIFY( m_cboxPartition.SetCurSel( nPartitionIndex ) != CB_ERR );
        }
    }
    else
    {
        // There is nothing we can do in this case. There is something seriously wrong
        // with the cluster.
        CNTException nte(
                        ERROR_QUORUM_DISK_NOT_FOUND,
                        IDS_GET_QUORUM_DEVICES_ERROR
                        );
        nte.ReportError();
    } // else: the current quorum device is not in the list of quorum capable resources

}  //*** CClusterQuorumPage::FillResourceList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::ClearPartitionList
//
//  Routine Description:
//      Clear the partition list and release references to pointers.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::ClearPartitionList(void)
{
    int                     cItems;
    int                     iItem;
    CString *               pstrPartition = NULL;

    cItems = m_cboxPartition.GetCount();
    for ( iItem = 0 ; iItem < cItems ; iItem++ )
    {
        pstrPartition = (CString *) m_cboxPartition.GetItemDataPtr( iItem );
        delete pstrPartition;

    }  // for:  each item in the list

    m_cboxPartition.ResetContent();

}  //*** CClusterQuorumPage::ClearPartitionList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::FillPartitionList
//
//  Routine Description:
//      Fill the partition combobox with all partitions available on the
//      currently selected quorum resource.
//
//  Arguments:
//      pciRes      [IN OUT] Currently selected quorum resource.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::FillPartitionList(IN OUT CResource * pciRes)
{
    CString                 strPartitionInfo;
    CLUSPROP_BUFFER_HELPER  buf;
    DWORD                   cbData;
    DWORD                   cbBuf;
    int                     nIndex;
    CString *               pstrPartition = NULL;
    CWaitCursor             wc;
    SResourceItemData *     prid = NULL;

    ASSERT_VALID(pciRes);

    // Clear the list.
    ClearPartitionList();

    // Get the currently selected resource so that we can get its SResourceItemData
    // from which we'll be able to get the currently selected partition preference.
    nIndex = m_cboxQuorumResource.GetCurSel();
    if ( nIndex == CB_ERR )
    {
        nIndex = 0;
    }

    prid = (SResourceItemData *) m_cboxQuorumResource.GetItemDataPtr( nIndex );
    ASSERT( prid != NULL );

    // Get disk info for this resource.
    if ( BGetDiskInfo( *pciRes ) )
    {
        buf.pb = m_pbDiskInfo;
        cbBuf = m_cbDiskInfo;

        while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
        {
            // Calculate the size of the value.
            cbData = sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);
            ASSERT(cbData <= cbBuf);

            // Parse the value.
            if (buf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
            {
                // Add the partition to the combobox if it is a usable partition
                // and it hasn't been added already.
                if (   (buf.pPartitionInfoValue->dwFlags & CLUSPROP_PIFLAG_USABLE)
                    && (m_cboxPartition.FindString(-1, buf.pPartitionInfoValue->szDeviceName) == CB_ERR))
                {
                    try
                    {
                        pstrPartition = new CString;
                        if ( pstrPartition != NULL )
                        {
    
                            *pstrPartition = buf.pPartitionInfoValue->szDeviceName;
    
                            // Construct the name to display to the user
                            // and add the item to the combobox.
                            strPartitionInfo.Format(
                                    ( buf.pPartitionInfoValue->szVolumeLabel[ 0 ] ? _T("%ls (%ls) ") : _T("%ls") ),
                                    *pstrPartition,
                                    buf.pPartitionInfoValue->szVolumeLabel
                                    );

                            nIndex = m_cboxPartition.AddString( strPartitionInfo );
                            ASSERT( nIndex != CB_ERR );
    
                            m_cboxPartition.SetItemDataPtr( nIndex, pstrPartition );
                        }
                    }  // try
                    catch (...)
                    {
                        delete pstrPartition;
                        pstrPartition = NULL;

                        throw;

                    }  // catch:  Anything

                }  // if:  partition not added yet

            }  // if:  partition info

            // Advance the buffer pointer
            buf.pb += cbData;
            cbBuf -= cbData;
        }  // while:  more values
    }  // if:  got disk info successfully
    else
    {
        // We were not able to retrieve the disk info.  BGetDiskInfo throws a message box in this case.
    }

    if ( prid != NULL )
    {
        // Select the current partition in the list.
        // By default the prid is set to NULL, so the first entry will be selected unless
        // something else (OnChangePartition) changed prid->nIndex
        m_cboxPartition.SetCurSel( prid->nIndex );
    }

}  //*** CClusterQuorumPage::FillPartitionList

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::OnChangePartition
//
//  Routine Description:
//      Handler for the CBN_SELCHANGE message on the Partition combobox.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::OnChangePartition(void)
{
    int                     nSelected;
    SResourceItemData *     prid = NULL;

    OnChangeCtrl();

    // First, save the root path as it appears on the screen.
    m_editRootPath.GetLine( 0, m_strRootPath.GetBuffer( _MAX_PATH ) );
    m_strRootPath.ReleaseBuffer();

    // Get the current resource so that we can get it's SResourceItemData and
    // update the partition index.
    nSelected = m_cboxQuorumResource.GetCurSel();
    ASSERT( nSelected != CB_ERR );

    prid = (SResourceItemData *) m_cboxQuorumResource.GetItemDataPtr( nSelected );
    ASSERT( prid != NULL );

    // Update the partition index.
    prid->nIndex = m_cboxPartition.GetCurSel(); 

    UpdateData( TRUE /*bSaveAndValidate*/ );

}  //*** CClusterQuorumPage::OnChangePartition

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::SplitRootPath
//
//  Routine Description:
//      Take the current quorum path (from GetClusterQuorumResource) and compare
//      it to the device names returned from the resource.  From this take the
//      additional path from the quorum path and set that as our root path.
//
//      It is expected that the IN buffers are at least of size _MAX_PATH.
//
//  Arguments:
//      pciResIn            Current quorum resource.
//      pszPartitionNameOut Partition name buffer to fill.  
//      cchPartitionIn      Max char count of buffer.
//      pszRootPathOut      Root path buffer to fill.  
//      cchRootPathIn       Max char count of buffer. 
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterQuorumPage::SplitRootPath(
    CResource * pciResIn,
    LPTSTR      pszPartitionNameOut,
    DWORD       cchPartitionIn,
    LPTSTR      pszRootPathOut,
    DWORD       cchRootPathIn
    )
{
    CString                 strQuorumPath;
    CString                 strTemp;
    CLUSPROP_BUFFER_HELPER  buf;
    DWORD                   cbData;
    DWORD                   cbBuf;
    size_t                  cchDeviceName;
    WCHAR *                 pszDevice;
    HRESULT                 hr;

    ASSERT_VALID(pciResIn);
    ASSERT( pszPartitionNameOut != NULL );
    ASSERT( pszRootPathOut != NULL );

    strQuorumPath = PciCluster()->StrQuorumPath();

    // Get disk info for this resource.
    if (BGetDiskInfo(*pciResIn))
    {
        buf.pb = m_pbDiskInfo;
        cbBuf = m_cbDiskInfo;

        while (buf.pSyntax->dw != CLUSPROP_SYNTAX_ENDMARK)
        {
            // Calculate the size of the value.
            cbData = sizeof(*buf.pValue) + ALIGN_CLUSPROP(buf.pValue->cbLength);
            ASSERT(cbData <= cbBuf);

            // Parse the value.
            if (buf.pSyntax->dw == CLUSPROP_SYNTAX_PARTITION_INFO)
            {
                //
                // A resource may have multiple partitions defined - make sure that ours matches the quorum path.
                // For any partition that is an SMB share we have to be careful - the quorum path may differ from the device name
                // by the first 8 characters - "\\" vs. "\\?\UNC\".  If it's an SMB path do special parsing, otherwise compare
                // the beginning of the quorum path against the full device name.  The reason for this is 
                // that SetClusterQuorumResource will convert any given SMB path to a UNC path.
                //

                // Make it easier to follow.
                pszDevice = buf.pPartitionInfoValue->szDeviceName;

                if ( (wcslen( pszDevice ) >= 2) &&
                     (ClRtlStrNICmp( L"\\\\", pszDevice, 2 ) == 0 ) )
                {
                    // Everything is defined as LPTSTRs except buf.
                    ASSERT( sizeof( TCHAR ) == sizeof( WCHAR ) );

                    // SMB and UNC paths always lead off with two leading backslashes - remove these from the 
                    // partition name since a compare of "\\<part>" and "\\?\UNC\<part>" will never match.
                    // Instead, we'll just search for "<part>" in the quorum path. 
                    strTemp = pszDevice;

                    // This will remove all leading backslashes.
                    strTemp.TrimLeft( _T("\\") );

                    // It may end with a \ - remove this if present.
                    strTemp.TrimRight( _T("\\") );

                    // Now, search strQuorumPath for the partition.
                    cchDeviceName = strQuorumPath.Find( strTemp );
                    if ( cchDeviceName != -1 )
                    {
                        // We found a match, now find the offset of the root path. 
                        cchDeviceName += strTemp.GetLength();

                        // Copy the partition and NULL terminate it.
                        hr = StringCchCopy( pszPartitionNameOut, cchPartitionIn, pszDevice );
                        ASSERT( SUCCEEDED( hr ) );

                        // Copy the root path and NULL terminate it.
                        strQuorumPath = strQuorumPath.Right( strQuorumPath.GetLength() - static_cast< int >( cchDeviceName ) );
                        hr = StringCchCopy( pszRootPathOut, cchRootPathIn, strQuorumPath );
                        ASSERT( SUCCEEDED( hr ) );

                        break;
                    }
                }
                else if ( ClRtlStrNICmp( strQuorumPath.GetBuffer( 1 ), pszDevice, wcslen( pszDevice )) == 0 ) 
                {
                    // we found a match - pszDevice is a substring of strQuorumPath
                    cchDeviceName = _tcslen( pszDevice );
                    hr = StringCchCopy( pszPartitionNameOut, cchPartitionIn, pszDevice );
                    ASSERT( SUCCEEDED( hr ) );

                    strQuorumPath = strQuorumPath.Right( strQuorumPath.GetLength() - static_cast< int >( cchDeviceName ) );
                    hr = StringCchCopy( pszRootPathOut, cchRootPathIn, strQuorumPath );
                    ASSERT( SUCCEEDED( hr ) );

                    break;

                } // if: same partition

            }  // if:  partition info

            // Advance the buffer pointer
            buf.pb += cbData;
            cbBuf -= cbData;

        }  // while:  more values

    }  // if:  got disk info successfully

    if ( *pszPartitionNameOut == _T('\0') )
    {
        hr = StringCchCopyN( pszPartitionNameOut, cchPartitionIn, PciCluster()->StrQuorumPath(), PciCluster()->StrQuorumPath().GetLength() );
        ASSERT( SUCCEEDED( hr ) );
    }  

    if ( *pszRootPathOut == _T('\0') )
    {
        hr = StringCchCopy( pszRootPathOut, cchRootPathIn, _T("\\") );
        ASSERT( SUCCEEDED( hr ) );
    }  

}  //*** CClusterQuorumPage::SplitRootPath

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterQuorumPage::BGetDiskInfo
//
//  Routine Description:
//      Get information about the currently selected disk.
//
//  Arguments:
//      rpciRes     [IN OUT] Disk resource to get info about.
//
//  Return Value:
//      TRUE        The operation was successful.
//      FALSE       The operation failed.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterQuorumPage::BGetDiskInfo( IN OUT CResource & rpciRes )
{
    DWORD   dwStatus    = ERROR_SUCCESS;
    DWORD   cbDiskInfo  = sizeof( CLUSPROP_DWORD )
                            + sizeof( CLUSPROP_SCSI_ADDRESS )
                            + sizeof( CLUSPROP_DISK_NUMBER )
                            + sizeof( CLUSPROP_PARTITION_INFO )
                            + sizeof( CLUSPROP_SYNTAX );
    PBYTE   pbDiskInfo  = NULL;
    BOOL    bSuccess = FALSE;

    try
    {
        // Get disk info.
        pbDiskInfo = new BYTE[ cbDiskInfo ];
        if ( pbDiskInfo == NULL )
        {
            AfxThrowMemoryException();
        } // if: error allocating memory
        dwStatus = ClusterResourceControl(
                        rpciRes.Hresource(),
                        NULL,
                        CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                        NULL,
                        0,
                        pbDiskInfo,
                        cbDiskInfo,
                        &cbDiskInfo
                        );
        if ( dwStatus == ERROR_MORE_DATA )
        {
            delete [] pbDiskInfo;
            pbDiskInfo = new BYTE[ cbDiskInfo ] ;
            if ( pbDiskInfo == NULL )
            {
                AfxThrowMemoryException();
            } // if: error allocating memory
            dwStatus = ClusterResourceControl(
                            rpciRes.Hresource(),
                            NULL,
                            CLUSCTL_RESOURCE_STORAGE_GET_DISK_INFO,
                            NULL,
                            0,
                            pbDiskInfo,
                            cbDiskInfo,
                            &cbDiskInfo
                            );
        }  // if:  buffer is too small
    }  // try
    catch ( CMemoryException * pme )
    {
        pme->Delete();
        dwStatus = ERROR_NOT_ENOUGH_MEMORY;
    }  // catch:  CMemoryException

    if ( dwStatus != ERROR_SUCCESS )
    {
        CNTException nte(
                        dwStatus,
                        IDS_GET_DISK_INFO_ERROR,
                        rpciRes.StrName(),
                        NULL,
                        FALSE /*bAutoDelete*/
                        );
        nte.ReportError();
        nte.Delete();
        goto Cleanup;
    }  // if:  error getting disk info

    delete [] m_pbDiskInfo;
    m_pbDiskInfo = pbDiskInfo;
    m_cbDiskInfo = cbDiskInfo;
    pbDiskInfo = NULL;
    bSuccess = TRUE;

Cleanup:

    delete [] pbDiskInfo;
    return bSuccess;

}  //*** CClusterQuorumPage::BGetDiskInfo


//*************************************************************************//


/////////////////////////////////////////////////////////////////////////////
// CClusterNetPriorityPage property page
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CClusterNetPriorityPage, CBasePropertyPage)

/////////////////////////////////////////////////////////////////////////////
// Message Maps

BEGIN_MESSAGE_MAP(CClusterNetPriorityPage, CBasePropertyPage)
    //{{AFX_MSG_MAP(CClusterNetPriorityPage)
    ON_LBN_SELCHANGE(IDC_PP_CLUS_PRIORITY_LIST, OnSelChangeList)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_UP, OnUp)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_DOWN, OnDown)
    ON_BN_CLICKED(IDC_PP_CLUS_PRIORITY_PROPERTIES, OnProperties)
    ON_WM_DESTROY()
    ON_WM_CONTEXTMENU()
    ON_LBN_DBLCLK(IDC_PP_CLUS_PRIORITY_LIST, OnDblClkList)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_FILE_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::CClusterNetPriorityPage
//
//  Routine Description:
//      Constructor.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
CClusterNetPriorityPage::CClusterNetPriorityPage(void)
    : CBasePropertyPage(IDD, g_aHelpIDs_IDD_PP_CLUSTER_NET_PRIORITY)
{
    //{{AFX_DATA_INIT(CClusterNetPriorityPage)
    //}}AFX_DATA_INIT

    m_bControlsInitialized = FALSE;

}  //*** CClusterNetPriorityPage::CClusterNetPriorityPage

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnDestroy
//
//  Routine Description:
//      Handler for the WM_DESTROY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::OnDestroy(void)
{
    // If the controls have been initialized, clear the list box.
    if (BControlsInitialized())
    {
        ClearNetworkList();
    }

    // Call the base class method.
    CBasePropertyPage::OnDestroy();

}  //*** CClusterNetPriorityPage::OnDestroy

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::DoDataExchange
//
//  Routine Description:
//      Do data exchange between the dialog and the class.
//
//  Arguments:
//      pDX     [IN OUT] Data exchange object
//
//  Return Value:
//      None.
//
//--
/////////////////////////////////////////////////////////////////////////////
void CClusterNetPriorityPage::DoDataExchange(CDataExchange* pDX)
{
    CBasePropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CClusterNetPriorityPage)
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_PROPERTIES, m_pbProperties);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_DOWN, m_pbDown);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_UP, m_pbUp);
    DDX_Control(pDX, IDC_PP_CLUS_PRIORITY_LIST, m_lbList);
    //}}AFX_DATA_MAP

    m_bControlsInitialized = TRUE;

    if (pDX->m_bSaveAndValidate)
    {
        int         nIndex;
        int         cItems;
        CNetwork *  pciNet;

        ASSERT(!BReadOnly());

        // Save the list.
        LpciNetworkPriority().RemoveAll();

        cItems = m_lbList.GetCount();
        for (nIndex = 0 ; nIndex < cItems ; nIndex++)
        {
            pciNet = (CNetwork *) m_lbList.GetItemDataPtr(nIndex);
            ASSERT_VALID(pciNet);
            LpciNetworkPriority().AddTail(pciNet);
        }  // for:  each item in the list box
    }  // if:  saving data from the dialog

}  //*** CClusterNetPriorityPage::DoDataExchange

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnInitDialog
//
//  Routine Description:
//      Handler for the WM_INITDIALOG message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE        Focus not set yet.
//      FALSE       Focus already set.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNetPriorityPage::OnInitDialog(void)
{
    CBasePropertyPage::OnInitDialog();

    if (BReadOnly())
    {
        m_lbList.EnableWindow(FALSE);
        m_pbUp.EnableWindow(FALSE);
        m_pbDown.EnableWindow(FALSE);
    }  // if:  object is read only

    try
    {
        // Duplicate the network priority list.
        {
            POSITION    pos;
            CNetwork *  pciNet;

            pos = PciCluster()->LpciNetworkPriority().GetHeadPosition();
            while (pos != NULL)
            {
                pciNet = (CNetwork *) PciCluster()->LpciNetworkPriority().GetNext(pos);
                ASSERT_VALID(pciNet);
                m_lpciNetworkPriority.AddTail(pciNet);
            }  // while:  more networks in the list
        }  // Duplicate the network priority list
    } // try
    catch (CException * pe)
    {
        pe->ReportError();
        pe->Delete();
    }  // catch:  CException

    // Fill the list.
    FillList();

    // Set button states.
    OnSelChangeList();

    return TRUE;    // return TRUE unless you set the focus to a control
                    // EXCEPTION: OCX Property Pages should return FALSE

}  //*** CClusterNetPriorityPage::OnInitDialog

/////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusterNetPriorityPage::OnApply
//
//  Routine Description:
//      Handler for the PSN_APPLY message.
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE    Page successfully applied.
//      FALSE   Error applying page.
//
//--
/////////////////////////////////////////////////////////////////////////////
BOOL CClusterNetPriorityPage::OnApply(void)
{
    ASSERT(!