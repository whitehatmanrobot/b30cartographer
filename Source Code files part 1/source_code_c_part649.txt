ess->RateKbitsPerSec &&
            (BASIC_TIMER_GRANULARITY_IN_MSECS > BITS_PER_BYTE));
    if (((pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS) / BITS_PER_BYTE) >=
        pSend->pSender->PacketBufferSize)
    {
        //
        // We have a high Send rate, so we need to increment our window every timeout
        // So, Bytes to be sent in (x) Millisecs = Rate of Bytes/Millisecs * (x)
        //
        pSend->pSender->SendTimeoutCount = 1;
    }
    else
    {
        //
        // We will set our Send timeout count based for a slow timer
        // -- enough for pAddress->OutIfMTU
        // So, Number of Timeouts of x millisecs before we can send pAddress->OutIfMTU:
        //  = Rate of Bytes/Millisecs * (x)
        //
        pSend->pSender->SendTimeoutCount = (pAddress->OutIfMTU +(pAddress->RateKbitsPerSec/BITS_PER_BYTE-1)) /
                                            ((pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS)/BITS_PER_BYTE);
        if (!pSend->pSender->SendTimeoutCount)
        {
            ASSERT (0);
            pSend->pSender->SendTimeoutCount = 1;
        }
    }
    pSend->pSender->IncrementBytesOnSendTimeout = (ULONG) (pAddress->RateKbitsPerSec *
                                                           pSend->pSender->SendTimeoutCount *
                                                           BASIC_TIMER_GRANULARITY_IN_MSECS) /
                                                           BITS_PER_BYTE;

    pSend->pSender->OriginalIncrementBytes = pSend->pSender->IncrementBytesOnSendTimeout;
    pSend->pSender->DeltaIncrementBytes = pSend->pSender->IncrementBytesOnSendTimeout >> 8;     // 1/256

    //
    // Now, set the values for the next timeout!
    //
    pSend->pSender->CurrentTimeoutCount = pSend->pSender->SendTimeoutCount;
    pSend->pSender->CurrentBytesSendable = pSend->pSender->IncrementBytesOnSendTimeout;

    //
    // Set the SPM timeouts
    //
    pSend->pSender->CurrentSPMTimeout = 0;
    pSend->pSender->AmbientSPMTimeout = AMBIENT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->InitialHeartbeatSPMTimeout = INITIAL_HEARTBEAT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->MaxHeartbeatSPMTimeout = MAX_HEARTBEAT_SPM_TIMEOUT_IN_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->HeartbeatSPMTimeout = pSend->pSender->InitialHeartbeatSPMTimeout;

    //
    // Set the Increment window settings
    //
    // TimerTickCount, LastWindowAdvanceTime and LastTrailingEdgeTime should be 0
    WindowAdvanceInMSecs = (((ULONGLONG)pAddress->WindowSizeInMSecs) * pAddress->WindowAdvancePercentage)/100;
    pSend->pSender->WindowSizeTime = pAddress->WindowSizeInMSecs / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->WindowAdvanceDeltaTime = WindowAdvanceInMSecs / BASIC_TIMER_GRANULARITY_IN_MSECS;
    pSend->pSender->NextWindowAdvanceTime = pSend->pSender->WindowSizeTime + pSend->pSender->WindowAdvanceDeltaTime;

    // Set the RData linger time!
    pSend->pSender->RDataLingerTime = RDATA_LINGER_TIME_MSECS / BASIC_TIMER_GRANULARITY_IN_MSECS;

    //
    // Set the late Joiner settings
    //
    if (pAddress->LateJoinerPercentage)
    {
        pSend->pSender->LateJoinSequenceNumbers = (SEQ_TYPE) ((pSend->pSender->MaxPacketsInBuffer *
                                                               pAddress->LateJoinerPercentage) /
                                                              (2 * 100));

        pSend->pSender->DataOptions |= PGM_OPTION_FLAG_JOIN;
        pSend->pSender->DataOptionsLength += PGM_PACKET_OPT_JOIN_LENGTH;

        pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_JOIN;
    }

    // The timer will be started when the first send comes down
    pSend->SessionFlags |= (PGM_SESSION_FLAG_FIRST_PACKET | PGM_SESSION_FLAG_SENDER);

#if 0
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset =
                (pSend->pSender->MaxDataFileSize/(pSend->pSender->PacketBufferSize*2))*pSend->pSender->PacketBufferSize;
#endif
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset = 0;

    ASSERT (pSend->pSender->SendTimeoutCount);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    ExInitializeNPagedLookasideList (&pSend->pSender->SenderBufferLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     pSend->pSender->PacketBufferSize,
                                     PGM_TAG('2'),
                                     SENDER_BUFFER_LOOKASIDE_DEPTH);

    ExInitializeNPagedLookasideList (&pSend->pSender->SendContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (tCLIENT_SEND_REQUEST),
                                     PGM_TAG('2'),
                                     SEND_CONTEXT_LOOKASIDE_DEPTH);

    PgmTrace (LogStatus, ("PgmConnect:  "  \
        "pSend=<%p>, DestIP=<%x>, Rate=<%d>, WinBytes=<%d>, WinMS=<%d>, SendTC=<%d>, IncBytes=<%d>, CurrentBS=<%d>\n",
            pSend, (ULONG) IpAddress, (ULONG) pAddress->RateKbitsPerSec,
            (ULONG) pAddress->WindowSizeInBytes, (ULONG) pAddress->WindowSizeInMSecs,
            (ULONG) pSend->pSender->SendTimeoutCount, (ULONG) pSend->pSender->IncrementBytesOnSendTimeout,
            (ULONG) pSend->pSender->CurrentBytesSendable));

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_CONNECT);
    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CONNECT);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmCancelDisconnectIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Disconnect Irp. It must
    release the cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PGMLockHandle           OldIrq;
    PIRP                    pIrpToComplete;
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tCOMMON_SESSION_CONTEXT *pSession = (tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext;

    if (!PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmTrace (LogError, ("PgmCancelDisconnectIrp: ERROR -- "  \
            "pIrp=<%p> pSession=<%p>, pAddress=<%p>\n",
                pIrp, pSession, (pSession ? pSession->pAssociatedAddress : NULL)));
        return;
    }

    PgmLock (pSession, OldIrq);

    ASSERT (pIrp == pSession->pIrpDisconnect);
    if ((pIrpToComplete = pSession->pIrpDisconnect) &&
        (pIrpToComplete == pIrp))
    {
        pSession->pIrpDisconnect = NULL;
    }
    else
    {
        pIrpToComplete = NULL;
    }

    if (pSession->pSender)
    {
        pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount;
    }

    //
    // If we have reached here, then the Irp must already
    // be in the process of being completed!
    //
    PgmUnlock (pSession, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);

    PgmTrace (LogAllFuncs, ("PgmCancelDisconnectIrp:  "  \
        "pIrp=<%p> was CANCELled, pIrpTpComplete=<%p>\n", pIrp, pIrpToComplete));

    if (pIrpToComplete)
    {
        pIrp->IoStatus.Information = 0;
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDisconnect(
    IN  tPGM_DEVICE                 *pPgmDevice,
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client to disconnect a currently-active
    session

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the disconnect operation

--*/
{
    LIST_ENTRY                      PendingIrpsList;
    PGMLockHandle                   OldIrq1, OldIrq2, OldIrq3;
    PIRP                            pIrpReceive;
    NTSTATUS                        Status;
    LARGE_INTEGER                   TimeoutInMSecs;
    LARGE_INTEGER                   *pTimeoutInMSecs;
    tADDRESS_CONTEXT                *pAddress = NULL;
    tCOMMON_SESSION_CONTEXT         *pSession = (tCOMMON_SESSION_CONTEXT *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_DISCONNECT  pDisconnectRequest = (PTDI_REQUEST_KERNEL_CONNECT) &(pIrpSp->Parameters);

    PgmLock (&PgmDynamicConfig, OldIrq1);
    //
    // Now, verify that the Connection handle is valid + associated!
    //
    if ((!PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!(pAddress = pSession->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmTrace (LogError, ("PgmDisconnect: ERROR -- "  \
            "BAD Handle(s), pSession=<%p>, pAddress=<%p>\n", pSession, pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_HANDLE);
    }

    InitializeListHead (&PendingIrpsList);
    TimeoutInMSecs.QuadPart = 0;

    IoAcquireCancelSpinLock (&OldIrq2);
    PgmLock (pSession, OldIrq3);

    Status = STATUS_SUCCESS;
    if (pSession->pReceiver)
    {
        //
        // If we have any receive Irps pending, cancel them
        //
        RemovePendingIrps (pSession, &PendingIrpsList);
        //
        // Do the cleanup!
        //
        if (!(pSession->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED))
        {
            pSession->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            CleanupPendingNaks (pSession, (PVOID) FALSE, (PVOID) TRUE);
        }
    }
    else if (pSession->pSender)
    {
        //
        // See if there is an abortive or graceful disconnect, and
        // also if there is a timeout specified.
        //
        if ((pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT) ||
            (pSession->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET))       // No packets sent yet!
        {
            pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount;
        }
        else if (NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelDisconnectIrp, TRUE)))
        {
            if ((pTimeoutInMSecs = pDisconnectRequest->RequestSpecific) &&
                ((pTimeoutInMSecs->LowPart != -1) || (pTimeoutInMSecs->HighPart != -1)))   // Check Infinite
            {
                //
                // NT relative timeouts are negative. Negate first to get a
                // positive value to pass to the transport.
                //
                TimeoutInMSecs.QuadPart = -((*pTimeoutInMSecs).QuadPart);
                TimeoutInMSecs = PgmConvert100nsToMilliseconds (TimeoutInMSecs);

                pSession->pSender->DisconnectTimeInTicks = pSession->pSender->TimerTickCount +
                                                           TimeoutInMSecs.QuadPart /
                                                               BASIC_TIMER_GRANULARITY_IN_MSECS;
            }

            pSession->pIrpDisconnect = pIrp;
            Status = STATUS_PENDING;
        }
        else
        {
            Status = STATUS_CANCELLED;
        }
    }

    if (NT_SUCCESS (Status))
    {
        pSession->SessionFlags |= PGM_SESSION_CLIENT_DISCONNECTED;
    }

    PgmTrace (LogStatus, ("PgmDisconnect:  "  \
        "pIrp=<%p>, pSession=<%p>, pAddress=<%p>, Timeout=<%I64x>, %s\n",
            pIrp, pSession, pAddress, TimeoutInMSecs.QuadPart,
            (pDisconnectRequest->RequestFlags & TDI_DISCONNECT_ABORT ? "ABORTive" : "GRACEful")));

    PgmUnlock (pSession, OldIrq3);
    IoReleaseCancelSpinLock (OldIrq2);
    PgmUnlock (&PgmDynamicConfig, OldIrq1);

    while (!IsListEmpty (&PendingIrpsList))
    {
        pIrpReceive = CONTAINING_RECORD (PendingIrpsList.Flink, IRP, Tail.Overlay.ListEntry);
        RemoveEntryList (&pIrpReceive->Tail.Overlay.ListEntry);

        PgmCancelCancelRoutine (pIrpReceive);
        pIrpReceive->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);
    }

    return (Status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetRcvBufferLength(
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called by the client by the client to set the receive buffer length
    Currently, we do not utilize this option meaningfully.

Arguments:

    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS            status;
    tRECEIVE_SESSION    *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    tPGM_MCAST_REQUEST  *pInputBuffer = (tPGM_MCAST_REQUEST *) pIrp->AssociatedIrp.SystemBuffer;

    PAGED_CODE();

    if (pIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof (tPGM_MCAST_REQUEST))
    {
        PgmTrace (LogError, ("PgmSetRcvBufferLength: ERROR -- "  \
            "Invalid BufferLength, <%d> < <%d>\n",
                pIrpSp->Parameters.DeviceIoControl.InputBufferLength, sizeof (tPGM_MCAST_REQUEST)));
        return (STATUS_INVALID_PARAMETER);
    }

    if (!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE))
    {
        PgmTrace (LogError, ("PgmSetRcvBufferLength: ERROR -- "  \
            "Invalid Handle <%p>\n", pReceive));
        return (STATUS_INVALID_HANDLE);
    }

    pReceive->pReceiver->RcvBufferLength = pInputBuffer->RcvBufferLength;

    PgmTrace (LogStatus, ("PgmSetRcvBufferLength:  "  \
        "RcvBufferLength=<%d>\n", pReceive->pReceiver->RcvBufferLength));

    //
    // ISSUE:  What else should we do here ?
    //

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\precomp.h ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompilation header file.

Author:

    Mohammad Shabbir Alam (MAlam) 3-30-2000

Revision History:

--*/

//
// These are needed for CTE
//

#pragma once

#if DBG
#define DEBUG 1
#endif

#define NT 1

#pragma warning( disable : 4103 )

#if(WINVER > 0x0500)
#include <ntosp.h>
#include <stddef.h>     // for FILE_LOGGING
#include <wmikm.h>      // for FILE_LOGGING
#else
#include <ntos.h>
#include <status.h>
#include <ntstatus.h>
#endif  // WINVER

#include <ipexport.h>
#include <fipsapi.h>
#include <zwapi.h>

#include <tdikrnl.h>
#include <cxport.h>

#include <tdi.h>
#include <RmCommon.h>

#include <Types.h>
#include <Macroes.h>
#include <DrvProcs.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\pnp.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    PnP.c

Abstract:

    This module contains the various PnP handlers

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#include <ipinfo.h>     // for IPInterfaceInfo
#include "ntddip.h"     // Needed for IP_INTERFACE_INFO
#include <tcpinfo.h>    // for AO_OPTION_xxx, TCPSocketOption

#ifdef FILE_LOGGING
#include "pnp.tmh"
#endif  // FILE_LOGGING


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SetTdiHandlers)
#endif
//*******************  Pageable Routine Declarations ****************


HANDLE      TdiClientHandle     = NULL;

//----------------------------------------------------------------------------
BOOLEAN
SrcIsUs(
    tIPADDRESS  IpAddress
    )
/*++

Routine Description:

    This routine determines if the IP address passed in is a
    local address

Arguments:

    IN  IpAddress   -- IpAddress to verify

Return Value:

    TRUE if IpAddress is local, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;

    PgmLock (&PgmDynamicConfig, OldIrq);

    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddress)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                return (TRUE);
            }
        }
    }
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    return (FALSE);
}


//----------------------------------------------------------------------------
BOOLEAN
SrcIsOnLocalSubnet(
    tIPADDRESS  IpAddress
    )
/*++

Routine Description:

    This routine determines if the IP address passed in is a
    local address

Arguments:

    IN  IpAddress   -- IpAddress to verify

Return Value:

    TRUE if IpAddress is local, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;
    tIPADDRESS              SubnetAddr;

    PgmLock (&PgmDynamicConfig, OldIrq);

    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);

            SubnetAddr = pLocalAddress->IpAddress & pLocalAddress->SubnetMask;
            if (SubnetAddr == (IpAddress & pLocalAddress->SubnetMask))
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                return (TRUE);
            }
        }
    }
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    return (FALSE);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpInterfaceIndexFromAddress(
    IN  tIPADDRESS      IpAddr,
    OUT ULONG           *pIPInterfaceIndex
    )
/*++

Routine Description:

    Given an IP address, this routine determines will return the
    Ip interface context that address is registered on

Arguments:

    IN  IpAddress           -- IpAddress
    OUT IpInterfaceIndex  -- IpInterfaceIndex for the IP address passed

Return Value:

    STATUS_SUCCESS if IpAddress was matched to interface,
    STATUS_UNSUCCESSFUL otherwise

    The DynamicConfig lock is held on entry and exit from this routine
--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;

    if (!IpAddr)
    {
        return (STATUS_UNSUCCESSFUL);
    }

    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                *pIPInterfaceIndex = pLocalInterface->IpInterfaceIndex;
                return (STATUS_SUCCESS);
            }
        }
    }

    return (STATUS_UNSUCCESSFUL);
}


//----------------------------------------------------------------------------

NTSTATUS
GetIpInterfaceInfoForDevice(
    IN  PUNICODE_STRING     pucBindString,
    IN  tIPADDRESS          NetIpAddr,
    OUT tLOCAL_INTERFACE    *pInterfaceInfo
    )
/*++

Routine Description:

    Given a Unicode device name string, this routine will query Ip
    and return the IpInterfaceIndex for that device

Arguments:

    IN  NetIpAddr           -- IpAddress on Device
    IN  pucBindString       -- Pointer to unicode device name string
    OUT IpInterfaceIndex  -- IpInterfaceIndex for the device name
    IN  BufferLength        -- Length of Output buffer passed
    OUT pBuffer             -- Output buffer passed for Interface properties
    IN  fGetInterfaceInfo   -- Whether to return Interface properties or not

Return Value:

    STATUS_SUCCESS if IpInterfaceIndex was found, and properties
    successfully queried, STATUS_UNSUCCESSFUL otherwise

--*/
{
    LONG                i, NumEntries;
    NTSTATUS            status;
    ULONG               BufferLen;
    IP_INTERFACE_INFO   *pIPIfInfoIoctl = NULL;
    IPInterfaceInfo     *pIpIfInfoQTcp = NULL;
    IPAddrEntry         *pAddrTable = NULL;

    BufferLen = 3 * sizeof (IPInterfaceInfo);
    status = PgmQueryTcpInfo (pgPgmDevice->hControl,
                              IP_INTFC_INFO_ID,
                              &NetIpAddr,
                              sizeof (tIPADDRESS),
                              &pIpIfInfoQTcp,
                              &BufferLen);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("GetInterfaceContext: ERROR -- "  \
            "PgmQueryTcpInfo[IP_INTFC_INFO_ID] returned <%x>\n", status));

        return (status);
    }

    BufferLen = pIpIfInfoQTcp->iii_addrlength < sizeof(tMAC_ADDRESS) ?
                    pIpIfInfoQTcp->iii_addrlength : sizeof(tMAC_ADDRESS);
    PgmCopyMemory (&pInterfaceInfo->MacAddress, pIpIfInfoQTcp->iii_addr, BufferLen);
    pInterfaceInfo->MTU = pIpIfInfoQTcp->iii_mtu - (sizeof(IPV4Header) + ROUTER_ALERT_SIZE);
    pInterfaceInfo->Flags = pIpIfInfoQTcp->iii_flags;
    PgmFreeMem (pIpIfInfoQTcp);

    BufferLen = 3 * sizeof (IPAddrEntry);
    status = PgmQueryTcpInfo (pgPgmDevice->hControl,
                              IP_MIB_ADDRTABLE_ENTRY_ID,
                              NULL,
                              0,
                              &pAddrTable,
                              &BufferLen);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("GetInterfaceContext: ERROR -- "  \
            "PgmQueryTcpInfo[IP_MIB_ADDRTABLE_ENTRY_ID] returned <%x>\n", status));

        return (status);
    }

    status = STATUS_UNSUCCESSFUL;
    NumEntries = BufferLen / sizeof (IPAddrEntry);
    for (i=0; i<NumEntries; i++)
    {
        if (pAddrTable[i].iae_addr == NetIpAddr)
        {
            pInterfaceInfo->IpInterfaceIndex = pAddrTable[i].iae_index;
            pInterfaceInfo->SubnetMask = ntohl (pAddrTable[i].iae_mask);
            status = STATUS_SUCCESS;
        }
    }
    PgmFreeMem (pAddrTable);

    PgmTrace (LogAllFuncs, ("GetInterfaceContext:  "  \
        "Device=<%wZ>: IPInterfaceIndex=<%x>\n",
            pucBindString, pInterfaceInfo->IpInterfaceIndex));


    return (status);
}


//----------------------------------------------------------------------------

ULONG
StopListeningOnInterface(
#ifdef IP_FIX
    IN  ULONG               IpInterfaceIndex,
#else
    IN  tIPADDRESS          IpAddress,          // Host format
#endif  // IP_FIX
    IN  PGMLockHandle       *pOldIrqDynamicConfig
    )
/*++

Routine Description:

    Given an IPInterfaceIndex, this routine traverses the list of
    all Receivers, and if any are determined to be listening on that
    interface, stops them from listening on all the addresses on this
    interface.  In the case that the listener is part of an active
    session, the routine will also change the state of the Receiver
    to start listening on all interfaces

Arguments:

    IN  IpInterfaceIndex  -- IpInterfaceIndex to stop listening on
    IN  pOldIrqDynamicConfig-- OldIrq for DynamicConfig lock held

    The DynamicConfig lock is held on entry and exit from this routine

Return Value:

    Number of receivers found listening on this interface

--*/
{
    NTSTATUS                status;
    tRECEIVE_SESSION        *pReceive;
    tADDRESS_CONTEXT        *pAddress;
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq1, OldIrq2;
    USHORT                  i;
    tMCAST_INFO             MCastInfo;
    ULONG                   NumDisconnected = 0;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;

#ifdef IP_FIX
    MCastInfo.MCastInIf = IpInterfaceIndex;
#else
    MCastInfo.MCastInIf = htonl (IpAddress);
#endif  // IP_FIX

    pEntry = &PgmDynamicConfig.ReceiverAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.ReceiverAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        PgmLock (pAddress, OldIrq1);

        if (!(pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES))
        {
            //
            // If the app had specified interfaces to listen on,
            // then don't manage interfaces!
            //
            PgmUnlock (pAddress, OldIrq1);
            continue;
        }

        //
        // See if this address was listening on this interface
        //
        for (i=0; i<pAddress->NumReceiveInterfaces; i++)
        {
#ifdef IP_FIX
            if (pAddress->ReceiverInterfaceList[i] == IpInterfaceIndex)
#else
            if (pAddress->ReceiverInterfaceList[i] == IpAddress)
#endif  // IP_FIX
            {
                break;
            }
        }

        if (i >= pAddress->NumReceiveInterfaces)
        {
            PgmUnlock (pAddress, OldIrq1);
            continue;
        }

        //
        // Remove this Interface from the list of listening interfaces
        //
        pAddress->NumReceiveInterfaces--;
        while (i < pAddress->NumReceiveInterfaces)
        {
            pAddress->ReceiverInterfaceList[i] = pAddress->ReceiverInterfaceList[i+1];
            i++;
        }

        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING, TRUE);

        //
        // If this were the only interface we were listening on
        // for an active session (or waiting for a session), ensure
        // that we go back into listening mode!
        //
        if ((pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES) &&
            (!pAddress->NumReceiveInterfaces))
        {
            pAddress->Flags |= PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE;

            if (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
            {
                status = ListenOnAllInterfaces (pAddress, pOldIrqDynamicConfig, &OldIrq1);

                if (NT_SUCCESS (status))
                {
                    PgmTrace (LogStatus, ("StopListeningOnInterface:  "  \
                        "ListenOnAllInterfaces for pAddress=<%p> succeeded\n", pAddress));
                }
                else
                {
                    PgmTrace (LogError, ("StopListeningOnInterface: ERROR -- "  \
                        "ListenOnAllInterfaces for pAddress=<%p> returned <%x>\n",
                            pAddress, status));
                }
            }
        }

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

        if (pAddressToDeref)
        {
            PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_STOP_LISTENING);
        }
        pAddressToDeref = pAddress;

        //
        // So, stop listening on this interface
        //
        MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
#ifdef IP_FIX
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmTrace (LogStatus, ("StopListeningOnInterface:  "  \
                "Stopped pAddress=<%p> from listening on Interface=<%x>\n",
                    pAddress, MCastInfo.MCastInIf));
        }
        else
        {
            //
            // We failed to stop listening on this interface -- don't so anything!
            //
            PgmTrace (LogError, ("StopListeningOnInterface: ERROR -- "  \
                "AO_OPTION_INDEX_DEL_MCAST for If=<%x> on pAddress=<%p> returned <%x>\n",
                    MCastInfo.MCastInIf, pAddress, status));
        }

        PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    }

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_STOP_LISTENING);
    }

    return (NumDisconnected);
}


//----------------------------------------------------------------------------

VOID
StopListeningOnAllInterfacesExcept(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PVOID               Data1,
    IN  PVOID               Unused
    )
/*++

Routine Description:

    Given an Address Context and IPInterfaceIndex (Data1), this routine
    stops the Address from listening on all the addresses except on this
    interface.

Arguments:

    IN  pAddress            -- Address Context
    IN  Data1               -- IpInterfaceIndex to stop listening on

Return Value:

    None

--*/
{
    NTSTATUS                status;
    PGMLockHandle           OldIrq;
    tMCAST_INFO             MCastInfo;
    ULONG                   InterfacesToStop[MAX_RECEIVE_INTERFACES+1];
    USHORT                  NumInterfaces, i;
    ULONG                   InterfaceToKeep = PtrToUlong (Data1);
#ifndef IP_FIX
    PGMLockHandle           OldIrq0;
    LIST_ENTRY              *pEntry;
    tLOCAL_INTERFACE        *pLocalInterface;
    tADDRESS_ON_INTERFACE   *pLocalAddress;
    USHORT                  j;
#endif  // !IP_FIX

    PgmLock (&PgmDynamicConfig, OldIrq0);
    PgmLock (pAddress, OldIrq);

    //
    // pAddress must be referenced before entering this routine
    //
    if (!(PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE))
    {
        //
        // Out state has changed -- deref and return immediately
        //
        PgmUnlock (pAddress, OldIrq);
        PgmUnlock (&PgmDynamicConfig, OldIrq0);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
        return;
    }

#ifdef IP_FIX
    //
    // If this is the only interface we are listening on,
    // return success
    //
    if ((pAddress->NumReceiveInterfaces == 1) &&
        (pAddress->ReceiverInterfaceList[0] == InterfaceToKeep))
    {
        PgmTrace (LogStatus, ("StopListeningOnAllInterfacesExcept:  "  \
            "pAddress=<%p> is only listening on 1 Interface=<%x>\n",
                pAddress, InterfaceToKeep));

        PgmUnlock (pAddress, OldIrq);
        return;
    }

    ASSERT (pAddress->NumReceiveInterfaces > 1);

    //
    // First, enumerate all interfaces to stop listening on
    //
    NumInterfaces = 0;
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        if (pAddress->ReceiverInterfaceList[i] != InterfaceToKeep)
        {
            InterfacesToStop[NumInterfaces++] = pAddress->ReceiverInterfaceList[i];
        }
    }

    pAddress->ReceiverInterfaceList[0] = InterfaceToKeep;
    pAddress->NumReceiveInterfaces = 1;

    //
    // Now, remove the remaining interfaces
    //
#else
    //
    // First, make a copy of all addresses being listened on
    //
    NumInterfaces = 0;
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        InterfacesToStop[NumInterfaces++] = pAddress->ReceiverInterfaceList[i];
    }

    //
    // Zero out the current listening list on the address
    //
    pAddress->NumReceiveInterfaces = 0;

    //
    // Now, remove the addresses on this interface from this list
    //
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        if (InterfaceToKeep == pLocalInterface->IpInterfaceIndex)
        {
            //
            // Found the interface -- now save these addresses in the Address
            // list and remove from the stop list
            //
            pEntry = &pLocalInterface->Addresses;
            while ((pEntry = pEntry->Flink) != &pLocalInterface->Addresses)
            {
                pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);

                pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces++] = pLocalAddress->IpAddress;

                i = 0;
                while (i < NumInterfaces)
                {
                    if (InterfacesToStop[i] == pLocalAddress->IpAddress)
                    {
                        j = i;
                        NumInterfaces--;
                        while (j < NumInterfaces)
                        {
                            InterfacesToStop[j] = InterfacesToStop[j+1];
                            j++;
                        }
                    }
                    else
                    {
                        i++;
                    }
                }

            }

            break;
        }
    }
#endif  // IP_FIX

    PgmUnlock (pAddress, OldIrq);
    PgmUnlock (&PgmDynamicConfig, OldIrq0);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
    for (i=0; i<NumInterfaces; i++)
    {
#ifdef IP_FIX
        MCastInfo.MCastInIf = InterfacesToStop[i];
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        MCastInfo.MCastInIf = htonl (InterfacesToStop[i]);
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_DEL_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmTrace (LogStatus, ("\tStopListeningOnAllInterfacesExcept:  "  \
                "Stopped pAddress=<%p> from listening on Interface=<%x>\n",
                    pAddress, MCastInfo.MCastInIf));
        }
        else
        {
            //
            // We failed to stop this interface -- don't so anything!
            //
            PgmTrace (LogError, ("\tStopListeningOnAllInterfacesExcept: ERROR -- "  \
                "AO_OPTION_INDEX_DEL_MCAST for If=<%x> on pAddress=<%p> returned <%x>\n",
                    MCastInfo.MCastInIf, pAddress, status));
        }
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
    return;
}


//----------------------------------------------------------------------------

NTSTATUS
ListenOnAllInterfaces(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  PGMLockHandle       *pOldIrqDynamicConfig,
    IN  PGMLockHandle       *pOldIrqAddress
    )
/*++

Routine Description:

    Given an Address Context, this routine enables the Address to
    start listening on all interfaces

Arguments:

    IN  pAddress            -- Address Context
    IN  pOldIrqDynamicConfig-- OldIrq for DynamicConfig lock held
    IN  pOldIrqAddress      -- OldIrq for Address lock held

    The DynamicConfig and Address locks are held on entry and exit
    from this routine

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                status;
    LIST_ENTRY              *pEntry;
    tLOCAL_INTERFACE        *pLocalInterface;
    tMCAST_INFO             MCastInfo;
    ULONG                   InterfacesToAdd[MAX_RECEIVE_INTERFACES+1];
    USHORT                  NumInterfaces, i, j;
#ifndef IP_FIX
    LIST_ENTRY              *pEntry2;
    tADDRESS_ON_INTERFACE   *pLocalAddress;
#endif  // !IP_FIX

    //
    // First, get the list of all active interfaces
    //
    NumInterfaces = 0;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
#ifdef IP_FIX
        InterfacesToAdd[NumInterfaces++] = pLocalInterface->IpInterfaceIndex;
#else
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);

            InterfacesToAdd[NumInterfaces++] = pLocalAddress->IpAddress;

            if (NumInterfaces >= MAX_RECEIVE_INTERFACES)
            {
                break;
            }
        }
#endif  // IP_FIX

        if (NumInterfaces >= MAX_RECEIVE_INTERFACES)
        {
            break;
        }
    }

    //
    // Remove all the interfaces we are already listening
    // on from the list of interfaces to be added
    //
    for (i=0; i<pAddress->NumReceiveInterfaces; i++)
    {
        for (j = 0; j < NumInterfaces; j++)
        {
            if (pAddress->ReceiverInterfaceList[i] == InterfacesToAdd[j])
            {
                NumInterfaces--;
                while (j < NumInterfaces)
                {
                    InterfacesToAdd[j] = InterfacesToAdd[j+1];
                    j++;
                }

                break;
            }
        }
    }

    if (!NumInterfaces)
    {
        PgmTrace (LogStatus, ("ListenOnAllInterfaces:  "  \
            "No new interfaces to listen on for pAddress=<%p>, currently listening on <%x> Ifs\n",
                pAddress, pAddress->NumReceiveInterfaces));

        return (STATUS_SUCCESS);
    }

    //
    // Ensure that the complete list will not
    // exceed the maximum limit
    //
    if ((pAddress->NumReceiveInterfaces + NumInterfaces) > MAX_RECEIVE_INTERFACES)
    {
        NumInterfaces = MAX_RECEIVE_INTERFACES - pAddress->NumReceiveInterfaces;
    }

    //
    // Now, add the remaining interfaces
    //
    PgmUnlock (pAddress, *pOldIrqAddress);
    PgmUnlock (&PgmDynamicConfig, *pOldIrqDynamicConfig);

    MCastInfo.MCastIpAddr = htonl (pAddress->ReceiverMCastAddr);
    i = 0;
    while (i < NumInterfaces)
    {
#ifdef IP_FIX
        MCastInfo.MCastInIf = InterfacesToAdd[i];
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_INDEX_ADD_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#else
        MCastInfo.MCastInIf = htonl (InterfacesToAdd[i]);
        status = PgmSetTcpInfo (pAddress->FileHandle,
                                AO_OPTION_ADD_MCAST,
                                &MCastInfo,
                                sizeof (tMCAST_INFO));
#endif  // IP_FIX

        if (NT_SUCCESS (status))
        {
            PgmTrace (LogStatus, ("\tListenOnAllInterfaces:  "  \
                "pAddress=<%p> now also listening on If=<%x>\n",
                    pAddress, MCastInfo.MCastInIf));

            i++;
            continue;
        }

        //
        // We failed to add this interface, so remove it from   
        // the list
        //
        PgmTrace (LogError, ("\tListenOnAllInterfaces: ERROR -- "  \
            "pAddress=<%p> could not listen on If=<%x>\n",
                pAddress, MCastInfo.MCastInIf));

        j = i;
        NumInterfaces--;
        while (j < NumInterfaces)
        {
            InterfacesToAdd[j] = InterfacesToAdd[j+1];
            j++;
        }
    }

    PgmLock (&PgmDynamicConfig, *pOldIrqDynamicConfig);
    PgmLock (pAddress, *pOldIrqAddress);

    //
    // Now, append the new list to the Address context
    //
    for (i=0; i<NumInterfaces; i++)
    {
        if (pAddress->NumReceiveInterfaces > MAX_RECEIVE_INTERFACES)
        {
            ASSERT (0);
            break;
        }

        pAddress->ReceiverInterfaceList[pAddress->NumReceiveInterfaces] = InterfacesToAdd[i];
        pAddress->NumReceiveInterfaces++;
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
TdiAddressArrival(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
/*++

Routine Description:

    PnP TDI_ADD_ADDRESS_HANDLER
    This routine handles an IP address arriving.
    It is called by TDI when an address arrives.

Arguments:

    IN  Addr        -- IP address that's coming.
    IN  pDeviceName -- Unicode string Ptr for Device whose address is changing
    IN  Context     -- Tdi PnP context

Return Value:

    Nothing!

--*/
{
    tIPADDRESS              IpAddr, NetIpAddr;
    LIST_ENTRY              *pEntry;
    PGMLockHandle           OldIrq, OldIrq1;
    tLOCAL_INTERFACE        InterfaceInfo;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;
    NTSTATUS                status;
    tADDRESS_CONTEXT        *pAddress;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;
    BOOLEAN                 fFound;

    //
    // Proceed only if this is an IP address
    //
    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }

    //
    // First, verify that we are not getting unloaded
    //
    PgmLock (&PgmDynamicConfig, OldIrq);
    if (!PGM_VERIFY_HANDLE (pgPgmDevice, PGM_VERIFY_DEVICE))
    {
        //
        // The driver is most probably being unloaded now
        //
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return;
    }
    PGM_REFERENCE_DEVICE (pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    NetIpAddr = ((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr;
    IpAddr = ntohl (NetIpAddr);

    //
    // Now, get the interface context and other info from TcpIp
    //
    PgmZeroMemory (&InterfaceInfo, sizeof (tLOCAL_INTERFACE));
    status = GetIpInterfaceInfoForDevice (pDeviceName,
                                          NetIpAddr,
                                          &InterfaceInfo);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("TdiAddressArrival: ERROR -- "  \
            "GetIpInterfaceIndex returned <%x>\n", status));

        PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
        return;
    }

    PgmLock (&PgmDynamicConfig, OldIrq);

    fFound = FALSE;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        if (pLocalInterface->IpInterfaceIndex == InterfaceInfo.IpInterfaceIndex)
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        fFound = FALSE;
        pEntry = &pLocalInterface->Addresses;
        while ((pEntry = pEntry->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);
                PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);

                PgmTrace (LogError, ("TdiAddressArrival: ERROR -- "  \
                    "\tDUPLICATE address notification for [%d.%d.%d.%d] on <%wZ>\n",
                    (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
                    pDeviceName));

                return;
            }
        }
    }
    else
    {
        if (!(pLocalInterface = PgmAllocMem (sizeof(tLOCAL_INTERFACE), PGM_TAG('0'))))
        {
            PgmUnlock (&PgmDynamicConfig, OldIrq);

            PgmTrace (LogError, ("TdiAddressArrival: ERROR -- "  \
                "STATUS_INSUFFICIENT_RESOURCES[Interface] for IP=<%x>, IfContext=<%x>\n",
                    IpAddr, InterfaceInfo.IpInterfaceIndex));

            PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
            return;
        }

        PgmZeroMemory (pLocalInterface, sizeof (tLOCAL_INTERFACE));
        InitializeListHead (&pLocalInterface->Addresses);

        pLocalInterface->IpInterfaceIndex = InterfaceInfo.IpInterfaceIndex;
        pLocalInterface->MTU = InterfaceInfo.MTU;
        pLocalInterface->Flags = InterfaceInfo.Flags;
        pLocalInterface->SubnetMask = InterfaceInfo.SubnetMask;
        PgmCopyMemory (&pLocalInterface->MacAddress, &InterfaceInfo.MacAddress, sizeof(tMAC_ADDRESS));

        if (pLocalInterface->MTU > PgmDynamicConfig.MaxMTU)
        {
            PgmDynamicConfig.MaxMTU = pLocalInterface->MTU;
        }
        InsertTailList (&PgmDynamicConfig.LocalInterfacesList, &pLocalInterface->Linkage);
    }

    //
    // Now, add this address to the interface
    //
    if (pLocalAddress = PgmAllocMem (sizeof(tADDRESS_ON_INTERFACE), PGM_TAG('0')))
    {
        PgmZeroMemory (pLocalAddress, sizeof (tADDRESS_ON_INTERFACE));
        pLocalAddress->IpAddress = IpAddr;
        pLocalAddress->SubnetMask = InterfaceInfo.SubnetMask;
        InsertTailList (&pLocalInterface->Addresses, &pLocalAddress->Linkage);
    }
    else
    {
        //
        // If we had just added the interface, there is no point
        // in keeping an empty context around!
        //
        if (IsListEmpty (&pLocalInterface->Addresses))
        {
            RemoveEntryList (&pLocalInterface->Linkage);
            PgmFreeMem (pLocalInterface);
        }

        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmTrace (LogError, ("TdiAddressArrival: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES[Address] -- [%d.%d.%d.%d] on <%wZ>\n",
                (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
                pDeviceName));

        PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);
        return;
    }

    //
    // Now, check if we have any receivers waiting for an address
    //
    pEntry = &PgmDynamicConfig.ReceiverAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.ReceiverAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        PgmLock (pAddress, OldIrq1);

        if ((PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) &&
            (pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE) &&
            (pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES))
        {
            PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SET_INFO, TRUE);

            if (pAddressToDeref)
            {
                PgmUnlock (pAddress, OldIrq1);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_SET_INFO);

                PgmLock (&PgmDynamicConfig, OldIrq);
                PgmLock (pAddress, OldIrq1);
            }
            pAddressToDeref = pAddress;

            status = ReceiverAddMCastIf (pAddress, IpAddr, &OldIrq, &OldIrq1);

            if (NT_SUCCESS (status))
            {
                PgmTrace (LogStatus, ("TdiAddressArrival:  "  \
                    "ReceiverAddMCastIf for pAddress=<%p> succeeded for IP=<%x>\n",
                        pAddress, IpAddr));
            }
            else
            {
                PgmTrace (LogError, ("TdiAddressArrival: ERROR -- "  \
                    "ReceiverAddMCastIf for pAddress=<%p> returned <%x>, IP=<%x>\n",
                        pAddress, status, IpAddr));
            }
        }

        PgmUnlock (pAddress, OldIrq1);
    }

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_SET_INFO);
    }

    PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_ADDRESS_NOTIFICATION);

    PgmTrace (LogStatus, ("TdiAddressArrival:  "  \
        "\t[%d.%d.%d.%d] on <%wZ>\n",
        (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
        pDeviceName));
}


//----------------------------------------------------------------------------

VOID
TdiAddressDeletion(
    PTA_ADDRESS         Addr,
    PUNICODE_STRING     pDeviceName,
    PTDI_PNP_CONTEXT    Context
    )
/*++

Routine Description:

    This routine handles an IP address going away.
    It is called by TDI when an address is deleted.
    If it's an address we care about we'll clean up appropriately.

Arguments:

    IN  Addr        -- IP address that's going.
    IN  pDeviceName -- Unicode string Ptr for Device whose address is changing
    IN  Context     -- Tdi PnP context

Return Value:

    Nothing!

--*/
{
    tIPADDRESS              IpAddr;
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              *pEntry2;
    PGMLockHandle           OldIrq, OldIrq1;
    tSEND_SESSION           *pSend;
    tADDRESS_CONTEXT        *pAddress;
    NTSTATUS                status;
    BOOLEAN                 fFound;
    tADDRESS_CONTEXT        *pAddressToDeref = NULL;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;
    ULONG                   IpInterfaceIndex;

    if (Addr->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        return;
    }
    IpAddr = ntohl(((PTDI_ADDRESS_IP)&Addr->Address[0])->in_addr);

    PgmLock (&PgmDynamicConfig, OldIrq);

    fFound = FALSE;
    pEntry = &PgmDynamicConfig.LocalInterfacesList;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.LocalInterfacesList)
    {
        pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
        pEntry2 = &pLocalInterface->Addresses;
        while ((pEntry2 = pEntry2->Flink) != &pLocalInterface->Addresses)
        {
            pLocalAddress = CONTAINING_RECORD (pEntry2, tADDRESS_ON_INTERFACE, Linkage);
            if (pLocalAddress->IpAddress == IpAddr)
            {
                IpInterfaceIndex = pLocalInterface->IpInterfaceIndex;
                RemoveEntryList (&pLocalAddress->Linkage);
                PgmFreeMem (pLocalAddress);

                //
                // If this is the last address on this interface, clean up!
                //
                if (IsListEmpty (&pLocalInterface->Addresses))
                {
                    RemoveEntryList (&pLocalInterface->Linkage);
                    PgmFreeMem (pLocalInterface);
                    pLocalInterface = NULL;
                }

                fFound = TRUE;
                break;
            }
        }

        if (fFound)
        {
            break;
        }
    }

    if (!fFound)
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmTrace (LogError, ("TdiAddressDeletion: ERROR -- "  \
            "\tAddress [%d.%d.%d.%d] NOT notified on <%wZ>\n",
            (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
            pDeviceName));

        return;
    }

    pEntry = &PgmDynamicConfig.SenderAddressHead;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.SenderAddressHead)
    {
        pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
        if (pAddress->SenderMCastOutIf == IpAddr)
        {
            PgmLock (pAddress, OldIrq1);
            pAddress->Flags |= PGM_ADDRESS_FLAG_INVALID_OUT_IF;

            pEntry2 = &pAddress->AssociatedConnections;
            while ((pEntry2 = pEntry2->Flink) != &pAddress->AssociatedConnections)
            {
                pSend = CONTAINING_RECORD (pEntry2, tSEND_SESSION, Linkage);
                if (!(pSend->SessionFlags & PGM_SESSION_TERMINATED_ABORT))
                {
                    pSend->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

                    if (pAddress->evDisconnect)
                    {
                        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_DISCONNECT, TRUE);
                        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_DISCONNECT, FALSE);

                        PgmUnlock (pAddress, OldIrq1);
                        PgmUnlock (&PgmDynamicConfig, OldIrq);

                        if (pAddressToDeref)
                        {
                            PGM_DEREFERENCE_ADDRESS (pAddressToDeref, REF_ADDRESS_DISCONNECT);
                        }
                        pAddressToDeref = pAddress;

                        status = (*pAddress->evDisconnect) (pAddress->DiscEvContext,
                                                            pSend->ClientSessionContext,
                                                            0,
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            TDI_DISCONNECT_ABORT);

                        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_DISCONNECT);

                        PgmLock (&PgmDynamicConfig, OldIrq);
                        PgmLock (pAddress, OldIrq1);

                        pEntry = &PgmDynamicConfig.SenderAddressHead;
                        break;
                    }
                }
            }

            PgmUnlock (pAddress, OldIrq1);
        }
    }

    //
    // See which receivers were actively listening on this interface
    // If this was an interface for an active session, then we need to
    // restart listening on all interfaces if no interface(s) had been
    // specified by the user.
    //
#ifdef IP_FIX
    if (!pLocalInterface)
    {
        StopListeningOnInterface (IpInterfaceIndex, &OldIrq);
    }
#else
    StopListeningOnInterface (IpAddr, &OldIrq);
#endif  // IP_FIX

    PgmUnlock (&PgmDynamicConfig, OldIrq);

    if (pAddressToDeref)
    {
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_DISCONNECT);
    }

    PgmTrace (LogStatus, ("TdiAddressDeletion:  "  \
        "\t[%d.%d.%d.%d] on <%wZ>\n",
            (IpAddr>>24)&0xFF,(IpAddr>>16)&0xFF,(IpAddr>>8)&0xFF,IpAddr&0xFF,
            pDeviceName));
}


//----------------------------------------------------------------------------

VOID
TdiBindHandler(
    TDI_PNP_OPCODE  PnPOpCode,
    PUNICODE_STRING pDeviceName,
    PWSTR           MultiSZBindList
    )
/*++

Routine Description:

    This routine is the handler for TDI to notify clients of bind notifications

Arguments:

    IN  PnPOpCode   --  Notification code
    IN  pDeviceName --  Unicode string Ptr for Device whose address is changing
    IN  MultiSZBindList --  Current list of bindings

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{

    PAGED_CODE();

    switch (PnPOpCode)
    {
        case (TDI_PNP_OP_ADD):
        {
            PgmTrace (LogAllFuncs, ("TdiBindHandler:  "  \
                "\t[ADD]: Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (TDI_PNP_OP_DEL):
        {
            PgmTrace (LogAllFuncs, ("TdiBindHandler:  "  \
                "\t[DEL]: Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (TDI_PNP_OP_PROVIDERREADY):
        {
            PgmTrace (LogAllFuncs, ("TdiBindHandler:  "  \
                "\t[PROVIDERREADY]: Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (TDI_PNP_OP_NETREADY):
        {
            PgmTrace (LogAllFuncs, ("TdiBindHandler:  "  \
                "\t[NETREADY]: Device=<%wZ>\n", pDeviceName));

            break;
        }

        default:
        {
            PgmTrace (LogAllFuncs, ("TdiBindHandler:  "  \
                "\t[?=%x]: Device=<%wZ>\n", PnPOpCode, pDeviceName));

            break;
        }
    }

}


//----------------------------------------------------------------------------

NTSTATUS
TdiPnPPowerHandler(
    IN  PUNICODE_STRING     pDeviceName,
    IN  PNET_PNP_EVENT      pPnPEvent,
    IN  PTDI_PNP_CONTEXT    Context1,
    IN  PTDI_PNP_CONTEXT    Context2
    )
/*++

Routine Description:

    This routine is the handler called by TDI notify its clients of Power notifications

Arguments:

    IN  pDeviceName --  Unicode string Ptr for Device whose address is changing
    IN  PnPEvent    --  Event notification
    IN  Context1    --
    IN  Context2    --

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PAGED_CODE();

    switch (pPnPEvent->NetEvent)
    {
        case (NetEventQueryPower):
        {
            PgmTrace (LogPath, ("TdiPnPPowerHandler:  "  \
                "[QueryPower]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventSetPower):
        {
            PgmTrace (LogPath, ("TdiPnPPowerHandler:  "  \
                "[SetPower]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventQueryRemoveDevice):
        {
            PgmTrace (LogStatus, ("TdiPnPPowerHandler:  "  \
                "[QueryRemoveDevice]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventCancelRemoveDevice):
        {
            PgmTrace (LogStatus, ("TdiPnPPowerHandler:  "  \
                "[CancelRemoveDevice]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventReconfigure):
        {
            PgmTrace (LogPath, ("TdiPnPPowerHandler:  "  \
                "[Reconfigure]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventBindList):
        {
            PgmTrace (LogPath, ("TdiPnPPowerHandler:  "  \
                "[BindList]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        case (NetEventPnPCapabilities):
        {
            PgmTrace (LogPath, ("TdiPnPPowerHandler:  "  \
                "[PnPCapabilities]:  Device=<%wZ>\n", pDeviceName));

            break;
        }

        default:
        {
            PgmTrace (LogStatus, ("TdiPnPPowerHandler:  "  \
                "[?=%d]:  Device=<%wZ>\n", (ULONG) pPnPEvent->NetEvent, pDeviceName));

            break;
        }
    }


    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
SetTdiHandlers(
    )
/*++

Routine Description:

    This routine is called at DriverEntry to register our handlers with TDI

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                    status;
    UNICODE_STRING              ucPgmClientName;
    TDI_CLIENT_INTERFACE_INFO   TdiClientInterface;

    PAGED_CODE();

    //
    // Register our Handlers with TDI
    //
    RtlInitUnicodeString (&ucPgmClientName, WC_PGM_CLIENT_NAME);
    ucPgmClientName.MaximumLength = sizeof (WC_PGM_CLIENT_NAME);
    PgmZeroMemory (&TdiClientInterface, sizeof(TdiClientInterface));

    TdiClientInterface.MajorTdiVersion      = TDI_CURRENT_MAJOR_VERSION;
    TdiClientInterface.MinorTdiVersion      = TDI_CURRENT_MINOR_VERSION;
    TdiClientInterface.ClientName           = &ucPgmClientName;
    TdiClientInterface.AddAddressHandlerV2  = TdiAddressArrival;
    TdiClientInterface.DelAddressHandlerV2  = TdiAddressDeletion;
    TdiClientInterface.BindingHandler       = TdiBindHandler;
    TdiClientInterface.PnPPowerHandler      = TdiPnPPowerHandler;

    status = TdiRegisterPnPHandlers (&TdiClientInterface, sizeof(TdiClientInterface), &TdiClientHandle);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("SetTdiHandlers: ERROR -- "  \
            "TdiRegisterPnPHandlers ==> <%x>\n", status));
        return (status);
    }

    TdiEnumerateAddresses(TdiClientHandle);

    PgmTrace (LogAllFuncs, ("SetTdiHandlers:  "  \
        "\tSUCCEEDed\n"));

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\driver.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Driver.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "driver.tmh"
#else
#if DBG
enum eLOGGING_LEVEL    PgmLoggingLevel = LogStatus;
#endif  // DBG
#endif  // FILE_LOGGING


tPGM_STATIC_CONFIG      PgmStaticConfig;
tPGM_DYNAMIC_CONFIG     PgmDynamicConfig;
tPGM_REGISTRY_CONFIG    *pPgmRegistryConfig = NULL;

tPGM_DEVICE             *pgPgmDevice = NULL;
DEVICE_OBJECT           *pPgmDeviceObject = NULL;


NTSTATUS
PgmDispatchCreate(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS
PgmDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS
PgmDispatchDeviceControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    );

NTSTATUS
PgmDispatchCleanup(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

NTSTATUS
PgmDispatchClose(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, PgmUnload)
#endif
//*******************  Pageable Routine Declarations ****************



//----------------------------------------------------------------------------
//
// Internal routines
//

FILE_FULL_EA_INFORMATION *
FindEA(
    IN  PFILE_FULL_EA_INFORMATION   StartEA,
    IN  CHAR                        *pTargetName,
    IN  USHORT                      TargetNameLength
    );

VOID
CompleteDispatchIrp(
    IN PIRP         pIrp,
    IN NTSTATUS     status
    );

//----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the PGM device driver.
    This routine creates the device object for the PGM
    device and does other driver initialization.

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS                status;

    PAGED_CODE();

#ifdef FILE_LOGGING
    //---------------------------------------------------------------------------------------

    WPP_INIT_TRACING (DriverObject, RegistryPath);
#endif  // FILE_LOGGING

    //---------------------------------------------------------------------------------------

    status = InitPgm (DriverObject, RegistryPath);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("DriverEntry: ERROR -- "  \
            "InitPgm returned <%x>\n", status));
        return (status);
    }

    //---------------------------------------------------------------------------------------

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = (PDRIVER_DISPATCH)PgmDispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = (PDRIVER_DISPATCH)PgmDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = (PDRIVER_DISPATCH)PgmDispatchInternalDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 = (PDRIVER_DISPATCH)PgmDispatchCleanup;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = (PDRIVER_DISPATCH)PgmDispatchClose;
    DriverObject->DriverUnload                                  = PgmUnload;

    //---------------------------------------------------------------------------------------

    status = SetTdiHandlers ();
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("DriverEntry: ERROR -- "  \
            "SetTdiHandlers returned <%x>\n", status));
        CleanupInit (E_CLEANUP_DEVICE);
        return (status);
    }

    //---------------------------------------------------------------------------------------

    //
    // Return to the caller.
    //
    PgmTrace (LogAllFuncs, ("DriverEntry:  "  \
        "Succeeded! ...\n"));

    return (status);
}


//----------------------------------------------------------------------------
VOID
CleanupInit(
    enum eCLEANUP_STAGE     CleanupStage
    )
/*++

Routine Description:

    This routine is called either at DriverEntry or DriverUnload
    to cleanup (or do partial cleanup) of items initialized at Init-time

Arguments:

    IN  CleanupStage    -- determines the stage to which we had initialized
                            settings

Return Value:

    NONE

--*/
{
    NTSTATUS                status;
    LIST_ENTRY              *pEntry;
    PGMLockHandle           OldIrq;
    tADDRESS_CONTEXT        *pAddress;
    PGM_WORKER_CONTEXT      *pWorkerContext;
    PPGM_WORKER_ROUTINE     pDelayedWorkerRoutine;
    tLOCAL_INTERFACE        *pLocalInterface = NULL;
    tADDRESS_ON_INTERFACE   *pLocalAddress = NULL;

    PgmTrace (LogAllFuncs, ("CleanupInit:  "  \
        "CleanupStage=<%d>\n", CleanupStage));

    switch (CleanupStage)
    {
        case (E_CLEANUP_UNLOAD):
        {
            //
            // Ensure that there are no more worker threads to be cleaned up
            //
            //
            // See if there are any worker threads currently executing, and if so, wait for
            // them to complete
            //
            KeClearEvent (&PgmDynamicConfig.LastWorkerItemEvent);
            PgmLock (&PgmDynamicConfig, OldIrq);
            if (PgmDynamicConfig.NumWorkerThreadsQueued)
            {
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                status = KeWaitForSingleObject(&PgmDynamicConfig.LastWorkerItemEvent,  // Object to wait on.
                                               Executive,            // Reason for waiting
                                               KernelMode,           // Processor mode
                                               FALSE,                // Alertable
                                               NULL);                // Timeout
                ASSERT (status == STATUS_SUCCESS);
                PgmLock (&PgmDynamicConfig, OldIrq);
            }

            ASSERT (!PgmDynamicConfig.NumWorkerThreadsQueued);

            //
            // Dequeue each of the requests in the Worker Queue and complete them
            //
            while (!IsListEmpty (&PgmDynamicConfig.WorkerQList))
            {
                pWorkerContext = CONTAINING_RECORD(PgmDynamicConfig.WorkerQList.Flink, PGM_WORKER_CONTEXT, PgmConfigLinkage);
                RemoveEntryList (&pWorkerContext->PgmConfigLinkage);
                PgmUnlock (&PgmDynamicConfig, OldIrq);

                pDelayedWorkerRoutine = pWorkerContext->WorkerRoutine;

                PgmTrace (LogAllFuncs, ("CleanupInit:  "  \
                    "Completing Worker request <%p>\n", pDelayedWorkerRoutine));

                (*pDelayedWorkerRoutine) (pWorkerContext->Context1,
                                          pWorkerContext->Context2,
                                          pWorkerContext->Context3);
                PgmFreeMem ((PVOID) pWorkerContext);

                //
                // Acquire Lock again to check if we have completed all the requests
                //
                PgmLock (&PgmDynamicConfig, OldIrq);
            }

            PgmUnlock (&PgmDynamicConfig, OldIrq);
        }

        // no break -- Fall through!
        case (E_CLEANUP_PNP):
        {
            status = TdiDeregisterPnPHandlers (TdiClientHandle);

            while (!IsListEmpty (&PgmDynamicConfig.LocalInterfacesList))
            {
                pEntry = RemoveHeadList (&PgmDynamicConfig.LocalInterfacesList);
                pLocalInterface = CONTAINING_RECORD (pEntry, tLOCAL_INTERFACE, Linkage);
                while (!IsListEmpty (&pLocalInterface->Addresses))
                {
                    pEntry = RemoveHeadList (&pLocalInterface->Addresses);
                    pLocalAddress = CONTAINING_RECORD (pEntry, tADDRESS_ON_INTERFACE, Linkage);
                    PgmFreeMem (pLocalAddress);
                }
                PgmFreeMem (pLocalInterface);
            }
        }

        // no break -- Fall through!

        case (E_CLEANUP_DEVICE):
        {
            PGM_DEREFERENCE_DEVICE (&pgPgmDevice, REF_DEV_CREATE);
        }

        // no break -- Fall through!

        case (E_CLEANUP_STRUCTURES):
        {
            // Nothing specific to cleanup
        }

        // no break -- Fall through!

        case (E_CLEANUP_REGISTRY_PARAMETERS):
        {
            if (pPgmRegistryConfig)
            {
                if (pPgmRegistryConfig->ucSenderFileLocation.Buffer)
                {
                    PgmFreeMem (pPgmRegistryConfig->ucSenderFileLocation.Buffer);
                    pPgmRegistryConfig->ucSenderFileLocation.Buffer = NULL;
                }

                PgmFreeMem (pPgmRegistryConfig);
                pPgmRegistryConfig = NULL;
            }
        }

        // no break -- Fall through!

        case (E_CLEANUP_DYNAMIC_CONFIG):
        {
            // See if there are any addresses we were unable to close earlier
            while (!IsListEmpty (&PgmDynamicConfig.DestroyedAddresses))
            {
                pEntry = RemoveHeadList (&PgmDynamicConfig.DestroyedAddresses);
                pAddress = CONTAINING_RECORD (pEntry, tADDRESS_CONTEXT, Linkage);
                PgmDestroyAddress (pAddress, NULL, NULL);
            }
        }

        // no break -- Fall through!

        case (E_CLEANUP_STATIC_CONFIG):
        {
#ifdef  OLD_LOGGING
            ExDeleteNPagedLookasideList(&PgmStaticConfig.DebugMessagesLookasideList);
#endif  // OLD_LOGGING
            ExDeleteNPagedLookasideList(&PgmStaticConfig.TdiLookasideList);

            PgmFreeMem (PgmStaticConfig.RegistryPath.Buffer);

            //
            // Dereference FipsFileObject.
            //
            if (PgmStaticConfig.FipsFileObject)
            {
                ASSERT (PgmStaticConfig.FipsInitialized);
                PgmStaticConfig.FipsInitialized = FALSE;
                ObDereferenceObject (PgmStaticConfig.FipsFileObject);
                PgmStaticConfig.FipsFileObject = NULL;
            }
            else
            {
                ASSERT (!PgmStaticConfig.FipsInitialized);
            }
        }

        // no break -- Fall through!

        default:
        {
            break;
        }
    }
}


//----------------------------------------------------------------------------

VOID
PgmUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This is the Pgm driver's function for Unload requests

Arguments:

    IN  DriverObject - Pointer to driver object created by the system.

Return Value:

    None

--*/

{
    NTSTATUS                status;

    PAGED_CODE();

    PgmDynamicConfig.GlobalFlags |= PGM_CONFIG_FLAG_UNLOADING;

    PgmTrace (LogStatus, ("PgmUnload:  "  \
        "Unloading ...\n"));

    CleanupInit (E_CLEANUP_UNLOAD);

#ifdef FILE_LOGGING
    WPP_CLEANUP (DriverObject);
#endif  // FILE_LOGGING
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchCreate(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )

/*++

Routine Description:

    Dispatch function for creating Pgm objects

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    NTSTATUS - Final status of the create request

--*/

{
    tPGM_DEVICE                 *pPgmDevice = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION          pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    UCHAR                       IrpFlags = pIrpSp->Control;
    tCONTROL_CONTEXT            *pControlContext = NULL;
    FILE_FULL_EA_INFORMATION    *ea = (PFILE_FULL_EA_INFORMATION) pIrp->AssociatedIrp.SystemBuffer;
    FILE_FULL_EA_INFORMATION    *TargetEA;
    TRANSPORT_ADDRESS UNALIGNED *pTransportAddr;
    TA_ADDRESS                  *pAddress;
    NTSTATUS                    status;

    PAGED_CODE();

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    //
    // See if this is a Control Channel open.
    //
    if (!ea)
    {
        PgmTrace (LogAllFuncs, ("PgmDispatchCreate:  "  \
            "Opening control channel for file object %p\n", pIrpSp->FileObject));

        if (pControlContext = PgmAllocMem (sizeof(tCONTROL_CONTEXT), PGM_TAG('0')))
        {
            PgmZeroMemory (pControlContext, sizeof (tCONTROL_CONTEXT));
            InitializeListHead (&pControlContext->Linkage);
            PgmInitLock (pControlContext, CONTROL_LOCK);
            pControlContext->Verify = PGM_VERIFY_CONTROL;
            PGM_REFERENCE_CONTROL (pControlContext, REF_CONTROL_CREATE, TRUE);

            pIrpSp->FileObject->FsContext = pControlContext;
            pIrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;

            status = STATUS_SUCCESS;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    //
    // See if this is a Connection Object open.
    //
    else if (TargetEA = FindEA (ea, TdiConnectionContext, TDI_CONNECTION_CONTEXT_LENGTH))
    {
        status = PgmCreateConnection (pPgmDevice, pIrp, pIrpSp, TargetEA);

        PgmTrace (LogAllFuncs, ("PgmDispatchCreate:  "  \
            "Open Connection, pIrp=<%p>, status=<%x>\n", pIrp, status));
    }
    //
    // See if this is an Address Object open.
    //
    else if (TargetEA = FindEA (ea, TdiTransportAddress, TDI_TRANSPORT_ADDRESS_LENGTH))
    {
        status = PgmCreateAddress (pPgmDevice, pIrp, pIrpSp, TargetEA);

        PgmTrace (LogAllFuncs, ("PgmDispatchCreate:  "  \
            "Open Address, pIrp=<%p>, status=<%x>\n", pIrp, status));
    }
    else
    {
        PgmTrace (LogError, ("PgmDispatchCreate: ERROR -- "  \
            "Unsupported EA!\n"));

        status =  STATUS_INVALID_EA_NAME;
    }

    if (status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, status);
    }

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchCleanup(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    Dispatch function for cleaning-up Pgm objects

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    NTSTATUS - Final status of the cleanup request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    UCHAR               IrpFlags = pIrpSp->Control;
    PVOID               *pContext = pIrpSp->FileObject->FsContext;

    PAGED_CODE();

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    switch (PtrToUlong (pIrpSp->FileObject->FsContext2))
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
        {
            status = PgmCleanupAddress ((tADDRESS_CONTEXT *) pContext, pIrp);

            PgmTrace (LogAllFuncs, ("PgmDispatchCleanup:  "  \
                "pConnect=<%p>, pIrp=<%p>, status=<%x>\n", pContext, pIrp, status));
            break;
        }

        case TDI_CONNECTION_FILE:
        {
            status = PgmCleanupConnection ((tCOMMON_SESSION_CONTEXT *) pContext, pIrp);

            PgmTrace (LogAllFuncs, ("PgmDispatchCleanup:  "  \
                "pConnect=<%p>, pIrp=<%p>, status=<%x>\n", pContext, pIrp, status));
            break;
        }

        case TDI_CONTROL_CHANNEL_FILE:
        {
            //
            // Nothing to Cleanup here!
            //
            PgmTrace (LogAllFuncs, ("PgmDispatchCleanup:  "  \
                "pControl=<%p>, pIrp=<%p>, status=<%x>\n", pContext, pIrp, status));
            break;
        }

        default:
        {
            PgmTrace (LogError, ("PgmDispatchCleanup: ERROR -- "  \
                "pIrp=<%p>, Context=[%p:%p] ...\n",
                    pIrp, pContext, pIrpSp->FileObject->FsContext2));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if (status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, status);
    }

    return (status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchClose(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    This routine completes the cleanup, closing handles, free'ing all
    memory associated with the object

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    NTSTATUS - Final status of the close request

--*/
{
    NTSTATUS            status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    UCHAR               IrpFlags = pIrpSp->Control;
    PVOID               *pContext = pIrpSp->FileObject->FsContext;

    PAGED_CODE();

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    switch (PtrToUlong (pIrpSp->FileObject->FsContext2))
    {
        case TDI_TRANSPORT_ADDRESS_FILE:
        {
            status = PgmCloseAddress (pIrp, pIrpSp);

            PgmTrace (LogAllFuncs, ("PgmDispatchClose:  "  \
                "pAddress=<%p>, pIrp=<%p>, status=<%x>\n", pContext, pIrp, status));
            break;
        }

        case TDI_CONNECTION_FILE:
        {
            status = PgmCloseConnection (pIrp, pIrpSp);

            PgmTrace (LogAllFuncs, ("PgmDispatchClose:  "  \
                "pConnect=<%p>, pIrp=<%p>, status=<%x>\n", pContext, pIrp, status));
            break;
        }

        case TDI_CONTROL_CHANNEL_FILE:
        {
            //
            // There is nothing special to do here so just dereference!
            //
            PgmTrace (LogAllFuncs, ("PgmDispatchClose:  "  \
                "pControl=<%p>, pIrp=<%p>, status=<%x>\n", pIrpSp->FileObject->FsContext, pIrp, status));

            PGM_DEREFERENCE_CONTROL ((tCONTROL_CONTEXT *) pContext, REF_CONTROL_CREATE);
            break;
        }

        default:
        {
            PgmTrace (LogError, ("PgmDispatchClose: ERROR -- "  \
                "pIrp=<%p>, Context=[%p:%p] ...\n",
                    pIrp, pIrpSp->FileObject->FsContext, pIrpSp->FileObject->FsContext2));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
    }

    if (status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, status);
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT       pDeviceObject,
    IN PIRP                 pIrp
    )
/*++

Routine Description:

    This routine primarily handles Tdi requests since we are a Tdi component

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    tPGM_DEVICE                 *pPgmDevice = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION          pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    UCHAR                       IrpFlags = pIrpSp->Control;
    NTSTATUS                    Status = STATUS_UNSUCCESSFUL;

    PgmTrace (LogAllFuncs, ("PgmDispatchInternalDeviceControl:  "  \
        "[%d] Context=<%p> ...\n", pIrpSp->MinorFunction, pIrpSp->FileObject->FsContext));

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending(pIrp);

    switch (pIrpSp->MinorFunction)
    {
        case TDI_QUERY_INFORMATION:
        {
            Status = PgmQueryInformation (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_SET_EVENT_HANDLER:
        {
            Status = PgmSetEventHandler (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_ASSOCIATE_ADDRESS:
        {
            Status = PgmAssociateAddress (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_DISASSOCIATE_ADDRESS:
        {
            Status = PgmDisassociateAddress (pIrp, pIrpSp);
            break;
        }

        case TDI_CONNECT:
        {
            Status = PgmConnect (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_DISCONNECT:
        {
            Status = PgmDisconnect (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_SEND:
        {
            Status = PgmSendRequestFromClient (pPgmDevice, pIrp, pIrpSp);
            break;
        }

        case TDI_RECEIVE:
        {
            Status = PgmReceive (pPgmDevice, pIrp, pIrpSp);
            break;
        }

/*
        case TDI_SEND_DATAGRAM:
        {
            Status = PgmSendDatagram (pPgmDevice, pIrp, pIrpSp);
            break;
        }
*/

        default:
        {
            PgmTrace (LogAllFuncs, ("PgmDispatchInternalDeviceControl: ERROR -- "  \
                "[%x]:  Context=<%p> ...\n", pIrpSp->MinorFunction, pIrpSp->FileObject->FsContext));

            Status = STATUS_NOT_IMPLEMENTED;
            break;
        }
    }

    if (Status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, Status);
    }

    return (Status);
}



//----------------------------------------------------------------------------

NTSTATUS
PgmDispatchDeviceControl(
    IN PDEVICE_OBJECT   pDeviceObject,
    IN PIRP             pIrp
    )
/*++

Routine Description:

    This routine handles private Ioctls into Pgm.  These Ioctls are
    to be called only by the Pgm Winsock helper (WshPgm.dll)

Arguments:

    IN  pDeviceObject   - ptr to device object for target device
    IN  pIrp            - ptr to I/O request packet

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    UCHAR               IrpFlags = pIrpSp->Control;

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    if (STATUS_SUCCESS == TdiMapUserRequest (pDeviceObject, pIrp, pIrpSp))
    {
        //
        // This is a Tdi request!
        //
        status = PgmDispatchInternalDeviceControl (pDeviceObject, pIrp);
        return (status);
    }

    pIrp->IoStatus.Information = 0;
    pIrp->IoStatus.Status = STATUS_PENDING;
    IoMarkIrpPending (pIrp);

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
        case IOCTL_PGM_WSH_SET_WINDOW_SIZE_RATE:
        {
            status = PgmSetWindowSizeAndSendRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_WINDOW_SIZE_RATE:
        {
            status = PgmQueryWindowSizeAndSendRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_ADVANCE_WINDOW_RATE:
        {
            status = PgmSetWindowAdvanceRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_ADVANCE_WINDOW_RATE:
        {
            status = PgmQueryWindowAdvanceRate (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_LATE_JOINER_PERCENTAGE:
        {
            status = PgmSetLateJoinerPercentage (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_LATE_JOINER_PERCENTAGE:
        {
            status = PgmQueryLateJoinerPercentage (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_WINDOW_ADVANCE_METHOD:
        {
            status = PgmSetWindowAdvanceMethod (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_WINDOW_ADVANCE_METHOD:
        {
            status = PgmQueryWindowAdvanceMethod (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_NEXT_MESSAGE_BOUNDARY:
        {
            status = PgmSetNextMessageBoundary (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_SEND_IF:
        {
            status = PgmSetMCastOutIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_ADD_RECEIVE_IF:
        case IOCTL_PGM_WSH_JOIN_MCAST_LEAF:
        {
            status = PgmAddMCastReceiveIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_DEL_RECEIVE_IF:
        {
            status = PgmDelMCastReceiveIf (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_RCV_BUFF_LEN:
        {
            status = PgmSetRcvBufferLength (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_SENDER_STATS:
        {
            status = PgmQuerySenderStats (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_RECEIVER_STATS:
        {
            status = PgmQueryReceiverStats (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_USE_FEC:
        {
            status = PgmSetFECInfo (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_FEC_INFO:
        {
            status = PgmQueryFecInfo (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_MCAST_TTL:
        {
            status = PgmSetMCastTtl (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_QUERY_HIGH_SPEED_INTRANET_OPT:
        {
            status = PgmQueryHighSpeedOptimization (pIrp, pIrpSp);
            break;
        }

        case IOCTL_PGM_WSH_SET_HIGH_SPEED_INTRANET_OPT:
        {
            status = PgmSetHighSpeedOptimization (pIrp, pIrpSp);
            break;
        }

        default:
        {
            PgmTrace (LogAllFuncs, ("PgmDispatchIoctls:  "  \
                "WARNING:  Invalid Ioctl=[%x]:  Context=<%p> ...\n",
                    pIrpSp->Parameters.DeviceIoControl.IoControlCode,
                    pIrpSp->FileObject->FsContext));

            status = STATUS_NOT_IMPLEMENTED;
            break;
        }
    }

    PgmTrace (LogAllFuncs, ("PgmDispatchIoctls:  "  \
        "[%d]: Context=<%p>, status=<%x>\n",
            pIrpSp->Parameters.DeviceIoControl.IoControlCode,
            pIrpSp->FileObject->FsContext, status));

    if (status != STATUS_PENDING)
    {
        // reset the pending returned bit, since we are NOT returning pending
        pIrpSp->Control = IrpFlags;
        CompleteDispatchIrp (pIrp, status);
    }

    return (status);
}




//----------------------------------------------------------------------------
//
// Utility functions
//
//----------------------------------------------------------------------------

FILE_FULL_EA_INFORMATION *
FindEA(
    IN  PFILE_FULL_EA_INFORMATION   StartEA,
    IN  CHAR                        *pTargetName,
    IN  USHORT                      TargetNameLength
    )
/*++

Routine Description:

    Parses and extended attribute list for a given target attribute.

Arguments:

    IN  StartEA           - the first extended attribute in the list.
    IN  pTargetName       - the name of the target attribute.
    IN  TargetNameLength  - the length of the name of the target attribute.

Return Value:

    A pointer to the requested attribute or NULL if the target wasn't found.

--*/

{
    USHORT                      i;
    BOOLEAN                     found;
    FILE_FULL_EA_INFORMATION    *CurrentEA;

    for (CurrentEA = StartEA;
         CurrentEA;
         CurrentEA =  (PFILE_FULL_EA_INFORMATION) ((PUCHAR)CurrentEA + CurrentEA->NextEntryOffset))
    {
        if (strncmp (CurrentEA->EaName, pTargetName, CurrentEA->EaNameLength) == 0)
        {
            PgmTrace (LogAllFuncs, ("FindEA:  "  \
                "Found EA, Target=<%s>\n", pTargetName));

           return (CurrentEA);
        }

        if (CurrentEA->NextEntryOffset == 0)
        {
            break;
        }
    }

    PgmTrace (LogAllFuncs, ("FindEA:  "  \
        "FAILed to find EA, Target=<%s>\n", pTargetName));

    return (NULL);
}


//----------------------------------------------------------------------------
VOID
PgmIoComplete(
    IN  PIRP            pIrp,
    IN  NTSTATUS        Status,
    IN  ULONG           SentLength
    )
/*++

Routine Description:

    This routine

Arguments:

    IN  pIrp        -- Pointer to I/O request packet
    IN  Status      -- the final status of the request
    IN  SentLength  -- the value to be set in the Information field

Return Value:

    NONE

--*/
{
    pIrp->IoStatus.Status = Status;

    // use -1 as a flag to mean do not adjust the sent length since it is
    // already set
    if (SentLength != -1)
    {
        pIrp->IoStatus.Information = SentLength;
    }

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    PgmCancelCancelRoutine (pIrp);

    PgmTrace (LogAllFuncs, ("PgmIoComplete:  "  \
        "pIrp=<%p>, Status=<%x>, SentLength=<%d>\n", pIrp, Status, SentLength));

    IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
}


//----------------------------------------------------------------------------


VOID
CompleteDispatchIrp(
    IN PIRP         pIrp,
    IN NTSTATUS     status
    )

/*++

Routine Description:

    This function completes an IRP, and arranges for return parameters,
    if any, to be copied.

    Although somewhat a misnomer, this function is named after a similar
    function in the SpiderSTREAMS emulator.

Arguments:

    IN  pIrp        -  pointer to the IRP to complete
    IN  status      -  completion status of the IRP

Return Value:

    NONE

--*/

{
    CCHAR priboost;

    //
    // pIrp->IoStatus.Information is meaningful only for STATUS_SUCCESS
    //

    // set the Irps cancel routine to null or the system may bugcheck
    // with a bug code of CANCEL_STATE_IN_COMPLETED_IRP
    //
    // refer to IoCancelIrp()  ..\ntos\io\iosubs.c
    //
    PgmCancelCancelRoutine (pIrp);

    pIrp->IoStatus.Status = status;

    priboost = (CCHAR) ((status == STATUS_SUCCESS) ? IO_NETWORK_INCREMENT : IO_NO_INCREMENT);

    PgmTrace (LogAllFuncs, ("CompleteDispatchIrp:  "  \
        "Completing pIrp=<%p>, status=<%x>\n", pIrp, status));

    IoCompleteRequest (pIrp, priboost);

    return;

}


//----------------------------------------------------------------------------

NTSTATUS
PgmCheckSetCancelRoutine(
    IN  PIRP            pIrp,
    IN  PVOID           CancelRoutine,
    IN  BOOLEAN         fLocked
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp.

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS        status;
    PGMLockHandle   CancelIrql;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    if (!fLocked)
    {
        IoAcquireCancelSpinLock (&CancelIrql);
    }

    if (pIrp->Cancel)
    {
        pIrp->IoStatus.Status = STATUS_CANCELLED;
        status = STATUS_CANCELLED;
    }
    else
    {
        // setup the cancel routine
        IoMarkIrpPending (pIrp);
        IoSetCancelRoutine (pIrp, CancelRoutine);
        status = STATUS_SUCCESS;
    }

    if (!fLocked)
    {
        IoReleaseCancelSpinLock (CancelIrql);
    }

    return(status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCancelCancelRoutine(
    IN  PIRP            pIrp
    )

/*++
Routine Description:

    This Routine sets the cancel routine for an Irp to NULL

Arguments:

    status - a completion status for the Irp

Return Value:

    NTSTATUS - status of the request

--*/

{
    NTSTATUS        status = STATUS_SUCCESS;
    PGMLockHandle   CancelIrql;

    //
    // Check if the irp was cancelled yet and if not, then set the
    // irp cancel routine.
    //
    IoAcquireCancelSpinLock (&CancelIrql);
    if (pIrp->Cancel)
    {
        status = STATUS_CANCELLED;
    }

    IoSetCancelRoutine (pIrp, NULL);
    IoReleaseCancelSpinLock (CancelIrql);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\fileio.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    FileIo.c

Abstract:

    This module implements various FileSystem routines used by
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "fileio.tmh"
#endif  // FILE_LOGGING


NTSTATUS
BuildPgmDataFileName(
    IN  tSEND_SESSION   *pSend
    );

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BuildPgmDataFileName)
#pragma alloc_text(PAGE, PgmCreateDataFileAndMapSection)
#pragma alloc_text(PAGE, PgmUnmapAndCloseDataFile)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
BuildPgmDataFileName(
    IN  tSEND_SESSION   *pSend
    )
/*++

Routine Description:

    This routine build the string for the file name used for buffering
    data packets.

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NONE    -- since we don't expect any error

--*/
{
    UNICODE_STRING      ucPortNumber;
    WCHAR               wcPortNumber[10];
    USHORT              usRandomNumber, MaxFileLength;

    PAGED_CODE();

    if (pPgmRegistryConfig->Flags & PGM_REGISTRY_SENDER_FILE_SPECIFIED)
    {
        MaxFileLength = pPgmRegistryConfig->ucSenderFileLocation.Length / sizeof(WCHAR);
    }
    else
    {
        MaxFileLength = sizeof (WS_DEFAULT_SENDER_FILE_LOCATION) /  sizeof (WCHAR);
    }

    //
    // The file name is composed of the following:
    // "\\T" + Last2DigitPort# + UptoMAX_USHORT5DigitRandom# + ".PGM" + "\0"
    //
    MaxFileLength += 2 + 2 + 5 + 4 + 1;

    if (!(pSend->pSender->DataFileName.Buffer = PgmAllocMem ((sizeof (WCHAR) * MaxFileLength), PGM_TAG('2'))))
    {
        PgmTrace (LogError, ("BuildPgmDataFileName: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating <%d> bytes\n", MaxFileLength));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    pSend->pSender->DataFileName.MaximumLength = sizeof (WCHAR) * MaxFileLength;
    pSend->pSender->DataFileName.Length = 0;

    //
    // First, set the root directory
    //
    if (pPgmRegistryConfig->Flags & PGM_REGISTRY_SENDER_FILE_SPECIFIED)
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, pPgmRegistryConfig->ucSenderFileLocation.Buffer);
    }
    else
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, WS_DEFAULT_SENDER_FILE_LOCATION);
    }

    RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L"\\T");

    //
    // Append the last 2 digits of the Port#
    //
    ucPortNumber.MaximumLength = sizeof (wcPortNumber);
    ucPortNumber.Buffer = wcPortNumber;
    usRandomNumber = pSend->TSI.hPort % 100;
    if (usRandomNumber < 10)
    {
        RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L"0");
    }
    RtlIntegerToUnicodeString ((ULONG) usRandomNumber, 10, &ucPortNumber);
    RtlAppendUnicodeStringToString (&pSend->pSender->DataFileName, &ucPortNumber);

    //
    // Now, Append a random 5 digit value
    //
    GetRandomData ((PUCHAR) &usRandomNumber, sizeof (usRandomNumber));
    RtlIntegerToUnicodeString ((ULONG) usRandomNumber, 10, &ucPortNumber);
    RtlAppendUnicodeStringToString (&pSend->pSender->DataFileName, &ucPortNumber);

    //
    // Now, add the file name extension for id
    //
    RtlAppendUnicodeToString (&pSend->pSender->DataFileName, L".PGM");

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateDataFileAndMapSection(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tSEND_SESSION       *pSend
    )
/*++

Routine Description:

    This routine creates the file and creates a section mapping for it.
    This file is used for buffering the data packets on behalf of the sender

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NTSTATUS - Final status of the create operation

--*/
{
    SECURITY_DESCRIPTOR         *pSecurityDescriptor;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    LARGE_INTEGER               lgMaxDataFileSize;
    NTSTATUS                    Status;
    ULONGLONG                   Size, BlockSize, PacketsInWindow;

    ULONG                       DesiredAccess;
    ULONG                       FileAttributes, AllocationAttributes;
    ULONG                       ShareAccess;
    ULONG                       CreateDisposition;
    ULONG                       CreateOptions;
    ULONG                       Protection;
    SIZE_T                      ViewSize;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;

    PAGED_CODE();

    //
    // Make sure we are currently attached to the Application process
    //
    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);

    //
    // First build the File name string
    //
    Status = BuildPgmDataFileName (pSend);
    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "BuildPgmDataFileName returned <%x>\n", Status));

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }

    //
    // Compute the size of the Data file required to hold 2 * Window size
    // Also make it a multiple of the MTU and the FECGroupSize (if applicable)
    //
    PacketsInWindow = pSend->pAssociatedAddress->WindowSizeInBytes / pSend->pAssociatedAddress->OutIfMTU;
    if (pSend->FECGroupSize > 1)
    {
//        PacketsInWindow += PacketsInWindow + (PacketsInWindow >> 2) + pSend->FECGroupSize - 1;
        PacketsInWindow += PacketsInWindow + pSend->FECGroupSize - 1;
    }
    else
    {
        PacketsInWindow += PacketsInWindow - (PacketsInWindow >> 2);
    }

    if (PacketsInWindow > SENDER_MAX_WINDOW_SIZE_PACKETS)
    {
        PacketsInWindow = SENDER_MAX_WINDOW_SIZE_PACKETS;
        if (pSend->pAssociatedAddress->WindowSizeInBytes > ((PacketsInWindow >> 1) *
                                                            pSend->pAssociatedAddress->OutIfMTU))
        {
            pSend->pAssociatedAddress->WindowSizeInBytes = (PacketsInWindow >> 1) * pSend->pAssociatedAddress->OutIfMTU;
            pSend->pAssociatedAddress->WindowSizeInMSecs = (BITS_PER_BYTE *
                                                            pSend->pAssociatedAddress->WindowSizeInBytes) /
                                                           pSend->pAssociatedAddress->RateKbitsPerSec;
        }
    }

    BlockSize = pSend->FECGroupSize * pSend->pSender->PacketBufferSize;
    Size = PacketsInWindow * pSend->pSender->PacketBufferSize;
    Size = (Size / BlockSize) * BlockSize; 
    pSend->pSender->MaxDataFileSize = Size;
    pSend->pSender->MaxPacketsInBuffer = Size / pSend->pSender->PacketBufferSize;
    lgMaxDataFileSize.QuadPart = Size;

    Status = InitRDataInfo (pAddress, pSend);
    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "InitRDataInfo returned <%x>\n", Status));

        PgmFreeMem (pSend->pSender->DataFileName.Buffer);
        pSend->pSender->DataFileName.Buffer = NULL;

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
        return (Status);
    }

    pSecurityDescriptor = NULL;
    Status = PgmBuildAdminSecurityDescriptor (&pSecurityDescriptor);
    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "PgmCreateSecurityDescriptor returned <%x>\n", Status));

        goto Cleanup;
    }


    PgmZeroMemory (&ObjectAttributes, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes (&ObjectAttributes,
                                &pSend->pSender->DataFileName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                pSecurityDescriptor);


    //
    // We need to open the data file. This file contains data
    // and will be mapped into memory. Read and Write access 
    // are requested.
    // 
    DesiredAccess = FILE_READ_DATA | FILE_WRITE_DATA | DELETE;

    // Using the FILE_ATTRIBUTE_TEMPORARY flag:
    // you let the system know that the file is likely to be short lived.
    // The temporary file is created as a normal file. The system needs to do
    // a minimal amount of lazy writes to the file system to keep the disk
    // structures (directories and so forth) consistent. This gives the
    // appearance that the file has been written to the disk. However, unless
    // the Memory Manager detects an inadequate supply of free pages and
    // starts writing modified pages to the disk, the Cache Manager's Lazy
    // Writer may never write the data pages of this file to the disk.
    // If the system has enough memory, the pages may remain in memory for
    // any arbitrary amount of time. Because temporary files are generally
    // short lived, there is a good chance the system will never write the pages to the disk. 
    FileAttributes = FILE_ATTRIBUTE_TEMPORARY;

    ShareAccess = 0;    // Gives the caller exclusive access to the open file

    CreateDisposition = FILE_CREATE | FILE_SUPERSEDE;
    // Delete the file when the last handle to it is passed to ZwClose.
    CreateOptions = FILE_NON_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE;

    PgmZeroMemory (&IoStatusBlock, sizeof(IO_STATUS_BLOCK));
    Status = ZwCreateFile (&pSend->pSender->FileHandle,
                           DesiredAccess,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           &lgMaxDataFileSize,              // AllocationSize
                           FileAttributes,
                           ShareAccess,
                           CreateDisposition,
                           CreateOptions,
                           NULL,                            // EaBuffer
                           0);                              // EaLength

    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "ZwCreateFile for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status));

        goto Cleanup;
    }

    //
    // Now we have a handle to our open test file. We now create a section
    // object with this handle.
    //
    DesiredAccess              = STANDARD_RIGHTS_REQUIRED | 
                                 SECTION_QUERY            | 
                                 SECTION_MAP_READ         |
                                 SECTION_MAP_WRITE;
    Protection                 = PAGE_READWRITE;
    AllocationAttributes       = SEC_COMMIT;

    PgmZeroMemory (&ObjectAttributes, sizeof (OBJECT_ATTRIBUTES));
    InitializeObjectAttributes (&ObjectAttributes,
                                NULL,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwCreateSection (&pSend->pSender->SectionHandle,
                              DesiredAccess,
                              &ObjectAttributes,    // NULL ?
                              &lgMaxDataFileSize,
                              Protection,
                              AllocationAttributes,
                              pSend->pSender->FileHandle);

    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "ZwCreateSection for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status));

        goto Cleanup;
    }

    //
    // Reference the section object, if a view is mapped to the section
    // object, the object is not dereferenced as the virtual address
    // descriptor contains a pointer to the section object.
    //

    Status = ObReferenceObjectByHandle (pSend->pSender->SectionHandle,
                                        0,
                                        0,
                                        KernelMode,
                                        &pSend->pSender->pSectionObject,
                                        NULL );

    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "ObReferenceObjectByHandle for SectionHandle=<%p> returned <%x>\n",
                pSend->pSender->SectionHandle, Status));

        goto Cleanup;
    }

    //
    // Our section object has been created and linked to the file
    // object that was previous opened. Now we map a view on
    // this section.
    //
    ViewSize                   = 0; 
    Protection                 = PAGE_READWRITE;
    Status = ZwMapViewOfSection (pSend->pSender->SectionHandle,
                                 NtCurrentProcess(),
                                 &pSend->pSender->SendDataBufferMapping,
                                 0L,                                // ZeroBits
                                 0L,                                // CommitSize (initially committed region)
                                 NULL,                              // &SectionOffset
                                 &ViewSize,
                                 ViewUnmap,                         // InheritDisposition: for child processes
                                 0L,                                // AllocationType
                                 Protection);

    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDataFileAndMapSection: ERROR -- "  \
            "ZwMapViewOfSection for <%wZ> returned <%x>\n", &pSend->pSender->DataFileName, Status));

        goto Cleanup;
    }

    PgmTrace (LogStatus, ("PgmCreateDataFileAndMapSection:  "  \
        "Mapped <%wZ> to address<%p>, Filelength=<%I64d>\n",
            &pSend->pSender->DataFileName, pSend->pSender->SendDataBufferMapping, Size));

    pSend->pSender->BufferSizeAvailable = pSend->pSender->MaxDataFileSize;
    pSend->pSender->BufferPacketsAvailable = (ULONG) pSend->pSender->MaxPacketsInBuffer;
    pSend->pSender->LeadingWindowOffset = pSend->pSender->TrailingWindowOffset = 0;

    //
    // Now, reference the process
    //
    ObReferenceObject (pSend->Process);
    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);
    PgmFreeMem (pSecurityDescriptor);
    return (STATUS_SUCCESS);

Cleanup:

    ASSERT (!NT_SUCCESS (Status));

    if (pSend->pSender->pSectionObject)
    {
        ObDereferenceObject (pSend->pSender->pSectionObject);
        pSend->pSender->pSectionObject = NULL;
    }

    if (pSend->pSender->SectionHandle)
    {
        ZwClose (pSend->pSender->SectionHandle);
        pSend->pSender->SectionHandle = NULL;
    }

    if (pSend->pSender->FileHandle)
    {
        ZwClose (pSend->pSender->FileHandle);
        pSend->pSender->FileHandle = NULL;
    }

    if (pSecurityDescriptor)
    {
        PgmFreeMem (pSecurityDescriptor);
    }

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CREATE_DATA_FILE);

    PgmFreeMem (pSend->pSender->DataFileName.Buffer);
    pSend->pSender->DataFileName.Buffer = NULL;
    DestroyRDataInfo (pSend);

    return (Status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmUnmapAndCloseDataFile(
    IN  tSEND_SESSION   *pSend
    )
/*++

Routine Description:

    This routine cleansup the file mapping and closes the file
    handles.  The file should automatically get deleted on closing
    the handle since we used the FILE_DELETE_ON_CLOSE option while
    creating the file.

Arguments:

    IN  pSend   -- the Send object

Return Value:

    NTSTATUS - Final status of the operation (STATUS_SUCCESS)

--*/
{
    NTSTATUS    Status;
    KAPC_STATE  ApcState;
    BOOLEAN     fAttached;

    PAGED_CODE();

    DestroyRDataInfo (pSend);

    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_CLOSE_DATA_FILE);
    Status = ZwUnmapViewOfSection (NtCurrentProcess(), (PVOID) pSend->pSender->SendDataBufferMapping);
    ASSERT (NT_SUCCESS (Status));

    ObDereferenceObject (pSend->pSender->pSectionObject);
    pSend->pSender->pSectionObject = NULL;

    Status = ZwClose (pSend->pSender->SectionHandle);
    ASSERT (NT_SUCCESS (Status));
    pSend->pSender->SectionHandle = NULL;

    Status = ZwClose (pSend->pSender->FileHandle);
    ASSERT (NT_SUCCESS (Status));

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_CLOSE_DATA_FILE);
    ObDereferenceObject (pSend->Process);   // Since we had referenced it when the file was created

    pSend->pSender->SendDataBufferMapping = NULL;
    pSend->pSender->pSectionObject = NULL;
    pSend->pSender->SectionHandle = NULL;
    pSend->pSender->FileHandle = NULL;

    PgmTrace (LogStatus, ("PgmUnmapAndCloseDataFile:  "  \
        "pSend = <%p>\n", pSend));

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\init.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Init.c

Abstract:

    This module implements Initialization routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <ntddtcp.h>

#ifdef FILE_LOGGING
#include "init.tmh"
#endif  // FILE_LOGGING


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PgmFipsInitialize)
#pragma alloc_text(PAGE, InitPgm)
#pragma alloc_text(PAGE, InitStaticPgmConfig)
#pragma alloc_text(PAGE, InitDynamicPgmConfig)
#pragma alloc_text(PAGE, PgmReadRegistryParameters)
#pragma alloc_text(PAGE, AllocateInitialPgmStructures)
#pragma alloc_text(PAGE, PgmCreateDevice)
#pragma alloc_text(PAGE, PgmDereferenceDevice)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

BOOLEAN
PgmFipsInitialize(
    VOID
    )
/*++

Routine Description:

    Initialize the FIPS library table.

Arguments:

    Called at PASSIVE level.

Return Value:

    TRUE/FALSE.

--*/
{
    UNICODE_STRING  DeviceName;
    PDEVICE_OBJECT  pFipsDeviceObject = NULL;
    PIRP            pIrp;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT          Event;
    NTSTATUS        status;

    PAGED_CODE();

    //
    // Return success if FIPS already initialized.
    //
    if (PgmStaticConfig.FipsInitialized)
    {
        return (TRUE);
    }

    RtlInitUnicodeString (&DeviceName, FIPS_DEVICE_NAME);

    //
    // Get the file and device objects for FIPS.
    //
    status = IoGetDeviceObjectPointer (&DeviceName,
                                       FILE_ALL_ACCESS,
                                       &PgmStaticConfig.FipsFileObject,
                                       &pFipsDeviceObject);

    if (!NT_SUCCESS(status))
    {
        PgmTrace (LogAllFuncs, ("PgmFipsInitialize: ERROR -- "  \
            "IoGetDeviceObjectPointer returned <%x>\n", status));

        PgmStaticConfig.FipsFileObject = NULL;
        return (FALSE);
    }

    //
    // Build the request to send to FIPS to get library table.
    //
    KeInitializeEvent (&Event, SynchronizationEvent, FALSE);

    pIrp = IoBuildDeviceIoControlRequest (IOCTL_FIPS_GET_FUNCTION_TABLE,
                                          pFipsDeviceObject,
                                          NULL,
                                          0,
                                          &PgmStaticConfig.FipsFunctionTable,
                                          sizeof (FIPS_FUNCTION_TABLE),
                                          FALSE,
                                          &Event,
                                          &StatusBlock);
    
    if (pIrp == NULL)
    {
        PgmTrace (LogError, ("PgmFipsInitialize: ERROR -- "  \
            "IoBuildDeviceIoControlRequest FAILed for IOCTL_FIPS_GET_FUNCTION_TABLE\n"));

        ObDereferenceObject (PgmStaticConfig.FipsFileObject);
        PgmStaticConfig.FipsFileObject = NULL;

        return (FALSE);
    }
    
    status = IoCallDriver (pFipsDeviceObject, pIrp);
    
    if (status == STATUS_PENDING)
    {
        status = KeWaitForSingleObject (&Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);
        if (status == STATUS_SUCCESS)
        {
            status = StatusBlock.Status;
        }
    }

    if (status != STATUS_SUCCESS)
    {
        PgmTrace (LogError, ("PgmFipsInitialize: ERROR -- "  \
            "IoCallDriver for IOCTL_FIPS_GET_FUNCTION_TABLE returned <%#x>\n", status));

        ObDereferenceObject (PgmStaticConfig.FipsFileObject);
        PgmStaticConfig.FipsFileObject = NULL;

        return (FALSE);
    }
    
    PgmStaticConfig.FipsInitialized = TRUE;

    return (TRUE);
}


//----------------------------------------------------------------------------

NTSTATUS
InitStaticPgmConfig(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine initializes the static values used by Pgm

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS    status;

    PAGED_CODE();

    //
    // Initialize the Static Configuration data structure
    //
    PgmZeroMemory (&PgmStaticConfig, sizeof(tPGM_STATIC_CONFIG));

    if (!PgmFipsInitialize ())
    {
        PgmTrace (LogAllFuncs, ("InitStaticPgmConfig: ERROR -- "  \
            "PgmFipsInitialize FAILed, continueing anyway ...\n"));

        //
        // Continue anyway!
        //
//        return (STATUS_UNSUCCESSFUL);
    }

    //
    // get the file system process since we need to know this for
    // allocating and freeing handles
    //
    PgmStaticConfig.FspProcess = PsGetCurrentProcess();
    PgmStaticConfig.DriverObject = DriverObject;    // save the driver object for event logging purposes

    //
    // save the registry path for later use (to read the registry)
    //
    PgmStaticConfig.RegistryPath.MaximumLength = (USHORT) RegistryPath->MaximumLength;
    if (PgmStaticConfig.RegistryPath.Buffer = PgmAllocMem (RegistryPath->MaximumLength, PGM_TAG('0')))
    {
        RtlCopyUnicodeString(&PgmStaticConfig.RegistryPath, RegistryPath);
    }
    else
    {
        PgmTrace (LogError, ("InitStaticPgmConfig: ERROR -- "  \
            "INSUFFICIENT_RESOURCES <%d> bytes\n", PgmStaticConfig.RegistryPath.MaximumLength));

        if (PgmStaticConfig.FipsFileObject)
        {
            ASSERT (PgmStaticConfig.FipsInitialized);
            PgmStaticConfig.FipsInitialized = FALSE;
            ObDereferenceObject (PgmStaticConfig.FipsFileObject);
            PgmStaticConfig.FipsFileObject = NULL;
        }

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    ExInitializeNPagedLookasideList(&PgmStaticConfig.TdiLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof (tTDI_SEND_CONTEXT),
                                    PGM_TAG('2'),
                                    TDI_LOOKASIDE_DEPTH);

#ifdef  OLD_LOGGING
    ExInitializeNPagedLookasideList(&PgmStaticConfig.DebugMessagesLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    (MAX_DEBUG_MESSAGE_LENGTH + 1),
                                    PGM_TAG('3'),
                                    DEBUG_MESSAGES_LOOKASIDE_DEPTH);
#endif  // OLD_LOGGING

    status = FECInitGlobals ();

    if (!NT_SUCCESS (status))
    {
#ifdef  OLD_LOGGING
        ExDeleteNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList);
#endif  // OLD_LOGGING
        ExDeleteNPagedLookasideList (&PgmStaticConfig.TdiLookasideList);
        PgmFreeMem (PgmStaticConfig.RegistryPath.Buffer);

        if (PgmStaticConfig.FipsFileObject)
        {
            ASSERT (PgmStaticConfig.FipsInitialized);
            PgmStaticConfig.FipsInitialized = FALSE;
            ObDereferenceObject (PgmStaticConfig.FipsFileObject);
            PgmStaticConfig.FipsFileObject = NULL;
        }
    }

    PgmTrace (LogAllFuncs, ("InitStaticPgmConfig:  "  \
        "FECInitGlobals returned <%x>\n", status));

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
InitDynamicPgmConfig(
    )
/*++

Routine Description:

    This routine initializes the dynamic values used by Pgm

Arguments:


Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    ULONG       i;

    PAGED_CODE();

    //
    // Initialize the Static Configuration data structure
    //
    PgmZeroMemory (&PgmDynamicConfig, sizeof(tPGM_DYNAMIC_CONFIG));

    //
    // Initialize the list heads before doing anything else since
    // we can access them anytime later
    //
    InitializeListHead (&PgmDynamicConfig.SenderAddressHead);
    InitializeListHead (&PgmDynamicConfig.ReceiverAddressHead);
    InitializeListHead (&PgmDynamicConfig.DestroyedAddresses);
    InitializeListHead (&PgmDynamicConfig.ClosedAddresses);
    InitializeListHead (&PgmDynamicConfig.CurrentReceivers);
    InitializeListHead (&PgmDynamicConfig.ClosedConnections);
    InitializeListHead (&PgmDynamicConfig.ConnectionsCreated);
    InitializeListHead (&PgmDynamicConfig.CleanedUpConnections);
    InitializeListHead (&PgmDynamicConfig.LocalInterfacesList);
    InitializeListHead (&PgmDynamicConfig.WorkerQList);

    PgmDynamicConfig.ReceiversTimerTickCount = 1;       // Init
    GetRandomData ((PUCHAR) &PgmDynamicConfig.SourcePort, sizeof (PgmDynamicConfig.SourcePort));
    PgmDynamicConfig.SourcePort = PgmDynamicConfig.SourcePort % (20000 - 2000 + 1);
    PgmDynamicConfig.SourcePort += 2000;

#if DBG
    for (i=0; i<MAXIMUM_PROCESSORS; i++)
    {
        PgmDynamicConfig.CurrentLockNumber[i] = 0;
    }
#endif
    PgmInitLock (&PgmDynamicConfig, DCONFIG_LOCK);

    KeInitializeEvent (&PgmDynamicConfig.LastWorkerItemEvent, NotificationEvent, TRUE);

    PgmTrace (LogAllFuncs, ("InitDynamicPgmConfig:  "  \
        "STATUS_SUCCESS\n"));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmOpenRegistryParameters(
    IN  PUNICODE_STRING         RegistryPath,
    OUT HANDLE                  *pConfigHandle,
    OUT HANDLE                  *pParametersHandle
    )
/*++

Routine Description:

    This routine reads any required registry parameters

Arguments:

    OUT ppPgmDynamic    -- non-NULL only if we have any registry valuies to read

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    OBJECT_ATTRIBUTES   TmpObjectAttributes;
    NTSTATUS            status;
    ULONG               Disposition;
    UNICODE_STRING      KeyName;
    PWSTR               ParametersString = L"Parameters";

    PAGED_CODE();

    InitializeObjectAttributes (&TmpObjectAttributes,
                                RegistryPath,               // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,       // attributes
                                NULL,                       // root
                                NULL);                      // security descriptor

    status = ZwCreateKey (pConfigHandle,
                          KEY_READ,
                          &TmpObjectAttributes,
                          0,                 // title index
                          NULL,              // class
                          0,                 // create options
                          &Disposition);     // disposition

    if (!NT_SUCCESS(status))
    {
        PgmTrace (LogError, ("PgmOpenRegistryParameters: ERROR -- "  \
            "ZwCreateKey returned <%x>\n", status));

        return (status);
    }

    //
    // Open the Pgm key.
    //
    RtlInitUnicodeString (&KeyName, ParametersString);
    InitializeObjectAttributes (&TmpObjectAttributes,
                                &KeyName,                                   // name
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,   // attributes
                                *pConfigHandle,                             // root
                                NULL);                                      // security descriptor

    status = ZwOpenKey (pParametersHandle, KEY_READ, &TmpObjectAttributes);
    if (!NT_SUCCESS(status))
    {
        PgmTrace (LogError, ("PgmOpenRegistryParameters: ERROR -- "  \
            "ZwOpenKey returned <%x>\n", status));

        ZwClose(*pConfigHandle);
    }

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
ReadRegistryElement(
    IN  HANDLE          HandleToKey,
    IN  PWSTR           pwsValueName,
    OUT PUNICODE_STRING pucString
    )
/*++

Routine Description:

    This routine is will read a string value given by pwsValueName, under a
    given Key (which must be open) - given by HandleToKey. This routine
    allocates memory for the buffer in the returned pucString, so the caller
    must deallocate that.

Arguments:

    pwsValueName- the name of the value to read (i.e. IPAddress)

Return Value:

    pucString - the string returns the string read from the registry

--*/

{
    ULONG                       BytesRead;
    NTSTATUS                    Status;
    UNICODE_STRING              TempString;
    PKEY_VALUE_FULL_INFORMATION ReadValue = NULL;

    PAGED_CODE();

    //
    // First, get the sizeof the string
    //
    RtlInitUnicodeString(&TempString, pwsValueName);      // initilize the name of the value to read
    Status = ZwQueryValueKey (HandleToKey,
                              &TempString,               // string to retrieve
                              KeyValueFullInformation,
                              NULL,
                              0,
                              &BytesRead);             // get bytes to be read

    if (((!NT_SUCCESS (Status)) &&
         (Status != STATUS_BUFFER_OVERFLOW) &&
         (Status != STATUS_BUFFER_TOO_SMALL)) ||
        (BytesRead == 0))
    {
        return (STATUS_UNSUCCESSFUL);
    }

    if (ReadValue = (PKEY_VALUE_FULL_INFORMATION) PgmAllocMem (BytesRead, PGM_TAG('R')))
    {
        Status = ZwQueryValueKey (HandleToKey,
                                  &TempString,               // string to retrieve
                                  KeyValueFullInformation,
                                  (PVOID)ReadValue,        // returned info
                                  BytesRead,
                                  &BytesRead);             // # of bytes returned

        if ((NT_SUCCESS (Status)) &&
            (ReadValue->DataLength))
        {
            // move the read in data to the front of the buffer
            RtlMoveMemory ((PVOID) ReadValue, (((PUCHAR)ReadValue) + ReadValue->DataOffset), ReadValue->DataLength);
            RtlInitUnicodeString (pucString, (PWSTR) ReadValue);
        }
        else
        {
            PgmFreeMem (ReadValue);
            Status = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    return(Status);
}
//----------------------------------------------------------------------------

NTSTATUS
PgmReadRegistryParameters(
    IN  PUNICODE_STRING         RegistryPath,
    OUT tPGM_REGISTRY_CONFIG    **ppPgmRegistryConfig
    )
/*++

Routine Description:

    This routine reads any required registry parameters

Arguments:

    OUT ppPgmDynamic    -- non-NULL only if we have any registry valuies to read

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    HANDLE                  PgmConfigHandle;
    HANDLE                  ParametersHandle;
    NTSTATUS                status;
    tPGM_REGISTRY_CONFIG    *pRegistryConfig;

    PAGED_CODE();

    if (!(pRegistryConfig = PgmAllocMem (sizeof (tPGM_REGISTRY_CONFIG), PGM_TAG('0'))))
    {
        PgmTrace (LogError, ("PgmReadRegistryParameters: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pRegistryConfig = <%d> bytes\n",
                (ULONG) sizeof (tPGM_REGISTRY_CONFIG)));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pRegistryConfig, sizeof(tPGM_REGISTRY_CONFIG));  // zero out the Registry fields
    *ppPgmRegistryConfig = pRegistryConfig;

    //
    // Set any default values here!
    //

    status = PgmOpenRegistryParameters (RegistryPath, &PgmConfigHandle, &ParametersHandle);
    if (!NT_SUCCESS(status))
    {
        PgmTrace (LogError, ("PgmReadRegistryParameters: ERROR -- "  \
            "ZwOpenKey returned <%x>, will continue without reading registry\n", status));

        return STATUS_SUCCESS;
    }

    //
    // ***************************************
    // Now read all the registry needs we need
    //

    status = ReadRegistryElement (ParametersHandle,
                                  PARAM_SENDER_FILE_LOCATION,
                                  &pRegistryConfig->ucSenderFileLocation);
    if (NT_SUCCESS (status))
    {
        //
        // If specifying an alternate disk location, user should specify
        // the following path for say, D:\Temp:
        // "\??\D:\Temp"
        //
        pRegistryConfig->Flags |= PGM_REGISTRY_SENDER_FILE_SPECIFIED;
    }

    //
    // End of list of entries to be read
    // ***************************************
    //

    ZwClose(ParametersHandle);
    ZwClose(PgmConfigHandle);

    PgmTrace (LogAllFuncs, ("PgmReadRegistryParameters:  "  \
        "STATUS_SUCCESS\n"));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
AllocateInitialPgmStructures(
    )
/*++

Routine Description:

    This routine allocates any initial structures that may be required

Arguments:


Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    PAGED_CODE();

    PgmTrace (LogAllFuncs, ("AllocateInitialPgmStructures:  "  \
        "STATUS_SUCCESS\n"));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmCreateDevice(
    )
/*++

Routine Description:

    This routine allocates the Pgm device for clients to
    call into the Pgm driver.

Arguments:

    IN 

Return Value:

    NTSTATUS - Final status of the CreateDevice operation

--*/
{
    NTSTATUS            Status;
    tPGM_DEVICE         *pPgmDevice = NULL;
    UNICODE_STRING      ucPgmDeviceExportName;
    UNICODE_STRING      ucProtocolNumber;
    WCHAR               wcProtocolNumber[10];
    USHORT              PgmBindDeviceNameLength;

    PAGED_CODE();

    RtlInitUnicodeString (&ucPgmDeviceExportName, WC_PGM_DEVICE_EXPORT_NAME);
    PgmBindDeviceNameLength = sizeof(DD_RAW_IP_DEVICE_NAME) + 10;

    Status = IoCreateDevice (PgmStaticConfig.DriverObject,                  // Driver Object
                             sizeof(tPGM_DEVICE)+PgmBindDeviceNameLength,   // Device Extension
                             &ucPgmDeviceExportName,                        // Device Name
                             FILE_DEVICE_NETWORK,                           // Device type 0x12
                             FILE_DEVICE_SECURE_OPEN,                       // Device Characteristics
                             FALSE,                                         // Exclusive
                             &pPgmDeviceObject);

    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDevice: ERROR -- "  \
            "FAILed <%x> ExportDevice=%wZ\n", Status, &ucPgmDeviceExportName));

        pgPgmDevice = NULL;
        return Status;
    }

    pPgmDevice = (tPGM_DEVICE *) pPgmDeviceObject->DeviceExtension;

    //
    // zero out the DeviceExtension
    //
    PgmZeroMemory (pPgmDevice, sizeof(tPGM_DEVICE)+PgmBindDeviceNameLength);

    // put a verifier value into the structure so that we can check that
    // we are operating on the right data
    PgmInitLock (pPgmDevice, DEVICE_LOCK);
    pPgmDevice->Verify = PGM_VERIFY_DEVICE;
    PGM_REFERENCE_DEVICE (pPgmDevice, REF_DEV_CREATE, TRUE);

    pPgmDevice->pPgmDeviceObject = pPgmDeviceObject;
    //
    // Save the raw IP device name as a counted string.  The device
    // name is followed by a path separator then the protocol number
    // of interest.
    //
    pPgmDevice->ucBindName.Buffer = (PWSTR) &pPgmDevice->BindNameBuffer;
    pPgmDevice->ucBindName.Length = 0;
    pPgmDevice->ucBindName.MaximumLength = PgmBindDeviceNameLength;
    RtlAppendUnicodeToString (&pPgmDevice->ucBindName, DD_RAW_IP_DEVICE_NAME);
    pPgmDevice->ucBindName.Buffer[pPgmDevice->ucBindName.Length / sizeof(WCHAR)] = OBJ_NAME_PATH_SEPARATOR;
    pPgmDevice->ucBindName.Length += sizeof(WCHAR);

    ucProtocolNumber.Buffer = wcProtocolNumber;
    ucProtocolNumber.MaximumLength = sizeof (wcProtocolNumber);
    RtlIntegerToUnicodeString ((ULONG) IPPROTO_RM, 10, &ucProtocolNumber);

    RtlAppendUnicodeStringToString (&pPgmDevice->ucBindName, &ucProtocolNumber);

    //
    // Initialize the event that will be used to signal the Device is ready to be deleted
    //
    KeInitializeEvent (&pPgmDevice->DeviceCleanedupEvent, NotificationEvent, FALSE);

    //
    // Now open a control channel on top of Ip
    //
    Status = PgmTdiOpenControl (pPgmDevice);
    if (!NT_SUCCESS (Status))
    {
        PgmTrace (LogError, ("PgmCreateDevice: ERROR -- "  \
            "PgmTdiOpenControl FAILed <%x>\n", Status));

        IoDeleteDevice (pPgmDeviceObject);
        return (Status);
    }

    // increase the stack size of our device object, over that of the transport
    // so that clients create Irps large enough
    // to pass on to the transport below.
    // In theory, we should just add 1 here, to account for our presence in the
    // driver chain.
    //
    pPgmDeviceObject->StackSize = pPgmDevice->pControlDeviceObject->StackSize + 1;

    pPgmDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    pgPgmDevice = pPgmDevice;

    PgmTrace (LogAllFuncs, ("PgmCreateDevice:  "  \
        "Status=<%x> ExportDevice=%wZ\n", Status, &ucPgmDeviceExportName));

    return (Status);
}


//----------------------------------------------------------------------------

VOID
PgmDereferenceDevice(
    IN OUT  tPGM_DEVICE **ppPgmDevice,
    IN      ULONG       RefContext
    )
/*++

Routine Description:

    This routine dereferences the RefCount on the Pgm
    device extension and deletes the device if the RefCount
    goes down to 0.

Arguments:

    IN  ppPgmDevice --  ptr to PgmDevice Extension
    IN  RefContext  --  the context for which this device extension was
                        referenced earlier

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tPGM_DEVICE         *pPgmDevice = *ppPgmDevice;
    KAPC_STATE          ApcState;
    BOOLEAN             fAttached;

    PAGED_CODE();

    ASSERT (PGM_VERIFY_HANDLE (pPgmDevice, PGM_VERIFY_DEVICE));
    ASSERT (pPgmDevice->RefCount);             // Check for too many derefs
    ASSERT (pPgmDevice->ReferenceContexts[RefContext]--);

    if (--pPgmDevice->RefCount)
    {
        return;
    }

    if (pPgmDevice->hControl)
    {
        //
        // This is only done at Load/Unload time, so we should
        // be currently in the System Process Context!
        //
        PgmAttachFsp (&ApcState, &fAttached, REF_FSP_DESTROY_DEVICE);

        ObDereferenceObject (pPgmDevice->pControlFileObject);
        ZwClose (pPgmDevice->hControl);

        pPgmDevice->pControlFileObject = NULL;
        pPgmDevice->hControl = NULL;

        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_DESTROY_DEVICE);
    }

    PgmTrace (LogAllFuncs, ("PgmDereferenceDevice:  "  \
        "Deleting pgPgmDevice=<%p> ...\n", pgPgmDevice));

    IoDeleteDevice (pPgmDevice->pPgmDeviceObject);
    *ppPgmDevice = NULL;

    return;
}


//----------------------------------------------------------------------------

NTSTATUS
InitPgm(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    This routine is called at DriverEntry to initialize all the
    Pgm parameters

Arguments:

    IN  DriverObject    - Pointer to driver object created by the system.
    IN  RegistryPath    - Pgm driver's registry location

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                status;
    tPGM_REGISTRY_CONFIG    *pPgmRegistry = NULL;

    PAGED_CODE();

    status = InitStaticPgmConfig (DriverObject, RegistryPath);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("InitPgm: ERROR -- "  \
            "InitStaticPgmConfig returned <%x>\n", status));
        return (status);
    }

    //---------------------------------------------------------------------------------------

    status = InitDynamicPgmConfig ();
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("InitPgm: ERROR -- "  \
            "InitDynamicPgmConfig returned <%x>\n", status));
        CleanupInit (E_CLEANUP_STATIC_CONFIG);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Read Registry configuration data
    //
    status = PgmReadRegistryParameters (RegistryPath, &pPgmRegistry);
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmTrace (LogError, ("InitPgm: ERROR -- "  \
            "FAILed to read registry, status = <%x>\n", status));
        CleanupInit (E_CLEANUP_DYNAMIC_CONFIG);
        return (status);
    }
    ASSERT (pPgmRegistry);
    pPgmRegistryConfig = pPgmRegistry;

    //---------------------------------------------------------------------------------------

    //
    // Allocate the data structures we need at Init time
    //
    status = AllocateInitialPgmStructures ();
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmTrace (LogError, ("InitPgm: ERROR -- "  \
            "FAILed to allocate initial structures = <%x>\n", status));
        CleanupInit (E_CLEANUP_REGISTRY_PARAMETERS);
        return (status);
    }

    //---------------------------------------------------------------------------------------
    //
    // Create the Pgm Device to be exported
    //
    status = PgmCreateDevice ();
    if (!NT_SUCCESS(status))
    {
        //
        // There must have been some major problems with the registry read, so we will not load!
        //
        PgmTrace (LogError, ("InitPgm: ERROR -- "  \
            "FAILed to create PgmDevice, status=<%x>\n", status));
        CleanupInit (E_CLEANUP_STRUCTURES);
        return (status);
    }

    PgmTrace (LogAllFuncs, ("InitPgm:  "  \
        "SUCCEEDed!\n"));

    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\query.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Query.c

Abstract:

    This module implements Query handling routines
    for the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "query.tmh"
#endif  // FILE_LOGGING

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
// #pragma alloc_text(PAGE, PgmQueryInformation)    Should not be pageable!
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
QueryAddressCompletion(
    IN PDEVICE_OBJECT   pDeviceContext,
    IN  PIRP            pIrp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query address
    Information completes.

Arguments:

    IN  pDeviceContext  -- unused.
    IN  pIrp         -- Supplies Irp that the transport has finished processing.
    IN  Context         -- not used

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    tTDI_QUERY_ADDRESS_INFO                 *pTdiQueryInfo;
    PIO_STACK_LOCATION                      pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    tCOMMON_SESSION_CONTEXT                 *pSession = pIrpSp->FileObject->FsContext;

    if ((NT_SUCCESS (pIrp->IoStatus.Status)) &&
        (pTdiQueryInfo = (tTDI_QUERY_ADDRESS_INFO *) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress,
                                                                                   HighPagePriority)))
    {
        if (PGM_VERIFY_HANDLE3 (pSession, PGM_VERIFY_SESSION_UNASSOCIATED,
                                          PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
        {
            PgmTrace (LogAllFuncs, ("QueryAddressCompletion:  "  \
                "Tdi IpAddress=<%x>, Port=<%x>\n",
                    ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->in_addr,
                    ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->sin_port));

            //
            // Save the transport's address information in our own structure!
            //
            pSession->TdiIpAddress =((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->in_addr;
            pSession->TdiPort = ((PTDI_ADDRESS_IP) &pTdiQueryInfo->IpAddress.Address[0].Address)->sin_port;
        }
        else
        {
            PgmTrace (LogError, ("QueryAddressCompletion: ERROR -- "  \
                "Invalid Session Context <%p>\n", pSession));
        }
    }
    else
    {
        PgmTrace (LogError, ("QueryAddressCompletion: ERROR -- "  \
            "Transport returned <%x>, pTdiQueryInfo=<%p>\n", pIrp->IoStatus.Status, pTdiQueryInfo));
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
QueryProviderCompletion(
    IN PDEVICE_OBJECT   pDeviceContext,
    IN  PIRP            pIrp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine handles the completion event when the Query Provider
    Information completes.  This routine must decrement the MaxDgramSize
    and max send size by the respective NBT header sizes.

Arguments:

    IN  pDeviceContext  -- unused.
    IN  pIrp         -- Supplies Irp that the transport has finished processing.
    IN  Context         -- not used

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    PTDI_PROVIDER_INFO      pProvider;

    if ((NT_SUCCESS (pIrp->IoStatus.Status)) &&
        (pProvider = (PTDI_PROVIDER_INFO) MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority)))
    {

        //
        // Set the correct service flags to indicate what Pgm supports.
        //
        pProvider->ServiceFlags = TDI_SERVICE_MESSAGE_MODE          |
                                  TDI_SERVICE_CONNECTION_MODE       |
                                  TDI_SERVICE_ERROR_FREE_DELIVERY   |
                                  TDI_SERVICE_MULTICAST_SUPPORTED   |
                                  TDI_SERVICE_NO_ZERO_LENGTH        |
                                  TDI_SERVICE_FORCE_ACCESS_CHECK    |
                                  TDI_SERVICE_ROUTE_DIRECTED;

/*
    ISSUE: Do we need: TDI_SERVICE_INTERNAL_BUFFERING ?
                        TDI_SERVICE_FORCE_ACCESS_CHECK ?
                        TDI_SERVICE_CONNECTIONLESS_MODE ?
                        TDI_SERVICE_DELAYED_ACCEPTANCE ?
                        TDI_SERVICE_BROADCAST_SUPPORTED ?
*/
        pProvider->MinimumLookaheadData = 1;

        //
        // The following data is for Streams
        //
        pProvider->MaxSendSize = SENDER_MAX_WINDOW_SIZE_PACKETS;

        if (pProvider->MaxDatagramSize > PGM_MAX_FEC_DATA_HEADER_LENGTH)
        {
            pProvider->MaxDatagramSize -= PGM_MAX_FEC_DATA_HEADER_LENGTH;
        }
        else
        {
            pProvider->MaxDatagramSize = 0;
        }

        PgmTrace (LogAllFuncs, ("QueryProviderCompletion:  "  \
            "SvcFlags=<%x> MaxSendSize=<%d>, MaxDgramSize=<%d>\n",
                pProvider->ServiceFlags, pProvider->MaxSendSize, pProvider->MaxDatagramSize));
    }
    else
    {
        PgmTrace (LogError, ("QueryProviderCompletion: ERROR -- "  \
            "Transport returned <%x>, pProvider=<%p>\n", pIrp->IoStatus.Status, pProvider));
    }

    //
    //  Must return a non-error status otherwise the IO system will not copy
    //  back into the users buffer.
    //
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
PgmQueryInformation(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine performs the TdiQueryInformation request for the transport
    provider.

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS                                status = STATUS_NOT_IMPLEMENTED;
    ULONG                                   Size, BytesCopied = 0;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   Query;
    tTDI_QUERY_ADDRESS_INFO                 TdiQueryInfo;
    tADDRESS_CONTEXT                        *pAddress = pIrpSp->FileObject->FsContext;
    tCOMMON_SESSION_CONTEXT                 *pSession = pIrpSp->FileObject->FsContext;

    Query = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION) &pIrpSp->Parameters;

    switch (Query->QueryType)
    {
        case TDI_QUERY_PROVIDER_INFO:
        {
            PgmTrace (LogAllFuncs, ("PgmQueryInformation:  "  \
                "[TDI_QUERY_PROVIDER_INFO]:\n"));

            TdiBuildQueryInformation (pIrp,
                                      pPgmDevice->pControlDeviceObject,
                                      pPgmDevice->pControlFileObject,
                                      QueryProviderCompletion,
                                      NULL,
                                      TDI_QUERY_PROVIDER_INFO,
                                      pIrp->MdlAddress);

            status = IoCallDriver (pPgmDevice->pControlDeviceObject, pIrp);
            //
            // we must return the next drivers ret code back to the IO subsystem
            //
            status = STATUS_PENDING;
            break;
        }

        case TDI_QUERY_ADDRESS_INFO:
        {
            if (pIrp->MdlAddress)
            {
                if (PGM_VERIFY_HANDLE2 (pAddress, PGM_VERIFY_ADDRESS, PGM_VERIFY_ADDRESS_DOWN))
                {
                    PgmZeroMemory (&TdiQueryInfo, sizeof (tTDI_QUERY_ADDRESS_INFO));
                    TdiQueryInfo.ActivityCount = 1;
                    TdiQueryInfo.IpAddress.TAAddressCount = 1;
                    TdiQueryInfo.IpAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
                    TdiQueryInfo.IpAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
                    ((PTDI_ADDRESS_IP) &TdiQueryInfo.IpAddress.Address[0].Address)->in_addr =
                        htonl (pAddress->ReceiverMCastAddr);
                    ((PTDI_ADDRESS_IP) &TdiQueryInfo.IpAddress.Address[0].Address)->sin_port =
                        htons (pAddress->ReceiverMCastPort);

                    //
                    // Due to the structure being Unaligned, we cannot reference the address
                    // and port fields directly!
                    //
                    Size = offsetof (tTDI_QUERY_ADDRESS_INFO, IpAddress.Address[0].Address)
                           + sizeof(TDI_ADDRESS_IP);

                    status = TdiCopyBufferToMdl (&TdiQueryInfo, 0, Size, pIrp->MdlAddress, 0, &BytesCopied);
                    pIrp->IoStatus.Information = BytesCopied;

                    PgmTrace (LogAllFuncs, ("PgmQueryInformation:  "  \
                        "[ADDRESS_INFO]: pAddress=<%p>, Copied=<%d/%d>\n", pAddress, BytesCopied, Size));

                    break;
                }
                else if (PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_RECEIVE))
                {
                    if ((pAddress = pSession->pAssociatedAddress) &&
                        (PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
                    {
                        TdiBuildQueryInformation (pIrp,
                                                  pAddress->pDeviceObject,
                                                  pAddress->pFileObject,
                                                  QueryAddressCompletion,
                                                  NULL,
                                                  TDI_QUERY_ADDRESS_INFO,
                                                  pIrp->MdlAddress);

                        PgmTrace (LogAllFuncs, ("PgmQueryInformation:  "  \
                            "[ADDRESS_INFO]: pSession=<%p>, querying transport ...\n", pSession));

                        status = IoCallDriver (pPgmDevice->pControlDeviceObject, pIrp);
                        //
                        // we must return the next drivers ret code back to the IO subsystem
                        //
                        status = STATUS_PENDING;
                    }
                    else
                    {
                        PgmTrace (LogError, ("PgmQueryInformation: ERROR -- "  \
                            "[ADDRESS_INFO]: pSession=<%p>, Invalid pAddress=<%p>\n", pSession, pAddress));

                        status = STATUS_INVALID_HANDLE;
                    }

                    break;
                }
                else    // neither an address nor a connect context!
                {
                    PgmTrace (LogError, ("PgmQueryInformation: ERROR -- "  \
                        "[TDI_QUERY_ADDRESS_INFO]: Invalid Handle=<%p>\n", pIrpSp->FileObject->FsContext));

                    status = STATUS_INVALID_HANDLE;
                }
            }
            else
            {
                PgmTrace (LogError, ("PgmQueryInformation: ERROR -- "  \
                    "[TDI_QUERY_ADDRESS_INFO]: No Mdl, pIrp=<%p>\n", pIrp));

                status = STATUS_UNSUCCESSFUL;
            }

            break;
        }

        default:
        {
            PgmTrace (LogError, ("PgmQueryInformation: ERROR -- "  \
                "Query=<%d> not Implemented!\n", Query->QueryType));

            break;
        }
    }

    return (status);
}
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\i386\xsum.asm ===
.xlist
include xsum.x86
.list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\amd64\xsum.asm ===
include xsum.amd64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\send.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Send.c

Abstract:

    This module implements Send routines
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "send.tmh"
#endif  // FILE_LOGGING

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
InitDataSpmOptions(
    IN      tCOMMON_SESSION_CONTEXT *pSession,
    IN      tCLIENT_SEND_REQUEST    *pSendContext,
    IN      PUCHAR                  pOptions,
    IN OUT  USHORT                  *pBufferSize,
    IN      ULONG                   PgmOptionsFlag,
    IN      tPACKET_OPTIONS         *pPacketOptions
    )
/*++

Routine Description:

    This routine initializes the header options for Data and Spm packets

Arguments:

    IN      pOptions                    -- Options buffer
    IN OUT  pBufferSize                 -- IN Maximum packet size, OUT Options length
    IN      PgmOptionsFlag              -- Options requested to be set by caller
    IN      pPacketOptions              -- Data for specific options
    IN      pSendContext                -- Context for this send

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    ULONG                               pOptionsData[3];
    USHORT                              OptionsLength = 0;
    USHORT                              MaxBufferSize = *pBufferSize;
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    tPACKET_OPTION_LENGTH  UNALIGNED    *pLengthOption = (tPACKET_OPTION_LENGTH UNALIGNED *) pOptions;

    //
    // Set the Packet Extension information
    //
    OptionsLength += PGM_PACKET_EXTENSION_LENGTH;
    if (OptionsLength > MaxBufferSize)
    {
        PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
            "Not enough space for HeaderExtension! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
        return (STATUS_INVALID_BLOCK_LENGTH);
    }
    pLengthOption->Type = PACKET_OPTION_LENGTH;
    pLengthOption->Length = PGM_PACKET_EXTENSION_LENGTH;
    
    //
    // First fill in the Network-Element-specific options:
    //
    if (PgmOptionsFlag & (PGM_OPTION_FLAG_CRQST | PGM_OPTION_FLAG_NBR_UNREACH))
    {
        // Not supporting these options for now
        ASSERT (0);
        return (STATUS_NOT_SUPPORTED);
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_PRM)
    {
        //
        // Applies to SPMs only
        //
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_PRM_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for PARITY_PRM Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_PARITY_PRM;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_PRM_LENGTH;

        pOptionHeader->U_OptSpecific = pSession->FECOptions;
        pOptionsData[0] = htonl (pPacketOptions->FECContext.FECGroupInfo);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for PARITY_CUR_TGSIZE Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_CURR_TGSIZE;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
        pOptionsData[0] = htonl (pPacketOptions->FECContext.NumPacketsInThisGroup);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // Now, fill in the non-Network significant options
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_SYN)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_SYN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for SYN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }

        pOptionHeader->E_OptionType = PACKET_OPTION_SYN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_SYN_LENGTH;

        if ((pSendContext) &&
            (pSendContext->DataOptions & PGM_OPTION_FLAG_SYN))
        {
            //
            // Remove this option once it has been used!
            //
            pSendContext->DataOptions &= ~PGM_OPTION_FLAG_SYN;
            pSendContext->DataOptionsLength -= PGM_PACKET_OPT_SYN_LENGTH;
            if (!pSendContext->DataOptions)
            {
                // No other options, so set the length to 0
                pSendContext->DataOptionsLength = 0;
            }
        }
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_FIN)
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_FIN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for FIN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_FIN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_FIN_LENGTH;
    }

    if (PgmOptionsFlag & (PGM_OPTION_FLAG_RST | PGM_OPTION_FLAG_RST_N))
    {
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_RST_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for RST Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_RST;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_RST_LENGTH;
        if (PgmOptionsFlag & PGM_OPTION_FLAG_RST_N)
        {
            pOptionHeader->U_OptSpecific = PACKET_OPTION_SPECIFIC_RST_N_BIT;
        }
    }

    //
    // now, set the FEC-specific options
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_PARITY_GRP)
    {
        //
        // Applies to Parity packets only
        //
        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_PARITY_GRP_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for PARITY_GRP Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_PARITY_GRP;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_PARITY_GRP_LENGTH;

        pOptionsData[0] = htonl (pPacketOptions->FECContext.FECGroupInfo);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // The following options should always be at the end, since they
    // are never net-sig.
    //
    if (PgmOptionsFlag & PGM_OPTION_FLAG_FRAGMENT)
    {
        pPacketOptions->FragmentOptionOffset = OptionsLength;

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for FragmentExtension! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_FRAGMENT;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_FRAGMENT_LENGTH;

        //
        // The PACKET_OPTION_RES_F_OPX_ENCODED_BIT will be set if necessary
        // later since the OptionSpecific component is computed at the same
        // time the entire data is encoded
        //
        pOptionsData[0] = htonl ((ULONG) pPacketOptions->MessageFirstSequence);
        pOptionsData[1] = htonl (pPacketOptions->MessageOffset);
        pOptionsData[2] = htonl (pPacketOptions->MessageLength);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (3 * sizeof(ULONG)));
    }

    if (PgmOptionsFlag & PGM_OPTION_FLAG_JOIN)
    {
        pPacketOptions->LateJoinerOptionOffset = OptionsLength;

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &pOptions[OptionsLength];
        OptionsLength += PGM_PACKET_OPT_JOIN_LENGTH;
        if (OptionsLength > MaxBufferSize)
        {
            PgmTrace (LogError, ("InitDataSpmOptions: ERROR -- "  \
                "Not enough space for JOIN Option! <%d> > <%d>\n", OptionsLength, MaxBufferSize));
            return (STATUS_INVALID_BLOCK_LENGTH);
        }
        pOptionHeader->E_OptionType = PACKET_OPTION_JOIN;
        pOptionHeader->OptionLength = PGM_PACKET_OPT_JOIN_LENGTH;
        pOptionsData[0] = htonl ((ULONG) (SEQ_TYPE) pPacketOptions->LateJoinerSequence);
        PgmCopyMemory ((pOptionHeader + 1), pOptionsData, (sizeof(ULONG)));
    }

    //
    // So far, so good -- so set the rest of the option-specific info
    //
    if (OptionsLength)
    {
        pLengthOption->TotalOptionsLength = htons (OptionsLength);   // Total length of all options
        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;        // Indicates the last option
    }

    *pBufferSize = OptionsLength;
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
InitDataSpmHeader(
    IN  tCOMMON_SESSION_CONTEXT *pSession,
    IN  tCLIENT_SEND_REQUEST    *pSendContext,
    IN  PUCHAR                  pHeader,
    IN  OUT USHORT              *pHeaderLength,
    IN  ULONG                   PgmOptionsFlag,
    IN  tPACKET_OPTIONS         *pPacketOptions,
    IN  UCHAR                   PacketType
    )
/*++

Routine Description:

    This routine initializes most of the header for Data and Spm packets
    and fills in all of the optional fields

Arguments:

    IN  pSession                    -- Pgm session (sender) context
    IN  pHeader                     -- Packet buffer
    IN  pHeaderLength               -- Maximum packet size
    IN  PgmOptionsFlag              -- Options requested to be set by caller
    IN  pPacketOptions              -- Data for specific options
    IN  PacketType                  -- whether Data or Spm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tCOMMON_HEADER                      *pCommonHeader = (tCOMMON_HEADER *) pHeader;
    USHORT                              HeaderLength;
    USHORT                              OptionsLength;
    NTSTATUS                            status = STATUS_SUCCESS;

// NOTE:  Session Lock must be held on Entry and Exit!

    if (!(PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_SEND, PGM_VERIFY_SESSION_DOWN)))
    {
        PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
            "Bad Session ptr = <%p>\n", pSession));
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // Memory for the Header must have been pre-allocated by the caller
    //
    if (*pHeaderLength < sizeof (tCOMMON_HEADER))
    {
        PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
            "InBufferLength = <%x> < Min = <%d>\n", *pHeaderLength, sizeof (tCOMMON_HEADER)));
        return (STATUS_INVALID_BUFFER_SIZE);
    }

    pCommonHeader->SrcPort = htons (pSession->TSI.hPort);
    PgmCopyMemory (&pCommonHeader->gSourceId, pSession->TSI.GSI, SOURCE_ID_LENGTH);
    pCommonHeader->Type = PacketType;
    pCommonHeader->Options = 0;
    pCommonHeader->DestPort = htons (pSession->pSender->DestMCastPort);

    //
    // Now, set the initial header size and verify that we have a
    // valid set of options based on the Packet type
    //
    switch (PacketType)
    {
        case (PACKET_TYPE_SPM):
        {
            HeaderLength = sizeof (tBASIC_SPM_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_SPM_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
                    "Unsupported Options flags=<%x> for SPM packets\n", PgmOptionsFlag));

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_SPM_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        case (PACKET_TYPE_ODATA):
        {
            HeaderLength = sizeof (tBASIC_DATA_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_DATA_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
                    "Unsupported Options flags=<%x> for ODATA packets\n", PgmOptionsFlag));

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_ODATA_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        case (PACKET_TYPE_RDATA):
        {
            HeaderLength = sizeof (tBASIC_DATA_PACKET_HEADER);
            if (PgmOptionsFlag != (PGM_VALID_DATA_OPTION_FLAGS & PgmOptionsFlag))
            {
                PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
                    "Unsupported Options flags=<%x> for RDATA packets\n", PgmOptionsFlag));

                return (STATUS_INVALID_PARAMETER);
            }

            if (PgmOptionsFlag & NETWORK_SIG_RDATA_OPTIONS_FLAGS)
            {
                pCommonHeader->Options |= PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT;
            }

            break;
        }

        default:
        {
            PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
                "Unsupported packet type = <%x>\n", PacketType));

            return (STATUS_INVALID_PARAMETER);          // Unrecognized Packet type!
        }
    }

    if (*pHeaderLength < HeaderLength)
    {
        PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
            "InBufferLength=<%x> < HeaderLength=<%d> based on PacketType=<%x>\n",
                *pHeaderLength, HeaderLength, PacketType));

        return (STATUS_INVALID_BLOCK_LENGTH);
    }

    //  
    // Add any options if specified
    //
    OptionsLength = 0;
    if (PgmOptionsFlag)
    {
        OptionsLength = *pHeaderLength - HeaderLength;
        status = InitDataSpmOptions (pSession,
                                     pSendContext,
                                     &pHeader[HeaderLength],
                                     &OptionsLength,
                                     PgmOptionsFlag,
                                     pPacketOptions);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("InitDataSpmHeader: ERROR -- "  \
                "InitDataSpmOptions returned <%x>\n", status));

            return (status);
        }

        //
        // So far, so good -- so set the rest of the option-specific info
        //
        pCommonHeader->Options |= PACKET_HEADER_OPTIONS_PRESENT;        // Set the options bit
    }

    //
    // The caller must now set the Checksum and other header information
    //
    PgmTrace (LogAllFuncs, ("InitDataSpmHeader:  "  \
        "pHeader=<%p>, HeaderLength=<%d>, OptionsLength=<%d>\n",
            pHeader, (ULONG) HeaderLength, (ULONG) OptionsLength));

    *pHeaderLength = HeaderLength + OptionsLength;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmSendSpmCompletion(
    IN  tSEND_SESSION                   *pSend,
    IN  tBASIC_SPM_PACKET_HEADER        *pSpmPacket,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This routine is called by the transport when the Spm send has been completed

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pSpmPacket  -- Spm packet buffer
    IN  status      --

Return Value:

    NONE

--*/
{
    PGMLockHandle               OldIrq;

    PgmLock (pSend, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Spm statistics
        //
        PgmTrace (LogAllFuncs, ("PgmSendSpmCompletion:  "  \
            "SUCCEEDED\n"));
    }
    else
    {
        PgmTrace (LogError, ("PgmSendSpmCompletion: ERROR -- "  \
            "status=<%x>\n", status));
    }
    PgmUnlock (pSend, OldIrq);

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_SPM);

    //
    // Free the Memory that was allocated for this
    //
    PgmFreeMem (pSpmPacket);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendSpm(
    IN  tSEND_SESSION   *pSend,
    IN  PGMLockHandle   *pOldIrq,
    OUT ULONG           *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send an Spm packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Return Value:

    NTSTATUS - Final status of the send

--*/
{
    NTSTATUS                    status;
    ULONG                       XSum, OptionsFlags;
    tBASIC_SPM_PACKET_HEADER    *pSpmPacket = NULL;
    tPACKET_OPTIONS             PacketOptions;
    USHORT                      PacketLength = (USHORT) pSend->pSender->pAddress->OutIfMTU;   // Init to max

    *pBytesSent = 0;

    if (!(pSpmPacket = PgmAllocMem (PacketLength, PGM_TAG('2'))))
    {
        PgmTrace (LogError, ("PgmSendSpm: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pSpmPacket, PacketLength);
    PgmZeroMemory (&PacketOptions, sizeof(tPACKET_OPTIONS));

    OptionsFlags = pSend->pSender->SpmOptions;
    if (OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        //
        // See if we have enough packets for the LateJoiner sequence numbers
        //
        if (SEQ_GEQ (pSend->pSender->NextODataSequenceNumber, (pSend->pSender->TrailingGroupSequenceNumber +
                                                               pSend->pSender->LateJoinSequenceNumbers)))
        {
            PacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) (pSend->pSender->NextODataSequenceNumber -
                                                                   pSend->pSender->LateJoinSequenceNumbers);
        }
        else
        {
            PacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) pSend->pSender->TrailingGroupSequenceNumber;
        }
    }

    if (OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM)    // Check if this is FEC-enabled
    {
        PacketOptions.FECContext.FECGroupInfo = pSend->FECGroupSize;

        //
        // See if we need to set the CURR_TGSIZE option for variable Group length
        //
        if ((pSend->pSender->EmptySequencesForLastSend) &&
            (pSend->pSender->LastVariableTGPacketSequenceNumber ==
             (pSend->pSender->NextODataSequenceNumber - (1 + pSend->pSender->EmptySequencesForLastSend))))
        {
            PacketOptions.FECContext.NumPacketsInThisGroup = pSend->FECGroupSize -
                                                             (UCHAR)pSend->pSender->EmptySequencesForLastSend;
            OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;
            ASSERT (PacketOptions.FECContext.NumPacketsInThisGroup);
        }
    }

    status = InitDataSpmHeader (pSend,
                                NULL,
                                (PUCHAR) pSpmPacket,
                                &PacketLength,
                                OptionsFlags,
                                &PacketOptions,
                                PACKET_TYPE_SPM);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmSendSpm: ERROR -- "  \
            "InitDataSpmHeader returned <%x>\n", status));

        PgmFreeMem (pSpmPacket);
        return (status);
    }

    ASSERT (PacketLength);

    pSpmPacket->SpmSequenceNumber = htonl ((ULONG) pSend->pSender->NextSpmSequenceNumber++);
    pSpmPacket->TrailingEdgeSeqNumber = htonl ((ULONG) pSend->pSender->TrailingGroupSequenceNumber);
    pSpmPacket->LeadingEdgeSeqNumber = htonl ((ULONG)((SEQ_TYPE)(pSend->pSender->NextODataSequenceNumber - 1)));
    pSpmPacket->PathNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pSpmPacket->PathNLA.IpAddress = htonl (pSend->pSender->SenderMCastOutIf);

    pSpmPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pSpmPacket, PacketLength);       // Compute the Checksum
    pSpmPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_SPM, TRUE);
    PgmUnlock (pSend, *pOldIrq);

    status = TdiSendDatagram (pSend->pSender->pAddress->pRAlertFileObject,
                              pSend->pSender->pAddress->pRAlertDeviceObject,
                              pSpmPacket,
                              PacketLength,
                              PgmSendSpmCompletion,     // Completion
                              pSend,                    // Context1
                              pSpmPacket,               // Context2
                              pSend->pSender->DestMCastIpAddress,
                              pSend->pSender->DestMCastPort,
                              FALSE);

    ASSERT (NT_SUCCESS (status));

    PgmTrace (LogAllFuncs, ("PgmSendSpm:  "  \
        "Sent <%d> bytes to <%x:%d>, Options=<%x>, Window=[%d--%d]\n",
            (ULONG) PacketLength, pSend->pSender->DestMCastIpAddress, pSend->pSender->DestMCastPort,
            OptionsFlags, (ULONG) pSend->pSender->TrailingGroupSequenceNumber,
            (ULONG) (pSend->pSender->NextODataSequenceNumber-1)));

    PgmLock (pSend, *pOldIrq);

    *pBytesSent = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmSendRDataCompletion(
    IN  tSEND_RDATA_CONTEXT *pRDataContext,
    IN  PVOID               pRDataBuffer,
    IN  NTSTATUS            status
    )
/*++

Routine Description:

    This routine is called by the transport when the RData send has been completed

Arguments:

    IN  pRDataContext   -- RData context
    IN  pContext2       -- not used
    IN  status          --

Return Value:

    NONE

--*/
{
    tSEND_SESSION       *pSend = pRDataContext->pSend;
    PGMLockHandle       OldIrq;

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmSendRDataCompletion: ERROR -- "  \
            "status=<%x>\n", status));
    }

    //
    // Set the RData statistics
    //
    PgmLock (pSend, OldIrq);
    if ((!--pRDataContext->NumPacketsInTransport) &&
        (!AnyMoreNaks(pRDataContext)))
    {
        ASSERT (pSend->pSender->NumRDataRequestsPending <= pSend->pSender->pRDataInfo->NumAllocated);
        if (pRDataContext->PostRDataHoldTime)
        {
            if (!pRDataContext->CleanupTime)
            {
                pSend->pSender->NumRDataRequestsPending--;
            }
            pRDataContext->CleanupTime = pSend->pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
        }
        else
        {
            //
            // We have already removed the entry, so just destroy it!
            //
            DestroyEntry (pSend->pSender->pRDataInfo, pRDataContext);
        }
    }
    PgmUnlock (pSend, OldIrq);

    if (pRDataBuffer)
    {
        ExFreeToNPagedLookasideList (&pSend->pSender->SenderBufferLookaside, pRDataBuffer);
    }

    PgmTrace (LogAllFuncs, ("PgmSendRDataCompletion:  "  \
        "status=<%x>, pRDataBuffer=<%p>\n", status, pRDataBuffer));

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_RDATA);
    return;
}


//----------------------------------------------------------------------------

NTSTATUS
PgmBuildParityPacket(
    IN  tSEND_SESSION               *pSend,
    IN  tPACKET_BUFFER              *pPacketBuffer,
    IN  tBUILD_PARITY_CONTEXT       *pParityContext,
    IN  PUCHAR                      pFECPacket,
    IN OUT  USHORT                  *pPacketLength,
    IN  UCHAR                       PacketType
    )
{
    NTSTATUS                            status;
    tPACKET_OPTIONS                     PacketOptions;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECContext;
    tPOST_PACKET_FEC_CONTEXT            FECContext;
    ULONG                               SequenceNumber;
    ULONG                               FECGroupMask;
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    USHORT                              PacketLength = *pPacketLength;  // Init to max buffer length
    tBASIC_DATA_PACKET_HEADER UNALIGNED *pRData = (tBASIC_DATA_PACKET_HEADER UNALIGNED *)
                                                        &pPacketBuffer->DataPacket;

    *pPacketLength = 0;     // Init, in case of error

    //
    // First, get the options encoded in this RData packet to see
    // if we need to use them!
    //
    FECGroupMask = pSend->FECGroupSize - 1;
    pParityContext->NextFECPacketIndex = pPacketBuffer->PacketOptions.FECContext.SenderNextFECPacketIndex;
    SequenceNumber = (ntohl(pRData->DataSequenceNumber)) | (pParityContext->NextFECPacketIndex & FECGroupMask);
    ASSERT (!(pParityContext->OptionsFlags & ~(PGM_OPTION_FLAG_SYN |
                                               PGM_OPTION_FLAG_FIN |
                                               PGM_OPTION_FLAG_FRAGMENT |
                                               PGM_OPTION_FLAG_PARITY_CUR_TGSIZE |
                                               PGM_OPTION_FLAG_PARITY_GRP)));

    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));

    //
    // We don't need to set any parameters for the SYN and FIN options
    // We will set the parameters for the FRAGMENT option (if needed) later
    // since will need to have the encoded paramters
    //
    if (pParityContext->OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        ASSERT (pParityContext->NumPacketsInThisGroup);
        PacketOptions.FECContext.NumPacketsInThisGroup = pParityContext->NumPacketsInThisGroup;
    }

    if (pParityContext->NextFECPacketIndex >= pSend->FECGroupSize)
    {
        pParityContext->OptionsFlags |= PGM_OPTION_FLAG_PARITY_GRP;
        PacketOptions.FECContext.FECGroupInfo = pParityContext->NextFECPacketIndex / pSend->FECGroupSize;
    }

    //
    // The Out buffer must be initialized before entering this routine
    //
    // PgmZeroMemory (pFECPacket, PacketLength);
    status = InitDataSpmHeader (pSend,
                                NULL,
                                (PUCHAR) pFECPacket,
                                &PacketLength,
                                pParityContext->OptionsFlags,
                                &PacketOptions,
                                PacketType);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmBuildParityPacket: ERROR -- "  \
            "InitDataSpmHeader returned <%x>\n", status));
        return (status);
    }

#ifdef FEC_DBG
if (pParityContext->NextFECPacketIndex == pSend->FECGroupSize)
{
    UCHAR                               i;
    PUCHAR                              *ppData;
    PUCHAR                              pData;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECC;
    tPOST_PACKET_FEC_CONTEXT            FECC;

    ppData = &pParityContext->pDataBuffers[0];
    PgmTrace (LogFec, ("\n"));
    for (i=0; i<pSend->FECGroupSize; i++)
    {
        pData = ppData[i];
        pFECC = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *) &pData[pSend->pSender->MaxPayloadSize];
        PgmCopyMemory (&FECC, pFECC, sizeof (tPOST_PACKET_FEC_CONTEXT));
        PgmTrace (LogFec, ("\t[%d]  EncTSDULen=<%x>, Fpr=<%x>, [%x -- %x -- %x]\n",
            SequenceNumber+i, FECC.EncodedTSDULength, FECC.FragmentOptSpecific,
            FECC.EncodedFragmentOptions.MessageFirstSequence,
            FECC.EncodedFragmentOptions.MessageOffset,
            FECC.EncodedFragmentOptions.MessageLength));
    }
}
#endif  // FEC_DBG

    status = FECEncode (&pSend->FECContext,
                        &pParityContext->pDataBuffers[0],
                        pParityContext->NumPacketsInThisGroup,
                        (pSend->pSender->MaxPayloadSize + sizeof (tPOST_PACKET_FEC_CONTEXT)),
                        pParityContext->NextFECPacketIndex,
                        &pFECPacket[PacketLength]);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("PgmBuildParityPacket: ERROR -- "  \
            "FECEncode returned <%x>\n", status));
        return (status);
    }

#ifdef FEC_DBG
{
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECC;
    tPOST_PACKET_FEC_CONTEXT            FECC;

    pFECC = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *) &pFECPacket[PacketLength+pSend->pSender->MaxPayloadSize];
    PgmCopyMemory (&FECC, pFECC, sizeof (tPOST_PACKET_FEC_CONTEXT));

    PgmTrace (LogFec, ("[%d:%d] ==> EncTSDULen=<%x>, Fpr=<%x>, [%x -- %x -- %x]\n",
        (ULONG) SequenceNumber, (ULONG) pParityContext->NextFECPacketIndex,
        FECC.EncodedTSDULength, FECC.FragmentOptSpecific,
        FECC.EncodedFragmentOptions.MessageFirstSequence,
        FECC.EncodedFragmentOptions.MessageOffset,
        FECC.EncodedFragmentOptions.MessageLength));
}
#endif  // FEC_DBG

    //
    // Now, fill in the remaining fields of the header
    //
    pRData = (tBASIC_DATA_PACKET_HEADER *) pFECPacket;

    //
    // Set the FEC-specific options
    //
    pRData->CommonHeader.Options |= (PACKET_HEADER_OPTIONS_PARITY |
                                     PACKET_HEADER_OPTIONS_VAR_PKTLEN);

    if (pParityContext->OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
    {
        pFECContext = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *) (pFECPacket +
                                                              PacketLength +
                                                              pSend->pSender->MaxPayloadSize);
        PgmCopyMemory (&FECContext, pFECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

        ASSERT (pRData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT);
        if (PacketOptions.FragmentOptionOffset)
        {
            pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) &((PUCHAR) (pRData + 1)) [PacketOptions.FragmentOptionOffset];

            pOptionHeader->Reserved_F_Opx |= PACKET_OPTION_RES_F_OPX_ENCODED_BIT;
            pOptionHeader->U_OptSpecific = FECContext.FragmentOptSpecific;

            PgmCopyMemory ((pOptionHeader + 1),
                           &FECContext.EncodedFragmentOptions,
                           (sizeof (tFRAGMENT_OPTIONS)));
        }
        else
        {
            ASSERT (0);
        }
    }

    pRData->CommonHeader.TSDULength = htons ((USHORT) pSend->pSender->MaxPayloadSize + sizeof (USHORT));
    pRData->DataSequenceNumber = htonl (SequenceNumber);

    //
    // Set the next FECPacketIndex
    //
    if (++pParityContext->NextFECPacketIndex >= pSend->FECBlockSize)    // n
    {
        pParityContext->NextFECPacketIndex = pSend->FECGroupSize;       // k
    }
    pPacketBuffer->PacketOptions.FECContext.SenderNextFECPacketIndex = pParityContext->NextFECPacketIndex;

    PacketLength += (USHORT) (pSend->pSender->MaxPayloadSize + sizeof (USHORT));
    *pPacketLength = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendRData(
    IN      tSEND_SESSION       *pSend,
    IN      tSEND_RDATA_CONTEXT *pRDataContext,
    IN      PGMLockHandle       *pOldIrq,
    OUT     ULONG               *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send a Repair Data (RData) packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the send request

--*/
{
    NTSTATUS                    status;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached, fInserted;
    LIST_ENTRY                  *pEntry;
    ULONGLONG                   OffsetBytes;
    ULONG                       XSum, PacketsBehindLeadingEdge, NumNaksProcessed;
    tBASIC_DATA_PACKET_HEADER   *pRData;
    PUCHAR                      pSendBuffer = NULL;
    USHORT                      i, PacketLength;
    tPACKET_BUFFER              *pPacketBuffer;
    tPACKET_BUFFER              *pPacketBufferTemp;
    SEQ_TYPE                    RDataSequenceNumber;
    tSEND_CONTEXT               *pSender = pSend->pSender;
    USHORT                      NakType;
    UCHAR                       NakIndex;
    BOOLEAN                     fMoreRequests;

    *pBytesSent = 0;
    if (!(pSendBuffer = ExAllocateFromNPagedLookasideList (&pSender->SenderBufferLookaside)))
    {
        PgmTrace (LogError, ("PgmSendRData: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PacketLength = PGM_MAX_FEC_DATA_HEADER_LENGTH + (USHORT) pSender->MaxPayloadSize;
    ASSERT (PacketLength <= pSender->PacketBufferSize);

    NumNaksProcessed = 1;
    RDataSequenceNumber = pRDataContext->RDataSequenceNumber;
    if (pSend->FECOptions)
    {
        if (pRDataContext->NumParityNaks)
        {
            NakType = NAK_TYPE_PARITY;
            pRDataContext->NumParityNaks--;
        }
        else
        {
            NakType = NAK_TYPE_SELECTIVE;
            if (GetNextNakIndex (pRDataContext, &NakIndex))
            {
                ASSERT (NakIndex < pSend->FECGroupSize);
                RDataSequenceNumber += NakIndex;
            }
            else
            {
                ASSERT (0);
            }
        }

        if (!(fMoreRequests = AnyMoreNaks (pRDataContext)))
        {
            pRDataContext->CleanupTime = pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
            pSender->NumRDataRequestsPending--;
            if (!pRDataContext->PostRDataHoldTime)
            {
                RemoveEntry (pSender->pRDataInfo, pRDataContext);
            }
        }
    }
    else
    {
        NakType = NAK_TYPE_SELECTIVE;
        pRDataContext->SelectiveNaksMask[0] = 0;
        fMoreRequests = FALSE;
        pRDataContext->CleanupTime = pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
        pSender->NumRDataRequestsPending--;
        if (!pRDataContext->PostRDataHoldTime)
        {
            RemoveEntry (pSender->pRDataInfo, pRDataContext);
        }
    }

    ASSERT (PGM_MAX_FEC_DATA_HEADER_LENGTH >= PGM_MAX_DATA_HEADER_LENGTH);
    ASSERT ((SEQ_LT (RDataSequenceNumber, pSender->NextODataSequenceNumber)) &&
            (SEQ_GEQ (RDataSequenceNumber, pSender->TrailingGroupSequenceNumber)));

    //
    // Find the buffer address based on offset from the trailing edge
    // Also, check for wrap-around
    //
    OffsetBytes = (SEQ_TYPE) (RDataSequenceNumber-pSender->TrailingEdgeSequenceNumber) *
                              pSender->PacketBufferSize;
    OffsetBytes += pSender->TrailingWindowOffset;
    if (OffsetBytes >= pSender->MaxDataFileSize)
    {
        OffsetBytes -= pSender->MaxDataFileSize;             // Wrap -around
    }

    pPacketBuffer = (tPACKET_BUFFER *) (((PUCHAR) pSender->SendDataBufferMapping) + OffsetBytes);

    pRDataContext->NumPacketsInTransport++;        // Referenced until SendCompletion
    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_RDATA, TRUE);

    PgmUnlock (pSend, *pOldIrq);
    PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);

    switch (NakType)
    {
        case (NAK_TYPE_PARITY):
        {
            //
            // If this is the first parity packet to be sent from this group,
            // then we will need to initialize the buffers
            //
            if (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup)
            {
                pRDataContext->OnDemandParityContext.OptionsFlags = 0;
                pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = 0;

                pPacketBufferTemp = pPacketBuffer;
                for (i=0; i<pSend->FECGroupSize; i++)
                {
                    pRDataContext->OnDemandParityContext.pDataBuffers[i] = &((PUCHAR) &pPacketBufferTemp->DataPacket)
                                                                    [sizeof (tBASIC_DATA_PACKET_HEADER) +
                                                                     pPacketBufferTemp->PacketOptions.OptionsLength];

                    pRDataContext->OnDemandParityContext.OptionsFlags |= pPacketBufferTemp->PacketOptions.OptionsFlags &
                                                                         (PGM_OPTION_FLAG_SYN |
                                                                          PGM_OPTION_FLAG_FIN |
                                                                          PGM_OPTION_FLAG_FRAGMENT |
                                                                          PGM_OPTION_FLAG_PARITY_CUR_TGSIZE);

                    if (pPacketBufferTemp->PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
                    {
                        ASSERT (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup);
                        ASSERT (pPacketBufferTemp->PacketOptions.FECContext.NumPacketsInThisGroup);
                        pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = pPacketBufferTemp->PacketOptions.FECContext.NumPacketsInThisGroup;
                    }

                    pPacketBufferTemp = (tPACKET_BUFFER *) (((PUCHAR) pPacketBufferTemp) +
                                                            pSender->PacketBufferSize);
                }

                if (!(pRDataContext->OnDemandParityContext.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE))
                {
                    ASSERT (!pRDataContext->OnDemandParityContext.NumPacketsInThisGroup);
                    pRDataContext->OnDemandParityContext.NumPacketsInThisGroup = pSend->FECGroupSize;
                }
            }

            ASSERT (pRDataContext->OnDemandParityContext.pDataBuffers[0]);

            //
            // If we have just 1 packet in this group, then we just do
            // a selective Nak
            //
            if (pRDataContext->OnDemandParityContext.NumPacketsInThisGroup != 1)
            {
                PgmZeroMemory (pSendBuffer, PacketLength);     // Zero the buffer
                status = PgmBuildParityPacket (pSend,
                                               pPacketBuffer,
                                               &pRDataContext->OnDemandParityContext,
                                               pSendBuffer,
                                               &PacketLength,
                                               PACKET_TYPE_RDATA);
                if (!NT_SUCCESS (status))
                {
                    PgmTrace (LogError, ("PgmSendRData: ERROR -- "  \
                        "PgmBuildParityPacket returned <%x>\n", status));

                    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);
                    PgmLock (pSend, *pOldIrq);

                    ExFreeToNPagedLookasideList (&pSender->SenderBufferLookaside, pSendBuffer);

                    if ((!fMoreRequests) &&
                        (!pRDataContext->PostRDataHoldTime))
                    {
                        ASSERT (pRDataContext->CleanupTime);
                        DestroyEntry (pSend->pSender->pRDataInfo, pRDataContext);
                    }
                    else
                    {
                        pRDataContext->NumPacketsInTransport--;         // Undoing what we did earlier
                        ASSERT (!pRDataContext->CleanupTime);
                        pRDataContext->NumParityNaks++;
                        pSender->NumRDataRequestsPending++;
                    }

                    return (status);
                }

                break;
            }

            //
            // FALL THROUGH to send a selective Nak!
            // Do not send any more Naks for this group!
            //
            NakType = NAK_TYPE_SELECTIVE;
            if (fMoreRequests)
            {
                NumNaksProcessed += pRDataContext->NumParityNaks;
                pRDataContext->NumParityNaks = 0;
                while (GetNextNakIndex (pRDataContext, &NakIndex))
                {
                    NumNaksProcessed++;
                }

                fMoreRequests = FALSE;
                pRDataContext->CleanupTime = pSender->TimerTickCount + pRDataContext->PostRDataHoldTime;
                pSender->NumRDataRequestsPending--;
                if (!pRDataContext->PostRDataHoldTime)
                {
                    RemoveEntry (pSender->pRDataInfo, pRDataContext);
                }
            }
        }

        case (NAK_TYPE_SELECTIVE):
        {
            //
            // Since the packet was already filled in earlier, we just need to
            // update the Trailing Edge Seq number + PacketType and Checksum!
            //
            pRData = &pPacketBuffer->DataPacket;
            ASSERT ((ULONG) RDataSequenceNumber == (ULONG) ntohl (pRData->DataSequenceNumber));

            PacketLength = pPacketBuffer->PacketOptions.TotalPacketLength;

            PgmCopyMemory (pSendBuffer, pRData, PacketLength);

            break;
        }

        default:
        {
            ASSERT (0);
        }
    }

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_SEND_RDATA);

    pRData = (tBASIC_DATA_PACKET_HEADER *) pSendBuffer;
    pRData->TrailingEdgeSequenceNumber = htonl ((ULONG) pSender->TrailingGroupSequenceNumber);
    pRData->CommonHeader.Type = PACKET_TYPE_RDATA;
    pRData->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pRData, (ULONG) PacketLength);       // Compute the Checksum
    pRData->CommonHeader.Checksum = (USHORT) (~XSum);

    status = TdiSendDatagram (pSender->pAddress->pRAlertFileObject,
                              pSender->pAddress->pRAlertDeviceObject,
                              pRData,
                              (ULONG) PacketLength,
                              PgmSendRDataCompletion,                                   // Completion
                              pRDataContext,                                            // Context1
                              pSendBuffer,                                               // Context2
                              pSender->DestMCastIpAddress,
                              pSender->DestMCastPort,
                              FALSE);

    ASSERT (NT_SUCCESS (status));

    PgmTrace (LogAllFuncs, ("PgmSendRData:  "  \
        "[%d] Sent <%d> bytes to <%x->%d>\n",
            (ULONG) RDataSequenceNumber, (ULONG) PacketLength,
            pSender->DestMCastIpAddress, pSender->DestMCastPort));

    PgmLock (pSend, *pOldIrq);

    ASSERT (pSender->NumRDataRequestsPending <= pSender->pRDataInfo->NumAllocated);

    pSender->NumOutstandingNaks -= NumNaksProcessed;
    pSender->TotalRDataPacketsSent++;
    pSender->RDataPacketsInLastInterval++;

    *pBytesSent = PacketLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmSendNcfCompletion(
    IN  tSEND_SESSION                   *pSend,
    IN  tBASIC_NAK_NCF_PACKET_HEADER    *pNcfPacket,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This routine is called by the transport when the Ncf send has been completed

Arguments:

    IN  pSend           -- Pgm session (sender) context
    IN  pNcfPacket      -- Ncf packet buffer
    IN  status          --

Return Value:

    NONE

--*/
{
    PGMLockHandle       OldIrq;

    PgmLock (pSend, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Ncf statistics
        //
        PgmTrace (LogAllFuncs, ("PgmSendNcfCompletion:  "  \
            "SUCCEEDED\n"));
    }
    else
    {
        PgmTrace (LogError, ("PgmSendNcfCompletion: ERROR -- "  \
            "status=<%x>\n", status));
    }
    PgmUnlock (pSend, OldIrq);

    PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_NCF);
    PgmFreeMem (pNcfPacket);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNcf(
    IN  tSEND_SESSION                           *pSend,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakPacket,
    IN  tNAKS_LIST                              *pNcfsList,
    IN  ULONG                                   NakPacketLength
    )
/*++

Routine Description:

    This routine is called to send an NCF packet

Arguments:

    IN  pSend           -- Pgm session (sender) context
    IN  pNakPacket      -- Nak packet which trigerred the Ncf
    IN  NakPacketLength -- Length of Nak packet

Return Value:

    NTSTATUS - Final status of the send

--*/
{
    ULONG                           i, XSum;
    NTSTATUS                        status;
    tBASIC_NAK_NCF_PACKET_HEADER    *pNcfPacket;
    tPACKET_OPTION_LENGTH           *pPacketExtension;
    tPACKET_OPTION_GENERIC          *pOptionHeader;
    USHORT                          OptionsLength = 0;

    if (!(pNcfPacket = PgmAllocMem (NakPacketLength, PGM_TAG('2'))))
    {
        PgmTrace (LogError, ("PgmSendNcf: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pNcfPacket, NakPacketLength);    // Copy the packet in its entirety

    //
    // Now, set the fields specific to this sender
    //
    pNcfPacket->CommonHeader.DestPort = htons (pSend->pSender->DestMCastPort);
    pNcfPacket->CommonHeader.SrcPort = htons (pSend->TSI.hPort);
    PgmCopyMemory (&pNcfPacket->CommonHeader.gSourceId, pSend->TSI.GSI, SOURCE_ID_LENGTH);
    pNcfPacket->CommonHeader.Type = PACKET_TYPE_NCF;
    if (pNcfsList->NakType == NAK_TYPE_PARITY)
    {
        pNcfPacket->CommonHeader.Options = PACKET_HEADER_OPTIONS_PARITY;
        for (i=0; i<pNcfsList->NumSequences; i++)
        {
            pNcfsList->NumParityNaks[i]--;      // Convert from NumParityNaks to NakIndex
        }
    }
    else
    {
        pNcfPacket->CommonHeader.Options = 0;
    }

    pNcfPacket->SourceNLA.NLA_AFI = pNakPacket->SourceNLA.NLA_AFI;
    pNcfPacket->SourceNLA.IpAddress = pNakPacket->SourceNLA.IpAddress;
    pNcfPacket->MCastGroupNLA.NLA_AFI = pNakPacket->MCastGroupNLA.NLA_AFI;
    pNcfPacket->MCastGroupNLA.IpAddress = pNakPacket->MCastGroupNLA.IpAddress;

    //
    // Now, fill in the Sequence numbers
    //
    pNcfPacket->RequestedSequenceNumber = htonl ((ULONG) ((SEQ_TYPE) (pNcfsList->pNakSequences[0] +
                                                                      pNcfsList->NakIndex[0])));
    if (pNcfsList->NumSequences > 1)
    {
        pPacketExtension = (tPACKET_OPTION_LENGTH *) (pNcfPacket + 1);
        pPacketExtension->Type = PACKET_OPTION_LENGTH;
        pPacketExtension->Length = PGM_PACKET_EXTENSION_LENGTH;
        OptionsLength += PGM_PACKET_EXTENSION_LENGTH;

        pOptionHeader = (tPACKET_OPTION_GENERIC *) (pPacketExtension + 1);
        pOptionHeader->E_OptionType = PACKET_OPTION_NAK_LIST;
        pOptionHeader->OptionLength = 4 + (UCHAR) ((pNcfsList->NumSequences-1) * sizeof(ULONG));
        for (i=1; i<pNcfsList->NumSequences; i++)
        {
            ((PULONG) (pOptionHeader))[i] = htonl ((ULONG) ((SEQ_TYPE) (pNcfsList->pNakSequences[i] +
                                                                        pNcfsList->NakIndex[i])));
        }

        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;    // One and only (last) opt
        pNcfPacket->CommonHeader.Options |=(PACKET_HEADER_OPTIONS_PRESENT |
                                            PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT);
        OptionsLength = PGM_PACKET_EXTENSION_LENGTH + pOptionHeader->OptionLength;
        pPacketExtension->TotalOptionsLength = htons (OptionsLength);
    }

    OptionsLength += sizeof(tBASIC_NAK_NCF_PACKET_HEADER);  // Now is whole pkt

    pNcfPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pNcfPacket, NakPacketLength);
    pNcfPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_NCF, FALSE);

    status = TdiSendDatagram (pSend->pSender->pAddress->pRAlertFileObject,
                              pSend->pSender->pAddress->pRAlertDeviceObject,
                              pNcfPacket,
                              OptionsLength,
                              PgmSendNcfCompletion,     // Completion
                              pSend,                    // Context1
                              pNcfPacket,               // Context2
                              pSend->pSender->DestMCastIpAddress,
                              pSend->pSender->DestMCastPort,
                              FALSE);

    ASSERT (NT_SUCCESS (status));

    PgmTrace (LogAllFuncs, ("PgmSendNcf:  "  \
        "Sent <%d> bytes to <%x:%d>\n",
            NakPacketLength, pSend->pSender->DestMCastIpAddress, pSend->pSender->DestMCastPort));

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
SenderProcessNakPacket(
    IN  tADDRESS_CONTEXT                        *pAddress,
    IN  tSEND_SESSION                           *pSend,
    IN  ULONG                                   PacketLength,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakPacket
    )
/*++

Routine Description:

    This routine processes an incoming Nak packet sent to the sender

Arguments:

    IN  pAddress        -- Pgm's address object
    IN  pSend           -- Pgm session (sender) context
    IN  PacketLength    -- Nak packet length
    IN  pNakPacket      -- Nak packet data


Return Value:

    NTSTATUS - Final status of the call

--*/
{
    PGMLockHandle                   OldIrq;
    tNAKS_LIST                      NaksList;
    tSEND_RDATA_CONTEXT             *pRDataContext;
    tSEND_RDATA_CONTEXT             *pRDataNew;
    SEQ_TYPE                        LastSequenceNumber;
    NTSTATUS                        status;

    ASSERT (!pNakPacket->CommonHeader.TSDULength);

    PgmLock (pSend, OldIrq);

    //
    // Initialize the last sequence number
    //
    LastSequenceNumber = pSend->pSender->NextODataSequenceNumber;
    status = ExtractNakNcfSequences (pNakPacket,
                                     (PacketLength - sizeof(tBASIC_NAK_NCF_PACKET_HEADER)),
                                     &NaksList,
                                     &LastSequenceNumber,
                                     pSend->FECGroupSize);
    if (!NT_SUCCESS (status))
    {
        PgmUnlock (pSend, OldIrq);
        PgmTrace (LogError, ("SenderProcessNakPacket: ERROR -- "  \
            "ExtractNakNcfSequences returned <%x>\n", status));

        return (status);
    }

    pSend->pSender->NaksReceived += NaksList.NumSequences;

    //
    // The oldest as well as latest sequence numbers have to be in our window
    //
    if (SEQ_LT (NaksList.pNakSequences[0], pSend->pSender->TrailingGroupSequenceNumber) ||
        SEQ_GEQ (LastSequenceNumber, pSend->pSender->NextODataSequenceNumber))
    {
        pSend->pSender->NaksReceivedTooLate++;
        PgmUnlock (pSend, OldIrq);

        PgmTrace (LogError, ("SenderProcessNakPacket: ERROR -- "  \
            "Invalid %s Naks = [%d-%d] not in window [%d -- [%d]\n",
                (NaksList.NakType == NAK_TYPE_PARITY ? "Parity" : "Selective"),
                (ULONG) NaksList.pNakSequences[0], (ULONG) LastSequenceNumber,
                (ULONG) pSend->pSender->TrailingGroupSequenceNumber, (ULONG) (pSend->pSender->NextODataSequenceNumber-1)));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Check if this is a parity Nak and we are anabled for Parity Naks
    //
    if ((pNakPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY) &&
        !(pSend->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT))
    {
        PgmTrace (LogError, ("SenderProcessNakPacket: ERROR -- "  \
            "Receiver requested Parity Naks, but we are not enabled for parity!\n"));

        PgmUnlock (pSend, OldIrq);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    status = FilterAndAddNaksToList (pSend, &NaksList);

    PgmUnlock (pSend, OldIrq);

    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("SenderProcessNakPacket: ERROR -- "  \
            "FilterAndAddNaksToList returned <%x>\n", status));

        return (status);
    }

    //
    // If applicable, send the Ncf for this Nak
    //
    if (NaksList.NumSequences)
    {
        PgmTrace (LogAllFuncs, ("SenderProcessNakPacket:  "  \
            "Now sending Ncf for Nak received for <%d> Sequences, NakType=<%x>\n",
                NaksList.NumSequences, NaksList.NakType));

        status = PgmSendNcf (pSend, pNakPacket, &NaksList, PacketLength);
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

VOID
PgmSendODataCompletion(
    IN  tCLIENT_SEND_REQUEST        *pSendContext,
    IN  tPACKET_BUFFER              *pPacketBuffer,
    IN  NTSTATUS                    status
    )
/*++

Routine Description:

    This routine is called by the transport when the OData send has been completed

Arguments:

    IN  pSendContext    -- Pgm's Send context
    IN  pUnused         -- not used
    IN  status          --

Return Value:

    NONE

--*/
{
    ULONG                               SendLength;
    PGMLockHandle                       OldIrq;
    PIRP                                pIrpCurrentSend = NULL;
    PIRP                                pIrpToComplete = NULL;
    tSEND_SESSION                       *pSend = pSendContext->pSend;

    PgmLock (pSend, OldIrq);

    if (NT_SUCCESS (status))
    {
        //
        // Set the Ncf statistics
        //
        PgmTrace (LogAllFuncs, ("PgmSendODataCompletion:  "  \
            "SUCCEEDED\n"));

        if (!pPacketBuffer)
        {
            pSendContext->NumDataPacketsSentSuccessfully++;
        }
    }
    else
    {
        PgmTrace (LogError, ("PgmSendODataCompletion: ERROR -- "  \
            "status=<%x>\n", status));
    }

    //
    // If all the OData has been sent, we may need to complete the Irp
    // Since we don't know whether we are on the CurrentSend or Completed
    // Sends list, we will need to also check the Bytes
    //
    if ((--pSendContext->NumSendsPending == 0) &&                       // No other sends pending
        (pSendContext->NumParityPacketsToSend == 0) &&                  // No parity packets pending
        (!pSendContext->BytesLeftToPacketize) &&                        // All bytes have been packetized
        (pSendContext->NumDataPacketsSent == pSendContext->DataPacketsPacketized))  // Pkts sent == total Pkts
    {
        PgmTrace (LogAllFuncs, ("PgmSendODataCompletion:  "  \
            "Completing Send#=<%d>, pIrp=<%p> for <%d> packets, Seq=[%d, %d]\n",
                pSendContext->SendNumber, pSendContext->pIrp, pSendContext->DataPacketsPacketized,
                (ULONG) pSendContext->StartSequenceNumber, (ULONG) pSendContext->EndSequenceNumber));

        pSend->DataBytes += pSendContext->BytesInSend;
        if (pIrpCurrentSend = pSendContext->pIrp)
        {
            if (pSendContext->NumDataPacketsSentSuccessfully == pSendContext->NumDataPacketsSent)
            {
                status = STATUS_SUCCESS;
                SendLength = pSendContext->BytesInSend;

                PgmTrace (LogPath, ("PgmSendODataCompletion:  "  \
                    "pIrp=<%p -- %p>, pSendContext=<%p>, NumPackets sent successfully = <%d/%d>\n",
                        pSendContext->pIrp, pSendContext->pIrpToComplete, pSendContext,
                        pSendContext->NumDataPacketsSentSuccessfully, pSendContext->NumDataPacketsSent));
            }
            else
            {
                PgmTrace (LogError, ("PgmSendODataCompletion: ERROR -- "  \
                    "pIrp=<%p -- %p>, pSendContext=<%p>, NumPackets sent successfully = <%d/%d>\n",
                        pSendContext->pIrp, pSendContext->pIrpToComplete, pSendContext,
                        pSendContext->NumDataPacketsSentSuccessfully, pSendContext->NumDataPacketsSent));

                status = STATUS_UNSUCCESSFUL;
                SendLength = 0;
            }

            pSendContext->pIrp = NULL;
            pIrpToComplete = pSendContext->pIrpToComplete;
        }
        else
        {
            ASSERT (0);     // To verify there is no double completion!
        }

        if (pSendContext->pMessage2Request)
        {
            //
            // We could have a situation where the send was split into 2, and
            // the second send could either be in the PendingSends list or
            // the PendingPacketizedSends list, or the CompletedSendsInWindow list
            //
            // We should have the other send complete the Irp and delink ourselves
            //
            ASSERT (pSendContext == pSendContext->pMessage2Request->pMessage2Request);

            if (pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pIrpToComplete = pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }
    }

    PgmUnlock (pSend, OldIrq);

    if (pPacketBuffer)
    {
        ExFreeToNPagedLookasideList (&pSend->pSender->SenderBufferLookaside, pPacketBuffer);
    }

    if (pIrpCurrentSend)
    {
        if (pIrpToComplete)
        {
            PgmIoComplete (pIrpToComplete, status, SendLength);
        }
        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
GetNextPacketOptionsAndData(
    IN  tSEND_SESSION               *pSend,
    IN  tCLIENT_SEND_REQUEST        *pSendContext,
    IN  tBASIC_DATA_PACKET_HEADER   **ppODataBuffer,
    IN  PGMLockHandle               *pOldIrq,
    OUT USHORT                      *pPacketLength
    )
{
    KAPC_STATE                          ApcState;
    BOOLEAN                             fAttached;
    NTSTATUS                            status;
    SEQ_TYPE                            NextODataSequenceNumber, FECGroupMask;
    PUCHAR                              pSendBuffer;
    tPACKET_BUFFER                      *pFileBuffer;
    tPACKET_OPTIONS                     EmptyPacketOptions;
    ULONG                               ulBytes, ulOptionsLength;
    ULONG                               i, DataBytesInThisPacket;
    USHORT                              usBytes, HeaderLength, PacketsLeftInGroup;
    tPOST_PACKET_FEC_CONTEXT            FECContext;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pBufferFECContext;
    tPACKET_OPTIONS                     *pPacketOptions;
    tBASIC_DATA_PACKET_HEADER           *pODataBuffer;
    ULONG                               PacketBufferSize;
    ULONG                               MaxPayloadSize;
    tSEND_CONTEXT                       *pSender = pSend->pSender;
    UCHAR                               NumPackets, EmptyPackets = 0;

    //
    // Get the current send packet
    //
    pFileBuffer = (tPACKET_BUFFER *) (pSender->SendDataBufferMapping + pSendContext->NextPacketOffset);

    pPacketOptions = &pFileBuffer->PacketOptions;
    pODataBuffer = &pFileBuffer->DataPacket;
    *ppODataBuffer = pODataBuffer;              // Save this buffer address!

    NextODataSequenceNumber = pSender->NextODataSequenceNumber;
    PacketBufferSize = pSender->PacketBufferSize;
    MaxPayloadSize = pSender->MaxPayloadSize;

    //
    // Prepare info for any applicable options
    //
    if (pSendContext->BytesLeftToPacketize > pSender->MaxPayloadSize)
    {
        DataBytesInThisPacket = pSender->MaxPayloadSize;
    }
    else
    {
        DataBytesInThisPacket = (USHORT) pSendContext->BytesLeftToPacketize;
    }
    ASSERT (DataBytesInThisPacket);

    PgmZeroMemory (&EmptyPacketOptions, sizeof (tPACKET_OPTIONS));

    //
    // See if we need to set the FIN flag
    //
    if ((pSendContext->bLastSend) &&
        (pSendContext->BytesLeftToPacketize == DataBytesInThisPacket))
    {
        PgmTrace (LogPath, ("GetNextPacketOptionsAndData:  "  \
            "Setting Fin flag since bLastSend set for last packet!\n"));

        //
        // We have finished packetizing all the packets, but
        // since this is the last send we also need to set the
        // FIN on the last packet
        //
        pSendContext->bLastSend = FALSE;
        if (!pSendContext->DataOptions)
        {
            ASSERT (!pSendContext->DataOptionsLength);
            pSendContext->DataOptionsLength = PGM_PACKET_EXTENSION_LENGTH;
        }

        if ((pSend->SessionFlags & PGM_SESSION_SENDS_CANCELLED) ||
            !(pSend->pIrpDisconnect))
        {
            pSendContext->DataOptions |= PGM_OPTION_FLAG_RST;
            pSendContext->DataOptionsLength += PGM_PACKET_OPT_RST_LENGTH;
        }
        else
        {
            pSendContext->DataOptions |= PGM_OPTION_FLAG_FIN;
            pSendContext->DataOptionsLength += PGM_PACKET_OPT_FIN_LENGTH;
        }
    }
    EmptyPacketOptions.OptionsFlags = pSendContext->DataOptions;
    ulOptionsLength = pSendContext->DataOptionsLength;  // Save for assert below

    if (EmptyPacketOptions.OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
    {
        EmptyPacketOptions.MessageFirstSequence = (ULONG) (SEQ_TYPE) pSendContext->MessageFirstSequenceNumber;
        EmptyPacketOptions.MessageOffset =  pSendContext->LastMessageOffset + pSendContext->NextDataOffsetInMdl;
        EmptyPacketOptions.MessageLength = pSendContext->ThisMessageLength;
    }

    if (EmptyPacketOptions.OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        //
        // See if we have enough packets for the LateJoiner sequence numbers
        //
        if (SEQ_GT (NextODataSequenceNumber, (pSender->TrailingGroupSequenceNumber +
                                              pSender->LateJoinSequenceNumbers)))
        {
            EmptyPacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) (NextODataSequenceNumber -
                                                                     pSender->LateJoinSequenceNumbers);
        }
        else
        {
            EmptyPacketOptions.LateJoinerSequence = (ULONG) (SEQ_TYPE) pSender->TrailingGroupSequenceNumber;
        }
    }

    if (pSend->FECOptions)                          // Check if this is FEC-enabled
    {
        FECGroupMask = pSend->FECGroupSize-1;
        PacketsLeftInGroup = pSend->FECGroupSize - (UCHAR) (NextODataSequenceNumber & FECGroupMask);
        //
        // Save information if we are at beginning of group boundary
        //
        if (PacketsLeftInGroup == pSend->FECGroupSize)
        {
            EmptyPacketOptions.FECContext.SenderNextFECPacketIndex = pSend->FECGroupSize;
        }

        //
        // Check if we need to set the variable TG size option
        //
        if ((pSender->NumPacketsRemaining == 1) &&              // Last packet
            (PacketsLeftInGroup > 1))                           // Variable TG size
        {
            //
            // This is a variable Transmission Group Size, i.e. PacketsInGroup < pSend->FECGroupSize
            //
            if (!EmptyPacketOptions.OptionsFlags)
            {
                ulOptionsLength = PGM_PACKET_EXTENSION_LENGTH;
            }
            ulOptionsLength += PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
            EmptyPacketOptions.OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;

            EmptyPacketOptions.FECContext.NumPacketsInThisGroup = 1 + (UCHAR) (NextODataSequenceNumber & FECGroupMask);
            pSender->LastVariableTGPacketSequenceNumber = NextODataSequenceNumber;
            EmptyPackets = (UCHAR) (PacketsLeftInGroup - 1);

            pSendContext->NumParityPacketsToSend = pSend->FECProActivePackets;
        }

        //
        // Otherwise see if the next send needs to be for pro-active parity
        //
        else if ((pSend->FECProActivePackets) &&    // Need to send FEC pro-active packets
                 (1 == PacketsLeftInGroup))         // Last Packet In Group
        {
            pSendContext->NumParityPacketsToSend = pSend->FECProActivePackets;
        }

        //
        // If this is the GroupLeader packet, and we have pro-active parity enabled,
        // then we need to set the buffer information for computing the FEC packets
        //
        if ((pSend->FECProActivePackets) &&                 // Need to send FEC pro-active packets
            (pSend->FECGroupSize == PacketsLeftInGroup))    // GroupLeader
        {
            pSender->pLastProActiveGroupLeader = pFileBuffer;
        }
    }

    HeaderLength = (USHORT) pSender->MaxPayloadSize;          // Init -- max buffer size available

    //
    // Now, save the Buffer(s) to the memory-mapped file for repairs
    //
    PgmUnlock (pSend, *pOldIrq);
    PgmAcquireResourceExclusive (&pSend->pSender->Resource, TRUE);
    PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

    PgmZeroMemory (pODataBuffer, PGM_MAX_FEC_DATA_HEADER_LENGTH);     // Zero the buffer
    status = InitDataSpmHeader (pSend,
                                pSendContext,
                                (PUCHAR) pODataBuffer,
                                &HeaderLength,
                                EmptyPacketOptions.OptionsFlags,
                                &EmptyPacketOptions,
                                PACKET_TYPE_ODATA);

    if (NT_SUCCESS (status))
    {
        ASSERT ((sizeof(tBASIC_DATA_PACKET_HEADER) + ulOptionsLength) == HeaderLength);
        ASSERT ((pSend->FECBlockSize && (HeaderLength+pSendContext->DataPayloadSize) <=
                                        (PacketBufferSize-sizeof(tPOST_PACKET_FEC_CONTEXT))) ||
                (!pSend->FECBlockSize && ((HeaderLength+pSendContext->DataPayloadSize) <=
                                          PacketBufferSize)));

        ulBytes = 0;
        status = TdiCopyMdlToBuffer (pSendContext->pIrp->MdlAddress,
                                     pSendContext->NextDataOffsetInMdl,
                                     (((PUCHAR) pODataBuffer) + HeaderLength),
                                     0,                         // Destination Offset
                                     DataBytesInThisPacket,
                                     &ulBytes);

        if (((!NT_SUCCESS (status)) && (STATUS_BUFFER_OVERFLOW != status)) || // Overflow acceptable!
            (ulBytes != DataBytesInThisPacket))
        {
            PgmTrace (LogError, ("GetNextPacketOptionsAndData: ERROR -- "  \
                "TdiCopyMdlToBuffer returned <%x>, BytesCopied=<%d/%d>\n",
                    status, ulBytes, DataBytesInThisPacket));

            status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }
    else
    {
        PgmTrace (LogError, ("GetNextPacketOptionsAndData: ERROR -- "  \
            "InitDataSpmHeader returned <%x>\n", status));
    }

    if (!NT_SUCCESS (status))
    {
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
        PgmReleaseResource (&pSend->pSender->Resource);
        PgmLock (pSend, *pOldIrq);

        if ((pSendContext->DataOptions & PGM_OPTION_FLAG_FIN) &&
            (pSendContext->BytesLeftToPacketize == DataBytesInThisPacket))
        {
            pSendContext->bLastSend = TRUE;
            pSendContext->DataOptions &= ~PGM_OPTION_FLAG_FIN;
            if (pSendContext->DataOptions)
            {
                pSendContext->DataOptionsLength -= PGM_PACKET_OPT_FIN_LENGTH;
            }
            else
            {
                pSendContext->DataOptionsLength = 0;
            }
        }
        pSendContext->NumParityPacketsToSend = 0;

        return (status);
    }

    pODataBuffer->CommonHeader.TSDULength = htons ((USHORT) DataBytesInThisPacket);
    pODataBuffer->DataSequenceNumber = htonl ((ULONG) NextODataSequenceNumber);

    EmptyPacketOptions.OptionsLength = HeaderLength - sizeof (tBASIC_DATA_PACKET_HEADER);
    EmptyPacketOptions.TotalPacketLength = HeaderLength + (USHORT) DataBytesInThisPacket;
    *pPacketLength = EmptyPacketOptions.TotalPacketLength;

    //
    // Zero out the remaining buffer
    //
    PgmZeroMemory ((((PUCHAR) pODataBuffer)+EmptyPacketOptions.TotalPacketLength),
                   (PacketBufferSize-(sizeof(tPACKET_OPTIONS)+EmptyPacketOptions.TotalPacketLength)));

    //
    // Set the PacketOptions Information for FEC packets
    //
    if (pSend->FECOptions)
    {
        pBufferFECContext = (tPOST_PACKET_FEC_CONTEXT *) (((PUCHAR) pODataBuffer) +
                                                           HeaderLength +
                                                           MaxPayloadSize);
        PgmZeroMemory (&FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

        FECContext.EncodedTSDULength = htons ((USHORT) DataBytesInThisPacket);
        FECContext.EncodedFragmentOptions.MessageFirstSequence = htonl ((ULONG) (SEQ_TYPE) EmptyPacketOptions.MessageFirstSequence);
        FECContext.EncodedFragmentOptions.MessageOffset =  htonl (EmptyPacketOptions.MessageOffset);
        FECContext.EncodedFragmentOptions.MessageLength = htonl (EmptyPacketOptions.MessageLength);
        PgmCopyMemory (pBufferFECContext, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

        //
        // If this is not a fragment, set the PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT
        //
        if (!(EmptyPacketOptions.OptionsFlags & PGM_OPTION_FLAG_FRAGMENT))
        {
            ((PUCHAR) pBufferFECContext)
                [FIELD_OFFSET (tPOST_PACKET_FEC_CONTEXT, FragmentOptSpecific)] =
                    PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
        }
    }

    //
    // Save the PacketOptions
    //
    PgmCopyMemory (pPacketOptions, &EmptyPacketOptions, sizeof (tPACKET_OPTIONS));

    //
    // From this point onwards, pFileBuffer will not be a valid ptr
    //
    NextODataSequenceNumber++;
    if (EmptyPackets)
    {
        if (EmptyPacketOptions.OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
        {
            EmptyPacketOptions.OptionsFlags &= ~PGM_OPTION_FLAG_FRAGMENT;
            ulOptionsLength -= PGM_PACKET_OPT_FRAGMENT_LENGTH;
        }

        if (EmptyPacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
        {
            EmptyPacketOptions.OptionsFlags &= ~PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;
            ulOptionsLength -= PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH;
        }

        if (!EmptyPacketOptions.OptionsFlags)
        {
            ulOptionsLength = 0;
        }

        EmptyPacketOptions.OptionsLength = (USHORT) ulOptionsLength;

        NumPackets = EmptyPackets;
        while (NumPackets--)
        {
            pFileBuffer = (tPACKET_BUFFER *) (((PUCHAR) pFileBuffer) + PacketBufferSize);

            pPacketOptions = &pFileBuffer->PacketOptions;
            pODataBuffer = &pFileBuffer->DataPacket;
            PgmCopyMemory (pPacketOptions, &EmptyPacketOptions, sizeof (tPACKET_OPTIONS));
            PgmZeroMemory (pODataBuffer, (PacketBufferSize-sizeof(tPACKET_OPTIONS)));        // Zero the buffer

            HeaderLength = (USHORT) MaxPayloadSize;                    // Init -- max buffer size available
            status = InitDataSpmHeader (pSend,
                                        pSendContext,
                                        (PUCHAR) &pFileBuffer->DataPacket,
                                        &HeaderLength,
                                        EmptyPacketOptions.OptionsFlags,
                                        &EmptyPacketOptions,
                                        PACKET_TYPE_ODATA);

            //
            // Since these packets are not expected to be sent, we will ignore the return status!
            //
            ASSERT (NT_SUCCESS (status));
            ASSERT ((sizeof(tBASIC_DATA_PACKET_HEADER) + ulOptionsLength) == HeaderLength);
            ASSERT ((HeaderLength+pSendContext->DataPayloadSize) <=
                    (PacketBufferSize-sizeof(tPOST_PACKET_FEC_CONTEXT)));

            pODataBuffer->CommonHeader.TSDULength = 0;
            pODataBuffer->DataSequenceNumber = htonl ((ULONG) NextODataSequenceNumber++);

            pPacketOptions->TotalPacketLength = HeaderLength;
            pPacketOptions->OptionsLength = HeaderLength - sizeof (tBASIC_DATA_PACKET_HEADER);
        }
    }

    if (pSendContext->NumParityPacketsToSend)
    {
        //
        // Start from the Group leader packet
        //
        ASSERT (pSender->pLastProActiveGroupLeader);
        pFileBuffer = pSender->pLastProActiveGroupLeader;
        pSendBuffer = (PUCHAR) pFileBuffer;

        pSender->pProActiveParityContext->OptionsFlags = 0;
        pSender->pProActiveParityContext->NumPacketsInThisGroup = 0;

        for (i=0; i<pSend->FECGroupSize; i++)
        {
            pSender->pProActiveParityContext->pDataBuffers[i] =
                    &((PUCHAR) &pFileBuffer->DataPacket)[sizeof(tBASIC_DATA_PACKET_HEADER) +
                                                         pFileBuffer->PacketOptions.OptionsLength];
            pSender->pProActiveParityContext->OptionsFlags |= pFileBuffer->PacketOptions.OptionsFlags &
                                                              (PGM_OPTION_FLAG_SYN |
                                                               PGM_OPTION_FLAG_FIN |
                                                               PGM_OPTION_FLAG_FRAGMENT |
                                                               PGM_OPTION_FLAG_PARITY_CUR_TGSIZE);

            if (pFileBuffer->PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
            {
                ASSERT (!pSender->pProActiveParityContext->NumPacketsInThisGroup);
                ASSERT (pFileBuffer->PacketOptions.FECContext.NumPacketsInThisGroup);
                pSender->pProActiveParityContext->NumPacketsInThisGroup = pFileBuffer->PacketOptions.FECContext.NumPacketsInThisGroup;
            }

            pSendBuffer += PacketBufferSize;
            pFileBuffer = (tPACKET_BUFFER *) pSendBuffer;
        }

        if (!(pSender->pProActiveParityContext->OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE))
        {
            ASSERT (!pSender->pProActiveParityContext->NumPacketsInThisGroup);
            pSender->pProActiveParityContext->NumPacketsInThisGroup = pSend->FECGroupSize;
        }
    }

    PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
    PgmReleaseResource (&pSend->pSender->Resource);
    PgmLock (pSend, *pOldIrq);

    ASSERT (pSender->BufferPacketsAvailable >= (ULONG) (1 + EmptyPackets));
    ASSERT (NextODataSequenceNumber == (pSender->NextODataSequenceNumber + 1 + EmptyPackets));

    //
    // Update the Send buffer information
    //
    pSendContext->DataPacketsPacketized++;
    pSendContext->NextPacketOffset += PacketBufferSize;
    pSendContext->DataBytesInLastPacket = DataBytesInThisPacket;
    pSendContext->NextDataOffsetInMdl += DataBytesInThisPacket;
    pSendContext->BytesLeftToPacketize -= DataBytesInThisPacket;
    if (!pSendContext->BytesLeftToPacketize)
    {
        pSendContext->EndSequenceNumber = pSender->NextODataSequenceNumber;
    }


    pSender->LastODataSentSequenceNumber++;
    ASSERT (pSender->LastODataSentSequenceNumber == pSender->NextODataSequenceNumber);
    pSender->NextODataSequenceNumber++;
    pSender->NumPacketsRemaining--;
    pSender->BufferPacketsAvailable--;
    pSender->BufferSizeAvailable -= pSender->PacketBufferSize;
    pSender->LeadingWindowOffset += pSender->PacketBufferSize;
    pSender->EmptySequencesForLastSend = EmptyPackets;

    while (EmptyPackets--)
    {
        pSender->NextODataSequenceNumber++;
        pSender->BufferPacketsAvailable--;
        pSender->BufferSizeAvailable -= pSender->PacketBufferSize;
        pSender->LeadingWindowOffset += pSender->PacketBufferSize;
        pSendContext->NextPacketOffset += pSender->PacketBufferSize;

        ASSERT (pSender->LeadingWindowOffset <= pSender->MaxDataFileSize);
    }

    ASSERT (pSender->NextODataSequenceNumber == NextODataSequenceNumber);

    if (pSender->LeadingWindowOffset >= pSender->MaxDataFileSize)
    {
        ASSERT (pSender->LeadingWindowOffset == pSender->MaxDataFileSize);
        pSender->LeadingWindowOffset = 0;
    }

    if (pSendContext->NextPacketOffset >= pSender->MaxDataFileSize)
    {
        ASSERT (pSendContext->NextPacketOffset == pSender->MaxDataFileSize);
        pSendContext->NextPacketOffset = 0;                                 // We need to wrap around!
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNextOData(
    IN  tSEND_SESSION       *pSend,
    IN  PGMLockHandle       *pOldIrq,
    OUT ULONG               *pBytesSent
    )
/*++

Routine Description:

    This routine is called to send a Data (OData) packet
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  pOldIrq     -- pSend's OldIrq
    OUT pBytesSent  -- Set if send succeeded (used for calculating throughput)

Return Value:

    NTSTATUS - Final status of the send request

--*/
{
    ULONG                       i, XSum;
    USHORT                      SendBufferLength;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;
    tCLIENT_SEND_REQUEST        *pSendContext;
    tPACKET_OPTIONS             PacketOptions;
    ULONG                       OptionValue;
    tSEND_CONTEXT               *pSender = pSend->pSender;
    SEQ_TYPE                    FECGroupMask = pSend->FECGroupSize-1;
    BOOLEAN                     fSendingFECPacket = FALSE;
    BOOLEAN                     fResetOptions = FALSE;
    tBASIC_DATA_PACKET_HEADER   *pODataBuffer = NULL;
    tPACKET_BUFFER              *pSendBuffer = NULL;
    UCHAR                       EmptyPackets = 0;
    NTSTATUS                    status = STATUS_SUCCESS;

    *pBytesSent = 0;        // Initialize
    if (pSend->pSender->BufferPacketsAvailable < pSend->FECGroupSize)
    {
        return (STATUS_SUCCESS);
    }

    if (IsListEmpty (&pSender->PendingPacketizedSends))
    {
        if (IsListEmpty (&pSender->PendingSends))
        {
            ASSERT (0);
            ExFreeToNPagedLookasideList (&pSender->SenderBufferLookaside, pSendBuffer);
            return (STATUS_UNSUCCESSFUL);
        }

        pSendContext = CONTAINING_RECORD (pSender->PendingSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
        RemoveEntryList (&pSendContext->Linkage);
        InsertTailList (&pSender->PendingPacketizedSends, &pSendContext->Linkage);

        pSendContext->NextPacketOffset = pSend->pSender->LeadingWindowOffset;       // First packet's offset
        pSendContext->StartSequenceNumber = pSend->pSender->NextODataSequenceNumber;
        pSendContext->EndSequenceNumber = pSend->pSender->NextODataSequenceNumber;  // temporary

        if (pSendContext->LastMessageOffset)
        {
            pSendContext->MessageFirstSequenceNumber = pSend->pSender->LastMessageFirstSequence;
        }
        else
        {
            pSendContext->MessageFirstSequenceNumber = pSendContext->StartSequenceNumber;
            pSend->pSender->LastMessageFirstSequence = pSendContext->StartSequenceNumber;
        }
    }
    else
    {
        pSendContext = CONTAINING_RECORD (pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
    }

    //
    // This routine is called only if we have a packet to send, so
    // set pODataBuffer to the packet to be sent
    // NumDataPacketsSent and DataPacketsPacketized should both be 0 for a fresh send
    // They will be equal if we had run out of Buffer space for the last
    // packetization (i.e. Send length > available buffer space)
    //

    if (pSendContext->NumParityPacketsToSend)
    {
        SendBufferLength = (USHORT) pSender->PacketBufferSize;
        if (!(pSendBuffer = ExAllocateFromNPagedLookasideList (&pSender->SenderBufferLookaside)))
        {
            PgmTrace (LogError, ("PgmSendNextOData: ERROR -- "  \
                "STATUS_INSUFFICIENT_RESOURCES\n"));
            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        PgmZeroMemory (pSendBuffer, pSender->PacketBufferSize);     // Zero the buffer
        pODataBuffer = &pSendBuffer->DataPacket;

        //
        // Release the Send lock and attach to the SectionMap process
        // to compute the parity packet
        //
        PgmUnlock (pSend, *pOldIrq);
        PgmAttachToProcessForVMAccess (pSend->Process, &ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);

        SendBufferLength -= sizeof (tPACKET_OPTIONS);
        status = PgmBuildParityPacket (pSend,
                                       pSender->pLastProActiveGroupLeader,
                                       pSender->pProActiveParityContext,
                                       (PUCHAR) pODataBuffer,
                                       &SendBufferLength,
                                       PACKET_TYPE_ODATA);

        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_PACKETIZE);
        PgmLock (pSend, *pOldIrq);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmSendNextOData: ERROR -- "  \
                "PgmBuildParityPacket returned <%x>\n", status));

            ExFreeToNPagedLookasideList (&pSender->SenderBufferLookaside, pSendBuffer);
            return (STATUS_SUCCESS);
        }

        ASSERT (SendBufferLength <= (PGM_MAX_FEC_DATA_HEADER_LENGTH +
                                     htons (pODataBuffer->CommonHeader.TSDULength)));
        fSendingFECPacket = TRUE;
        pSendContext->NumParityPacketsToSend--;
    }
    else
    {
        if (!pSendContext->NumDataPacketsSent)
        {
            pSendContext->SendStartTime = pSend->pSender->TimerTickCount;
            if (pSend->FECOptions)
            {
                ASSERT ((SEQ_LT (pSender->LastODataSentSequenceNumber, pSender->NextODataSequenceNumber)) &&
                    ((pSender->NextODataSequenceNumber - pSender->LastODataSentSequenceNumber) <= pSend->FECGroupSize));
                pSender->LastODataSentSequenceNumber = pSender->NextODataSequenceNumber - 1;
            }
        }

        status = GetNextPacketOptionsAndData (pSend, pSendContext, &pODataBuffer, pOldIrq, &SendBufferLength);
        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmSendNextOData: ERROR -- "  \
                "GetNextPacketOptionsAndDataOffset returned <%x>\n", status));

            return (STATUS_SUCCESS);
        }

        ASSERT (pSendContext->NumDataPacketsSent < pSendContext->DataPacketsPacketized);
        pSendContext->NumDataPacketsSent++;
    }

    //
    // If we have sent all the data for this Send (or however many bytes
    // we had packetized from this send), we need to packetize more packets
    //
    if ((pSendContext->NumDataPacketsSent == pSendContext->DataPacketsPacketized) &&
        (!pSendContext->NumParityPacketsToSend) &&
        (!pSendContext->BytesLeftToPacketize))
    {
        //
        // Move it to the CompletedSends list
        // The last send completion will complete the Send Irp
        //
        ASSERT (pSender->NextODataSequenceNumber == (1 + pSendContext->EndSequenceNumber + pSender->EmptySequencesForLastSend));

        RemoveEntryList (&pSendContext->Linkage);
        InsertTailList (&pSender->CompletedSendsInWindow, &pSendContext->Linkage);
        pSender->NumODataRequestsPending--;
        //
        // If the last packet on this Send had a FIN, we will need to
        // follow this send with an Ambient SPM including the FIN flag
        //
        ASSERT (!pSendContext->bLastSend);
        if (pSendContext->DataOptions & PGM_OPTION_FLAG_FIN)
        {
            PgmTrace (LogPath, ("PgmSendNextOData:  "  \
                "Setting FIN since client closed session!\n"));

            pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
            pSender->CurrentSPMTimeout = pSender->AmbientSPMTimeout;
            pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
        }
    }

    pSendContext->NumSendsPending++;
    ASSERT (pSendContext->NumSendsPending);
    PgmUnlock (pSend, *pOldIrq);

    pODataBuffer->TrailingEdgeSequenceNumber = htonl ((ULONG) pSender->TrailingGroupSequenceNumber);
    XSum = 0;
    pODataBuffer->CommonHeader.Checksum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pODataBuffer, SendBufferLength);       // Compute the Checksum
    pODataBuffer->CommonHeader.Checksum = (USHORT) (~XSum);

    status = TdiSendDatagram (pSender->pAddress->pFileObject,
                              pSender->pAddress->pDeviceObject,
                              pODataBuffer,
                              (ULONG) SendBufferLength,
                              PgmSendODataCompletion,   // Completion
                              pSendContext,             // Context1
                              pSendBuffer,              // Context2
                              pSender->DestMCastIpAddress,
                              pSender->DestMCastPort,
                              (BOOLEAN) (pSendBuffer ? FALSE : TRUE));

    ASSERT (NT_SUCCESS (status));

    PgmTrace (LogAllFuncs, ("PgmSendNextOData:  "  \
        "[%d-%d] -- Sent <%d> bytes to <%x:%d>\n",
            (ULONG) pSender->TrailingGroupSequenceNumber,
            (ULONG) pSender->LastODataSentSequenceNumber,
            SendBufferLength, pSender->DestMCastIpAddress, pSender->DestMCastPort));

    PgmLock (pSend, *pOldIrq);

    pSend->pSender->TotalODataPacketsSent++;
    pSend->pSender->ODataPacketsInLastInterval++;

    *pBytesSent = SendBufferLength;
    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmCancelAllSends(
    IN  tSEND_SESSION           *pSend,
    IN  LIST_ENTRY              *pListEntry,
    IN  PIRP                    pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Send Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PLIST_ENTRY             pEntry;
    tCLIENT_SEND_REQUEST    *pSendContext;
    PIRP                    pIrpToComplete = NULL;
    SEQ_TYPE                HighestLeadSeq;
    ULONG                   NumExSequencesInOldWindow, NumRequests = 0;
    ULONGLONG               BufferSpaceFreed;

    //
    // Now cancel all the remaining send requests because the integrity
    // of the data cannot be guaranteed
    // We also have to deal with the fact that some Irps may have
    // data in the transport (i.e. possibly the first send on the Packetized
    // list, or the last send of the completed list)
    //
    // We will start with the unpacketized requests
    //
    while (!IsListEmpty (&pSend->pSender->PendingSends))
    {
        pEntry = RemoveHeadList (&pSend->pSender->PendingSends);
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        InsertTailList (pListEntry, pEntry);
        NumRequests++;

        ASSERT (!pSendContext->NumSendsPending);

        //
        // If this is a partial send, we will mark the Irp for completion
        // initially to the companion send request (to avoid complications
        // of Sends pending in the transport here)
        //
        if (pSendContext->pMessage2Request)
        {
            //
            // pMessage2Request could either be on the PendingPacketizedSends
            // list or on the Completed Sends list (awaiting a send completion)
            //
            ASSERT (pSendContext->pMessage2Request->pIrp);
            if (pSendContext->pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }

        ASSERT (pSendContext->BytesLeftToPacketize == pSendContext->BytesInSend);
        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;
    }

    //
    // Now, go through all the sends which have already been packetized
    // except for the first one which we will handle below
    //
    HighestLeadSeq = pSend->pSender->NextODataSequenceNumber;
    pEntry = pSend->pSender->PendingPacketizedSends.Flink;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingPacketizedSends)
    {
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        pEntry = pEntry->Blink;
        RemoveEntryList (&pSendContext->Linkage);
        InsertTailList (pListEntry, &pSendContext->Linkage);
        pSend->pSender->NumODataRequestsPending--;
        pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;
        NumRequests++;

        if (SEQ_LT (pSendContext->StartSequenceNumber, HighestLeadSeq))
        {
            HighestLeadSeq = pSendContext->StartSequenceNumber;
        }

        ASSERT ((!pSendContext->NumDataPacketsSent) && (!pSendContext->NumSendsPending));
        if (pSendContext->pMessage2Request)
        {
            //
            // pMessage2Request could either be on the PendingPacketizedSends
            // list or on the Completed Sends list (awaiting a send completion)
            //
            ASSERT (pSendContext->pMessage2Request->pIrp);
            if (pSendContext->pIrpToComplete)
            {
                ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                pSendContext->pIrpToComplete = NULL;
            }

            pSendContext->pMessage2Request->pMessage2Request = NULL;
            pSendContext->pMessage2Request = NULL;
        }
    }

    //
    // Terminate the first PendingPacketizedSend only if we have not
    // yet started sending it or this Cancel was meant for that request
    // (Try to protect data integrity as much as possible)
    //
    if (!IsListEmpty (&pSend->pSender->PendingPacketizedSends))
    {
        pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if ((!pSendContext->NumDataPacketsSent) ||
            (!pIrp || (pSendContext->pIrp == pIrp)))
        {
            RemoveEntryList (&pSendContext->Linkage);
            ASSERT (IsListEmpty (&pSend->pSender->PendingPacketizedSends));
            NumRequests++;

            //
            // If we have some data pending in the transport,
            // then we will have to let the SendCompletion handle that
            //
            ASSERT ((pSendContext->BytesLeftToPacketize) ||
                    (pSendContext->NumDataPacketsSent < pSendContext->DataPacketsPacketized) ||
                    (pSendContext->NumParityPacketsToSend));

            PgmTrace (LogPath, ("PgmCancelAllSends:  "  \
                "Partial Send, pIrp=<%p>, BytesLeftToPacketize=<%d/%d>, PacketsSent=<%d/%d>, Pending=<%d>\n",
                    pSendContext->pIrp, pSendContext->BytesLeftToPacketize,
                    pSendContext->BytesInSend, pSendContext->NumDataPacketsSent,
                    pSendContext->DataPacketsPacketized, pSendContext->NumSendsPending));

            pSendContext->BytesLeftToPacketize = 0;
            pSendContext->DataPacketsPacketized = pSendContext->NumDataPacketsSent;
            pSendContext->NumParityPacketsToSend = 0;

            pSend->pSender->NumODataRequestsPending--;
            pSend->pSender->NumPacketsRemaining -= pSendContext->NumPacketsRemaining;

            if (pSendContext->NumSendsPending)
            {
                InsertTailList (&pSend->pSender->CompletedSendsInWindow, &pSendContext->Linkage);
            }
            else
            {
                //
                // If we have a companion partial, then it must be in the completed list
                // awaiting SendCompletion
                //
                if (pSendContext->pMessage2Request)
                {
                    ASSERT (pSendContext->pMessage2Request->pIrp);
                    if (pSendContext->pIrpToComplete)
                    {
                        ASSERT (!pSendContext->pMessage2Request->BytesLeftToPacketize);
                        ASSERT (!pSendContext->pMessage2Request->pIrpToComplete);
                        pSendContext->pMessage2Request->pIrpToComplete = pSendContext->pIrpToComplete;
                        pSendContext->pIrpToComplete = NULL;
                    }

                    pSendContext->pMessage2Request->pMessage2Request = NULL;
                    pSendContext->pMessage2Request = NULL;
                }

                InsertTailList (pListEntry, &pSendContext->Linkage);
            }

            pSendContext->EndSequenceNumber = pSend->pSender->LastODataSentSequenceNumber;
            HighestLeadSeq = pSend->pSender->LastODataSentSequenceNumber + 1;
        }
    }

    NumExSequencesInOldWindow = (ULONG) (SEQ_TYPE) (pSend->pSender->NextODataSequenceNumber-HighestLeadSeq);
    BufferSpaceFreed = NumExSequencesInOldWindow * pSend->pSender->PacketBufferSize;
    if (NumExSequencesInOldWindow)
    {
        pSend->SessionFlags |= PGM_SESSION_SENDS_CANCELLED;

        PgmTrace (LogPath, ("PgmCancelAllSends:  "  \
            "[%d]: NumSeqs=<%d>, NextOData=<%d-->%d>, BuffFreeed=<%d>, LeadingOffset=<%d-->%d>\n",
                NumRequests, NumExSequencesInOldWindow,
                (ULONG) pSend->pSender->NextODataSequenceNumber, (ULONG) HighestLeadSeq,
                (ULONG) BufferSpaceFreed, (ULONG) pSend->pSender->LeadingWindowOffset,
                (ULONG) (pSend->pSender->LeadingWindowOffset - BufferSpaceFreed)));
    }

    pSend->pSender->NextODataSequenceNumber = HighestLeadSeq;

    pSend->pSender->BufferPacketsAvailable += NumExSequencesInOldWindow;
    pSend->pSender->BufferSizeAvailable += BufferSpaceFreed;
    ASSERT (pSend->pSender->BufferSizeAvailable <= pSend->pSender->MaxDataFileSize);
    if (pSend->pSender->LeadingWindowOffset >= BufferSpaceFreed)
    {
        pSend->pSender->LeadingWindowOffset -= BufferSpaceFreed;
    }
    else
    {
        pSend->pSender->LeadingWindowOffset = pSend->pSender->MaxDataFileSize - (BufferSpaceFreed - pSend->pSender->LeadingWindowOffset);
    }
}


//----------------------------------------------------------------------------

ULONG
AdvanceWindow(
    IN  tSEND_SESSION       *pSend
    )
/*++

Routine Description:

    This routine is called to check if we need to advance the
    trailing window, and does so as appropriate
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context

Return Value:

    TRUE if the send window buffer is empty, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    tCLIENT_SEND_REQUEST    *pSendContextAdjust;
    tCLIENT_SEND_REQUEST    *pSendContext1;
    tSEND_RDATA_CONTEXT     *pRDataContext;
    SEQ_TYPE                HighestTrailSeq, MaxSequencesToAdvance, NumSequences, NumExSequencesInOldWindow;
    ULONGLONG               NewTrailTime, PreferredTrailTime = 0;
    tSEND_CONTEXT           *pSender = pSend->pSender;

    //
    // See if we need to increment the Trailing edge of our transmit window
    //
    if (pSender->TimerTickCount > pSender->NextWindowAdvanceTime)
    {
        PgmTrace (LogPath, ("AdvanceWindow:  "  \
            "Advancing NextWindowAdvanceTime -- TimerTC = [%I64d] >= NextWinAdvT [%I64d]\n",
                pSender->TimerTickCount, pSender->NextWindowAdvanceTime));

        pSender->NextWindowAdvanceTime = pSender->TimerTickCount + pSender->WindowAdvanceDeltaTime;
    }

    PreferredTrailTime = (pSender->NextWindowAdvanceTime - pSender->WindowAdvanceDeltaTime) -
                         pSender->WindowSizeTime;
    if (PreferredTrailTime < pSender->TrailingEdgeTime)
    {
        //
        // Out window is already ahead of the Preferred trail time
        //
        PgmTrace (LogAllFuncs, ("AdvanceWindow:  "  \
            "Transmit Window=[%d, %d], TimerTC=[%I64d], PrefTrail=<%I64d>, TrailTime=<%I64d>\n",
                (ULONG) pSender->TrailingEdgeSequenceNumber, (ULONG) (pSender->NextODataSequenceNumber-1),
                pSender->TimerTickCount, PreferredTrailTime, pSender->TrailingEdgeTime));

        return (0);
    }

    //
    // Determine the maximum sequences we can advance by (initially all seqs in window)
    //
    HighestTrailSeq = pSender->NextODataSequenceNumber & ~((SEQ_TYPE) pSend->FECGroupSize-1);   // Init
    NumSequences = HighestTrailSeq - pSender->TrailingEdgeSequenceNumber;

    //
    // Now, limit that depending on pending RData
    //
    if (pRDataContext = AnyRequestPending (pSender->pRDataInfo)) // Start with pending RData requests
    {
        if (SEQ_LT (pRDataContext->RDataSequenceNumber, HighestTrailSeq))
        {
            HighestTrailSeq = pRDataContext->RDataSequenceNumber;
        }
    }
    MaxSequencesToAdvance = HighestTrailSeq - pSender->TrailingEdgeSequenceNumber;

    //
    // If we are required to advance the window on-demand, then we
    // will need to limit the Maximum sequences we can advance by
    //
    if ((pSender->pAddress->Flags & PGM_ADDRESS_USE_WINDOW_AS_DATA_CACHE) &&
        !(pSend->SessionFlags & PGM_SESSION_SENDER_DISCONNECTED))
    {
        if (NumSequences <= (pSender->MaxPacketsInBuffer >> 1))
        {
            MaxSequencesToAdvance = 0;
        }
        else if ((NumSequences - MaxSequencesToAdvance) < (pSender->MaxPacketsInBuffer >> 1))
        {
            MaxSequencesToAdvance = (ULONG) (NumSequences - (pSender->MaxPacketsInBuffer >> 1));
            HighestTrailSeq = pSender->TrailingEdgeSequenceNumber + MaxSequencesToAdvance;
        }
    }

    if (!MaxSequencesToAdvance)
    {
        PgmTrace (LogAllFuncs, ("AdvanceWindow:  "  \
            "Transmit Window=[%d, %d], TimerTC=[%I64d], MaxSeqs=<%d>, PrefTrail=<%I64d>, TrailTime=<%I64d>\n",
                (ULONG) pSender->TrailingEdgeSequenceNumber, (ULONG) (pSender->NextODataSequenceNumber-1),
                pSender->TimerTickCount, MaxSequencesToAdvance,
                PreferredTrailTime, pSender->TrailingEdgeTime));

        return (0);
    }

    PgmTrace (LogPath, ("AdvanceWindow:  "  \
        "PreferredTrail=[%I64d] > TrailingEdge=[%I64d], WinAdvMSecs=<%I64d>, WinSizeMSecs=<%I64d>\n",
            PreferredTrailTime, pSender->TrailingEdgeTime, pSender->WindowAdvanceDeltaTime,
            pSender->WindowSizeTime));

    NewTrailTime = PreferredTrailTime;      // Init to Preferred Trail time (in case no data)

    // Now, check the completed sends list
    NumExSequencesInOldWindow = NumSequences = 0;
    pSendContext1 = pSendContextAdjust = NULL;
    pEntry = pSender->CompletedSendsInWindow.Flink;
    while (pEntry != &pSender->CompletedSendsInWindow)
    {
        pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        ASSERT (NumExSequencesInOldWindow <= MaxSequencesToAdvance);
        ASSERT (SEQ_LEQ (pSendContext1->StartSequenceNumber, HighestTrailSeq));
        ASSERT (SEQ_GEQ (pSendContext1->EndSequenceNumber, pSender->TrailingEdgeSequenceNumber));

        NewTrailTime = pSendContext1->SendStartTime;
        if ((pSendContext1->NumSendsPending) ||         // Cannot advance if completions are pending
            (pSendContext1->SendStartTime >= PreferredTrailTime) ||     // need to keep for window
            (SEQ_GEQ (pSendContext1->StartSequenceNumber, HighestTrailSeq)))    // Only == valid
        {
            ASSERT (SEQ_LEQ (pSendContext1->StartSequenceNumber, HighestTrailSeq));

            //
            // Reset HighestTrailSeq
            //
            if (SEQ_GT (pSender->TrailingEdgeSequenceNumber, pSendContext1->StartSequenceNumber))
            {
                HighestTrailSeq = pSender->TrailingEdgeSequenceNumber;
                ASSERT (!NumExSequencesInOldWindow);
            }
            else
            {
                HighestTrailSeq = pSendContext1->StartSequenceNumber;
                NumExSequencesInOldWindow = HighestTrailSeq - pSender->TrailingEdgeSequenceNumber;
            }
            MaxSequencesToAdvance = NumExSequencesInOldWindow;

            break;
        }
        else if (SEQ_GEQ (pSendContext1->EndSequenceNumber, HighestTrailSeq))    // Need to keep this Send
        {
            if (SEQ_LEQ (pSender->TrailingEdgeSequenceNumber, pSendContext1->StartSequenceNumber))
            {
                NumExSequencesInOldWindow = pSendContext1->StartSequenceNumber -
                                            pSender->TrailingEdgeSequenceNumber;
            }

            pSendContextAdjust = pSendContext1;
            break;
        }

        // Remove the send that is definitely out of the new window
        pEntry = pEntry->Flink;
        RemoveEntryList (&pSendContext1->Linkage);
        ASSERT ((!pSendContext1->pMessage2Request) && (!pSendContext1->pIrp));
        ExFreeToNPagedLookasideList (&pSender->SendContextLookaside,pSendContext1);
    }

    ASSERT (NumExSequencesInOldWindow <= MaxSequencesToAdvance);

    //
    // pSendContext1 will be NULL if there are no completed sends,
    // in which case we may have 1 huge current send that could be hogging
    // our buffer, so check that then!
    //
    if ((!pSendContext1) &&
        (!IsListEmpty (&pSender->PendingPacketizedSends)))
    {
        ASSERT (!pSendContextAdjust);
        pSendContextAdjust = CONTAINING_RECORD (pSender->PendingPacketizedSends.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if ((pSendContextAdjust->NumSendsPending) ||          // Ensure no sends pending
            (pSendContextAdjust->NumParityPacketsToSend) ||   // No parity packets left to send
            (!pSendContextAdjust->NumDataPacketsSent) ||      // No packets sent yet
            (pSendContextAdjust->DataPacketsPacketized != pSendContextAdjust->NumDataPacketsSent) ||
            (pSendContextAdjust->SendStartTime > PreferredTrailTime))
        {
            pSendContextAdjust = NULL;
        }
    }

    //
    // pSendContextAdjust will be non-NULL if we need to adjust
    // the Trailing edge within this Send request
    //
    if (pSendContextAdjust)
    {
        //
        // Do some sanity checks!
        //
        ASSERT (PreferredTrailTime >= pSendContextAdjust->SendStartTime);
        ASSERT (SEQ_GEQ (HighestTrailSeq, pSender->TrailingEdgeSequenceNumber));
        ASSERT (SEQ_GEQ (HighestTrailSeq, pSendContextAdjust->StartSequenceNumber));
        ASSERT (SEQ_GEQ (pSendContextAdjust->EndSequenceNumber,pSender->TrailingEdgeSequenceNumber));

        //
        // See if this send is partially in or out of the window now!
        // Calculate the offset of sequences in this Send request for the
        // preferred trail time
        //
        NumSequences = (ULONG) (SEQ_TYPE) (((PreferredTrailTime - pSendContextAdjust->SendStartTime) *
                                             BASIC_TIMER_GRANULARITY_IN_MSECS *
                                             pSender->pAddress->RateKbitsPerSec) /
                                            (pSender->pAddress->OutIfMTU << LOG2_BITS_PER_BYTE));

        //
        // Limit the NumSequences by the number of packets in this Send
        //
        if (SEQ_GT ((pSendContextAdjust->StartSequenceNumber + NumSequences),
                    pSendContextAdjust->EndSequenceNumber))
        {
            NumSequences = pSendContextAdjust->EndSequenceNumber -
                           pSendContextAdjust->StartSequenceNumber + 1;
        }

        //
        // Limit the NumSequences by the HighestTrailSeq (pending RData requests)
        //
        if (SEQ_GT ((pSendContextAdjust->StartSequenceNumber + NumSequences),
                    HighestTrailSeq))
        {
            NumSequences = HighestTrailSeq - pSendContextAdjust->StartSequenceNumber;
        }

        //
        // We may not need to advance here if we are at (or behind) the trailing edge
        //
        if (SEQ_LEQ ((pSendContextAdjust->StartSequenceNumber + NumSequences),
                      pSender->TrailingEdgeSequenceNumber))
        {
            NumSequences = 0;
            HighestTrailSeq = pSender->TrailingEdgeSequenceNumber;
        }
        else if (SEQ_LT (pSendContextAdjust->StartSequenceNumber, pSender->TrailingEdgeSequenceNumber))
        {
            ASSERT (SEQ_LEQ (pSender->TrailingEdgeSequenceNumber, pSendContextAdjust->EndSequenceNumber));
            NumSequences = pSendContextAdjust->StartSequenceNumber + NumSequences -
                           pSender->TrailingEdgeSequenceNumber;
            HighestTrailSeq = pSender->TrailingEdgeSequenceNumber + NumSequences;
        }
        else
        {
            HighestTrailSeq = pSendContextAdjust->StartSequenceNumber + NumSequences;
        }

        NumExSequencesInOldWindow += NumSequences;
        ASSERT (NumExSequencesInOldWindow <= MaxSequencesToAdvance);

        //
        // Now, set the NewTrailTime
        //
        NewTrailTime = (NumSequences * pSender->pAddress->OutIfMTU * BITS_PER_BYTE) /
                       (pSender->pAddress->RateKbitsPerSec * BASIC_TIMER_GRANULARITY_IN_MSECS);
        NewTrailTime += pSendContextAdjust->SendStartTime;

        //
        // See, if we can discard this whole send request
        //
        if ((!pSendContextAdjust->BytesLeftToPacketize) &&
            (SEQ_GT ((pSendContextAdjust->StartSequenceNumber + NumSequences),
                    pSendContextAdjust->EndSequenceNumber)))
        {
            //
            // We can drop this whole send since it is outside of our window
            //
            ASSERT (HighestTrailSeq == (pSendContextAdjust->EndSequenceNumber + 1));

            // Remove this send and free it!
            ASSERT ((!pSendContextAdjust->pMessage2Request) && (!pSendContextAdjust->pIrp));
            RemoveEntryList (&pSendContextAdjust->Linkage);
            ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContextAdjust);
        }
    }

    if (!NumExSequencesInOldWindow)
    {
        PgmTrace (LogAllFuncs, ("AdvanceWindow:  "  \
            "Transmit Window=[%d, %d], TimerTC=[%I64d], MaxSeqs=<%d>, PrefTrail=<%I64d>, TrailTime=<%I64d>\n",
                (ULONG) pSender->TrailingEdgeSequenceNumber, (ULONG) (pSender->NextODataSequenceNumber-1),
                pSender->TimerTickCount, MaxSequencesToAdvance,
                PreferredTrailTime, pSender->TrailingEdgeTime));

        return (0);
    }

    ASSERT (SEQ_GT (HighestTrailSeq, pSender->TrailingEdgeSequenceNumber));
    ASSERT (HighestTrailSeq == (pSender->TrailingEdgeSequenceNumber + NumExSequencesInOldWindow));

    //
    // Now, limit the # sequences to advance with the window size
    //
    if (NumExSequencesInOldWindow > MaxSequencesToAdvance)
    {
        ASSERT (0);
        NumExSequencesInOldWindow = MaxSequencesToAdvance;
    }
    HighestTrailSeq = pSender->TrailingEdgeSequenceNumber + NumExSequencesInOldWindow;

    PgmTrace (LogPath, ("AdvanceWindow:  "  \
        "BuffAva=<%d>, NumSeqsAdvanced=<%d>, Max=<%d>, TrailSeqNum=<%d>=><%d>, TrailTime=<%I64d>=><%I64d>\n",
            (ULONG) pSender->BufferSizeAvailable, (ULONG) NumExSequencesInOldWindow,
            (ULONG) MaxSequencesToAdvance, (ULONG) pSender->TrailingEdgeSequenceNumber,
            (ULONG) HighestTrailSeq, pSender->TrailingEdgeTime, NewTrailTime));

    //
    // Now, adjust the buffer settings
    //
    pSender->BufferPacketsAvailable += NumExSequencesInOldWindow;
    pSender->BufferSizeAvailable += (NumExSequencesInOldWindow * pSender->PacketBufferSize);
    ASSERT (pSender->BufferPacketsAvailable <= pSender->MaxPacketsInBuffer);
    ASSERT (pSender->BufferSizeAvailable <= pSender->MaxDataFileSize);
    pSender->TrailingWindowOffset += (NumExSequencesInOldWindow * pSender->PacketBufferSize);
    if (pSender->TrailingWindowOffset >= pSender->MaxDataFileSize)
    {
        // Wrap around case!
        pSender->TrailingWindowOffset -= pSender->MaxDataFileSize;
    }
    ASSERT (pSender->TrailingWindowOffset < pSender->MaxDataFileSize);
    pSender->TrailingEdgeSequenceNumber = HighestTrailSeq;
    pSender->TrailingGroupSequenceNumber = (HighestTrailSeq+pSend->FECGroupSize-1) &
                                              ~((SEQ_TYPE) pSend->FECGroupSize-1);
    pSender->TrailingEdgeTime = NewTrailTime;
    UpdateRDataTrailingEdge (pSender->pRDataInfo, HighestTrailSeq);

    PgmTrace (LogAllFuncs, ("AdvanceWindow:  "  \
        "Transmit Window Range=[%d, %d], TimerTC=[%I64d]\n",
            (ULONG) pSender->TrailingEdgeSequenceNumber,
            (ULONG) (pSender->NextODataSequenceNumber-1),
            pSender->TimerTickCount));

    return (NumExSequencesInOldWindow);
}


//----------------------------------------------------------------------------

BOOLEAN
CheckForTermination(
    IN  tSEND_SESSION       *pSend,
    IN  PGMLockHandle       *pOldIrq
    )
/*++

Routine Description:

    This routine is called to check and terminate the session
    if necessary.
    The pSend lock is held before calling this routine

Arguments:

    IN  pSend       -- Pgm session (sender) context

Return Value:

    TRUE if the send window buffer is empty, FALSE otherwise

--*/
{
    LIST_ENTRY              *pEntry;
    LIST_ENTRY              ListEntry;
    tCLIENT_SEND_REQUEST    *pSendContext;
    tSEND_RDATA_CONTEXT     *pRDataContext;
    PIRP                    pIrp;
    ULONG                   NumSequences;

    if (!(PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_DOWN)) &&
        !(PGM_VERIFY_HANDLE (pSend->pSender->pAddress, PGM_VERIFY_ADDRESS_DOWN)) &&
        !(pSend->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED))
    {
        PgmTrace (LogAllFuncs, ("CheckForTermination:  "  \
            "Session for pSend=<%p> does not need to be terminated\n", pSend));

        return (FALSE);
    }

    //
    // See if we have processed the disconnect for the first time yet
    //
    if (!(pSend->SessionFlags & PGM_SESSION_SENDER_DISCONNECTED))
    {
        PgmTrace (LogStatus, ("CheckForTermination:  "  \
            "Session is going down!, Packets remaining=<%d>\n", pSend->pSender->NumPacketsRemaining));

        pSend->SessionFlags |= PGM_SESSION_SENDER_DISCONNECTED;

        //
        // We have to set the FIN on the Data as well as SPM packets.
        // Thus, there are 2 situations -- either we have finished sending
        // all the Data packets, or we are still in the midst of sending
        //
        // If there are no more sends pending, we will have to
        // modify the last packet ourselves to set the FIN option
        //
        if (!IsListEmpty (&pSend->pSender->PendingSends))
        {
            PgmTrace (LogStatus, ("CheckForTermination:  "  \
                "Send pending on list -- setting bLastSend for FIN on last Send\n"));

            pSendContext = CONTAINING_RECORD (pSend->pSender->PendingSends.Blink, tCLIENT_SEND_REQUEST,Linkage);

            //
            // We will just set a flag here, so that when the last packet
            // is packetized, the FIN flags are set
            //
            pSendContext->bLastSend = TRUE;
        }
        else if (pSend->pSender->NumODataRequestsPending)
        {
            PgmTrace (LogStatus, ("CheckForTermination:  "  \
                "Last Send in progress -- setting bLastSend for FIN on this Send\n"));

            //
            // If have already packetized the last send, but have not yet
            // sent it out, then PgmSendNextOData will put the FIN in the data packet
            // otherwise, if we have not yet packetized the packet, then we will set the
            // FIN option while preparing the last packet
            //
            pSendContext = CONTAINING_RECORD (pSend->pSender->PendingPacketizedSends.Blink, tCLIENT_SEND_REQUEST,Linkage);
            pSendContext->bLastSend = TRUE;
        }
        else
        {
            PgmTrace (LogStatus, ("CheckForTermination:  "  \
                "No Sends in progress -- setting FIN for next SPM\n"));

            //
            // We have finished packetizing and sending all the packets,
            // so set the FIN flag on the SPMs and also modify the last
            // RData packet (if still in the window) for the FIN -- this
            // will be done when the next RData packet is sent out
            //
            if ((pSend->SessionFlags & PGM_SESSION_SENDS_CANCELLED) ||
                !(pSend->pIrpDisconnect))
            {
                pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_FIN;
                pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_RST;
            }
            else
            {
                pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_RST;
                pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
            }

            //
            // We also need to send an SPM immediately
            //
            pSend->pSender->CurrentSPMTimeout = pSend->pSender->AmbientSPMTimeout;
            pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
        }

        return (FALSE);
    }

    //
    // If we have a (graceful) disconnect Irp to complete, we should complete
    // it if we have timed out, or are ready to do so now
    //
    if ((pIrp = pSend->pIrpDisconnect) &&                               // Disconnect Irp pending
        (((pSend->pSender->DisconnectTimeInTicks) && (pSend->pSender->TimerTickCount >
                                                      pSend->pSender->DisconnectTimeInTicks)) ||
         ((IsListEmpty (&pSend->pSender->PendingSends)) &&              // No Unpacketized Sends pending
          (IsListEmpty (&pSend->pSender->PendingPacketizedSends)) &&    // No Packetized sends pending
          !(FindFirstEntry (pSend, NULL, TRUE)) &&                      // No Pending RData requests
          (IsListEmpty (&pSend->pSender->CompletedSendsInWindow)) &&    // Window is Empty
          (pSend->pSender->SpmOptions & (PGM_OPTION_FLAG_FIN |          // FIN | RST | RST_N set on SPMs
                                         PGM_OPTION_FLAG_RST |
                                         PGM_OPTION_FLAG_RST_N))   &&
          !(pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)))) // No  Ambient Spm pending
    {
        pSend->pIrpDisconnect = NULL;
        PgmUnlock (pSend, *pOldIrq);

        PgmTrace (LogStatus, ("CheckForTermination:  "  \
            "Completing Graceful disconnect pIrp=<%p>\n", pIrp));

        PgmIoComplete (pIrp, STATUS_SUCCESS, 0);

        PgmLock (pSend, *pOldIrq);
        return (FALSE);
    }

    //
    // Do the final cleanup only if the handles have been closed
    // or the disconnect has timed out
    //
    if (!(PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_DOWN)) &&
        !(PGM_VERIFY_HANDLE (pSend->pSender->pAddress, PGM_VERIFY_ADDRESS_DOWN)) &&
        ((!pSend->pSender->DisconnectTimeInTicks) || (pSend->pSender->TimerTickCount <
                                                      pSend->pSender->DisconnectTimeInTicks)))
    {
        PgmTrace (LogAllFuncs, ("CheckForTermination:  "  \
            "Handles have not yet been closed for pSend=<%p>, TC=<%I64d>, DisconnectTime=<%I64d>\n",
                pSend, pSend->pSender->TimerTickCount, pSend->pSender->DisconnectTimeInTicks));

        return (FALSE);
    }

    // *****************************************************************
    //      We will reach here only if we need to cleanup ASAP
    // *****************************************************************

    //
    // First, cleanup all handled RData requests (which have completed)
    //
    RemoveAllEntries (pSend, TRUE);

    //
    // Now, Cancel and Complete all the send requests which are pending
    //
    InitializeListHead (&ListEntry);
    PgmCancelAllSends (pSend, &ListEntry, NULL);
    while (!IsListEmpty (&ListEntry))
    {
        pEntry = RemoveHeadList (&ListEntry);
        pSendContext = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        ASSERT (!pSendContext->pMessage2Request);

        PgmUnlock (pSend, *pOldIrq);
        if (pSendContext->pIrpToComplete)
        {
            ASSERT (pSendContext->pIrpToComplete == pSendContext->pIrp);
            PgmIoComplete (pSendContext->pIrpToComplete, STATUS_CANCELLED, 0);
        }
        else
        {
            ASSERT (pSendContext->pIrp);
        }

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        PgmLock (pSend, *pOldIrq);

        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext);
    }

    //
    // Verify that at least 1 SPM with the FIN or RST or RST_N flag
    // has been sent
    //
    if (!(pSend->pSender->SpmOptions & (PGM_OPTION_FLAG_FIN |
                                        PGM_OPTION_FLAG_RST |
                                        PGM_OPTION_FLAG_RST_N)))
    {
        if ((pSend->SessionFlags & PGM_SESSION_SENDS_CANCELLED) ||
           !(pSend->pIrpDisconnect))
        {
            pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_FIN;
            pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_RST;
        }
        else
        {
            pSend->pSender->SpmOptions &= ~PGM_OPTION_FLAG_RST;
            pSend->pSender->SpmOptions |= PGM_OPTION_FLAG_FIN;
        }

        pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;

        PgmTrace (LogAllFuncs, ("CheckForTermination:  "  \
            "SPM with FIN|RST|RST_N has not yet been sent for pSend=<%p>\n", pSend));

        return (FALSE);
    }

    //
    // Verify that there are no SPMs pending
    //
    if (pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)
    {
        PgmTrace (LogAllFuncs, ("CheckForTermination:  "  \
            "Cannot cleanup pSend=<%p> since we have Ambient SPM pending!\n", pSend));

        return (FALSE);
    }

    //
    // Verify that we do not have any completions pending also since
    // Ip would need to reference the data buffer otherwise
    //
    while (!IsListEmpty (&pSend->pSender->CompletedSendsInWindow))
    {
        pSendContext = CONTAINING_RECORD (pSend->pSender->CompletedSendsInWindow.Flink, tCLIENT_SEND_REQUEST, Linkage);
        if (pSendContext->NumSendsPending)
        {
            PgmTrace (LogPath, ("CheckForTermination:  "  \
                "Session has terminated, but cannot continue cleanup since Sends are still pending!\n"));

            break;
        }

        //
        // Now, set the buffer settings
        //
        ASSERT (SEQ_GEQ (pSend->pSender->TrailingEdgeSequenceNumber,
                         (pSendContext->StartSequenceNumber+1-pSend->FECGroupSize)));
        ASSERT (SEQ_LEQ (pSend->pSender->TrailingEdgeSequenceNumber, pSendContext->EndSequenceNumber));

        NumSequences = (ULONG) (SEQ_TYPE) (pSendContext->EndSequenceNumber-pSend->pSender->TrailingEdgeSequenceNumber) +1;
        pSend->pSender->BufferPacketsAvailable += NumSequences;
        pSend->pSender->BufferSizeAvailable += (NumSequences * pSend->pSender->PacketBufferSize);
        ASSERT (pSend->pSender->BufferPacketsAvailable <= pSend->pSender->MaxPacketsInBuffer);
        ASSERT (pSend->pSender->BufferSizeAvailable <= pSend->pSender->MaxDataFileSize);
        pSend->pSender->TrailingWindowOffset += (NumSequences * pSend->pSender->PacketBufferSize);
        if (pSend->pSender->TrailingWindowOffset >= pSend->pSender->MaxDataFileSize)
        {
            // Wrap around case!
            pSend->pSender->TrailingWindowOffset -= pSend->pSender->MaxDataFileSize;
        }
        pSend->pSender->TrailingEdgeSequenceNumber += (SEQ_TYPE) NumSequences;

        ASSERT (pSend->pSender->TrailingWindowOffset < pSend->pSender->MaxDataFileSize);
        ASSERT (SEQ_GT (pSend->pSender->TrailingEdgeSequenceNumber, pSendContext->EndSequenceNumber));
        ASSERT ((!pSendContext->pMessage2Request) && (!pSendContext->pIrp));

        RemoveEntryList (&pSendContext->Linkage);
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext);
    }

    //
    // If any sends are pending, return False
    //
    if ((pSend->pIrpDisconnect) ||
        !(IsListEmpty (&pSend->pSender->CompletedSendsInWindow)) ||
        !(IsListEmpty (&pSend->pSender->PendingSends)) ||
        !(IsListEmpty (&pSend->pSender->PendingPacketizedSends)) ||
        (AnyRequestPending (pSend->pSender->pRDataInfo)))
    {
        PgmTrace (LogPath, ("CheckForTermination:  "  \
            "Cannot cleanup completely since transmit Window=[%d--%d] still has pending Sends!\n",
                (ULONG) pSend->pSender->TrailingEdgeSequenceNumber,
                (ULONG) (pSend->pSender->NextODataSequenceNumber-1)));

        return (FALSE);
    }

    PgmTrace (LogAllFuncs, ("CheckForTermination:  "  \
        "Transmit Window has no pending Sends!  TimerTC=[%I64d]\n", pSend->pSender->TimerTickCount));

    ASSERT (!pSend->pIrpDisconnect);
    return (TRUE);
}


//----------------------------------------------------------------------------

BOOLEAN
SendNextPacket(
    IN  tSEND_SESSION       *pSend
    )
/*++

Routine Description:

    This routine is queued by the timer to send Data/Spm packets
    based on available throughput

Arguments:

    IN  pSend       -- Pgm session (sender) context
    IN  Unused1
    IN  Unused2

Return Value:

    NONE

--*/
{
    ULONG                   BytesSent;
    ULONG                   NumSequences;
    PGMLockHandle           OldIrq;
    BOOLEAN                 fTerminateSession = FALSE;
    LIST_ENTRY              *pEntry;
    tSEND_RDATA_CONTEXT     *pRDataContext, *pRDataToSend;
    tSEND_RDATA_CONTEXT     *pRDataLast = NULL;
    tSEND_CONTEXT           *pSender = pSend->pSender;
    BOOLEAN                 fHighSpeedOptimize = (BOOLEAN) (pSender->pAddress->Flags &
                                                            PGM_ADDRESS_HIGH_SPEED_OPTIMIZED);

    PgmLock (pSend, OldIrq);
    //
    // pSender->CurrentBytesSendable applies to OData, RData and SPMs only
    //
    while (pSender->CurrentBytesSendable >= pSender->pAddress->OutIfMTU)
    {
        BytesSent = 0;

        //
        // See if we need to send any Ambient SPMs
        //
        if ((pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM) &&
            ((pSender->PacketsSentSinceLastSpm > MAX_DATA_PACKETS_BEFORE_SPM) ||
             (pSender->CurrentSPMTimeout >= pSender->AmbientSPMTimeout)))
        {
            PgmTrace (LogPath, ("SendNextPacket:  "  \
                "Send Ambient SPM, TC=[%I64d], BS=<%d>\n",
                    pSender->TimerTickCount, pSender->CurrentBytesSendable));
            //
            // Some data packet was sent recently, so we are in Ambient SPM mode
            //
            PgmSendSpm (pSend, &OldIrq, &BytesSent);

            pSender->CurrentSPMTimeout = 0;    // Reset the SPM timeout
            pSender->HeartbeatSPMTimeout = pSender->InitialHeartbeatSPMTimeout;
            pSend->SessionFlags &= ~PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
            pSender->PacketsSentSinceLastSpm = 0;
        }
        //
        // Otherwise see if we need to send any Heartbeat SPMs
        //
        else if ((!(pSend->SessionFlags & PGM_SESSION_FLAG_SEND_AMBIENT_SPM)) &&
                 (pSender->CurrentSPMTimeout >= pSender->HeartbeatSPMTimeout))
        {
            //
            // No data packet was sent recently, so we need to send a Heartbeat SPM
            //
            PgmTrace (LogPath, ("SendNextPacket:  "  \
                "Send Heartbeat SPM, TC=[%I64d], BS=<%d>\n",
                    pSender->TimerTickCount, pSender->CurrentBytesSendable));

            //
            // (Send Heartbeat SPM Packet)
            //
            PgmSendSpm (pSend, &OldIrq, &BytesSent);

            pSender->CurrentSPMTimeout = 0;    // Reset the SPM timeout
            pSender->HeartbeatSPMTimeout *= 2;
            if (pSender->HeartbeatSPMTimeout > pSender->MaxHeartbeatSPMTimeout)
            {
                pSender->HeartbeatSPMTimeout = pSender->MaxHeartbeatSPMTimeout;
            }
            pSender->PacketsSentSinceLastSpm = 0;
        }
        //
        // Next, see if we need to send any RData
        //
        else if ((pSender->NumRDataRequestsPending) || (pSender->NumODataRequestsPending))
        {
            //
            // See if we need to send an RData packet now
            //
            if (pRDataToSend = FindFirstEntry (pSend, &pRDataLast, fHighSpeedOptimize))
            {
                PgmTrace (LogPath, ("SendNextPacket:  "  \
                    "Send RData[%d] -- TC=[%I64d], BS=<%d>, MTU=<%d>\n",
                        pRDataToSend->RDataSequenceNumber, pSender->TimerTickCount,
                        pSender->CurrentBytesSendable, pSender->pAddress->OutIfMTU));

                PgmSendRData (pSend, pRDataToSend, &OldIrq, &BytesSent);
            }
            else if (pSender->NumODataRequestsPending)
            {
                PgmTrace (LogPath, ("SendNextPacket:  "  \
                    "Send OData -- TC=[%I64d], BS=<%d>, MTU=<%d>\n",
                        pSender->TimerTickCount, pSender->CurrentBytesSendable,
                        pSender->pAddress->OutIfMTU));

                //
                // Send OData
                //
                PgmSendNextOData (pSend, &OldIrq, &BytesSent);
            }

            PgmTrace (LogPath, ("SendNextPacket:  "  \
                "Sent <%d> Data bytes\n", BytesSent));

            if (BytesSent == 0)
            {
                //
                // We may not have enough buffer space to packetize and send
                // more data, or we have no data to send at this time, so just
                // break out and see if we can advance the trailing window!
                //
                if (pSender->CurrentBytesSendable >
                    (NUM_LEAKY_BUCKETS * pSender->IncrementBytesOnSendTimeout))
                {
                    pSender->CurrentBytesSendable = NUM_LEAKY_BUCKETS *
                                                    pSender->IncrementBytesOnSendTimeout;
                }

                break;
            }

            pSend->SessionFlags |= PGM_SESSION_FLAG_SEND_AMBIENT_SPM;
            pSender->PacketsSentSinceLastSpm++;
        }

        //
        //  We do not have any more packets to send, so reset
        //  BytesSendable so that we don't exceed the rate on
        //  the next send
        //
        else
        {
            if (pSender->CurrentBytesSendable >
                (NUM_LEAKY_BUCKETS * pSender->IncrementBytesOnSendTimeout))
            {
                pSender->CurrentBytesSendable = NUM_LEAKY_BUCKETS *
                                                pSender->IncrementBytesOnSendTimeout;
            }

            break;
        }

        pSend->TotalBytes += BytesSent;
        pSender->CurrentBytesSendable -= BytesSent;
    }   // while (CurrentBytesSendable >= pSender->pAddress->OutIfMTU)

    //
    // See if we need to scavenge completed RData requests
    //
    if (!fHighSpeedOptimize)
    {
        RemoveAllEntries (pSend, FALSE);
    }

    //
    // See if we need to increment the Trailing Window -- returns number of Sequences advanced
    //
    NumSequences = AdvanceWindow (pSend);

    //
    // Now check if we need to terminate this session
    //
    fTerminateSession = CheckForTermination (pSend, &OldIrq);

    PgmTrace (LogAllFuncs, ("SendNextPacket:  "  \
        "Sent <%I64d> total bytes, fTerminateSession=<%x>\n", pSend->TotalBytes, fTerminateSession));

    //
    // Clear the WorkerRunning flag so that the next Worker
    // routine can be queued
    //
    pSend->SessionFlags &= ~PGM_SESSION_FLAG_WORKER_RUNNING;
    PgmUnlock (pSend, OldIrq);

    return (fTerminateSession);
}


//----------------------------------------------------------------------------

VOID
SendSessionTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    )
/*++

Routine Description:

    This routine is the timout that gets called every BASIC_TIMER_GRANULARITY_IN_MSECS
    to schedule the next Send request

Arguments:

    IN  Dpc
    IN  DeferredContext -- Our context for this timer
    IN  SystemArg1
    IN  SystemArg2

Return Value:

    NONE

--*/
{
    NTSTATUS            status;
    PGMLockHandle       OldIrq;
    LARGE_INTEGER       Now;
    LARGE_INTEGER       DeltaTime, GranularTimeElapsed, TimeoutGranularity;
    ULONG               NumTimeouts;
    SEQ_TYPE            NumSequencesInWindow;
    ULONGLONG           LastRDataPercentage;
    tSEND_SESSION       *pSend = (tSEND_SESSION *) DeferredContext;
    tSEND_CONTEXT       *pSender = pSend->pSender;
    tADDRESS_CONTEXT    *pAddress = pSender->pAddress;

    Now.QuadPart = KeQueryInterruptTime ();

    PgmLock (pSend, OldIrq);

    //
    // First check if we have been told to stop the timer
    //
    if (pSend->SessionFlags & PGM_SESSION_FLAG_STOP_TIMER)
    {
        PgmTrace (LogStatus, ("SendSessionTimeout:  "  \
            "Session has terminated -- will deref and not restart timer!\n"));

        //
        // Deref for the timer reference
        //
        pSender->pAddress = NULL;
        PgmUnlock (pSend, OldIrq);
        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_TIMER_RUNNING);
        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_SEND_IN_PROGRESS);
        return;
    }

    DeltaTime.QuadPart = Now.QuadPart - pSender->LastTimeout.QuadPart;
    TimeoutGranularity.QuadPart = pSender->TimeoutGranularity.QuadPart;
    for (GranularTimeElapsed.QuadPart = 0, NumTimeouts = 0;
         DeltaTime.QuadPart > TimeoutGranularity.QuadPart;
         NumTimeouts++)
    {
        GranularTimeElapsed.QuadPart += TimeoutGranularity.QuadPart;
        DeltaTime.QuadPart -= TimeoutGranularity.QuadPart;
    }

    if (NumTimeouts)
    {
        pSend->RateCalcTimeout += NumTimeouts;
        if (pSend->RateCalcTimeout >=
            (INTERNAL_RATE_CALCULATION_FREQUENCY/BASIC_TIMER_GRANULARITY_IN_MSECS))
        {
            pSend->RateKBitsPerSecOverall = (pSend->TotalBytes << LOG2_BITS_PER_BYTE) /
                                            (pSender->TimerTickCount * BASIC_TIMER_GRANULARITY_IN_MSECS);

            pSend->RateKBitsPerSecLast = (pSend->TotalBytes - pSend->TotalBytesAtLastInterval) >>
                                         (LOG2_INTERNAL_RATE_CALCULATION_FREQUENCY - LOG2_BITS_PER_BYTE);

            pSend->DataBytesAtLastInterval = pSend->DataBytes;
            pSend->TotalBytesAtLastInterval = pSend->TotalBytes;
            pSend->RateCalcTimeout = 0;

            LastRDataPercentage = 0;
            if (pSender->RDataPacketsInLastInterval)
            {
                LastRDataPercentage = (100*pSender->RDataPacketsInLastInterval) /
                                      (pSender->RDataPacketsInLastInterval +
                                       pSender->ODataPacketsInLastInterval);

                PgmTrace (LogPath, ("SendSessionTimeout:  "  \
                    "Sent %d RData + %d OData, %% = %d -- Overall RData %% = %d\n",
                        (ULONG) pSender->RDataPacketsInLastInterval,
                        (ULONG) pSender->ODataPacketsInLastInterval, (ULONG) LastRDataPercentage,
                        (ULONG) ((100*pSender->TotalRDataPacketsSent)/
                            (pSender->TotalRDataPacketsSent+pSender->TotalODataPacketsSent))));
            }
            else
            {
                PgmTrace (LogPath, ("SendSessionTimeout:  "  \
                    "No RData, %d OData packets in last interval\n",
                        (ULONG) pSender->ODataPacketsInLastInterval));
            }

            if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
            {
                if (LastRDataPercentage > MIN_PREFERRED_REPAIR_PERCENTAGE)
                {
                    if (pSender->IncrementBytesOnSendTimeout > pSender->DeltaIncrementBytes)
                    {
                        PgmTrace (LogStatus, ("SendSessionTimeout:  "  \
                            "\tIncBytes = <%d> - <%d>\n",
                                (ULONG) pSender->IncrementBytesOnSendTimeout, (ULONG) pSender->DeltaIncrementBytes));
                        pSender->IncrementBytesOnSendTimeout -= pSender->DeltaIncrementBytes;
                    }
                }
                else if (pSender->IncrementBytesOnSendTimeout < pSender->OriginalIncrementBytes)
                {
                    PgmTrace (LogStatus, ("SendSessionTimeout:  "  \
                        "\tIncBytes = <%d> + <%d>\n",
                            (ULONG) pSender->IncrementBytesOnSendTimeout, (ULONG) pSender->DeltaIncrementBytes));
                    pSender->IncrementBytesOnSendTimeout += pSender->DeltaIncrementBytes;
                    ASSERT (pSender->IncrementBytesOnSendTimeout <=
                            pSender->OriginalIncrementBytes);
                }
            }

            pSender->RDataPacketsInLastInterval = 0;
            pSender->ODataPacketsInLastInterval = 0;
        }

        pSender->LastTimeout.QuadPart += GranularTimeElapsed.QuadPart;

        //
        // Increment the absolute timer, and check for overflow
        //
        pSender->TimerTickCount += NumTimeouts;

        //
        // If the SPMTimeout value is less than the HeartbeatTimeout, increment it
        //
        if (pSender->CurrentSPMTimeout <= pSender->HeartbeatSPMTimeout)
        {
            pSender->CurrentSPMTimeout += NumTimeouts;
        }

        //
        // See if we can send anything
        //
        ASSERT (pSender->CurrentTimeoutCount);
        ASSERT (pSender->SendTimeoutCount);
        if (pSender->CurrentTimeoutCount > NumTimeouts)
        {
            pSender->CurrentTimeoutCount -= NumTimeouts;
        }
        else
        {
            //
            // We got here because NumTimeouts >= pSender->CurrentTimeoutCount
            //
            pSender->CurrentBytesSendable += (ULONG) pSender->IncrementBytesOnSendTimeout;
            if (NumTimeouts != pSender->CurrentTimeoutCount)
            {
                if (1 == pSender->SendTimeoutCount)
                {
                    pSender->CurrentBytesSendable += (ULONG) ((NumTimeouts - pSender->CurrentTimeoutCount)
                                                                        * pSender->IncrementBytesOnSendTimeout);
                }
                else
                {
                    //
                    // This path will get taken on a slow receiver when the timer
                    // fires at a lower granularity than that requested
                    //
                    pSender->CurrentBytesSendable += (ULONG) (((NumTimeouts - pSender->CurrentTimeoutCount)
                                                                      * pSender->IncrementBytesOnSendTimeout) /
                                                                     pSender->SendTimeoutCount);
                }
            }
            pSender->CurrentTimeoutCount = pSender->SendTimeoutCount;

            //
            // Send a synchronization event to the sender thread to
            // send the next available data
            //
            KeSetEvent (&pSender->SendEvent, 0, FALSE);
        }
    }

    PgmUnlock (pSend, OldIrq);

    //
    // Now, restart the timer
    //
    PgmInitTimer (&pSend->SessionTimer);
    PgmStartTimer (&pSend->SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, SendSessionTimeout, pSend);

    PgmTrace (LogAllFuncs, ("SendSessionTimeout:  "  \
        "TickCount=<%I64d>, CurrentTimeoutCount=<%I64d>, CurrentSPMTimeout=<%I64d>, Worker %srunning\n",
            pSender->TimerTickCount, pSender->CurrentTimeoutCount,
            pSender->CurrentSPMTimeout,
            ((pSend->SessionFlags & PGM_SESSION_FLAG_WORKER_RUNNING) ? "" : "NOT ")));
}


//----------------------------------------------------------------------------

VOID
SenderWorkerThread(
    IN  tSEND_SESSION       *pSend
    )
{
    BOOLEAN         fTerminateSends;
    PGMLockHandle   OldIrq;
    NTSTATUS        status;

    do
    {
        status = KeWaitForSingleObject (&pSend->pSender->SendEvent,  // Object to wait on.
                                        Executive,                   // Reason for waiting
                                        KernelMode,                  // Processor mode
                                        FALSE,                       // Alertable
                                        NULL);                       // Timeout
        ASSERT (NT_SUCCESS (status));

        fTerminateSends = SendNextPacket (pSend);
    }
    while (!fTerminateSends);

    PgmLock (pSend, OldIrq);
    pSend->SessionFlags |= PGM_SESSION_FLAG_STOP_TIMER; // To ensure timer does last deref and stops
    PgmUnlock (pSend, OldIrq);

//    PsTerminateSystemThread (STATUS_SUCCESS);
    return;
}


//----------------------------------------------------------------------------

VOID
PgmCancelSendIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Send Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tSEND_SESSION           *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    PGMLockHandle           OldIrq;
    PLIST_ENTRY             pEntry;
    LIST_ENTRY              ListEntry;
    tCLIENT_SEND_REQUEST    *pSendContext1;
    tCLIENT_SEND_REQUEST    *pSendContext2 = NULL;
    ULONG                   NumRequests;

    if (!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmTrace (LogError, ("PgmCancelSendIrp: ERROR -- "  \
            "pIrp=<%p> pSend=<%p>, pAddress=<%p>\n",
                pIrp, pSend, (pSend ? pSend->pAssociatedAddress : NULL)));
        return;
    }

    PgmLock (pSend, OldIrq);

    //
    // First, see if the Irp is on any of our lists
    //
    pEntry = &pSend->pSender->PendingSends;
    while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingSends)
    {
        pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        if (pSendContext1->pIrp == pIrp)
        {
            pSendContext2 = pSendContext1;
            break;
        }
    }

    if (!pSendContext2)
    {
        //
        // Now, search the packetized list
        //
        pEntry = &pSend->pSender->PendingPacketizedSends;
        while ((pEntry = pEntry->Flink) != &pSend->pSender->PendingPacketizedSends)
        {
            pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
            if (pSendContext1->pIrp == pIrp)
            {
                pSendContext2 = pSendContext1;
                break;
            }
        }

        if (!pSendContext2)
        {
            //
            // We did not find the irp -- either it was just being completed
            // (or waiting for a send-complete), or the Irp was bad ?
            //
            PgmUnlock (pSend, OldIrq);
            IoReleaseCancelSpinLock (pIrp->CancelIrql);

            PgmTrace (LogPath, ("PgmCancelSendIrp:  "  \
                "Did not find Cancel Irp=<%p>\n", pIrp));

            return;
        }
    }

    InitializeListHead (&ListEntry);
    PgmCancelAllSends (pSend, &ListEntry, pIrp);

    PgmUnlock (pSend, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);

    //
    // Now, complete all the sends which we removed
    //
    NumRequests = 0;
    while (!IsListEmpty (&ListEntry))
    {
        pEntry = RemoveHeadList (&ListEntry);
        pSendContext1 = CONTAINING_RECORD (pEntry, tCLIENT_SEND_REQUEST, Linkage);
        ASSERT (!pSendContext1->pMessage2Request);

        if (pSendContext1->pIrpToComplete)
        {
            NumRequests++;
            ASSERT (pSendContext1->pIrpToComplete == pSendContext1->pIrp);
            PgmIoComplete (pSendContext1->pIrpToComplete, STATUS_CANCELLED, 0);
        }
        else
        {
            ASSERT (pSendContext1->pIrp);
        }

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        ExFreeToNPagedLookasideList (&pSend->pSender->SendContextLookaside, pSendContext1);
    }

    PgmTrace (LogPath, ("PgmCancelSendIrp:  "  \
        "Cancelled <%d> Irps for pIrp=<%p>\n", NumRequests, pIrp));
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendRequestFromClient(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called via dispatch by the client to post a Send pIrp

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS                    status;
    PGMLockHandle               OldIrq1, OldIrq2, OldIrq3, OldIrq4;
    tADDRESS_CONTEXT            *pAddress = NULL;
    tCLIENT_SEND_REQUEST        *pSendContext1;
    tCLIENT_SEND_REQUEST        *pSendContext2 = NULL;
    ULONG                       BytesLeftInMessage;
    tSEND_SESSION               *pSend = (tSEND_SESSION *) pIrpSp->FileObject->FsContext;
    tSEND_CONTEXT               *pSender;
    PTDI_REQUEST_KERNEL_SEND    pTdiRequest = (PTDI_REQUEST_KERNEL_SEND) &pIrpSp->Parameters;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fFirstSend, fResourceAcquired, fAttached;
    LARGE_INTEGER               Frequency;
    LIST_ENTRY                  ListEntry;

    PgmLock (&PgmDynamicConfig, OldIrq1);

    //
    // Verify that the connection is valid and is associated with an address
    //
    if ((!PGM_VERIFY_HANDLE (pSend, PGM_VERIFY_SESSION_SEND)) ||
        (!(pAddress = pSend->pAssociatedAddress)) ||
        (!pSend->pSender->SendTimeoutCount) ||          // Verify PgmConnect has run!
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)) ||
        (pSend->SessionFlags & (PGM_SESSION_CLIENT_DISCONNECTED | PGM_SESSION_SENDS_CANCELLED)) ||
        (pAddress->Flags & PGM_ADDRESS_FLAG_INVALID_OUT_IF))
    {
        PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
            "Invalid Handles pSend=<%p>, pAddress=<%p>\n", pSend, pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_HANDLE);
    }

    pSender = pSend->pSender;
    if (!pSender->DestMCastIpAddress)
    {
        PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
            "Destination address not specified for pSend=<%p>\n", pSend));

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_INVALID_ADDRESS_COMPONENT);
    }

    if (!pTdiRequest->SendLength)
    {
        PgmTrace (LogStatus, ("PgmSendRequestFromClient:  "  \
            "pIrp=<%p> for pSend=<%p> is of length 0!\n", pIrp, pSend));

        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        return (STATUS_SUCCESS);
    }

    PgmLock (pAddress, OldIrq2);
    PgmLock (pSend, OldIrq3);

    if (!(pSendContext1 = ExAllocateFromNPagedLookasideList (&pSender->SendContextLookaside)))
    {
        PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pSendContext1\n"));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // If we have more that 1 message data in this request,
    // we will need another send context
    //
    if ((pSender->ThisSendMessageLength) &&          // Client has specified current message length
        (BytesLeftInMessage = pSender->ThisSendMessageLength - pSender->BytesSent) &&
        (BytesLeftInMessage < pTdiRequest->SendLength) &&   // ==> Have some extra data in this request
        (!(pSendContext2 = ExAllocateFromNPagedLookasideList (&pSender->SendContextLookaside))))
    {
        ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContext1);
        PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pSendContext1\n"));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    //
    // Zero the SendDataContext structure(s)
    //
    PgmZeroMemory (pSendContext1, sizeof (tCLIENT_SEND_REQUEST));
    InitializeListHead (&pSendContext1->Linkage);
    if (pSendContext2)
    {
        PgmZeroMemory (pSendContext2, sizeof (tCLIENT_SEND_REQUEST));
        InitializeListHead (&pSendContext2->Linkage);
    }

    if (pSend->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET)
    {
        fFirstSend = TRUE;
    }
    else
    {
        fFirstSend = FALSE;
    }

    //
    // Reference the Address and Connection so that they cannot go away
    // while we are processing!
    //
    PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW, TRUE);

    PgmUnlock (pSend, OldIrq3);
    PgmUnlock (pAddress, OldIrq2);
    PgmUnlock (&PgmDynamicConfig, OldIrq1);

    if (PgmGetCurrentIrql())
    {
        fResourceAcquired = FALSE;
    }
    else
    {
        fResourceAcquired = TRUE;
        PgmAcquireResourceExclusive (&pSender->Resource, TRUE);
    }

    if (fFirstSend)
    {
        //
        // Don't start the timer yet, but start the sender thread
        //
        PgmAttachToProcessForVMAccess (pSend, &ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);

        status = PsCreateSystemThread (&pSender->SendHandle,
                                       PROCESS_ALL_ACCESS,
                                       NULL,
                                       NULL,
                                       NULL,
                                       SenderWorkerThread,
                                       pSend);

        if (!NT_SUCCESS (status))
        {
            PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);
            if (fResourceAcquired)
            {
                PgmReleaseResource (&pSender->Resource);
            }

            ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContext1);
            if (pSendContext2)
            {
                ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContext2);
            }
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);

            PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
                "status=<%x> starting sender thread\n", status));

            return (status);
        }

        //
        // Close the handle to the thread so that it goes away when the
        // thread terminates
        //
        ZwClose (pSender->SendHandle);
        PgmDetachProcess (&ApcState, &fAttached, REF_PROCESS_ATTACH_START_SENDER_THREAD);

        PgmLock (&PgmDynamicConfig, OldIrq1);
        IoAcquireCancelSpinLock (&OldIrq2);
        PgmLock (pAddress, OldIrq3);
        PgmLock (pSend, OldIrq4);

        pSend->SessionFlags &= ~PGM_SESSION_FLAG_FIRST_PACKET;
        pSender->pAddress = pAddress;
        pSender->LastODataSentSequenceNumber = -1;

        //
        // Set the SYN flag for the first packet
        //
        pSendContext1->DataOptions |= PGM_OPTION_FLAG_SYN;   // First packet only
        pSendContext1->DataOptionsLength += PGM_PACKET_OPT_SYN_LENGTH;

        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_TIMER_RUNNING, TRUE);
        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_SEND_IN_PROGRESS, TRUE);

        //
        // Now, set and start the timer
        //
        pSender->LastTimeout.QuadPart = KeQueryInterruptTime ();
        pSender->TimeoutGranularity.QuadPart = BASIC_TIMER_GRANULARITY_IN_MSECS * 10000;    // 100 ns units
        pSender->TimerTickCount = 1;
        PgmInitTimer (&pSend->SessionTimer);
        PgmStartTimer (&pSend->SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, SendSessionTimeout, pSend);
    }
    else
    {
        PgmLock (&PgmDynamicConfig, OldIrq1);
        IoAcquireCancelSpinLock (&OldIrq2);
        PgmLock (pAddress, OldIrq3);
        PgmLock (pSend, OldIrq4);
    }

    pSendContext1->pSend = pSend;
    pSendContext1->pIrp = pIrp;
    pSendContext1->pIrpToComplete = pIrp;
    pSendContext1->NextDataOffsetInMdl = 0;
    pSendContext1->SendNumber = pSender->NextSendNumber++;
    pSendContext1->DataPayloadSize = pSender->MaxPayloadSize;
    pSendContext1->DataOptions |= pSender->DataOptions;   // Attach options common for every send
    pSendContext1->DataOptionsLength += pSender->DataOptionsLength;
    pSendContext1->pLastMessageVariableTGPacket = (PVOID) -1;       // FEC-specific

    if (pSender->ThisSendMessageLength)
    {
        PgmTrace (LogPath, ("PgmSendRequestFromClient:  "  \
            "Send # [%d]: MessageLength=<%d>, BytesSent=<%d>, BytesInSend=<%d>\n",
                pSendContext1->SendNumber, pSender->ThisSendMessageLength,
                pSender->BytesSent, pTdiRequest->SendLength));

        pSendContext1->ThisMessageLength = pSender->ThisSendMessageLength;
        pSendContext1->LastMessageOffset = pSender->BytesSent;
        if (pSendContext2)
        {
            //
            // First, set the parameters for SendDataContext1
            //
            pSendContext1->BytesInSend = BytesLeftInMessage;
            pSendContext1->pIrpToComplete = NULL;        // This Irp will be completed by the Context2

            //
            // Now, set the parameters for SendDataContext1
            //
            pSendContext2->pSend = pSend;
            pSendContext2->pIrp = pIrp;
            pSendContext2->pIrpToComplete = pIrp;
            pSendContext2->SendNumber = pSender->NextSendNumber++;
            pSendContext2->DataPayloadSize = pSender->MaxPayloadSize;
            pSendContext2->DataOptions |= pSender->DataOptions;   // Attach options common for every send
            pSendContext2->DataOptionsLength += pSender->DataOptionsLength;
            pSendContext2->pLastMessageVariableTGPacket = (PVOID) -1;       // FEC-specific

            pSendContext2->ThisMessageLength = pTdiRequest->SendLength - BytesLeftInMessage;
            pSendContext2->BytesInSend = pSendContext2->ThisMessageLength;
            pSendContext2->NextDataOffsetInMdl = BytesLeftInMessage;
        }
        else
        {
            pSendContext1->BytesInSend = pTdiRequest->SendLength;
        }

        pSender->BytesSent += pSendContext1->BytesInSend;
        if (pSender->BytesSent == pSender->ThisSendMessageLength)
        {
            pSender->BytesSent = pSender->ThisSendMessageLength = 0;
        }
    }
    else
    {
        pSendContext1->ThisMessageLength = pTdiRequest->SendLength;
        pSendContext1->BytesInSend = pTdiRequest->SendLength;
    }

    // If the total Message length exceeds that of PayloadSize/Packet, then we need to fragment
    if ((pSendContext1->ThisMessageLength > pSendContext1->DataPayloadSize) ||
        (pSendContext1->ThisMessageLength > pSendContext1->BytesInSend))
    {
        pSendContext1->DataOptions |= PGM_OPTION_FLAG_FRAGMENT;
        pSendContext1->DataOptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;

        pSendContext1->NumPacketsRemaining = (pSendContext1->BytesInSend +
                                                 (pSender->MaxPayloadSize - 1)) /
                                                pSender->MaxPayloadSize;
        ASSERT (pSendContext1->NumPacketsRemaining >= 1);
    }
    else
    {
        pSendContext1->NumPacketsRemaining = 1;
    }
    pSender->NumPacketsRemaining += pSendContext1->NumPacketsRemaining;

    // Adjust the OptionsLength for the Packet Extension and determine
    if (pSendContext1->DataOptions)
    {
        pSendContext1->DataOptionsLength += PGM_PACKET_EXTENSION_LENGTH;
    }

    pSendContext1->BytesLeftToPacketize = pSendContext1->BytesInSend;
    InsertTailList (&pSender->PendingSends, &pSendContext1->Linkage);
    pSender->NumODataRequestsPending++;

    //
    // Do the same for Context2, if applicable
    if (pSendContext2)
    {
        //
        // Interlink the 2 Send requests
        //
        pSendContext2->pMessage2Request = pSendContext1;
        pSendContext1->pMessage2Request = pSendContext2;

        PGM_REFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW, TRUE);

        if (pSendContext2->ThisMessageLength > pSendContext1->DataPayloadSize)
        {
            pSendContext2->DataOptions |= PGM_OPTION_FLAG_FRAGMENT;
            pSendContext2->DataOptionsLength += PGM_PACKET_OPT_FRAGMENT_LENGTH;

            pSendContext2->NumPacketsRemaining = (pSendContext2->BytesInSend +
                                                      (pSender->MaxPayloadSize - 1)) /
                                                     pSender->MaxPayloadSize;
            ASSERT (pSendContext2->NumPacketsRemaining >= 1);
        }
        else
        {
            pSendContext2->NumPacketsRemaining = 1;
        }
        pSender->NumPacketsRemaining += pSendContext2->NumPacketsRemaining;

        // Adjust the OptionsLength for the Packet Extension and determine
        if (pSendContext2->DataOptions)
        {
            pSendContext2->DataOptionsLength += PGM_PACKET_EXTENSION_LENGTH;
        }

        pSendContext2->BytesLeftToPacketize = pSendContext2->BytesInSend;
        InsertTailList (&pSender->PendingSends, &pSendContext2->Linkage);
        pSender->NumODataRequestsPending++;
    }

    if (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelSendIrp, TRUE)))
    {
        pSend->SessionFlags |= PGM_SESSION_SENDS_CANCELLED;

        pSender->NumODataRequestsPending--;
        pSender->NumPacketsRemaining -= pSendContext1->NumPacketsRemaining;
        RemoveEntryList (&pSendContext1->Linkage);
        ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContext1);

        if (pSendContext2)
        {
            pSender->NumODataRequestsPending--;
            pSender->NumPacketsRemaining -= pSendContext2->NumPacketsRemaining;
            RemoveEntryList (&pSendContext2->Linkage);
            ExFreeToNPagedLookasideList (&pSender->SendContextLookaside, pSendContext2);
        }

        PgmUnlock (pSend, OldIrq4);
        PgmUnlock (pAddress, OldIrq3);
        IoReleaseCancelSpinLock (OldIrq2);
        PgmUnlock (&PgmDynamicConfig, OldIrq1);

        PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        if (pSendContext2)
        {
            PGM_DEREFERENCE_SESSION_SEND (pSend, REF_SESSION_SEND_IN_WINDOW);
        }

        PgmTrace (LogError, ("PgmSendRequestFromClient: ERROR -- "  \
            "Could not set Cancel routine on Send Irp=<%p>, pSend=<%p>, pAddress=<%p>\n",
                pIrp, pSend, pAddress));

        return (STATUS_CANCELLED);
    }

    IoReleaseCancelSpinLock (OldIrq4);

    PgmUnlock (pAddress, OldIrq3);
    PgmUnlock (&PgmDynamicConfig, OldIrq2);

    if (fResourceAcquired)
    {
//        PgmPrepareNextSend (pSend, &OldIrq1, TRUE, TRUE);
    }

    if (pSender->CurrentBytesSendable >= pAddress->OutIfMTU)
    {
        //
        // Send a synchronization event to the sender thread to
        // send the next available data
        //
        KeSetEvent (&pSender->SendEvent, 0, FALSE);
    }

    PgmUnlock (pSend, OldIrq1);

    if (fResourceAcquired)
    {
        PgmReleaseResource (&pSender->Resource);
    }

    PgmTrace (LogPath, ("PgmSendRequestFromClient:  "  \
        "[%d] Send pending for pIrp=<%p>, pSendContext=<%p -- %p>\n",
            pSendContext1->SendNumber, pIrp, pSendContext1, pSendContext2));

    return (STATUS_PENDING);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\utils.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Utils.c

Abstract:

    This module implements various Utility routines used by
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

VOID
GetRandomData(
    IN  PUCHAR  pBuffer,
    IN  ULONG   BufferSize
    )
/*++

Routine Description:

    This routine returns a random integer calculated using the help of SystemTime

Arguments:

    IN  StartRange  -- Lower bound for range
    IN  EndRange    -- upper bound for range

Return Value:

    Random integer between StartRange and EndRange (inclusive)
    If StartRange >= EndRange, then StartRange is returned

--*/
{
    LARGE_INTEGER   TimeValue;
    ULONG           i;
    UCHAR           *pRandom = (PUCHAR) &TimeValue.LowPart;

    if ((PgmGetCurrentIrql()) ||
        (!PgmFipsInitialize ()) ||
        (!PgmStaticConfig.FipsFunctionTable.FIPSGenRandom (pBuffer, BufferSize)))
    {
        //
        // We were unable to use the Fips routine, so fallback to a quick'n'dirty mechanism
        //
        while (BufferSize)
        {
            KeQuerySystemTime (&TimeValue);
            // the lower 4 bits appear to be zero always...!!
            TimeValue.QuadPart = TimeValue.QuadPart >> 4;
            for (i = 0; i <sizeof(TimeValue.LowPart); i++)
            {
                pBuffer[BufferSize-1] = pRandom[i];
                if (!--BufferSize)
                {
                    break;
                }
            }
        }
    }
}


ULONG
GetRandomInteger(
    IN  ULONG   StartRange,
    IN  ULONG   EndRange
    )
/*++

Routine Description:

    This routine returns a random integer calculated using the help of SystemTime

Arguments:

    IN  StartRange  -- Lower bound for range
    IN  EndRange    -- upper bound for range

Return Value:

    Random integer between StartRange and EndRange (inclusive)
    If StartRange >= EndRange, then StartRange is returned

--*/
{
    ULONG           RandomNumber;
    ULONG           Range = (EndRange - StartRange) + 1;

    if (StartRange >= EndRange)
    {
        return (StartRange);
    }

    GetRandomData ((PUCHAR) &RandomNumber, sizeof (RandomNumber));
    return (StartRange + (RandomNumber % Range));
}


//----------------------------------------------------------------------------

VOID
PgmExecuteWorker(
    IN  PVOID     pContextInfo
    )
/*++

Routine Description:

    This routine handles executing delayed requests at non-Dpc level.  If
    the Driver is currently being unloaded, we let the Unload Handler
    complete the request.

Arguments:
    pContext        - the Context data for this Worker thread

Return Value:

    none

--*/

{
    PGM_WORKER_CONTEXT          *pContext = (PGM_WORKER_CONTEXT *) pContextInfo;
    PPGM_WORKER_ROUTINE         pDelayedWorkerRoutine = (PPGM_WORKER_ROUTINE) pContext->WorkerRoutine;
    PGMLockHandle               OldIrq;

    (*pDelayedWorkerRoutine) (pContext->Context1,
                              pContext->Context2,
                              pContext->Context3);

    PgmFreeMem ((PVOID) pContext);


    PgmLock (&PgmDynamicConfig, OldIrq);
    if ((!--PgmDynamicConfig.NumWorkerThreadsQueued) &&
        (PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_UNLOADING))
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
        KeSetEvent(&PgmDynamicConfig.LastWorkerItemEvent, 0, FALSE);
    }
    else
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmQueueForDelayedExecution(
    IN  PVOID                   DelayedWorkerRoutine,
    IN  PVOID                   Context1,
    IN  PVOID                   Context2,
    IN  PVOID                   Context3,
    IN  BOOLEAN                 fConfigLockHeld
    )
/*++

Routine Description:

    This routine simply queues a request on an excutive worker thread
    for later execution.

Arguments:
    DelayedWorkerRoutine- the routine for the Workerthread to call
    Context1            - Context
    Context2
    Context3

Return Value:

    NTSTATUS    -- Final status of the Queue request

--*/
{
    NTSTATUS            status = STATUS_INSUFFICIENT_RESOURCES;
    PGM_WORKER_CONTEXT  *pContext;
    PGMLockHandle       OldIrq;

    if (!fConfigLockHeld)
    {
        PgmLock (&PgmDynamicConfig, OldIrq);
    }

    if (pContext = (PGM_WORKER_CONTEXT *) PgmAllocMem (sizeof(PGM_WORKER_CONTEXT), PGM_TAG('2')))
    {
        PgmZeroMemory (pContext, sizeof(PGM_WORKER_CONTEXT));
        InitializeListHead(&pContext->PgmConfigLinkage);

        pContext->Context1 = Context1;
        pContext->Context2 = Context2;
        pContext->Context3 = Context3;
        pContext->WorkerRoutine = DelayedWorkerRoutine;

        //
        // Don't Queue this request onto the Worker Queue if we have
        // already started unloading
        //
        if (PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_UNLOADING)
        {
            InsertTailList (&PgmDynamicConfig.WorkerQList, &pContext->PgmConfigLinkage);
        }
        else
        {
            ++PgmDynamicConfig.NumWorkerThreadsQueued;
            ExInitializeWorkItem (&pContext->Item, PgmExecuteWorker, pContext);
            ExQueueWorkItem (&pContext->Item, DelayedWorkQueue);
        }

        status = STATUS_SUCCESS;
    }

    if (!fConfigLockHeld)
    {
        PgmUnlock (&PgmDynamicConfig, OldIrq);
    }

    return (status);
}



//----------------------------------------------------------------------------
//
// The following routines are temporary and will be replaced by WMI logging
// in the near future
//
//----------------------------------------------------------------------------
#ifdef  OLD_LOGGING

// ULONG   PgmDebugFlags = DBG_ENABLE_DBGPRINT;
// ULONG   PgmDebugFlags = 0xffffffff;

#if DBG
enum eSEVERITY_LEVEL    PgmDebuggerSeverity = PGM_LOG_INFORM_STATUS;
#else
enum eSEVERITY_LEVEL    PgmDebuggerSeverity = PGM_LOG_DISABLED;
#endif  // DBG
ULONG                   PgmDebuggerPath = 0xffffffff;

enum eSEVERITY_LEVEL    PgmLogFileSeverity = PGM_LOG_DISABLED;
ULONG                   PgmLogFilePath = 0x0;


NTSTATUS
_PgmLog(
    IN  enum eSEVERITY_LEVEL    Severity,
    IN  ULONG                   Path,
    IN  PUCHAR                  pszFunctionName,
    IN  PUCHAR                  Format,
    IN  va_list                 Marker
    )
/*++

Routine Description:

    This routine

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PUCHAR          pLogBuffer = NULL;

    if ((Path & PgmLogFilePath) && (Severity <= PgmLogFileSeverity))
    {
        ASSERT (0);     // Not implemented yet!
    }

    if ((Path & PgmDebuggerPath) && (Severity <= PgmDebuggerSeverity))
    {
        if (MAX_DEBUG_MESSAGE_LENGTH <= (sizeof ("RMCast.") +
                                         sizeof (": ") +
                                         sizeof ("ERROR -- ") +
                                         strlen (pszFunctionName) + 1))
        {
            DbgPrint ("PgmLog:  FunctionName=<%s> too big to print!\n", pszFunctionName);
            return (STATUS_UNSUCCESSFUL);
        }

        if (!(pLogBuffer = ExAllocateFromNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList)))
        {
            DbgPrint ("PgmLog:  STATUS_INSUFFICIENT_RESOURCES Logging %sMessage from Function=<%s>\n",
                ((Severity == PGM_LOG_ERROR || Severity == PGM_LOG_CRITICAL_ERROR) ? "ERROR " : ""), pszFunctionName);
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        strcpy(pLogBuffer, "RMCast.");
        strcat(pLogBuffer, pszFunctionName);
        strcat(pLogBuffer, ": ");

        if ((Severity == PGM_LOG_ERROR) ||
            (Severity == PGM_LOG_CRITICAL_ERROR))
        {
            strcat(pLogBuffer, "ERROR -- ");
        }

        _vsnprintf (pLogBuffer+strlen(pLogBuffer), MAX_DEBUG_MESSAGE_LENGTH-strlen(pLogBuffer), Format, Marker);
        pLogBuffer[MAX_DEBUG_MESSAGE_LENGTH] = '\0';

        DbgPrint ("%s", pLogBuffer);

        ExFreeToNPagedLookasideList (&PgmStaticConfig.DebugMessagesLookasideList, pLogBuffer);
    }

    return (STATUS_SUCCESS);
}



//----------------------------------------------------------------------------
NTSTATUS
PgmLog(
    IN  enum eSEVERITY_LEVEL    Severity,
    IN  ULONG                   Path,
    IN  PUCHAR                  pszFunctionName,
    IN  PUCHAR                  Format,
    ...
    )
/*++

Routine Description:

    This routine

Arguments:

    IN

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    va_list Marker;

    //
    // Based on our Path and the Flags, see if this Event qualifies
    // for being logged
    //
    if (((Path & PgmDebuggerPath) && (Severity <= PgmDebuggerSeverity)) ||
        ((Path & PgmLogFilePath) && (Severity <= PgmLogFileSeverity)))
    {
        va_start (Marker, Format);

        status =_PgmLog (Severity, Path, pszFunctionName, Format, Marker);

        va_end (Marker);
    }

    return (status);
}

//----------------------------------------------------------------------------

#endif  // OLD_LOGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\tdi.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Tdi.c

Abstract:

    This module implements Initialization routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"
#include <ntddtcp.h>    // for IOCTL_TCP_SET_INFORMATION_EX
#include <tcpinfo.h>    // for TCPSocketOption
#include <tdiinfo.h>    // for TCP_REQUEST_SET_INFORMATION_EX

#ifdef FILE_LOGGING
#include "tdi.tmh"
#endif  // FILE_LOGGING


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TdiOpenAddressHandle)
#pragma alloc_text(PAGE, CloseAddressHandles)
#pragma alloc_text(PAGE, PgmTdiOpenControl)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------

NTSTATUS
PgmTdiCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine does not complete the Irp. It is used to signal to a
    synchronous part of the NBT driver that it can proceed (i.e.
    to allow some code that is waiting on a "KeWaitForSingleObject" to
    proceeed.

Arguments:

    IN  DeviceObject    -- unused.
    IN  Irp             -- Supplies Irp that the transport has finished processing.
    IN  Context         -- Supplies the event associated with the Irp.

Return Value:

    The STATUS_MORE_PROCESSING_REQUIRED so that the IO system stops
    processing Irp stack locations at this point.

--*/
{
    PgmTrace (LogAllFuncs, ("PgmTdiCompletionRoutine:  "  \
        "CompletionEvent:  pEvent=<%p>, pIrp=<%p>, DeviceObject=<%p>\n", Context, Irp, DeviceObject));

    KeSetEvent ((PKEVENT )Context, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//----------------------------------------------------------------------------

NTSTATUS
TdiSetEventHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG EventType,
    IN PVOID EventHandler,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine registers an event handler with a TDI transport provider.

Arguments:

    IN PDEVICE_OBJECT DeviceObject  -- Supplies the device object of the transport provider.
    IN PFILE_OBJECT FileObject      -- Supplies the address object's file object.
    IN ULONG EventType,             -- Supplies the type of event.
    IN PVOID EventHandler           -- Supplies the event handler.
    IN PVOID Context                -- Supplies the context passed into the event handler when it runs

Return Value:

    NTSTATUS - Final status of the set event operation

--*/

{
    NTSTATUS    Status;
    KEVENT      Event;
    PIRP        pIrp;

    PAGED_CODE();

    if (!(pIrp = IoAllocateIrp (IoGetRelatedDeviceObject (FileObject)->StackSize, FALSE)))
    {
        PgmTrace (LogError, ("TdiSetEventHandler: ERROR -- "  \
            "INSUFFICIENT_RESOURCES allocating Irp, StackSize=<%d>\n",
                IoGetRelatedDeviceObject (FileObject)->StackSize));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    TdiBuildSetEventHandler (pIrp, DeviceObject, FileObject,
                             NULL, NULL,
                             EventType, EventHandler, Context);

    KeInitializeEvent (&Event, NotificationEvent, FALSE);

    // set the address of the routine to be executed when the IRP
    // finishes.  This routine signals the event and allows the code
    // below to continue (i.e. KeWaitForSingleObject)
    //
    IoSetCompletionRoutine (pIrp,
                            (PIO_COMPLETION_ROUTINE) PgmTdiCompletionRoutine,
                            (PVOID)&Event,
                            TRUE, TRUE, TRUE);

    Status = IoCallDriver (IoGetRelatedDeviceObject (FileObject), pIrp);
    if (Status == STATUS_PENDING)
    {
        Status = KeWaitForSingleObject ((PVOID)&Event, // Object to wait on.
                                        Executive,  // Reason for waiting
                                        KernelMode, // Processor mode
                                        FALSE,      // Alertable
                                        NULL);      // Timeout
        if (NT_SUCCESS(Status))
        {
            Status = pIrp->IoStatus.Status;
        }
    }

    IoFreeIrp (pIrp);

    PgmTrace (LogAllFuncs, ("TdiSetEventHandler:  "  \
        "Status=<%d>, EventType=<%d>, Handler=<%p>\n", Status, EventType, EventHandler));

    return (Status);
}

//----------------------------------------------------------------------------

NTSTATUS
TdiErrorHandler(
    IN PVOID Context,
    IN NTSTATUS Status
    )
/*++

Routine Description:

    This routine is the handler for TDI errors

Arguments:

    IN  Context -- unused
    IN  Status  -- error status

Return Value:

    NTSTATUS - Final status of the set event operation

--*/
{
    PgmTrace (LogError, ("TdiErrorHandler: ERROR -- "  \
        "Status=<%x>\n", Status));

    return (STATUS_DATA_NOT_ACCEPTED);
}


//----------------------------------------------------------------------------

NTSTATUS
TdiOpenAddressHandle(
    IN  tPGM_DEVICE     *pPgmDevice,
    IN  PVOID           HandlerContext,
    IN  tIPADDRESS      IpAddress,
    IN  USHORT          PortNumber,
    OUT HANDLE          *pFileHandle,
    OUT PFILE_OBJECT    *ppFileObject,
    OUT PDEVICE_OBJECT  *ppDeviceObject
    )
/*++

Routine Description:

    This routine is called to open an address handle on IP

Arguments:

    IN  pPgmDevice      -- Pgm's Device object context
    IN  HandlerContext  -- pAddress object ptr to be used as context ptr (NULL if don't want to be notified)
    IN  IpAddress       -- local IpAddress on which to open address
    IN  PortNumber      -- IP protocol port
    OUT pFileHandle     -- FileHandle if we succeeded
    OUT ppFileObject    -- FileObject if we succeeded
    OUT ppDeviceObject  -- IP's DeviceObject ptr if we succeeded

Return Value:

    NTSTATUS - Final status of the Open Address operation

--*/
{
    NTSTATUS                    status;
    ULONG                       EaBufferSize;
    PFILE_FULL_EA_INFORMATION   EaBuffer;
    PTRANSPORT_ADDRESS          pTransAddressEa;
    PTRANSPORT_ADDRESS          pTransAddr;
    TDI_ADDRESS_IP              IpAddr;
    OBJECT_ATTRIBUTES           AddressAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    PFILE_OBJECT                pFileObject;
    HANDLE                      FileHandle;
    PDEVICE_OBJECT              pDeviceObject;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;
    ULONG                       True = TRUE;

    PAGED_CODE();

    EaBufferSize = sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                   TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                   sizeof(TRANSPORT_ADDRESS) +
                   sizeof(TDI_ADDRESS_IP);

    if (!(EaBuffer = PgmAllocMem (EaBufferSize, PGM_TAG('1'))))
    {
        PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
            "[1]:  INSUFFICIENT_RESOURCES allocating <%d> bytes\n", EaBufferSize));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    // allocate Memory for the transport address
    //
    if (!(pTransAddr = PgmAllocMem (sizeof(TRANSPORT_ADDRESS)+sizeof(TDI_ADDRESS_IP), PGM_TAG('2'))))
    {
        PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
            "[2]:  INSUFFICIENT_RESOURCES allocating <%d> bytes\n",
                (sizeof(TRANSPORT_ADDRESS)+sizeof(TDI_ADDRESS_IP))));

        PgmFreeMem (EaBuffer);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    EaBuffer->NextEntryOffset = 0;
    EaBuffer->Flags = 0;
    EaBuffer->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    EaBuffer->EaValueLength = (USHORT)(sizeof(TRANSPORT_ADDRESS) -1 + sizeof(TDI_ADDRESS_IP));
    PgmMoveMemory (EaBuffer->EaName, TdiTransportAddress, EaBuffer->EaNameLength+1); // "TransportAddress"

    // fill in the IP address and Port number
    //
    IpAddr.sin_port = htons (PortNumber);   // put in network order
    IpAddr.in_addr = htonl (IpAddress);
    RtlFillMemory ((PVOID)&IpAddr.sin_zero, sizeof(IpAddr.sin_zero), 0);    // zero fill the  last component

    // copy the ip address to the end of the structure
    //
    PgmMoveMemory (pTransAddr->Address[0].Address, (CONST PVOID)&IpAddr, sizeof(IpAddr));
    pTransAddr->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTransAddr->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pTransAddr->TAAddressCount = 1;

    // copy the ip address to the end of the name in the EA structure
    pTransAddressEa = (TRANSPORT_ADDRESS *)&EaBuffer->EaName[EaBuffer->EaNameLength+1];
    PgmMoveMemory ((PVOID)pTransAddressEa,
                   (CONST PVOID)pTransAddr,
                   sizeof(TDI_ADDRESS_IP) + sizeof(TRANSPORT_ADDRESS)-1);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);

    InitializeObjectAttributes (&AddressAttributes,
                                &pPgmDevice->ucBindName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL);

    status = ZwCreateFile (&FileHandle,
                           GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                           &AddressAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN_IF,
                           0,
                           (PVOID)EaBuffer,
                           sizeof(FILE_FULL_EA_INFORMATION) - 1 +
                               EaBuffer->EaNameLength + 1 +
                               EaBuffer->EaValueLength);

    PgmFreeMem ((PVOID)pTransAddr);
    PgmFreeMem ((PVOID)EaBuffer);

    if (NT_SUCCESS (status))
    {
        status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS (status))
    {
        //
        // Reference the FileObject to keep device ptr around!
        //
        status = ObReferenceObjectByHandle (FileHandle, (ULONG)0, 0, KernelMode, (PVOID *)&pFileObject, NULL);
        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
                "FAILed to Reference FileObject: status=<%x>\n", status));

            ZwClose (FileHandle);
        }
    }
    else
    {
        PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
            "FAILed to create handle: status=<%x>, Device:\n\t%wZ\n", status, &pPgmDevice->ucBindName));
    }

    if (!NT_SUCCESS (status))
    {
        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);
        return (status);
    }

    pDeviceObject = IoGetRelatedDeviceObject (pFileObject);

    //
    // Now set the Event handlers (only if we have the HandlerContext set)!
    //
    if (HandlerContext)
    {
        status = TdiSetEventHandler (pDeviceObject,
                                     pFileObject,
                                     TDI_EVENT_ERROR,
                                     (PVOID) TdiErrorHandler,
                                     HandlerContext);
        if (NT_SUCCESS (status))
        {
            // Datagram Udp Handler
            status = TdiSetEventHandler (pDeviceObject,
                                         pFileObject,
                                         TDI_EVENT_RECEIVE_DATAGRAM,
                                         (PVOID) TdiRcvDatagramHandler,
                                         HandlerContext);
            if (NT_SUCCESS (status))
            {
#if(WINVER > 0x0500)
                status = PgmSetTcpInfo (FileHandle,
                                        AO_OPTION_IP_PKTINFO,
                                        &True,
                                        sizeof (True));

                if (!NT_SUCCESS (status))
                {
                    PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
                        "Setting AO_OPTION_IP_PKTINFO, status=<%x>\n", status));
                }
#endif  // WINVER
            }
            else
            {
                PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
                    "FAILed to set TDI_EVENT_RECEIVE_DATAGRAM handler, status=<%x>\n", status));
            }
        }
        else
        {
            PgmTrace (LogError, ("TdiOpenAddressHandle: ERROR -- "  \
                "FAILed to set TDI_EVENT_ERROR handler, status=<%x>\n", status));
        }
    }

    if (NT_SUCCESS(status))
    {
        *pFileHandle = FileHandle;
        *ppFileObject = pFileObject;
        *ppDeviceObject = pDeviceObject;

        PgmTrace (LogAllFuncs, ("TdiOpenAddressHandle:  "  \
            "SUCCEEDed, FileHandle=<%p>, pFileObject=<%p>, pDeviceObject=<%p>\n",
                FileHandle, pFileObject, pDeviceObject));
    }
    else
    {
        //
        // FAILed to set Tdi handlers
        //
        ObDereferenceObject (pFileObject);
        ZwClose (FileHandle);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_ADDR_HANDLE);

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
CloseAddressHandles(
    IN  HANDLE          FileHandle,
    IN  PFILE_OBJECT    pFileObject
    )
/*++

Routine Description:

    This routine dereferences any FileObjects as necessary and closes the
    FileHandle that was opened earlier

Arguments:

    IN  FileHandle  -- FileHandle to be closed
    IN  pFileObject -- FileObject to be dereferenced

Return Value:

    NTSTATUS - Final status of the CloseAddress operation

--*/
{
    NTSTATUS    status1 = STATUS_SUCCESS;
    KAPC_STATE  ApcState;
    BOOLEAN     fAttached;

    PAGED_CODE();

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_CLOSE_ADDRESS_HANDLES);

    if (pFileObject)
    {
        ObDereferenceObject ((PVOID *) pFileObject);
    }

    if (FileHandle)
    {
        status1 = ZwClose (FileHandle);
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_CLOSE_ADDRESS_HANDLES);

    PgmTrace (LogAllFuncs, ("CloseAddressHandles:  "  \
        "FileHandle=<%p> ==> status=<%x>, pFileObject=<%p>\n",
            FileHandle, status1, pFileObject));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmTdiOpenControl(
    IN  tPGM_DEVICE         *pPgmDevice
    )
/*++

Routine Description:

    This routine opens a Control channel over Raw IP

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    PFILE_FULL_EA_INFORMATION   EaBuffer = NULL;
    IO_STATUS_BLOCK             IoStatusBlock;
    KAPC_STATE                  ApcState;
    BOOLEAN                     fAttached;

    PAGED_CODE();

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_OPEN_CONTROL_HANDLE);

    InitializeObjectAttributes (&ObjectAttributes,
                                &pPgmDevice->ucBindName,
                                0,
                                NULL,
                                NULL);

    Status = ZwCreateFile ((PHANDLE) &pPgmDevice->hControl,
                           GENERIC_READ | GENERIC_WRITE,
                           &ObjectAttributes,     // object attributes.
                           &IoStatusBlock,        // returned status information.
                           NULL,                  // block size (unused).
                           FILE_ATTRIBUTE_NORMAL, // file attributes.
                           0,
                           FILE_CREATE,
                           0,                     // create options.
                           (PVOID)EaBuffer,       // EA buffer.
                           0); // Ea length

    if (NT_SUCCESS (Status))
    {
        Status = IoStatusBlock.Status;
    }

    if (NT_SUCCESS (Status))
    {
        //
        // get a reference to the file object and save it since we can't
        // dereference a file handle at DPC level so we do it now and keep
        // the ptr around for later.
        //
        Status = ObReferenceObjectByHandle (pPgmDevice->hControl,
                                            0L,
                                            NULL,
                                            KernelMode,
                                            (PVOID *) &pPgmDevice->pControlFileObject,
                                            NULL);

        if (!NT_SUCCESS(Status))
        {
            PgmTrace (LogError, ("PgmTdiOpenControl: ERROR -- "  \
                "ObReferenceObjectByHandle FAILed status=<%x>\n", Status));

            ZwClose (pPgmDevice->hControl);
        }
    }
    else
    {
        PgmTrace (LogError, ("PgmTdiOpenControl: ERROR -- "  \
            "Failed to Open the Control file, Status=<%x>\n", Status));
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_OPEN_CONTROL_HANDLE);

    if (NT_SUCCESS(Status))
    {
        //
        // We Succeeded!
        //
        pPgmDevice->pControlDeviceObject = IoGetRelatedDeviceObject (pPgmDevice->pControlFileObject);

        PgmTrace (LogAllFuncs, ("PgmTdiOpenControl:  "  \
            "Opened Control channel on: %wZ\n", &pPgmDevice->ucBindName));
    }
    else
    {
        // set control file object ptr to null so we know that we did not open the control point.
        pPgmDevice->hControl = NULL;
        pPgmDevice->pControlFileObject = NULL;
    }

    return (Status);
}


//----------------------------------------------------------------------------
VOID
PgmDereferenceControl(
    IN  tCONTROL_CONTEXT    *pControlContext,
    IN  ULONG               RefContext
    )
/*++

Routine Description:

    This routine dereferences the control channel oblect over RawIP and
    frees the memory if the RefCount drops to 0

Arguments:

    IN  pControlContext -- Control object context
    IN  RefContext      -- Context for which this control object was referenced earlier

Return Value:

    NONE

--*/
{
    ASSERT (PGM_VERIFY_HANDLE (pControlContext, PGM_VERIFY_CONTROL));
    ASSERT (pControlContext->RefCount);             // Check for too many derefs
    ASSERT (pControlContext->ReferenceContexts[RefContext]--);

    if (--pControlContext->RefCount)
    {
        return;
    }

    PgmTrace (LogAllFuncs, ("PgmDereferenceControl:  "  \
        "pControl=<%p> closed\n", pControlContext));
    //
    // Just Free the memory
    //
    PgmFreeMem (pControlContext);
}


//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagramCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            pContext
    )
/*++

Routine Description:

    This routine is called on completion of a DatagramSend

Arguments:

    IN  PDEVICE_OBJECT DeviceObject -- Supplies the device object of the transport provider.
    IN  pIrp                        -- Request
    IN  PVOID Context               -- Supplies the context passed

Return Value:

    NTSTATUS - Final status of the completion which will determine
                how the IO subsystem processes it subsequently

--*/

{
    NTSTATUS            status;
    tTDI_SEND_CONTEXT   *pTdiSendContext = (tTDI_SEND_CONTEXT *) pContext;

    PgmTrace (LogAllFuncs, ("TdiSendDatagramCompletion:  "  \
        "status=<%x>, Info=<%x>, pIrp=<%p>\n",
            pIrp->IoStatus.Status, (ULONG) pIrp->IoStatus.Information, pIrp));

    pTdiSendContext->pClientCompletionRoutine (pTdiSendContext->ClientCompletionContext1,
                                               pTdiSendContext->ClientCompletionContext2,
                                               pIrp->IoStatus.Status);

    //
    // Free the Memory that was allocated for this send
    //
    if (pTdiSendContext->fPagedBuffer)
    {
        MmUnlockPages (pIrp->MdlAddress);
    }
    ExFreeToNPagedLookasideList (&PgmStaticConfig.TdiLookasideList, pTdiSendContext);
    IoFreeMdl (pIrp->MdlAddress);
    IoFreeIrp (pIrp);

    // return this status to stop the IO subsystem from further processing the
    // IRP - i.e. trying to complete it back to the initiating thread! -since
    // there is no initiating thread - we are the initiator
    return (STATUS_MORE_PROCESSING_REQUIRED);
}


//----------------------------------------------------------------------------
NTSTATUS
TdiSendDatagram(
    IN  PFILE_OBJECT                pTdiFileObject,
    IN  PDEVICE_OBJECT              pTdiDeviceObject,
    IN  PVOID                       pBuffer,
    IN  ULONG                       BufferLength,
    IN  pCLIENT_COMPLETION_ROUTINE  pClientCompletionRoutine,
    IN  PVOID                       ClientCompletionContext1,
    IN  PVOID                       ClientCompletionContext2,
    IN  tIPADDRESS                  DestIpAddress,
    IN  USHORT                      DestPort,
    IN  BOOLEAN                     fPagedBuffer
    )
/*++

Routine Description:

    This routine sends a datagram over RawIp

Arguments:

    IN  pTdiFileObject              -- IP's FileObject for this address
    IN  pTdiDeviceObject            -- DeviceObject for this address
    IN  pBuffer                     -- Data buffer (Pgm packet)
    IN  BufferLength                -- length of pBuffer
    IN  pClientCompletionRoutine    -- SendCompletion to be called
    IN  ClientCompletionContext1    -- Context1 for SendCompletion
    IN  ClientCompletionContext2    -- Context2 for SendCompletion
    IN  DestIpAddress               -- IP address to send datagram to
    IN  DestPort                    -- Port to send to

Return Value:

    NTSTATUS - STATUS_PENDING on success, and also if SendCompletion was specified

--*/
{
    NTSTATUS            status;
    tTDI_SEND_CONTEXT   *pTdiSendContext = NULL;
    PIRP                pIrp = NULL;
    PMDL                pMdl = NULL;

    //
    // Allocate the SendContext, pIrp and pMdl
    //
    if ((!(pTdiSendContext = ExAllocateFromNPagedLookasideList (&PgmStaticConfig.TdiLookasideList))) ||
        (!(pIrp = IoAllocateIrp (pgPgmDevice->pPgmDeviceObject->StackSize, FALSE))) ||
        (!(pMdl = IoAllocateMdl (pBuffer, BufferLength, FALSE, FALSE, NULL))))
    {
        if (pTdiSendContext)
        {
            ExFreeToNPagedLookasideList (&PgmStaticConfig.TdiLookasideList, pTdiSendContext);
        }

        if (pIrp)
        {
            IoFreeIrp (pIrp);
        }

        PgmTrace (LogError, ("TdiSendDatagram: ERROR -- "  \
            "INSUFFICIENT_RESOURCES for TdiSendContext=<%d> bytes\n", sizeof(tTDI_SEND_CONTEXT)));

        if (pClientCompletionRoutine)
        {
            pClientCompletionRoutine (ClientCompletionContext1,
                                      ClientCompletionContext2,
                                      STATUS_INSUFFICIENT_RESOURCES);
            status = STATUS_PENDING;
        }
        else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }

        return (status);
    }

    if (fPagedBuffer)
    {
        try
        {
            MmProbeAndLockPages (pMdl, KernelMode, IoReadAccess);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
//            status = GetExceptionCode();
            IoFreeMdl (pMdl);
            IoFreeIrp (pIrp);
            ExFreeToNPagedLookasideList (&PgmStaticConfig.TdiLookasideList, pTdiSendContext);

            if (pClientCompletionRoutine)
            {
                pClientCompletionRoutine (ClientCompletionContext1,
                                          ClientCompletionContext2,
                                          STATUS_INSUFFICIENT_RESOURCES);
                status = STATUS_PENDING;
            }
            else
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

            return (status);
        }
        pTdiSendContext->fPagedBuffer = TRUE;
    }
    else
    {
        MmBuildMdlForNonPagedPool (pMdl);
        pTdiSendContext->fPagedBuffer = FALSE;
    }
    pIrp->MdlAddress = pMdl;

    // fill in the remote address
    pTdiSendContext->TransportAddress.TAAddressCount = 1;
    pTdiSendContext->TransportAddress.Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    pTdiSendContext->TransportAddress.Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    pTdiSendContext->TransportAddress.Address[0].Address->in_addr  = htonl(DestIpAddress);
    pTdiSendContext->TransportAddress.Address[0].Address->sin_port = htons(DestPort);

    // fill in the connection information
    pTdiSendContext->TdiConnectionInfo.RemoteAddressLength = sizeof(TA_IP_ADDRESS);
    pTdiSendContext->TdiConnectionInfo.RemoteAddress = &pTdiSendContext->TransportAddress;

    // Fill in our completion Context information
    pTdiSendContext->pClientCompletionRoutine = pClientCompletionRoutine;
    pTdiSendContext->ClientCompletionContext1 = ClientCompletionContext1;
    pTdiSendContext->ClientCompletionContext2 = ClientCompletionContext2;

    // Complete the "send datagram" IRP initialization.
    //
    TdiBuildSendDatagram (pIrp,
                          pTdiDeviceObject,
                          pTdiFileObject,
                          (PVOID) TdiSendDatagramCompletion,
                          pTdiSendContext,
                          pIrp->MdlAddress,
                          BufferLength,
                          &pTdiSendContext->TdiConnectionInfo);

    //
    // Tell the I/O manager to pass our IRP to the transport for
    // processing.
    //
    status = IoCallDriver (pTdiDeviceObject, pIrp);
    ASSERT (status == STATUS_PENDING);

    PgmTrace (LogAllFuncs, ("TdiSendDatagram:  "  \
        "%s Send to <%x:%x>, status=<%x>\n",
            (CLASSD_ADDR(DestIpAddress) ? "MCast" : "Unicast"), DestIpAddress, DestPort, status));

    //
    // IoCallDriver will always result in completion routien being called
    //
    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSetTcpInfo(
    IN HANDLE       FileHandle,
    IN ULONG        ToiId,
    IN PVOID        pData,
    IN ULONG        DataLength
    )
/*++

Routine Description:

    This routine is called to set IP-specific options

Arguments:

    IN  FileHandle  -- FileHandle over IP for which to set option
    IN  ToId        -- Option Id
    IN  pData       -- Option data
    IN  DataLength  -- pData length

Return Value:

    NTSTATUS - Final status of the set option operation

--*/
{
    NTSTATUS                        Status, LocStatus;
    ULONG                           BufferLength;
    TCP_REQUEST_SET_INFORMATION_EX  *pTcpInfo;
    IO_STATUS_BLOCK                 IoStatus;
    HANDLE                          event;
    KAPC_STATE                      ApcState;
    BOOLEAN                         fAttached;

    IoStatus.Status = STATUS_SUCCESS;

    BufferLength = sizeof (TCP_REQUEST_SET_INFORMATION_EX) + DataLength;
    if (!(pTcpInfo = (TCP_REQUEST_SET_INFORMATION_EX *) PgmAllocMem (BufferLength, PGM_TAG('2'))))
    {
        PgmTrace (LogError, ("PgmSetTcpInfo: ERROR -- "  \
            "INSUFFICIENT_RESOURCES for pTcpInfo=<%d+%d> bytes\n",
                sizeof(TCP_REQUEST_SET_INFORMATION_EX), DataLength));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    PgmZeroMemory (pTcpInfo, BufferLength);

    pTcpInfo->ID.toi_entity.tei_entity  = CL_TL_ENTITY;
    pTcpInfo->ID.toi_entity.tei_instance= TL_INSTANCE;
    pTcpInfo->ID.toi_class              = INFO_CLASS_PROTOCOL;
    pTcpInfo->ID.toi_type               = INFO_TYPE_ADDRESS_OBJECT;

    //
    // Set the Configured values
    //
    pTcpInfo->ID.toi_id                 = ToiId;
    pTcpInfo->BufferSize                = DataLength;
    PgmCopyMemory (&pTcpInfo->Buffer[0], pData, DataLength);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    Status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (NT_SUCCESS(Status))
    {
        //
        // Make the actual TDI call
        //
        Status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_SET_INFORMATION_EX,
                                        pTcpInfo,
                                        BufferLength,
                                        NULL,
                                        0);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT (NT_SUCCESS(Status));
        }

        if (STATUS_SUCCESS == Status)
        {
            Status = IoStatus.Status;
            if (!NT_SUCCESS (Status))
            {
                PgmTrace (LogError, ("PgmSetTcpInfo: ERROR -- "  \
                    "TcpSetInfoEx request returned Status = <%x>, Id=<0x%x>\n", Status, ToiId));
            }
        }
        else
        {
            PgmTrace (LogError, ("PgmSetTcpInfo: ERROR -- "  \
                "ZwDeviceIoControlFile returned Status = <%x>, Id=<0x%x>\n", Status, ToiId));
        }

        LocStatus = ZwClose (event);
        ASSERT (NT_SUCCESS(LocStatus));
    }
    else
    {
        PgmTrace (LogError, ("PgmSetTcpInfo: ERROR -- "  \
            "ZwCreateEvent returned Status = <%x>, Id=<0x%x>\n", Status, ToiId));
    }

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    if (STATUS_SUCCESS == Status)
    {
        PgmTrace (LogStatus, ("PgmSetTcpInfo:  "  \
            "ToiId=<%x>, DataLength=<%d>\n", ToiId, DataLength));
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;   // Once, we received a wierd status!
    }

    PgmFreeMem (pTcpInfo);

    return (Status);
}

//----------------------------------------------------------------------------

NTSTATUS
PgmQueryTcpInfo(
    IN  HANDLE       FileHandle,
    IN  ULONG        ToiId,
    IN  PVOID        pDataIn,
    IN  ULONG        DataInLength,
    OUT PVOID        *ppDataOut,
    OUT ULONG        *pDataOutLength
    )
/*++

Routine Description:

    This routine queries IP for transport-specific information

Arguments:

    IN  FileHandle      -- FileHandle over IP for which to set option
    IN  ToId            -- Option Id
    IN  pDataIn         -- Option data
    IN  DataInLength    -- pDataIn length
    IN  pDataOut        -- Buffer for output data
    IN  DataOutLength   -- pDataOut length

Return Value:

    NTSTATUS - Final status of the Query operation

--*/
{
    NTSTATUS                            Status, LocStatus;
    TCP_REQUEST_QUERY_INFORMATION_EX    QueryRequest;
    IO_STATUS_BLOCK                     IoStatus;
    HANDLE                              event;
    KAPC_STATE                          ApcState;
    BOOLEAN                             fAttached;
    PVOID                               pDataOut = NULL;
    ULONG                               DataOutLength = 0;

    if ((ppDataOut) &&
        (pDataOutLength) &&
        (*pDataOutLength))
    {
        DataOutLength = *pDataOutLength;
    }

    PgmZeroMemory (&QueryRequest, sizeof (TCP_REQUEST_QUERY_INFORMATION_EX));
    QueryRequest.ID.toi_entity.tei_entity   = CL_NL_ENTITY;
    QueryRequest.ID.toi_entity.tei_instance = 0;
    QueryRequest.ID.toi_class               = INFO_CLASS_PROTOCOL;
    QueryRequest.ID.toi_type                = INFO_TYPE_PROVIDER;
    QueryRequest.ID.toi_id                  = ToiId;                // Set the Configured value
    if ((DataInLength) &&
        (DataInLength < CONTEXT_SIZE) &&
        (pDataIn))
    {
        PgmCopyMemory (&QueryRequest.Context, pDataIn, DataInLength);
    }

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    Status = ZwCreateEvent (&event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE);
    if (!NT_SUCCESS(Status))
    {
        PgmTrace (LogError, ("PgmQueryTcpInfo: ERROR -- "  \
            "ZwCreateEvent returned Status = <%x>, Id=<0x%x>\n", Status, ToiId));

        return (Status);
    }

    do
    {
        if (pDataOut)
        {
            PgmFreeMem (pDataOut);
            pDataOut = NULL;
            DataOutLength = DataOutLength << 1;
        }

        if (DataOutLength)
        {
            if (!(pDataOut = PgmAllocMem (DataOutLength, PGM_TAG('3'))))
            {
                PgmTrace (LogError, ("PgmQueryTcpInfo: ERROR -- "  \
                    "STATUS_INSUFFICIENT_RESOURCES allocating <%d> bytes for ToiId=<0x%x>\n",
                        DataOutLength, ToiId));

                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            PgmZeroMemory (pDataOut, DataOutLength);
        }

        //
        // Make the actual TDI call
        //
        IoStatus.Status = STATUS_SUCCESS;
        Status = ZwDeviceIoControlFile (FileHandle,
                                        event,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_TCP_QUERY_INFORMATION_EX,
                                        &QueryRequest,
                                        sizeof (TCP_REQUEST_QUERY_INFORMATION_EX),
                                        pDataOut,
                                        DataOutLength);

        //
        // If the call pended and we were supposed to wait for completion,
        // then wait.
        //
        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (event, FALSE, NULL);
            ASSERT (NT_SUCCESS(Status));
        }

        if (STATUS_SUCCESS == Status)
        {
            Status = IoStatus.Status;
            if (!NT_SUCCESS (Status))
            {
                PgmTrace (LogError, ("PgmQueryTcpInfo: ERROR -- "  \
                    "TcpQueryInfoEx request returned Status = <%x>, Id=<0x%x>, DataOutLength=<%d>\n",
                        Status, ToiId, DataOutLength));
            }
        }
        else
        {
            PgmTrace (LogError, ("PgmQueryTcpInfo: ERROR -- "  \
                "ZwDeviceIoControlFile returned Status = <%x>, Id=<0x%x>, DataOutLength=<%d>\n",
                    Status, ToiId, DataOutLength));
        }

    } while ((DataOutLength) &&
             ((STATUS_BUFFER_OVERFLOW == Status) ||
              (STATUS_BUFFER_TOO_SMALL == Status)));

    LocStatus = ZwClose (event);
    ASSERT (NT_SUCCESS(LocStatus));

    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_SET_TCP_INFO);

    if (NT_SUCCESS(Status))
    {
        if (pDataOut)
        {
            *ppDataOut = pDataOut;
//            *pDataOutLength = DataOutLength;
            ASSERT (IoStatus.Information);
            *pDataOutLength = (ULONG) IoStatus.Information;
        }

        PgmTrace (LogAllFuncs, ("PgmQueryTcpInfo:  "  \
            "ToiId=<%x>, DataInLength=<%d>, DataOutLength=<%d>/<%d>\n",
                ToiId, DataInLength, (ULONG) IoStatus.Information, DataOutLength));
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;   // Once, we received a wierd status!
        if (pDataOut)
        {
            PgmFreeMem (pDataOut);
            pDataOut = NULL;
        }
    }

    return (Status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmProcessIPRequest(
    IN ULONG        IOControlCode,
    IN PVOID        pInBuffer,
    IN ULONG        InBufferLen,
    OUT PVOID       *pOutBuffer,
    IN OUT ULONG    *pOutBufferLen
    )

/*++

Routine Description:

    This routine performs IOCTL queries into IP

Arguments:

    IOControlCode   - Ioctl to be made into IP
    pInBuffer       - Buffer containing data to be passed into IP
    InBufferLen     - Length of Input Buffer data
    pOutBuffer      - Returned information
    pOutBufferLen   - Initial expected length of Output Buffer + final length

Return Value:

    NTSTATUS - Final status of the operation

--*/

{
    NTSTATUS                Status;
    HANDLE                  hIP;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          ucDeviceName;
    IO_STATUS_BLOCK         IoStatusBlock;
    ULONG                   OutBufferLen = 0;
    KAPC_STATE              ApcState;
    BOOLEAN                 fAttached;
    HANDLE                  Event = NULL;
    UCHAR                   *pIPInfo = NULL;
    PWSTR                   pNameIP = L"\\Device\\IP";

    PAGED_CODE();

    ucDeviceName.Buffer = pNameIP;
    ucDeviceName.Length = (USHORT) (sizeof (WCHAR) * wcslen (pNameIP));
    ucDeviceName.MaximumLength = ucDeviceName.Length + sizeof (WCHAR);
    
    if (pOutBuffer)
    {
        ASSERT (pOutBufferLen);
        OutBufferLen = *pOutBufferLen;  // Save the initial buffer length
        *pOutBuffer = NULL;
        *pOutBufferLen = 0;     // Initialize the return parameter in case we fail below

        if (!OutBufferLen ||
            !(pIPInfo = PgmAllocMem (OutBufferLen, PGM_TAG('I'))))
        {
            PgmTrace (LogError, ("PgmProcessIPRequest: ERROR -- "  \
                "STATUS_INSUFFICIENT_RESOURCES\n"));

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    InitializeObjectAttributes (&ObjectAttributes,
                                &ucDeviceName,
                                OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL);

    PgmAttachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

    Status = ZwCreateFile (&hIP,
                           SYNCHRONIZE | GENERIC_READ,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           0,
                           FILE_OPEN,
                           0,
                           NULL,
                           0);

    //
    // If we succeeded above, let us also try to create the Event handle
    //
    if ((NT_SUCCESS (Status)) &&
        (!NT_SUCCESS (Status = ZwCreateEvent(&Event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE))))
    {
        ZwClose (hIP);
    }

    if (!NT_SUCCESS (Status))
    {
        PgmDetachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

        PgmTrace (LogError, ("PgmProcessIPRequest: ERROR -- "  \
            "status=<%x> -- ZwCreate\n", Status));

        if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
        return (Status);
    }

    //
    // At this point, we have succeeded in creating the hIP and Event handles,
    // and possibly also the output buffer memory (pIPInfo)
    //
    do
    {
        Status = ZwDeviceIoControlFile(hIP,                 // g_hIPDriverHandle
                                       Event,
                                       NULL,
                                       NULL,
                                       &IoStatusBlock,
                                       IOControlCode,       // Ioctl
                                       pInBuffer,
                                       InBufferLen,
                                       pIPInfo,
                                       OutBufferLen);

        if (Status == STATUS_PENDING)
        {
            Status = NtWaitForSingleObject (Event,  FALSE, NULL);
            ASSERT(Status == STATUS_SUCCESS);
        }

        if (Status == STATUS_BUFFER_OVERFLOW)
        {
            if (!OutBufferLen)
            {
                PgmTrace (LogError, ("PgmProcessIPRequest: ERROR -- "  \
                    "IOControlCode=<%x> => overflow when no data expected\n", IOControlCode));

                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            PgmFreeMem (pIPInfo);
            OutBufferLen *=2;
            if (NULL == (pIPInfo = PgmAllocMem (OutBufferLen, PGM_TAG('I'))))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if ((NT_SUCCESS (Status)) &&
                 (NT_SUCCESS (IoStatusBlock.Status)))
        {
            PgmTrace (LogPath, ("PgmProcessIPRequest:  "  \
                "Success, Ioctl=<%x>\n", IOControlCode));
        }
        else
        {
            PgmTrace (LogError, ("PgmProcessIPRequest: ERROR -- "  \
                "IOCTL=<%x> returned Status=<%x : %x>\n", IOControlCode, Status, IoStatusBlock.Status));
        }
    } while (Status == STATUS_BUFFER_OVERFLOW);

    ZwClose (Event);
    ZwClose (hIP);
    PgmDetachFsp (&ApcState, &fAttached, REF_FSP_PROCESS_IP_REQUEST);

    if (NT_SUCCESS(Status))
    {
        if ((pOutBuffer) && (pOutBufferLen))
        {
            *pOutBuffer = pIPInfo;
            *pOutBufferLen = OutBufferLen;
        }
        else if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
    }
    else
    {
        if (pIPInfo)
        {
            PgmFreeMem (pIPInfo);
        }
    }

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\security.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Security.c

Abstract:

    This module implements various Security routines used by
    the PGM Transport

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "security.tmh"
#endif  // FILE_LOGGING


//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PgmBuildAdminSecurityDescriptor)
#pragma alloc_text(PAGE, PgmGetUserInfo)
#endif
//*******************  Pageable Routine Declarations ****************


//----------------------------------------------------------------------------
NTSTATUS
PgmBuildAdminSecurityDescriptor(
    OUT SECURITY_DESCRIPTOR     **ppSecurityDescriptor
    )
/*++

Routine Description:

    (Lifted from TCP - TcpBuildDeviceAcl)
    This routine builds an ACL which gives Administrators, LocalService and NetworkService
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/
{
    PGENERIC_MAPPING    GenericMapping;
    PSID                pAdminsSid, pServiceSid, pNetworkSid;
    ULONG               AclLength;
    NTSTATUS            Status;
    ACCESS_MASK         AccessMask = GENERIC_ALL;
    PACL                pNewAcl, pAclCopy;
    PSID                pSid;
    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;
    SECURITY_DESCRIPTOR  *pSecurityDescriptor;

    PAGED_CODE();

    if (!(pSid = PgmAllocMem (RtlLengthRequiredSid (3), PGM_TAG('S'))) ||
        (!NT_SUCCESS (Status = RtlInitializeSid (pSid, &Authority, 3))))
    {
        if (pSid)
        {
            PgmFreeMem (pSid);
        }
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    *RtlSubAuthoritySid (pSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
    *RtlSubAuthoritySid (pSid, 1) = DOMAIN_ALIAS_RID_ADMINS;
    *RtlSubAuthoritySid (pSid, 2) = SECURITY_LOCAL_SYSTEM_RID;
    ASSERT (RtlValidSid (pSid));

    AclLength = sizeof(ACL) +
                RtlLengthSid(pSid) +
                sizeof(ACCESS_ALLOWED_ACE) -
                sizeof(ULONG);
    if (!(pNewAcl = PgmAllocMem (AclLength, PGM_TAG('S'))))
    {
        PgmFreeMem (pSid);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl (pNewAcl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status))
    {
        PgmFreeMem (pNewAcl);
        PgmFreeMem (pSid);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce (pNewAcl,
                                     ACL_REVISION,
                                     GENERIC_ALL,
                                     pSid);
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status))
    {
        PgmFreeMem (pNewAcl);
        PgmFreeMem (pSid);
        return (Status);
    }

    if (!(pSecurityDescriptor = PgmAllocMem ((sizeof(SECURITY_DESCRIPTOR) + AclLength), PGM_TAG('S'))))
    {
        PgmFreeMem (pNewAcl);
        PgmFreeMem (pSid);
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    pAclCopy = (PACL) ((PISECURITY_DESCRIPTOR) pSecurityDescriptor+1);
    RtlCopyMemory (pAclCopy, pNewAcl, AclLength);

    Status = RtlCreateSecurityDescriptor (pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS (Status))
    {
        PgmFreeMem (pNewAcl);
        PgmFreeMem (pSid);
        PgmFreeMem (pSecurityDescriptor);
    }

    Status = RtlSetDaclSecurityDescriptor (pSecurityDescriptor, TRUE, pAclCopy, FALSE);
    if (!NT_SUCCESS (Status))
    {
        PgmFreeMem (pNewAcl);
        PgmFreeMem (pSid);
        PgmFreeMem (pSecurityDescriptor);
    }

    PgmFreeMem (pNewAcl);
    PgmFreeMem (pSid);
    *ppSecurityDescriptor = pSecurityDescriptor;

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------
NTSTATUS
PgmGetUserInfo(
    IN  PIRP                        pIrp,
    IN  PIO_STACK_LOCATION          pIrpSp,
    OUT TOKEN_USER                  **ppUserId,
    OUT BOOLEAN                     *pfUserIsAdmin
    )
{
    PACCESS_TOKEN   *pAccessToken = NULL;
    TOKEN_USER      *pUserId = NULL;
    BOOLEAN         fUserIsAdmin = FALSE;
    SECURITY_SUBJECT_CONTEXT    *pSubjectContext;

    PAGED_CODE();

    //
    // Get User ID
    //
    pSubjectContext = &pIrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext;
    pAccessToken = SeQuerySubjectContextToken (pSubjectContext);
    if ((!pAccessToken) ||
        (!NT_SUCCESS (SeQueryInformationToken (pAccessToken, TokenUser, &pUserId))))
    {
        //
        // Cannot get the user token
        //
        *ppUserId = NULL;
        *pfUserIsAdmin = FALSE;
        return (STATUS_UNSUCCESSFUL);
    }

    if (ppUserId)
    {
        *ppUserId = pUserId;
    }
    else
    {
        PgmFreeMem (pUserId);
    }

    if (pfUserIsAdmin)
    {
        *pfUserIsAdmin = SeTokenIsAdmin (pAccessToken);
    }
    return (STATUS_SUCCESS);


/*
    //
    // Got the user SID
    //
    if (!RtlEqualSid (gpSystemSid, pUserId->User.Sid))
    {
        fUserIsAdmin = TRUE;
    }

    PgmFreeMem (pUserId);
    return (fUserIsAdmin);
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\receive.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    Receive.c

Abstract:

    This module implements Receive handlers and other routines
    the PGM Transport and other routines that are specific to the
    NT implementation of a driver.

Author:

    Mohammad Shabbir Alam (MAlam)   3-30-2000

Revision History:

--*/


#include "precomp.h"

#ifdef FILE_LOGGING
#include "receive.tmh"
#endif  // FILE_LOGGING


typedef struct in_pktinfo {
    tIPADDRESS  ipi_addr;       // destination IPv4 address
    UINT        ipi_ifindex;    // received interface index
} IP_PKTINFO;

//*******************  Pageable Routine Declarations ****************
#ifdef ALLOC_PRAGMA
#endif
//*******************  Pageable Routine Declarations ****************


VOID
FreeDataBuffer(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  tPENDING_DATA       *pPendingData
    )
{
    ASSERT (pPendingData->pDataPacket);

    if (pPendingData->PendingDataFlags & PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG)
    {
        ExFreeToNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside, pPendingData->pDataPacket);
        if ((0 == --pReceive->pReceiver->NumDataBuffersFromLookaside) &&
            !(pReceive->SessionFlags & PGM_SESSION_DATA_FROM_LOOKASIDE))
        {
            ASSERT (pReceive->pReceiver->MaxBufferLength > pReceive->pReceiver->DataBufferLookasideLength);
            pReceive->pReceiver->MaxBufferLength += 100;
            pReceive->pReceiver->DataBufferLookasideLength = pReceive->pReceiver->MaxBufferLength;
            pReceive->SessionFlags |= PGM_SESSION_DATA_FROM_LOOKASIDE;

            ExDeleteNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside);

            ASSERT (pReceive->pReceiver->MaxPacketsBufferedInLookaside);
            ExInitializeNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside,
                                             NULL,
                                             NULL,
                                             0,
                                             pReceive->pReceiver->DataBufferLookasideLength,
                                             PGM_TAG ('D'),
                                             pReceive->pReceiver->MaxPacketsBufferedInLookaside);
        }

        pPendingData->PendingDataFlags &= ~PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG;
    }
    else
    {
        PgmFreeMem (pPendingData->pDataPacket);
    }

    pPendingData->pDataPacket = NULL;
    pPendingData->PacketLength = pPendingData->DataOffset = 0;
}

PVOID
AllocateDataBuffer(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  tPENDING_DATA       *pPendingData,
    IN  ULONG               BufferSize
    )
{
    ASSERT (!pPendingData->pDataPacket);
    ASSERT (!(pPendingData->PendingDataFlags & PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG));

    if ((pReceive->SessionFlags & PGM_SESSION_DATA_FROM_LOOKASIDE) &&
        (BufferSize <= pReceive->pReceiver->DataBufferLookasideLength))
    {
        if (pPendingData->pDataPacket = ExAllocateFromNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside))
        {
            pReceive->pReceiver->NumDataBuffersFromLookaside++;
            pPendingData->PendingDataFlags |= PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG;
        }
    }
    else
    {
        pReceive->SessionFlags &= ~PGM_SESSION_DATA_FROM_LOOKASIDE;     // Ensure no more lookaside!
        pPendingData->pDataPacket = PgmAllocMem (BufferSize, PGM_TAG('D'));

        if (BufferSize > pReceive->pReceiver->MaxBufferLength)
        {
            pReceive->pReceiver->MaxBufferLength = BufferSize;
        }
    }

    return (pPendingData->pDataPacket);
}

PVOID
ReAllocateDataBuffer(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  tPENDING_DATA       *pPendingData,
    IN  ULONG               BufferSize
    )
{
    ULONG   SavedFlags1, SavedFlags2;
    PUCHAR  pSavedPacket1, pSavedPacket2;

    //
    // First, save the context for the current buffer
    //
    SavedFlags1 = pPendingData->PendingDataFlags;
    pSavedPacket1 = pPendingData->pDataPacket;
    pPendingData->PendingDataFlags = 0;
    pPendingData->pDataPacket = NULL;

    if (AllocateDataBuffer (pReceive, pPendingData, BufferSize))
    {
        ASSERT (pPendingData->pDataPacket);

        //
        // Now, save the context for the new buffer
        //
        SavedFlags2 = pPendingData->PendingDataFlags;
        pSavedPacket2 = pPendingData->pDataPacket;

        //
        // Free the original buffer
        //
        pPendingData->PendingDataFlags = SavedFlags1;
        pPendingData->pDataPacket = pSavedPacket1;
        FreeDataBuffer (pReceive, pPendingData);

        //
        // Reset the information for the new buffer!
        //
        if (SavedFlags2 & PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG)
        {
            pPendingData->PendingDataFlags = SavedFlags1 | PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG;
        }
        else
        {
            pPendingData->PendingDataFlags = SavedFlags1 & ~PENDING_DATA_LOOKASIDE_ALLOCATION_FLAG;
        }
        pPendingData->pDataPacket = pSavedPacket2;

        return (pPendingData->pDataPacket);
    }

    //
    // Failure case!
    //
    pPendingData->pDataPacket = pSavedPacket1;
    pPendingData->PendingDataFlags = SavedFlags1;

    return (NULL);
}

//----------------------------------------------------------------------------
VOID
RemovePendingIrps(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  LIST_ENTRY          *pIrpsList
    )
{
    PIRP        pIrp;

    if (pIrp = pReceive->pReceiver->pIrpReceive)
    {
        pReceive->pReceiver->pIrpReceive = NULL;

        pIrp->IoStatus.Information = pReceive->pReceiver->BytesInMdl;
        InsertTailList (pIrpsList, &pIrp->Tail.Overlay.ListEntry);
    }

    while (!IsListEmpty (&pReceive->pReceiver->ReceiveIrpsList))
    {
        pIrp = CONTAINING_RECORD (pReceive->pReceiver->ReceiveIrpsList.Flink, IRP, Tail.Overlay.ListEntry);

        RemoveEntryList (&pIrp->Tail.Overlay.ListEntry);
        InsertTailList (pIrpsList, &pIrp->Tail.Overlay.ListEntry);
        pIrp->IoStatus.Information = 0;
    }
}


//----------------------------------------------------------------------------

VOID
FreeNakContext(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tNAK_FORWARD_DATA       *pNak
    )
/*++

Routine Description:

    This routine free's the context used for tracking missing sequences

Arguments:

    IN  pReceive    -- Receive context
    IN  pNak        -- Nak Context to be free'ed

Return Value:

    NONE

--*/
{
    UCHAR   i, j, k, NumPackets;

    //
    // Free any memory for non-parity data
    //
    j = k = 0;
    NumPackets = pNak->NumDataPackets + pNak->NumParityPackets;
    for (i=0; i<NumPackets; i++)
    {
        if (pNak->pPendingData[i].PacketIndex < pReceive->FECGroupSize)
        {
            j++;
        }
        else
        {
            k++;
        }
        FreeDataBuffer (pReceive, &pNak->pPendingData[i]);
    }
    ASSERT (j == pNak->NumDataPackets);
    ASSERT (k == pNak->NumParityPackets);

    //
    // Return the pNak memory based on whether it was allocated
    // from the parity or non-parity lookaside list
    //
    if (pNak->OriginalGroupSize > 1)
    {
        ExFreeToNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside, pNak);
    }
    else
    {
        ExFreeToNPagedLookasideList (&pReceive->pReceiver->NonParityContextLookaside, pNak);
    }
}


//----------------------------------------------------------------------------

VOID
CleanupPendingNaks(
    IN  tRECEIVE_SESSION                *pReceive,
    IN  PVOID                           fDerefReceive,
    IN  PVOID                           fReceiveLockHeld
    )
{
    LIST_ENTRY              NaksList, DataList;
    tNAK_FORWARD_DATA       *pNak;
    LIST_ENTRY              *pEntry;
    ULONG                   NumBufferedData = 0;
    ULONG                   NumNaks = 0;
    PGMLockHandle           OldIrq;

    ASSERT (pReceive->pReceiver);

    if (!fReceiveLockHeld)
    {
        PgmLock (pReceive, OldIrq);
    }
    else
    {
        ASSERT (!fDerefReceive);
    }

    DataList.Flink = pReceive->pReceiver->BufferedDataList.Flink;
    DataList.Blink = pReceive->pReceiver->BufferedDataList.Blink;
    pReceive->pReceiver->BufferedDataList.Flink->Blink = &DataList;
    pReceive->pReceiver->BufferedDataList.Blink->Flink = &DataList;
    InitializeListHead (&pReceive->pReceiver->BufferedDataList);

    NaksList.Flink = pReceive->pReceiver->NaksForwardDataList.Flink;
    NaksList.Blink = pReceive->pReceiver->NaksForwardDataList.Blink;
    pReceive->pReceiver->NaksForwardDataList.Flink->Blink = &NaksList;
    pReceive->pReceiver->NaksForwardDataList.Blink->Flink = &NaksList;
    InitializeListHead (&pReceive->pReceiver->NaksForwardDataList);

    RemoveAllPendingReceiverEntries (pReceive->pReceiver);

    pReceive->pReceiver->NumDataBuffersFromLookaside++;     // So that we don't assert

    if (!fReceiveLockHeld)
    {
        PgmUnlock (pReceive, OldIrq);
    }

    //
    // Cleanup any pending Nak entries
    //
    while (!IsListEmpty (&DataList))
    {
        pEntry = RemoveHeadList (&DataList);
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
        FreeNakContext (pReceive, pNak);
        NumBufferedData++;
    }

    while (!IsListEmpty (&NaksList))
    {
        pEntry = RemoveHeadList (&NaksList);
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

        FreeNakContext (pReceive, pNak);
        NumNaks++;
    }

    PgmTrace (LogStatus, ("CleanupPendingNaks:  "  \
        "pReceive=<%p>, FirstNak=<%d>, NumBufferedData=<%d=%d>, TotalDataPackets=<%d>, NumNaks=<%d * %d>\n",
        pReceive, (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
        (ULONG) pReceive->pReceiver->NumPacketGroupsPendingClient, NumBufferedData,
        (ULONG) pReceive->pReceiver->TotalDataPacketsBuffered, NumNaks, (ULONG) pReceive->FECGroupSize));

//    ASSERT (NumBufferedData == pReceive->pReceiver->NumPacketGroupsPendingClient);
    pReceive->pReceiver->NumPacketGroupsPendingClient = 0;

    if (!fReceiveLockHeld)
    {
        PgmLock (pReceive, OldIrq);
    }

    pReceive->pReceiver->NumDataBuffersFromLookaside--;     // Undoing what we did earlier!
    ASSERT (!pReceive->pReceiver->NumDataBuffersFromLookaside);
    if (pReceive->SessionFlags & PGM_SESSION_DATA_FROM_LOOKASIDE)
    {
        pReceive->pReceiver->MaxBufferLength = 0;
        pReceive->SessionFlags &= ~PGM_SESSION_DATA_FROM_LOOKASIDE;     // Ensure no more lookaside!
        ExDeleteNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside);
    }

    if (pReceive->pReceiver->pReceiveData)
    {
        PgmFreeMem (pReceive->pReceiver->pReceiveData);
        pReceive->pReceiver->pReceiveData = NULL;
    }

    if (!fReceiveLockHeld)
    {
        PgmUnlock (pReceive, OldIrq);

        if (fDerefReceive)
        {
            PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLEANUP_NAKS);
        }
    }
}


//----------------------------------------------------------------------------

BOOLEAN
CheckIndicateDisconnect(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive,
    IN  BOOLEAN             fAddressLockHeld
    )
{
    ULONG                   DisconnectFlag;
    NTSTATUS                status;
    BOOLEAN                 fDisconnectIndicated = FALSE;
    LIST_ENTRY              PendingIrpsList;
    PIRP                    pIrp;
    tNAK_FORWARD_DATA       *pNak;
    SEQ_TYPE                FirstNakSequenceNumber;

    //
    // Don't abort if we are currently indicating, or if we have
    // already aborted!
    //
    fDisconnectIndicated = (pReceive->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED ? TRUE : FALSE);
    if (pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_CLIENT_DISCONNECTED))
    {
        return (fDisconnectIndicated);
    }

    if (IsListEmpty (&pReceive->pReceiver->NaksForwardDataList))
    {
         FirstNakSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber;
    }
    else
    {
        pNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);
        FirstNakSequenceNumber = pNak->SequenceNumber + pNak->NextIndexToIndicate;
    }

    if ((pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT) ||
        ((pReceive->SessionFlags & PGM_SESSION_TERMINATED_GRACEFULLY) &&
         (IsListEmpty (&pReceive->pReceiver->BufferedDataList)) &&
         SEQ_GEQ (FirstNakSequenceNumber, (pReceive->pReceiver->FinDataSequenceNumber+1))))
    {
        //
        // The session has terminated, so let the client know
        //
        if (pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT)
        {
            DisconnectFlag = TDI_DISCONNECT_ABORT;
        }
        else
        {
            DisconnectFlag = TDI_DISCONNECT_RELEASE;
        }

        pReceive->SessionFlags |= (PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_CLIENT_DISCONNECTED);

        InitializeListHead (&PendingIrpsList);
        RemovePendingIrps (pReceive, &PendingIrpsList);

        PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLEANUP_NAKS, TRUE);

        PgmUnlock (pReceive, *pOldIrqReceive);
        if (fAddressLockHeld)
        {
            PgmUnlock (pAddress, *pOldIrqAddress);
        }

        while (!IsListEmpty (&PendingIrpsList))
        {
            pIrp = CONTAINING_RECORD (PendingIrpsList.Flink, IRP, Tail.Overlay.ListEntry);
            PgmCancelCancelRoutine (pIrp);
            RemoveEntryList (&pIrp->Tail.Overlay.ListEntry);

            pIrp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest (pIrp, IO_NETWORK_INCREMENT);
        }

        PgmTrace (LogStatus, ("CheckIndicateDisconnect:  "  \
            "Disconnecting pReceive=<%p:%p>, with %s, FirstNak=<%d>, NextOData=<%d>\n",
                pReceive, pReceive->ClientSessionContext,
                (DisconnectFlag == TDI_DISCONNECT_RELEASE ? "TDI_DISCONNECT_RELEASE":"TDI_DISCONNECT_ABORT"),
                FirstNakSequenceNumber, pReceive->pReceiver->NextODataSequenceNumber));

        status = (*pAddress->evDisconnect) (pAddress->DiscEvContext,
                                            pReceive->ClientSessionContext,
                                            0,
                                            NULL,
                                            0,
                                            NULL,
                                            DisconnectFlag);


        fDisconnectIndicated = TRUE;

        //
        // See if we can Enqueue the Nak cleanup request to a Worker thread
        //
        if (STATUS_SUCCESS != PgmQueueForDelayedExecution (CleanupPendingNaks,
                                                           pReceive,
                                                           (PVOID) TRUE,
                                                           (PVOID) FALSE,
                                                           FALSE))
        {
            CleanupPendingNaks (pReceive, (PVOID) TRUE, (PVOID) FALSE);
        }

        if (fAddressLockHeld)
        {
            PgmLock (pAddress, *pOldIrqAddress);
        }
        PgmLock (pReceive, *pOldIrqReceive);

        pReceive->SessionFlags &= ~PGM_SESSION_FLAG_IN_INDICATE;

        //
        // We may have received a disassociate while disconnecting, so
        // complete the irp here
        //
        if (pIrp = pReceive->pIrpDisassociate)
        {
            pReceive->pIrpDisassociate = NULL;
            PgmUnlock (pReceive, *pOldIrqReceive);
            if (fAddressLockHeld)
            {
                PgmUnlock (pAddress, *pOldIrqAddress);
            }

            PgmIoComplete (pIrp, STATUS_SUCCESS, 0);

            if (fAddressLockHeld)
            {
                PgmLock (pAddress, *pOldIrqAddress);
            }
            PgmLock (pReceive, *pOldIrqReceive);
        }
    }

    return (fDisconnectIndicated);
}


//----------------------------------------------------------------------------

VOID
ProcessNakOption(
    IN  tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader,
    OUT tNAKS_LIST                          *pNaksList
    )
/*++

Routine Description:

    This routine processes the Nak list option in the Pgm packet

Arguments:

    IN  pOptionHeader       -- The Nak List option ptr
    OUT pNaksList           -- The parameters extracted (i.e. list of Nak sequences)

Return Value:

    NONE

--*/
{
    UCHAR       i, NumNaks;
    ULONG       pPacketNaks[MAX_SEQUENCES_PER_NAK_OPTION];

    NumNaks = (pOptionHeader->OptionLength - 4) / 4;
    ASSERT (NumNaks <= MAX_SEQUENCES_PER_NAK_OPTION);

    PgmCopyMemory (pPacketNaks, (pOptionHeader + 1), (pOptionHeader->OptionLength - 4));
    for (i=0; i < NumNaks; i++)
    {
        //
        // Do not fill in the 0th entry, since that is from the packet header itself
        //
        pNaksList->pNakSequences[i+1] = (SEQ_TYPE) ntohl (pPacketNaks[i]);
    }
    pNaksList->NumSequences = (USHORT) i;
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessOptions(
    IN  tPACKET_OPTION_LENGTH UNALIGNED *pPacketExtension,
    IN  ULONG                           BytesAvailable,
    IN  ULONG                           PacketType,
    OUT tPACKET_OPTIONS                 *pPacketOptions,
    OUT tNAKS_LIST                      *pNaksList
    )
/*++

Routine Description:

    This routine processes the options fields on an incoming Pgm packet
    and returns the options information extracted in the OUT parameters

Arguments:

    IN  pPacketExtension    -- Options section of the packet
    IN  BytesAvailable      -- from the start of the options
    IN  PacketType          -- Whether Data or Spm packet, etc
    OUT pPacketOptions      -- Structure containing the parameters from the options

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    tPACKET_OPTION_GENERIC UNALIGNED    *pOptionHeader;
    ULONG                               BytesLeft = BytesAvailable;
    UCHAR                               i;
    ULONG                               MessageFirstSequence, MessageLength, MessageOffset;
    ULONG                               pOptionsData[3];
    ULONG                               OptionsFlags = 0;
    ULONG                               NumOptionsProcessed = 0;
    USHORT                              TotalOptionsLength = 0;
    NTSTATUS                            status = STATUS_UNSUCCESSFUL;

    pPacketOptions->OptionsLength = 0;      // Init
    pPacketOptions->OptionsFlags = 0;       // Init

    if (BytesLeft > sizeof(tPACKET_OPTION_LENGTH))
    {
        PgmCopyMemory (&TotalOptionsLength, &pPacketExtension->TotalOptionsLength, sizeof (USHORT));
        TotalOptionsLength = ntohs (TotalOptionsLength);
    }

    //
    // First process the Option extension
    //
    if ((BytesLeft < ((sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC)))) || // Ext+opt
        (pPacketExtension->Type != PACKET_OPTION_LENGTH) ||
        (pPacketExtension->Length != 4) ||
        (BytesLeft < TotalOptionsLength))       // Verify length
    {
        //
        // Need to get at least our header from transport!
        //
        PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
            "BytesLeft=<%d> < Min=<%d>, TotalOptionsLength=<%d>, ExtLength=<%d>, ExtType=<%x>\n",
                BytesLeft, ((sizeof(tPACKET_OPTION_LENGTH) + sizeof(tPACKET_OPTION_GENERIC))),
                (ULONG) TotalOptionsLength, pPacketExtension->Length, pPacketExtension->Type));

        return (status);
    }

    //
    // Now, process each option
    //
    pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *) (pPacketExtension + 1);
    BytesLeft -= sizeof(tPACKET_OPTION_LENGTH);
    NumOptionsProcessed = 0;
    status = STATUS_SUCCESS;            // By default

    do
    {
        if (pOptionHeader->OptionLength > BytesLeft)
        {
            PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                "Incorrectly formatted Options: OptionLength=<%d> > BytesLeft=<%d>, NumProcessed=<%d>\n",
                    pOptionHeader->OptionLength, BytesLeft, NumOptionsProcessed));

            status = STATUS_UNSUCCESSFUL;
            break;
        }

        switch (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT)
        {
            case (PACKET_OPTION_NAK_LIST):
            {
                if (((PacketType == PACKET_TYPE_NAK) ||
                     (PacketType == PACKET_TYPE_NCF) ||
                     (PacketType == PACKET_TYPE_NNAK)) &&
                    ((pOptionHeader->OptionLength >= PGM_PACKET_OPT_MIN_NAK_LIST_LENGTH) &&
                     (pOptionHeader->OptionLength <= PGM_PACKET_OPT_MAX_NAK_LIST_LENGTH)))
                {
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "NAK_LIST:  Num Naks=<%d>\n", (pOptionHeader->OptionLength-4)/4));

                    if (!pNaksList)
                    {
                        ASSERT (0);
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }

                    ProcessNakOption (pOptionHeader, pNaksList);
                    OptionsFlags |= PGM_OPTION_FLAG_NAK_LIST;
                }
                else
                {
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "NAK_LIST:  PacketType=<%x>, Length=<0x%x>, pPacketOptions=<%p>\n",
                            PacketType, pOptionHeader->OptionLength, pPacketOptions));

                    status = STATUS_UNSUCCESSFUL;
                }

                break;
            }

/*
// Not supported for now!
            case (PACKET_OPTION_REDIRECT):
            {
                ASSERT (pOptionHeader->OptionLength > 4);     // 4 + sizeof(NLA)
                break;
            }
*/

            case (PACKET_OPTION_FRAGMENT):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_FRAGMENT_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), (3 * sizeof(ULONG)));
                    if (pOptionHeader->Reserved_F_Opx & PACKET_OPTION_RES_F_OPX_ENCODED_BIT)
                    {
                        pPacketOptions->MessageFirstSequence = pOptionsData[0];
                        pPacketOptions->MessageOffset = pOptionsData[1];
                        pPacketOptions->MessageLength = pOptionsData[2];
                        pPacketOptions->FECContext.FragmentOptSpecific = pOptionHeader->U_OptSpecific;

                        OptionsFlags |= PGM_OPTION_FLAG_FRAGMENT;
                    }
                    else
                    {
                        MessageFirstSequence = ntohl (pOptionsData[0]);
                        MessageOffset = ntohl (pOptionsData[1]);
                        MessageLength = ntohl (pOptionsData[2]);
                        if ((MessageLength) && (MessageOffset <= MessageLength))
                        {
                            PgmTrace (LogPath, ("ProcessOptions:  "  \
                                "FRAGMENT:  MsgOffset/Length=<%d/%d>\n", MessageOffset, MessageLength));

                            if (pPacketOptions)
                            {
                                pPacketOptions->MessageFirstSequence = MessageFirstSequence;
                                pPacketOptions->MessageOffset = MessageOffset;
                                pPacketOptions->MessageLength = MessageLength;
//                                pPacketOptions->FECContext.FragmentOptSpecific = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
                            }

                            OptionsFlags |= PGM_OPTION_FLAG_FRAGMENT;
                        }
                        else
                        {
                            PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                                "FRAGMENT:  MsgOffset/Length=<%d/%d>\n", MessageOffset, MessageLength));
                            status = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
                else
                {
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "FRAGMENT:  OptionLength=<%d> != PGM_PACKET_OPT_FRAGMENT_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_FRAGMENT_LENGTH));
                    status = STATUS_UNSUCCESSFUL;
                }

                break;
            }

            case (PACKET_OPTION_JOIN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_JOIN_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "JOIN:  LateJoinerSeq=<%d>\n", ntohl (pOptionsData[0])));

                    if (pPacketOptions)
                    {
                        pPacketOptions->LateJoinerSequence = ntohl (pOptionsData[0]);
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_JOIN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "JOIN:  OptionLength=<%d> != PGM_PACKET_OPT_JOIN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_JOIN_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_SYN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_SYN_LENGTH)
                {
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "SYN\n"));

                    OptionsFlags |= PGM_OPTION_FLAG_SYN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "SYN:  OptionLength=<%d> != PGM_PACKET_OPT_SYN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_SYN_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_FIN):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_FIN_LENGTH)
                {
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "FIN\n"));

                    OptionsFlags |= PGM_OPTION_FLAG_FIN;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "FIN:  OptionLength=<%d> != PGM_PACKET_OPT_FIN_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_FIN_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_RST):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_RST_LENGTH)
                {
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "RST\n"));

                    OptionsFlags |= PGM_OPTION_FLAG_RST;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "RST:  OptionLength=<%d> != PGM_PACKET_OPT_RST_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_RST_LENGTH));
                }

                break;
            }

            //
            // FEC options
            //
            case (PACKET_OPTION_PARITY_PRM):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_PRM_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "PARITY_PRM:  OptionsSpecific=<%x>, FECGroupInfo=<%d>\n",
                            pOptionHeader->U_OptSpecific, ntohl (pOptionsData[0])));

                    if (pPacketOptions)
                    {
                        pOptionsData[0] = ntohl (pOptionsData[0]);
                        ASSERT (((UCHAR) pOptionsData[0]) == pOptionsData[0]);
                        pPacketOptions->FECContext.ReceiverFECOptions = pOptionHeader->U_OptSpecific;
                        pPacketOptions->FECContext.FECGroupInfo = (UCHAR) pOptionsData[0];
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_PARITY_PRM;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "PARITY_PRM:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_PRM_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_PRM_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_PARITY_GRP):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_GRP_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    PgmTrace (LogPath, ("ProcessOptions:  "  \
                        "PARITY_GRP:  FECGroupInfo=<%d>\n",
                            ntohl (pOptionsData[0])));

                    if (pPacketOptions)
                    {
                        pOptionsData[0] = ntohl (pOptionsData[0]);
                        ASSERT (((UCHAR) pOptionsData[0]) == pOptionsData[0]);
                        pPacketOptions->FECContext.FECGroupInfo = (UCHAR) pOptionsData[0];
                    }

                    OptionsFlags |= PGM_OPTION_FLAG_PARITY_GRP;
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "PARITY_GRP:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_GRP_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_GRP_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_CURR_TGSIZE):
            {
                if (pOptionHeader->OptionLength == PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH)
                {
                    PgmCopyMemory (pOptionsData, (pOptionHeader + 1), sizeof(ULONG));
                    if (pOptionsData[0])
                    {
                        PgmTrace (LogPath, ("ProcessOptions:  "  \
                            "CURR_TGSIZE:  NumPacketsInThisGroup=<%d>\n",
                                ntohl (pOptionsData[0])));

                        if (pPacketOptions)
                        {
                            pPacketOptions->FECContext.NumPacketsInThisGroup = (UCHAR) (ntohl (pOptionsData[0]));
                        }

                        OptionsFlags |= PGM_OPTION_FLAG_PARITY_CUR_TGSIZE;
                    }
                    else
                    {
                        PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                            "CURR_TGSIZE:  NumPacketsInThisGroup=<%d>\n", ntohl (pOptionsData[0])));
                        status = STATUS_UNSUCCESSFUL;
                    }
                }
                else
                {
                    status = STATUS_UNSUCCESSFUL;
                    PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                        "PARITY_GRP:  OptionLength=<%d> != PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH=<%d>\n",
                            pOptionHeader->OptionLength, PGM_PACKET_OPT_PARITY_CUR_TGSIZE_LENGTH));
                }

                break;
            }

            case (PACKET_OPTION_REDIRECT):
            case (PACKET_OPTION_CR):
            case (PACKET_OPTION_CRQST):
            case (PACKET_OPTION_NAK_BO_IVL):
            case (PACKET_OPTION_NAK_BO_RNG):
            case (PACKET_OPTION_NBR_UNREACH):
            case (PACKET_OPTION_PATH_NLA):
            case (PACKET_OPTION_INVALID):
            {
                PgmTrace (LogStatus, ("ProcessOptions:  "  \
                    "WARNING:  PacketType=<%x>:  Unhandled Option=<%x>, OptionLength=<%d>\n",
                        PacketType, (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT), pOptionHeader->OptionLength));

                OptionsFlags |= PGM_OPTION_FLAG_UNRECOGNIZED;
                break;
            }

            default:
            {
                PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                    "PacketType=<%x>:  Unrecognized Option=<%x>, OptionLength=<%d>\n",
                        PacketType, (pOptionHeader->E_OptionType & ~PACKET_OPTION_TYPE_END_BIT), pOptionHeader->OptionLength));
                ASSERT (0);     // We do not recognize this option, but we will continue anyway!

                OptionsFlags |= PGM_OPTION_FLAG_UNRECOGNIZED;
                status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

        if (!NT_SUCCESS (status))
        {
            break;
        }

        NumOptionsProcessed++;
        BytesLeft -= pOptionHeader->OptionLength;

        if (pOptionHeader->E_OptionType & PACKET_OPTION_TYPE_END_BIT)
        {
            break;
        }

        pOptionHeader = (tPACKET_OPTION_GENERIC UNALIGNED *)
                            (((UCHAR *) pOptionHeader) + pOptionHeader->OptionLength);

    } while (BytesLeft >= sizeof(tPACKET_OPTION_GENERIC));

    ASSERT (NT_SUCCESS (status));
    if (NT_SUCCESS (status))
    {
        if ((BytesLeft + TotalOptionsLength) == BytesAvailable)
        {
            pPacketOptions->OptionsLength = TotalOptionsLength;
            pPacketOptions->OptionsFlags = OptionsFlags;
        }
        else
        {
            PgmTrace (LogError, ("ProcessOptions: ERROR -- "  \
                "BytesLeft=<%d> + TotalOptionsLength=<%d> != BytesAvailable=<%d>\n",
                    BytesLeft, TotalOptionsLength, BytesAvailable));

            status = STATUS_INVALID_BUFFER_SIZE;
        }
    }

    PgmTrace (LogAllFuncs, ("ProcessOptions:  "  \
        "Processed <%d> options, TotalOptionsLength=<%d>\n", NumOptionsProcessed, TotalOptionsLength));

    return (status);
}


//----------------------------------------------------------------------------

ULONG
AdjustReceiveBufferLists(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    tNAK_FORWARD_DATA           *pNak;
    UCHAR                       TotalPackets, i;
    ULONG                       NumMoved = 0;
    ULONG                       DataPacketsMoved = 0;

    //
    // Update the last consumed time if we did not have any data buffered prior
    // to this
    //
    if (IsListEmpty (&pReceive->pReceiver->BufferedDataList))
    {
        pReceive->pReceiver->LastDataConsumedTime = PgmDynamicConfig.ReceiversTimerTickCount;
    }

    //
    // Assume we have no Naks pending
    //
    pReceive->pReceiver->FirstNakSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber
                                                  + pReceive->FECGroupSize;
    while (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList))
    {
        //
        // Move any Naks contexts for which the group is complete
        // to the BufferedDataList
        //
        pNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);
        if (((pNak->NumDataPackets + pNak->NumParityPackets) < pNak->PacketsInGroup) &&
            ((pNak->NextIndexToIndicate + pNak->NumDataPackets) < pNak->PacketsInGroup))
        {
            pReceive->pReceiver->FirstNakSequenceNumber = pNak->SequenceNumber;
            break;
        }

        //
        // If this is a partial group with extraneous parity packets,
        // remove the parity packets
        //
        if ((pNak->NextIndexToIndicate) &&
            (pNak->NumParityPackets) &&
            ((pNak->NextIndexToIndicate + pNak->NumDataPackets) >= pNak->PacketsInGroup))
        {
            //
            // Start from the end and go backwards
            //
            i = TotalPackets = pNak->NumDataPackets + pNak->NumParityPackets;
            while (i && pNak->NumParityPackets)
            {
                i--;    // Convert from packet # to index
                if (pNak->pPendingData[i].PacketIndex >= pNak->OriginalGroupSize)
                {
                    PgmTrace (LogAllFuncs, ("AdjustReceiveBufferLists:  "  \
                        "Extraneous parity [%d] -- NextIndex=<%d>, Data=<%d>, Parity=<%d>, PktsInGrp=<%d>\n",
                            i, (ULONG) pNak->NextIndexToIndicate, (ULONG) pNak->NumDataPackets,
                            (ULONG) pNak->NumParityPackets, (ULONG) pNak->PacketsInGroup));

                    FreeDataBuffer (pReceive, &pNak->pPendingData[i]);
                    if (i != (TotalPackets - 1))
                    {
                        PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                    }
                    PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                    pNak->NumParityPackets--;

                    TotalPackets--;

                    pReceive->pReceiver->DataPacketsPendingNaks--;
                    pReceive->pReceiver->TotalDataPacketsBuffered--;
                }
            }

            //
            // Re-Init all the indices
            //
            for (i=0; i<pNak->OriginalGroupSize; i++)
            {
                pNak->pPendingData[i].ActualIndexOfDataPacket = pNak->OriginalGroupSize;
            }

            //
            // Set the indices only for the data packets
            //
            for (i=0; i<TotalPackets; i++)
            {
                if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
                {
                    pNak->pPendingData[pNak->pPendingData[i].PacketIndex].ActualIndexOfDataPacket = i;
                }
            }
        }

        RemoveEntryList (&pNak->Linkage);
        InsertTailList (&pReceive->pReceiver->BufferedDataList, &pNak->Linkage);
        NumMoved++;
        DataPacketsMoved += (pNak->NumDataPackets + pNak->NumParityPackets);
    }

    pReceive->pReceiver->NumPacketGroupsPendingClient += NumMoved;
    pReceive->pReceiver->DataPacketsPendingIndicate += DataPacketsMoved;
    pReceive->pReceiver->DataPacketsPendingNaks -= DataPacketsMoved;

    ASSERT (pReceive->pReceiver->TotalDataPacketsBuffered == (pReceive->pReceiver->DataPacketsPendingIndicate +
                                                              pReceive->pReceiver->DataPacketsPendingNaks));

    return (NumMoved);
}


//----------------------------------------------------------------------------

VOID
AdjustNcfRDataResponseTimes(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  PNAK_FORWARD_DATA       pLastNak
    )
{
    ULONGLONG               NcfRDataTickCounts;

    NcfRDataTickCounts = PgmDynamicConfig.ReceiversTimerTickCount - pLastNak->FirstNcfTickCount;
    pReceive->pReceiver->StatSumOfNcfRDataTicks += NcfRDataTickCounts;
    pReceive->pReceiver->NumNcfRDataTicksSamples++;
    if (!pReceive->pReceiver->NumNcfRDataTicksSamples)
    {
        //
        // This will be the divisor below, so it has to be non-zero!
        //
        ASSERT (0);
        return;
    }

    if ((NcfRDataTickCounts > pReceive->pReceiver->MaxOutstandingNakTimeout) &&
        (pReceive->pReceiver->MaxOutstandingNakTimeout !=
         pReceive->pReceiver->MaxRDataResponseTCFromWindow))
    {
        if (pReceive->pReceiver->MaxRDataResponseTCFromWindow &&
            NcfRDataTickCounts > pReceive->pReceiver->MaxRDataResponseTCFromWindow)
        {
            pReceive->pReceiver->MaxOutstandingNakTimeout = pReceive->pReceiver->MaxRDataResponseTCFromWindow;
        }
        else
        {
            pReceive->pReceiver->MaxOutstandingNakTimeout = NcfRDataTickCounts;
        }

        //
        // Since we just updated the Max value, we should also
        // recalculate the default timeout
        //
        pReceive->pReceiver->AverageNcfRDataResponseTC = pReceive->pReceiver->StatSumOfNcfRDataTicks /
                                                         pReceive->pReceiver->NumNcfRDataTicksSamples;
        NcfRDataTickCounts = (pReceive->pReceiver->AverageNcfRDataResponseTC +
                              pReceive->pReceiver->MaxOutstandingNakTimeout) >> 1;
        if (NcfRDataTickCounts > (pReceive->pReceiver->AverageNcfRDataResponseTC << 1))
        {
            NcfRDataTickCounts = pReceive->pReceiver->AverageNcfRDataResponseTC << 1;
        }

        if (NcfRDataTickCounts > pReceive->pReceiver->OutstandingNakTimeout)
        {
            pReceive->pReceiver->OutstandingNakTimeout = NcfRDataTickCounts;
        }
    }
}


//----------------------------------------------------------------------------
VOID
UpdateSpmIntervalInformation(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    ULONG   LastIntervalTickCount = (ULONG) (PgmDynamicConfig.ReceiversTimerTickCount -
                                             pReceive->pReceiver->LastSpmTickCount);

    if (!LastIntervalTickCount)
    {
        return;
    }

    pReceive->pReceiver->LastSpmTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
    if (LastIntervalTickCount > pReceive->pReceiver->MaxSpmInterval)
    {
        pReceive->pReceiver->MaxSpmInterval = LastIntervalTickCount;
    }

/*
    if (pReceive->pReceiver->NumSpmIntervalSamples)
    {
        pReceive->pReceiver->StatSumOfSpmIntervals += pReceive->pReceiver->LastSpmTickCount;
        pReceive->pReceiver->NumSpmIntervalSamples++;
        pReceive->pReceiver->AverageSpmInterval = pReceive->pReceiver->StatSumOfSpmIntervals /
                                                  pReceive->pReceiver->NumSpmIntervalSamples;
    }
*/
}

//----------------------------------------------------------------------------


VOID
UpdateRealTimeWindowInformation(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  SEQ_TYPE                LeadingEdgeSeqNumber,
    IN  SEQ_TYPE                TrailingEdgeSeqNumber
    )
{
    tRECEIVE_CONTEXT    *pReceiver = pReceive->pReceiver;
    SEQ_TYPE            SequencesInWindow = 1 + LeadingEdgeSeqNumber - TrailingEdgeSeqNumber;

    if (SEQ_GT (SequencesInWindow, pReceiver->MaxSequencesInWindow))
    {
        pReceiver->MaxSequencesInWindow = SequencesInWindow;
    }

    if (TrailingEdgeSeqNumber)
    {
        if ((!pReceiver->MinSequencesInWindow) ||
            SEQ_LT (SequencesInWindow, pReceiver->MinSequencesInWindow))
        {
            pReceiver->MinSequencesInWindow = SequencesInWindow;
        }

        pReceiver->StatSumOfWindowSeqs += SequencesInWindow;
        pReceiver->NumWindowSamples++;
    }
}

VOID
UpdateSampleTimeWindowInformation(
    IN  tRECEIVE_SESSION        *pReceive
    )
{
    ULONGLONG           NcfRDataTimeout;
    tRECEIVE_CONTEXT    *pReceiver = pReceive->pReceiver;

    //
    // No need to update if there is no data
    //
    if (!pReceive->MaxRateKBitsPerSec ||
        !pReceive->TotalPacketsReceived)          // Avoid divide by 0 error
    {
        return;
    }

    //
    // Now, update the window information
    //
    if (pReceiver->NumWindowSamples)
    {
        pReceiver->AverageSequencesInWindow = pReceiver->StatSumOfWindowSeqs /
                                              pReceiver->NumWindowSamples;
    }

    if (pReceiver->AverageSequencesInWindow)
    {
        pReceiver->WindowSizeLastInMSecs = ((pReceiver->AverageSequencesInWindow *
                                             pReceive->TotalBytes) << LOG2_BITS_PER_BYTE) /
                                           (pReceive->TotalPacketsReceived *
                                            pReceive->MaxRateKBitsPerSec);
    }
    else
    {
        pReceiver->WindowSizeLastInMSecs = ((pReceiver->MaxSequencesInWindow *
                                             pReceive->TotalBytes) << LOG2_BITS_PER_BYTE) /
                                           (pReceive->TotalPacketsReceived *
                                            pReceive->MaxRateKBitsPerSec);
    }
    pReceiver->MaxRDataResponseTCFromWindow = pReceiver->WindowSizeLastInMSecs /
                                              (NCF_WAITING_RDATA_MAX_RETRIES * BASIC_TIMER_GRANULARITY_IN_MSECS);

    PgmTrace (LogPath, ("UpdateSampleTimeWindowInformation:  "  \
        "pReceive=<%p>, MaxRate=<%I64d>, AvgSeqsInWindow=<%I64d>, WinSzinMSecsLast=<%I64d>\n",
            pReceive, pReceive->MaxRateKBitsPerSec, pReceiver->AverageSequencesInWindow, pReceiver->WindowSizeLastInMSecs));

    //
    // Now, update the NcfRData timeout information
    //
    if (pReceiver->StatSumOfNcfRDataTicks &&
        pReceiver->NumNcfRDataTicksSamples)
    {
        pReceiver->AverageNcfRDataResponseTC = pReceiver->StatSumOfNcfRDataTicks /
                                               pReceiver->NumNcfRDataTicksSamples;
    }

    if (pReceiver->AverageNcfRDataResponseTC)
    {
        NcfRDataTimeout = (pReceiver->AverageNcfRDataResponseTC +
                           pReceiver->MaxOutstandingNakTimeout) >> 1;
        if (NcfRDataTimeout > (pReceiver->AverageNcfRDataResponseTC << 1))
        {
            NcfRDataTimeout = pReceiver->AverageNcfRDataResponseTC << 1;
        }
        if (NcfRDataTimeout >
            pReceiver->InitialOutstandingNakTimeout/BASIC_TIMER_GRANULARITY_IN_MSECS)
        {
            pReceiver->OutstandingNakTimeout = NcfRDataTimeout;
        }
        else
        {
            pReceiver->OutstandingNakTimeout = pReceiver->InitialOutstandingNakTimeout /
                                               BASIC_TIMER_GRANULARITY_IN_MSECS;
        }
    }
}


//----------------------------------------------------------------------------
VOID
RemoveRedundantNaks(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tNAK_FORWARD_DATA       *pNak,
    IN  BOOLEAN                 fEliminateExtraParityPackets
    )
{
    UCHAR   i, TotalPackets;

    ASSERT (fEliminateExtraParityPackets || !pNak->NumParityPackets);
    TotalPackets = pNak->NumDataPackets + pNak->NumParityPackets;

    //
    // First, eliminate the NULL Packets
    //
    if (pNak->PacketsInGroup < pNak->OriginalGroupSize)
    {
        i = 0;
        while (i < pNak->OriginalGroupSize)
        {
            if ((pNak->pPendingData[i].PacketIndex < pNak->PacketsInGroup) ||       // Non-NULL Data packet
                (pNak->pPendingData[i].PacketIndex >= pNak->OriginalGroupSize))     // Parity packet
            {
                //
                // Ignore for now!
                //
                i++;
                continue;
            }

            FreeDataBuffer (pReceive, &pNak->pPendingData[i]);
            if (i != (TotalPackets-1))
            {
                PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
            }
            PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
            pNak->NumDataPackets--;
            TotalPackets--;
        }
        ASSERT (pNak->NumDataPackets <= TotalPackets);

        if (fEliminateExtraParityPackets)
        {
            //  
            // If we still have extra parity packets, free those also
            //
            i = 0;
            while ((i < TotalPackets) &&
                   (TotalPackets > pNak->PacketsInGroup))
            {
                ASSERT (pNak->NumParityPackets);
                if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
                {
                    //
                    // Ignore data packets
                    //
                    i++;
                    continue;
                }

                FreeDataBuffer (pReceive, &pNak->pPendingData[i]);
                if (i != (TotalPackets-1))
                {
                    PgmCopyMemory (&pNak->pPendingData[i], &pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                }
                PgmZeroMemory (&pNak->pPendingData[TotalPackets-1], sizeof (tPENDING_DATA));
                pNak->NumParityPackets--;
                TotalPackets--;
            }

            ASSERT (TotalPackets <= pNak->PacketsInGroup);
        }
    }

    //
    // Re-Init all the indices
    //
    for (i=0; i<pNak->OriginalGroupSize; i++)
    {
        pNak->pPendingData[i].ActualIndexOfDataPacket = pNak->OriginalGroupSize;
    }

    //
    // Set the indices only for the data packets
    //
    for (i=0; i<TotalPackets; i++)
    {
        if (pNak->pPendingData[i].PacketIndex < pNak->OriginalGroupSize)
        {
            pNak->pPendingData[pNak->pPendingData[i].PacketIndex].ActualIndexOfDataPacket = i;
        }
    }

    if ((fEliminateExtraParityPackets) &&
        (((pNak->NumDataPackets + pNak->NumParityPackets) >= pNak->PacketsInGroup) ||
         ((pNak->NextIndexToIndicate + pNak->NumDataPackets) >= pNak->PacketsInGroup)))
    {
        RemovePendingReceiverEntry (pNak);
    }
}


//----------------------------------------------------------------------------

VOID
PgmSendNakCompletion(
    IN  tRECEIVE_SESSION                *pReceive,
    IN  tNAK_CONTEXT                    *pNakContext,
    IN  NTSTATUS                        status
    )
/*++

Routine Description:

    This is the Completion routine called by IP on completing a NakSend

Arguments:

    IN  pReceive    -- Receive context
    IN  pNakContext -- Nak Context to be free'ed
    IN  status      -- status of send from tansport

Return Value:

    NONE

--*/
{
    PGMLockHandle               OldIrq;

    PgmLock (pReceive, OldIrq);
    if (NT_SUCCESS (status))
    {
        //
        // Set the Receiver Nak statistics
        //
        PgmTrace (LogAllFuncs, ("PgmSendNakCompletion:  "  \
            "SUCCEEDED\n"));
    }
    else
    {
        PgmTrace (LogError, ("PgmSendNakCompletion: ERROR -- "  \
            "status=<%x>\n", status));
    }

    if (!(--pNakContext->RefCount))
    {
        PgmUnlock (pReceive, OldIrq);

        //
        // Free the Memory and deref the Session context for this Nak
        //
        PgmFreeMem (pNakContext);
        PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_SEND_NAK);
    }
    else
    {
        PgmUnlock (pReceive, OldIrq);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
PgmSendNak(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tNAKS_CONTEXT           *pNakSequences
    )
/*++

Routine Description:

    This routine sends a Nak packet with the number of sequences specified

Arguments:

    IN  pReceive        -- Receive context
    IN  pNakSequences   -- List of Sequence #s

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    tBASIC_NAK_NCF_PACKET_HEADER    *pNakPacket;
    tNAK_CONTEXT                    *pNakContext;
    tPACKET_OPTION_LENGTH           *pPacketExtension;
    tPACKET_OPTION_GENERIC          *pOptionHeader;
    ULONG                           i;
    ULONG                           XSum;
    USHORT                          OptionsLength = 0;
    NTSTATUS                        status;

    if ((!pNakSequences->NumSequences) ||
        (pNakSequences->NumSequences > (MAX_SEQUENCES_PER_NAK_OPTION+1)) ||
        (!(pNakContext = PgmAllocMem ((2*sizeof(ULONG)+PGM_MAX_NAK_NCF_HEADER_LENGTH), PGM_TAG('2')))))
    {
        PgmTrace (LogError, ("PgmSendNak: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pNakContext\n"));
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
    PgmZeroMemory (pNakContext, (2*sizeof(ULONG)+PGM_MAX_NAK_NCF_HEADER_LENGTH));

    pNakContext->RefCount = 2;              // 1 for the unicast, and the other for the MCast Nak
    pNakPacket = &pNakContext->NakPacket;
    pNakPacket->CommonHeader.SrcPort = htons (pReceive->pReceiver->ListenMCastPort);
    pNakPacket->CommonHeader.DestPort = htons (pReceive->TSI.hPort);
    pNakPacket->CommonHeader.Type = PACKET_TYPE_NAK;

    if (pNakSequences->NakType == NAK_TYPE_PARITY)
    {
        pNakPacket->CommonHeader.Options = PACKET_HEADER_OPTIONS_PARITY;
        pReceive->pReceiver->TotalParityNaksSent += pNakSequences->NumSequences;
    }
    else
    {
        pNakPacket->CommonHeader.Options = 0;
        pReceive->pReceiver->TotalSelectiveNaksSent += pNakSequences->NumSequences;
    }
    PgmCopyMemory (&pNakPacket->CommonHeader.gSourceId, pReceive->TSI.GSI, SOURCE_ID_LENGTH);

    pNakPacket->RequestedSequenceNumber = htonl ((ULONG) pNakSequences->Sequences[0]);
    pNakPacket->SourceNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pNakPacket->SourceNLA.IpAddress = htonl (pReceive->pReceiver->SenderIpAddress);
    pNakPacket->MCastGroupNLA.NLA_AFI = htons (IPV4_NLA_AFI);
    pNakPacket->MCastGroupNLA.IpAddress = htonl (pReceive->pReceiver->ListenMCastIpAddress);

    PgmTrace (LogPath, ("PgmSendNak:  "  \
        "Sending Naks for:\n\t[%d]\n", (ULONG) pNakSequences->Sequences[0]));

    if (pNakSequences->NumSequences > 1)
    {
        pPacketExtension = (tPACKET_OPTION_LENGTH *) (pNakPacket + 1);
        pPacketExtension->Type = PACKET_OPTION_LENGTH;
        pPacketExtension->Length = PGM_PACKET_EXTENSION_LENGTH;
        OptionsLength += PGM_PACKET_EXTENSION_LENGTH;

        pOptionHeader = (tPACKET_OPTION_GENERIC *) (pPacketExtension + 1);
        pOptionHeader->E_OptionType = PACKET_OPTION_NAK_LIST;
        pOptionHeader->OptionLength = 4 + (UCHAR) ((pNakSequences->NumSequences-1) * sizeof(ULONG));
        for (i=1; i<pNakSequences->NumSequences; i++)
        {
            PgmTrace (LogPath, ("PgmSendNak:  "  \
                "\t[%d]\n", (ULONG) pNakSequences->Sequences[i]));

            ((PULONG) (pOptionHeader))[i] = htonl ((ULONG) pNakSequences->Sequences[i]);
        }

        pOptionHeader->E_OptionType |= PACKET_OPTION_TYPE_END_BIT;    // One and only (last) opt
        pNakPacket->CommonHeader.Options |=(PACKET_HEADER_OPTIONS_PRESENT |
                                            PACKET_HEADER_OPTIONS_NETWORK_SIGNIFICANT);
        OptionsLength = PGM_PACKET_EXTENSION_LENGTH + pOptionHeader->OptionLength;
        pPacketExtension->TotalOptionsLength = htons (OptionsLength);
    }

    OptionsLength += sizeof(tBASIC_NAK_NCF_PACKET_HEADER);  // Now is whole pkt
    pNakPacket->CommonHeader.Checksum = 0;
    XSum = 0;
    XSum = tcpxsum (XSum, (CHAR *) pNakPacket, OptionsLength); 
    pNakPacket->CommonHeader.Checksum = (USHORT) (~XSum);

    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_SEND_NAK, FALSE);

    //
    // First multicast the Nak
    //
    status = TdiSendDatagram (pReceive->pReceiver->pAddress->pFileObject,
                              pReceive->pReceiver->pAddress->pDeviceObject,
                              pNakPacket,
                              OptionsLength,
                              PgmSendNakCompletion,     // Completion
                              pReceive,                 // Context1
                              pNakContext,              // Context2
                              pReceive->pReceiver->ListenMCastIpAddress,
                              pReceive->pReceiver->ListenMCastPort,
                              FALSE);

    ASSERT (NT_SUCCESS (status));

    //
    // Now, Unicast the Nak
    //
    status = TdiSendDatagram (pReceive->pReceiver->pAddress->pFileObject,
                              pReceive->pReceiver->pAddress->pDeviceObject,
                              pNakPacket,
                              OptionsLength,
                              PgmSendNakCompletion,     // Completion
                              pReceive,                 // Context1
                              pNakContext,              // Context2
                              pReceive->pReceiver->LastSpmSource,
                              IPPROTO_RM,
                              FALSE);

    ASSERT (NT_SUCCESS (status));

    PgmTrace (LogAllFuncs, ("PgmSendNak:  "  \
        "Sent %s Nak for <%d> Sequences [%d--%d] to <%x:%d>\n",
            (pNakSequences->NakType == NAK_TYPE_PARITY ? "PARITY" : "SELECTIVE"),
            pNakSequences->NumSequences, (ULONG) pNakSequences->Sequences[0],
            (ULONG) pNakSequences->Sequences[pNakSequences->NumSequences-1],
            pReceive->pReceiver->SenderIpAddress, IPPROTO_RM));

    return (status);
}


//----------------------------------------------------------------------------

VOID
CheckSendPendingNaks(
    IN  tADDRESS_CONTEXT        *pAddress,
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tRECEIVE_CONTEXT        *pReceiver,
    IN  PGMLockHandle           *pOldIrq
    )
/*++

Routine Description:

    This routine checks if any Naks need to be sent and sends them
    as required

    The PgmDynamicConfig lock is held on entry and exit from
    this routine

Arguments:

    IN  pAddress    -- Address object context
    IN  pReceive    -- Receive context
    IN  pOldIrq     -- Irq for PgmDynamicConfig

Return Value:

    NONE

--*/
{
    tNAKS_CONTEXT               *pNakContext, *pSelectiveNaks = NULL;
    tNAKS_CONTEXT               *pParityNaks = NULL;
    LIST_ENTRY                  NaksList;
    LIST_ENTRY                  *pEntry;
    tNAK_FORWARD_DATA           *pNak;
    PGMLockHandle               OldIrq, OldIrq1;
    ULONG                       NumMissingPackets, PacketsInGroup, NumNaks, TotalSeqsNacked = 0;
    BOOLEAN                     fSendSelectiveNak, fSendParityNak;
    UCHAR                       i, j;
    ULONG                       NumPendingNaks = 0;
    ULONG                       NumOutstandingNaks = 0;
    USHORT                      Index;
    ULONG                       NakRandomBackoffMSecs, NakRepeatIntervalMSecs;

    if ((!pReceiver->LastSpmSource) ||
        ((pReceiver->DataPacketsPendingNaks <= OUT_OF_ORDER_PACKETS_BEFORE_NAK) &&
         ((pReceiver->LastNakSendTime + (pReceive->pReceiver->InitialOutstandingNakTimeout>>2)) >
          PgmDynamicConfig.ReceiversTimerTickCount)))
    {
        PgmTrace (LogPath, ("CheckSendPendingNaks:  "  \
            "No Naks to send for pReceive=<%p>, LastSpmSource=<%x>, NumDataPackets=<%d>, LastSendTime=<%I64d>, Current=<%I64d>\n",
                pReceive, pReceiver->LastSpmSource,
                pReceiver->DataPacketsPendingNaks,
                pReceiver->LastNakSendTime+(NAK_MIN_INITIAL_BACKOFF_TIMEOUT_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS),
                PgmDynamicConfig.ReceiversTimerTickCount));

        return;
    }

    InitializeListHead (&NaksList);
    if (!(pSelectiveNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('5'))) ||
        !(pParityNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('6'))))
    {
        PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pNakContext\n"));

        if (pSelectiveNaks)
        {
            PgmFreeMem (pSelectiveNaks);
        }

        return;
    }

    PgmZeroMemory (pSelectiveNaks, sizeof (tNAKS_CONTEXT));
    PgmZeroMemory (pParityNaks, sizeof (tNAKS_CONTEXT));
    pParityNaks->NakType = NAK_TYPE_PARITY;
    pSelectiveNaks->NakType = NAK_TYPE_SELECTIVE;
    InsertTailList (&NaksList, &pParityNaks->Linkage);
    InsertTailList (&NaksList, &pSelectiveNaks->Linkage);

    PgmLock (pAddress, OldIrq);
    PgmLock (pReceive, OldIrq1);

    AdjustReceiveBufferLists (pReceive);

    if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS_OPT;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS_OPT;
    }
    else
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS;
    }

    fSendSelectiveNak = fSendParityNak = FALSE;
    pEntry = &pReceiver->PendingNaksList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->PendingNaksList)
    {
        pNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, SendNakLinkage);
        NumMissingPackets = pNak->PacketsInGroup - (pNak->NumDataPackets + pNak->NumParityPackets);

        ASSERT (NumMissingPackets);
        //
        // if this Nak is outside the trailing window, then we are hosed!
        //
        if (SEQ_GT (pReceiver->LastTrailingEdgeSeqNum, pNak->SequenceNumber))
        {
            PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                "Sequence # [%d] out of trailing edge <%d>, NumNcfs received=<%d>\n",
                    (ULONG) pNak->SequenceNumber,
                    (ULONG) pReceiver->LastTrailingEdgeSeqNum,
                    pNak->WaitingRDataRetries));
            pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
            break;
        }

        //
        // See if we are currently in NAK pending mode
        //
        if (pNak->PendingNakTimeout)
        {
            NumPendingNaks += NumMissingPackets;
            if (PgmDynamicConfig.ReceiversTimerTickCount > pNak->PendingNakTimeout)
            {
                //
                // Time out Naks only after we have received a FIN!
                //
                if (pNak->WaitingNcfRetries++ >= NAK_WAITING_NCF_MAX_RETRIES)
                {
                    PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                        "Pending Nak for Sequence # [%d] Timed out!  Num Naks sent=<%d>, Window=<%d--%d> ( %d seqs)\n",
                            (ULONG) pNak->SequenceNumber, pNak->WaitingNcfRetries,
                            (ULONG) pReceiver->LastTrailingEdgeSeqNum,
                            (ULONG) pReceiver->FurthestKnownGroupSequenceNumber,
                            (ULONG) (1+pReceiver->FurthestKnownGroupSequenceNumber-
                                       pReceiver->LastTrailingEdgeSeqNum)));
                    pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
                    break;
                }

                if ((pNak->PacketsInGroup > 1) &&
                    (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT) &&
                    ((pNak->SequenceNumber != pReceiver->FurthestKnownGroupSequenceNumber) ||
                     (SEQ_GEQ (pReceiver->FurthestKnownSequenceNumber, (pNak->SequenceNumber+pReceive->FECGroupSize-1)))))
                {
                    ASSERT (NumMissingPackets <= pReceive->FECGroupSize);

                    pParityNaks->Sequences[pParityNaks->NumSequences] = (SEQ_TYPE) (pNak->SequenceNumber + NumMissingPackets - 1);

                    if (++pParityNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                    {
                        fSendParityNak = TRUE;
                    }
                    pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NakRepeatIntervalMSecs + (NakRandomBackoffMSecs/NumMissingPackets)) /
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);
                    TotalSeqsNacked += NumMissingPackets;
                    NumMissingPackets = 0;
                }
                else
                {
                    NumNaks = 0;
                    if (pReceive->FECOptions)
                    {
                        if (pNak->SequenceNumber == pReceiver->FurthestKnownGroupSequenceNumber)
                        {
                            ASSERT (SEQ_GEQ (pReceiver->FurthestKnownSequenceNumber, pReceiver->FurthestKnownGroupSequenceNumber));
                            PacketsInGroup = pReceiver->FurthestKnownSequenceNumber - pNak->SequenceNumber + 1;
                            ASSERT (PacketsInGroup >= (ULONG) (pNak->NumDataPackets + pNak->NumParityPackets));
                        }
                        else
                        {
                            PacketsInGroup = pNak->PacketsInGroup;
                        }
                        NumMissingPackets = PacketsInGroup -
                                            (pNak->NextIndexToIndicate +pNak->NumDataPackets +pNak->NumParityPackets);

                        ASSERT ((NumMissingPackets) ||
                                (pNak->SequenceNumber == pReceiver->FurthestKnownGroupSequenceNumber));

                        for (i=pNak->NextIndexToIndicate; i<PacketsInGroup; i++)
                        {
                            if (pNak->pPendingData[i].ActualIndexOfDataPacket >= pNak->OriginalGroupSize)
                            {
                                if (!pNak->pPendingData[i].NcfsReceivedForActualIndex)
                                {
                                    pSelectiveNaks->Sequences[pSelectiveNaks->NumSequences++] = pNak->SequenceNumber+i;
                                    NumNaks++;
                                }

                                if (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                                {
                                    if (!(pSelectiveNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('5'))))
                                    {
                                        PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                                            "STATUS_INSUFFICIENT_RESOURCES allocating pSelectiveNaks\n"));

                                        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                                        break;
                                    }

                                    PgmZeroMemory (pSelectiveNaks, sizeof (tNAKS_CONTEXT));
                                    pSelectiveNaks->NakType = NAK_TYPE_SELECTIVE;
                                    InsertTailList (&NaksList, &pSelectiveNaks->Linkage);
                                }

                                if (!--NumMissingPackets)
                                {
                                    break;
                                }
                            }
                        }

                        ASSERT (!NumMissingPackets);
                        if (NumNaks)
                        {
                            TotalSeqsNacked += NumNaks;
                        }
                        else
                        {
                            pNak->WaitingNcfRetries--;
                        }
                    }
                    else
                    {
                        pSelectiveNaks->Sequences[pSelectiveNaks->NumSequences++] = pNak->SequenceNumber;
                        TotalSeqsNacked++;
                    }

                    pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NakRepeatIntervalMSecs + NakRandomBackoffMSecs) /
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);

                    if (!pSelectiveNaks)
                    {
                        break;
                    }

                    if (pSelectiveNaks->NumSequences == (MAX_SEQUENCES_PER_NAK_OPTION+1))
                    {
                        fSendSelectiveNak = TRUE;
                    }
                }
            }
        }
        else if (pNak->OutstandingNakTimeout)
        {
            NumOutstandingNaks += NumMissingPackets;
            if (PgmDynamicConfig.ReceiversTimerTickCount > pNak->OutstandingNakTimeout)
            {
                //
                // We have timed-out waiting for RData -- Reset the Timeout to send
                // a Nak after the Random Backoff (if we have not exceeded the Data retries)
                //
                if (pNak->WaitingRDataRetries++ == NCF_WAITING_RDATA_MAX_RETRIES)
                {
                    PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                        "Outstanding Nak for Sequence # [%d] Timed out!, Window=<%d--%d> ( %d seqs), Ncfs=<%d>, FirstNak=<%d>\n",
                            (ULONG) pNak->SequenceNumber, (ULONG) pReceiver->LastTrailingEdgeSeqNum,
                            (ULONG) pReceiver->FurthestKnownGroupSequenceNumber,
                            (ULONG) (1+pReceiver->FurthestKnownGroupSequenceNumber-pReceiver->LastTrailingEdgeSeqNum),
                            pNak->WaitingRDataRetries, (ULONG) pReceiver->FirstNakSequenceNumber));

                    pReceive->SessionFlags |= PGM_SESSION_FLAG_NAK_TIMED_OUT;
                    break;
                }

                pNak->WaitingNcfRetries = 0;
                pNak->OutstandingNakTimeout = 0;
                pNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                          ((NakRandomBackoffMSecs/NumMissingPackets) /
                                           BASIC_TIMER_GRANULARITY_IN_MSECS);

                for (i=0; i<pNak->PacketsInGroup; i++)
                {
                    pNak->pPendingData[i].NcfsReceivedForActualIndex = 0;
                }

                NumMissingPackets = 0;
            }
        }

        while (fSendSelectiveNak || fSendParityNak)
        {
            if (fSendSelectiveNak)
            {
                if (!(pSelectiveNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('5'))))
                {
                    PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                        "STATUS_INSUFFICIENT_RESOURCES allocating pSelectiveNaks\n"));

                    pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    break;
                }

                PgmZeroMemory (pSelectiveNaks, sizeof (tNAKS_CONTEXT));
                pSelectiveNaks->NakType = NAK_TYPE_SELECTIVE;
                InsertTailList (&NaksList, &pSelectiveNaks->Linkage);
                fSendSelectiveNak = FALSE;
            }

            if (fSendParityNak)
            {
                if (!(pParityNaks = PgmAllocMem (sizeof (tNAKS_CONTEXT), PGM_TAG('6'))))
                {
                    PgmTrace (LogError, ("CheckSendPendingNaks: ERROR -- "  \
                        "STATUS_INSUFFICIENT_RESOURCES allocating pParityNaks\n"));

                    pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    break;
                }

                PgmZeroMemory (pParityNaks, sizeof (tNAKS_CONTEXT));
                pParityNaks->NakType = NAK_TYPE_PARITY;
                InsertTailList (&NaksList, &pParityNaks->Linkage);
                fSendParityNak = FALSE;
            }
        }

        if (pReceive->SessionFlags & PGM_SESSION_TERMINATED_ABORT)
        {
            break;
        }
    }

    pReceiver->NumPendingNaks = NumPendingNaks;
    pReceiver->NumOutstandingNaks = NumOutstandingNaks;

    if (!IsListEmpty (&NaksList))
    {
        pReceiver->LastNakSendTime = PgmDynamicConfig.ReceiversTimerTickCount;
    }

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);
    PgmUnlock (&PgmDynamicConfig, *pOldIrq);

    while (!IsListEmpty (&NaksList))
    {
        pNakContext = CONTAINING_RECORD (NaksList.Flink, tNAKS_CONTEXT, Linkage);

        if (pNakContext->NumSequences &&
            !(pReceive->SessionFlags & (PGM_SESSION_FLAG_NAK_TIMED_OUT | PGM_SESSION_TERMINATED_ABORT)))
        {
            PgmTrace (LogAllFuncs, ("CheckSendPendingNaks:  "  \
                "Sending %s Nak for <%d> sequences, [%d -- %d]!\n",
                    (pNakContext->NakType == NAK_TYPE_PARITY ? "Parity" : "Selective"),
                    pNakContext->NumSequences, (ULONG) pNakContext->Sequences[0],
                    (ULONG) pNakContext->Sequences[MAX_SEQUENCES_PER_NAK_OPTION]));

            PgmSendNak (pReceive, pNakContext);
        }

        RemoveEntryList (&pNakContext->Linkage);
        PgmFreeMem (pNakContext);
    }

    PgmLock (&PgmDynamicConfig, *pOldIrq);
}


//----------------------------------------------------------------------------

VOID
CheckForSessionTimeout(
    IN  tRECEIVE_SESSION        *pReceive,
    IN  tRECEIVE_CONTEXT        *pReceiver
    )
{
    ULONG               LastInterval;

    LastInterval = (ULONG) (PgmDynamicConfig.ReceiversTimerTickCount -
                            pReceiver->LastSessionTickCount);

    if ((LastInterval > MAX_SPM_INTERVAL_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS) &&
        (LastInterval > (pReceiver->MaxSpmInterval << 5)))   // (32 * MaxSpmInterval)
    {
        PgmTrace (LogError, ("ReceiveTimerTimeout: ERROR -- "  \
            "Disconnecting session because no SPM or Data packets received for <%d> Msecs\n",
                (LastInterval * BASIC_TIMER_GRANULARITY_IN_MSECS)));

        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        return;
    }

    LastInterval = (ULONG) (PgmDynamicConfig.ReceiversTimerTickCount -
                            pReceiver->LastDataConsumedTime);
    if ((!IsListEmpty (&pReceiver->BufferedDataList)) &&
        (LastInterval > MAX_DATA_CONSUMPTION_TIME_MSECS/BASIC_TIMER_GRANULARITY_IN_MSECS))
    {
        PgmTrace (LogError, ("ReceiveTimerTimeout: ERROR -- "  \
            "Disconnecting session because Data has not been consumed for <%I64x> Msecs\n",
                (LastInterval * BASIC_TIMER_GRANULARITY_IN_MSECS)));

        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
    }
}


//----------------------------------------------------------------------------

VOID
ReceiveTimerTimeout(
    IN  PKDPC   Dpc,
    IN  PVOID   DeferredContext,
    IN  PVOID   SystemArg1,
    IN  PVOID   SystemArg2
    )
/*++

Routine Description:

    This timeout routine is called periodically to cycle through the
    list of active receivers and send any Naks if required

Arguments:

    IN  Dpc
    IN  DeferredContext -- Our context for this timer
    IN  SystemArg1
    IN  SystemArg2

Return Value:

    NONE

--*/
{
    LIST_ENTRY          *pEntry;
    PGMLockHandle       OldIrq, OldIrq1;
    tRECEIVE_CONTEXT    *pReceiver;
    tRECEIVE_SESSION    *pReceive;
    NTSTATUS            status;
    LARGE_INTEGER       Now;
    LARGE_INTEGER       DeltaTime, GranularTimeElapsed;
    ULONG               NumTimeouts;
    BOOLEAN             fReStartTimer = TRUE;
    ULONGLONG           BytesInLastInterval;

    PgmLock (&PgmDynamicConfig, OldIrq);

    ASSERT (!IsListEmpty (&PgmDynamicConfig.CurrentReceivers));

    Now.QuadPart = KeQueryInterruptTime ();
    DeltaTime.QuadPart = Now.QuadPart - PgmDynamicConfig.LastReceiverTimeout.QuadPart;
    //
    // If more than a certain number of timeouts have elapsed, we should skip the
    // optimization since it could result in a big loop!
    // Let's limit the optimization to 256 times the TimeoutGranularity for now.
    //
    if (DeltaTime.QuadPart > (PgmDynamicConfig.TimeoutGranularity.QuadPart << 8))
    {
        NumTimeouts = (ULONG) (DeltaTime.QuadPart / PgmDynamicConfig.TimeoutGranularity.QuadPart);
        GranularTimeElapsed.QuadPart = NumTimeouts * PgmDynamicConfig.TimeoutGranularity.QuadPart;
    }
    else
    {
        for (GranularTimeElapsed.QuadPart = 0, NumTimeouts = 0;
             DeltaTime.QuadPart > PgmDynamicConfig.TimeoutGranularity.QuadPart;
             NumTimeouts++)
        {
            GranularTimeElapsed.QuadPart += PgmDynamicConfig.TimeoutGranularity.QuadPart;
            DeltaTime.QuadPart -= PgmDynamicConfig.TimeoutGranularity.QuadPart;
        }
    }

    if (!NumTimeouts)
    {
        PgmInitTimer (&PgmDynamicConfig.SessionTimer);
        PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return;
    }

    PgmDynamicConfig.ReceiversTimerTickCount += NumTimeouts;
    PgmDynamicConfig.LastReceiverTimeout.QuadPart += GranularTimeElapsed.QuadPart;

    pEntry = &PgmDynamicConfig.CurrentReceivers;
    while ((pEntry = pEntry->Flink) != &PgmDynamicConfig.CurrentReceivers)
    {
        pReceiver = CONTAINING_RECORD (pEntry, tRECEIVE_CONTEXT, Linkage);
        pReceive = pReceiver->pReceive;

        PgmLock (pReceive, OldIrq1);

        CheckForSessionTimeout (pReceive, pReceiver);

        if (pReceive->SessionFlags & (PGM_SESSION_FLAG_NAK_TIMED_OUT | PGM_SESSION_TERMINATED_ABORT))
        {
            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            pReceive->SessionFlags &= ~PGM_SESSION_ON_TIMER;
        }

        if (pReceive->SessionFlags & PGM_SESSION_ON_TIMER)
        {
            pReceive->RateCalcTimeout += NumTimeouts;

            if ((pReceive->RateCalcTimeout >=
                 (INTERNAL_RATE_CALCULATION_FREQUENCY/BASIC_TIMER_GRANULARITY_IN_MSECS)) &&
                (pReceiver->StartTickCount != PgmDynamicConfig.ReceiversTimerTickCount))    // Avoid Div by 0
            {
                BytesInLastInterval = pReceive->TotalBytes - pReceive->TotalBytesAtLastInterval;
                pReceive->RateKBitsPerSecOverall = (pReceive->TotalBytes << LOG2_BITS_PER_BYTE) /
                                                   ((PgmDynamicConfig.ReceiversTimerTickCount-pReceiver->StartTickCount) * BASIC_TIMER_GRANULARITY_IN_MSECS);

                pReceive->RateKBitsPerSecLast = BytesInLastInterval >>
                                                (LOG2_INTERNAL_RATE_CALCULATION_FREQUENCY-LOG2_BITS_PER_BYTE);

                if (pReceive->RateKBitsPerSecLast > pReceive->MaxRateKBitsPerSec)
                {
                    pReceive->MaxRateKBitsPerSec = pReceive->RateKBitsPerSecLast;
                }

                //
                // Now, Reset for next calculations
                //
                pReceive->DataBytesAtLastInterval = pReceive->DataBytes;
                pReceive->TotalBytesAtLastInterval = pReceive->TotalBytes;
                pReceive->RateCalcTimeout = 0;

                //
                // Now, update the window information, if applicable
                //
                if (pReceive->RateKBitsPerSecLast)
                {
                    UpdateSampleTimeWindowInformation (pReceive);
                }
                pReceiver->StatSumOfWindowSeqs = pReceiver->NumWindowSamples = 0;
//                pReceiver->StatSumOfNcfRDataTicks = pReceiver->NumNcfRDataTicksSamples = 0;
            }

            if (IsListEmpty (&pReceiver->PendingNaksList))
            {
                pReceiver->NumPendingNaks = 0;
                pReceiver->NumOutstandingNaks = 0;

                PgmUnlock (pReceive, OldIrq1);

                PgmTrace (LogAllFuncs, ("ReceiveTimerTimeout:  "  \
                    "No pending Naks for pReceive=<%p>, Addr=<%x>\n",
                        pReceive, pReceiver->ListenMCastIpAddress));
            }
            else
            {
                PgmUnlock (pReceive, OldIrq1);

                PgmTrace (LogAllFuncs, ("ReceiveTimerTimeout:  "  \
                    "Checking for pending Naks for pReceive=<%p>, Addr=<%x>\n",
                        pReceive, pReceiver->ListenMCastIpAddress));

                CheckSendPendingNaks (pReceiver->pAddress, pReceive, pReceiver, &OldIrq);
            }
        }
        else if (!(pReceive->SessionFlags & PGM_SESSION_FLAG_IN_INDICATE))
        {
            PgmTrace (LogStatus, ("ReceiveTimerTimeout:  "  \
                "PGM_SESSION_ON_TIMER flag cleared for pReceive=<%p>, Addr=<%x>\n",
                    pReceive, pReceiver->ListenMCastIpAddress));

            pEntry = pEntry->Blink;
            RemoveEntryList (&pReceiver->Linkage);

            if (IsListEmpty (&PgmDynamicConfig.CurrentReceivers))
            {
                fReStartTimer = FALSE;
                PgmDynamicConfig.GlobalFlags &= ~PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING;

                PgmTrace (LogStatus, ("ReceiveTimerTimeout:  "  \
                    "Not restarting Timer since no Receivers currently active!\n"));
            }

            PgmUnlock (&PgmDynamicConfig, OldIrq1);

            CheckIndicateDisconnect (pReceiver->pAddress, pReceive, NULL, &OldIrq1, FALSE);

            PgmUnlock (pReceive, OldIrq);

            PGM_DEREFERENCE_ADDRESS (pReceiver->pAddress, REF_ADDRESS_RECEIVE_ACTIVE);
            PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TIMER_RUNNING);

            if (!fReStartTimer)
            {
                return;
            }

            PgmLock (&PgmDynamicConfig, OldIrq);
        }
        else
        {
            PgmUnlock (pReceive, OldIrq1);
        }
    }

    PgmInitTimer (&PgmDynamicConfig.SessionTimer);
    PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);

    PgmUnlock (&PgmDynamicConfig, OldIrq);
}


//----------------------------------------------------------------------------

NTSTATUS
ExtractNakNcfSequences(
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket,
    IN  ULONG                                   BytesAvailable,
    OUT tNAKS_LIST                              *pNakNcfList,
    OUT SEQ_TYPE                                *pLastSequenceNumber,
    IN  UCHAR                                   FECGroupSize
    )
/*++

Routine Description:

    This routine is called to process a Nak/Ncf packet and extract all
    the Sequences specified therein into a list.
    It also verifies that the sequences are unique and sorted

Arguments:

    IN  pNakNcfPacket           -- Nak/Ncf packet
    IN  BytesAvailable          -- PacketLength
    OUT pNakNcfList             -- List of sequences returned on success

Return Value:

    NTSTATUS - Final status of the operation

--*/
{
    NTSTATUS        status;
    ULONG           i;
    tPACKET_OPTIONS PacketOptions;
    USHORT          ThisSequenceIndex;
    SEQ_TYPE        LastSequenceNumber, ThisSequenceNumber, ThisSequenceGroup;
    SEQ_TYPE        NextUnsentSequenceNumber, NextUnsentSequenceGroup;
    SEQ_TYPE        FECSequenceMask = FECGroupSize - 1;
    SEQ_TYPE        FECGroupMask = ~FECSequenceMask;

// Must be called with the Session lock held!

    PgmZeroMemory (pNakNcfList, sizeof (tNAKS_LIST));
    if (pNakNcfPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY)
    {
        pNakNcfList->NakType = NAK_TYPE_PARITY;
    }
    else
    {
        pNakNcfList->NakType = NAK_TYPE_SELECTIVE;
    }

    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pNakNcfPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pNakNcfPacket + 1),
                                 BytesAvailable,
                                 (pNakNcfPacket->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 pNakNcfList);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                "ProcessOptions returned <%x>\n", status));

            return (STATUS_DATA_NOT_ACCEPTED);
        }
        ASSERT (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_NAK_LIST);
    }

    pNakNcfList->pNakSequences[0] = (SEQ_TYPE) ntohl (pNakNcfPacket->RequestedSequenceNumber);
    pNakNcfList->NumSequences += 1;

    //
    // Now, adjust the sequences according to our local relative sequence number
    // (This is to account for wrap-arounds)
    //
    if (pLastSequenceNumber)
    {
        NextUnsentSequenceNumber = *pLastSequenceNumber;
    }
    else
    {
        NextUnsentSequenceNumber = FECGroupSize + pNakNcfList->pNakSequences[pNakNcfList->NumSequences-1];
    }
    NextUnsentSequenceGroup = NextUnsentSequenceNumber & FECGroupMask;

    LastSequenceNumber = pNakNcfList->pNakSequences[0] - FECGroupSize;
    for (i=0; i < pNakNcfList->NumSequences; i++)
    {
        ThisSequenceNumber = pNakNcfList->pNakSequences[i];

        //
        // If this is a parity Nak, then we need to separate the TG_SQN from the PKT_SQN
        //
        ThisSequenceGroup = ThisSequenceNumber & FECGroupMask;
        ThisSequenceIndex = (USHORT) (ThisSequenceNumber & FECSequenceMask);
        pNakNcfList->pNakSequences[i] = ThisSequenceGroup;
        pNakNcfList->NakIndex[i] = ThisSequenceIndex;

        PgmTrace (LogPath, ("ExtractNakNcfSequences:  "  \
            "[%d] Sequence# = <%d> ==> [%d:%d]\n",
                i, (ULONG) pNakNcfList->pNakSequences[i], ThisSequenceNumber, ThisSequenceIndex));

        if (SEQ_LEQ (ThisSequenceNumber, LastSequenceNumber))
        {
            //
            // This list is not ordered, so just bail!
            //
            PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                "[%d] Unordered list! Sequence#<%d> before <%d>\n",
                i, (ULONG) LastSequenceNumber, (ULONG) ThisSequenceNumber));

            return (STATUS_DATA_NOT_ACCEPTED);
        }

        if (pNakNcfList->NakType == NAK_TYPE_SELECTIVE)
        {
            if (SEQ_LEQ (ThisSequenceNumber, LastSequenceNumber))
            {
                //
                // This list is not ordered, so just bail!
                //
                PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                    "[%d] Unordered Selective list! Sequence#<%d> before <%d>\n",
                    i, (ULONG) LastSequenceNumber, (ULONG) ThisSequenceNumber));

                return (STATUS_DATA_NOT_ACCEPTED);
            }

            if (SEQ_GEQ (ThisSequenceNumber, NextUnsentSequenceNumber))
            {
                pNakNcfList->NumSequences = (USHORT) i;      // Don't want to include this sequence!

                PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                    "Invalid Selective Nak = [%d] further than leading edge = [%d]\n",
                        (ULONG) ThisSequenceNumber, (ULONG) NextUnsentSequenceNumber));

                break;
            }

            LastSequenceNumber = ThisSequenceNumber;
        }
        else    // pNakNcfList->NakType == NAK_TYPE_PARITY
        {
            if (SEQ_LEQ (ThisSequenceGroup, LastSequenceNumber))
            {
                //
                // This list is not ordered, so just bail!
                //
                PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                    "[%d] Unordered Parity list! Sequence#<%d> before <%d>\n",
                    i, (ULONG) LastSequenceNumber, (ULONG) ThisSequenceNumber));

                return (STATUS_DATA_NOT_ACCEPTED);
            }

            if (SEQ_GEQ (ThisSequenceGroup, NextUnsentSequenceGroup))
            {
                pNakNcfList->NumSequences = (USHORT) i;      // Don't want to include this sequence!

                PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                    "Invalid Parity Nak = [%d] further than leading edge = [%d]\n",
                        (ULONG) ThisSequenceGroup, (ULONG) NextUnsentSequenceGroup));

                break;
            }

            LastSequenceNumber = ThisSequenceGroup;
            pNakNcfList->NumParityNaks[i]++;
        }
    }

    if (!pNakNcfList->NumSequences)
    {
        PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
            "No Valid %s Naks in List, First Nak=<%d>!\n",
                (pNakNcfList->NakType == NAK_TYPE_PARITY ? "Parity" : "Selective"),
                (ULONG) ThisSequenceNumber));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    if (pLastSequenceNumber)
    {
        *pLastSequenceNumber = LastSequenceNumber;
    }

    if (pNakNcfList->NumSequences)
    {
        return (STATUS_SUCCESS);
    }
    else
    {
        return (STATUS_UNSUCCESSFUL);
    }
}


//----------------------------------------------------------------------------

NTSTATUS
CheckAndAddNakRequests(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  SEQ_TYPE            *pLatestSequenceNumber,
    OUT tNAK_FORWARD_DATA   **ppThisNak,
    IN  enum eNAK_TIMEOUT   NakTimeoutType,
    IN  BOOLEAN             fSetFurthestKnown
    )
{
    tNAK_FORWARD_DATA   *pOldNak;
    tNAK_FORWARD_DATA   *pLastNak;
    SEQ_TYPE            MidSequenceNumber;
    SEQ_TYPE            FECGroupMask = pReceive->FECGroupSize-1;
    SEQ_TYPE            ThisSequenceNumber = *pLatestSequenceNumber;
    SEQ_TYPE            ThisGroupSequenceNumber = ThisSequenceNumber & ~FECGroupMask;
    SEQ_TYPE            FurthestGroupSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
    ULONG               NakRequestSize = sizeof(tNAK_FORWARD_DATA) +
                                         ((pReceive->FECGroupSize-1) * sizeof(tPENDING_DATA));
    ULONGLONG           Pending0NakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 2;
    LIST_ENTRY          *pEntry;
    UCHAR               i;
    ULONG               NakRandomBackoffMSecs, NakRepeatIntervalMSecs;
    tRECEIVE_CONTEXT    *pReceiver = pReceive->pReceiver;

    //
    // Verify that the FurthestKnownGroupSequenceNumber is on a Group boundary
    //
    ASSERT (!(FurthestGroupSequenceNumber & FECGroupMask));

    if (SEQ_LT (ThisSequenceNumber, pReceiver->FirstNakSequenceNumber))
    {
        if (ppThisNak)
        {
            ASSERT (0);
            *ppThisNak = NULL;
        }

        return (STATUS_SUCCESS);
    }

    if (SEQ_GT (ThisGroupSequenceNumber, (pReceiver->NextODataSequenceNumber + MAX_SEQUENCES_IN_RCV_WINDOW)))
    {
        PgmTrace (LogError, ("CheckAndAddNakRequests: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES -- Too many packets in Window [%d, %d] = %d Sequences\n",
                (ULONG) pReceiver->NextODataSequenceNumber,
                (ULONG) ThisGroupSequenceNumber,
                (ULONG) (ThisGroupSequenceNumber - pReceiver->NextODataSequenceNumber + 1)));

        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    if (SEQ_GT (ThisGroupSequenceNumber, (FurthestGroupSequenceNumber + 1000)) &&
        !(pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET))
    {
        PgmTrace (LogStatus, ("CheckAndAddNakRequests:  "  \
            "WARNING!!! Too many successive packets lost =<%d>!!! Expecting Next=<%d>, FurthestKnown=<%d>, This=<%d>\n",
                (ULONG) (ThisGroupSequenceNumber - FurthestGroupSequenceNumber),
                (ULONG) pReceiver->FirstNakSequenceNumber,
                (ULONG) FurthestGroupSequenceNumber,
                (ULONG) ThisGroupSequenceNumber));
    }

    if (pReceiver->pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS_OPT;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS_OPT;
    }
    else
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS;
    }

    //
    // Add any Nak requests if necessary!
    // FurthestGroupSequenceNumber must be a multiple of the FECGroupSize (if applicable)
    //
    pLastNak = NULL;
    while (SEQ_LT (FurthestGroupSequenceNumber, ThisGroupSequenceNumber))
    {
        if (pReceive->FECOptions)
        {
            pLastNak = ExAllocateFromNPagedLookasideList (&pReceiver->ParityContextLookaside);
        }
        else
        {
            pLastNak = ExAllocateFromNPagedLookasideList (&pReceiver->NonParityContextLookaside);
        }

        if (!pLastNak)
        {
            pReceiver->FurthestKnownGroupSequenceNumber = FurthestGroupSequenceNumber;
            pReceiver->FurthestKnownSequenceNumber = pReceiver->FurthestKnownSequenceNumber + FECGroupMask; // End of prev group

            PgmTrace (LogError, ("ExtractNakNcfSequences: ERROR -- "  \
                "STATUS_INSUFFICIENT_RESOURCES allocating tNAK_FORWARD_DATA, Size=<%d>, Seq=<%d>\n",
                    NakRequestSize, (ULONG) pReceiver->FurthestKnownGroupSequenceNumber));

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        PgmZeroMemory (pLastNak, NakRequestSize);

        if (pReceive->FECOptions)
        {
            pLastNak->OriginalGroupSize = pLastNak->PacketsInGroup = pReceive->FECGroupSize;
            for (i=0; i<pLastNak->OriginalGroupSize; i++)
            {
                pLastNak->pPendingData[i].ActualIndexOfDataPacket = pLastNak->OriginalGroupSize;
            }
        }
        else
        {
            pLastNak->OriginalGroupSize = pLastNak->PacketsInGroup = 1;
            pLastNak->pPendingData[0].ActualIndexOfDataPacket = 1;
        }

        FurthestGroupSequenceNumber += pReceive->FECGroupSize;
        pLastNak->SequenceNumber = FurthestGroupSequenceNumber;
        pLastNak->MinPacketLength = pReceive->MaxFECPacketLength;

        if (NakTimeoutType == NAK_OUTSTANDING)
        {
            pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              pReceiver->OutstandingNakTimeout;
            pLastNak->PendingNakTimeout = 0;
            pLastNak->WaitingNcfRetries = 0;
        }
        else
        {
            pLastNak->OutstandingNakTimeout = 0;
            switch (NakTimeoutType)
            {
                case (NAK_PENDING_0):
                {
                    pLastNak->PendingNakTimeout = Pending0NakTimeout;
                    break;
                }

                case (NAK_PENDING_RB):
                {
                    pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                                  ((NakRandomBackoffMSecs/pReceive->FECGroupSize) /
                                                   BASIC_TIMER_GRANULARITY_IN_MSECS);

                    break;
                }

                case (NAK_PENDING_RPT_RB):
                {
                    pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                                  ((NakRepeatIntervalMSecs +(NakRandomBackoffMSecs/pReceive->FECGroupSize))/
                                                   BASIC_TIMER_GRANULARITY_IN_MSECS);

                    break;
                }

                default:
                {
                    ASSERT (0);
                }
            }
        }

        InsertTailList (&pReceiver->NaksForwardDataList, &pLastNak->Linkage);
        AppendPendingReceiverEntry (pReceiver, pLastNak);

        PgmTrace (LogPath, ("CheckAndAddNakRequests:  "  \
            "ADDing NAK request for SeqNum=<%d>, Furthest=<%d>\n",
                (ULONG) pLastNak->SequenceNumber, (ULONG) FurthestGroupSequenceNumber));
    }

    pReceiver->FurthestKnownGroupSequenceNumber = FurthestGroupSequenceNumber;
    if (SEQ_GT (ThisSequenceNumber, pReceiver->FurthestKnownSequenceNumber))
    {
        if (fSetFurthestKnown)
        {
            pReceiver->FurthestKnownSequenceNumber = ThisSequenceNumber;
        }
        else if (SEQ_GT (FurthestGroupSequenceNumber, pReceiver->FurthestKnownSequenceNumber))
        {
            pReceiver->FurthestKnownSequenceNumber = FurthestGroupSequenceNumber + FECGroupMask;
        }
    }

    if (pLastNak)
    {
        pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                      NakRepeatIntervalMSecs / BASIC_TIMER_GRANULARITY_IN_MSECS;
    }
    else if ((ppThisNak) && (!IsListEmpty (&pReceiver->NaksForwardDataList)))
    {
        pLastNak = FindReceiverEntry (pReceiver, ThisGroupSequenceNumber);
        ASSERT (!pLastNak || (pLastNak->SequenceNumber == ThisGroupSequenceNumber));
    }

    if (ppThisNak)
    {
        *ppThisNak = pLastNak;
    }

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ReceiverProcessNakNcfPacket(
    IN  tADDRESS_CONTEXT                        *pAddress,
    IN  tRECEIVE_SESSION                        *pReceive,
    IN  ULONG                                   PacketLength,
    IN  tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket,
    IN  UCHAR                                   PacketType
    )
/*++

Routine Description:

    This is the common routine for processing Nak or Ncf packets

Arguments:

    IN  pAddress        -- Address object context
    IN  pReceive        -- Receive context
    IN  PacketLength    -- Length of packet received from the wire
    IN  pNakNcfPacket   -- Nak/Ncf packet
    IN  PacketType      -- whether Nak or Ncf

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    PGMLockHandle                   OldIrq;
    ULONG                           i, j, PacketIndex;
    tNAKS_LIST                      NakNcfList;
    SEQ_TYPE                        LastSequenceNumber, FECGroupMask;
    NTSTATUS                        status;
    LIST_ENTRY                      *pEntry;
    tNAK_FORWARD_DATA               *pLastNak;
    ULONG                           PacketsInGroup, NumMissingPackets;
    ULONG                           NakRandomBackoffMSecs, NakRepeatIntervalMSecs;
    BOOLEAN                         fValidNcf, fFECWithSelectiveNaksOnly = FALSE;
    tRECEIVE_CONTEXT                *pReceiver = pReceive->pReceiver;

    ASSERT (!pNakNcfPacket->CommonHeader.TSDULength);

    PgmZeroMemory (&NakNcfList, sizeof (tNAKS_LIST));
    PgmLock (pReceive, OldIrq);

    status = ExtractNakNcfSequences (pNakNcfPacket,
                                     (PacketLength - sizeof(tBASIC_NAK_NCF_PACKET_HEADER)),
                                     &NakNcfList,
                                     NULL,
                                     pReceive->FECGroupSize);
    if (!NT_SUCCESS (status))
    {
        PgmUnlock (pReceive, OldIrq);
        PgmTrace (LogError, ("ReceiverProcessNakNcfPacket: ERROR -- "  \
            "ExtractNakNcfSequences returned <%x>\n", status));

        return (status);
    }

    PgmTrace (LogAllFuncs, ("ReceiverProcessNakNcfPacket:  "  \
        "NumSequences=[%d] Range=<%d--%d>, Furthest=<%d>\n",
            NakNcfList.NumSequences,
            (ULONG) NakNcfList.pNakSequences[0], (ULONG) NakNcfList.pNakSequences[NakNcfList.NumSequences-1],
            (ULONG) pReceiver->FurthestKnownGroupSequenceNumber));

    //
    // Compares apples to apples and oranges to oranges
    // i.e. Process parity Naks only if we are parity-aware, and vice-versa
    // Exception is ofr the case of a selective Ncf received when we have OnDemand parity
    //
    if ((pReceiver->SessionNakType == NakNcfList.NakType) ||
        ((PacketType == PACKET_TYPE_NCF) &&
         (NakNcfList.NakType == NAK_TYPE_SELECTIVE)))
    {
        if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
        {
            NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS_OPT;
            NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS_OPT;
        }
        else
        {
            NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS;
            NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS;
        }
    }
    else
    {
        PgmUnlock (pReceive, OldIrq);
        PgmTrace (LogPath, ("ReceiverProcessNakNcfPacket:  "  \
            "Received a %s Nak!  Not processing ... \n",
            ((pReceive->FECGroupSize > 1) ? "Non-parity" : "Parity")));

        return (STATUS_SUCCESS);
    }

    i = 0;
    FECGroupMask = pReceive->FECGroupSize - 1;

    //
    // Special case:  If we have FEC enabled, but not with OnDemand parity,
    // then we will process Ncf requests only
    //
    fFECWithSelectiveNaksOnly = pReceive->FECOptions &&
                                !(pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT);

    if ((PacketType == PACKET_TYPE_NAK) &&
        (fFECWithSelectiveNaksOnly))
    {
        i = NakNcfList.NumSequences;
    }

    for ( ; i <NakNcfList.NumSequences; i++)
    {
        LastSequenceNumber = NakNcfList.pNakSequences[i];
        pLastNak = FindReceiverEntry (pReceiver, LastSequenceNumber);

        if (pLastNak)
        {
            ASSERT (pLastNak->SequenceNumber == LastSequenceNumber);
            if ((pReceive->FECOptions) &&
                (LastSequenceNumber == pReceiver->FurthestKnownGroupSequenceNumber))
            {
                ASSERT (SEQ_GEQ (pReceiver->FurthestKnownSequenceNumber, pReceiver->FurthestKnownGroupSequenceNumber));
                PacketsInGroup = pReceiver->FurthestKnownSequenceNumber - pLastNak->SequenceNumber + 1;
                ASSERT (PacketsInGroup >= (ULONG) (pLastNak->NumDataPackets + pLastNak->NumParityPackets));
            }
            else
            {
                PacketsInGroup = pLastNak->PacketsInGroup;
            }
            NumMissingPackets = PacketsInGroup - (pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets + pLastNak->NumParityPackets);
        }

        if ((!pLastNak) ||
            (!NumMissingPackets))
        {
            continue;
        }

        if (PacketType == PACKET_TYPE_NAK)
        {
            //
            // If we are currently waiting for a Nak or Ncf, we need to
            // reset the timeout for either of the 2 scenarios
            //
            if (pLastNak->PendingNakTimeout)    // We are waiting for a Nak
            {
                pLastNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                              ((NakRepeatIntervalMSecs + (NakRandomBackoffMSecs/NumMissingPackets))/
                                               BASIC_TIMER_GRANULARITY_IN_MSECS);
            }
            else
            {
                    ASSERT (pLastNak->OutstandingNakTimeout);

                pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                  (pReceiver->OutstandingNakTimeout <<
                                                   pLastNak->WaitingRDataRetries);

                if ((pLastNak->WaitingRDataRetries >= (NCF_WAITING_RDATA_MAX_RETRIES >> 1)) &&
                    ((pReceiver->OutstandingNakTimeout << pLastNak->WaitingRDataRetries) <
                     pReceiver->MaxRDataResponseTCFromWindow))
                {
                    pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                      (pReceiver->MaxRDataResponseTCFromWindow<<1);
                }
            }
        }
        else    // NCF case
        {
            PacketIndex = NakNcfList.NakIndex[i];
            fValidNcf = FALSE;

            // first check for OnDemand case
            if (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
            {
                // We may also need to process selective naks in certain cases
                if (NakNcfList.NakType == NAK_TYPE_SELECTIVE)
                {
                    fValidNcf = TRUE;

                    pLastNak->pPendingData[PacketIndex].NcfsReceivedForActualIndex++;
                    for (j=0; j<PacketsInGroup; j++)
                    {
                        if ((pLastNak->pPendingData[j].ActualIndexOfDataPacket >= pLastNak->OriginalGroupSize) &&
                            (!pLastNak->pPendingData[j].NcfsReceivedForActualIndex))
                        {
                            fValidNcf = FALSE;
                            break;
                        }
                    }

                    if (!pLastNak->FirstNcfTickCount)
                    {
                        pLastNak->FirstNcfTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
                    }
                }
                else if (NakNcfList.NumParityNaks[i] >= NumMissingPackets)  // Parity Nak
                {
                    fValidNcf = TRUE;

                    if (!pLastNak->FirstNcfTickCount)
                    {
                        pLastNak->FirstNcfTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
                    }
                }
            }
            // Selective Naks only -- with or without FEC
            else if (pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket >= pLastNak->OriginalGroupSize)
            {
                fValidNcf = TRUE;
                if (fFECWithSelectiveNaksOnly)
                {
                    pLastNak->pPendingData[PacketIndex].NcfsReceivedForActualIndex++;
                    for (j=0; j<pLastNak->PacketsInGroup; j++)
                    {
                        if ((pLastNak->pPendingData[j].ActualIndexOfDataPacket >= pLastNak->OriginalGroupSize) &&
                            (!pLastNak->pPendingData[j].NcfsReceivedForActualIndex))
                        {
                            fValidNcf = FALSE;
                            break;
                        }
                    }
                }

                if (!pLastNak->FirstNcfTickCount)
                {
                    pLastNak->FirstNcfTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
                }
            }

            if (fValidNcf)
            {
                pLastNak->PendingNakTimeout = 0;
                pLastNak->WaitingNcfRetries = 0;

                pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                  (pReceiver->OutstandingNakTimeout <<
                                                   pLastNak->WaitingRDataRetries);

                if ((pLastNak->WaitingRDataRetries >= (NCF_WAITING_RDATA_MAX_RETRIES >> 1)) &&
                    ((pReceiver->OutstandingNakTimeout << pLastNak->WaitingRDataRetries) <
                     pReceiver->MaxRDataResponseTCFromWindow))
                {
                    pLastNak->OutstandingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount + 
                                                      (pReceiver->MaxRDataResponseTCFromWindow<<1);
                }
            }
        }
    }

    //
    // So, we need to create new Nak contexts for the remaining Sequences
    // Since the Sequences are ordered, just pick the highest one, and
    // create Naks for all up to that
    //
    LastSequenceNumber = NakNcfList.pNakSequences[NakNcfList.NumSequences-1] + NakNcfList.NakIndex[NakNcfList.NumSequences-1];
    if (NakNcfList.NakType == NAK_TYPE_PARITY)
    {
        LastSequenceNumber--;
    }

    if (PacketType == PACKET_TYPE_NAK)
    {
        status = CheckAndAddNakRequests (pReceive, &LastSequenceNumber, NULL, NAK_PENDING_RPT_RB, TRUE);
    }
    else    // PacketType == PACKET_TYPE_NCF
    {
        status = CheckAndAddNakRequests (pReceive, &LastSequenceNumber, NULL, NAK_OUTSTANDING, TRUE);
    }

    PgmUnlock (pReceive, OldIrq);
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
CoalesceSelectiveNaksIntoGroups(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  UCHAR               GroupSize
    )
{
    PNAK_FORWARD_DATA   pOldNak, pNewNak;
    LIST_ENTRY          NewNaksList;
    LIST_ENTRY          OldNaksList;
    LIST_ENTRY          *pEntry;
    SEQ_TYPE            FirstGroupSequenceNumber, LastGroupSequenceNumber, LastSequenceNumber;
    SEQ_TYPE            FurthestKnownSequenceNumber;
    SEQ_TYPE            GroupMask = GroupSize - 1;
    ULONG               NakRequestSize = sizeof(tNAK_FORWARD_DATA) + ((GroupSize-1) * sizeof(tPENDING_DATA));
    USHORT              MinPacketLength;
    UCHAR               i;
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG               NakRandomBackoffMSecs, NakRepeatIntervalMSecs;

    ASSERT (pReceive->FECGroupSize == 1);
    ASSERT (GroupSize > 1);

    //
    // First, call AdjustReceiveBufferLists to ensure that FirstNakSequenceNumber is current
    //
    AdjustReceiveBufferLists (pReceive);

    FirstGroupSequenceNumber = pReceive->pReceiver->FirstNakSequenceNumber & ~GroupMask;
    LastGroupSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber & ~GroupMask;
    FurthestKnownSequenceNumber = pReceive->pReceiver->FurthestKnownSequenceNumber;     // Save

    //
    // If the next packet seq we are expecting is > the furthest known sequence #,
    // then we don't need to do anything
    //
    LastSequenceNumber = LastGroupSequenceNumber + (GroupSize-1);
    //
    // First, add Nak requests for the missing packets in furthest group!
    //
    status = CheckAndAddNakRequests (pReceive, &LastSequenceNumber, NULL, NAK_PENDING_RB, FALSE);
    if (!NT_SUCCESS (status))
    {
        PgmTrace (LogError, ("CoalesceSelectiveNaksIntoGroups: ERROR -- "  \
            "CheckAndAddNakRequests returned <%x>\n", status));

        return (status);
    }
    pReceive->pReceiver->FurthestKnownSequenceNumber = FurthestKnownSequenceNumber;     // Reset

    ASSERT (LastSequenceNumber == pReceive->pReceiver->FurthestKnownGroupSequenceNumber);
    ASSERT (pReceive->pReceiver->MaxPacketsBufferedInLookaside);
    ExInitializeNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     NakRequestSize,
                                     PGM_TAG('2'),
                                     (USHORT) (pReceive->pReceiver->MaxPacketsBufferedInLookaside/GroupSize));

    if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, LastSequenceNumber))
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber = LastGroupSequenceNumber;

        ASSERT (IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));

        PgmTrace (LogStatus, ("CoalesceSelectiveNaksIntoGroups:  "  \
            "[1] NextOData=<%d>, FirstNak=<%d>, FirstGroup=<%d>, LastGroup=<%d>, no Naks pending!\n",
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                (ULONG) FirstGroupSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber));

        return (STATUS_SUCCESS);
    }

    if (pReceive->pReceiver->pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS_OPT;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS_OPT;
    }
    else
    {
        NakRandomBackoffMSecs = NAK_RANDOM_BACKOFF_MSECS;
        NakRepeatIntervalMSecs = NAK_REPEAT_INTERVAL_MSECS;
    }

    //
    // We will start coalescing from the end of the list in case we run
    // into failures
    // Also, we will ignore the first Group since it may be a partial group,
    // or we may have indicated some of the data already, so we may not know
    // the exact data length
    //
    pOldNak = pNewNak = NULL;
    InitializeListHead (&NewNaksList);
    InitializeListHead (&OldNaksList);
    while (SEQ_GEQ (LastGroupSequenceNumber, FirstGroupSequenceNumber))
    {
        if (!(pNewNak = ExAllocateFromNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside)))
        {
            PgmTrace (LogError, ("CoalesceSelectiveNaksIntoGroups: ERROR -- "  \
                "STATUS_INSUFFICIENT_RESOURCES allocating tNAK_FORWARD_DATA\n"));

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        PgmZeroMemory (pNewNak, NakRequestSize);
        InitializeListHead (&pNewNak->SendNakLinkage);
        InitializeListHead (&pNewNak->LookupLinkage);

        pNewNak->OriginalGroupSize = pNewNak->PacketsInGroup = GroupSize;
        pNewNak->SequenceNumber = LastGroupSequenceNumber;
        MinPacketLength = pReceive->MaxFECPacketLength;

        for (i=0; i<pNewNak->OriginalGroupSize; i++)
        {
            pNewNak->pPendingData[i].ActualIndexOfDataPacket = pNewNak->OriginalGroupSize;
        }

        i = 0;
        while (SEQ_GEQ (LastSequenceNumber, LastGroupSequenceNumber) &&
               (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList)))
        {
            pEntry = RemoveTailList (&pReceive->pReceiver->NaksForwardDataList);
            pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
            if (!pOldNak->NumDataPackets)
            {
                RemovePendingReceiverEntry (pOldNak);
            }
            else
            {
                ASSERT (pOldNak->NumDataPackets == 1);
                ASSERT (IsListEmpty (&pOldNak->SendNakLinkage));
                ASSERT (IsListEmpty (&pOldNak->LookupLinkage));
            }

            ASSERT (pOldNak->SequenceNumber == LastSequenceNumber);
            ASSERT (pOldNak->OriginalGroupSize == 1);

            if (pOldNak->pPendingData[0].pDataPacket)
            {
                ASSERT (pOldNak->NumDataPackets == 1);

                pNewNak->NumDataPackets++;
                PgmCopyMemory (&pNewNak->pPendingData[i], &pOldNak->pPendingData[0], sizeof (tPENDING_DATA));
                pNewNak->pPendingData[i].PacketIndex = (UCHAR) (LastSequenceNumber - LastGroupSequenceNumber);
                pNewNak->pPendingData[LastSequenceNumber-LastGroupSequenceNumber].ActualIndexOfDataPacket = i;
                i++;

                pOldNak->pPendingData[0].pDataPacket = NULL;
                pOldNak->pPendingData[0].PendingDataFlags = 0;
                pOldNak->NumDataPackets--;

                if (pOldNak->MinPacketLength < MinPacketLength)
                {
                    MinPacketLength = pOldNak->MinPacketLength;
                }

                if ((pOldNak->ThisGroupSize) &&
                    (pOldNak->ThisGroupSize < GroupSize))
                {
                    if (pNewNak->PacketsInGroup == GroupSize)
                    {
                        pNewNak->PacketsInGroup = pOldNak->ThisGroupSize;
                    }
                    else
                    {
                        ASSERT (pNewNak->PacketsInGroup == pOldNak->ThisGroupSize);
                    }
                }
            }

            InsertHeadList (&OldNaksList, &pOldNak->Linkage);
            LastSequenceNumber--;
        }

        pNewNak->MinPacketLength = MinPacketLength;

        //
        // See if we need to get rid of any excess (NULL) data packets
        //
        RemoveRedundantNaks (pReceive, pNewNak, FALSE);

        ASSERT (!pNewNak->NumParityPackets);
        if (pNewNak->NumDataPackets < pNewNak->PacketsInGroup)  // No parity packets yet!
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NakRandomBackoffMSecs/(pNewNak->PacketsInGroup-pNewNak->NumDataPackets))/
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }

        InsertHeadList (&NewNaksList, &pNewNak->Linkage);
        LastGroupSequenceNumber -= GroupSize;
    }

    //
    // If we succeeded in allocating all NewNaks above, set the
    // NextIndexToIndicate for the first group.
    // We may also need to adjust FirstNakSequenceNumber and NextODataSequenceNumber
    //
    if ((pNewNak) &&
        (pNewNak->SequenceNumber == FirstGroupSequenceNumber))
    {
        if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, pNewNak->SequenceNumber))
        {
            pNewNak->NextIndexToIndicate = (UCHAR) (pReceive->pReceiver->FirstNakSequenceNumber -
                                                    pNewNak->SequenceNumber);
            pReceive->pReceiver->FirstNakSequenceNumber = pNewNak->SequenceNumber;
            ASSERT (pNewNak->NextIndexToIndicate < GroupSize);
            ASSERT ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) <= pNewNak->PacketsInGroup);
        }
        ASSERT (pReceive->pReceiver->FirstNakSequenceNumber == pNewNak->SequenceNumber);

        //
        // We may have data available for this group already in the buffered
        // list (if it has not been indicated already) -- we should move it here
        //
        while ((pNewNak->NextIndexToIndicate) &&
               (!IsListEmpty (&pReceive->pReceiver->BufferedDataList)))
        {
            ASSERT (pNewNak->NumDataPackets < pNewNak->OriginalGroupSize);

            pEntry = RemoveTailList (&pReceive->pReceiver->BufferedDataList);
            pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

            pReceive->pReceiver->NumPacketGroupsPendingClient--;
            pReceive->pReceiver->DataPacketsPendingIndicate--;
            pReceive->pReceiver->DataPacketsPendingNaks++;
            pNewNak->NextIndexToIndicate--;

            ASSERT (pOldNak->pPendingData[0].pDataPacket);
            ASSERT ((pOldNak->NumDataPackets == 1) && (pOldNak->OriginalGroupSize == 1));
            ASSERT (pOldNak->SequenceNumber == (pNewNak->SequenceNumber + pNewNak->NextIndexToIndicate));

            PgmCopyMemory (&pNewNak->pPendingData[pNewNak->NumDataPackets], &pOldNak->pPendingData[0], sizeof (tPENDING_DATA));
            pNewNak->pPendingData[pNewNak->NumDataPackets].PacketIndex = pNewNak->NextIndexToIndicate;
            pNewNak->pPendingData[pNewNak->NextIndexToIndicate].ActualIndexOfDataPacket = pNewNak->NumDataPackets;
            pNewNak->NumDataPackets++;

            if (pOldNak->MinPacketLength < pNewNak->MinPacketLength)
            {
                pNewNak->MinPacketLength = pOldNak->MinPacketLength;
            }

            if ((pOldNak->ThisGroupSize) &&
                (pOldNak->ThisGroupSize < GroupSize))
            {
                if (pNewNak->PacketsInGroup == GroupSize)
                {
                    pNewNak->PacketsInGroup = pOldNak->ThisGroupSize;
                }
                else
                {
                    ASSERT (pNewNak->PacketsInGroup == pOldNak->ThisGroupSize);
                }
            }

            pOldNak->pPendingData[0].pDataPacket = NULL;
            pOldNak->pPendingData[0].PendingDataFlags = 0;
            pOldNak->NumDataPackets--;
            InsertHeadList (&OldNaksList, &pOldNak->Linkage);
        }

        if (SEQ_GEQ (pReceive->pReceiver->NextODataSequenceNumber, pNewNak->SequenceNumber))
        {
            ASSERT (pReceive->pReceiver->NextODataSequenceNumber ==
                    (pReceive->pReceiver->FirstNakSequenceNumber + pNewNak->NextIndexToIndicate));
            ASSERT (IsListEmpty (&pReceive->pReceiver->BufferedDataList));

            pReceive->pReceiver->NextODataSequenceNumber = pNewNak->SequenceNumber;
        }
        else
        {
            ASSERT ((0 == pNewNak->NextIndexToIndicate) &&
                    !(IsListEmpty (&pReceive->pReceiver->BufferedDataList)));
        }

        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, pReceive->pReceiver->FirstNakSequenceNumber))
        {
            pReceive->pReceiver->LastTrailingEdgeSeqNum = pReceive->pReceiver->FirstNakSequenceNumber;
        }

        RemoveRedundantNaks (pReceive, pNewNak, FALSE);

        if ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) >= pNewNak->PacketsInGroup)
        {
            // This entry will be moved automatically to the buffered data list
            // when we call AdjustReceiveBufferLists below
            pNewNak->PendingNakTimeout = 0;
        }
        else
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NakRandomBackoffMSecs/(pNewNak->PacketsInGroup-(pNewNak->NextIndexToIndicate+pNewNak->NumDataPackets)))/
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }
    }

    ASSERT (IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
    ASSERT (IsListEmpty (&pReceive->pReceiver->PendingNaksList));

    if (!IsListEmpty (&NewNaksList))
    {
        //
        // Now, move the new list to the end of the current list
        //
        NewNaksList.Flink->Blink = pReceive->pReceiver->NaksForwardDataList.Blink;
        NewNaksList.Blink->Flink = &pReceive->pReceiver->NaksForwardDataList;
        pReceive->pReceiver->NaksForwardDataList.Blink->Flink = NewNaksList.Flink;
        pReceive->pReceiver->NaksForwardDataList.Blink = NewNaksList.Blink;
    }

    while (!IsListEmpty (&OldNaksList))
    {
        pEntry = RemoveHeadList (&OldNaksList);
        pOldNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);

        FreeNakContext (pReceive, pOldNak);
    }

    //
    // Put the pending Naks in the PendingNaks list
    //
    pReceive->pReceiver->ReceiveDataIndexShift = gFECLog2[GroupSize];
    pEntry = &pReceive->pReceiver->NaksForwardDataList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->NaksForwardDataList)
    {
        pNewNak = CONTAINING_RECORD (pEntry, tNAK_FORWARD_DATA, Linkage);
        if (((pNewNak->NumDataPackets + pNewNak->NumParityPackets) < pNewNak->PacketsInGroup) &&
            ((pNewNak->NextIndexToIndicate + pNewNak->NumDataPackets) < pNewNak->PacketsInGroup))
        {
            AppendPendingReceiverEntry (pReceive->pReceiver, pNewNak);
        }
    }

    AdjustReceiveBufferLists (pReceive);

    pNewNak = NULL;
    if (!(IsListEmpty (&pReceive->pReceiver->NaksForwardDataList)))
    {
        //
        // For the last context, set the Nak timeout appropriately
        //
        pNewNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Blink, tNAK_FORWARD_DATA, Linkage);
        if (pNewNak->NumDataPackets < pNewNak->PacketsInGroup)
        {
            pNewNak->PendingNakTimeout = PgmDynamicConfig.ReceiversTimerTickCount +
                                         ((NakRepeatIntervalMSecs +
                                           (NakRandomBackoffMSecs /
                                            (pNewNak->PacketsInGroup-pNewNak->NumDataPackets))) /
                                          BASIC_TIMER_GRANULARITY_IN_MSECS);
        }
    }
    else if (!(IsListEmpty (&pReceive->pReceiver->BufferedDataList)))
    {
        pNewNak = CONTAINING_RECORD (pReceive->pReceiver->BufferedDataList.Blink, tNAK_FORWARD_DATA, Linkage);
    }

    //
    // Now, set the FirstKnownGroupSequenceNumber
    //
    if (pNewNak)
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber = pNewNak->SequenceNumber;
    }
    else
    {
        pReceive->pReceiver->FurthestKnownGroupSequenceNumber &= ~GroupMask;
    }

    PgmTrace (LogStatus, ("CoalesceSelectiveNaksIntoGroups:  "  \
        "[2] NextOData=<%d>, FirstNak=<%d->%d>, FirstGroup=<%d>, LastGroup=<%d>\n",
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
            (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
            (pNewNak ? (ULONG) pNewNak->NextIndexToIndicate : (ULONG) 0),
            (ULONG) FirstGroupSequenceNumber,
            (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber));

    return (status);        // If we had failed earlier, we should still fail!
}


//----------------------------------------------------------------------------

NTSTATUS
PgmIndicateToClient(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  ULONG               BytesAvailable,
    IN  PUCHAR              pDataBuffer,
    IN  ULONG               MessageOffset,
    IN  ULONG               MessageLength,
    OUT ULONG               *pBytesTaken,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine tries to indicate the Data packet provided to the client
    It is called with the pAddress and pReceive locks held

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  BytesAvailableToIndicate        -- Length of packet received from the wire
    IN  pPgmDataHeader      -- Data packet
    IN  pOldIrqAddress      -- OldIrq for the Address lock
    IN  pOldIrqReceive      -- OldIrq for the Receive lock

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    PIO_STACK_LOCATION          pIrpSp;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams;
    CONNECTION_CONTEXT          ClientSessionContext;
    PIRP                        pIrpReceive;
    ULONG                       ReceiveFlags, BytesTaken, BytesToCopy, BytesLeftInMessage, ClientBytesTaken;
    tRECEIVE_CONTEXT            *pReceiver = pReceive->pReceiver;
    NTSTATUS                    status = STATUS_SUCCESS;
    PTDI_IND_RECEIVE            evReceive = NULL;
    PVOID                       RcvEvContext = NULL;
    ULONG                       BytesAvailableToIndicate = BytesAvailable;

    if (pReceive->SessionFlags & (PGM_SESSION_CLIENT_DISCONNECTED |
                                  PGM_SESSION_TERMINATED_ABORT))
    {
        PgmTrace (LogError, ("PgmIndicateToClient: ERROR -- "  \
            "pReceive=<%p> disassociated during Receive!\n", pReceive));

        *pBytesTaken = 0;
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    ASSERT ((!pReceiver->CurrentMessageLength) || (pReceiver->CurrentMessageLength == MessageLength));
    ASSERT (pReceiver->CurrentMessageProcessed == MessageOffset);

    pReceiver->CurrentMessageLength = MessageLength;
    pReceiver->CurrentMessageProcessed = MessageOffset;

    BytesLeftInMessage = MessageLength - MessageOffset;

    PgmTrace (LogAllFuncs, ("PgmIndicateToClient:  "  \
        "MessageLen=<%d/%d>, MessageOff=<%d>, CurrentML=<%d>, CurrentMP=<%d>\n",
            BytesAvailableToIndicate, MessageLength, MessageOffset,
            pReceiver->CurrentMessageLength, pReceiver->CurrentMessageProcessed));

    //
    // We may have a receive Irp pending from a previous indication,
    // so see if need to fill that first!
    //
    while ((BytesAvailableToIndicate) &&
           ((pIrpReceive = pReceiver->pIrpReceive) ||
            (!IsListEmpty (&pReceiver->ReceiveIrpsList))))
    {
        if (!pIrpReceive)
        {
            //
            // The client had posted a receive Irp, so use it now!
            //
            pIrpReceive = CONTAINING_RECORD (pReceiver->ReceiveIrpsList.Flink,
                                             IRP, Tail.Overlay.ListEntry);
            RemoveEntryList (&pIrpReceive->Tail.Overlay.ListEntry);

            pIrpSp = IoGetCurrentIrpStackLocation (pIrpReceive);
            pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;

            pReceiver->pIrpReceive = pIrpReceive;
            pReceiver->TotalBytesInMdl = pClientParams->ReceiveLength;
            pReceiver->BytesInMdl = 0;
        }

        //
        // Copy whatever bytes we can into it
        //
        if (BytesAvailableToIndicate >
            (pReceiver->TotalBytesInMdl - pReceiver->BytesInMdl))
        {
            BytesToCopy = pReceiver->TotalBytesInMdl - pReceiver->BytesInMdl;
        }
        else
        {
            BytesToCopy = BytesAvailableToIndicate;
        }

        ClientBytesTaken = 0;
        status = TdiCopyBufferToMdl (pDataBuffer,
                                     0,
                                     BytesToCopy,
                                     pReceiver->pIrpReceive->MdlAddress,
                                     pReceiver->BytesInMdl,
                                     &ClientBytesTaken);

        pReceiver->BytesInMdl += ClientBytesTaken;
        pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        BytesLeftInMessage -= ClientBytesTaken;
        BytesAvailableToIndicate -= ClientBytesTaken;
        pDataBuffer += ClientBytesTaken;

        if ((!ClientBytesTaken) ||
            (pReceiver->BytesInMdl >= pReceiver->TotalBytesInMdl) ||
            (!BytesLeftInMessage))
        {
            //
            // The Irp is full, so complete the Irp!
            //
            pIrpReceive = pReceiver->pIrpReceive;
            pIrpReceive->IoStatus.Information = pReceiver->BytesInMdl;
            if (BytesLeftInMessage)
            {
                pIrpReceive->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            }
            else
            {
                ASSERT (pReceiver->CurrentMessageLength == pReceiver->CurrentMessageProcessed);
                pIrpReceive->IoStatus.Status = STATUS_SUCCESS;
            }

            //
            // Before releasing the lock, set the parameters for the next receive
            //
            pReceiver->pIrpReceive = NULL;
            pReceiver->TotalBytesInMdl = pReceiver->BytesInMdl = 0;

            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmCancelCancelRoutine (pIrpReceive);

            PgmTrace (LogPath, ("PgmIndicateToClient:  "  \
                "Completing prior pIrp=<%p>, Bytes=<%d>, BytesLeft=<%d>\n",
                    pIrpReceive, (ULONG) pIrpReceive->IoStatus.Information, BytesAvailableToIndicate));

            IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }
    }

    //
    // If there are no more bytes left to indicate, return
    //
    if (BytesAvailableToIndicate == 0)
    {
        if (!BytesLeftInMessage)
        {
            ASSERT (pReceiver->CurrentMessageLength == pReceiver->CurrentMessageProcessed);
            pReceiver->CurrentMessageLength = pReceiver->CurrentMessageProcessed = 0;
        }

        if (BytesTaken = (BytesAvailable - BytesAvailableToIndicate))
        {
            *pBytesTaken = BytesTaken;
            pReceiver->LastDataConsumedTime = PgmDynamicConfig.ReceiversTimerTickCount;
        }
        return (STATUS_SUCCESS);
    }


    // call the Client Event Handler
    pIrpReceive = NULL;
    ClientBytesTaken = 0;
    evReceive = pAddress->evReceive;
    ClientSessionContext = pReceive->ClientSessionContext;
    RcvEvContext = pAddress->RcvEvContext;
    ASSERT (RcvEvContext);

    PgmUnlock (pReceive, *pOldIrqReceive);
    PgmUnlock (pAddress, *pOldIrqAddress);

    ReceiveFlags = TDI_RECEIVE_NORMAL;

    if (PgmGetCurrentIrql())
    {
        ReceiveFlags |= TDI_RECEIVE_AT_DISPATCH_LEVEL;
    }

#if 0
    if (BytesLeftInMessage == BytesAvailableToIndicate)
    {
        ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;
    }

    status = (*evReceive) (RcvEvContext,
                           ClientSessionContext,
                           ReceiveFlags,
                           BytesAvailableToIndicate,
                           BytesAvailableToIndicate,
                           &ClientBytesTaken,
                           pDataBuffer,
                           &pIrpReceive);
#else
    ReceiveFlags |= TDI_RECEIVE_ENTIRE_MESSAGE;

    status = (*evReceive) (RcvEvContext,
                           ClientSessionContext,
                           ReceiveFlags,
                           BytesAvailableToIndicate,
                           BytesLeftInMessage,
                           &ClientBytesTaken,
                           pDataBuffer,
                           &pIrpReceive);
#endif  // 0

    PgmTrace (LogPath, ("PgmIndicateToClient:  "  \
        "Client's evReceive returned status=<%x>, ReceiveFlags=<%x>, Client took <%d/%d|%d>, pIrp=<%p>\n",
            status, ReceiveFlags, ClientBytesTaken, BytesAvailableToIndicate, BytesLeftInMessage, pIrpReceive));

    if (ClientBytesTaken > BytesAvailableToIndicate)
    {
        ClientBytesTaken = BytesAvailableToIndicate;
    }

    ASSERT (ClientBytesTaken <= BytesAvailableToIndicate);
    BytesAvailableToIndicate -= ClientBytesTaken;
    BytesLeftInMessage -= ClientBytesTaken;
    pDataBuffer = pDataBuffer + ClientBytesTaken;

    if ((status == STATUS_MORE_PROCESSING_REQUIRED) &&
        (pIrpReceive) &&
        (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrpReceive, PgmCancelReceiveIrp, FALSE))))
    {
        PgmTrace (LogError, ("PgmIndicateToClient: ERROR -- "  \
            "pReceive=<%p>, pIrp=<%p> Cancelled during Receive!\n", pReceive, pIrpReceive));

        PgmIoComplete (pIrpReceive, STATUS_CANCELLED, 0);

        PgmLock (pAddress, *pOldIrqAddress);
        PgmLock (pReceive, *pOldIrqReceive);

        pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        if (BytesTaken = (BytesAvailable - BytesAvailableToIndicate))
        {
            *pBytesTaken = BytesTaken;
            pReceiver->LastDataConsumedTime = PgmDynamicConfig.ReceiversTimerTickCount;
        }
        return (STATUS_UNSUCCESSFUL);
    }

    PgmLock (pAddress, *pOldIrqAddress);
    PgmLock (pReceive, *pOldIrqReceive);

    pReceiver->CurrentMessageProcessed += ClientBytesTaken;

    if (!pReceiver->pAddress)
    {
        // the connection was disassociated in the interim so do nothing.
        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmIoComplete (pIrpReceive, STATUS_CANCELLED, 0);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }

        PgmTrace (LogError, ("PgmIndicateToClient: ERROR -- "  \
            "pReceive=<%p> disassociated during Receive!\n", pReceive));

        if (BytesTaken = (BytesAvailable - BytesAvailableToIndicate))
        {
            *pBytesTaken = BytesTaken;
            pReceiver->LastDataConsumedTime = PgmDynamicConfig.ReceiversTimerTickCount;
        }
        return (STATUS_UNSUCCESSFUL);
    }

    if (status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        ASSERT (pIrpReceive);
        ASSERT (pIrpReceive->MdlAddress);

        pIrpSp = IoGetCurrentIrpStackLocation (pIrpReceive);
        pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;
        ASSERT (pClientParams->ReceiveLength);
        ClientBytesTaken = 0;

        if (pClientParams->ReceiveLength < BytesAvailableToIndicate)
        {
            BytesToCopy = pClientParams->ReceiveLength;
        }
        else
        {
            BytesToCopy = BytesAvailableToIndicate;
        }

        status = TdiCopyBufferToMdl (pDataBuffer,
                                     0,
                                     BytesToCopy,
                                     pIrpReceive->MdlAddress,
                                     pReceiver->BytesInMdl,
                                     &ClientBytesTaken);

        BytesLeftInMessage -= ClientBytesTaken;
        BytesAvailableToIndicate -= ClientBytesTaken;
        pDataBuffer = pDataBuffer + ClientBytesTaken;
        pReceiver->CurrentMessageProcessed += ClientBytesTaken;

        PgmTrace (LogPath, ("PgmIndicateToClient:  "  \
            "Client's evReceive returned pIrp=<%p>, BytesInIrp=<%d>, Copied <%d> bytes\n",
                pIrpReceive, pClientParams->ReceiveLength, ClientBytesTaken));

        if ((!ClientBytesTaken) ||
            (ClientBytesTaken >= pClientParams->ReceiveLength) ||
            (pReceiver->CurrentMessageLength == pReceiver->CurrentMessageProcessed))
        {
            //
            // The Irp is full, so complete the Irp!
            //
            pIrpReceive->IoStatus.Information = ClientBytesTaken;
            if (pReceiver->CurrentMessageLength == pReceiver->CurrentMessageProcessed)
            {
                pIrpReceive->IoStatus.Status = STATUS_SUCCESS;
            }
            else
            {
                pIrpReceive->IoStatus.Status = STATUS_BUFFER_OVERFLOW;
            }

            //
            // Before releasing the lock, set the parameters for the next receive
            //
            pReceiver->TotalBytesInMdl = pReceiver->BytesInMdl = 0;

            PgmUnlock (pReceive, *pOldIrqReceive);
            PgmUnlock (pAddress, *pOldIrqAddress);

            PgmCancelCancelRoutine (pIrpReceive);
            IoCompleteRequest (pIrpReceive, IO_NETWORK_INCREMENT);

            PgmLock (pAddress, *pOldIrqAddress);
            PgmLock (pReceive, *pOldIrqReceive);
        }
        else
        {
            pReceiver->TotalBytesInMdl = pClientParams->ReceiveLength;
            pReceiver->BytesInMdl = ClientBytesTaken;
            pReceiver->pIrpReceive = pIrpReceive;
        }

        status = STATUS_SUCCESS;
    }
    else if (status == STATUS_DATA_NOT_ACCEPTED)
    {
        //
        // An Irp could have been posted in the interval
        // between the indicate and acquiring the SpinLocks,
        // so check for that here
        //
        if ((pReceiver->pIrpReceive) ||
            (!IsListEmpty (&pReceiver->ReceiveIrpsList)))
        {
            status = STATUS_SUCCESS;
        }
        else
        {
            pReceive->SessionFlags |= PGM_SESSION_WAIT_FOR_RECEIVE_IRP;
        }
    }

    if (pReceiver->CurrentMessageLength == pReceiver->CurrentMessageProcessed)
    {
        pReceiver->CurrentMessageLength = pReceiver->CurrentMessageProcessed = 0;
    }

    if ((NT_SUCCESS (status)) ||
        (status == STATUS_DATA_NOT_ACCEPTED))
    {
        PgmTrace (LogAllFuncs, ("PgmIndicateToClient:  "  \
            "status=<%x>, pReceive=<%p>, Taken=<%d>, Available=<%d>\n",
                status, pReceive, ClientBytesTaken, BytesLeftInMessage));
        //
        // since some bytes were taken (i.e. the session hdr) so
        // return status success. (otherwise the status is
        // statusNotAccpeted).
        //
    }
    else
    {
        PgmTrace (LogError, ("PgmIndicateToClient: ERROR -- "  \
            "Unexpected status=<%x>\n", status));

        ASSERT (0);
    }

    if (BytesTaken = (BytesAvailable - BytesAvailableToIndicate))
    {
        *pBytesTaken = BytesTaken;
        pReceiver->LastDataConsumedTime = PgmDynamicConfig.ReceiversTimerTickCount;
    }
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmIndicateGroup(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive,
    IN  tNAK_FORWARD_DATA   *pNak
    )
{
    UCHAR       i, j;
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       BytesTaken, DataBytes, MessageLength;

    ASSERT (pNak->SequenceNumber == pReceive->pReceiver->NextODataSequenceNumber);

    j = pNak->NextIndexToIndicate;
    while (j < pNak->PacketsInGroup)
    {
        if (pReceive->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED)
        {
            status = STATUS_DATA_NOT_ACCEPTED;
            break;
        }

        i = pNak->pPendingData[j].ActualIndexOfDataPacket;
        ASSERT (i < pNak->OriginalGroupSize);

        if (pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET)
        {
            //
            // pReceive->pReceiver->CurrentMessageProcessed would have been set
            // if we were receiving a fragmented message
            // or if we had only accounted for a partial message earlier
            //
            ASSERT (!(pReceive->pReceiver->CurrentMessageProcessed) &&
                    !(pReceive->pReceiver->CurrentMessageLength));

            if (pNak->pPendingData[i].MessageOffset)
            {
                PgmTrace (LogPath, ("PgmIndicateGroup:  "  \
                    "Dropping SeqNum=[%d] since it's a PARTIAL message [%d / %d]!\n",
                        (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                        pNak->pPendingData[i].MessageOffset, pNak->pPendingData[i].MessageLength));

                j++;
                pNak->NextIndexToIndicate++;
                status = STATUS_SUCCESS;
                continue;
            }

            pReceive->SessionFlags &= ~PGM_SESSION_FLAG_FIRST_PACKET;
        }
        else if ((pReceive->pReceiver->CurrentMessageProcessed !=
                        pNak->pPendingData[i].MessageOffset) ||   // Check Offsets
                 ((pReceive->pReceiver->CurrentMessageProcessed) &&         // in the midst of a Message, and
                  (pReceive->pReceiver->CurrentMessageLength !=
                        pNak->pPendingData[i].MessageLength)))  // Check MessageLength
        {
            //
            // Our state expects us to be in the middle of a message, but
            // the current packets do not show this
            //
            PgmTrace (LogError, ("PgmIndicateGroup: ERROR -- "  \
                "SeqNum=[%d] Expecting MsgLen=<%d>, MsgOff=<%d>, have MsgLen=<%d>, MsgOff=<%d>\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                    pReceive->pReceiver->CurrentMessageLength, pReceive->pReceiver->CurrentMessageProcessed,
                    pNak->pPendingData[i].MessageLength,
                    pNak->pPendingData[i].MessageOffset));

//            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }

        DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
        if (!DataBytes)
        {
            //
            // No need to process empty data packets (can happen if the client
            // picks up partial FEC group)
            //
            j++;
            pNak->NextIndexToIndicate++;
            status = STATUS_SUCCESS;
            continue;
        }

        if (DataBytes > (pNak->pPendingData[i].MessageLength - pNak->pPendingData[i].MessageOffset))
        {
            PgmTrace (LogError, ("PgmIndicateGroup: ERROR -- "  \
                "[%d]  DataBytes=<%d> > MsgLen=<%d> - MsgOff=<%d> = <%d>\n",
                    (ULONG) (pReceive->pReceiver->NextODataSequenceNumber + j),
                    DataBytes, pNak->pPendingData[i].MessageLength,
                    pNak->pPendingData[i].MessageOffset,
                    (pNak->pPendingData[i].MessageLength - pNak->pPendingData[i].MessageOffset)));

            ASSERT (0);
            return (STATUS_UNSUCCESSFUL);
        }

        BytesTaken = 0;
        status = PgmIndicateToClient (pAddress,
                                      pReceive,
                                      DataBytes,
                                      (pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset),
                                      pNak->pPendingData[i].MessageOffset,
                                      pNak->pPendingData[i].MessageLength,
                                      &BytesTaken,
                                      pOldIrqAddress,
                                      pOldIrqReceive);

        PgmTrace (LogPath, ("PgmIndicateGroup:  "  \
            "SeqNum=[%d]: PgmIndicate returned<%x>\n",
                (ULONG) pNak->SequenceNumber, status));

        ASSERT (BytesTaken <= DataBytes);

        pNak->pPendingData[i].MessageOffset += BytesTaken;
        pNak->pPendingData[i].DataOffset += (USHORT) BytesTaken;

        if (BytesTaken == DataBytes)
        {
            //
            // Go to the next packet
            //
            j++;
            pNak->NextIndexToIndicate++;
            pReceive->pReceiver->DataPacketsIndicated++;
            status = STATUS_SUCCESS;
        }
        else if (!NT_SUCCESS (status))
        {
            //
            // We failed, and if the status was STATUS_DATA_NOT_ACCEPTED,
            // we also don't have any ReceiveIrps pending either
            //
            break;
        }
        //
        // else retry indicating this data until we get an error
        //
    }

    //
    // If the status is anything other than STATUS_DATA_NOT_ACCEPTED (whether
    // success or failure), then it means we are done with this data!
    //
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
DecodeParityPackets(
    IN  tRECEIVE_SESSION    *pReceive,
    IN  tNAK_FORWARD_DATA   *pNak
    )
{
    NTSTATUS                    status;
    USHORT                      MinBufferSize;
    USHORT                      DataBytes, FprOffset;
    UCHAR                       i;
    PUCHAR                      pDataBuffer;
    tPOST_PACKET_FEC_CONTEXT    FECContext;

    PgmZeroMemory (&FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));

    //
    // Verify that the our buffer is large enough to hold the data
    //
    ASSERT (pReceive->MaxMTULength > pNak->ParityDataSize);
    MinBufferSize = pNak->ParityDataSize + sizeof(tPOST_PACKET_FEC_CONTEXT) - sizeof(USHORT);

    ASSERT (pNak->PacketsInGroup == pNak->NumDataPackets + pNak->NumParityPackets);
    //
    // Now, copy the data into the DecodeBuffers
    //
    FprOffset = pNak->ParityDataSize - sizeof(USHORT) +
                FIELD_OFFSET (tPOST_PACKET_FEC_CONTEXT, FragmentOptSpecific);
    pDataBuffer = pReceive->pFECBuffer;
    for (i=0; i<pReceive->FECGroupSize; i++)
    {
        //
        // See if this is a NULL buffer (for partial groups!)
        //
        if (i >= pNak->PacketsInGroup)
        {
            ASSERT (!pNak->pPendingData[i].PacketIndex);
            ASSERT (!pNak->pPendingData[i].pDataPacket);
            DataBytes = pNak->ParityDataSize - sizeof(USHORT) + sizeof (tPOST_PACKET_FEC_CONTEXT);
            pNak->pPendingData[i].PacketIndex = i;
            pNak->pPendingData[i].PacketLength = DataBytes;
            pNak->pPendingData[i].DataOffset = 0;

            PgmZeroMemory (pDataBuffer, DataBytes);
            pDataBuffer [FprOffset] = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;
            pNak->pPendingData[i].DecodeBuffer = pDataBuffer;
            pDataBuffer += DataBytes;

            PgmZeroMemory (pDataBuffer, DataBytes);
            pNak->pPendingData[i].pDataPacket = pDataBuffer;
            pDataBuffer += DataBytes;

            continue;
        }

        //
        // See if this is a parity packet!
        //
        if (pNak->pPendingData[i].PacketIndex >= pReceive->FECGroupSize)
        {
            DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
            ASSERT (DataBytes == pNak->ParityDataSize);
            PgmCopyMemory (pDataBuffer,
                           pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset,
                           DataBytes);
            pNak->pPendingData[i].DecodeBuffer = pDataBuffer;

            pDataBuffer += (pNak->ParityDataSize - sizeof(USHORT));
            PgmCopyMemory (&FECContext.EncodedTSDULength, pDataBuffer, sizeof (USHORT));
            FECContext.FragmentOptSpecific = pNak->pPendingData[i].FragmentOptSpecific;
            FECContext.EncodedFragmentOptions.MessageFirstSequence = pNak->pPendingData[i].MessageFirstSequence;
            FECContext.EncodedFragmentOptions.MessageOffset = pNak->pPendingData[i].MessageOffset;
            FECContext.EncodedFragmentOptions.MessageLength = pNak->pPendingData[i].MessageLength;

            PgmCopyMemory (pDataBuffer, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
            pDataBuffer += sizeof (tPOST_PACKET_FEC_CONTEXT);

            continue;
        }

        //
        // This is a Data packet
        //
        ASSERT (pNak->pPendingData[i].PacketIndex < pNak->PacketsInGroup);

        DataBytes = pNak->pPendingData[i].PacketLength - pNak->pPendingData[i].DataOffset;
        ASSERT ((DataBytes+sizeof(USHORT)) <= pNak->ParityDataSize);

        // Copy the data
        PgmCopyMemory (pDataBuffer,
                       pNak->pPendingData[i].pDataPacket + pNak->pPendingData[i].DataOffset,
                       DataBytes);

        //
        // Verify that the Data Buffer length is sufficient for the output data
        //
        if ((pNak->MinPacketLength < MinBufferSize) &&
            (pNak->pPendingData[i].PacketLength < pNak->ParityDataSize))
        {
            if (!ReAllocateDataBuffer (pReceive, &pNak->pPendingData[i], MinBufferSize))
            {
                ASSERT (0);
                PgmTrace (LogError, ("DecodeParityPackets: ERROR -- "  \
                    "STATUS_INSUFFICIENT_RESOURCES[2] ...\n"));

                return (STATUS_INSUFFICIENT_RESOURCES);
            }
        }
        pNak->pPendingData[i].DecodeBuffer = pDataBuffer;

        //
        // Zero the remaining buffer
        //
        PgmZeroMemory ((pDataBuffer + DataBytes), (pNak->ParityDataSize - DataBytes));
        pDataBuffer += (pNak->ParityDataSize - sizeof(USHORT));

        FECContext.EncodedTSDULength = htons (DataBytes);
        FECContext.FragmentOptSpecific = pNak->pPendingData[i].FragmentOptSpecific;
        if (FECContext.FragmentOptSpecific & PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT)
        {
            //
            // This bit is set if the option did not exist in the original packet
            //
            FECContext.EncodedFragmentOptions.MessageFirstSequence = 0;
            FECContext.EncodedFragmentOptions.MessageOffset = 0;
            FECContext.EncodedFragmentOptions.MessageLength = 0;
        }
        else
        {
            FECContext.EncodedFragmentOptions.MessageFirstSequence = htonl (pNak->pPendingData[i].MessageFirstSequence);
            FECContext.EncodedFragmentOptions.MessageOffset = htonl (pNak->pPendingData[i].MessageOffset);
            FECContext.EncodedFragmentOptions.MessageLength = htonl (pNak->pPendingData[i].MessageLength);
        }

        PgmCopyMemory (pDataBuffer, &FECContext, sizeof (tPOST_PACKET_FEC_CONTEXT));
        pDataBuffer += sizeof (tPOST_PACKET_FEC_CONTEXT);
    }

#ifdef FEC_DBG
{
    UCHAR                               i;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECC;
    tPOST_PACKET_FEC_CONTEXT            FECC;

    for (i=0; i<pReceive->FECGroupSize; i++)
    {
        pFECC = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *)
                &pNak->pPendingData[i].DecodeBuffer[pNak->ParityDataSize-sizeof(USHORT)];
        PgmCopyMemory (&FECC, pFECC, sizeof (tPOST_PACKET_FEC_CONTEXT));
        PgmTrace (LogFec, ("\t-- [%d:%d:%d]  EncTSDULen=<%x>, Fpr=<%x>, [%x -- %x -- %x]\n",
            (ULONG) pNak->SequenceNumber, (ULONG) pNak->pPendingData[i].PacketIndex,
            (ULONG) pNak->pPendingData[i].ActualIndexOfDataPacket,
            FECC.EncodedTSDULength, FECC.FragmentOptSpecific,
            FECC.EncodedFragmentOptions.MessageFirstSequence,
            FECC.EncodedFragmentOptions.MessageOffset,
            FECC.EncodedFragmentOptions.MessageLength)));
    }
}
#endif  // FEC_DBG

    DataBytes = pNak->ParityDataSize - sizeof(USHORT) + sizeof (tPOST_PACKET_FEC_CONTEXT);
    status = FECDecode (&pReceive->FECContext,
                        &(pNak->pPendingData[0]),
                        DataBytes,
                        pNak->PacketsInGroup);

    //
    // Before we do anything else, we should NULL out the dummy DataBuffer
    // ptrs so that they don't get Free'ed accidentally!
    //
    for (i=0; i<pReceive->FECGroupSize; i++)
    {
        pNak->pPendingData[i].DecodeBuffer = NULL;
        if (i >= pNak->PacketsInGroup)
        {
            ASSERT (!pNak->pPendingData[i].PendingDataFlags);
            pNak->pPendingData[i].pDataPacket = NULL;
        }
        pNak->pPendingData[i].ActualIndexOfDataPacket = i;
    }

    if (NT_SUCCESS (status))
    {
        pNak->NumDataPackets = pNak->PacketsInGroup;
        pNak->NumParityPackets = 0;

        DataBytes -= sizeof (tPOST_PACKET_FEC_CONTEXT);
        for (i=0; i<pNak->PacketsInGroup; i++)
        {
            PgmCopyMemory (&FECContext,
                           &(pNak->pPendingData[i].pDataPacket) [DataBytes],
                           sizeof (tPOST_PACKET_FEC_CONTEXT));

            pNak->pPendingData[i].PacketLength = ntohs (FECContext.EncodedTSDULength);
            if (pNak->pPendingData[i].PacketLength > DataBytes)
            {
                PgmTrace (LogError, ("DecodeParityPackets: ERROR -- "  \
                    "[%d] PacketLength=<%d> > MaxDataBytes=<%d>\n",
                    (ULONG) i, (ULONG) pNak->pPendingData[i].PacketLength, (ULONG) DataBytes));

                ASSERT (0);
                return (STATUS_UNSUCCESSFUL);
            }
            pNak->pPendingData[i].DataOffset = 0;
            pNak->pPendingData[i].PacketIndex = i;

            ASSERT ((pNak->AllOptionsFlags & PGM_OPTION_FLAG_FRAGMENT) ||
                    (!FECContext.EncodedFragmentOptions.MessageLength));

            if (!(pNak->AllOptionsFlags & PGM_OPTION_FLAG_FRAGMENT) ||
                (FECContext.FragmentOptSpecific & PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT))
            {
                //
                // This is not a packet fragment
                //
                pNak->pPendingData[i].MessageFirstSequence = (ULONG) (SEQ_TYPE) (pNak->SequenceNumber + i);
                pNak->pPendingData[i].MessageOffset = 0;
                pNak->pPendingData[i].MessageLength = pNak->pPendingData[i].PacketLength;
            }
            else
            {
                pNak->pPendingData[i].MessageFirstSequence = ntohl (FECContext.EncodedFragmentOptions.MessageFirstSequence);
                pNak->pPendingData[i].MessageOffset = ntohl (FECContext.EncodedFragmentOptions.MessageOffset);
                pNak->pPendingData[i].MessageLength = ntohl (FECContext.EncodedFragmentOptions.MessageLength);
            }
        }
    }
    else
    {
        PgmTrace (LogError, ("DecodeParityPackets: ERROR -- "  \
            "FECDecode returned <%x>\n", status));

        ASSERT (0);
        status = STATUS_UNSUCCESSFUL;
    }

#ifdef FEC_DBG
if (NT_SUCCESS (status))
{
    UCHAR                               i;
    tPOST_PACKET_FEC_CONTEXT UNALIGNED  *pFECC;
    tPOST_PACKET_FEC_CONTEXT            FECC;

    DataBytes = pNak->ParityDataSize - sizeof(USHORT);
    for (i=0; i<pNak->PacketsInGroup; i++)
    {
        pFECC = (tPOST_PACKET_FEC_CONTEXT UNALIGNED *) &pNak->pPendingData[i].pDataPacket[DataBytes];
        PgmCopyMemory (&FECC, pFECC, sizeof (tPOST_PACKET_FEC_CONTEXT));
        PgmTrace (LogFec, ("\t++ [%d]  EncTSDULen=<%x>, Fpr=<%x>, [%x -- %x -- %x], ==> [%x -- %x -- %x]\n",
            (ULONG) (pNak->SequenceNumber+i), FECC.EncodedTSDULength, FECC.FragmentOptSpecific,
            FECC.EncodedFragmentOptions.MessageFirstSequence,
            FECC.EncodedFragmentOptions.MessageOffset,
            FECC.EncodedFragmentOptions.MessageLength,
            pNak->pPendingData[i].MessageFirstSequence,
            pNak->pPendingData[i].MessageOffset,
            pNak->pPendingData[i].MessageLength));
    }
    PgmTrace (LogFec, ("\n"));
}
#endif  // FEC_DBG
    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
CheckIndicatePendedData(
    IN  tADDRESS_CONTEXT    *pAddress,
    IN  tRECEIVE_SESSION    *pReceive,
    IN  PGMLockHandle       *pOldIrqAddress,
    IN  PGMLockHandle       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine is typically called if the client signalled an
    inability to handle indicated data -- it will reattempt to
    indicate the data to the client

    It is called with the pAddress and pReceive locks held

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  pOldIrqAddress      -- OldIrq for the Address lock
    IN  pOldIrqReceive      -- OldIrq for the Receive lock

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tNAK_FORWARD_DATA                   *pNextNak;
    tPACKET_OPTIONS                     PacketOptions;
    ULONG                               PacketsIndicated;
    tBASIC_DATA_PACKET_HEADER UNALIGNED *pPgmDataHeader;
    NTSTATUS                            status = STATUS_SUCCESS;
    tRECEIVE_CONTEXT                    *pReceiver = pReceive->pReceiver;

    //
    // If we are already indicating data on another thread, or
    // waiting for the client to post a receive irp, just return
    //
    if (pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_WAIT_FOR_RECEIVE_IRP))
    {
        return (STATUS_SUCCESS);
    }

    ASSERT (!(pReceive->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED));
    pReceive->SessionFlags |= PGM_SESSION_FLAG_IN_INDICATE;
    while (!IsListEmpty (&pReceiver->BufferedDataList))
    {
        pNextNak = CONTAINING_RECORD (pReceiver->BufferedDataList.Flink, tNAK_FORWARD_DATA, Linkage);

        ASSERT ((pReceiver->NumPacketGroupsPendingClient) &&
                (pNextNak->SequenceNumber == pReceiver->NextODataSequenceNumber) &&
                (SEQ_GT(pReceiver->FirstNakSequenceNumber, pReceiver->NextODataSequenceNumber)));

        //
        // If we do not have all the data packets, we will need to decode them now
        //
        if (pNextNak->NumParityPackets)
        {
            ASSERT ((pNextNak->NumParityPackets + pNextNak->NumDataPackets) == pNextNak->PacketsInGroup);
            status = DecodeParityPackets (pReceive, pNextNak);
            if (!NT_SUCCESS (status))
            {
                PgmTrace (LogError, ("CheckIndicatePendedData: ERROR -- "  \
                    "DecodeParityPackets returned <%x>\n", status));
                pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                break;
            }
        }
        else
        {
            // The below assertion can be greater if we have only partially indicated a group
            ASSERT ((pNextNak->NextIndexToIndicate + pNextNak->NumDataPackets) >= pNextNak->PacketsInGroup);
        }

        status = PgmIndicateGroup (pAddress, pReceive, pOldIrqAddress, pOldIrqReceive, pNextNak);
        if (!NT_SUCCESS (status))
        {
            //
            // If the client cannot accept any more data at this time, so
            // we will try again later, otherwise terminate this session!
            //
            if (status != STATUS_DATA_NOT_ACCEPTED)
            {
                ASSERT (0);
                pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            }

            break;
        }

        //
        // Advance to the next group boundary
        //
        pReceiver->NextODataSequenceNumber += pNextNak->OriginalGroupSize;

        PacketsIndicated = pNextNak->NumDataPackets + pNextNak->NumParityPackets;
        pReceiver->TotalDataPacketsBuffered -= PacketsIndicated;
        pReceiver->DataPacketsPendingIndicate -= PacketsIndicated;
        pReceiver->NumPacketGroupsPendingClient--;
        ASSERT (pReceiver->TotalDataPacketsBuffered >= pReceiver->NumPacketGroupsPendingClient);

        RemoveEntryList (&pNextNak->Linkage);
        FreeNakContext (pReceive, pNextNak);
    }
    pReceive->SessionFlags &= ~PGM_SESSION_FLAG_IN_INDICATE;

    PgmTrace (LogAllFuncs, ("CheckIndicatePendedData:  "  \
        "status=<%x>, pReceive=<%p>, SessionFlags=<%x>\n",
            status, pReceive, pReceive->SessionFlags));

    CheckIndicateDisconnect (pAddress, pReceive, pOldIrqAddress, pOldIrqReceive, TRUE);

    return (STATUS_SUCCESS);
}



#ifdef MAX_BUFF_DBG
ULONG   MaxPacketGroupsPendingClient = 0;
ULONG   MaxPacketsBuffered = 0;
ULONG   MaxPacketsPendingIndicate = 0;
ULONG   MaxPacketsPendingNaks = 0;
#endif  // MAX_BUFF_DBG

//----------------------------------------------------------------------------

NTSTATUS
PgmHandleNewData(
    IN  SEQ_TYPE                            *pThisDataSequenceNumber,
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  USHORT                              PacketLength,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pOData,
    IN  UCHAR                               PacketType,
    IN  PGMLockHandle                       *pOldIrqAddress,
    IN  PGMLockHandle                       *pOldIrqReceive
    )
/*++

Routine Description:

    This routine buffers data packets received out-of-order

Arguments:

    IN  pThisDataSequenceNumber -- Sequence # of unordered data packet
    IN  pAddress                -- Address object context
    IN  pReceive                -- Receive context
    IN  PacketLength            -- Length of packet received from the wire
    IN  pODataBuffer            -- Data packet
    IN  PacketType              -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    SEQ_TYPE                ThisDataSequenceNumber = *pThisDataSequenceNumber;
    LIST_ENTRY              *pEntry;
    PNAK_FORWARD_DATA       pOldNak, pLastNak;
    ULONG                   MessageLength, DataOffset, BytesTaken, DataBytes, BufferLength;
    ULONGLONG               NcfRDataTickCounts;
    NTSTATUS                status;
    USHORT                  TSDULength;
    tPACKET_OPTIONS         PacketOptions;
    UCHAR                   i, PacketIndex, NakIndex;
    BOOLEAN                 fIsParityPacket, fPartiallyIndicated;
    PUCHAR                  pDataBuffer;
    tRECEIVE_CONTEXT        *pReceiver = pReceive->pReceiver;

    ASSERT (PacketLength <= pReceive->MaxMTULength);
    fIsParityPacket = pOData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY;

    //
    // First, ensure we have a Nak context available for this data
    //
    pLastNak = NULL;
    status = CheckAndAddNakRequests (pReceive, &ThisDataSequenceNumber, &pLastNak, NAK_PENDING_RB, (BOOLEAN) !fIsParityPacket);
    if ((!NT_SUCCESS (status)) ||
        (!pLastNak))
    {
        PgmTrace (LogAllFuncs, ("PgmHandleNewData:  "  \
            "CheckAndAddNakRequests for <%d> returned <%x>, pLastNak=<%p>\n",
                ThisDataSequenceNumber, status, pLastNak));

        if (NT_SUCCESS (status))
        {
            pReceiver->NumDupPacketsBuffered++;
        }
        else
        {
            pReceiver->NumDataPacketsDropped++;
        }
        return (status);
    }

    //
    // Now, extract all the information that we need from the packet options
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pOData->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pOData + 1),
                                 (PacketLength - sizeof(tBASIC_DATA_PACKET_HEADER)),
                                 (pOData->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmHandleNewData: ERROR -- "  \
                "ProcessOptions returned <%x>, SeqNum=[%d]: NumOutOfOrder=<%d> ...\n",
                    status, (ULONG) ThisDataSequenceNumber, pReceiver->TotalDataPacketsBuffered));

            ASSERT (0);

            pReceiver->NumDataPacketsDropped++;
            return (status);
        }
    }

    PgmCopyMemory (&TSDULength, &pOData->CommonHeader.TSDULength, sizeof (USHORT));
    TSDULength = ntohs (TSDULength);
    if (PacketLength != (sizeof(tBASIC_DATA_PACKET_HEADER) + PacketOptions.OptionsLength + TSDULength))
    {
        ASSERT (0);
        pReceiver->NumDataPacketsDropped++;
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    DataOffset = sizeof (tBASIC_DATA_PACKET_HEADER) + PacketOptions.OptionsLength;
    DataBytes = TSDULength;

    ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_DATA_OPTION_FLAGS) == 0);
    BytesTaken = 0;

    //
    // If this group has a different GroupSize, set that now
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
    {
        if (pLastNak->OriginalGroupSize == 1)
        {
            //
            // This path will be used if we have not yet received
            // an SPM (so don't know group size, etc), but have a
            // data packet from a partial group
            //
            pLastNak->ThisGroupSize = PacketOptions.FECContext.NumPacketsInThisGroup;
        }
        else if (PacketOptions.FECContext.NumPacketsInThisGroup >= pReceive->FECGroupSize)
        {
            //
            // Bad Packet!
            //
            ASSERT (0);
            pReceiver->NumDataPacketsDropped++;
            return (STATUS_DATA_NOT_ACCEPTED);
        }
        //
        // If we have already received all the data packets, don't do anything here
        //
        else if (pLastNak->PacketsInGroup == pReceive->FECGroupSize)
        {
            pLastNak->PacketsInGroup = PacketOptions.FECContext.NumPacketsInThisGroup;
            if (pLastNak->SequenceNumber == pReceiver->FurthestKnownGroupSequenceNumber)
            {
                pReceiver->FurthestKnownSequenceNumber = pLastNak->SequenceNumber + pLastNak->PacketsInGroup - 1;
            }

            //
            // Get rid of any of the excess (NULL) data packets
            //
            RemoveRedundantNaks (pReceive, pLastNak, TRUE);
        }
        else if (pLastNak->PacketsInGroup != PacketOptions.FECContext.NumPacketsInThisGroup)
        {
            ASSERT (0);
            pReceiver->NumDataPacketsDropped++;
            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }

    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FIN)
    {
        if (fIsParityPacket)
        {
            pReceiver->FinDataSequenceNumber = pLastNak->SequenceNumber + (pLastNak->PacketsInGroup - 1);
        }
        else
        {
            pReceiver->FinDataSequenceNumber = ThisDataSequenceNumber;
        }
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_GRACEFULLY;

        PgmTrace (LogStatus, ("PgmHandleNewData:  "  \
            "SeqNum=[%d]:  Got a FIN!!!\n", (ULONG) pReceiver->FinDataSequenceNumber));

        if (pLastNak)
        {
            ASSERT (pLastNak->SequenceNumber == (pReceiver->FinDataSequenceNumber & ~(pReceive->FECGroupSize-1)));
            pLastNak->PacketsInGroup = (UCHAR) (pReceiver->FinDataSequenceNumber + 1 - pLastNak->SequenceNumber);
            ASSERT (pLastNak->PacketsInGroup <= pReceive->FECGroupSize);

            RemoveRedundantNaks (pReceive, pLastNak, TRUE);
            AdjustReceiveBufferLists (pReceive);
        }
    }

    //
    // Determine the Packet Index
    //
    fPartiallyIndicated = FALSE;
    if (pReceive->FECOptions)
    {
        PacketIndex = (UCHAR) (ThisDataSequenceNumber & (pReceive->FECGroupSize-1));

        //
        // See if we even need this packet!
        //
        if (!fIsParityPacket)
        {
            //
            // This is a data packet!
            //
            if ((PacketIndex >= pLastNak->PacketsInGroup) ||
                (PacketIndex < pLastNak->NextIndexToIndicate))
            {
                //
                // We don't need this Packet!
                //
                status = STATUS_DATA_NOT_ACCEPTED;
            }
        }
        //
        // Parity packet
        //
        else if (((pLastNak->NumDataPackets+pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
                 ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup))
        {
            status = STATUS_DATA_NOT_ACCEPTED;
        }
        else
        {
            if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_GRP)
            {
                ASSERT (((pOData->CommonHeader.Type & 0x0f) == PACKET_TYPE_RDATA) ||
                        ((pOData->CommonHeader.Type & 0x0f) == PACKET_TYPE_ODATA));
                ASSERT (PacketOptions.FECContext.FECGroupInfo);
                PacketIndex += ((USHORT) PacketOptions.FECContext.FECGroupInfo * pReceive->FECGroupSize);
            }
        }

        if (status != STATUS_DATA_NOT_ACCEPTED)
        {
            //
            // Verify that this is not a duplicate of a packet we
            // may have already received
            //
            for (i=0; i < (pLastNak->NumDataPackets+pLastNak->NumParityPackets); i++)
            {
                if (pLastNak->pPendingData[i].PacketIndex == PacketIndex)
                {
                    ASSERT (!fIsParityPacket);
                    status = STATUS_DATA_NOT_ACCEPTED;
                    break;
                }
            }
        }
        else
        {
            AdjustReceiveBufferLists (pReceive);    // In case this became a partial group
        }

        if (status == STATUS_DATA_NOT_ACCEPTED)
        {
            pReceiver->NumDupPacketsBuffered++;
            return (status);
        }
    }
    else    // We are not aware of FEC
    {
        //
        // If we are not aware of options, drop this packet if it is a parity packet!
        //
        if (fIsParityPacket)
        {
            pReceiver->NumDataPacketsDropped++;
            return (STATUS_DATA_NOT_ACCEPTED);
        }
        PacketIndex = 0;

        ASSERT (!pLastNak->pPendingData[0].pDataPacket);

        //
        // If this is the next expected data packet, let's see if we can try
        // to indicate this data over here only (avoid a packet copy)
        // Note: This should be the regular indicate path in the case of non-FEC,
        // low-loss and low-CPU sessions
        //
        if ((ThisDataSequenceNumber == pReceiver->NextODataSequenceNumber) &&
            !(pReceive->SessionFlags & (PGM_SESSION_FLAG_IN_INDICATE |
                                        PGM_SESSION_WAIT_FOR_RECEIVE_IRP)) &&
            (IsListEmpty (&pReceiver->BufferedDataList)))
        {
            ASSERT (!pReceiver->NumPacketGroupsPendingClient);

            //
            // If we are starting receiving in the midst of a message, we should ignore them
            //
            if ((pReceive->SessionFlags & PGM_SESSION_FLAG_FIRST_PACKET) &&
                (PacketOptions.MessageOffset))
            {
                //
                // pReceive->pReceiver->CurrentMessageProcessed would have been set
                // if we were receiving a fragmented message
                // or if we had only accounted for a partial message earlier
                //
                ASSERT (!(pReceive->pReceiver->CurrentMessageProcessed) &&
                        !(pReceive->pReceiver->CurrentMessageLength));

                PgmTrace (LogPath, ("PgmHandleNewData:  "  \
                    "Dropping SeqNum=[%d] since it's a PARTIAL message [%d / %d]!\n",
                        (ULONG) (pReceive->pReceiver->NextODataSequenceNumber),
                        PacketOptions.MessageOffset, PacketOptions.MessageLength));

                DataBytes = 0;
                status = STATUS_SUCCESS;
            }
            else if ((pReceiver->CurrentMessageProcessed != PacketOptions.MessageOffset) ||
                     ((pReceiver->CurrentMessageProcessed) &&
                      (pReceiver->CurrentMessageLength != PacketOptions.MessageLength)))
            {
                //
                // Our state expects us to be in the middle of a message, but
                // the current packets do not show this
                //
                PgmTrace (LogError, ("PgmHandleNewData: ERROR -- "  \
                    "SeqNum=[%d] Expecting MsgLen=<%d>, MsgOff=<%d>, have MsgLen=<%d>, MsgOff=<%d>\n",
                        (ULONG) pReceiver->NextODataSequenceNumber,
                        pReceiver->CurrentMessageLength,
                        pReceiver->CurrentMessageProcessed,
                        PacketOptions.MessageLength, PacketOptions.MessageOffset));

                ASSERT (0);
                BytesTaken = DataBytes;
                pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                return (STATUS_UNSUCCESSFUL);
            }

            RemoveEntryList (&pLastNak->Linkage);
            RemovePendingReceiverEntry (pLastNak);

            pReceiver->NextODataSequenceNumber++;
            pReceiver->FirstNakSequenceNumber = pReceiver->NextODataSequenceNumber;

            if (PacketOptions.MessageLength)
            {
                MessageLength = PacketOptions.MessageLength;
                ASSERT (DataBytes <= MessageLength - PacketOptions.MessageOffset);
            }
            else
            {
                MessageLength = DataBytes;
                ASSERT (!PacketOptions.MessageOffset);
            }

            //
            // If we have a NULL packet, then skip it
            //
            if ((!DataBytes) ||
                (PacketOptions.MessageOffset == MessageLength))
            {
                PgmTrace (LogPath, ("PgmHandleNewData:  "  \
                    "Dropping SeqNum=[%d] since it's a NULL message [%d / %d]!\n",
                        (ULONG) (pReceiver->NextODataSequenceNumber),
                        PacketOptions.MessageOffset, PacketOptions.MessageLength));

                BytesTaken = DataBytes;
                status = STATUS_SUCCESS;
            }
            else
            {
                ASSERT (!(pReceive->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED));
                pReceive->SessionFlags |= PGM_SESSION_FLAG_IN_INDICATE;

                status = PgmIndicateToClient (pAddress,
                                              pReceive,
                                              DataBytes,
                                              (((PUCHAR) pOData) + DataOffset),
                                              PacketOptions.MessageOffset,
                                              MessageLength,
                                              &BytesTaken,
                                              pOldIrqAddress,
                                              pOldIrqReceive);

                pReceive->SessionFlags &= ~(PGM_SESSION_FLAG_IN_INDICATE | PGM_SESSION_FLAG_FIRST_PACKET);

                pReceive->DataBytes += BytesTaken;

                PgmTrace (LogPath, ("PgmHandleNewData:  "  \
                    "SeqNum=[%d]: PgmIndicate returned<%x>\n",
                        (ULONG) ThisDataSequenceNumber, status));

                ASSERT (BytesTaken <= DataBytes);

                if (!NT_SUCCESS (status))
                {
                    //
                    // If the client cannot accept any more data at this time, so
                    // we will try again later, otherwise terminate this session!
                    //
                    if (status != STATUS_DATA_NOT_ACCEPTED)
                    {
                        ASSERT (0);
                        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                        BytesTaken = DataBytes;
                    }
                }
            }

            if (BytesTaken == DataBytes)
            {
                if ((PacketType == PACKET_TYPE_RDATA) &&
                    (pLastNak->FirstNcfTickCount))
                {
                    AdjustNcfRDataResponseTimes (pReceive, pLastNak);
                }

                FreeNakContext (pReceive, pLastNak);
                AdjustReceiveBufferLists (pReceive); // move any additional complete groups to the BufferedDataList

                return (status);
            }

            fPartiallyIndicated = TRUE;
            InsertHeadList (&pReceiver->BufferedDataList, &pLastNak->Linkage);
        }
    }

#ifdef MAX_BUFF_DBG
{
    if (pReceiver->NumPacketGroupsPendingClient > MaxPacketGroupsPendingClient)
    {
        MaxPacketGroupsPendingClient = pReceiver->NumPacketGroupsPendingClient;
    }
    if (pReceiver->TotalDataPacketsBuffered >= MaxPacketsBuffered)
    {
        MaxPacketsBuffered = pReceiver->TotalDataPacketsBuffered;
    }
    if (pReceiver->DataPacketsPendingIndicate >= MaxPacketsPendingIndicate)
    {
        MaxPacketsPendingIndicate = pReceiver->DataPacketsPendingIndicate;
    }
    if (pReceiver->DataPacketsPendingNaks >= MaxPacketsPendingNaks)
    {
        MaxPacketsPendingNaks = pReceiver->DataPacketsPendingNaks;
    }
    ASSERT (pReceiver->TotalDataPacketsBuffered == (pReceiver->DataPacketsPendingIndicate +
                                                              pReceiver->DataPacketsPendingNaks));
}
#endif  // MAX_BUFF_DBG

    if (pReceiver->TotalDataPacketsBuffered >= pReceiver->MaxPacketsBufferedInLookaside)
    {
        PgmTrace (LogError, ("PgmHandleNewData: ERROR -- "  \
            "[%d -- %d]:  Excessive number of packets buffered=<%d> > <%d>, Aborting ...\n",
                (ULONG) pReceiver->FirstNakSequenceNumber, (ULONG) ThisDataSequenceNumber,
                (ULONG) pReceiver->TotalDataPacketsBuffered,
                (ULONG) pReceiver->MaxPacketsBufferedInLookaside));

        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // First, check if we are a data packet
    // (save unique data packets even if we have extra parity packets)
    // This can help save CPU!
    //
    pDataBuffer = NULL;
    NakIndex = pLastNak->NumDataPackets + pLastNak->NumParityPackets;
    if (fIsParityPacket)
    {
        BufferLength = PacketLength + sizeof(tPOST_PACKET_FEC_CONTEXT) - sizeof(USHORT);
    }
    else if ((PacketLength + sizeof (tPOST_PACKET_FEC_CONTEXT)) <= pLastNak->MinPacketLength)
    {
        BufferLength = pLastNak->MinPacketLength;
    }
    else
    {
        BufferLength = PacketLength + sizeof(tPOST_PACKET_FEC_CONTEXT);
    }
    pDataBuffer = NULL;

    if (!fIsParityPacket)
    {
        ASSERT (PacketIndex < pReceive->FECGroupSize);
        ASSERT (pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket == pLastNak->OriginalGroupSize);

        //
        // If we have some un-needed parity packets, we
        // can free that memory now
        //
        if (NakIndex >= pLastNak->PacketsInGroup)
        {
            ASSERT (pLastNak->NumParityPackets);
            for (i=0; i<pLastNak->PacketsInGroup; i++)
            {
                if (pLastNak->pPendingData[i].PacketIndex >= pLastNak->OriginalGroupSize)
                {
                    pDataBuffer = ReAllocateDataBuffer (pReceive, &pLastNak->pPendingData[i], BufferLength);
                    BufferLength = 0;

                    break;
                }
            }
            ASSERT (i < pLastNak->PacketsInGroup);
            pLastNak->NumParityPackets--;
            NakIndex = i;
        }
        else
        {
            ASSERT (!pLastNak->pPendingData[NakIndex].pDataPacket);
        }

        if (BufferLength)
        {
            pDataBuffer = AllocateDataBuffer (pReceive, &pLastNak->pPendingData[NakIndex], BufferLength);
        }

        if (!pDataBuffer)
        {
            PgmTrace (LogError, ("PgmHandleNewData: ERROR -- "  \
                "[%d]:  STATUS_INSUFFICIENT_RESOURCES <%d> bytes, NumDataPackets=<%d>, Aborting ...\n",
                    (ULONG) ThisDataSequenceNumber, pLastNak->MinPacketLength,
                    (ULONG) pReceiver->TotalDataPacketsBuffered));

            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        ASSERT (pLastNak->pPendingData[NakIndex].pDataPacket == pDataBuffer);

        PgmCopyMemory (pDataBuffer, pOData, PacketLength);

        pLastNak->pPendingData[NakIndex].PacketLength = PacketLength;
        pLastNak->pPendingData[NakIndex].DataOffset = (USHORT) (DataOffset + BytesTaken);
        pLastNak->pPendingData[NakIndex].PacketIndex = PacketIndex;
        pLastNak->pPendingData[PacketIndex].ActualIndexOfDataPacket = NakIndex;

        pLastNak->NumDataPackets++;
        pReceive->DataBytes += PacketLength - (DataOffset + BytesTaken);

        ASSERT (!(PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_GRP));

        //
        // Save some options for future reference
        //
        if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FRAGMENT)
        {
            pLastNak->pPendingData[NakIndex].FragmentOptSpecific = 0;
            pLastNak->pPendingData[NakIndex].MessageFirstSequence = PacketOptions.MessageFirstSequence;
            pLastNak->pPendingData[NakIndex].MessageLength = PacketOptions.MessageLength;
            pLastNak->pPendingData[NakIndex].MessageOffset = PacketOptions.MessageOffset + BytesTaken;
        }
        else
        {
            //
            // This is not a fragment
            //
            pLastNak->pPendingData[NakIndex].FragmentOptSpecific = PACKET_OPTION_SPECIFIC_ENCODED_NULL_BIT;

            pLastNak->pPendingData[NakIndex].MessageFirstSequence = (ULONG) (SEQ_TYPE) (pLastNak->SequenceNumber + PacketIndex);
            pLastNak->pPendingData[NakIndex].MessageOffset = BytesTaken;
            pLastNak->pPendingData[NakIndex].MessageLength = PacketLength - DataOffset;
        }
    }
    else
    {
        ASSERT (PacketIndex >= pLastNak->OriginalGroupSize);
        ASSERT (NakIndex < pLastNak->PacketsInGroup);
        ASSERT (!pLastNak->pPendingData[NakIndex].pDataPacket);

        pDataBuffer = AllocateDataBuffer (pReceive, &pLastNak->pPendingData[NakIndex], BufferLength);
        if (!pDataBuffer)
        {
            PgmTrace (LogError, ("PgmHandleNewData: ERROR -- "  \
                "[%d -- Parity]:  STATUS_INSUFFICIENT_RESOURCES <%d> bytes, NumDataPackets=<%d>, Aborting ...\n",
                    (ULONG) ThisDataSequenceNumber, PacketLength,
                    (ULONG) pReceiver->TotalDataPacketsBuffered));

            pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
            return (STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // This is a new parity packet
        //
        ASSERT (pLastNak->pPendingData[NakIndex].pDataPacket == pDataBuffer);

        PgmCopyMemory (pDataBuffer, pOData, PacketLength);
        pLastNak->pPendingData[NakIndex].PacketLength = PacketLength;
        pLastNak->pPendingData[NakIndex].DataOffset = (USHORT) DataOffset;
        pLastNak->pPendingData[NakIndex].PacketIndex = PacketIndex;

        pLastNak->pPendingData[NakIndex].FragmentOptSpecific = PacketOptions.FECContext.FragmentOptSpecific;
        pLastNak->pPendingData[NakIndex].MessageFirstSequence = PacketOptions.MessageFirstSequence;
        pLastNak->pPendingData[NakIndex].MessageLength = PacketOptions.MessageLength;
        pLastNak->pPendingData[NakIndex].MessageOffset = PacketOptions.MessageOffset + BytesTaken;

        pLastNak->NumParityPackets++;
        pReceive->DataBytes += PacketLength - DataOffset;

        if (!pLastNak->ParityDataSize)
        {
            pLastNak->ParityDataSize = (USHORT) (PacketLength - DataOffset);
        }
        else
        {
            ASSERT (pLastNak->ParityDataSize == (USHORT) (PacketLength - DataOffset));
        }
    }

    if ((PacketType == PACKET_TYPE_RDATA) &&
        (pLastNak->FirstNcfTickCount) &&
        (((pLastNak->NumDataPackets + pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
         ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup)))
    {
        AdjustNcfRDataResponseTimes (pReceive, pLastNak);
    }

    pLastNak->AllOptionsFlags |= PacketOptions.OptionsFlags;

    pReceiver->TotalDataPacketsBuffered++;
    if (fPartiallyIndicated)
    {
        pReceiver->NumPacketGroupsPendingClient++;
        pReceiver->DataPacketsPendingIndicate++;
        pReceiver->NextODataSequenceNumber = ThisDataSequenceNumber;
    }
    else
    {
        pReceiver->DataPacketsPendingNaks++;

        //
        // See if this group is complete
        //
        if (((pLastNak->NumDataPackets + pLastNak->NumParityPackets) >= pLastNak->PacketsInGroup) ||
            ((pLastNak->NextIndexToIndicate + pLastNak->NumDataPackets) >= pLastNak->PacketsInGroup))
        {
            RemovePendingReceiverEntry (pLastNak);
            AdjustReceiveBufferLists (pReceive);
        }
    }

    PgmTrace (LogAllFuncs, ("PgmHandleNewData:  "  \
        "SeqNum=[%d]: NumOutOfOrder=<%d> ...\n",
            (ULONG) ThisDataSequenceNumber, pReceiver->TotalDataPacketsBuffered));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessDataPacket(
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  ULONG                               PacketLength,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pODataBuffer,
    IN  UCHAR                               PacketType
    )
/*++

Routine Description:

    This routine looks at the data packet received from the wire
    and handles it appropriately depending on whether it is in order
    or not

Arguments:

    IN  pAddress                -- Address object context
    IN  pReceive                -- Receive context
    IN  PacketLength            -- Length of packet received from the wire
    IN  pODataBuffer            -- Data packet
    IN  PacketType              -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                    status;
    SEQ_TYPE                    ThisPacketSequenceNumber;
    SEQ_TYPE                    ThisTrailingEdge;
    tNAK_FORWARD_DATA           *pNextNak;
    ULONG                       DisconnectFlag;
    PGMLockHandle               OldIrq, OldIrq1;
    ULONG                       ulData;

    if (PacketLength < sizeof(tBASIC_DATA_PACKET_HEADER))
    {
        PgmTrace (LogError, ("ProcessDataPacket: ERROR -- "  \
            "PacketLength=<%d> < tBASIC_DATA_PACKET_HEADER=<%d>\n",
                PacketLength, sizeof(tBASIC_DATA_PACKET_HEADER)));
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (pAddress, OldIrq);
    PgmLock (pReceive, OldIrq1);

    if (pReceive->SessionFlags & (PGM_SESSION_CLIENT_DISCONNECTED |
                                  PGM_SESSION_TERMINATED_ABORT))
    {
        PgmTrace (LogPath, ("ProcessDataPacket:  "  \
            "Dropping packet because session is terminating!\n"));
        pReceive->pReceiver->NumDataPacketsDropped++;

        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmCopyMemory (&ulData, &pODataBuffer->DataSequenceNumber, sizeof(ULONG));
    ThisPacketSequenceNumber = (SEQ_TYPE) ntohl (ulData);

    PgmCopyMemory (&ulData, &pODataBuffer->TrailingEdgeSequenceNumber, sizeof(ULONG));
    ThisTrailingEdge = (SEQ_TYPE) ntohl (ulData);

    ASSERT (ntohl (ulData) == (LONG) ThisTrailingEdge);

    //
    // Update our Window information (use offset from Leading edge to account for wrap-around)
    //
    if (SEQ_GT (ThisTrailingEdge, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->pReceiver->LastTrailingEdgeSeqNum = ThisTrailingEdge;
    }

    //
    // If the next packet we are expecting is out-of-range, then we
    // should terminate the session
    //
    if (SEQ_LT (pReceive->pReceiver->FirstNakSequenceNumber, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, (1 + pReceive->pReceiver->FurthestKnownGroupSequenceNumber)))
        {
            PgmTrace (LogStatus, ("ProcessDataPacket:  "  \
                "NETWORK problems -- data loss=<%d> packets > window size!\n\tExpecting=<%d>, FurthestKnown=<%d>, Window=[%d--%d]=<%d> seqs\n",
                    (ULONG) (1 + ThisPacketSequenceNumber -
                             pReceive->pReceiver->FurthestKnownGroupSequenceNumber),
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) ThisTrailingEdge, (ULONG) ThisPacketSequenceNumber,
                    (ULONG) (1+ThisPacketSequenceNumber-ThisTrailingEdge)));
        }
        else
        {
            ASSERT (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
            pNextNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);

            PgmTrace (LogStatus, ("ProcessDataPacket:  "  \
                "Session window has past TrailingEdge -- Expecting=<%d==%d>, NumNcfs=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pNextNak->SequenceNumber,
                    (ULONG) pNextNak->WaitingRDataRetries,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum,
                    (ULONG) ThisPacketSequenceNumber,
                    (ULONG) (1+ThisPacketSequenceNumber-ThisTrailingEdge)));
        }
    }
    else if (SEQ_GT (pReceive->pReceiver->FirstNakSequenceNumber, ThisPacketSequenceNumber))
    {
        //
        // Drop this packet since it is earlier than our window
        //
        pReceive->pReceiver->NumDupPacketsOlderThanWindow++;

        PgmTrace (LogPath, ("ProcessDataPacket:  "  \
            "Dropping this packet, SeqNum=[%d] < NextOData=[%d]\n",
                (ULONG) ThisPacketSequenceNumber, (ULONG) pReceive->pReceiver->FirstNakSequenceNumber));
    }
    else
    {
        if (PacketType == PACKET_TYPE_ODATA)
        {
            UpdateRealTimeWindowInformation (pReceive, ThisPacketSequenceNumber, ThisTrailingEdge);
        }

        status = PgmHandleNewData (&ThisPacketSequenceNumber,
                                   pAddress,
                                   pReceive,
                                   (USHORT) PacketLength,
                                   pODataBuffer,
                                   PacketType,
                                   &OldIrq,
                                   &OldIrq1);

        PgmTrace (LogPath, ("ProcessDataPacket:  "  \
            "PgmHandleNewData returned <%x>, SeqNum=[%d] < NextOData=[%d]\n",
                status, (ULONG) ThisPacketSequenceNumber, (ULONG) pReceive->pReceiver->NextODataSequenceNumber));

        //
        // Now, try to indicate any data which may still be pending
        //
        status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);
    }

    CheckIndicateDisconnect (pAddress, pReceive, &OldIrq, &OldIrq1, TRUE);

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessSpmPacket(
    IN  tADDRESS_CONTEXT                    *pAddress,
    IN  tRECEIVE_SESSION                    *pReceive,
    IN  ULONG                               PacketLength,
    IN  tBASIC_SPM_PACKET_HEADER UNALIGNED  *pSpmPacket
    )
/*++

Routine Description:

    This routine processes Spm packets

Arguments:

    IN  pAddress        -- Address object context
    IN  pReceive        -- Receive context
    IN  PacketLength    -- Length of packet received from the wire
    IN  pSpmPacket      -- Spm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    SEQ_TYPE                        SpmSequenceNumber, LeadingEdgeSeqNumber, TrailingEdgeSeqNumber;
    LIST_ENTRY                      *pEntry;
    ULONG                           DisconnectFlag;
    NTSTATUS                        status;
    PGMLockHandle                   OldIrq, OldIrq1;
    tPACKET_OPTIONS                 PacketOptions;
    PNAK_FORWARD_DATA               pNak;
    USHORT                          TSDULength;
    tNLA                            PathNLA;
    BOOLEAN                         fFirstSpm;
    ULONG                           ulData;

    //
    // First process the options
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pSpmPacket->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pSpmPacket + 1),
                                 (PacketLength - sizeof(tBASIC_SPM_PACKET_HEADER)),
                                 (pSpmPacket->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
                "ProcessOptions returned <%x>\n", status));

            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }
    ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_SPM_OPTION_FLAGS) == 0);

    PgmCopyMemory (&PathNLA, &pSpmPacket->PathNLA, sizeof (tNLA));
    PgmCopyMemory (&TSDULength, &pSpmPacket->CommonHeader.TSDULength, sizeof (USHORT));
    TSDULength = ntohs (TSDULength);

    PathNLA.NLA_AFI = ntohs (PathNLA.NLA_AFI);

    if ((TSDULength) ||
        (IPV4_NLA_AFI != PathNLA.NLA_AFI) ||
        (!PathNLA.IpAddress))
    {
        PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
            "TSDULength=<%d>, PathNLA.IpAddress=<%x>\n",
                (ULONG) TSDULength, PathNLA.IpAddress));

        return (STATUS_DATA_NOT_ACCEPTED);
    }
    
    PgmCopyMemory (&ulData, &pSpmPacket->SpmSequenceNumber, sizeof (ULONG));
    SpmSequenceNumber = (SEQ_TYPE) ntohl (ulData);
    PgmCopyMemory (&ulData, &pSpmPacket->LeadingEdgeSeqNumber, sizeof (ULONG));
    LeadingEdgeSeqNumber = (SEQ_TYPE) ntohl (ulData);
    PgmCopyMemory (&ulData, &pSpmPacket->TrailingEdgeSeqNumber, sizeof (ULONG));
    TrailingEdgeSeqNumber = (SEQ_TYPE) ntohl (ulData);

    //
    // Verify Packet length
    //
    if ((sizeof(tBASIC_SPM_PACKET_HEADER) + PacketOptions.OptionsLength) != PacketLength)
    {
        PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
            "Bad PacketLength=<%d>, OptionsLength=<%d>, TSDULength=<%d>\n",
                PacketLength, PacketOptions.OptionsLength, (ULONG) TSDULength));
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (pAddress, OldIrq);

    if (!pReceive)
    {
        //
        // Since we do not have a live connection yet, we will
        // have to store some state in the Address context
        //
        PgmTrace (LogPath, ("ProcessSpmPacket:  "  \
            "[%d] Received SPM before OData for session, LastSpmSource=<%x>, FEC %sabled, Window=[%d - %d]\n",
                SpmSequenceNumber, PathNLA.IpAddress,
                (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM ? "EN" : "DIS"),
                (ULONG) TrailingEdgeSeqNumber, (ULONG) LeadingEdgeSeqNumber));

        if ((ntohs (PathNLA.NLA_AFI) == IPV4_NLA_AFI) &&
            (PathNLA.IpAddress))
        {
            pAddress->LastSpmSource = ntohl (PathNLA.IpAddress);
        }

        //
        // Check if the sender is FEC-enabled
        //
        if ((PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM) &&
            (PacketOptions.FECContext.ReceiverFECOptions) &&
            (PacketOptions.FECContext.FECGroupInfo > 1))
        {
            pAddress->FECOptions = PacketOptions.FECContext.ReceiverFECOptions;
            pAddress->FECGroupSize = (UCHAR) PacketOptions.FECContext.FECGroupInfo;
            ASSERT (PacketOptions.FECContext.FECGroupInfo == pAddress->FECGroupSize);
        }

        PgmUnlock (pAddress, OldIrq);
        return (STATUS_SUCCESS);
    }

    PgmLock (pReceive, OldIrq1);
    UpdateSpmIntervalInformation (pReceive);

    //
    // If this is not the first SPM packet (LastSpmSource is not NULL), see if it is out-of-sequence,
    // otherwise take this as the first packet
    //
    if ((pReceive->pReceiver->LastSpmSource) &&
        (SEQ_LEQ (SpmSequenceNumber, pReceive->pReceiver->LastSpmSequenceNumber)))
    {
        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        PgmTrace (LogAllFuncs, ("ProcessSpmPacket:  "  \
            "Out-of-sequence SPM Packet received!\n"));

        return (STATUS_DATA_NOT_ACCEPTED);
    }
    pReceive->pReceiver->LastSpmSequenceNumber = SpmSequenceNumber;

    //
    // Save the last Sender NLA
    //
    if ((ntohs(PathNLA.NLA_AFI) == IPV4_NLA_AFI) &&
        (PathNLA.IpAddress))
    {
        pReceive->pReceiver->LastSpmSource = ntohl (PathNLA.IpAddress);
    }
    else
    {
        pReceive->pReceiver->LastSpmSource = pReceive->pReceiver->SenderIpAddress;
    }

    UpdateRealTimeWindowInformation (pReceive, LeadingEdgeSeqNumber, TrailingEdgeSeqNumber);

    //
    // Update the trailing edge if this is more ahead
    //
    if (SEQ_GT (TrailingEdgeSeqNumber, pReceive->pReceiver->LastTrailingEdgeSeqNum))
    {
        pReceive->pReceiver->LastTrailingEdgeSeqNum = TrailingEdgeSeqNumber;
    }

    if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, pReceive->pReceiver->FirstNakSequenceNumber))
    {
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
        if (SEQ_GT (pReceive->pReceiver->LastTrailingEdgeSeqNum, (1 + pReceive->pReceiver->FurthestKnownGroupSequenceNumber)))
        {
            PgmTrace (LogStatus, ("ProcessSpmPacket:  "  \
                "NETWORK problems -- data loss=<%d> packets > window size!\n\tExpecting=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) (1 + LeadingEdgeSeqNumber -
                             pReceive->pReceiver->FurthestKnownGroupSequenceNumber),
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum, LeadingEdgeSeqNumber,
                    (ULONG) (1+LeadingEdgeSeqNumber-pReceive->pReceiver->LastTrailingEdgeSeqNum)));
        }
        else
        {
            ASSERT (!IsListEmpty (&pReceive->pReceiver->NaksForwardDataList));
            pNak = CONTAINING_RECORD (pReceive->pReceiver->NaksForwardDataList.Flink, tNAK_FORWARD_DATA, Linkage);

            PgmTrace (LogStatus, ("ProcessSpmPacket:  "  \
                "Session window has past TrailingEdge -- Expecting <%d==%d>, NumNcfs=<%d>, FurthestKnown=<%d>, Window=[%d--%d] = < %d > seqs\n",
                    (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                    (ULONG) pNak->SequenceNumber,
                    pNak->WaitingRDataRetries,
                    (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber,
                    (ULONG) pReceive->pReceiver->LastTrailingEdgeSeqNum, LeadingEdgeSeqNumber,
                    (ULONG) (1+LeadingEdgeSeqNumber-pReceive->pReceiver->LastTrailingEdgeSeqNum)));
        }
    }

    //
    // If the Leading edge is > our current leading edge, then
    // we need to send NAKs for the missing data Packets
    //
    pNak = NULL;
    if (SEQ_GEQ (LeadingEdgeSeqNumber, pReceive->pReceiver->FirstNakSequenceNumber))
    {
        status = CheckAndAddNakRequests (pReceive, &LeadingEdgeSeqNumber, &pNak, NAK_PENDING_RB, TRUE);
        if (!NT_SUCCESS (status))
        {
            PgmUnlock (pReceive, OldIrq1);
            PgmUnlock (pAddress, OldIrq);

            PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
                "CheckAndAddNakRequests returned <%x>\n", status));

            return (status);
        }
    }

    //
    // Now, process all the options
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_RST_N)
    {
        pReceive->pReceiver->FinDataSequenceNumber = pReceive->pReceiver->FurthestKnownGroupSequenceNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

        PgmTrace (LogStatus, ("ProcessSpmPacket:  "  \
            "Got an RST_N!  FinSeq=<%d>, NextODataSeq=<%d>, FurthestData=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber));
    }
    else if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_RST)
    {
        pReceive->pReceiver->FinDataSequenceNumber = LeadingEdgeSeqNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

        PgmTrace (LogStatus, ("ProcessSpmPacket:  "  \
            "Got an RST!  FinSeq=<%d>, NextODataSeq=<%d>, FurthestData=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber));
    }
    else if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_FIN)
    {
        pReceive->pReceiver->FinDataSequenceNumber = LeadingEdgeSeqNumber;
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_GRACEFULLY;

        PgmTrace (LogStatus, ("ProcessSpmPacket:  "  \
            "Got a FIN!  FinSeq=<%d>, NextODataSeq=<%d>, FirstNak=<%d>, FurthestKnown=<%d>, FurthestGroup=<%d>\n",
                (ULONG) pReceive->pReceiver->FinDataSequenceNumber,
                (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
                (ULONG) pReceive->pReceiver->FirstNakSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownSequenceNumber,
                (ULONG) pReceive->pReceiver->FurthestKnownGroupSequenceNumber));

        //
        // See if we need to set the Fin Sequence #
        //
        if (pNak)
        {
            ASSERT (pNak->SequenceNumber == (LeadingEdgeSeqNumber & ~(pReceive->FECGroupSize-1)));
            pNak->PacketsInGroup = (UCHAR) (LeadingEdgeSeqNumber + 1 - pNak->SequenceNumber);
            ASSERT (pNak->PacketsInGroup <= pReceive->FECGroupSize);

            RemoveRedundantNaks (pReceive, pNak, TRUE);
            AdjustReceiveBufferLists (pReceive);
        }
    }

    //
    // See if we need to abort
    //
    if (CheckIndicateDisconnect (pAddress, pReceive, &OldIrq, &OldIrq1, TRUE))
    {
        PgmUnlock (pReceive, OldIrq1);
        PgmUnlock (pAddress, OldIrq);

        return (STATUS_SUCCESS);
    }

    //
    // Check if the sender is FEC-enabled
    //
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_PRM)
    {
        if ((pReceive->FECGroupSize == 1) &&
            (PacketOptions.FECContext.ReceiverFECOptions) &&
            (PacketOptions.FECContext.FECGroupInfo > 1))
        {
            ASSERT (!pReceive->pFECBuffer);

            if (!(pReceive->pFECBuffer = PgmAllocMem ((pReceive->MaxFECPacketLength * PacketOptions.FECContext.FECGroupInfo*2), PGM_TAG('3'))))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;

                PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
                    "STATUS_INSUFFICIENT_RESOURCES -- MaxFECPacketLength = <%d>, GroupSize=<%d>\n",
                        pReceive->MaxFECPacketLength, PacketOptions.FECContext.FECGroupInfo));

            }
            else if (!NT_SUCCESS (status = CreateFECContext (&pReceive->FECContext, PacketOptions.FECContext.FECGroupInfo, FEC_MAX_BLOCK_SIZE, TRUE)))
            {
                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
                    "CreateFECContext returned <%x>\n", status));
            }
            else if (!NT_SUCCESS (status = CoalesceSelectiveNaksIntoGroups (pReceive, (UCHAR) PacketOptions.FECContext.FECGroupInfo)))
            {
                DestroyFECContext (&pReceive->FECContext);

                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmTrace (LogError, ("ProcessSpmPacket: ERROR -- "  \
                    "CoalesceSelectiveNaksIntoGroups returned <%x>\n", status));
            }
            else
            {
                pReceive->FECOptions = PacketOptions.FECContext.ReceiverFECOptions;
                pReceive->FECGroupSize = (UCHAR) PacketOptions.FECContext.FECGroupInfo;
                if (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
                {
                    pReceive->pReceiver->SessionNakType = NAK_TYPE_PARITY;
                }
                ASSERT (PacketOptions.FECContext.FECGroupInfo == pReceive->FECGroupSize);
            }


            if (!NT_SUCCESS (status))
            {
                PgmUnlock (pReceive, OldIrq1);
                PgmUnlock (pAddress, OldIrq);
                return (STATUS_DATA_NOT_ACCEPTED);
            }

            fFirstSpm = TRUE;
        }
        else
        {
            fFirstSpm = FALSE;
        }

        if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_PARITY_CUR_TGSIZE)
        {
            //
            // The Leading edge Packet belongs to a Variable sized group
            // so set that information appropriately
            // Determine the group to which this leading edge belongs to
            //
            LeadingEdgeSeqNumber &= ~((SEQ_TYPE) (pReceive->FECGroupSize-1));

            if ((PacketOptions.FECContext.NumPacketsInThisGroup) &&
                (PacketOptions.FECContext.NumPacketsInThisGroup < pReceive->FECGroupSize) &&
                SEQ_GEQ (LeadingEdgeSeqNumber, pReceive->pReceiver->FirstNakSequenceNumber) &&
                (pNak = FindReceiverEntry (pReceive->pReceiver, LeadingEdgeSeqNumber)) &&
                (pNak->PacketsInGroup == pReceive->FECGroupSize))
            {
                    //
                    // We have already coalesced the list, so the packets should
                    // be ordered into groups!
                    //
                    pNak->PacketsInGroup = PacketOptions.FECContext.NumPacketsInThisGroup;
                    if (pNak->SequenceNumber == pReceive->pReceiver->FurthestKnownGroupSequenceNumber)
                    {
                        pReceive->pReceiver->FurthestKnownSequenceNumber = pNak->SequenceNumber + pNak->PacketsInGroup - 1;
                    }
                    RemoveRedundantNaks (pReceive, pNak, TRUE);
            }
            else
            {
                PgmTrace (LogPath, ("ProcessSpmPacket:  "  \
                    "WARNING .. PARITY_CUR_TGSIZE ThisGroupSize=<%x>, FECGroupSize=<%x>\n",
                        PacketOptions.FECContext.NumPacketsInThisGroup, pReceive->FECGroupSize));
            }
        }
    }

    status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    PgmTrace (LogAllFuncs, ("ProcessSpmPacket:  "  \
        "NextOData=<%d>, FinDataSeq=<%d> \n",
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber,
            (ULONG) pReceive->pReceiver->FinDataSequenceNumber));

    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmProcessIncomingPacket(
    IN  tADDRESS_CONTEXT            *pAddress,
    IN  tCOMMON_SESSION_CONTEXT     *pSession,
    IN  INT                         SourceAddressLength,
    IN  PTA_IP_ADDRESS              pRemoteAddress,
    IN  ULONG                       PacketLength,
    IN  tCOMMON_HEADER UNALIGNED    *pPgmHeader,
    IN  UCHAR                       PacketType
    )
/*++

Routine Description:

    This routine process an incoming packet and calls the
    appropriate handler depending on whether is a data packet
    packet, etc.

Arguments:

    IN  pAddress            -- Address object context
    IN  pReceive            -- Receive context
    IN  SourceAddressLength -- Length of source address
    IN  pRemoteAddress      -- Address of remote host
    IN  PacketLength        -- Length of packet received from the wire
    IN  pPgmHeader          -- Pgm packet
    IN  PacketType          -- Type of Pgm packet

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    tIPADDRESS                              SrcIpAddress;
    tNLA                                    SourceNLA, MCastGroupNLA;
    tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED  *pNakNcfPacket;
    NTSTATUS                                status = STATUS_SUCCESS;

    //
    // We have an active connection for this TSI, so process the data appropriately
    //

    //
    // First check for SPM packets
    //
    if (PACKET_TYPE_SPM == PacketType)
    {
        if (PacketLength < sizeof(tBASIC_SPM_PACKET_HEADER))
        {
            PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
                "Bad SPM Packet length:  PacketLength=<%d> < sizeof(tBASIC_SPM_PACKET_HEADER)=<%d>\n",
                    PacketLength, sizeof(tBASIC_SPM_PACKET_HEADER)));

            return (STATUS_DATA_NOT_ACCEPTED);
        }

        if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
        {
            pSession->TotalBytes += PacketLength;
            pSession->TotalPacketsReceived++;
            pSession->pReceiver->LastSessionTickCount = PgmDynamicConfig.ReceiversTimerTickCount;

            status = ProcessSpmPacket (pAddress,
                                       pSession,
                                       PacketLength,
                                       (tBASIC_SPM_PACKET_HEADER UNALIGNED *) pPgmHeader);

            PgmTrace (LogAllFuncs, ("PgmProcessIncomingPacket:  "  \
                "SPM PacketType=<%x> for pSession=<%p> PacketLength=<%d>, status=<%x>\n",
                    PacketType, pSession, PacketLength, status));
        }
        else
        {
            PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
                "Received SPM packet, not on Receiver session!  pSession=<%p>\n", pSession));
            status = STATUS_DATA_NOT_ACCEPTED;
        }

        return (status);
    }

    //
    // The only other packets we process are Nak and Ncf packets, so ignore the rest!
    //
    if ((PACKET_TYPE_NCF != PacketType) &&
        (PACKET_TYPE_NAK != PacketType))
    {
        PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
            "Unknown PacketType=<%x>, PacketLength=<%d>\n", PacketType, PacketLength));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now, verify packet info for Nak and Ncf packets
    //
    if (PacketLength < sizeof(tBASIC_NAK_NCF_PACKET_HEADER))
    {
        PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
            "NakNcf packet!  PacketLength=<%d>, Min=<%d>, ...\n",
                PacketLength, sizeof(tBASIC_NAK_NCF_PACKET_HEADER)));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    pNakNcfPacket = (tBASIC_NAK_NCF_PACKET_HEADER UNALIGNED *) pPgmHeader;
    PgmCopyMemory (&SourceNLA, &pNakNcfPacket->SourceNLA, sizeof (tNLA));
    PgmCopyMemory (&MCastGroupNLA, &pNakNcfPacket->MCastGroupNLA, sizeof (tNLA));
    if (((htons(IPV4_NLA_AFI) != SourceNLA.NLA_AFI) || (!SourceNLA.IpAddress)) ||
        ((htons(IPV4_NLA_AFI) != MCastGroupNLA.NLA_AFI) || (!MCastGroupNLA.IpAddress)))
    {
        PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
            "NakNcf packet!  PacketLength=<%d>, Min=<%d>, ...\n",
                PacketLength, sizeof(tBASIC_NAK_NCF_PACKET_HEADER)));

        return (STATUS_DATA_NOT_ACCEPTED);
    }


    if (PACKET_TYPE_NCF == PacketType)
    {
        if (PGM_VERIFY_HANDLE (pSession, PGM_VERIFY_SESSION_RECEIVE))
        {
            status = ReceiverProcessNakNcfPacket (pAddress,
                                                  pSession,
                                                  PacketLength,
                                                  pNakNcfPacket,
                                                  PacketType);
        }
        else
        {
            PgmTrace (LogError, ("PgmProcessIncomingPacket: ERROR -- "  \
                "Received Ncf packet, not on Receiver session!  pSession=<%p>\n", pSession));
            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }
    //  Now process NAK packet
    else if (pSession->pSender)
    {
        ASSERT (!pSession->pReceiver);
        status = SenderProcessNakPacket (pAddress,
                                         pSession,
                                         PacketLength,
                                         pNakNcfPacket);
    }
    else
    {
        ASSERT (pSession->pReceiver);

        //
        // Check for Remote guy's address
        // If the Nak was sent by us, then we can ignore it!
        //
        if ((pRemoteAddress->TAAddressCount == 1) &&
            (pRemoteAddress->Address[0].AddressLength == TDI_ADDRESS_LENGTH_IP) &&
            (pRemoteAddress->Address[0].AddressType == TDI_ADDRESS_TYPE_IP) &&
            (SrcIpAddress = ntohl(((PTDI_ADDRESS_IP)&pRemoteAddress->Address[0].Address)->in_addr)) &&
            (!SrcIsUs (SrcIpAddress)) &&
            (SrcIsOnLocalSubnet (SrcIpAddress)))
        {
            status = ReceiverProcessNakNcfPacket (pAddress,
                                                  pSession,
                                                  PacketLength,
                                                  pNakNcfPacket,
                                                  PacketType);
        }

        ASSERT (NT_SUCCESS (status));
    }

    PgmTrace (LogAllFuncs, ("PgmProcessIncomingPacket:  "  \
        "PacketType=<%x> for pSession=<%p> PacketLength=<%d>, status=<%x>\n",
            PacketType, pSession, PacketLength, status));

    return (status);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmNewInboundConnection(
    IN tADDRESS_CONTEXT                     *pAddress,
    IN INT                                  SourceAddressLength,
    IN PVOID                                pSourceAddress,
    IN ULONG                                ReceiveDatagramFlags,
    IN  tBASIC_DATA_PACKET_HEADER UNALIGNED *pPgmHeader,
    IN ULONG                                PacketLength,
    OUT tRECEIVE_SESSION                    **ppReceive
    )
/*++

Routine Description:

    This routine processes a new incoming connection

Arguments:

    IN  pAddress            -- Address object context
    IN  SourceAddressLength -- Length of source address
    IN  pSourceAddress      -- Address of remote host
    IN  ReceiveDatagramFlags-- Flags set by the transport for this packet
    IN  pPgmHeader          -- Pgm packet
    IN  PacketLength        -- Length of packet received from the wire
    OUT ppReceive           -- pReceive context for this session returned by the client (if successful)

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                    status;
    tRECEIVE_SESSION            *pReceive;
    CONNECTION_CONTEXT          ConnectId;
    PIO_STACK_LOCATION          pIrpSp;
    TA_IP_ADDRESS               RemoteAddress;
    INT                         RemoteAddressSize;
    PTDI_IND_CONNECT            evConnect = NULL;
    PVOID                       ConEvContext = NULL;
    PGMLockHandle               OldIrq, OldIrq1, OldIrq2;
    PIRP                        pIrp = NULL;
    ULONG                       ulData;
    USHORT                      PortNum;
    SEQ_TYPE                    FirstODataSequenceNumber;
    tPACKET_OPTIONS             PacketOptions;

    //
    // We need to set the Next expected sequence number, so first see if
    // there is a late joiner option
    //
    PgmZeroMemory (&PacketOptions, sizeof (tPACKET_OPTIONS));
    if (pPgmHeader->CommonHeader.Options & PACKET_HEADER_OPTIONS_PRESENT)
    {
        status = ProcessOptions ((tPACKET_OPTION_LENGTH *) (pPgmHeader + 1),
                                 (PacketLength - sizeof(tBASIC_DATA_PACKET_HEADER)),
                                 (pPgmHeader->CommonHeader.Type & 0x0f),
                                 &PacketOptions,
                                 NULL);

        if (!NT_SUCCESS (status))
        {
            PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
                "ProcessOptions returned <%x>\n", status));
            return (STATUS_DATA_NOT_ACCEPTED);
        }
        ASSERT ((PacketOptions.OptionsFlags & ~PGM_VALID_DATA_OPTION_FLAGS) == 0);
    }

    PgmCopyMemory (&ulData, &pPgmHeader->DataSequenceNumber, sizeof (ULONG));
    FirstODataSequenceNumber = (SEQ_TYPE) ntohl (ulData);
    PgmLock (pAddress, OldIrq1);
    //
    // The Address is already referenced in the calling routine,
    // so we don not need to reference it here again!
    //
#if 0
    if (!IsListEmpty(&pAddress->ListenHead))
    {
        //
        // Ignore this for now  since we have not encountered posted listens! (Is this an ISSUE ?)
    }
#endif  // 0

    if (!(ConEvContext = pAddress->ConEvContext))
    {
        //
        // Client has not yet posted a Listen!
        // take all of the data so that a disconnect will not be held up
        // by data still in the transport.
        //
        PgmUnlock (pAddress, OldIrq1);

        PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
            "No Connect handler, pAddress=<%p>\n", pAddress));

        return (STATUS_DATA_NOT_ACCEPTED);
    }

    RemoteAddressSize = offsetof (TA_IP_ADDRESS, Address[0].Address) + sizeof(TDI_ADDRESS_IP);
    ASSERT (SourceAddressLength <= RemoteAddressSize);
    PgmCopyMemory (&RemoteAddress, pSourceAddress, RemoteAddressSize);
    PgmCopyMemory (&((PTDI_ADDRESS_IP) &RemoteAddress.Address[0].Address)->sin_port,
                   &pPgmHeader->CommonHeader.SrcPort, sizeof (USHORT));
    RemoteAddress.TAAddressCount = 1;
    evConnect = pAddress->evConnect;

    PgmUnlock (pAddress, OldIrq1);

    status = (*evConnect) (ConEvContext,
                           RemoteAddressSize,
                           &RemoteAddress,
                           0,
                           NULL,
                           0,          // options length
                           NULL,       // Options
                           &ConnectId,
                           &pIrp);

    if ((status != STATUS_MORE_PROCESSING_REQUIRED) ||
        (pIrp == NULL))
    {
        PgmTrace (LogPath, ("PgmNewInboundConnection:  "  \
            "Client REJECTed incoming session: status=<%x>, pAddress=<%p>, evConn=<%p>\n",
                status, pAddress, pAddress->evConnect));

        if (pIrp)
        {
            PgmIoComplete (pIrp, STATUS_INTERNAL_ERROR, 0);
        }

        *ppReceive = NULL;
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    PgmLock (&PgmDynamicConfig, OldIrq);
    PgmLock (pAddress, OldIrq1);

    //
    // the pReceive ptr was stored in the FsContext value when the connection
    // was initially created.
    //
    pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (pReceive->pAssociatedAddress != pAddress))
    {
        PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
            "pReceive=<%p>, pAddress=<%p : %p>\n",
                pReceive, (pReceive ? pReceive->pAssociatedAddress : NULL), pAddress));

        PgmUnlock (pAddress, OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmIoComplete (pIrp, STATUS_INTERNAL_ERROR, 0);
        *ppReceive = NULL;
        return (STATUS_INTERNAL_ERROR);
    }
    ASSERT (ConnectId == pReceive->ClientSessionContext);

    PgmLock (pReceive, OldIrq2);

    if (!(pReceive->pReceiver->pReceiveData = InitReceiverData (pReceive)))
    {
        pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

        PgmUnlock (pAddress, OldIrq2);
        PgmUnlock (&PgmDynamicConfig, OldIrq1);
        PgmUnlock (pReceive, OldIrq);

        PgmIoComplete (pIrp, STATUS_INSUFFICIENT_RESOURCES, 0);
        *ppReceive = NULL;

        PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
            "STATUS_INSUFFICIENT_RESOURCES allocating pReceiveData -- pReceive=<%p>, pAddress=<%p>\n",
                pReceive, pAddress));

        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    pReceive->pReceiver->SenderIpAddress = ntohl (((PTDI_ADDRESS_IP)&RemoteAddress.Address[0].Address)->in_addr);
    pReceive->MaxMTULength = (USHORT) PgmDynamicConfig.MaxMTU;
    pReceive->MaxFECPacketLength = pReceive->MaxMTULength +
                                   sizeof (tPOST_PACKET_FEC_CONTEXT) - sizeof (USHORT);
    ASSERT (!pReceive->pFECBuffer);

    if (pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED)
    {
        pReceive->pReceiver->MaxPacketsBufferedInLookaside = MAX_PACKETS_BUFFERED * 3;      // 9000, about 15 Megs!
        pReceive->pReceiver->InitialOutstandingNakTimeout = INITIAL_NAK_OUTSTANDING_TIMEOUT_MS_OPT /
                                                            BASIC_TIMER_GRANULARITY_IN_MSECS;
    }
    else
    {
        pReceive->pReceiver->MaxPacketsBufferedInLookaside = MAX_PACKETS_BUFFERED;
        pReceive->pReceiver->InitialOutstandingNakTimeout = INITIAL_NAK_OUTSTANDING_TIMEOUT_MSECS /
                                                            BASIC_TIMER_GRANULARITY_IN_MSECS;
    }
    ASSERT (pReceive->pReceiver->MaxPacketsBufferedInLookaside);
    ASSERT (pReceive->pReceiver->InitialOutstandingNakTimeout);
    pReceive->pReceiver->OutstandingNakTimeout = pReceive->pReceiver->InitialOutstandingNakTimeout;

    //
    // If we had received an Spm earlier, then we may need to set
    // some of the Spm-specific options
    //
    pReceive->FECGroupSize = 1;         // Default to non-parity mode
    pReceive->pReceiver->SessionNakType = NAK_TYPE_SELECTIVE;
    if ((pAddress->LastSpmSource) ||
        (pAddress->FECOptions))
    {
        if (pAddress->LastSpmSource)
        {
            pReceive->pReceiver->LastSpmSource = pAddress->LastSpmSource;
        }
        else
        {
            pReceive->pReceiver->LastSpmSource = pReceive->pReceiver->SenderIpAddress;
        }

        if (pAddress->FECOptions)
        {
            status = STATUS_SUCCESS;
            if (!(pReceive->pFECBuffer = PgmAllocMem ((pReceive->MaxFECPacketLength * pAddress->FECGroupSize * 2), PGM_TAG('3'))))
            {
                PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
                    "STATUS_INSUFFICIENT_RESOURCES allocating pFECBuffer, %d bytes\n",
                        (pReceive->MaxFECPacketLength * pAddress->FECGroupSize * 2)));

                status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else if (!NT_SUCCESS (status = CreateFECContext (&pReceive->FECContext, pAddress->FECGroupSize, FEC_MAX_BLOCK_SIZE, TRUE)))
            {
                PgmFreeMem (pReceive->pFECBuffer);
                pReceive->pFECBuffer = NULL;

                PgmTrace (LogError, ("PgmNewInboundConnection: ERROR -- "  \
                    "CreateFECContext returned <%x>\n", status));
            }

            if (!NT_SUCCESS (status))
            {
                if (pReceive->pReceiver->pReceiveData)
                {
                    PgmFreeMem (pReceive->pReceiver->pReceiveData);
                    pReceive->pReceiver->pReceiveData = NULL;
                }

                pReceive->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;

                PgmUnlock (pAddress, OldIrq2);
                PgmUnlock (&PgmDynamicConfig, OldIrq1);
                PgmUnlock (pReceive, OldIrq);

                PgmIoComplete (pIrp, status, 0);
                *ppReceive = NULL;
                return (STATUS_DATA_NOT_ACCEPTED);
            }

            ASSERT (pAddress->FECGroupSize > 1);
            pReceive->FECGroupSize = pAddress->FECGroupSize;
            pReceive->FECOptions = pAddress->FECOptions;
            if (pReceive->FECOptions & PACKET_OPTION_SPECIFIC_FEC_OND_BIT)
            {
                pReceive->pReceiver->SessionNakType = NAK_TYPE_PARITY;
            }

            ExInitializeNPagedLookasideList (&pReceive->pReceiver->ParityContextLookaside,
                                             NULL,
                                             NULL,
                                             0,
                                             (sizeof(tNAK_FORWARD_DATA) +
                                              ((pReceive->FECGroupSize-1) * sizeof(tPENDING_DATA))),
                                             PGM_TAG('2'),
                                             (USHORT) (pReceive->pReceiver->MaxPacketsBufferedInLookaside/pReceive->FECGroupSize));
        }

        pAddress->LastSpmSource = pAddress->FECOptions = pAddress->FECGroupSize = 0;
    }

    //
    // Initialize our Connect info
    // Save the SourceId and Src port for this connection
    //
    PgmCopyMemory (&PortNum, &pPgmHeader->CommonHeader.SrcPort, sizeof (USHORT));
    PgmCopyMemory (pReceive->TSI.GSI, pPgmHeader->CommonHeader.gSourceId, SOURCE_ID_LENGTH);
    pReceive->TSI.hPort = ntohs (PortNum);

    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TDI_RCV_HANDLER, TRUE);
    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_TIMER_RUNNING, TRUE);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_RECEIVE_ACTIVE, TRUE);
    pReceive->SessionFlags |= (PGM_SESSION_ON_TIMER | PGM_SESSION_FLAG_FIRST_PACKET);
    pReceive->pReceiver->pAddress = pAddress;

    pReceive->pReceiver->MaxBufferLength = pReceive->MaxMTULength + sizeof(tPOST_PACKET_FEC_CONTEXT);
    pReceive->pReceiver->DataBufferLookasideLength = pReceive->pReceiver->MaxBufferLength;
    pReceive->SessionFlags |= PGM_SESSION_DATA_FROM_LOOKASIDE;
    ExInitializeNPagedLookasideList (&pReceive->pReceiver->DataBufferLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     pReceive->pReceiver->DataBufferLookasideLength,
                                     PGM_TAG ('D'),
                                     pReceive->pReceiver->MaxPacketsBufferedInLookaside);

    ExInitializeNPagedLookasideList (&pReceive->pReceiver->NonParityContextLookaside,
                                     NULL,
                                     NULL,
                                     0,
                                     sizeof (tNAK_FORWARD_DATA),
                                     PGM_TAG ('2'),
                                     pReceive->pReceiver->MaxPacketsBufferedInLookaside);

    //
    // Set the NextODataSequenceNumber and FurthestKnownGroupSequenceNumber based
    // on this packet's Sequence # and the lateJoin option (if present)
    // Make sure all of the Sequence numbers are on group boundaries (if not,
    // set them at the start of the next group)
    //
    FirstODataSequenceNumber &= ~((SEQ_TYPE) pReceive->FECGroupSize - 1);
    if (PacketOptions.OptionsFlags & PGM_OPTION_FLAG_JOIN)
    {
        PacketOptions.LateJoinerSequence += (pReceive->FECGroupSize - 1);
        PacketOptions.LateJoinerSequence &= ~((SEQ_TYPE) pReceive->FECGroupSize - 1);

        pReceive->pReceiver->NextODataSequenceNumber = (SEQ_TYPE) PacketOptions.LateJoinerSequence;
    }
    else
    {
        //
        // There is no late joiner option
        //
        pReceive->pReceiver->NextODataSequenceNumber = FirstODataSequenceNumber;
    }
    pReceive->pReceiver->LastTrailingEdgeSeqNum = pReceive->pReceiver->FirstNakSequenceNumber =
                                            pReceive->pReceiver->NextODataSequenceNumber;
    pReceive->pReceiver->MaxOutstandingNakTimeout = pReceive->pReceiver->OutstandingNakTimeout;

    //
    // Set the FurthestKnown Sequence # and Allocate Nak contexts
    //
    pReceive->pReceiver->FurthestKnownGroupSequenceNumber = (pReceive->pReceiver->NextODataSequenceNumber-
                                                             pReceive->FECGroupSize) &
                                                            ~((SEQ_TYPE) pReceive->FECGroupSize - 1);
    pReceive->pReceiver->FurthestKnownSequenceNumber = pReceive->pReceiver->NextODataSequenceNumber-1;

    //
    // Since this is the first receive for this session, see if we need to
    // start the receive timer
    //
    InsertTailList (&PgmDynamicConfig.CurrentReceivers, &pReceive->pReceiver->Linkage);
    if (!(PgmDynamicConfig.GlobalFlags & PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING))
    {
        pReceive->pReceiver->StartTickCount = PgmDynamicConfig.ReceiversTimerTickCount = 1;
        PgmDynamicConfig.LastReceiverTimeout.QuadPart = KeQueryInterruptTime ();
        PgmDynamicConfig.TimeoutGranularity.QuadPart =  BASIC_TIMER_GRANULARITY_IN_MSECS * 10000;   // 100ns
        if (!PgmDynamicConfig.TimeoutGranularity.QuadPart)
        {
            ASSERT (0);
            PgmDynamicConfig.TimeoutGranularity.QuadPart = 1;
        }

        PgmDynamicConfig.GlobalFlags |= PGM_CONFIG_FLAG_RECEIVE_TIMER_RUNNING;

        PgmInitTimer (&PgmDynamicConfig.SessionTimer);
        PgmStartTimer (&PgmDynamicConfig.SessionTimer, BASIC_TIMER_GRANULARITY_IN_MSECS, ReceiveTimerTimeout, NULL);
    }
    else
    {
        pReceive->pReceiver->StartTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
    }
    CheckAndAddNakRequests (pReceive, &FirstODataSequenceNumber, NULL, NAK_PENDING_0, TRUE);

    PgmTrace (LogStatus, ("PgmNewInboundConnection:  "  \
        "New incoming connection, pAddress=<%p>, pReceive=<%p>, ThisSeq=<%d==>%d> (%sparity), StartSeq=<%d>\n",
            pAddress, pReceive, ntohl(ulData), (ULONG) FirstODataSequenceNumber,
            (pPgmHeader->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY ? "" : "non-"),
            (ULONG) pReceive->pReceiver->NextODataSequenceNumber));

    PgmUnlock (pReceive, OldIrq2);
    PgmUnlock (pAddress, OldIrq1);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // We are ready to proceed!  So, complete the client's Accept Irp
    //
    PgmIoComplete (pIrp, STATUS_SUCCESS, 0);

    //
    // If we had failed, we would already have returned before now!
    //
    *ppReceive = pReceive;
    return (STATUS_SUCCESS);
}


//----------------------------------------------------------------------------

NTSTATUS
ProcessReceiveCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             pIrp,
    IN PVOID            Context
    )
/*++

Routine Description:

    This routine handles the case when a datagram is too
    short and and Irp has to be passed back to the transport to get the
    rest of the datagram.  The irp completes through here when full.

Arguments:

    IN  DeviceObject - unused.
    IN  Irp - Supplies Irp that the transport has finished processing.
    IN  Context - Supplies the pReceive - the connection data structure

Return Value:

    The final status from the operation (success or an exception).

--*/
{
    NTSTATUS                status;
    PIRP                    pIoRequestPacket;
    ULONG                   BytesTaken;
    tRCV_COMPLETE_CONTEXT   *pRcvContext = (tRCV_COMPLETE_CONTEXT *) Context;
    ULONG                   Offset = pRcvContext->BytesAvailable;
    PVOID                   pBuffer;
    ULONG                   SrcAddressLength;
    PVOID                   pSrcAddress;

    if (pBuffer = MmGetSystemAddressForMdlSafe (pIrp->MdlAddress, HighPagePriority))
    {
        PgmTrace (LogAllFuncs, ("ProcessReceiveCompletionRoutine:  "  \
            "pIrp=<%p>, pRcvBuffer=<%p>, Status=<%x> Length=<%d>\n",
                pIrp, Context, pIrp->IoStatus.Status, (ULONG) pIrp->IoStatus.Information));

        SrcAddressLength = pRcvContext->SrcAddressLength;
        pSrcAddress = pRcvContext->pSrcAddress;

        //
        // just call the regular indication routine as if UDP had done it.
        //
        TdiRcvDatagramHandler (pRcvContext->pAddress,
                               SrcAddressLength,
                               pSrcAddress,
                               0,
                               NULL,
                               TDI_RECEIVE_NORMAL,
                               (ULONG) pIrp->IoStatus.Information,
                               (ULONG) pIrp->IoStatus.Information,
                               &BytesTaken,
                               pBuffer,
                               &pIoRequestPacket);
    }
    else
    {
        PgmTrace (LogError, ("ProcessReceiveCompletionRoutine: ERROR -- "  \
            "MmGetSystemA... FAILed, pIrp=<%p>, pLocalBuffer=<%p>\n", pIrp, pRcvContext));
    }

    //
    // Free the Irp and Mdl and Buffer
    //
    IoFreeMdl (pIrp->MdlAddress);
    pIrp->MdlAddress = NULL;
    IoFreeIrp (pIrp);
    PgmFreeMem (pRcvContext);

    return (STATUS_MORE_PROCESSING_REQUIRED);
}


#ifdef DROP_DBG

ULONG   MinDropInterval = 10;
ULONG   MaxDropInterval = 10;
// ULONG   DropCount = 10;
ULONG   DropCount = -1;
#endif  // DROP_DBG

//----------------------------------------------------------------------------

NTSTATUS
TdiRcvDatagramHandler(
    IN PVOID                pDgramEventContext,
    IN INT                  SourceAddressLength,
    IN PVOID                pSourceAddress,
    IN INT                  OptionsLength,
#if(WINVER > 0x0500)
    IN TDI_CMSGHDR          *pControlData,
#else
    IN PVOID                *pControlData,
#endif  // WINVER
    IN ULONG                ReceiveDatagramFlags,
    IN ULONG                BytesIndicated,
    IN ULONG                BytesAvailable,
    OUT ULONG               *pBytesTaken,
    IN PVOID                pTsdu,
    OUT PIRP                *ppIrp
    )
/*++

Routine Description:

    This routine is the handler for receiving all Pgm packets from
    the transport (protocol == IPPROTO_RM)

Arguments:

    IN  pDgramEventContext      -- Our context (pAddress)
    IN  SourceAddressLength     -- Length of source address
    IN  pSourceAddress          -- Address of remote host
    IN  OptionsLength
    IN  pControlData            -- ControlData from transport
    IN  ReceiveDatagramFlags    -- Flags set by the transport for this packet
    IN  BytesIndicated          -- Bytes in this indicate
    IN  BytesAvailable          -- total bytes available with the transport
    OUT pBytesTaken             -- bytes taken by us
    IN  pTsdu                   -- data packet ptr
    OUT ppIrp                   -- pIrp if more processing required

Return Value:

    NTSTATUS - Final status of the call

--*/
{
    NTSTATUS                            status;
    tCOMMON_HEADER UNALIGNED            *pPgmHeader;
    tBASIC_SPM_PACKET_HEADER UNALIGNED  *pSpmPacket;
    tCOMMON_SESSION_CONTEXT             *pSession;
    PLIST_ENTRY                         pEntry;
    PGMLockHandle                       OldIrq, OldIrq1;
    USHORT                              LocalSessionPort, PacketSessionPort;
    tTSI                                TSI;
    PVOID                               pFECBuffer;
    UCHAR                               PacketType;
    IP_PKTINFO                          *pPktInfo;
    PIRP                                pLocalIrp = NULL;
    PMDL                                pLocalMdl = NULL;
    tRCV_COMPLETE_CONTEXT               *pRcvBuffer = NULL;
    ULONG                               XSum, BufferLength = 0;
    IPV4Header                          *pIp = (IPV4Header *) pTsdu;
    PTA_IP_ADDRESS                      pIpAddress = (PTA_IP_ADDRESS) pSourceAddress;
    tADDRESS_CONTEXT                    *pAddress = (tADDRESS_CONTEXT *) pDgramEventContext;

    *pBytesTaken = 0;   // Initialize the Bytes Taken!
    *ppIrp = NULL;

#ifdef DROP_DBG
//
// Drop OData packets only for now!
//
pPgmHeader = (tCOMMON_HEADER UNALIGNED *) (((PUCHAR)pIp) + (pIp->HeaderLength * 4));
PacketType = pPgmHeader->Type & 0x0f;
if ((PacketType == PACKET_TYPE_ODATA) &&
    !(((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY) &&
    !(--DropCount))
{
    ULONG           SequenceNumber;
    LARGE_INTEGER   TimeValue;

    KeQuerySystemTime (&TimeValue);
    DropCount = MinDropInterval + ((TimeValue.LowTime >> 8) % (MaxDropInterval - MinDropInterval + 1));

/*
    PgmCopyMemory (&SequenceNumber, &((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->DataSequenceNumber, sizeof (ULONG));
    DbgPrint("TdiRcvDatagramHandler:  Dropping packet, %s SeqNum = %d!\n",
        (((tBASIC_DATA_PACKET_HEADER *) pPgmHeader)->CommonHeader.Options & PACKET_HEADER_OPTIONS_PARITY ? "PARITY" : "DATA"),
        ntohl (SequenceNumber));
*/
    return (STATUS_DATA_NOT_ACCEPTED);
}
#endif  // DROP_DBG
    PgmLock (&PgmDynamicConfig, OldIrq);
    if (BytesIndicated > PgmDynamicConfig.MaxMTU)
    {
        PgmDynamicConfig.MaxMTU = BytesIndicated;
    }

    if (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS))
    {
        PgmTrace (LogPath, ("TdiRcvDatagramHandler:  "  \
            "Invalid Address handle=<%p>\n", pAddress));

        PgmUnlock (&PgmDynamicConfig, OldIrq);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now, Reference the Address so that it cannot go away
    // while we are processing it!
    //
    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER, FALSE);
    PgmUnlock (&PgmDynamicConfig, OldIrq);

    //
    // If we do not have the complete datagram, then pass an Irp down to retrieve it
    //
    if ((BytesAvailable != BytesIndicated) &&
        !(ReceiveDatagramFlags & TDI_RECEIVE_ENTIRE_MESSAGE))
    {
        ASSERT (BytesIndicated <= BytesAvailable);

        //
        // Build an irp to do the receive with and attach a buffer to it.
        //
        BufferLength = sizeof (tRCV_COMPLETE_CONTEXT) + BytesAvailable + SourceAddressLength;
        BufferLength = ((BufferLength + 3)/sizeof(ULONG)) * sizeof(ULONG);

        if ((pLocalIrp = IoAllocateIrp (pgPgmDevice->pPgmDeviceObject->StackSize, FALSE)) &&
            (pRcvBuffer = PgmAllocMem (BufferLength, PGM_TAG('3'))) &&
            (pLocalMdl = IoAllocateMdl (&pRcvBuffer->BufferData, BytesAvailable, FALSE, FALSE, NULL)))
        {
            pLocalIrp->MdlAddress = pLocalMdl;
            MmBuildMdlForNonPagedPool (pLocalMdl); // Map the pages in memory...

            TdiBuildReceiveDatagram (pLocalIrp,
                                     pAddress->pDeviceObject,
                                     pAddress->pFileObject,
                                     ProcessReceiveCompletionRoutine,
                                     pRcvBuffer,
                                     pLocalMdl,
                                     BytesAvailable,
                                     NULL,
                                     NULL,
                                     0);        // (ULONG) TDI_RECEIVE_NORMAL) ?

            // make the next stack location the current one.  Normally IoCallDriver
            // would do this but we are not going through IoCallDriver here, since the
            // Irp is just passed back with RcvIndication.
            //
            ASSERT (pLocalIrp->CurrentLocation > 1);
            IoSetNextIrpStackLocation (pLocalIrp);

            //
            // save the source address and length in the buffer for later
            // indication back to this routine.
            //
            pRcvBuffer->pAddress = pAddress;
            pRcvBuffer->SrcAddressLength = SourceAddressLength;
            pRcvBuffer->pSrcAddress = (PVOID) ((PUCHAR)&pRcvBuffer->BufferData + BytesAvailable);
            PgmCopyMemory (pRcvBuffer->pSrcAddress, pSourceAddress, SourceAddressLength);

            *pBytesTaken = 0;
            *ppIrp = pLocalIrp;

            status = STATUS_MORE_PROCESSING_REQUIRED;

            PgmTrace (LogAllFuncs, ("TdiRcvDatagramHandler:  "  \
                "BytesI=<%d>, BytesA=<%d>, Flags=<%x>, pIrp=<%p>\n",
                    BytesIndicated, BytesAvailable, ReceiveDatagramFlags, pLocalIrp));
        }
        else
        {
            // Cleanup on failure:
            if (pLocalIrp)
            {
                IoFreeIrp (pLocalIrp);
            }
            if (pRcvBuffer)
            {
                PgmFreeMem (pRcvBuffer);
            }

            status = STATUS_DATA_NOT_ACCEPTED;

            PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
                "INSUFFICIENT_RESOURCES, BuffLen=<%d>, pIrp=<%p>, pBuff=<%p>\n",
                    BufferLength, pLocalIrp, pRcvBuffer));
        }

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (status);
    }

    //
    // Now that we have the complete datagram, verify that it is valid
    // First line of defense against bad packets.
    //
    if ((BytesIndicated < (sizeof(IPV4Header) + sizeof(tCOMMON_HEADER))) ||
        (pIp->Version != 4) ||
        (BytesIndicated < ((pIp->HeaderLength<<2) + sizeof(tCOMMON_HEADER))))
    {
        //
        // Need to get at least our header from transport!
        //
        PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
            "IPver=<%d>, BytesI=<%d>, Min=<%d>, AddrType=<%d>\n",
                pIp->Version, BytesIndicated, (sizeof(IPV4Header) + sizeof(tBASIC_DATA_PACKET_HEADER)),
                pIpAddress->Address[0].AddressType));

        ASSERT (0);

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    pPgmHeader = (tCOMMON_HEADER UNALIGNED *) (((PUCHAR)pIp) + (pIp->HeaderLength * 4));

    BytesIndicated -= (pIp->HeaderLength * 4);
    BytesAvailable -= (pIp->HeaderLength * 4);

    //
    // Now, Verify Checksum
    //
    if ((XSum = tcpxsum (0, (CHAR *) pPgmHeader, BytesIndicated)) != 0xffff)
    {
        //
        // Need to get at least our header from transport!
        //
        PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
            "Bad Checksum on Pgm Packet (type=<%x>)!  XSum=<%x> -- Rejecting packet\n",
            pPgmHeader->Type, XSum));

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now, determine the TSI, i.e. GSI (from packet) + TSIPort (below)
    //
    PacketType = pPgmHeader->Type & 0x0f;
    if ((PacketType == PACKET_TYPE_NAK)  ||
        (PacketType == PACKET_TYPE_NNAK) ||
        (PacketType == PACKET_TYPE_SPMR) ||
        (PacketType == PACKET_TYPE_POLR))
    {
        PgmCopyMemory (&PacketSessionPort, &pPgmHeader->SrcPort, sizeof (USHORT));
        PgmCopyMemory (&TSI.hPort, &pPgmHeader->DestPort, sizeof (USHORT));
    }
    else
    {
        PgmCopyMemory (&PacketSessionPort, &pPgmHeader->DestPort, sizeof (USHORT));
        PgmCopyMemory (&TSI.hPort, &pPgmHeader->SrcPort, sizeof (USHORT));
    }
    PacketSessionPort = ntohs (PacketSessionPort);
    TSI.hPort = ntohs (TSI.hPort);
    PgmCopyMemory (&TSI.GSI, &pPgmHeader->gSourceId, SOURCE_ID_LENGTH);

    //
    // If this packet is for a different session port, drop it
    //
    if (pAddress->ReceiverMCastAddr)
    {
        LocalSessionPort = pAddress->ReceiverMCastPort;
    }
    else
    {
        LocalSessionPort = pAddress->SenderMCastPort;
    }

    if (LocalSessionPort != PacketSessionPort)
    {
        PgmTrace (LogPath, ("TdiRcvDatagramHandler:  "  \
            "Dropping packet for different Session port, <%x>!=<%x>!\n", LocalSessionPort, PacketSessionPort));

        PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
        return (STATUS_DATA_NOT_ACCEPTED);
    }

    //
    // Now check if this receive is for an active connection
    //
    pSession = NULL;
    PgmLock (pAddress, OldIrq);        // So that the list cannot change!
    pEntry = &pAddress->AssociatedConnections;
    while ((pEntry = pEntry->Flink) != &pAddress->AssociatedConnections)
    {
        pSession = CONTAINING_RECORD (pEntry, tCOMMON_SESSION_CONTEXT, Linkage);

        PgmLock (pSession, OldIrq1);

        if ((PGM_VERIFY_HANDLE2 (pSession, PGM_VERIFY_SESSION_RECEIVE, PGM_VERIFY_SESSION_SEND)) &&
            (pSession->TSI.ULLTSI == TSI.ULLTSI) &&
            !(pSession->SessionFlags & (PGM_SESSION_CLIENT_DISCONNECTED | PGM_SESSION_TERMINATED_ABORT)))
        {
            if (pSession->pReceiver)
            {
                PGM_REFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_TDI_RCV_HANDLER, TRUE);

                if ((pSession->FECOptions) &&
                    (BytesIndicated > pSession->MaxMTULength))
                {
                    if (pFECBuffer = PgmAllocMem (((BytesIndicated+sizeof(tPOST_PACKET_FEC_CONTEXT)-sizeof(USHORT))
                                                    *pSession->FECGroupSize*2), PGM_TAG('3')))
                    {
                        ASSERT (pSession->pFECBuffer);
                        PgmFreeMem (pSession->pFECBuffer);
                        pSession->pFECBuffer = pFECBuffer;
                        pSession->MaxMTULength = (USHORT) BytesIndicated;
                        pSession->MaxFECPacketLength = pSession->MaxMTULength +
                                                       sizeof (tPOST_PACKET_FEC_CONTEXT) - sizeof (USHORT);
                    }
                    else
                    {
                        PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
                            "STATUS_INSUFFICIENT_RESOURCES -- pFECBuffer=<%d> bytes\n",
                                (BytesIndicated+sizeof(tPOST_PACKET_FEC_CONTEXT)-sizeof(USHORT))));

                        pSession = NULL;
                        pSession->SessionFlags |= PGM_SESSION_TERMINATED_ABORT;
                    }
                }

                PgmUnlock (pSession, OldIrq1);
                break;
            }

            ASSERT (pSession->pSender);
            PGM_REFERENCE_SESSION_SEND (pSession, REF_SESSION_TDI_RCV_HANDLER, TRUE);

            PgmUnlock (pSession, OldIrq1);

            break;
        }

        PgmUnlock (pSession, OldIrq1);
        pSession = NULL;
    }

    PgmUnlock (pAddress, OldIrq);

    if (!pSession)
    {
        // We should drop this packet because we received this either because
        // we may have a loopback session, or we have a listen but this
        // is not an OData packet
        if ((pIpAddress->TAAddressCount != 1) ||
            (pIpAddress->Address[0].AddressLength != TDI_ADDRESS_LENGTH_IP) ||
            (pIpAddress->Address[0].AddressType != TDI_ADDRESS_TYPE_IP))
        {
            PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
                "[1] Bad AddrType=<%d>\n", pIpAddress->Address[0].AddressType));

            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
            return (STATUS_DATA_NOT_ACCEPTED);
        }

        status = STATUS_DATA_NOT_ACCEPTED;

        //
        // New sessions will be accepted only if we are a receiver
        // Also, new sessions will always be initiated only with an OData packet
        // Also, verify that the client has posted a connect handler!
        //
        if ((pAddress->ReceiverMCastAddr) &&
            (pAddress->ConEvContext))
        {
            if ((PacketType == PACKET_TYPE_ODATA) &&
                (!(pPgmHeader->Options & PACKET_HEADER_OPTIONS_PARITY)))
            {
                //
                // This is a new incoming connection, so see if the
                // client accepts it.
                //
                status = PgmNewInboundConnection (pAddress,
                                                  SourceAddressLength,
                                                  pIpAddress,
                                                  ReceiveDatagramFlags,
                                                  (tBASIC_DATA_PACKET_HEADER UNALIGNED *) pPgmHeader,
                                                  BytesIndicated,
                                                  &pSession);

                if (!NT_SUCCESS (status))
                {
                    PgmTrace (LogAllFuncs, ("TdiRcvDatagramHandler:  "  \
                        "pAddress=<%p> FAILed to accept new connection, PacketType=<%x>, status=<%x>\n",
                            pAddress, PacketType, status));
                }
            }
            else if ((PacketType == PACKET_TYPE_SPM) &&
                     (BytesIndicated >= sizeof(tBASIC_SPM_PACKET_HEADER)))
            {
                ProcessSpmPacket (pAddress,
                                  NULL,             // This will signify that we do not have a connection yet
                                  BytesIndicated,
                                  (tBASIC_SPM_PACKET_HEADER UNALIGNED *) pPgmHeader);
            }
        }

        if (!NT_SUCCESS (status))
        {
            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);
            return (STATUS_DATA_NOT_ACCEPTED);
        }
    }

#if(WINVER > 0x0500)
    if ((pAddress->Flags & PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE) &&
        (pAddress->Flags & PGM_ADDRESS_LISTEN_ON_ALL_INTERFACES) &&
        (ReceiveDatagramFlags & TDI_RECEIVE_CONTROL_INFO))
    {
        //
        // See if we can Enqueue the stop listening request
        //
        PgmLock (&PgmDynamicConfig, OldIrq);
        PgmLock (pAddress, OldIrq1);

        pPktInfo = (IP_PKTINFO*) TDI_CMSG_DATA (pControlData);
        PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING, TRUE);

        if (STATUS_SUCCESS == PgmQueueForDelayedExecution (StopListeningOnAllInterfacesExcept,
                                                           pAddress,
                                                           ULongToPtr (pPktInfo->ipi_ifindex),
                                                           NULL,
                                                           TRUE))
        {
            pAddress->Flags &= ~PGM_ADDRESS_WAITING_FOR_NEW_INTERFACE;

            PgmUnlock (pAddress, OldIrq1);
            PgmUnlock (&PgmDynamicConfig, OldIrq);
        }
        else
        {
            PgmUnlock (pAddress, OldIrq1);
            PgmUnlock (&PgmDynamicConfig, OldIrq);

            PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_STOP_LISTENING);
        }
    }
#endif  // WINVER

    //
    // Now, handle the packet appropriately
    //
    // Use fast Path for Data packets!
    //
    if ((PacketType == PACKET_TYPE_ODATA) ||
        (PacketType == PACKET_TYPE_RDATA))
    {
        if (pAddress->ReceiverMCastAddr)
        {
            if (PacketType == PACKET_TYPE_ODATA)
            {
                pSession->pReceiver->NumODataPacketsReceived++;
            }
            else
            {
                pSession->pReceiver->NumRDataPacketsReceived++;
            }
            pSession->pReceiver->LastSessionTickCount = PgmDynamicConfig.ReceiversTimerTickCount;
            pSession->TotalBytes += BytesIndicated;
            pSession->TotalPacketsReceived++;
            status = ProcessDataPacket (pAddress,
                                        pSession,
                                        BytesIndicated,
                                        (tBASIC_DATA_PACKET_HEADER UNALIGNED *) pPgmHeader,
                                        PacketType);
        }
        else
        {
            PgmTrace (LogError, ("TdiRcvDatagramHandler: ERROR -- "  \
                "Received Data packet, not on Receiver session!  pSession=<%p>\n", pSession));
            status = STATUS_DATA_NOT_ACCEPTED;
        }
    }
    else
    {
        status = PgmProcessIncomingPacket (pAddress,
                                           pSession,
                                           SourceAddressLength,
                                           pIpAddress,
                                           BytesIndicated,
                                           pPgmHeader,
                                           PacketType);
    }

    PgmTrace (LogAllFuncs, ("TdiRcvDatagramHandler:  "  \
        "PacketType=<%x> for pSession=<%p> BytesI=<%d>, BytesA=<%d>, status=<%x>\n",
            PacketType, pSession, BytesIndicated, BytesAvailable, status));

    if (pSession->pSender)
    {
        PGM_DEREFERENCE_SESSION_SEND (pSession, REF_SESSION_TDI_RCV_HANDLER);
    }
    else
    {
        ASSERT (pSession->pReceiver);
        PGM_DEREFERENCE_SESSION_RECEIVE (pSession, REF_SESSION_TDI_RCV_HANDLER);
    }

    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_TDI_RCV_HANDLER);

    //
    // Only acceptable return codes are STATUS_SUCCESS and STATUS_DATA_NOT_ACCPETED
    // (STATUS_MORE_PROCESSING_REQUIRED is not valid here because we have no Irp).
    //
    if (STATUS_SUCCESS != status)
    {
        status = STATUS_DATA_NOT_ACCEPTED;
    }

    return (status);
}


//----------------------------------------------------------------------------

VOID
PgmCancelReceiveIrp(
    IN PDEVICE_OBJECT DeviceContext,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine handles the cancelling of a Receive Irp. It must release the
    cancel spin lock before returning re: IoCancelIrp().

Arguments:


Return Value:

    None

--*/
{
    PIO_STACK_LOCATION      pIrpSp = IoGetCurrentIrpStackLocation (pIrp);
    tRECEIVE_SESSION        *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    PGMLockHandle           OldIrq;
    PLIST_ENTRY             pEntry;

    if (!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE))
    {
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        PgmTrace (LogError, ("PgmCancelReceiveIrp: ERROR -- "  \
            "pIrp=<%p> pReceive=<%p>, pAddress=<%p>\n",
                pIrp, pReceive, (pReceive ? pReceive->pReceiver->pAddress : NULL)));
        return;
    }

    PgmLock (pReceive, OldIrq);

    //
    // See if we are actively receiving
    //
    if (pIrp == pReceive->pReceiver->pIrpReceive)
    {
        pIrp->IoStatus.Information = pReceive->pReceiver->BytesInMdl;
        pIrp->IoStatus.Status = STATUS_CANCELLED;

        pReceive->pReceiver->BytesInMdl = pReceive->pReceiver->TotalBytesInMdl = 0;
        pReceive->pReceiver->pIrpReceive = NULL;

        PgmUnlock (pReceive, OldIrq);
        IoReleaseCancelSpinLock (pIrp->CancelIrql);

        IoCompleteRequest (pIrp,IO_NETWORK_INCREMENT);
        return;
    }

    //
    // We are not actively receiving, so see if this Irp is
    // in our Irps list
    //
    pEntry = &pReceive->pReceiver->ReceiveIrpsList;
    while ((pEntry = pEntry->Flink) != &pReceive->pReceiver->ReceiveIrpsList)
    {
        if (pEntry == &pIrp->Tail.Overlay.ListEntry)
        {
            RemoveEntryList (pEntry);
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;

            PgmUnlock (pReceive, OldIrq);
            IoReleaseCancelSpinLock (pIrp->CancelIrql);

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);
            return;
        }
    }

    //
    // If we have reached here, then the Irp must already
    // be in the process of being completed!
    //
    PgmUnlock (pReceive, OldIrq);
    IoReleaseCancelSpinLock (pIrp->CancelIrql);
}


//----------------------------------------------------------------------------

NTSTATUS
PgmReceive(
    IN  tPGM_DEVICE         *pPgmDevice,
    IN  PIRP                pIrp,
    IN  PIO_STACK_LOCATION  pIrpSp
    )
/*++

Routine Description:

    This routine is called via dispatch by the client to post a Receive pIrp

Arguments:

    IN  pPgmDevice  -- Pgm's Device object context
    IN  pIrp        -- Client's request Irp
    IN  pIrpSp      -- current request's stack pointer

Return Value:

    NTSTATUS - Final status of the request

--*/
{
    NTSTATUS                    status;
    PGMLockHandle               OldIrq, OldIrq1, OldIrq2, OldIrq3;
    tADDRESS_CONTEXT            *pAddress = NULL;
    tRECEIVE_SESSION            *pReceive = (tRECEIVE_SESSION *) pIrpSp->FileObject->FsContext;
    PTDI_REQUEST_KERNEL_RECEIVE pClientParams = (PTDI_REQUEST_KERNEL_RECEIVE) &pIrpSp->Parameters;

    PgmLock (&PgmDynamicConfig, OldIrq);
    IoAcquireCancelSpinLock (&OldIrq1);

    //
    // Verify that the connection is valid and is associated with an address
    //
    if ((!PGM_VERIFY_HANDLE (pReceive, PGM_VERIFY_SESSION_RECEIVE)) ||
        (!(pAddress = pReceive->pAssociatedAddress)) ||
        (!PGM_VERIFY_HANDLE (pAddress, PGM_VERIFY_ADDRESS)))
    {
        PgmTrace (LogError, ("PgmReceive: ERROR -- "  \
            "Invalid Handles pReceive=<%p>, pAddress=<%p>\n", pReceive, pAddress));

        status = STATUS_INVALID_HANDLE;
    }
    else if (pReceive->SessionFlags & PGM_SESSION_CLIENT_DISCONNECTED)
    {
        PgmTrace (LogPath, ("PgmReceive:  "  \
            "Receive Irp=<%p> was posted after session has been Disconnected, pReceive=<%p>, pAddress=<%p>\n",
            pIrp, pReceive, pAddress));

        status = STATUS_CANCELLED;
    }
    else if (!pClientParams->ReceiveLength)
    {
        ASSERT (0);
        PgmTrace (LogError, ("PgmReceive: ERROR -- "  \
            "Invalid Handles pReceive=<%p>, pAddress=<%p>\n", pReceive, pAddress));

        status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS (status))
    {
        IoReleaseCancelSpinLock (OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        pIrp->IoStatus.Information = 0;
        return (status);
    }

    PgmLock (pAddress, OldIrq2);
    PgmLock (pReceive, OldIrq3);

    if (!NT_SUCCESS (PgmCheckSetCancelRoutine (pIrp, PgmCancelReceiveIrp, TRUE)))
    {
        PgmUnlock (pReceive, OldIrq3);
        PgmUnlock (pAddress, OldIrq2);
        IoReleaseCancelSpinLock (OldIrq1);
        PgmUnlock (&PgmDynamicConfig, OldIrq);

        PgmTrace (LogError, ("PgmReceive: ERROR -- "  \
            "Could not set Cancel routine on receive Irp=<%p>, pReceive=<%p>, pAddress=<%p>\n",
                pIrp, pReceive, pAddress));

        return (STATUS_CANCELLED);
    }
    IoReleaseCancelSpinLock (OldIrq3);

    PGM_REFERENCE_ADDRESS (pAddress, REF_ADDRESS_CLIENT_RECEIVE, TRUE);
    PGM_REFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLIENT_RECEIVE, TRUE);

    PgmUnlock (&PgmDynamicConfig, OldIrq2);

    PgmTrace (LogAllFuncs, ("PgmReceive:  "  \
        "Client posted ReceiveIrp = <%p> for pReceive=<%p>\n", pIrp, pReceive));

    InsertTailList (&pReceive->pReceiver->ReceiveIrpsList, &pIrp->Tail.Overlay.ListEntry);
    pReceive->SessionFlags &= ~PGM_SESSION_WAIT_FOR_RECEIVE_IRP;

    //
    // Now, try to indicate any data which may still be pending
    //
//    if (!(pAddress->Flags & PGM_ADDRESS_HIGH_SPEED_OPTIMIZED))
    {
        status = CheckIndicatePendedData (pAddress, pReceive, &OldIrq, &OldIrq1);
    }

    PgmUnlock (pReceive, OldIrq1);
    PgmUnlock (pAddress, OldIrq);

    PGM_DEREFERENCE_SESSION_RECEIVE (pReceive, REF_SESSION_CLIENT_RECEIVE);
    PGM_DEREFERENCE_ADDRESS (pAddress, REF_ADDRESS_CLIENT_RECEIVE);

    return (STATUS_PENDING);
}


//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\ia64\xsum.s ===
#include <xsum.ia64>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\test\rmtest.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
// 
// Copyright (C) 2000  Microsoft Corporation.  All Rights Reserved.
//
// Module:
//    RMTest.c
//
// Abstract:
//    This sample shows how to send and receive data using the
//    RMcast driver
//    This sample is post-Windows 2000 only.
//
// Usage:
//    RMTest.exe -i:int -a:IP
//           -i:int              Capture on this interface
//                                This is a zero based index of the 
//                                local interfaces
//           -a:IP               Use this MCast address
//
// Build:
//    cl RMTest.c ws2_32.lib
// 
//       OR
//     
//    nmake.exe
//
// Author:
//    Mohammad Shabbir Alam
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <stdio.h>
#include <stdlib.h>

#include <winsock2.h>
#include <wsahelp.h>
#include <wsasetup.h>

#include <mstcpip.h>

#include <ws2tcpip.h>

#include <ws2spi.h>
#include <wsahelp.h>

#include <sys\timeb.h>

#include "wsRm.h"

//
// Globals
//
#define SOCK_RMCAST    SOCK_RDM

struct _timeb   StartTime, CurrentTime, PreviousTime;

//
// User-definable variables
//
BOOL    gSetWinsockInfo         = FALSE;
BOOL    gClearWinsockInfo       = FALSE;
BOOL    gReceiver               = FALSE;

DWORD   gInterface              = 0;
LONG    gRateKbitsPerSec        = 56;
LONG    gMinPktSize             = 500;
LONG    gMaxPktSize             = 100000;
LONG    gNumSends               = 10000;
LONG    gStatusInterval         = 100;
LONG    gMCastTtl               = MAX_MCAST_TTL;
ULONG   gLateJoinerPercentage   = 0;
BOOLEAN gfSetMCastTtl           = FALSE;
BOOLEAN gListenOnAllInterfaces  = FALSE;
BOOLEAN gUseSpecifiedInterface  = FALSE;
BOOLEAN gSetLateJoiner          = FALSE;
BOOLEAN gSetLingerTime          = FALSE;

USHORT  gLingerTime             = 0;

ULONG   gMCastGroupAddr         = 0;
USHORT  gMCastGroupPort         = 0;

ULONG   gAfdBufferSize          = 0;
ULONG   gHighSpeedOptimization  = 0;
BOOLEAN gfSetAfdBufferSize      = FALSE;
BOOLEAN gfEnumerateProts        = FALSE;
BOOLEAN gfVerifyData            = FALSE;

// FEC vars:
USHORT  gFECBlockSize           = 255;      // Default
UCHAR   gFECGroupSize           = 0;
USHORT  gFECProActive           = 0;
BOOLEAN gfFECOnDemand           = FALSE;

int
GetInterface(
    int     num,
    ULONG   *pIpAddress,
    BOOL    fPrintInterfaces
    );

//
// Function: usage
// 
// Description:
//    Prints usage information.
//
void usage(char *progname)
{
    WSADATA       wsd;

    // Load Winsock
    //
    if (WSAStartup(MAKEWORD(2,2), &wsd) != 0)
    {
        fprintf(stderr, "WSAStartup() failed: %d\n", GetLastError());
        ExitProcess(-1);
    }

    fprintf (stdout, "usage: %s [-l] [-i:Interface] [-a:MCastIP] [-p:Port] [-r:Rate] ...\n", progname);
    fprintf (stdout, "       -a:MCastIP          Use this MCast address (default is 231.7.8.9)\n");
    fprintf (stdout, "       -b:BufferSize       Override Afd's buffer size\n");
    fprintf (stdout, "       -e                  Enumerate all protocols known to Winsock\n");
    fprintf (stdout, "       -j:LateJoiner       Percentage of Window available for LateJoiner\n");
    fprintf (stdout, "       -min:MinPacketSize  must be >= 4, default = 500\n");
    fprintf (stdout, "       -max:MaxPacketSize  must be <= 10 Mb, default = 100000\n\n");
    fprintf (stdout, "       -p:MCastPort        Port # (default is 0)\n");
    fprintf (stdout, "       -s:StatusInterval   Number of messages between status\n\n");
    fprintf (stdout, "       -h                  Use High Speed Intranet Optimization\n");

    fprintf (stdout, "       -L[:a]              Listen for RMcast packets (otherwise we are sender)\n");
    fprintf (stdout, "                           -- option a means listen on all interfaces\n\n");
    fprintf (stdout, "       -v:VerifyData       Verify data integrity on the receiver (receiver only)\n");

    fprintf (stdout, "       -F:FECGroupSize     Use FEC, <= 128, & power of 2      (sender only)\n");
    fprintf (stdout, "       -Fo                 OnDemand FEC (FEC must be set)     (sender only)\n");
    fprintf (stdout, "       -Fp:ProactivePkts   Pro-active FEC (FEC must be set)   (sender only)\n");
    fprintf (stdout, "       -n:NumSends         Number of sends, default = 10000   (sender only)\n");
    fprintf (stdout, "       -r:Rate             Send Rate in Kbits/Sec, default=56 (sender only)\n");
    fprintf (stdout, "       -g:LingerTime       LingerTime in seconds              (sender only)\n");
    fprintf (stdout, "       -t:TTL              Send MCast Ttl, default = max = %d (sender only)\n",
        MAX_MCAST_TTL);

    fprintf (stdout, "       -i:Interface        Interface for Send/Capture, default=0\n");
    fprintf (stdout, "             Available interfaces:\n");
    GetInterface (0, NULL, TRUE);

    WSACleanup();
    ExitProcess(-1);
}

//
// Function: ValidateArgs
// 
// Description:
//    This function parses the command line arguments and
//    sets global variables to indicate how the app should act.
//
void ValidateArgs(int argc, char **argv)
{
    int   i;
    char *ptr;

    for(i=1; i < argc; i++)
    {
        if (strlen(argv[i]) < 2)    // Must have '-' or '/' preceding option!
            continue;

        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'a':        // Use this MCast address
                    if (gMCastGroupAddr = inet_addr (&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 'b':        // Afd's internal buffer size
                    gAfdBufferSize = atoi(&argv[i][3]);
                    gfSetAfdBufferSize = TRUE;
                    break;

                case 'e':
                    gfEnumerateProts = TRUE;
                    break;

                case 'i':        // interface number
                    gInterface = atoi(&argv[i][3]);
                    gUseSpecifiedInterface = TRUE;
                    break;

                case 'j':        // Late Joiner %
                    gSetLateJoiner = TRUE;
                    gLateJoinerPercentage = atoi(&argv[i][3]);
                    break;

                case 'f':
                    if ((tolower (argv[i][2]) == ':') &&
                        ((gFECGroupSize = (UCHAR) atoi (&argv[i][3])) <= 128))
                    {
                        break;
                    }

                    if ((tolower (argv[i][2]) == 'p') &&
                        ((gFECProActive = (UCHAR) atoi (&argv[i][4])) <= 128))
                    {
                        break;
                    }

                    if (tolower (argv[i][2]) == 'o')
                    {
                        gfFECOnDemand = TRUE;
                        break;
                    }

                    usage(argv[0]);

                case 'g':
                    gLingerTime = (USHORT) atoi (&argv[i][3]);
                    gSetLingerTime = TRUE;
                    break;

                case 'h':
                    gHighSpeedOptimization = 1;
                    break;

                case 'l':
                    gReceiver = TRUE;       // we are receiver, otherwise we would have been sender by default
                    if (((argv[i][2]) == ':') &&
                        (tolower (argv[i][3]) == 'a'))
                    {
                        gListenOnAllInterfaces = TRUE;
                    }
                    break;

                case 'm':
                    if ((tolower (argv[i][2]) == 'i') &&
                        ((gMinPktSize = atoi (&argv[i][5])) >= 4))
                    {
                        break;
                    }

                    if ((tolower (argv[i][2]) == 'a') &&
                        ((gMaxPktSize = atoi (&argv[i][5])) <= 10*1000*1000))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 'n':
                    gNumSends = atoi (&argv[i][3]);
                    break;

                case 'p':        // interface number
                    gMCastGroupPort = (USHORT) atoi (&argv[i][3]);
                    break;

                case 'r':
                    if (gRateKbitsPerSec = atoi (&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 's':
                    if (gStatusInterval = atoi(&argv[i][3]))
                    {
                        break;
                    }

                    usage(argv[0]);

                case 't':
                    if ((gMCastTtl = atoi(&argv[i][3])) <= MAX_MCAST_TTL)
                    {
                        gfSetMCastTtl = TRUE;
                        break;
                    }

                    usage(argv[0]);

                case 'v':
                    gfVerifyData = TRUE;
                    break;

                case 'x':
                    gSetWinsockInfo = TRUE;
                    break;

                case 'y':
                    gClearWinsockInfo = TRUE;
                    break;

                default:
                    usage(argv[0]);
            }
        }
    }

    //
    // Check FEC parameters
    //
    if ((gFECGroupSize || gFECProActive || gfFECOnDemand) &&
        ((!gFECGroupSize) || !(gFECProActive || gfFECOnDemand)))
    {
        usage(argv[0]);
    }

    return;
}


//
// Function: GetInterface
//
// Description:
//    This function retrieves a zero based index and returns
//    the IP interface corresponding to that.
//
int
GetInterface(
    int     InterfaceNum,
    ULONG   *pIpAddress,
    BOOL    fPrintInterfaces
    )
{
    SOCKET              s;
    SOCKET_ADDRESS_LIST *slist=NULL;
    char                 buf[2048];
    DWORD                dwBytesRet;
    int                  i, ret;

    s = WSASocket(AF_INET, SOCK_RAW, IPPROTO_IP, NULL, 0, WSA_FLAG_OVERLAPPED);
    if (s == INVALID_SOCKET)
    {
        fprintf(stderr, "WSASocket() failed: %d\n", WSAGetLastError());
        return -1;
    }
    ret = WSAIoctl (s, SIO_ADDRESS_LIST_QUERY, NULL, 0, buf, 2048, &dwBytesRet, NULL, NULL);
    if (ret == SOCKET_ERROR)
    {
        fprintf(stderr, "WSAIoctl(SIO_ADDRESS_LIST_QUERY) failed: %d\n",
            WSAGetLastError());
        closesocket(s);
        return -1;
    }
    slist = (SOCKET_ADDRESS_LIST *)buf;
    closesocket(s);

    if (fPrintInterfaces)
    {
        // Just print all local IP interfaces.
        for(i=0; i < slist->iAddressCount ;i++)
        {
            fprintf(stdout, "               %-2d ........ [%s]\n", i, 
                inet_ntoa(((SOCKADDR_IN *)slist->Address[i].lpSockaddr)->sin_addr));
        }
    }
    else
    {
        if (InterfaceNum >= slist->iAddressCount)
        {
            return -1;
        }

        *pIpAddress = (ULONG) ((SOCKADDR_IN *)slist->Address[InterfaceNum].lpSockaddr)->sin_addr.s_addr;
    }

    return 0;
}

// --------------------------------------------------------------
// ****************************************************************


#define RMCAST_PARAM_KEY   \
    L"System\\CurrentControlSet\\Services\\RMCast\\Parameters"

#define RMCAST_WINSOCK_KEY \
    L"System\\CurrentControlSet\\Services\\RMCast\\Parameters\\Winsock"

#define WINSOCK_PARAMS_KEY  \
    L"System\\CurrentControlSet\\Services\\WinSock\\Parameters"

#define RMCAST_TRANSPORT   \
    L"RMCast"

DWORD
SetHelperDllRegInfo(
    )
{
    DWORD               status;
    DWORD               NameLength, mappingSize, Type;
    HKEY                hKey = NULL;
    LPBYTE              mapping = NULL;
    WCHAR               *wshDllPath = L"%SystemRoot%\\system32\\wshrm.dll";
    ULONG               sockAddrLength = sizeof(SOCKADDR_IN);
    WCHAR               *pTransports;
    HANDLE                      hWshRm;
    PWSH_GET_WINSOCK_MAPPING    pMapFunc = NULL;

    system ("sc create RMCast binPath= %SystemRoot%\\system32\\drivers\\RMCast.sys type= kernel");

    //
    // First, create the keys in HKLM / System / CurrentControlSet / Services / RMCast
    //
    status = RegCreateKeyExW (HKEY_LOCAL_MACHINE,       // hkey
                              RMCAST_PARAM_KEY,            // lpSubKey
                              0,                        // reserved
                              NULL,                     // lpclass
                              REG_OPTION_NON_VOLATILE,  // options
                              KEY_ALL_ACCESS,           // samDesired
                              NULL,                     // lpSecurityAttributes
                              &hKey,                    // phkResult
                              NULL);                    // lpdwDisposition
    if (status != NO_ERROR)
    {
        return (status);
    }
    RegCloseKey(hKey);

    status = RegCreateKeyExW (HKEY_LOCAL_MACHINE,       // hkey
                              RMCAST_WINSOCK_KEY,          // lpSubKey
                              0,                        // reserved
                              NULL,                     // lpclass
                              REG_OPTION_NON_VOLATILE,  // options
                              KEY_ALL_ACCESS,           // samDesired
                              NULL,                     // lpSecurityAttributes
                              &hKey,                    // phkResult
                              NULL);                    // lpdwDisposition

    if (status != NO_ERROR)
    {
        return (status);
    }
    RegCloseKey(hKey);

    if (!(hWshRm = LoadLibrary ("wshrm.dll")) ||
        !(pMapFunc = (PWSH_GET_WINSOCK_MAPPING) GetProcAddress (hWshRm, "WSHGetWinsockMapping")))
    {
        if (hWshRm)
        {
            printf ("FAILed to find proc -- WSHGetWinsockMapping -- in wshrm.dll\n");
            FreeLibrary (hWshRm);
        }
        else
        {
            printf ("FAILed to load wshrm.dll\n");
        }

        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get the winsock mapping data.
    //
    mappingSize = (*pMapFunc) ((PWINSOCK_MAPPING) mapping, 0);
    mapping = LocalAlloc(LMEM_FIXED, mappingSize);
    if (mapping == NULL)
    {
        FreeLibrary (hWshRm);
        return (ERROR_NOT_ENOUGH_MEMORY);
    }
    mappingSize = (*pMapFunc) ((PWINSOCK_MAPPING) mapping, mappingSize);

    FreeLibrary (hWshRm);

    //
    // Open the RMCast winsock parameters registry key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            RMCAST_WINSOCK_KEY,
                            0,
                            KEY_WRITE,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        LocalFree (mapping);
        return (status);
    }

    //
    // Write the required values
    //
    status = RegSetValueExW (hKey,
                             L"Mapping",
                             0,
                             REG_BINARY,
                             (CONST BYTE *) mapping,
                             mappingSize);

    LocalFree (mapping);

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"HelperDllName",
                             0,
                             REG_EXPAND_SZ,
                             (CONST BYTE *) wshDllPath,
                             (lstrlenW(wshDllPath) + 1) * sizeof(WCHAR));

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"MinSockaddrLength",
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &sockAddrLength,
                             sizeof(DWORD));

    if (status != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"MaxSockaddrLength",
                             0,
                             REG_DWORD,
                             (CONST BYTE *) &sockAddrLength,
                             sizeof(DWORD));

    RegCloseKey (hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    //
    // Now, set the Winsock parameter key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            WINSOCK_PARAMS_KEY,
                            0,
                            MAXIMUM_ALLOWED,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    mapping = NULL;
    mappingSize = 0;
    status = RegQueryValueExW (hKey,
                               L"Transports",
                               NULL,
                               &Type,
                               mapping,
                               &mappingSize);

    NameLength = (wcslen (RMCAST_TRANSPORT) + 1) * sizeof(WCHAR);
    if ((status == ERROR_MORE_DATA) ||
        ((status == ERROR_SUCCESS) && (mappingSize)))
    {
        mapping = LocalAlloc(LMEM_FIXED, (mappingSize+NameLength));
        if (mapping == NULL)
        {
            RegCloseKey (hKey);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Append the RMCast entry to the Transports key
        //
        status = RegQueryValueExW (hKey,
                                   L"Transports",
                                   NULL,
                                   &Type,
                                   mapping,
                                   &mappingSize);

        pTransports = (WCHAR *) &mapping[mappingSize-sizeof(WCHAR)];
        wcscpy (pTransports, RMCAST_TRANSPORT);
        pTransports [wcslen(RMCAST_TRANSPORT)] = 0;
        pTransports [wcslen(RMCAST_TRANSPORT)+1] = 0;
    }
    else
    {
        status = ERROR_MORE_DATA;
    }

    if ((status != ERROR_SUCCESS) ||
        (Type != REG_MULTI_SZ))
    {
        if (mapping)
        {
            LocalFree (mapping);
        }
        RegCloseKey (hKey);
        return (status);
    }

    status = RegSetValueExW (hKey,
                             L"Transports",
                             0,
                             REG_MULTI_SZ,
                             mapping,
                             (mappingSize+NameLength));

    LocalFree (mapping);
    RegCloseKey (hKey);

    return (status);
}



DWORD
ClearHelperDllRegInfo(
    )
{
    DWORD               status;
    HKEY                hKey = NULL;
    DWORD               remainingSize, mappingSize, Type, RMNameLength = wcslen (RMCAST_TRANSPORT) + 1;
    LPBYTE              mapping = NULL;
    DWORD               CurStrLenPlusOne;
    WCHAR               *pTransports;

    //
    // Remove the RMCast transport from the Winsock parameter key
    //
    status = RegOpenKeyExW (HKEY_LOCAL_MACHINE,
                            WINSOCK_PARAMS_KEY,
                            0,
                            MAXIMUM_ALLOWED,
                            &hKey);

    if (status != ERROR_SUCCESS)
    {
        return (status);
    }

    mapping = NULL;
    mappingSize = 0;
    status = RegQueryValueExW (hKey,
                               L"Transports",
                               NULL,
                               &Type,
                               mapping,
                               &mappingSize);

    if ((status == ERROR_MORE_DATA) ||
        ((status == ERROR_SUCCESS) && (mappingSize)))
    {
        mapping = LocalAlloc(LMEM_FIXED, mappingSize);
        if (mapping == NULL)
        {
            RegCloseKey (hKey);
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        status = RegQueryValueExW (hKey,
                                   L"Transports",
                                   NULL,
                                   &Type,
                                   mapping,
                                   &mappingSize);
    }
    else
    {
        status = ERROR_MORE_DATA;
    }

    if ((status != ERROR_SUCCESS) ||
        (Type != REG_MULTI_SZ))
    {
        if (mapping)
        {
            LocalFree (mapping);
        }
        RegCloseKey (hKey);
        return (status);
    }

    pTransports = (WCHAR *) mapping;
    remainingSize = mappingSize;
    while (*pTransports != L'\0')
    {
        CurStrLenPlusOne = wcslen(pTransports) + 1;
        if (CurStrLenPlusOne > remainingSize)
        {
            status = ERROR_INVALID_DATA;
            break;
        }

        remainingSize -= (CurStrLenPlusOne * sizeof (WCHAR));   // Decrement the amount of buffer unparsed

        // If this string is RMCast
        if ((CurStrLenPlusOne == RMNameLength) &&
            (_wcsicmp( pTransports, RMCAST_TRANSPORT) == 0))
        {
            // Remove this string from the list
            mappingSize -= (RMNameLength * sizeof(WCHAR));
            MoveMemory (pTransports , pTransports + RMNameLength , remainingSize);
        }
        else
        {
            pTransports += CurStrLenPlusOne;                        // Move to the next string
        }

    } // while: the transport list has not been completely parsed.

    status = RegSetValueExW (hKey,
                             L"Transports",
                             0,
                             REG_MULTI_SZ,
                             mapping,
                             mappingSize);

    LocalFree (mapping);
    RegCloseKey (hKey);

    return (status);
}

// ****************************************************************
ULONGLONG       TotalBytes = 0;
ULONGLONG       DataBytes = 0;

ULONG
GetSenderStats(
    SOCKET  s,
    LONG    count
    )
{
    ULONG           BufferLength;
    RM_SENDER_STATS RmSenderStats;
    time_t          DiffTotalSecs, DiffTotalMSecs;
    time_t          DiffPreviousSecs, DiffPreviousMSecs;
    ULONG           ret;

    //   Add 1 below to MSsecs to avoid div by 0
    DiffTotalSecs = CurrentTime.time - StartTime.time;
    DiffTotalMSecs = (1 + CurrentTime.millitm - StartTime.millitm) + (1000 * DiffTotalSecs);

    DiffPreviousSecs = CurrentTime.time - PreviousTime.time;
    DiffPreviousMSecs = (1 + CurrentTime.millitm - PreviousTime.millitm) + (1000 * DiffPreviousSecs);

    BufferLength = sizeof(RM_SENDER_STATS);
    memset (&RmSenderStats, 0, BufferLength);
    ret = getsockopt (s, IPPROTO_RM, RM_SENDER_STATISTICS, (char *)&RmSenderStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        fprintf (stderr, "GetSenderStats:  Failed to retrieve sender stats!\n");
        return (ret);
    }

    fprintf (stdout, "MessagesSent=<%d>, Interval=[%d.%d / %d.%d]\n",
        count, DiffPreviousSecs, DiffPreviousMSecs, DiffTotalSecs, DiffTotalMSecs);
    fprintf (stdout, "\tDataBytesSent=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmSenderStats.DataBytesSent, (ULONG) ((RmSenderStats.DataBytesSent*BITS_PER_BYTE) / DiffTotalMSecs));
    fprintf (stdout, "\tTotalBytesSent=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmSenderStats.TotalBytesSent, ((RmSenderStats.TotalBytesSent*BITS_PER_BYTE)/DiffTotalMSecs));
    fprintf (stdout, "\tNaksReceived=<%I64d>\n", RmSenderStats.NaksReceived);
    fprintf (stdout, "\tNaksReceivedTooLate=<%I64d>\n", RmSenderStats.NaksReceivedTooLate);
    fprintf (stdout, "\tNumOutstandingNaks=<%I64d>\n", RmSenderStats.NumOutstandingNaks);
    fprintf (stdout, "\tNumNaksAfterRData=<%I64d>\n", RmSenderStats.NumNaksAfterRData);
    fprintf (stdout, "\tRepairPacketsSent=<%I64d>\n", RmSenderStats.RepairPacketsSent);
    fprintf (stdout, "\tBufferSpaceAvailable=<%I64d> bytes\n\n", RmSenderStats.BufferSpaceAvailable);
    fprintf (stdout, "\tLeadingEdgeSeqId=<%I64d>\n", RmSenderStats.LeadingEdgeSeqId);
    fprintf (stdout, "\tTrailingEdgeSeqId=<%I64d>\n", RmSenderStats.TrailingEdgeSeqId);
    fprintf (stdout, "\tSequences in Window=<%I64d>\n", (RmSenderStats.LeadingEdgeSeqId-RmSenderStats.TrailingEdgeSeqId+1));
    fprintf (stdout, "\tRateKBitsPerSecLast=<%I64d>\n", RmSenderStats.RateKBitsPerSecLast);
    fprintf (stdout, "\tRateKBitsPerSecOverall=<%I64d>\n", RmSenderStats.RateKBitsPerSecOverall);

    fprintf (stdout, "\n\tDataBytesSent in last interval=<%I64d>,  Rate= %d Kbits / Sec\n",
        (RmSenderStats.DataBytesSent-DataBytes),
        (ULONG) (BITS_PER_BYTE * (RmSenderStats.DataBytesSent-DataBytes) / DiffPreviousMSecs));
    fprintf (stdout, "\tTotalBytesSent in last interval=<%I64d>,  Rate= %d Kbits / Sec\n\n",
        (RmSenderStats.TotalBytesSent-TotalBytes),
        (ULONG) (BITS_PER_BYTE * (RmSenderStats.TotalBytesSent-TotalBytes)/DiffPreviousMSecs));

    TotalBytes = RmSenderStats.TotalBytesSent;
    DataBytes = RmSenderStats.DataBytesSent;

    fflush (stdout);
    return (ERROR_SUCCESS);
}

ULONG
GetReceiverStats(
    SOCKET  s,
    LONG    count
    )
{
    ULONG               BufferLength;
    RM_RECEIVER_STATS   RmReceiverStats;
    time_t              DiffTotalSecs, DiffTotalMSecs;
    time_t              DiffPreviousSecs, DiffPreviousMSecs;
    ULONG               ret;

    //   Add 1 below to MSsecs to avoid div by 0
    DiffTotalSecs = CurrentTime.time - StartTime.time;
    DiffTotalMSecs = (1 + CurrentTime.millitm - StartTime.millitm) + (1000 * DiffTotalSecs);

    DiffPreviousSecs = CurrentTime.time - PreviousTime.time;
    DiffPreviousMSecs = (1 + CurrentTime.millitm - PreviousTime.millitm) + (1000 * DiffPreviousSecs);

    BufferLength = sizeof(RM_RECEIVER_STATS);
    memset (&RmReceiverStats, 0, BufferLength);
    ret = getsockopt (s, IPPROTO_RM, RM_RECEIVER_STATISTICS, (char *)&RmReceiverStats, &BufferLength);
    if (ret != ERROR_SUCCESS)
    {
        fprintf (stderr, "GetReceiverStats:  Failed to retrieve Receiver stats, ret=<%d>, LastError=<%x>!\n",
            ret, GetLastError());
        return (ret);
    }

    fprintf (stdout, "MessagesRcvd=<%d>, Interval=[%d.%d / %d.%d]\n",
        count, DiffPreviousSecs, DiffPreviousMSecs, DiffTotalSecs, DiffTotalMSecs);
    fprintf (stdout, "\n\tDataBytesReceived in last interval=<%I64d>,  Rate= %d Kbits / Sec\n",
        (RmReceiverStats.DataBytesReceived-DataBytes),
        (ULONG) (BITS_PER_BYTE * (RmReceiverStats.DataBytesReceived-DataBytes) / DiffPreviousMSecs));
    fprintf (stdout, "\tTotalBytesReceived in last interval=<%I64d>,  Rate= %d Kbits / Sec\n\n",
        (RmReceiverStats.TotalBytesReceived-TotalBytes),
        (ULONG) (BITS_PER_BYTE * (RmReceiverStats.TotalBytesReceived-TotalBytes)/DiffPreviousMSecs));

    fprintf (stdout, "\tTotalDataBytesRcvd=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmReceiverStats.DataBytesReceived, (ULONG) ((RmReceiverStats.DataBytesReceived*BITS_PER_BYTE) / DiffTotalMSecs));
    fprintf (stdout, "\tTotalBytesReceived=<%I64d>,  Rate= %d Kbits / Sec\n",
        RmReceiverStats.TotalBytesReceived, ((RmReceiverStats.TotalBytesReceived*BITS_PER_BYTE)/DiffTotalMSecs));
    fprintf (stdout, "\tRateKBitsPerSecLast=<%I64d>\n", RmReceiverStats.RateKBitsPerSecLast);
    fprintf (stdout, "\tRateKBitsPerSecOverall=<%I64d>\n", RmReceiverStats.RateKBitsPerSecOverall);

    fprintf (stdout, "\tNumODataPacketsReceived=<%I64d>\n", RmReceiverStats.NumODataPacketsReceived);
    fprintf (stdout, "\tNumRDataPacketsReceived=<%I64d>\n", RmReceiverStats.NumRDataPacketsReceived);
    fprintf (stdout, "\tNumDuplicateDataPackets=<%I64d>\n", RmReceiverStats.NumDuplicateDataPackets);
    fprintf (stdout, "\tLeadingEdgeSeqId=<%I64d>\n", RmReceiverStats.LeadingEdgeSeqId);
    fprintf (stdout, "\tTrailingEdgeSeqId=<%I64d>\n", RmReceiverStats.TrailingEdgeSeqId);
    fprintf (stdout, "\tSequences in Window=<%I64d>\n\n", (RmReceiverStats.LeadingEdgeSeqId-RmReceiverStats.TrailingEdgeSeqId+1));

    fprintf (stdout, "\tFirstNakSequenceNumber=<%I64d>\n", RmReceiverStats.FirstNakSequenceNumber);
    fprintf (stdout, "\tNumPendingNaks=<%I64d>\n", RmReceiverStats.NumPendingNaks);
    fprintf (stdout, "\tNumOutstandingNaks=<%I64d>\n", RmReceiverStats.NumOutstandingNaks);
    fprintf (stdout, "\tNumDataPacketsBuffered=<%I64d>\n", RmReceiverStats.NumDataPacketsBuffered);
    fprintf (stdout, "\tTotalSelectiveNaksSent=<%I64d>\n", RmReceiverStats.TotalSelectiveNaksSent);
    fprintf (stdout, "\tTotalParityNaksSent=<%I64d>\n\n", RmReceiverStats.TotalParityNaksSent);

    TotalBytes = RmReceiverStats.TotalBytesReceived;
    DataBytes = RmReceiverStats.DataBytesReceived;

    fflush (stdout);
    return (ERROR_SUCCESS);
}

// --------------------------------------------------------------
VOID
EnumerateProtocols(
    )
{
#define BUFFER_SIZE 10*1024
    INT                 NumProts, err             = NO_ERROR;
    CHAR                pBuffer[BUFFER_SIZE];
    WSAPROTOCOL_INFOW*   pwpiProtoInfo   = (WSAPROTOCOL_INFOW *) pBuffer;
    WSAPROTOCOL_INFOW*   pwpiInfo   = pwpiProtoInfo;
    DWORD               dwBuffSize      = BUFFER_SIZE;

    if (NumProts = WSCEnumProtocols (NULL, pwpiProtoInfo, &dwBuffSize, &err))
    {
        // Print all protocols
        printf ("WSHEnumProtocols returned <%d>:\n", NumProts);
        for (err = 0; err < NumProts; err++)
        {
            printf ("\t[%d]:\tType=<%x>, ProtocolId=<%x>, Flags=<%x>\n",
                err, pwpiInfo->iSocketType, pwpiInfo->iProtocol, pwpiInfo->dwServiceFlags1);
            pwpiInfo++;
        }
    }
    else
    {
        printf ("WSCEnumProtocols failed: <%d>, dwBuffSize=<%d>\n", err, dwBuffSize);
    }
}

// --------------------------------------------------------------

//
// Function: main
//
// Description:
//    This function loads Winsock, parses the command line, and
//    begins receiving packets. Once a packet is received they
//    are decoded. Because we are receiving IP datagrams, the
//    receive call will return whole datagrams.
//
int __cdecl
main(int argc, char **argv)
{
    SOCKET        s, sockR;
    WSADATA       wsd;
    SOCKADDR_IN   SrcSockAddr;
    SOCKADDR_IN   SAMulticast;
    SOCKADDR_IN   SASender;
    WSA_SETUP_DISPOSITION   disposition;
    ULONG           IpAddress;

    LONG            ret;
    LONG            count, Length, BufferInfo;
    char            *TestBuffer=NULL;
    char            value;

    struct linger   LingerData;
    RM_SEND_WINDOW  RmWindow;
    RM_FEC_INFO     RmFEC;

    time_t          DiffSecs, DiffMSecs;
    LONG            Flags, BytesRead;
    WSABUF          WsaBuf;

    // Parse the command line
    //
    gMCastGroupAddr = inet_addr ("231.7.8.9");
    ValidateArgs(argc, argv);

    if (gClearWinsockInfo)
    {
        //
        // First, stop the service and delete the RMCast registry keys
        //
        system ("sc stop RMCast");
        system ("sc delete RMCast");

        ret = ClearHelperDllRegInfo ();

        if (ret == ERROR_SUCCESS)
        {
            fprintf (stdout, "ClearHelperDllRegInfo  returned <%x>\n", ret);
            //
            // Poke winsock to update the Winsock2 config
            //
            ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
            if (ret != ERROR_SUCCESS)
            {
                fprintf (stderr, "MigrateWinsockConfiguration FAILed <%x>\n", ret);
            }
        }
        else
        {
            fprintf (stderr, "ClearHelperDllRegInfo FAILed <%x>\n", ret);
        }

        if (ret != ERROR_SUCCESS)
        {
            return -1;
        }

        return 0;
    }

    if (gSetWinsockInfo)
    {
        //
        // First, clear any Registry keys that may still be lying around
        // from any previous installation
        //
        ret = ClearHelperDllRegInfo ();

        //
        // Now, rewrite the keys afresh
        //
        ret = SetHelperDllRegInfo ();

        if (ret == ERROR_SUCCESS)
        {
            fprintf (stdout, "SetHelperDllRegInfo  returned <%x>\n", ret);
            //
            // Poke winsock to update the Winsock2 config
            //
            ret = MigrateWinsockConfiguration (&disposition, NULL, 0);
            if (ret != ERROR_SUCCESS)
            {
                fprintf (stderr, "MigrateWinsockConfiguration FAILed <%x>\n", ret);
            }
        }
        else
        {
            fprintf (stderr, "SetHelperDllRegInfo FAILed <%x>\n", ret);
        }

        if (ret != ERROR_SUCCESS)
        {
            return -1;
        }

        return 0;
    }

    ret = 0;
    //
    // Now, check for validity of the parameters
    //
    if (gMinPktSize > gMaxPktSize)
    {
        fprintf (stderr, "ERROR in parameter specification: MinPktSize=%d > MaxPktSize=%d\n",
            gMinPktSize, gMaxPktSize);
        ret = -1;
    }

    if (ret)
    {
        return (ret);
    }

    // Load Winsock
    //
    if (WSAStartup (MAKEWORD(2,2), &wsd) != 0)
    {
        fprintf(stderr, "WSAStartup() failed: %d\n", GetLastError());
        return -1;
    }

    if (gfEnumerateProts)
    {
        EnumerateProtocols();
    }

    TestBuffer = (char *)HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BYTE) * gMaxPktSize);
    if (!TestBuffer)
    {
        fprintf(stderr, "HeapAlloc() for %d bytes failed: ERROR=%d\n", gMaxPktSize, GetLastError());
        WSACleanup();
        return -1;
    }

    if (gReceiver)
    {
        memset (TestBuffer, '#', gMaxPktSize);
    }
    else
    {
        value = 0;
        for (count = 0; count < gMaxPktSize; count++)
        {
            TestBuffer[count] = value++;
        }
    }

    // Create an RMCast socket
    if (INVALID_SOCKET == (s = WSASocket(AF_INET,
                                         SOCK_RMCAST, 
                                         IPPROTO_RM, 
                                         NULL, 
                                         0, 
                                         (WSA_FLAG_MULTIPOINT_C_LEAF |
                                          WSA_FLAG_MULTIPOINT_D_LEAF))))
    {
        fprintf(stderr, "socket() failed: %d\n", WSAGetLastError());
        HeapFree(GetProcessHeap(), 0, TestBuffer);
        WSACleanup();
        return -1;
    }
    fprintf(stdout, "socket SUCCEEDED, s=<%d>\n", s);

    SAMulticast.sin_family = AF_INET;
    SAMulticast.sin_port   = htons (gMCastGroupPort);
    SAMulticast.sin_addr.s_addr = gMCastGroupAddr;

    if (gReceiver)
    {
        fprintf(stdout, "We are Receiver!\n");

        if (bind (s, (SOCKADDR *) &SAMulticast, sizeof(SAMulticast)))
        {
            fprintf(stderr, "bind to (%s:%d) FAILed, status=<%d>\n",
                inet_ntoa(SAMulticast.sin_addr), ntohs(SAMulticast.sin_port), WSAGetLastError());
        }
        else
        {
            fprintf (stdout, "Bind to <%s> succeeded! ...\n", inet_ntoa(SAMulticast.sin_addr));

            if (gListenOnAllInterfaces)
            {
                count = 0;
                while (0 == GetInterface (count, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "\t[%d] Listening on <%s>\n", count, inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_ADD_RECEIVE_IF, (char *)&IpAddress, sizeof(IpAddress));

                    count++;
                }
            }
            else if (gUseSpecifiedInterface)
            {
                //
                // Set an interface to receive IP packets on
                //
                if (0 == GetInterface (gInterface, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "\t[%d] Interface is <%s>\n", gInterface, inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_ADD_RECEIVE_IF, (char *)&IpAddress, sizeof(IpAddress));
                }
                else
                {
                    fprintf (stderr, "Unable to obtain an interface from GetInterface\n");
                }
            }

            //
            // Check if we need to use high-speed intranet optimization
            //
            if (gHighSpeedOptimization)
            {
                setsockopt (s, IPPROTO_RM, RM_HIGH_SPEED_INTRANET_OPT, (char *)&gHighSpeedOptimization, sizeof(gHighSpeedOptimization));
            }

            // listen on the socket
            if (listen (s, 1))
            {
                fprintf(stderr, "listen() FAILed, status=<%x>\n", WSAGetLastError());
            }
            else
            {
                fprintf (stdout, "Listen succeeded! ...\n");

                // join an RMCast session
                Length = sizeof (SOCKADDR);
                sockR = accept (s, (SOCKADDR *) &SASender, &Length);
                if (sockR == INVALID_SOCKET)
                {
                    fprintf(stderr, "accept() failed: %d\n", WSAGetLastError());
                }
                else
                {
                    fprintf(stdout, "Accept succeeded!  s=<%d>, sockR=<%d>, Sender=<%s>\n",
                        s, sockR, inet_ntoa(SASender.sin_addr));

                    // start receiving data
//                    memset (TestBuffer, '@', gMaxPktSize);
                    WsaBuf.buf = TestBuffer;
                    WsaBuf.len = gMaxPktSize;

                    count = 0;
                    Length = gMinPktSize;

                    _ftime (&StartTime);
                    while (TRUE)
                    {
                        * ((PULONG) TestBuffer) = 0;
                        Flags = BytesRead = 0;

/*
                        ret = recv (sockR, TestBuffer, gMaxPktSize, 0);
                        if ((ret==0) || (ret == SOCKET_ERROR))
*/
                        ret = WSARecv (sockR,           // socket
                                       &WsaBuf,         // lpBuffers
                                       1,               // dwBufferCount
                                       &BytesRead,      // lpNumberOfBytesRecvd 
                                       &Flags,          // lpFlags
                                       NULL,            // lpOverlapped
                                       NULL);           // lpCompletionRoutine
                        if (ret)
                        {
                            fprintf(stderr, "WSARecv() FAILed==><%d>, ret=<%d>, count=<%d> BytesRead=<%d>\n",
                                WSAGetLastError(), ret, count, BytesRead);
                            break;
                        }

                        if (Flags)
                        {
                            fprintf(stdout, "[%d : %d] WARNING: BytesRead=<%d>, LastError=<%d>, Flags=<%x>\n",
                                count, Length, BytesRead, WSAGetLastError(), Flags);
                        }

                        TotalBytes += BytesRead;

                        _ftime (&CurrentTime);
                        if (!count++)
                        {
                            PreviousTime = StartTime = CurrentTime;
                        }

                        if (!(count % gStatusInterval))
                        {
                            if (ERROR_SUCCESS == GetReceiverStats (sockR, count))
                            {
                                PreviousTime = CurrentTime;
                            }
                        }

                        if (BytesRead != Length)
                        {
                            fprintf(stderr, "OUT-OF-ORDER:  Expecting <%d>, received <%d>\n",
                                Length, BytesRead);
                            fflush (stdout);
                        }
                        else if (BytesRead != * ((PLONG) TestBuffer))
                        {
                            fprintf(stderr, "BAD-DATA ?  First ULONG=<%d>, BytesRead=<%d>\n",
                                * ((PULONG) TestBuffer), BytesRead);
                            fflush (stdout);
                        }
                        else if (gfVerifyData)
                        {
                            value = TestBuffer[4];
                            for (BufferInfo = 5; BufferInfo < BytesRead; BufferInfo++)
                            {
                                if (++value != TestBuffer[BufferInfo])
                                {
                                    fprintf (stderr, "\tCORRUPT buffer!  Count=<%d>, Offset=<%d/%d> -- ActualValue=<%x>!=<%x>\n",
                                        count, BufferInfo, BytesRead, TestBuffer[BufferInfo], value);
                                    fflush (stdout);
                                    break;
                                }
                            }
                        }

                        Length = BytesRead+1;
                        if (Length > gMaxPktSize)
                        {
                            Length = gMinPktSize;
                        }
                    }

                    fprintf (stdout, "************************ Final Stats ***************************\n");
                    GetReceiverStats (sockR, count);

                    closesocket(sockR);
                }
            }
        }
    }
    else
    {
        fprintf(stdout, "We are Sender!\n");

        // Bind the socket socket
        SrcSockAddr.sin_family = AF_INET;
        SrcSockAddr.sin_port   = htons(0);      // let system pick the port #
        SrcSockAddr.sin_addr.s_addr = 0;        // set default interface = 0 for now
        if (bind (s, (SOCKADDR *)&SrcSockAddr, sizeof(SrcSockAddr)))
        {
            fprintf(stderr, "bind(%s:%d) FAILed: %d\n",
                inet_ntoa(SrcSockAddr.sin_addr), ntohs(SrcSockAddr.sin_port), WSAGetLastError());
        }
        else
        {
            fprintf (stdout, "Bind succeeded! ...\n");

            if (gfSetAfdBufferSize)
            {
                if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (char *) &gAfdBufferSize, sizeof (gAfdBufferSize)) < 0)
                {
                    fprintf (stderr, "SO_SNDBUF FAILed -- <%x>\n", WSAGetLastError());
                }
                else
                {
                    fprintf (stdout, "SO_SNDBUF SUCCEEDed\n");
                }
            }

            //
            // Set an interface to send IP packets on
            //
            if (gUseSpecifiedInterface)
            {
                if (0 == GetInterface (gInterface, &IpAddress, FALSE))
                {
                    SrcSockAddr.sin_addr.s_addr = IpAddress;
                    fprintf (stdout, "Interface <%d> is <%s>\n", gInterface,inet_ntoa(SrcSockAddr.sin_addr));

                    setsockopt (s, IPPROTO_RM, RM_SET_SEND_IF, (char *)&IpAddress, sizeof(IpAddress));
                }
                else
                {
                    fprintf (stderr, "Unable to obtain an interface from GetInterface\n");
                }
            }

            //
            // Check if we need to set the Linger time
            //
            if (gSetLingerTime)
            {
                LingerData.l_onoff = 1;
                LingerData.l_linger = gLingerTime;

                if (setsockopt (s, SOL_SOCKET, SO_LINGER, (char *) &LingerData, sizeof (struct linger)) < 0)
                {
                    fprintf (stderr, "SO_LINGER FAILed -- <%x>\n", WSAGetLastError());
                }
                else
                {
                    fprintf (stdout, "SO_LINGER SUCCEEDed, Lingertime=<%d>\n", (ULONG) gLingerTime);
                }
            }

            //
            // Check if we need to use high-speed intranet optimization
            //
            if (gHighSpeedOptimization)
            {
                setsockopt (s, IPPROTO_RM, RM_HIGH_SPEED_INTRANET_OPT, (char *)&gHighSpeedOptimization, sizeof(gHighSpeedOptimization));
            }

            //
            // Set the transmission rate and window size
            //
            RmWindow.RateKbitsPerSec = gRateKbitsPerSec;
            RmWindow.WindowSizeInMSecs = 0;
            RmWindow.WindowSizeInBytes = 0;
//            RmWindow.WindowSizeInBytes = 50*1000*1000;
            ret = setsockopt (s, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&RmWindow, sizeof(RM_SEND_WINDOW));

            //
            // Now, query the transmission rate and window size (to verify that it got set)
            //
            RmWindow.RateKbitsPerSec = 0;
            Length = sizeof(RM_SEND_WINDOW);
            ret = getsockopt (s, IPPROTO_RM, RM_RATE_WINDOW_SIZE, (char *)&RmWindow, &Length);
            fprintf (stdout, "Rate= %d Kb/sec, WindowSize = %d msecs = %d bytes\n",
                RmWindow.RateKbitsPerSec, RmWindow.WindowSizeInMSecs, RmWindow.WindowSizeInBytes);

            //
            // Set the FEC info if desired
            //
            if (gFECGroupSize)
            {
                RmFEC.FECBlockSize = gFECBlockSize;
                RmFEC.FECGroupSize = gFECGroupSize;
                RmFEC.FECProActivePackets = gFECProActive;
                RmFEC.fFECOnDemandParityEnabled = gfFECOnDemand;

                ret = setsockopt (s, IPPROTO_RM, RM_USE_FEC, (char *)&RmFEC, sizeof(RM_FEC_INFO));
                fprintf (stdout, "RM_USE_FEC: ret = <%x>, gFECGroupSize=<%x>, Pro:OnD=<%x:%x>\n",
                    ret, gFECGroupSize, gFECProActive, gfFECOnDemand);

                RmFEC.FECBlockSize = 0;
                RmFEC.FECGroupSize = 0;
                RmFEC.FECProActivePackets = 0;
                RmFEC.fFECOnDemandParityEnabled = 0;
                Length = sizeof(RM_FEC_INFO);
                ret = getsockopt (s, IPPROTO_RM, RM_USE_FEC, (char *)&RmFEC, &Length);
                fprintf (stdout, "ret=<%x>, BlockSize= %d, GroupSize = %d, ProActive = %d, OnDemand = %s\n",
                    ret, RmFEC.FECBlockSize, RmFEC.FECGroupSize, RmFEC.FECProActivePackets,
                    (RmFEC.fFECOnDemandParityEnabled ? "ENabled" : "DISabled"));
            }

            //
            // Set the Late joiner option
            //
            if (gSetLateJoiner)
            {
                ret = setsockopt (s, IPPROTO_RM, RM_LATEJOIN, (char *)&gLateJoinerPercentage, sizeof(ULONG));
            }

            if (gfSetMCastTtl)
            {
                //
                // Set the MCast packet Ttl
                //
                ret = setsockopt (s, IPPROTO_RM, RM_SET_MCAST_TTL, (char *)&gMCastTtl, sizeof(ULONG));
            }

            //
            // Set the Send-Window Advance-rate
            //
            Length = 20;
            ret = setsockopt (s, IPPROTO_RM, RM_SEND_WINDOW_ADV_RATE, (char *)&Length, sizeof(ULONG));

            //
            // Query the Send-Window Advance-rate
            //
            Length= sizeof(ULONG);
            BufferInfo = 0;
            ret = getsockopt (s, IPPROTO_RM, RM_SEND_WINDOW_ADV_RATE, (char *)&BufferInfo, &Length);
            fprintf (stdout, "ret=<%d>, Length=<%d>, WindowAdvRate=<%d>\n", ret, Length, BufferInfo);

            if (connect (s, (SOCKADDR *)&SAMulticast, sizeof(SAMulticast)))
            {
                fprintf(stderr, "connect to (%s:%d) FAILed, status=<%x>\n",
                    inet_ntoa(SAMulticast.sin_addr), ntohs(SAMulticast.sin_port), WSAGetLastError());
            }
            else
            {
                fprintf (stdout, "Connect to <%s> succeeded! ...\n", inet_ntoa(SAMulticast.sin_addr));

                _ftime (&StartTime);
                PreviousTime = StartTime;

                //
                // Now, send the rest of the data
                //
                Length = gMinPktSize;
                count = 0;
                while (count < gNumSends)
                {
                    * ((PULONG) TestBuffer) = Length;
//                    fprintf (stdout, "\tSending %d/%d  Length=<%d>\n", count, gNumSends, Length);
                    ret = send (s, TestBuffer, Length, 0);
                    if (ret == SOCKET_ERROR)
                    {
                        fprintf(stderr, "[%d]th sendto() failed: %d, Length=<%d>\n",
                            (count+1), WSAGetLastError(), Length);
                        fflush (stdout);

                        break;
                    }

                    Length++;
                    if (Length > gMaxPktSize)
                    {
                        Length = gMinPktSize;
                    }

                    _ftime (&CurrentTime);
                    count++;
                    if (!(count % gStatusInterval))
                    {
                        if (ERROR_SUCCESS == GetSenderStats (s, count))
                        {
                            PreviousTime = CurrentTime;
                        }
                    }
                }

//                fprintf (stdout, "Calling shutdown!\n");
//                shutdown (s, SD_SEND);
                fprintf (stdout, "\nWaiting 10 seconds for receivers to finish receiving ...\n");
                Sleep (10*1000);    // 10 seconds for any receivers to finish receiving data!

                fprintf (stdout, "************************ Final Stats ***************************\n");
                GetSenderStats (s, count);
            }
        }
    }

    HeapFree (GetProcessHeap(), 0, TestBuffer);

    closesocket(s);
    WSACleanup();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\about.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
    about.cpp
    base class for the IAbout interface for MMC

    FILE HISTORY:
    
*/

#include <stdafx.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DEBUG_DECLARE_INSTANCE_COUNTER(CAbout);

CAbout::CAbout() : 
    m_hSmallImage(NULL),
    m_hSmallImageOpen(NULL),
    m_hLargeImage(NULL),
    m_hAppIcon(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CAbout);
}


CAbout::~CAbout()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CAbout);
    if (m_hSmallImage)
    {
        DeleteObject(m_hSmallImage);
    }

    if (m_hSmallImageOpen)
    {
        DeleteObject(m_hSmallImageOpen);
    }

    if (m_hLargeImage)
    {
        DeleteObject(m_hLargeImage);
    }

    if (m_hAppIcon)
    {
        DeleteObject(m_hAppIcon);
    }
}

/*!--------------------------------------------------------------------------
    CAbout::AboutHelper
        Helper to get information from resource file
    Author:
 ---------------------------------------------------------------------------*/
HRESULT 
CAbout::AboutHelper
(
    UINT        nID, 
    LPOLESTR*   lpPtr
)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {

        s.LoadString(nID);
        *lpPtr = reinterpret_cast<LPOLESTR>
                 (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

        if (*lpPtr == NULL)
            return E_OUTOFMEMORY;

        lstrcpy(*lpPtr, (LPCTSTR)s);
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CAbout::GetSnapinDescription
        MMC calls this to get the snapin's description
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinDescription
(
    LPOLESTR* lpDescription
)
{
    return AboutHelper(GetAboutDescriptionId(), lpDescription);
}

/*!--------------------------------------------------------------------------
    CAbout::GetProvider
        MMC calls this to get the snapin's provider
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetProvider
(
    LPOLESTR* lpName
)
{
    return AboutHelper(GetAboutProviderId(), lpName);
}

/*!--------------------------------------------------------------------------
    CAbout::AboutHelper
        MMC calls this to get the snapin's version
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinVersion
(
    LPOLESTR* lpVersion
)
{
    return AboutHelper(GetAboutVersionId(), lpVersion);
}

/*!--------------------------------------------------------------------------
    CAbout::GetSnapinImage
        MMC calls this to get the snapin's icon
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetSnapinImage
(
    HICON* hAppIcon
)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (NULL == m_hAppIcon)
    {
        m_hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetAboutIconId()));
    }
    *hAppIcon = m_hAppIcon;

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


/*!--------------------------------------------------------------------------
    CAbout::GetStaticFolderImage
        MMC calls this to get the bitmap for the snapin's root node
    Author:
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CAbout::GetStaticFolderImage
(
    HBITMAP* hSmallImage, 
    HBITMAP* hSmallImageOpen, 
    HBITMAP* hLargeImage, 
    COLORREF* cLargeMask
)
{
    if (NULL == hSmallImage || NULL == hSmallImageOpen || NULL == hLargeImage)
    {
        return E_POINTER;
    }

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (NULL == m_hSmallImage)
    {
        m_hSmallImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetSmallRootId()));
    }
    *hSmallImage = m_hSmallImage;

    if (NULL == m_hSmallImageOpen)
    {
        m_hSmallImageOpen = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetSmallOpenRootId()));
    }
    *hSmallImageOpen = m_hSmallImageOpen;

    if (NULL == m_hLargeImage)
    {
        m_hLargeImage = LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(GetLargeRootId()));
    }
    *hLargeImage = m_hLargeImage;

    *cLargeMask = GetLargeColorMask();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\basehand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	basehand.h
        base classes for node handlers.
		
    FILE HISTORY:
	
*/

#ifndef _BASEHAND_H
#define _BASEHAND_H

#ifndef _TFSINT_H
#include "tfsint.h"
#endif

#ifndef _TFSNODE_H
#include "tfsnode.h"
#endif

/*---------------------------------------------------------------------------
	Class:  CBaseHandler

	This class provides functionality for handling notification from the
	IComponentData interface on a node (or handler) basis.  The 
	CBaseResultHandler class handles notifcation to the IConponent interface
	that a snapin exposes.
 ---------------------------------------------------------------------------*/

#define OVERRIDE_BaseHandlerNotify_OnPropertyChange() \
 virtual HRESULT OnPropertyChange(ITFSNode *pNode,LPDATAOBJECT pdo,DWORD dwType,LPARAM arg,LPARAM lParam) \
												
#define OVERRIDE_BaseHandlerNotify_OnDelete() \
 virtual HRESULT OnDelete(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnRename() \
 virtual HRESULT OnRename(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnRemoveChildren() \
	virtual HRESULT OnRemoveChildren(ITFSNode *pNode,LPDATAOBJECT pdo,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnExpandSync() \
	virtual HRESULT OnExpandSync(ITFSNode *pNode,LPDATAOBJECT pdo,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnExpand() \
 virtual HRESULT OnExpand(ITFSNode *pNode,LPDATAOBJECT pdo, DWORD dwType, LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnContextMenu() \
 virtual HRESULT OnContextMenu(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbCopy() \
 virtual HRESULT OnVerbCopy(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbPaste() \
 virtual HRESULT OnVerbPaste(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbDelete() \
 virtual HRESULT OnVerbDelete(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbProperties() \
 virtual HRESULT OnVerbProperties(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbRename() \
 virtual HRESULT OnVerbRename(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbRefresh() \
 virtual HRESULT OnVerbRefresh(ITFSNode *pNode,LPARAM arg,LPARAM lParam)

#define OVERRIDE_BaseHandlerNotify_OnVerbPrint() \
 virtual HRESULT OnVerbPrint(ITFSNode *pNode,LPARAM arg,LPARAM lParam)              

#define OVERRIDE_BaseHandlerNotify_OnRestoreView() \
 virtual HRESULT OnRestoreView(ITFSNode *pNode,LPARAM arg,LPARAM lParam)              

#define OVERRIDE_BaseHandlerNotify_OnCreateNodeId2() \
 virtual HRESULT OnCreateNodeId2(ITFSNode *pNode,CString & strId,LPDWORD pdwFlags)              

//class TFS_EXPORT_CLASS CBaseHandler :
class CBaseHandler :
	public ITFSNodeHandler
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareITFSNodeHandlerMembers(IMPL)
			
	CBaseHandler(ITFSComponentData *pTFSCompData);
	virtual ~CBaseHandler();

	// Here are the possible notifications
	OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseHandlerNotify_OnDelete();
	OVERRIDE_BaseHandlerNotify_OnRename();
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();
	OVERRIDE_BaseHandlerNotify_OnExpandSync();
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseHandlerNotify_OnContextMenu();
	OVERRIDE_BaseHandlerNotify_OnVerbCopy();
	OVERRIDE_BaseHandlerNotify_OnVerbPaste();
	OVERRIDE_BaseHandlerNotify_OnVerbDelete();
	OVERRIDE_BaseHandlerNotify_OnVerbProperties();
	OVERRIDE_BaseHandlerNotify_OnVerbRename();
	OVERRIDE_BaseHandlerNotify_OnVerbRefresh();
	OVERRIDE_BaseHandlerNotify_OnVerbPrint();
	OVERRIDE_BaseHandlerNotify_OnRestoreView();
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

protected:
	SPITFSComponentData     m_spTFSCompData;
	SPITFSNodeMgr           m_spNodeMgr;

	long                    m_cRef;
};


/*---------------------------------------------------------------------------
	Class:	CBaseResultHandler
 ---------------------------------------------------------------------------*/

#define OVERRIDE_BaseResultHandlerNotify_OnResultActivate() \
	virtual HRESULT OnResultActivate(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick() \
	virtual HRESULT OnResultColumnClick(ITFSComponent *, LPARAM, BOOL)

#define OVERRIDE_BaseResultHandlerNotify_OnResultColumnsChanged() \
    virtual HRESULT OnResultColumnsChanged(ITFSComponent *, LPDATAOBJECT, MMC_VISIBLE_COLUMNS *)

#define OVERRIDE_BaseResultHandlerNotify_OnResultDelete() \
	virtual HRESULT OnResultDelete(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRename() \
	virtual HRESULT OnResultRename(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRefresh() \
	virtual HRESULT OnResultRefresh(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp() \
	virtual HRESULT OnResultContextHelp(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultQueryPaste() \
	virtual HRESULT OnResultQueryPaste(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange() \
	virtual HRESULT OnResultPropertyChange(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk() \
	virtual HRESULT OnResultItemClkOrDblClk(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM,BOOL)

#define OVERRIDE_BaseResultHandlerNotify_OnResultMinimize() \
	virtual HRESULT OnResultMinimize(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultSelect() \
	virtual HRESULT OnResultSelect(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultInitOcx() \
	virtual HRESULT OnResultInitOcx(ITFSComponent *,LPDATAOBJECT,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultShow() \
	virtual HRESULT OnResultShow(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView() \
	virtual HRESULT OnResultUpdateView(ITFSComponent *,LPDATAOBJECT,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbCopy() \
	virtual HRESULT OnResultVerbCopy(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbPaste() \
	virtual HRESULT OnResultVerbPaste(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbDelete() \
	virtual HRESULT OnResultVerbDelete(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbProperties() \
	virtual HRESULT OnResultVerbProperties(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbRename() \
	virtual HRESULT OnResultVerbRename(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbPrint() \
	virtual HRESULT OnResultVerbPrint(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultVerbRefresh() \
	virtual HRESULT OnResultVerbRefresh(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

#define OVERRIDE_BaseResultHandlerNotify_OnResultRestoreView() \
	virtual HRESULT OnResultRestoreView(ITFSComponent *,MMC_COOKIE,LPARAM,LPARAM)

//class TFS_EXPORT_CLASS CBaseResultHandlerNotify :
class CBaseResultHandler :
	public ITFSResultHandler
{
public:
	CBaseResultHandler(ITFSComponentData *pTFSCompData);
	virtual ~CBaseResultHandler();

	DeclareIUnknownMembers(IMPL)
	DeclareITFSResultHandlerMembers(IMPL)

	// Here are the possible notifications
	OVERRIDE_BaseResultHandlerNotify_OnResultActivate();
	OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick();
    OVERRIDE_BaseResultHandlerNotify_OnResultColumnsChanged();
	OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultRename();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();
	OVERRIDE_BaseResultHandlerNotify_OnResultQueryPaste();
	OVERRIDE_BaseResultHandlerNotify_OnResultItemClkOrDblClk();
	OVERRIDE_BaseResultHandlerNotify_OnResultMinimize();
	OVERRIDE_BaseResultHandlerNotify_OnResultPropertyChange();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultInitOcx();
    OVERRIDE_BaseResultHandlerNotify_OnResultShow();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

	OVERRIDE_BaseResultHandlerNotify_OnResultVerbCopy();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbPaste();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbProperties();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbRename();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultVerbPrint();
	OVERRIDE_BaseResultHandlerNotify_OnResultRestoreView();
	
	// Over-ride these to provide custom column functionality
	// or custom ways to add things to the result pane
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT EnumerateResultPane(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
	virtual HRESULT SortColumns(ITFSComponent *);
    
    virtual HRESULT SetVirtualLbSize(ITFSComponent * pComponent, LONG_PTR data);
    virtual HRESULT ClearVirtualLb(ITFSComponent * pComponent, LONG_PTR data);

	void SetColumnStringIDs(UINT * pStringIDs) { m_pColumnStringIDs = pStringIDs; }
	void SetColumnWidths(int * pWidths) { m_pColumnWidths = pWidths; }
	void SetColumnFormat(int nColumnFormat) { m_nColumnFormat = nColumnFormat; }

    HRESULT ShowMessage(ITFSNode * pNode, LPCTSTR pszTitle, LPCTSTR pszBody, IconIdentifier lIcon);
    HRESULT ClearMessage(ITFSNode * pNode);

    virtual HRESULT FIsTaskpadPreferred(ITFSComponent *pComponent);
    virtual HRESULT DoTaskpadResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam, BOOL bTaskPadView);

protected:
    HRESULT ChangeResultPaneItem(ITFSComponent *, ITFSNode *, LONG_PTR);
    HRESULT AddResultPaneItem(ITFSComponent *, ITFSNode *);
    HRESULT DeleteResultPaneItem(ITFSComponent *, ITFSNode *);
    HRESULT ShowResultMessage(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam);

    BOOL    IsMessageView() {return m_fMessageView;}

protected:
	SPITFSComponentData     m_spTFSComponentData;
	SPITFSNodeMgr           m_spResultNodeMgr;

private:
	UINT *					m_pColumnStringIDs;
	int *					m_pColumnWidths;
   	int						m_nColumnFormat;

	LONG			        m_cRef;

    // result message view stuff
    BOOL                    m_fMessageView;
    CString                 m_strMessageTitle;
    CString                 m_strMessageBody;
    IconIdentifier          m_lMessageIcon;
};

#endif _BASEHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mcast\pgm\sys\i386\xsumw2k.asm ===
title  "Compute Checksum"

;/*++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    cksy.asm
;
; Abstract:
;
;    This module implements a function to compute the checksum of a buffer.
;
; Author:
;
;    David N. Cutler (davec) 27-Jan-1992
;
; Revision History:
;
;     Who         When        What
;     --------    --------    ----------------------------------------------
;     mikeab      01-22-94    Pentium optimization
;
; Environment:
;
;    Any mode.
;
; Revision History:
;
;--*/

LOOP_UNROLLING_BITS     equ     5
LOOP_UNROLLING          equ     (1 SHL LOOP_UNROLLING_BITS)

        .386
        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include callconv.inc
        include ks386.inc
        .list

        .code

;++
;
; ULONG
; tcpxsum(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word:
        jmp     checksum_last_word

to_checksum_done:
        jmp     checksum_done

to_checksum_dword_loop_done:
        jmp     checksum_dword_loop_done

cPublicProc tcpxsum,3

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     loop_entry[ebx*4]       ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING
        deflab  loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word label proc           ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done     ; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done label proc                ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine label proc             ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING*4
        REPT    LOOP_UNROLLING-1
TEMP=TEMP-4
        reflab  loop_entry_,%TEMP
        ENDM






stdENDP tcpxsum



LOOP_UNROLLING_BITS_XMMI     equ     4
LOOP_UNROLLING_XMMI          equ     (1 SHL LOOP_UNROLLING_BITS_XMMI)

;VRSTEST EQU     0
ifdef VRSTEST
;
; Test tcpxsum_xmmi for correctness.
tcksum   equ     8[ebp]                   ; stack offset to initial checksum
tbuf     equ     12[ebp]                   ; stack offset to source address
tlen     equ     16[ebp]                  ; stack offset to length in words
        align
cPublicProc tcpxsum_xmmi,3
        ;int     3
        push    ebp
        mov     ebp, esp
        push    ebx
        push    esi
        mov     ebx, offset tcpxsum
        mov     esi, offset tcpxsum_xmmi1
        ; Get a "random" number
        .586p
        rdtsc
        .386p
        and     eax, 10H
        jz      old_then_new
        ; Swap which routine is called first
        push    ebx
        mov     ebx, esi
        pop     esi
old_then_new:
        ; Call the first routine
        push    tlen
        push    tbuf
        push    tcksum
        call    ebx
        ; Save the answer
        push    eax
        ; Call the second routine
        push    tlen
        push    tbuf
        push    tcksum
        call    esi
        ; Check the answer
        cmp     eax, [esp]
        jnz     different_xsum
        ; Same answer, we are done
        pop     eax
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  tcpxsum_xmmi
        align
        ; Different answers, need to debug the problem
different_xsum:
        ; Get both checksums onto the stack
        push    eax
        ; ... and bugcheck
        ;EXTRNP  _KeBugCheck,1,IMPORT
        ;stdCall   _KeBugCheck, <0>
again:
        int     3
        jmp     again
stdENDP tcpxsum_xmmi
endif


;++
;
; ULONG
; tcpxsum_xmmi(
;   IN ULONG cksum,
;   IN PUCHAR buf,
;   IN ULONG len
;   )
;
; Routine Description:
;
;    This function computes the checksum of the specified buffer.
;    It uses Processor's prefetch instruction.
;
; Arguments:
;
;    cksum - Suppiles the initial checksum value, in 16-bit form,
;            with the high word set to 0.
;
;    buf - Supplies a pointer to the buffer to the checksum buffer.
;
;    len - Supplies the length of the buffer in bytes.
;
; Return Value:
;
;    The computed checksum in 32-bit two-partial-accumulators form, added to
;    the initial checksum, is returned as the function value.
;
;--

cksum   equ     12                      ; stack offset to initial checksum
buf     equ     16                      ; stack offset to source address
len     equ     20                      ; stack offset to length in words

to_checksum_last_word_xmmi:
        jmp     checksum_last_word_xmmi

to_checksum_done_xmmi:
        jmp     checksum_done_xmmi

to_checksum_dword_loop_done_xmmi:
        jmp     checksum_dword_loop_done_xmmi

ifdef VRSTEST
cPublicProc tcpxsum_xmmi1,3
else
cPublicProc tcpxsum_xmmi,3
endif

        push    ebx                     ; save nonvolatile register
        push    esi                     ; save nonvolatile register

        mov     ecx,[esp + len]         ; get length in bytes
        sub     eax,eax                 ; clear computed checksum
        test    ecx,ecx                 ; any bytes to checksum at all?
        jz      short to_checksum_done_xmmi  ; no bytes to checksum

;
; if the checksum buffer is not word aligned, then add the first byte of
; the buffer to the input checksum.
;

        mov     esi,[esp + buf]         ; get source address
        sub     edx,edx                 ; set up to load word into EDX below
        test    esi,1                   ; check if buffer word aligned
        jz      short checksum_word_aligned ; if zf, buffer word aligned
        mov     ah,[esi]                ; get first byte (we know we'll have
                                        ;  to swap at the end)
        inc     esi                     ; increment buffer address
        dec     ecx                     ; decrement number of bytes
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; If the buffer is not an even number of of bytes, then initialize
; the computed checksum with the last byte of the buffer.
;

checksum_word_aligned:                  ;
        shr     ecx,1                   ; convert to word count
        jnc     short checksum_start    ; if nc, even number of bytes
        mov     al,[esi+ecx*2]          ; initialize the computed checksum
        jz      short to_checksum_done_xmmi  ; if zf set, no more bytes

;
; Compute checksum in large blocks of dwords, with one partial word up front if
; necessary to get dword alignment, and another partial word at the end if
; needed.
;

;
; Compute checksum on the leading word, if that's necessary to get dword
; alignment.
;

checksum_start:                         ;
        test    esi,02h                 ; check if source dword aligned
        jz      short checksum_dword_aligned ; source is already dword aligned
        mov     dx,[esi]                ; get first word to checksum
        add     esi,2                   ; update source address
        add     eax,edx                 ; update partial checksum
                                        ;  (no carry is possible, because EAX
                                        ;  and EDX are both 16-bit values)
        dec     ecx                     ; count off this word (zero case gets
                                        ;  picked up below)

;
; Checksum as many words as possible by processing a dword at a time.
;

checksum_dword_aligned:
        push    ecx                     ; so we can tell if there's a trailing
                                        ;  word later
        shr     ecx,1                   ; # of dwords to checksum
        jz      short to_checksum_last_word_xmmi ; no dwords to checksum

        mov     edx,[esi]               ; preload the first dword
        add     esi,4                   ; point to the next dword
        dec     ecx                     ; count off the dword we just loaded
        jz      short to_checksum_dword_loop_done_xmmi
                                        ; skip the loop if that was the only
                                        ;  dword
        mov     ebx,ecx                 ; EBX = # of dwords left to checksum
        add     ecx,LOOP_UNROLLING_XMMI-1    ; round up loop count
        shr     ecx,LOOP_UNROLLING_BITS_XMMI ; convert from word count to unrolled
                                        ;  loop count
        and     ebx,LOOP_UNROLLING_XMMI-1    ; # of partial dwords to do in first
                                        ;  loop
        jz      short checksum_dword_loop ; special-case when no partial loop,
                                          ;  because fixup below doesn't work
                                          ;  in that case (carry flag is
                                          ;  cleared at this point, as required
                                          ;  at loop entry)
        lea     esi,[esi+ebx*4-(LOOP_UNROLLING_XMMI*4)]
                                        ; adjust buffer pointer back to
                                        ;  compensate for hardwired displacement
                                        ;  at loop entry point
                                        ; ***doesn't change carry flag***
        jmp     xmmi_loop_entry[ebx*4]  ; enter the loop to do the first,
                                        ; partial iteration, after which we can
                                        ; just do 64-word blocks
                                        ; ***doesn't change carry flag***

checksum_dword_loop:
        ; prefetch the 32-byte cache line from [esi+0]
        db 0fH
        db 18H
        db 46H
        db 00H

        ; prefetch the 32-byte cache line from [esi+20h]
        db 0fH
        db 18H
        db 46H
        db 20H

        ; prefetch the 32-byte cache line from [esi+40h]
        db 0fH
        db 18H
        db 46H
        db 40H

        ; prefetch the 32-byte cache line from [esi+60h]
        db 0fH
        db 18H
        db 46H
        db 60H

DEFLAB  macro   pre,suf
pre&suf:
        endm

TEMP=0
        REPT    LOOP_UNROLLING_XMMI
        deflab  xmmi_loop_entry_,%TEMP
        adc     eax,edx
        mov     edx,[esi + TEMP]
TEMP=TEMP+4
        ENDM

checksum_dword_loop_end:

        lea     esi,[esi + LOOP_UNROLLING_XMMI * 4]  ; update source address
                                        ; ***doesn't change carry flag***
        dec     ecx                     ; count off unrolled loop iteration
                                        ; ***doesn't change carry flag***
        jnz     checksum_dword_loop     ; do more blocks

checksum_dword_loop_done_xmmi label proc
        adc     eax,edx                 ; finish dword checksum
        mov     edx,0                   ; prepare to load trailing word
        adc     eax,edx

;
; Compute checksum on the trailing word, if there is one.
; High word of EDX = 0 at this point
; Carry flag set iff there's a trailing word to do at this point
;

checksum_last_word_xmmi label proc      ; "proc" so not scoped to function
        pop     ecx                     ; get back word count
        test    ecx,1                   ; is there a trailing word?
        jz      short checksum_done_xmmi; no trailing word
        add     ax,[esi]                ; add in the trailing word
        adc     eax,0                   ;

checksum_done_xmmi label proc           ; "proc" so not scoped to function
        mov     ecx,eax                 ; fold the checksum to 16 bits
        ror     ecx,16
        add     eax,ecx
        mov     ebx,[esp + buf]
        shr     eax,16
        test    ebx,1                   ; check if buffer word aligned
        jz      short checksum_combine_xmmi  ; if zf set, buffer word aligned
        ror     ax,8                    ; byte aligned--swap bytes back
checksum_combine_xmmi label proc        ; "proc" so not scoped to function
        add     ax,word ptr [esp + cksum] ; combine checksums
        pop     esi                     ; restore nonvolatile register
        adc     eax,0                   ;
        pop     ebx                     ; restore nonvolatile register
        stdRET  tcpxsum


REFLAB  macro   pre,suf
        dd      pre&suf
        endm

        align   4
xmmi_loop_entry      label   dword
        dd      0
TEMP=LOOP_UNROLLING_XMMI*4
        REPT    LOOP_UNROLLING_XMMI-1
TEMP=TEMP-4
        reflab  xmmi_loop_entry_,%TEMP
        ENDM

ifdef VRSTEST
stdENDP tcpxsum_xmmi1
else
stdENDP tcpxsum_xmmi
endif




;++
;
; PSINGLE_LIST_ENTRY
; FASTCALL
; InterlockedFlushSList (
;    IN PSINGLE_LIST_ENTRY ListHead
;    )
;
; Routine Description:
;
;    This function removes the entire list from a sequenced singly
;    linked list so that access to the list is synchronized in an MP system.
;    If there are no entries in the list, then a value of NULL is returned.
;    Otherwise, the address of the entry at the top of the list is removed
;    and returned as the function value and the list header is set to point
;    to NULL.
;
;    N.B. The cmpxchg8b instruction is only supported on some processors.
;         If the host processor does not support this instruction, then
;         then following code is patched to contain a jump to the normal
;         pop entry code which has a compatible calling sequence and data
;         structure.
;
; Arguments:
;
;    (ecx) = ListHead - Supplies a pointer to the sequenced listhead from
;         which the list is to be flushed.
;
; Return Value:
;
;    The address of the entire current list, or NULL if the list is
;    empty.
;
;--

cPublicProc InterlockedFlushSList, 1



;
; Save nonvolatile registers and read the listhead sequence number followed
; by the listhead next link.
;
; N.B. These two dwords MUST be read exactly in this order.
;


        push    ecx

        push    ebx                     ; save nonvolatile registers
        push    ebp                     ;
        mov     ecx, [esp+16]
        mov     ebp, ecx                ; save listhead address
        mov     edx, [ebp] + 4          ; get current sequence number
        mov     eax, [ebp] + 0          ; get current next link

;
; N.B. The following code is the retry code should the compare
;      part of the compare exchange operation fail
;
; If the list is empty, then there is nothing that can be removed.
;

Efls10: or      eax, eax                ; check if list is empty
        jz      short Efls20            ; if z set, list is empty
        mov     ecx, 0	                ; clear sequence number and depth
        mov     ebx, 0                  ; clear successor entry pointer

.586
ifndef NT_UP

   lock cmpxchg8b qword ptr [ebp]       ; compare and exchange

else

        cmpxchg8b qword ptr [ebp]       ; compare and exchange

endif
.386

        jnz     short Efls10            ; if z clear, exchange failed

;
; Restore nonvolatile registers and return result.
;



Efls20: pop     ebp                     ; restore nonvolatile registers
        pop     ebx                     ;
        pop     ecx

        stdRET    InterlockedFlushSList

stdENDP InterlockedFlushSList







        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\busydlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    busydlg.h
	base class for the busy dialog

    FILE HISTORY:
	
*/

#ifndef _BUSYDLG_H
#define _BUSYDLG_H

/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

class CWorkerThread : public CWinThread
{
public:
	CWorkerThread();
	virtual ~CWorkerThread();

	BOOL Start(HWND hWnd);
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run() { return -1;}					// MFC override

	void Lock() { ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	void Abandon();
	BOOL IsAbandoned();

	void AcknowledgeExiting() { VERIFY(0 != ::SetEvent(m_hEventHandle));}

protected:
	virtual void OnAbandon() {}

protected:
	BOOL PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam);
	void WaitForExitAcknowledge();

private:
	CRITICAL_SECTION		m_cs;	
	HANDLE					m_hEventHandle;

	HWND					m_hWnd;
	BOOL					m_bAbandoned;
};

/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

class CLongOperationDialog; // fwd decl

class CDlgWorkerThread : public CWorkerThread
{
public:
	CDlgWorkerThread();

	BOOL Start(CLongOperationDialog* pDlg);
	virtual int Run();								// MFC override

	DWORD GetError() { return m_dwErr;}

protected:
	virtual void OnDoAction() = 0;

	DWORD m_dwErr;

private:
	BOOL PostMessageToDlg();
};


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

class CLongOperationDialog : public CDialog
{
// Construction
public:
	static UINT s_nNotificationMessage;
	CLongOperationDialog(CDlgWorkerThread* pThreadObj, UINT nAviID = -1);
	virtual ~CLongOperationDialog();

	BOOL LoadTitleString(UINT nID);
	BOOL LoadDescriptionString(UINT nID);

    void EnableCancel(BOOL bCancel) { m_bCancel = bCancel; }

    CDlgWorkerThread* GetThreadObj() 
	{
		ASSERT(m_pThreadObj != NULL);
		return m_pThreadObj;
	}

	UINT m_nAviID;
	CString m_strTitle;
    CString m_strDescription;
    BOOL m_bAbandoned;

	afx_msg LONG OnNotificationMessage( WPARAM wParam, LPARAM lParam); 

// Implementation
protected:
	// Generated message map functions
	virtual BOOL OnInitDialog();
	virtual void OnCancel();

	DECLARE_MESSAGE_MAP()

private:
	CDlgWorkerThread*   m_pThreadObj;
    BOOL                m_bCancel;
};

#endif _BUSYDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\about.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    about.h
     prototypes for the IAbout interface for MMC

    FILE HISTORY:
    
*/

#ifndef _ABOUT_H
#define _ABOUT_H

class CAbout : 
    public ISnapinAbout,
    public CComObjectRoot
{
public:
    CAbout();
    ~CAbout();

public:
//DECLARE_REGISTRY(CSnapin, _T("Snapin.About.1"), _T("Snapin.About"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Must override
protected:
    virtual UINT GetAboutDescriptionId() = 0;
    virtual UINT GetAboutProviderId() = 0;
    virtual UINT GetAboutVersionId() = 0;
    virtual UINT GetAboutIconId() = 0;

    // helpers for the GetStaticFolderImage
    virtual UINT GetSmallRootId() = 0;
    virtual UINT GetSmallOpenRootId() = 0;
    virtual UINT GetLargeRootId() = 0;
    virtual COLORREF GetLargeColorMask() = 0;

private:
    HBITMAP m_hSmallImage;
    HBITMAP m_hSmallImageOpen;
    HBITMAP m_hLargeImage;
    HICON   m_hAppIcon;
        
// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\basehand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	node.cpp
		Root node information (the root node is not displayed
		in the MMC framework but contains information such as 
		all of the subnodes in this snapin).
		
    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "basehand.h"
#include "util.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CBaseHandler);

/*!--------------------------------------------------------------------------
	CBaseHandler::CBaseHandler
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CBaseHandler::CBaseHandler(ITFSComponentData *pTFSCompData)
	: m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBaseHandler);

	m_spTFSCompData.Set(pTFSCompData);
	pTFSCompData->GetNodeMgr(&m_spNodeMgr);
}

CBaseHandler::~CBaseHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CBaseHandler);
}

IMPLEMENT_ADDREF_RELEASE(CBaseHandler)

STDMETHODIMP CBaseHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
	*ppv = (LPVOID) this;
	else if (riid == IID_ITFSNodeHandler)
		*ppv = (ITFSNodeHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}


STDMETHODIMP CBaseHandler::DestroyHandler(ITFSNode *pNode)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::Notify
		Implementation of ITFSNodeHandler::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::Notify(ITFSNode *pNode, IDataObject *pDataObject,
								  DWORD dwType, MMC_NOTIFY_TYPE event, 
								  LPARAM arg, LPARAM lParam)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	switch (event)
	{
		case MMCN_PROPERTY_CHANGE:
			hr = OnPropertyChange(pNode, pDataObject, dwType, arg, lParam);
			break;
		
		case MMCN_EXPAND:
			{
				// when MMC calls us to expand the root node, it
				// hands us the scopeID.  We need to save it off here.
				SPITFSNode spRootNode;
				m_spNodeMgr->GetRootNode(&spRootNode);
				if (pNode == spRootNode)
					pNode->SetData(TFS_DATA_SCOPEID, lParam);

				// now walk the list of children for this node and 
				// show them (they may have been added to the internal tree,
				// but not the UI before this node was expanded 
				SPITFSNodeEnum spNodeEnum;
		        ITFSNode * pCurrentNode;
				ULONG nNumReturned = 0;

		        pNode->GetEnum(&spNodeEnum);

				spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
				while (nNumReturned)
				{
					if (pCurrentNode->IsVisible() && !pCurrentNode->IsInUI())
						pCurrentNode->Show();

					pCurrentNode->Release();
					spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
				}

				// Now call the notification handler for specific functionality
				hr = OnExpand(pNode, pDataObject, dwType, arg, lParam);
			}
			break;
		
        case MMCN_DELETE:
			hr = OnDelete(pNode, arg, lParam);
			break;

        case MMCN_RENAME:
			hr = OnRename(pNode, arg, lParam);
			break;

/*		case MMCN_CONTEXTMENU:
			hr = OnContextMenu(pNode, arg, lParam);
			break;
*/
        case MMCN_REMOVE_CHILDREN:
            hr = OnRemoveChildren(pNode, pDataObject, arg, lParam);
            break;

		case MMCN_EXPANDSYNC:
            hr = OnExpandSync(pNode, pDataObject, arg, lParam);
			break;

        case MMCN_BTN_CLICK:
			switch (lParam)
			{
				case MMC_VERB_COPY:
					hr = OnVerbCopy(pNode, arg, lParam);
					break;
				case MMC_VERB_PASTE:
					hr = OnVerbPaste(pNode, arg, lParam);
					break;
				case MMC_VERB_DELETE:
					hr = OnVerbDelete(pNode, arg, lParam);
					break;
				case MMC_VERB_PROPERTIES:
					hr = OnVerbProperties(pNode, arg, lParam);
					break;
				case MMC_VERB_RENAME:
					hr = OnVerbRename(pNode, arg, lParam);
					break;
				case MMC_VERB_REFRESH:
					hr = OnVerbRefresh(pNode, arg, lParam);
					break;
				case MMC_VERB_PRINT:
					hr = OnVerbPrint(pNode, arg, lParam);
					break;
			};
        break;

        case MMCN_RESTORE_VIEW:
            hr = OnRestoreView(pNode, arg, lParam);
            break;

        default:
			Panic1("Uknown event in CBaseHandler::Notify! 0x%x", event);  // Handle new messages
			hr = S_FALSE;
			break;

	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::CreatePropertyPages
		Implementation of ITFSNodeHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::CreatePropertyPages(ITFSNode *pNode,
											   LPPROPERTYSHEETCALLBACK lpProvider, 
											   LPDATAOBJECT pDataObject, 
											   LONG_PTR handle, 
											   DWORD dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;

	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		SPITFSNode              spRootNode;
		SPITFSNodeHandler       spHandler;
			
		// get the root node
		m_spNodeMgr->GetRootNode(&spRootNode);
		spRootNode->GetHandler(&spHandler);
		spHandler->CreatePropertyPages(spRootNode, lpProvider, pDataObject,
									   handle, dwType);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::HasPropertyPages(ITFSNode *pNode,
											LPDATAOBJECT pDataObject, 
											DATA_OBJECT_TYPES       type, 
											DWORD                           dwType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		
		SPITFSNode              spRootNode;
		SPITFSNodeHandler       spHandler;
			
		// get the root node
		m_spNodeMgr->GetRootNode(&spRootNode);
		spRootNode->GetHandler(&spHandler);
		hr = spHandler->HasPropertyPages(spRootNode, pDataObject, type, dwType);
	}
	else
	{
		// we have no property pages in the normal case
		hr = S_FALSE;
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::OnAddMenuItems
		Implementation of ITFSNodeHandler::OnAddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnAddMenuItems(ITFSNode *pNode,
										  LPCONTEXTMENUCALLBACK pContextMenuCallback, 
										  LPDATAOBJECT lpDataObject, 
										  DATA_OBJECT_TYPES type, 
										  DWORD dwType,
										  long *pInsertionAllowed)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseHandler::OnCommand
		Implementation of ITFSNodeHandler::OnCommand
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnCommand(ITFSNode *pNode,
									 long nCommandId, 
									 DATA_OBJECT_TYPES      type, 
									 LPDATAOBJECT pDataObject, 
									 DWORD  dwType)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR)CBaseHandler::GetString(ITFSNode *pNode, int nCol)
{
	return _T("Foo");
}

/*!--------------------------------------------------------------------------
	CBaseHandler::UserNotify
		Implememntation of ITFSNodeHandler::UserNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::UserNotify(ITFSNode *pNode, LPARAM dwParam1, LPARAM dwParam2)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseHandler::OnCreateDataObject
		Implementation of ITFSNodeHandler::OnCreateDataObject
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	// this relies on the ComponentData to do this work
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseHandler::CreateNodeId2
		Implementation of ITFSNodeHandler::CreateNodeId2
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseHandler::CreateNodeId2(ITFSNode * pNode, BSTR * pbstrId, DWORD * pdwFlags)
{
    HRESULT hr = S_FALSE;
	CString strId;

    COM_PROTECT_TRY
    {
        if (pbstrId == NULL) 
            return hr;

        // call the handler function to get the data
        hr = OnCreateNodeId2(pNode, strId, pdwFlags);
        if (SUCCEEDED(hr) && hr != S_FALSE)
        {
            *pbstrId = ::SysAllocString((LPOLESTR) (LPCTSTR) strId);
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

/*---------------------------------------------------------------------------
	CBaseHandler Notifications
 ---------------------------------------------------------------------------*/

HRESULT CBaseHandler::OnPropertyChange(ITFSNode *pNode, LPDATAOBJECT pDataobject, DWORD dwType, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_PROPERTY_CHANGE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnDelete(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnRename(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnExpand(ITFSNode *pNode, LPDATAOBJECT pDataObject, DWORD dwType, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_EXPAND) received\n");
	return hrOK;
}

HRESULT CBaseHandler::OnRemoveChildren(ITFSNode *pNode, LPDATAOBJECT pDataObject, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_REMOVECHILDREN) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnExpandSync(ITFSNode *pNode, LPDATAOBJECT pDataObject, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_EXPANDSYNC) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnContextMenu(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_CONTEXTMENU) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbCopy(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_COPY) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbPaste(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbDelete(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbProperties(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PROPERTIES) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbRename(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbRefresh(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnVerbPrint(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_VERB_PRINT) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnRestoreView(ITFSNode *pNode, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponentData::Notify(MMCN_RESTORE_VIEW) received\n");
	return S_FALSE;
}

HRESULT CBaseHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * pdwFlags)
{
	return S_FALSE;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CBaseResultHandler);

/*---------------------------------------------------------------------------
	CBaseResultHandler implementation
 ---------------------------------------------------------------------------*/
CBaseResultHandler::CBaseResultHandler(ITFSComponentData *pTFSCompData)
    : m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBaseResultHandler);

	m_spTFSComponentData.Set(pTFSCompData);
	pTFSCompData->GetNodeMgr(&m_spResultNodeMgr);

	m_nColumnFormat = LVCFMT_LEFT; // default column alignment
	m_pColumnStringIDs = NULL;
	m_pColumnWidths = NULL;

    m_fMessageView = FALSE;
}

CBaseResultHandler::~CBaseResultHandler()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CBaseResultHandler);
}

IMPLEMENT_ADDREF_RELEASE(CBaseResultHandler)

STDMETHODIMP CBaseResultHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
	*ppv = (LPVOID) this;
	else if (riid == IID_ITFSResultHandler)
		*ppv = (ITFSResultHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

STDMETHODIMP CBaseResultHandler::DestroyResultHandler(MMC_COOKIE cookie)
{
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::Notify
		Implementation of ITFSResultHandler::Notify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::Notify
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie,
	LPDATAOBJECT	pDataObject, 
	MMC_NOTIFY_TYPE	event, 
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    pComponent->SetCurrentDataObject(pDataObject);

    COM_PROTECT_TRY
    {
        switch(event)
	    {
		    case MMCN_PROPERTY_CHANGE:
			    hr = OnResultPropertyChange(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_ACTIVATE:
			    hr = OnResultActivate(pComponent, cookie, arg, param);
			    break;

		    case MMCN_CLICK:
			    hr = OnResultItemClkOrDblClk(pComponent, cookie, arg, param, FALSE);
			    break;

		    case MMCN_COLUMN_CLICK:
			    hr = OnResultColumnClick(pComponent, arg, (BOOL)param);
			    break;
                
            case MMCN_COLUMNS_CHANGED:
                hr = OnResultColumnsChanged(pComponent, pDataObject,
                                            (MMC_VISIBLE_COLUMNS *) param);
                break;

		    case MMCN_DBLCLICK:
			    hr = OnResultItemClkOrDblClk(pComponent, cookie, arg, param, TRUE);
			    break;
		    
            case MMCN_SHOW:
                {
                    CWaitCursor wait;
			        hr = OnResultShow(pComponent, cookie, arg, param);
                }
			    break;

		    case MMCN_SELECT:
			    hr = OnResultSelect(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_INITOCX:
			    hr = OnResultInitOcx(pComponent, pDataObject, cookie, arg, param);
			    break;

            case MMCN_MINIMIZED:
			    hr = OnResultMinimize(pComponent, cookie, arg, param);
			    break;

		    case MMCN_DELETE:
			    hr = OnResultDelete(pComponent, pDataObject, cookie, arg, param);
			    break;

		    case MMCN_RENAME:
			    hr = OnResultRename(pComponent, pDataObject, cookie, arg, param);
			    break;

            case MMCN_REFRESH:
                hr = OnResultRefresh(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_CONTEXTHELP:
                hr = OnResultContextHelp(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_QUERY_PASTE:
                hr = OnResultQueryPaste(pComponent, pDataObject, cookie, arg, param);
                break;

            case MMCN_BTN_CLICK:
			    switch (param)
			    {
				    case MMC_VERB_COPY:
					    OnResultVerbCopy(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_PASTE:
					    OnResultVerbPaste(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_DELETE:
					    OnResultVerbDelete(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_PROPERTIES:
					    OnResultVerbProperties(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_RENAME:
					    OnResultVerbRename(pComponent, cookie, arg, param);
					    break;

				    case MMC_VERB_REFRESH:
					    OnResultVerbRefresh(pComponent, cookie, arg, param);
					    break;
				    
				    case MMC_VERB_PRINT:
					    OnResultVerbPrint(pComponent, cookie, arg, param);
					    break;

				    default:
					    break;
			    }
			    break;

            case MMCN_RESTORE_VIEW:
                hr = OnResultRestoreView(pComponent, cookie, arg, param);
                break;

		    // Note - Future expansion of notify types possible
		    default:
			    Panic1("Uknown event in CBaseResultHandler::Notify! 0x%x", event);  // Handle new messages
			    hr = S_FALSE;
			    break;
	    }
    }
    COM_PROTECT_CATCH
    
    pComponent->SetCurrentDataObject(NULL);

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnUpdateView
		Implementation of ITFSResultHandler::UpdateView
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::UpdateView
(
    ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	LPARAM			data, 
	LPARAM			hint
)
{
	return OnResultUpdateView(pComponent, pDataObject, data, hint);
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetString
		Implementation of ITFSResultHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CBaseResultHandler::GetString
(
    ITFSComponent * pComponent, 
	MMC_COOKIE      cookie,
	int	            nCol
)
{
	return NULL;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CompareItems
		Implementation of ITFSResultHandler::CompareItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int) 
CBaseResultHandler::CompareItems
(
    ITFSComponent * pComponent, 
	MMC_COOKIE	    cookieA, 
	MMC_COOKIE	    cookieB,
	int		        nCol
)
{
	return S_FALSE;
}

STDMETHODIMP_(int)
CBaseResultHandler::CompareItems
(
    ITFSComponent *pComponent,
    RDCOMPARE     *prdc
)
{
    // See if IResultCompare is implemented and use it.
    return CompareItems( pComponent,
                         prdc->prdch1->cookie,
                         prdc->prdch2->cookie,
                         prdc->nColumn );
} // CBaseResultHandler::CompareItems()


/*!--------------------------------------------------------------------------
	CBaseResultHandler::FindItem
		called when the Virutal listbox needs to find an item.  
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::FindItem
(
    LPRESULTFINDINFO    pFindInfo, 
    int *               pnFoundIndex
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CacheHint
		called when the virtual listbox has hint information that we can
        pre-load.  The hint is not a guaruntee that the items will be used
        or that items outside this range will be used.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SortItems
		called when the Virutal listbox data needs to be sorted
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	return S_FALSE;
}

// task pad functions

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::EnumTasks
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetTitle
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetTitle
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
    LPOLESTR *      ppszTitle
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetBackground
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetBackground
(
    ITFSComponent *		      pComponent,
    MMC_COOKIE				  cookie,
    LPOLESTR				  pszGroup,
	MMC_TASK_DISPLAY_OBJECT * pTDO
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::TaskPadGetDescriptiveText
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::TaskPadGetDescriptiveText
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
	LPOLESTR *		pszDescriptiveText
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::HasPropertyPages
		Implementation of ITFSResultHandler::HasPropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::HasPropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::CreatePropertyPages
		Implementation of ITFSResultHandler::CreatePropertyPages
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::CreatePropertyPages
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPPROPERTYSHEETCALLBACK	lpProvider, 
	LPDATAOBJECT			pDataObject, 
	LONG_PTR 				handle
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::AddMenuItems
		Implementation of ITFSResultHandler::AddMenuItems
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::Command
		Implementation of ITFSResultHandler::Command
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnCreateControlbars
		Implementation of ITFSResultHandler::OnCreateControlbars
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::OnCreateControlbars
(
    ITFSComponent * pComponent, 
	LPCONTROLBAR pControlBar
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ControlbarNotify
		Implementation of ITFSResultHandler::ControlbarNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::ControlbarNotify
(
    ITFSComponent * pComponent, 
	MMC_NOTIFY_TYPE event, 
	LPARAM			arg, 
	LPARAM			param
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::UserResultNotify
		Implememntation of ITFSNodeHandler::UserResultNotify
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CBaseResultHandler::UserResultNotify
(
	ITFSNode *	pNode, 
	LPARAM		dwParam1, 
	LPARAM		dwParam2
)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CBaseResultHandler::OnCreateDataObject(ITFSComponent *pComponent, MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	// this relies on the ComponentData to do this work
	return S_FALSE;
}


/*---------------------------------------------------------------------------
	CBaseResultHandler Notifications
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultPropertyChange(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
	Trace0("IComponent::Notify(MMCN_PROPERTY_CHANGE) received\n");
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM          data, 
    LPARAM          hint
)
{
    SPITFSNode spSelectedNode;
    pComponent->GetSelectedNode(&spSelectedNode);

	if (hint == RESULT_PANE_DELETE_ALL)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// do it only if selected, if not, reselecting will do a delete/enumeration
		//
		if (spSelectedNode == pNode && !m_fMessageView)
		{
			SPIResultData spResultData;
            pComponent->GetResultData(&spResultData);

            Assert(spResultData != NULL);
			spResultData->DeleteAllRsltItems();
		}
	}
	else 
	if (hint == RESULT_PANE_ADD_ALL)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// do it only if selected, if not, reselecting will do a delete/enumeration
		//
		if (spSelectedNode == pNode)
		{
			SPIResultData spResultData;
            pComponent->GetResultData(&spResultData);

            Assert(spResultData != NULL);

			//
			// update all the nodes in the result pane
			//
            SPITFSNodeEnum spNodeEnum;
            ITFSNode * pCurrentNode;
            ULONG nNumReturned = 0;

            pNode->GetEnum(&spNodeEnum);

			spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
            while (nNumReturned)
			{
				// All containers go into the scope pane and automatically get 
				// put into the result pane for us by the MMC
				//
				if (!pCurrentNode->IsContainer())
				{
					AddResultPaneItem(pComponent, pCurrentNode);
				}
    
                pCurrentNode->Release();
                spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
			}
		}
	}
	else 
	if (hint == RESULT_PANE_REPAINT)
	{
        if (spSelectedNode == NULL)
		    return S_OK; // no selection for our IComponentData

        //
		// data contains the container whose result pane has to be refreshed
		//
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		//if (pNode == NULL)
		//	pContainer = m_pSelectedNode; // passing NULL means apply to the current selection

		//
		// update all the nodes in the result pane
		//
        SPITFSNodeEnum spNodeEnum;
        ITFSNode * pCurrentNode;
        ULONG nNumReturned = 0;

        pNode->GetEnum(&spNodeEnum);

		spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
        while (nNumReturned)
		{
			// All containers go into the scope pane and automatically get 
			// put into the result pane for us by the MMC
			//
			if (!pCurrentNode->IsContainer())
			{
				ChangeResultPaneItem(pComponent, pCurrentNode, RESULT_PANE_CHANGE_ITEM);
			}

            pCurrentNode->Release();
            spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
		}
	}
    else 
	if ( (hint == RESULT_PANE_ADD_ITEM) || (hint == RESULT_PANE_DELETE_ITEM) || (hint & RESULT_PANE_CHANGE_ITEM))
	{
		ITFSNode * pNode = reinterpret_cast<ITFSNode *>(data);
		Assert(pNode != NULL);
		
		//
		// consider only if the parent is selected, otherwise will enumerate later when selected
		//
        SPITFSNode spParentNode;
        pNode->GetParent(&spParentNode);
		if (spSelectedNode == spParentNode)
		{
			if (hint & RESULT_PANE_CHANGE_ITEM)
			{
				ChangeResultPaneItem(pComponent, pNode, hint);
			}
			else if ( hint ==  RESULT_PANE_ADD_ITEM)
			{
				AddResultPaneItem(pComponent, pNode);
			}
			else if ( hint ==  RESULT_PANE_DELETE_ITEM)
			{
				DeleteResultPaneItem(pComponent, pNode);
			}
		}
    }
	else
    if ( hint == RESULT_PANE_SET_VIRTUAL_LB_SIZE )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        if (pNode == spSelectedNode)
        {       
            SetVirtualLbSize(pComponent, data);
        }
    }
	else
    if ( hint == RESULT_PANE_CLEAR_VIRTUAL_LB )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        if (pNode == spSelectedNode)
        {       
            ClearVirtualLb(pComponent, data);
        }
    }
    else
    if ( hint == RESULT_PANE_EXPAND )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPIConsole spConsole;

        pComponent->GetConsole(&spConsole);
        spConsole->Expand(pNode->GetData(TFS_DATA_SCOPEID), (BOOL)data);

    }
    else
    if (hint == RESULT_PANE_SHOW_MESSAGE)
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        BOOL fOldMessageView = (BOOL) data;

        //
		// do it only if selected
		//
		if (spSelectedNode == pNode)
		{
            if (!fOldMessageView)
            {
                SPIConsole spConsole;

                pComponent->GetConsole(&spConsole);
                spConsole->SelectScopeItem(pNode->GetData(TFS_DATA_SCOPEID));
            }
            else
            {
                ShowResultMessage(pComponent, spInternal->m_cookie, NULL, NULL);
            }
        }
    }
    else
    if (hint == RESULT_PANE_CLEAR_MESSAGE)
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);

        BOOL fOldMessageView = (BOOL) data;

		//
		// do it only if selected
		//
		if (spSelectedNode == pNode)
		{
            if (fOldMessageView)
            {
                SPIConsole spConsole;

                pComponent->GetConsole(&spConsole);
                spConsole->SelectScopeItem(pNode->GetData(TFS_DATA_SCOPEID));
            }
        }
    }

    // else if

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ChangeResultPaneItem
		Implementation of ChangeResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::ChangeResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode, 
    LPARAM          changeMask
)
{
    Assert(changeMask & RESULT_PANE_CHANGE_ITEM);
	Assert(pNode != NULL);
	
    HRESULTITEM itemID;
    HRESULT hr = hrOK;
    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

	CORg ( pResultData->FindItemByLParam(static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE)), &itemID) );

    RESULTDATAITEM resultItem;
    ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
	resultItem.itemID = itemID;
	
	if (changeMask & RESULT_PANE_CHANGE_ITEM_DATA)
	{
		resultItem.mask |= RDI_STR;
		resultItem.str = MMC_CALLBACK;
	}
	
	if (changeMask & RESULT_PANE_CHANGE_ITEM_ICON)
	{
		resultItem.mask |= RDI_IMAGE;
		resultItem.nImage = (int)pNode->GetData(TFS_DATA_IMAGEINDEX);
	}
	
	CORg ( pResultData->SetItem(&resultItem) );
	
	CORg ( pResultData->UpdateItem(itemID) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::AddResultPaneItem
		Implementation of AddResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::AddResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode
)
{
	Assert(pNode != NULL);

    RESULTDATAITEM dataitemResult;
    HRESULT hr = hrOK;

    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

    ZeroMemory(&dataitemResult, sizeof(dataitemResult));
        
    dataitemResult.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
    dataitemResult.str = MMC_CALLBACK;
    
    dataitemResult.mask |= SDI_IMAGE;
    dataitemResult.nImage = (int)pNode->GetData(TFS_DATA_IMAGEINDEX);

    dataitemResult.lParam = static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE));

    CORg ( pResultData->InsertItem(&dataitemResult) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::DeleteResultPaneItem
		Implementation of DeleteResultPaneItem
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::DeleteResultPaneItem
(
    ITFSComponent * pComponent, 
    ITFSNode *      pNode
)
{
	Assert(pNode != NULL);

    HRESULT hr = hrOK;
	HRESULTITEM itemID;
	
    SPIResultData pResultData;

    CORg ( pComponent->GetResultData(&pResultData) );

    CORg ( pResultData->FindItemByLParam(static_cast<LPARAM>(pNode->GetData(TFS_DATA_COOKIE)), &itemID) );

	CORg ( pResultData->DeleteItem(itemID, 0 /* all cols */) );

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SetVirtualLbSize
		Sets the virtual listbox count.  Over-ride this if you need to 
        specify and options.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::SetVirtualLbSize
(
    ITFSComponent * pComponent,
    LONG_PTR        data
)
{
    HRESULT hr = hrOK;
    SPIResultData spResultData;

    CORg (pComponent->GetResultData(&spResultData));

    CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOINVALIDATEALL));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ClearVirtualLb
		Sets the virtual listbox count.  Over-ride this if you need to 
        specify and options.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CBaseResultHandler::ClearVirtualLb
(
    ITFSComponent * pComponent,
    LONG_PTR        data
)
{
    HRESULT hr = hrOK;
    SPIResultData spResultData;

    CORg (pComponent->GetResultData(&spResultData));

    CORg (spResultData->SetItemCount((int) data, 0));

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultActivate
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultActivate(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
	Trace0("IComponent::Notify(MMCN_ACTIVATE) received\n");
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultItemClkOrDblClk
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultItemClkOrDblClk(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM param, BOOL bDoubleClick)
{
	if (!bDoubleClick)
		Trace0("IComponent::Notify(MMCN_CLK) received\n");
	else
		Trace0("IComponent::Notify(MMCN_DBLCLK) received\n");

    // return false so that MMC does the default behavior (open the node);
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultShow
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultShow(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        // show the result view message if there is one
        ShowResultMessage(pComponent, cookie, arg, lParam);

		// Show the headers for this nodetype
		LoadColumns(pComponent, cookie, arg, lParam);
		EnumerateResultPane(pComponent, cookie, arg, lParam);

		SortColumns(pComponent);
		
		SPITFSNode spNode;
        m_spResultNodeMgr->FindNode(cookie, &spNode);
	    pComponent->SetSelectedNode(spNode);
    }
    else
    {
		SaveColumns(pComponent, cookie, arg, lParam);
	    pComponent->SetSelectedNode(NULL);
		// Free data associated with the result pane items, because
		// your node is no longer being displayed.
		// Note: The console will remove the items from the result pane
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultColumnClick
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultColumnClick(ITFSComponent *pComponent, LPARAM iColumn, BOOL fAscending)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultColumnsChanged
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultColumnsChanged(ITFSComponent *, LPDATAOBJECT, MMC_VISIBLE_COLUMNS *)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ShowResultMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ShowResultMessage(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT         hr = hrOK;
    SPIMessageView  spMessageView;
    SPIUnknown      spUnknown;
    SPIConsole      spConsole;
    LPOLESTR        pText = NULL;

    // put up our message text 
    if (m_fMessageView)
    {
        if (pComponent)
        {
            CORg ( pComponent->GetConsole(&spConsole) );

            CORg ( spConsole->QueryResultView(&spUnknown) );

            CORg ( spMessageView.HrQuery(spUnknown) );
        }

        // set the title text
		pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (m_strMessageTitle.GetLength() + 1));
        if (pText)
        {
            lstrcpy (pText, m_strMessageTitle);
            CORg(spMessageView->SetTitleText(pText));
            // bugid:148215 vivekk
            CoTaskMemFree(pText);
        }

        // set the body text
		pText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR) * (m_strMessageBody.GetLength() + 1));
        if (pText)
        {
            lstrcpy (pText, m_strMessageBody);
            CORg(spMessageView->SetBodyText(pText));
            // bugid:148215 vivekk           
            CoTaskMemFree(pText);
        }

        // set the icon
        CORg(spMessageView->SetIcon(m_lMessageIcon));

        COM_PROTECT_ERROR_LABEL;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ShowMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ShowMessage(ITFSNode * pNode, LPCTSTR pszTitle, LPCTSTR pszBody, IconIdentifier lIcon)
{
    HRESULT             hr = hrOK;
	SPIComponentData	spCompData;
	SPIConsole			spConsole;
    SPIDataObject       spDataObject;
    IDataObject *       pDataObject;
    BOOL                fOldMessageView;
    
    m_strMessageTitle = pszTitle;
    m_strMessageBody = pszBody;
    m_lMessageIcon = lIcon;

    fOldMessageView = m_fMessageView;
    m_fMessageView = TRUE;

    // tell the views to update themselves here
	m_spResultNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spResultNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) fOldMessageView, RESULT_PANE_SHOW_MESSAGE) ); 

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::ClearMessage
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::ClearMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
	SPIComponentData	spCompData;
	SPIConsole			spConsole;
    SPIDataObject       spDataObject;
    IDataObject *       pDataObject;
    BOOL                fOldMessageView;

    fOldMessageView = m_fMessageView;
    m_fMessageView = FALSE;

    // tell the views to update themselves here
	m_spResultNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spResultNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, (LPARAM) fOldMessageView, RESULT_PANE_CLEAR_MESSAGE) ); 

COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::LoadColumns
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::LoadColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIHeaderCtrl spHeaderCtrl;
	pComponent->GetHeaderCtrl(&spHeaderCtrl);

	CString str;
	int i = 0;

	if (!m_pColumnStringIDs)
		return hrOK;

    if (!m_fMessageView)
    {
	    while (TRUE)
	    {
		    int nColumnWidth = AUTO_WIDTH;

		    if ( 0 == m_pColumnStringIDs[i] )
			    break;
		    
		    str.LoadString(m_pColumnStringIDs[i]);
		    
		    if (m_pColumnWidths)
			    nColumnWidth = m_pColumnWidths[i];

		    spHeaderCtrl->InsertColumn(i, 
								       const_cast<LPTSTR>((LPCWSTR)str), 
								       m_nColumnFormat,
								       nColumnWidth);
		    i++;
	    }
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SaveColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::SaveColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::SortColumns
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::SortColumns(ITFSComponent *pComponent)
{
	return S_FALSE;
}


/*!--------------------------------------------------------------------------
	CBaseResultHandler::EnumerateResultPane
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::EnumerateResultPane(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPITFSNode spContainer;
    m_spResultNodeMgr->FindNode(cookie, &spContainer);

	//
	// Walk the list of children to see if there's anything
	// to put in the result pane
	//
    SPITFSNodeEnum spNodeEnum;
    ITFSNode * pCurrentNode;
    ULONG nNumReturned = 0;

    spContainer->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		//
		// All containers go into the scope pane and automatically get 
		// put into the result pane for us by the MMC
		//
		if (!pCurrentNode->IsContainer() && pCurrentNode->IsVisible())
		{
			AddResultPaneItem(pComponent, pCurrentNode);
		}

        pCurrentNode->Release();
        spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
	}

	return hrOK;
}
 
/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultSelect
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	HRESULT hr = hrOK;
	SPIConsoleVerb spConsoleVerb;
	
	CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

   	// Default is to turn everything off
	spConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    spConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
	spConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnResultInitOcx
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnResultInitOcx(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    // arg - not used
    // param - contains IUnknown to the OCX

	return S_FALSE;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::FIsTaskpadPreferred
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::FIsTaskpadPreferred(ITFSComponent *pComponent)
{
    HRESULT     hr = hrOK;
    SPIConsole  spConsole;

    pComponent->GetConsole(&spConsole);
    hr = spConsole->IsTaskpadViewPreferred();

//Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::DoTaskpadResultSelect
		Handlers with taskpads should override the OnResultSelect and call 
        this to handle setting of the selected node.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::DoTaskpadResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam, BOOL bTaskPadView)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    SPITFSNode spNode, spSelectedNode;
	HRESULT hr = hrOK;

    // if this node is being selected then set the selected node.
    // this node with a taskpad gets the MMCN_SHOW when the node is
    // de-selected, so that will set the selected node to NULL.
    if ( (HIWORD(arg) == TRUE) &&
          bTaskPadView )
    {
        m_spResultNodeMgr->FindNode(cookie, &spNode);
        pComponent->GetSelectedNode(&spSelectedNode);

        // in the normal case MMC will call whichever node is selected to 
        // notify that is being de-selected.  In this case our handler will
        // set the selected node to NULL.  If the selected node is not null then
        // we are just being notified of something like a selection for a context
        // menu...
        if (!spSelectedNode)
            pComponent->SetSelectedNode(spNode);
    }

    // call the base class to handle anything else
    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::OnGetResultViewType
        MMC calls this to get the result view information		
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CBaseResultHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    HRESULT hr = S_FALSE;

    //
	// use the MMC default result view if no message is specified.  
    // Multiple selection, or virtual listbox, override this function.
	// See MMC sample code for example.  The Message view uses an OCX...
	//
    if (m_fMessageView)
    {
        // create the message view thingie
        *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

        LPOLESTR psz = NULL;
        StringFromCLSID(CLSID_MessageView, &psz);

        USES_CONVERSION;

        if (psz != NULL)
        {
            *ppViewType = psz;
            hr = S_OK;
        }
    }

    return hr;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetVirtualString
        called when the virtual listbox needs information on an index
	Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR CBaseResultHandler::GetVirtualString
(
    int     nIndex,
    int     nCol
)
{
    return NULL;
}

/*!--------------------------------------------------------------------------
	CBaseResultHandler::GetVirtualImage
        called when the virtual listbox needs an image index for an item
	Author: EricDav
 ---------------------------------------------------------------------------*/
int CBaseResultHandler::GetVirtualImage
(
    int     nIndex
)
{
    return 0;
}


HRESULT CBaseResultHandler::OnResultMinimize(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_MINIMIZE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultDelete(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRename(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultContextHelp(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_CONTEXTHELP) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultQueryPaste(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_QUERY_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbCopy(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_COPY) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbPaste(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PASTE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbDelete(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_DELETE) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbProperties(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PROPERTIES) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbRename(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_RENAME) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbRefresh(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_REFRESH) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultVerbPrint(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_VERB_PRINT) received\n");
	return S_FALSE;
}

HRESULT CBaseResultHandler::OnResultRestoreView(ITFSComponent *pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
	Trace0("IComponent::Notify(MMCN_RESTORE_VIEW) received\n");
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\busydlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    busydlg.cpp
	base class for the busy dialog

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "busydlg.h"

/////////////////////////////////////////////////////////////////////////////
// CWorkerThread

CWorkerThread::CWorkerThread()
{
	m_bAutoDelete = FALSE;
	m_bAbandoned = FALSE;
	m_hEventHandle = NULL;
	::InitializeCriticalSection(&m_cs);
	m_hWnd = NULL; 
}

CWorkerThread::~CWorkerThread()
{
	::DeleteCriticalSection(&m_cs);
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}

BOOL CWorkerThread::Start(HWND hWnd)
{
	ASSERT(m_hWnd == NULL);
	ASSERT(::IsWindow(hWnd));
	m_hWnd = hWnd;

	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
		return FALSE;
	return CreateThread();
}

void CWorkerThread::Abandon()
{
	Lock();
	OnAbandon();
	m_bAutoDelete = TRUE;
	m_bAbandoned = TRUE;
	Unlock();
}


BOOL CWorkerThread::IsAbandoned()
{
	Lock();
	BOOL b = m_bAbandoned;
	Unlock();
	return b;
}

BOOL CWorkerThread::PostMessageToWnd(UINT Msg, WPARAM wParam, LPARAM lParam)
{
	BOOL b = IsAbandoned();
	if (b)
		return TRUE; // no need to post
	ASSERT(::IsWindow(m_hWnd));
	return ::PostMessage(m_hWnd, Msg, wParam, lParam);
}

void CWorkerThread::WaitForExitAcknowledge() 
{
	BOOL b = IsAbandoned();
	if (b)
		return;
	VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_hEventHandle,INFINITE)); 
}

/////////////////////////////////////////////////////////////////////////////
// CDlgWorkerThread

CDlgWorkerThread::CDlgWorkerThread()
{
	m_dwErr = 0x0;
}


BOOL CDlgWorkerThread::Start(CLongOperationDialog* pDlg)
{
	ASSERT(pDlg != NULL);
	HWND hWnd = pDlg->GetSafeHwnd();
	return CWorkerThread::Start(hWnd);
}

BOOL CDlgWorkerThread::PostMessageToDlg()
{
	return PostMessageToWnd(CLongOperationDialog::s_nNotificationMessage,
							(WPARAM)0, (LPARAM)0);
}


int CDlgWorkerThread::Run()
{
	// do the stuff
	OnDoAction();
	VERIFY(PostMessageToDlg());
	WaitForExitAcknowledge();
	//TRACE(_T("exiting\n"));
	return 0;

}


/////////////////////////////////////////////////////////////////////////////
// CLongOperationDialog dialog

UINT CLongOperationDialog::s_nNotificationMessage = WM_USER + 100;

CLongOperationDialog::CLongOperationDialog(CDlgWorkerThread* pThreadObj,
										   UINT nAviID)
	: CDialog(IDD_BUSY, NULL),
      m_bCancel(TRUE)
{
	ASSERT(pThreadObj != NULL);
	m_bAbandoned = TRUE;
	m_pThreadObj = pThreadObj;
	m_nAviID = nAviID;
}

CLongOperationDialog::~CLongOperationDialog()
{
	if(m_pThreadObj != NULL)
	{
		delete m_pThreadObj;
		m_pThreadObj = NULL;
	}
}

BOOL CLongOperationDialog::LoadTitleString(UINT nID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_strTitle.LoadString(nID);
}

BOOL CLongOperationDialog::LoadDescriptionString(UINT nID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return m_strDescription.LoadString(nID);
}

BEGIN_MESSAGE_MAP(CLongOperationDialog, CDialog)
	ON_MESSAGE( CLongOperationDialog::s_nNotificationMessage, OnNotificationMessage )
END_MESSAGE_MAP()


afx_msg LONG CLongOperationDialog::OnNotificationMessage( WPARAM wParam, LPARAM lParam)
{
	TRACE(_T("CLongOperationDialog::OnNotificationMessage()\n"));

	ASSERT(m_pThreadObj != NULL);
	if (m_pThreadObj != NULL)
	{
		m_pThreadObj->AcknowledgeExiting();
		VERIFY(WAIT_OBJECT_0 == ::WaitForSingleObject(m_pThreadObj->m_hThread,INFINITE));
		m_bAbandoned = FALSE;
		PostMessage(WM_CLOSE,0,0);
	}
	return 0;
}

BOOL CLongOperationDialog::OnInitDialog() 
{
	TRACE(_T("CLongOperationDialog::OnInitDialog()\n"));

	CDialog::OnInitDialog();
	
	if (!m_strTitle.IsEmpty())
		SetWindowText(m_strTitle);

	if (!m_strDescription.IsEmpty())
		GetDlgItem(IDC_STATIC_DESCRIPTION)->SetWindowText(m_strDescription);

    // load auto play AVI file if needed
	if (m_nAviID != -1)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
		CAnimateCtrl* pAnimate = (CAnimateCtrl*)GetDlgItem(IDC_SEARCH_ANIMATE);
		VERIFY(pAnimate->Open(m_nAviID)); 
	}
	
    if (!m_bCancel)
    {
        // hide the system menu
        DWORD dwWindowStyle = GetWindowLong(GetSafeHwnd(), GWL_STYLE);
        dwWindowStyle &= ~WS_SYSMENU;

        SetWindowLong(GetSafeHwnd(), GWL_STYLE, dwWindowStyle);

        // hide the cancel button
        GetDlgItem(IDCANCEL)->ShowWindow(FALSE);
    }

    // spawn worker thread
	GetThreadObj()->Start(this);
	
	return TRUE;
}

void CLongOperationDialog::OnCancel() 
{
	TRACE(_T("CLongOperationDialog::OnCancel()\n"));
	if (m_bAbandoned)
	{
		m_pThreadObj->Abandon();
		m_pThreadObj = NULL;
	}
	CDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\cmptrmgr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	cmptrmgr.cpp
        computer management 

	FILE HISTORY:
        
*/
#include "stdafx.h"
#include <compuuid.h>
#include "cmptrmgr.h"
GUID NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS = structuuidNodetypeServerApps;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\cmptrmgr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	cmptrmgr.h
        computer management 

	FILE HISTORY:
        
*/
extern GUID NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ccdata.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    ccdata.cpp
	base class for the IAbout interface for MMC

    FILE HISTORY:
	
*/

#include <stdafx.h>
#include "ccdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CComponentData::CComponentData()
{
}

CComponentData::~CComponentData()
{
}

IMPLEMENT_ADDREF_RELEASE(CComponentData)

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_IComponentData)
		*ppv = (IComponentData *) this;
	else if (riid == IID_IExtendPropertySheet)
		*ppv = (IExtendPropertySheet *) this;
	else if (riid == IID_IExtendPropertySheet2)
		*ppv = (IExtendPropertySheet2 *) this;
	else if (riid == IID_IExtendContextMenu)
		*ppv = (IExtendContextMenu *) this;
	else if (riid == IID_IPersistStreamInit)
		*ppv = (IPersistStreamInit *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
	((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}



/*!--------------------------------------------------------------------------
	CComponentData::FinalConstruct()
		Initialize values
	Author: 
		Modifide 12/12/97	WeiJiang,	Check return value from 
										CreateTFSComponentData and check the result
 ---------------------------------------------------------------------------*/
HRESULT 
CComponentData::FinalConstruct()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT				hr = S_OK;
	IComponentData *	pComponentData = NULL;

	// Create the underlying TFSComponentData
	hr = CreateTFSComponentData(&pComponentData,
						   (ITFSCompDataCallback *) &m_ITFSCompDataCallback);
	// 
	if(S_OK == hr)
	{
		m_spTFSComponentData.Query(pComponentData);
		m_spComponentData = pComponentData;
		m_spExtendPropertySheet.Query(pComponentData);
		m_spExtendContextMenu.Query(pComponentData);
        m_spSnapinHelp.Query(pComponentData);
	}
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CComponentData::FinalRelease()
		Called when the COM object is going away 
	Author: 
 ---------------------------------------------------------------------------*/
void 
CComponentData::FinalRelease()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_spTFSComponentData.Release();
	
	// Call destroy on our TFSComponentData if needed
	if (m_spComponentData)
		m_spComponentData->Destroy();
	m_spComponentData.Release();
	
	m_spExtendPropertySheet.Release();
	m_spExtendContextMenu.Release();
	m_spSnapinHelp.Release();
}


/*---------------------------------------------------------------------------
	Implementation of EITFSCompDataCallback
 ---------------------------------------------------------------------------*/

STDMETHODIMP CComponentData::EITFSCompDataCallback::QueryInterface(REFIID iid,void **ppv)
{ 
	*ppv = 0; 
	if (iid == IID_IUnknown)
		*ppv = (IUnknown *) this;
	else if (iid == IID_ITFSCompDataCallback)
		*ppv = (ITFSCompDataCallback *) this; 
	else
		return ResultFromScode(E_NOINTERFACE);
	
	((IUnknown *) *ppv)->AddRef(); 
	return hrOK;
}

STDMETHODIMP_(ULONG) CComponentData::EITFSCompDataCallback::AddRef() 
{ 
	return 1; 
}

STDMETHODIMP_(ULONG) CComponentData::EITFSCompDataCallback::Release() 
{ 
	return 1; 
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::GetClassID(LPCLSID pClassID)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetClassID)
	return pThis->GetClassID(pClassID);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::IsDirty()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, IsDirty())
	return pThis->IsDirty();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::Load(LPSTREAM pStm)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, Load)
	return pThis->Load(pStm);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::Save(LPSTREAM pStm, BOOL fClearDirty)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, Save)
	return pThis->Save(pStm, fClearDirty);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetSizeMax)
	return pThis->GetSizeMax(pcbSize);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::InitNew()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, InitNew)
	return pThis->InitNew();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnInitialize(LPIMAGELIST lpScopeImage)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnInitialize);
	return pThis->OnInitialize(lpScopeImage);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnInitializeNodeMgr(ITFSComponentData *pTFSCompData, ITFSNodeMgr *pNodeMgr)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnInitializeNodeMgr);
	return pThis->OnInitializeNodeMgr(pTFSCompData, pNodeMgr);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnCreateComponent(LPCOMPONENT *ppComponent)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnCreateComponent);
	return pThis->OnCreateComponent(ppComponent);
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnDestroy()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnDestroy);
	return pThis->OnDestroy();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnNotifyPropertyChange(LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnNotifyPropertyChange);
	return pThis->OnNotifyPropertyChange(pDataObject, event, arg, lParam);
}

STDMETHODIMP_(const CLSID *) CComponentData::EITFSCompDataCallback::GetCoClassID()
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, GetCoClassID);
	return pThis->GetCoClassID();
}

STDMETHODIMP CComponentData::EITFSCompDataCallback::OnCreateDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, IDataObject **ppDataObject)
{
	EMPrologIsolated(CComponentData, ITFSCompDataCallback, OnCreateDataObject);
	return pThis->OnCreateDataObject(cookie, type, ppDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ccdata.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ccdata.h
	 prototypes for the CComponentData

    FILE HISTORY:
	
*/

#ifndef _CCDATA_H
#define _CCDATA_H


#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _TFSINT_H
#include <tfsint.h>
#endif

/*---------------------------------------------------------------------------
	Forward declarations
 ---------------------------------------------------------------------------*/



/*---------------------------------------------------------------------------
	Class:	CComponentData

	This is a wrapper around the IComponentData facilities provided
	by TFSCore.
 ---------------------------------------------------------------------------*/
class CComponentData :
   public IComponentData,
   public IExtendPropertySheet2,
   public IExtendContextMenu,
   public IPersistStreamInit,
   public ISnapinHelp
{
public:
	CComponentData();
	virtual ~CComponentData();

public:
	DeclareIUnknownMembers(IMPL)

	// Implementation for these interfaces is provided by TFSCore
	DeclareIComponentDataMembers(IMPL)
	DeclareIExtendPropertySheetMembers(IMPL)
	DeclareIExtendContextMenuMembers(IMPL)
	DeclareISnapinHelpMembers(IMPL)

	// These have to be implemented by the derived classes
	DeclareIPersistStreamInitMembers(PURE)

    // manadatory callback members
    DeclareITFSCompDataCallbackMembers(PURE)

    // not required members
    STDMETHOD(OnNotifyPropertyChange)(THIS_ LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam) { return E_NOTIMPL; }

public:
	HRESULT FinalConstruct();
	void FinalRelease();

protected:
	LONG					m_cRef;
	SPITFSComponentData		m_spTFSComponentData;
	SPIComponentData		m_spComponentData;
	SPIExtendPropertySheet	m_spExtendPropertySheet;
	SPIExtendContextMenu	m_spExtendContextMenu;
	SPISnapinHelp	        m_spSnapinHelp;
	
private:
	
	// This class does NOT show up in our QI maps, this is purely
	// intended for passing down to the ITFSComponent
	// This is valid for as long as we have a valid m_spTFSComponentData
	class EITFSCompDataCallback : public ITFSCompDataCallback
	{
	public:
		DeclareIUnknownMembers(IMPL)
		DeclareIPersistStreamInitMembers(IMPL)
		DeclareITFSCompDataCallbackMembers(IMPL)

        // not required members
        STDMETHOD(OnNotifyPropertyChange)(THIS_ LPDATAOBJECT pDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM lParam);
    } m_ITFSCompDataCallback;
	friend class EITFSCompDataCallback;
};


/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline STDMETHODIMP CComponentData::Initialize(LPUNKNOWN punk)
{
	Assert(m_spComponentData);
	return m_spComponentData->Initialize(punk);
}

inline STDMETHODIMP CComponentData::CreateComponent(LPCOMPONENT *ppComp)
{
	Assert(m_spComponentData);
	return m_spComponentData->CreateComponent(ppComp);
}

inline STDMETHODIMP CComponentData::Notify(LPDATAOBJECT pDataObject,
										   MMC_NOTIFY_TYPE event,
										   LPARAM arg, LPARAM param)
{
	Assert(m_spComponentData);
	return m_spComponentData->Notify(pDataObject, event, arg, param);
}

inline STDMETHODIMP CComponentData::Destroy()
{
	Assert(m_spComponentData);
	return m_spComponentData->Destroy();
}

inline STDMETHODIMP CComponentData::QueryDataObject(MMC_COOKIE cookie,
	DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
	Assert(m_spComponentData);
	return m_spComponentData->QueryDataObject(cookie, type, ppDataObject);
}

inline STDMETHODIMP CComponentData::CompareObjects(LPDATAOBJECT pA, LPDATAOBJECT pB)
{
	Assert(m_spComponentData);
	return m_spComponentData->CompareObjects(pA, pB);
}

inline STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM *pScopeDataItem)
{
	Assert(m_spComponentData);
	return m_spComponentData->GetDisplayInfo(pScopeDataItem);
}

inline STDMETHODIMP CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
	LONG_PTR handle, LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->CreatePropertyPages(lpProvider, handle, pDataObject);
}

inline STDMETHODIMP CComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->QueryPagesFor(pDataObject);
}

inline STDMETHODIMP CComponentData::GetWatermarks(LPDATAOBJECT pDataObject,
                                                  HBITMAP *  lphWatermark, 
                                                  HBITMAP *  lphHeader, 
                                                  HPALETTE * lphPalette, 
                                                  BOOL *     bStretch)
{
	Assert(m_spExtendPropertySheet);
	return m_spExtendPropertySheet->GetWatermarks(pDataObject, lphWatermark, lphHeader, lphPalette, bStretch);
}


inline STDMETHODIMP CComponentData::AddMenuItems(LPDATAOBJECT pDataObject,
	LPCONTEXTMENUCALLBACK pCallback, long *pInsertionAllowed)
{
	Assert(m_spExtendContextMenu);
	return m_spExtendContextMenu->AddMenuItems(pDataObject, pCallback, pInsertionAllowed);
}

inline STDMETHODIMP CComponentData::Command(long nCommandId, LPDATAOBJECT pDataObject)
{
	Assert(m_spExtendContextMenu);
	return m_spExtendContextMenu->Command(nCommandId, pDataObject);
}

inline STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
	Assert(m_spSnapinHelp);
	return m_spSnapinHelp->GetHelpTopic(lpCompiledHelpFile);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\column.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipstrm.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "column.h"
#include "xstream.h"

/*---------------------------------------------------------------------------
	ViewInfo implementation
 ---------------------------------------------------------------------------*/

ViewInfo::ViewInfo()
{
	m_cColumns = 0;
	m_prgColumns = NULL;
	m_dwSortColumn = 0;
	m_dwSortDirection = TRUE;
	m_pViewColumnInfo = NULL;
	m_cVisibleColumns = 0;
	m_prgSubitems = NULL;
    m_fConfigurable = TRUE;
}

ViewInfo::~ViewInfo()
{
	delete [] m_prgColumns;
	delete [] m_prgSubitems;
	m_pViewColumnInfo = NULL;
}


/*!--------------------------------------------------------------------------
	ViewInfo::InitViewInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::InitViewInfo(ULONG cColumns,
                            BOOL fConfigurable,
							BOOL fDefaultSortDirectionDescending,
							const ContainerColumnInfo *pViewColInfo)
{
	m_cColumns = cColumns;
	delete [] m_prgColumns;
	m_prgColumns = new ColumnData[cColumns];

	delete [] m_prgSubitems;
	m_prgSubitems = new ULONG[cColumns];

	m_pViewColumnInfo = pViewColInfo;

	m_fDefaultSortDirection = fDefaultSortDirectionDescending;

    m_fConfigurable = fConfigurable;

	InitNew();
}

/*!--------------------------------------------------------------------------
	ViewInfo::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::InitNew()
{
	// setup the defaults for this column
	for (int i=0; i<(int) m_cColumns; i++)
	{
		if (m_pViewColumnInfo[i].m_fVisibleByDefault)
			m_prgColumns[i].m_nPosition = i+1;
		else
			m_prgColumns[i].m_nPosition = -(i+1);

		m_prgColumns[i].m_dwWidth = AUTO_WIDTH;
	}

 	m_dwSortDirection = m_fDefaultSortDirection;

	UpdateSubitemMap();
}

ULONG ViewInfo::MapSubitemToColumn(ULONG  nSubitemId)
{
	for (ULONG i=0; i<m_cVisibleColumns; i++)
	{
		if (m_prgSubitems[i] == nSubitemId)
			return i;
	}
	return 0xFFFFFFFF;
}

/*!--------------------------------------------------------------------------
	ViewInfo::UpdateSubitemMap
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ViewInfo::UpdateSubitemMap()
{
 	Assert(m_prgSubitems);
	
	ULONG	i, cVisible, j;

	// Iterate over the entire set of columns
	for (i=0, cVisible=0; i<m_cColumns; i++)
	{
		// look for this column in ColumnData
		for (j=0; j<m_cColumns; j++)
		{
			if ((ULONG) m_prgColumns[j].m_nPosition == (i+1))
				break;
		}

		// Did we find anything?  If not go on
		if (j >= m_cColumns)
			continue;

		m_prgSubitems[cVisible++] = j;
	}
	m_cVisibleColumns = cVisible;
}


HRESULT ViewInfo::Xfer(XferStream *pxstm, ULONG ulSortColumnId,
					  ULONG ulSortAscendingId, ULONG ulColumnsId)
{
	Assert(pxstm);
	
	HRESULT	hr = hrOK;
	ULONG cColumns;

	// Xfer the column data
	Assert(m_prgColumns);
	
	cColumns = m_cColumns;
	CORg( pxstm->XferColumnData(ulColumnsId, &m_cColumns,
								m_prgColumns) );
	
	// The number of columns shouldn't change!
	Assert(m_cColumns == cColumns);
	// Use the old number of columns (this is for as we change our code)
	m_cColumns = cColumns;

	// Xfer the sort column
	CORg( pxstm->XferDWORD( ulSortColumnId, &m_dwSortColumn) );

	// Xfer the ascending data
	CORg( pxstm->XferDWORD( ulSortAscendingId, &m_dwSortDirection) );

	UpdateSubitemMap();

Error:
	return hr;
}




/*---------------------------------------------------------------------------
	ConfigStream implementation
 ---------------------------------------------------------------------------*/


/*!--------------------------------------------------------------------------
	ConfigStream::ConfigStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
ConfigStream::ConfigStream()
	: m_nVersion(0x00020000),
	m_nVersionAdmin(0x0002000),
	m_fDirty(FALSE),
	m_rgViewInfo(NULL),
	m_cColumnSetsMax(0),
	m_prgrc(NULL)
{
}

ConfigStream::~ConfigStream()
{
	delete [] m_rgViewInfo;
	delete [] m_prgrc;
	m_cColumnSetsMax = 0;
}

void ConfigStream::Init(ULONG cColumnSetsMax)
{
	delete [] m_rgViewInfo;
	m_rgViewInfo = NULL;
	m_rgViewInfo = new ViewInfo[cColumnSetsMax];

	delete [] m_prgrc;
	m_prgrc = NULL;
	m_prgrc = new RECT[cColumnSetsMax];
	
	m_cColumnSetsMax = cColumnSetsMax;
}

/*!--------------------------------------------------------------------------
	ConfigStream::InitViewInfo
		Initializes the static data.  This is not the same as InitNew.
		This will initialize the data for a single view.
	Author: KennT
 ---------------------------------------------------------------------------*/
void ConfigStream::InitViewInfo(ULONG ulId,
                                BOOL fConfigurableColumns,
								ULONG cColumns,
								BOOL fSortDirection,
								const ContainerColumnInfo *pViewColumnInfo)
{
	Assert(ulId < m_cColumnSetsMax);
    m_fConfigurableColumns = fConfigurableColumns;
	m_rgViewInfo[ulId].InitViewInfo(cColumns, fConfigurableColumns,
                                    fSortDirection,
                                    pViewColumnInfo);
}

/*!--------------------------------------------------------------------------
	ConfigStream::InitNew
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::InitNew()
{
	int		iVisible=0;
	// Setup the appropriate defaults
	for (UINT i=0; i<m_cColumnSetsMax; i++)
	{
		m_rgViewInfo[i].InitNew();
		m_prgrc[i].top = m_prgrc[i].bottom = 0;
		m_prgrc[i].left = m_prgrc[i].right = 0;
	}

	return hrOK;
}

/*!--------------------------------------------------------------------------
	ConfigStream::SaveTo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::SaveTo(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::SaveAs
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::SaveAs(UINT nVersion, IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_WRITE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::LoadFrom
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::LoadFrom(IStream *pstm)
{
	return XferVersion0(pstm, XferStream::MODE_READ, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::GetSize
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::GetSize(ULONG *pcbSize)
{
	return XferVersion0(NULL, XferStream::MODE_SIZE, NULL);
}

/*!--------------------------------------------------------------------------
	ConfigStream::GetVersionInfo
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::GetVersionInfo(DWORD *pdwVersion, DWORD *pdwAdminVersion)
{
	if (pdwVersion)
		*pdwVersion = m_nVersion;
	if (pdwAdminVersion)
		*pdwAdminVersion = m_nVersionAdmin;
	return hrOK;
}

/*!--------------------------------------------------------------------------
	ConfigStream::XferVersion0
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ConfigStream::XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize)
{
	Panic0("Should be implemented by derived classes!");
	return E_NOTIMPL;
}


void ConfigStream::GetStatsWindowRect(ULONG ulId, RECT *prc)
{
	*prc = m_prgrc[ulId];
}

void ConfigStream::SetStatsWindowRect(ULONG ulId, RECT rc)
{
	m_prgrc[ulId] = rc;
}



/*!--------------------------------------------------------------------------
	ViewInfo::GetColumnData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT ViewInfo::GetColumnData(ULONG cColData,
								ColumnData *prgColData)
{
	Assert(cColData <= m_cColumns);
	Assert(prgColData);
	Assert(!IsBadWritePtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(prgColData, m_prgColumns, sizeof(ColumnData)*cColData);

	return hr;
}

HRESULT ViewInfo::GetColumnData(ULONG nColumnId, ULONG cColData,
								ColumnData *prgColData)
{
	Assert(cColData <= m_cColumns);
	Assert(prgColData);
	Assert(!IsBadWritePtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(prgColData, m_prgColumns + nColumnId, sizeof(ColumnData)*cColData);

	return hr;
}


HRESULT ViewInfo::SetColumnData(ULONG cColData, ColumnData*prgColData)
{
	// For now we don't do resizing
	Assert(cColData == m_cColumns);
	Assert(prgColData);
	Assert(!IsBadReadPtr(prgColData, sizeof(ColumnData)*cColData));
	
	HRESULT	hr = hrOK;

	memcpy(m_prgColumns, prgColData, sizeof(ColumnData)*cColData);
	UpdateSubitemMap();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\coldlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	column.h
		Column chooser.
		
    FILE HISTORY:
        
*/

#ifndef _COLDLG_H
#define _COLDLG_H

#ifndef _DIALOG_H
#include "dialog.h"
#endif

#ifndef _LISTCTRL_H
#include "listctrl.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _COLUMN_H
#include "column.h"	// need ContainerColumnInfo
#endif

//----------------------------------------------------------------------------
// Class:       ColumnDlg
//
// This dialog displays all the rows for available for a list-control,
// allowing the user to select which ones should be displayed.
//----------------------------------------------------------------------------

class ColumnDlg : public CBaseDialog
{
public:
	ColumnDlg(CWnd *pParent);

	void	Init(const ContainerColumnInfo *prgColInfo, UINT cColumns,
				 ColumnData *prgColumnData);
	~ColumnDlg( );

	//{{AFX_DATA(ColumnDlg)
	CListBox                 m_lboxDisplayed;
	CListBox                 m_lboxHidden;
	//}}AFX_DATA


	//{{AFX_VIRTUAL(ColumnDlg)
protected:
	virtual VOID                DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

protected:
    virtual DWORD * GetHelpMap() { return m_dwHelpMap; }
	static DWORD				m_dwHelpMap[];

	const ContainerColumnInfo *	m_pColumnInfo;
	UINT						m_cColumnInfo;
	ColumnData *				m_pColumnData;
	

	VOID MoveItem( INT dir );
	BOOL AddColumnsToList();
	
	static INT CALLBACK
			ColumnCmp(
					  LPARAM                  lParam1,
					  LPARAM                  lParam2,
					  LPARAM                  lParamSort );
	
	//{{AFX_MSG(ColumnDlg)
	virtual BOOL                OnInitDialog( );
	virtual VOID                OnOK();
	afx_msg VOID				OnUseDefaults();
	afx_msg VOID                OnMoveUp();
	afx_msg VOID                OnMoveDown();
	afx_msg VOID                OnAddColumn();
	afx_msg VOID                OnRemoveColumn();
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};




#endif _COLDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\coldlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	column.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "column.h"
#include "coldlg.h"

//----------------------------------------------------------------------------
// Class:       ColumnDlg
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Function:    ColumnDlg::ColumnDlg
//----------------------------------------------------------------------------

ColumnDlg::ColumnDlg(
    CWnd*           pParent
    ) : CBaseDialog(IDD_COMMON_SELECT_COLUMNS, pParent)
{
}


//----------------------------------------------------------------------------
// Function:    ColumnDlg::~ColumnDlg
//----------------------------------------------------------------------------

ColumnDlg::~ColumnDlg() { }



void ColumnDlg::Init(const ContainerColumnInfo *prgColInfo,
					 UINT cColumns,
					 ColumnData *prgColumnData)
{
	Assert(prgColInfo);
	Assert(prgColumnData);
	
	m_pColumnInfo = prgColInfo;
	m_cColumnInfo = cColumns;
	m_pColumnData = prgColumnData;
}

//----------------------------------------------------------------------------
// Function:    ColumnDlg::DoDataExchange
//----------------------------------------------------------------------------

void ColumnDlg::DoDataExchange(CDataExchange* pDX) {

    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(ColumnDlg)
    DDX_Control(pDX, IDC_DISPLAYED_COLUMNS, m_lboxDisplayed);
    DDX_Control(pDX, IDC_HIDDEN_COLUMNS,    m_lboxHidden);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ColumnDlg, CBaseDialog)
    //{{AFX_MSG_MAP(ColumnDlg)
    ON_WM_HSCROLL()
	ON_BN_CLICKED(IDC_RESET_COLUMNS,   OnUseDefaults)
    ON_BN_CLICKED(IDC_MOVEUP_COLUMN,   OnMoveUp)
    ON_BN_CLICKED(IDC_MOVEDOWN_COLUMN, OnMoveDown)
	ON_BN_CLICKED(IDC_ADD_COLUMNS,     OnAddColumn)
	ON_BN_CLICKED(IDC_REMOVE_COLUMNS,  OnRemoveColumn)
	ON_LBN_DBLCLK(IDC_HIDDEN_COLUMNS,    OnAddColumn)
	ON_LBN_DBLCLK(IDC_DISPLAYED_COLUMNS, OnRemoveColumn)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


DWORD ColumnDlg::m_dwHelpMap[] =
{
//	IDC_LCX_COLUMNS, HIDC_LCX_COLUMNS,
//	IDC_LCX_MOVEUP, HIDC_LCX_MOVEUP,
//	IDC_LCX_MOVEDOWN, HIDC_LCX_MOVEDOWN,
//	IDC_LCX_WIDTH, HIDC_LCX_WIDTH,
//	IDC_LCX_LEFT, HIDC_LCX_LEFT,
//	IDC_LCX_SCALE, HIDC_LCX_SCALE,
//	IDC_LCX_RIGHT, HIDC_LCX_RIGHT,
	0,0
};


//----------------------------------------------------------------------------
// Function:    ColumnDlg::OnInitDialog
//
// Handles the 'WM_INITDIALOG' message.
//----------------------------------------------------------------------------

BOOL ColumnDlg::OnInitDialog() {

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
	ULONG				i, j;
	int					iPos, iItem;
    RECT                rc;
	POSITION            pos;
    CString             sItem;
	ULONG				uCol;

    CBaseDialog::OnInitDialog();

	// Fill the list with the titles of the columns
	//
	if (!AddColumnsToList())
		return FALSE;
	
	//
	// Select the first item
	//
	return TRUE;
}

void ColumnDlg::OnUseDefaults()
{
	int		count, i;
	HDWP	hdwp;
	
	// Reset the column information
	for (i=0; i<(int)m_cColumnInfo; i++)
	{
		if (m_pColumnInfo[i].m_fVisibleByDefault)
			m_pColumnData[i].m_nPosition = i+1;
		else
			m_pColumnData[i].m_nPosition = -(i+1);
	}

	// Get rid of all of the current columns
	hdwp = BeginDeferWindowPos(2);


	m_lboxDisplayed.ResetContent();
	m_lboxHidden.ResetContent();

	// add the columns back to the list
	AddColumnsToList();

	if (hdwp)
		EndDeferWindowPos(hdwp);
}



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnOK
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnOK(
    ) {
    BOOL            bEmpty;
    INT             i;
    INT             count;
	DWORD_PTR		nPosition;

    count = m_lboxDisplayed.GetCount();
    
    //
    // Check to see whether any columns are enabled
    //
	bEmpty = (count == 0);

	//
	// If no columns are enabled and the caller needs at least one column,
	// complain to the user and don't close the dialog.
	//	
	if (bEmpty)
	{
		AfxMessageBox(IDS_ERR_NOCOLUMNS);
		return;
	}

	// Ok, we need to write the info back out
	for (i = 0; i < count; i++)
	{
		nPosition = m_lboxDisplayed.GetItemData(i);
		m_pColumnData[nPosition].m_nPosition = (i+1);
	}

	INT HiddenCount = m_lboxHidden.GetCount();
	for (i = 0; i < HiddenCount; i++)
	{
		nPosition = m_lboxHidden.GetItemData(i);
		m_pColumnData[nPosition].m_nPosition = -(1+i+count);
	}
	
    CBaseDialog::OnOK();
}



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnMoveUp
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnMoveUp( ) { MoveItem(-1); }



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnMoveDown
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnMoveDown( ) { MoveItem(1); }



//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnRemoveColumn
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnRemoveColumn( ) 
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxDisplayed.GetCurSel();
	if (LB_ERR == i)
		return;

    iItem = m_lboxDisplayed.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxDisplayed.DeleteString(i);

    //
    // Insert the item at its new position
    //
    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

	i = m_lboxHidden.GetCount();
    m_lboxHidden.InsertString(i, sItem);
    m_lboxHidden.SetItemData(i, (DWORD)iItem);
    m_lboxHidden.SetCurSel(i);
}

//----------------------------------------------------------------------------
// Function::   ColumnDlg::OnAddColumn
//----------------------------------------------------------------------------

VOID
ColumnDlg::OnAddColumn( ) 
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxHidden.GetCurSel();
	if (LB_ERR == i)
		return;

    iItem = m_lboxHidden.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxHidden.DeleteString(i);

    //
    // Insert the item at its new position
    //
    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

	i = m_lboxDisplayed.GetCount();
    m_lboxDisplayed.InsertString(i, sItem);
    m_lboxDisplayed.SetItemData(i, (DWORD)iItem);
    m_lboxDisplayed.SetCurSel(i);
}

//----------------------------------------------------------------------------
// Function::   ColumnDlg::MoveItem
//----------------------------------------------------------------------------

VOID
ColumnDlg::MoveItem(
    INT     dir
    ) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    INT		i;
    BOOL bEnabled;
    CString sItem;
    DWORD_PTR iItem;

    //
    // Get the selected item
    //
    i = m_lboxDisplayed.GetCurSel();

    if (i == -1 || (i + dir) < 0 || (i + dir) >= m_lboxDisplayed.GetCount())
        return;

    iItem = m_lboxDisplayed.GetItemData(i);

    //
    // Remove the item from its current position
    //
    m_lboxDisplayed.DeleteString(i);

    //
    // Insert the item at its new position
    //
    i += dir;

    sItem.LoadString(m_pColumnInfo[iItem].m_ulStringId);

    m_lboxDisplayed.InsertString(i, sItem);
    m_lboxDisplayed.SetItemData(i, (DWORD)iItem);
    m_lboxDisplayed.SetCurSel(i);
}



BOOL ColumnDlg::AddColumnsToList()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ULONG		i, j;
	int			iPos, iItem;
	CString		sItem;
	
	Assert(m_pColumnData);

	m_lboxDisplayed.ResetContent();
	m_lboxHidden.ResetContent();

	int cDisplayItems = 0;
	int HiddenItems = 0;
	for (i=0; i<m_cColumnInfo; i++)
	{
		// look for the column at position (i+1)
		for (j=0; j<m_cColumnInfo; j++)
		{
			iPos = m_pColumnData[j].m_nPosition;
			iPos = abs(iPos);
			if ((ULONG)iPos == (i+1))
				break;
		}
		Assert( j < m_cColumnInfo );

		sItem.LoadString(m_pColumnInfo[j].m_ulStringId);

		if (m_pColumnData[j].m_nPosition > 0)
		{
			iItem = m_lboxDisplayed.InsertString(cDisplayItems++, sItem);
		    if (iItem == -1) { OnCancel(); return FALSE; }
	        m_lboxDisplayed.SetItemData(iItem, j);
		}
		else
		{
			iItem = m_lboxHidden.InsertString(HiddenItems++, sItem);
		    if (iItem == -1) { OnCancel(); return FALSE; }
	        m_lboxHidden.SetItemData(iItem, j);
		}
	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\commres.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       commres.h
//
//--------------------------------------------------------------------------

#ifndef _COMMON_COMMRES_H
#define _COMMON_COMMRES_H

// Dialog ids start at 5000-5099
#define IDD_STATS                       5000
#define IDD_COMMON_SELECT_COLUMNS	5001
#define IDD_STATS_NARROW		5002
#define IDD_BUSY                        5003

// Controls are from 5100-5499
#define IDC_STATSDLG_LIST               5100
#define IDC_STATSDLG_BTN_REFRESH        5101
#define IDC_STATSDLG_BTN_SELECT_COLUMNS 5102
#define IDC_STATSDLG_BTN_CLEAR		5103

#define IDC_DISPLAYED_COLUMNS			5111
#define IDC_MOVEUP_COLUMN				5112
#define IDC_MOVEDOWN_COLUMN				5113
#define IDC_RESET_COLUMNS				5114
#define IDC_HIDDEN_COLUMNS				5120
#define IDC_ADD_COLUMNS					5121
#define IDC_REMOVE_COLUMNS				5122

// These are still used elsewhere in the system
#define IDC_LCX_LIST_COLUMNS            5111
#define IDC_LCX_BTN_MOVEUP              5112
#define IDC_LCX_BTN_MOVEDOWN            5113
#define IDC_LCX_BTN_DEFAULTS            5114

#define IDC_STATIC_DESCRIPTION          5115
#define IDC_SEARCH_ANIMATE              5116

// Miscellaneous at from 5500-5599
#define IDI_COMMON_CHECK				5500
#define IDI_COMMON_UNCHECK				5501
#define IDR_STATSDLG					5502

// Strings are from 5600-5999
#define IDS_ERR_NOCOLUMNS				5600
#define IDS_STATSDLG_MENU_REFRESH		5601
#define IDS_STATSDLG_MENU_SELECT		5602
#define IDS_STATSDLG_DESCRIPTION		5603
#define IDS_STATSDLG_DETAILS			5604
#define IDS_ERR_TOD_LOADLOGHOURDLL  	5605
#define IDS_ERR_TOD_FINDLOGHOURSAPI 	5606

#define IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK 5700
#define IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC   5701
#define IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE   5702
#define IDS_COMMON_ERR_IPADDRESS_127            5703
#define IDS_COMMON_ERR_IPADDRESS_NOT_EQ_MASK 5704

#endif	// _COMMON_COMMRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\compinfo.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	compinfo.cpp
		Computer info class plus helper functions

	FILE HISTORY:


*/

#define IP_ADDDRESS_LENGTH_MAX   16

typedef enum COMPUTER_INFO_TYPE
{
	COMPUTER_INFO_TYPE_IP,
	COMPUTER_INFO_TYPE_DNS,
	COMPUTER_INFO_TYPE_NB
};

class CIpInfo
{
public:
	DWORD	dwIp;
	CString	strFqdn;
};

typedef CArray<CIpInfo, CIpInfo &> CIpInfoArrayBase;

class CIpInfoArray : public CIpInfoArrayBase
{
public:
	BOOL	FIsInList(DWORD dwIp);
};

class CComputerInfo
{
public:
	CComputerInfo(LPCTSTR pszNameOrIp);
	~CComputerInfo();

	HRESULT	GetIp(DWORD * pdwIp, int nIndex = 0);
	HRESULT	GetIpStr(CString & strIp, int nIndex = 0);
	HRESULT	GetHostName(CString & strHostName);
	HRESULT	GetFqdn(CString & strFqdn, int nIndex = 0);
	int		GetCount();
	HRESULT	GetDomain(CString & strDomain);
	COMPUTER_INFO_TYPE	GetInputType();
	HRESULT IsLocalMachine(BOOL * pfIsLocal);
	HRESULT	InitializeData();

	void	Reset();

// internal functions
protected:
	HRESULT	GetHostInfo(DWORD dhipa);
	HRESULT GetHostAddressFQDN(LPCTSTR pszHostName, CString * pstrFQDN, DWORD * pdhipa);
	DWORD	addrFromHostent(const HOSTENT * pHostent, INT index = 0);
	HRESULT	GetHostAddress(LPCTSTR pszHostName, DWORD * pdhipa);
	HRESULT GetLocalHostAddress(DWORD * pdhipa);
	HRESULT GetLocalHostName(CString * pstrName);

private:
	CString				m_strNameOrIp;
	CString				m_strHostname;

	int					m_nIndex;
	
	CIpInfoArray		m_arrayIps;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\column.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	column.h
		Customizable column info.

		Use this to get/set configuration data.  This class will take
		care of versioning of config formats as well as serializing
		of the data.
		
    FILE HISTORY:
        
*/

#ifndef _COLUMN_H
#define _COLUMN_H

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

// forward declarations

/*---------------------------------------------------------------------------
	Struct:	ContainerColumnInfo
	This structure will hold column information that doesn't change.
 ---------------------------------------------------------------------------*/
struct ContainerColumnInfo
{
	ULONG	m_ulStringId;		// String id of the column header
	int		m_nSortCriteria;	// = 0 for string, = 1 for DWORD
	BOOL	m_fVisibleByDefault;// TRUE if default is column is visible
	ULONG	m_ulDefaultColumnWidth;	// in number of characters
};

// constants used by m_nSortCriteria
#define CON_SORT_BY_STRING	0
#define CON_SORT_BY_DWORD		1

// constants used for m_ulDefaultColumnWidth
// This should be used to ensure consistency (as well as making it
// easier to change a whole bunch of column widths at the same time).
#define COL_IF_NAME			30
#define COL_IF_DEVICE		30
#define COL_STATUS			12
#define COL_LARGE_NUM		15
#define COL_SMALL_NUM		8
#define COL_DATE			12
#define COL_IPADDR			15
#define COL_STRING			15
#define COL_MACHINE_NAME	20
#define COL_DURATION		10
#define COL_IPXNET			32
#define COL_NETBIOS_NAME	18
#define COL_BIG_STRING		32



//
//	Class:	ViewColumnInfo
//
//	This class is intended as a simple struct rather than a whole class.
//	Information needed on a per-view basis.
//
//
class ViewInfo
{
public:
	ViewInfo();
	~ViewInfo();

	//
	//	Initializes the data for a single view or column set.
	//
	void InitViewInfo(ULONG cColumns,
                      BOOL fConfigurable,
					  BOOL fDefaultSortDirectionDescending,
					  const ContainerColumnInfo *pViewColInfo);

	//
	//	Call this to initialize the column data (reset to defaults).
	//
	void InitNew();

	//
	//	Updates the mapping from the column id to the subitem ids.
	//
	void UpdateSubitemMap();

	//
	//	Xfers the data to the stream using the given ids.
	//
	HRESULT	Xfer(XferStream *pxstm,
				 ULONG ulSortColumId,
				 ULONG ulSortAscendingId,
				 ULONG ulColumnsId);

	ULONG	MapColumnToSubitem(ULONG nColumnId);
	ULONG	MapSubitemToColumn(ULONG nSubitemId);

	HRESULT	GetColumnData(ULONG cArrayMax, ColumnData *pColData);
	HRESULT SetColumnData(ULONG cArray, ColumnData *pColData);

	HRESULT	GetColumnData(ULONG nColumnId, ULONG cArrayMax, ColumnData *pColData);

	int		GetSortCriteria(ULONG nColumnId);
	ULONG	GetStringId(ULONG nColumnId);
	DWORD	GetColumnWidth(ULONG nColumnId);

	ULONG	GetVisibleColumns();
	BOOL	IsSubitemVisible(ULONG nSubitemId);

	ULONG	GetColumnCount();

	ULONG	GetSortColumn();
	void	SetSortColumn(ULONG nSortColumn);

	ULONG	GetSortDirection();
	void	SetSortDirection(ULONG ulSortDirection);

	const ContainerColumnInfo *	GetColumnInfo()
			{	return m_pViewColumnInfo;	}

protected:

	// The individual column data (indexed by subitem id)
	ColumnData *m_prgColumns;

	// Number of columns
	ULONG	m_cColumns;
	
	// The subitem id that we are sorting by
	DWORD	m_dwSortColumn;
	
	// TRUE if we are sorting by ascending order
	DWORD	m_dwSortDirection;

	// Pointer to default static data for this view
	const ContainerColumnInfo *	m_pViewColumnInfo;

    // TRUE if the column order can be changed
    BOOL    m_fConfigurable;

 	//
	//	The data after this point is for use during runtime display of data.
	//	Thus it is organized a little differently then the persisted data.
	//
	
 	// Number of visible columns.
	ULONG	m_cVisibleColumns;

	// This is the mapping from column id to subitem id.  The column ids
	// is the order in which the columns actually appear to MMC.
	//	For example, if there were 3 columns (subitemA, subitemB, subitemC)
	//	and we wished to show the columns in the order [subitemC, subitemB]
	//	then m_cVisibleColumns = 2
	//	and m_rgSubItems[] = { subitemC, subitemB, XXXX }
	// Do NOT make changes to this directly!  This must be kept in sync
	// with the ordered data.  This will get updated automatically when
	// SetColumnData is called.
	ULONG *	m_prgSubitems;


	BOOL	m_fDefaultSortDirection;
};


inline ULONG ViewInfo::MapColumnToSubitem(ULONG nColumnId)
{
	Assert(nColumnId < (int) m_cColumns);
    
    // In the new MMC model, the only time we have configurable
    // columns are the statistics dialogs.
    if (m_fConfigurable)
        return m_prgSubitems[nColumnId];
    else
        return nColumnId;
}

inline int ViewInfo::GetSortCriteria(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	return m_pViewColumnInfo[MapColumnToSubitem(nColumnId)].m_nSortCriteria;
}

inline ULONG ViewInfo::GetStringId(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	return m_pViewColumnInfo[MapColumnToSubitem(nColumnId)].m_ulStringId;
}

inline ULONG ViewInfo::GetColumnWidth(ULONG nColumnId)
{
	Assert(nColumnId < m_cColumns);
	Assert(m_prgColumns);
	return m_prgColumns[MapColumnToSubitem(nColumnId)].m_dwWidth;
}

inline ULONG ViewInfo::GetVisibleColumns()
{
	return m_cVisibleColumns;
}

inline ULONG ViewInfo::GetColumnCount()
{
	return m_cColumns;
}

inline BOOL ViewInfo::IsSubitemVisible(ULONG nSubitem)
{
	return (m_prgColumns[nSubitem].m_nPosition > 0);
}

inline void ViewInfo::SetSortColumn(ULONG nColumnId)
{
	m_dwSortColumn = nColumnId;
}

inline ULONG ViewInfo::GetSortColumn()
{
	return m_dwSortColumn;
}

inline void ViewInfo::SetSortDirection(ULONG ulDir)
{
	m_dwSortDirection = ulDir;
}

inline ULONG ViewInfo::GetSortDirection()
{
	return m_dwSortDirection;
}


/*---------------------------------------------------------------------------
	Class:	ConfigStream

	This class is used to place all configuration information into a
	single place.
 ---------------------------------------------------------------------------*/

class ConfigStream
{
public:
	ConfigStream();
	virtual ~ConfigStream();

	//
	//	Allocates the memory for these number of column sets
	//
	void Init(ULONG cColumnSetsMax);

	//
	//	Initializes the data for a single column set.
	//
	void InitViewInfo(ULONG ulId,
                      BOOL  fConfigurableColumns,
                      ULONG cColumns,
					  BOOL fSortDirection,
					  const ContainerColumnInfo *pColumnInfo);
	
	HRESULT	InitNew();				// set defaults
	HRESULT	SaveTo(IStream *pstm);
	HRESULT SaveAs(UINT nVersion, IStream *pstm);
	
	HRESULT LoadFrom(IStream *pstm);

	HRESULT GetSize(ULONG *pcbSize);

	BOOL	GetDirty() { return m_fDirty; } 
	void	SetDirty(BOOL fDirty) { m_fDirty = fDirty; };


	// --------------------------------------------------------
	// Accessors
	// --------------------------------------------------------
	
	HRESULT	GetVersionInfo(DWORD *pnVersion, DWORD *pnAdminVersion);

	ULONG	MapColumnToSubitem(ULONG ulId, ULONG ulColumnId);
	ULONG	MapSubitemToColumn(ULONG ulId, ULONG nSubitemId);

	HRESULT GetColumnData(ULONG ulId, ULONG cArrayMax, ColumnData *pColData);
	HRESULT GetColumnData(ULONG ulId, ULONG nColumnId, ULONG cArrayMax, ColumnData *pColData);
	HRESULT SetColumnData(ULONG ulId, ULONG cArray, ColumnData *pColData);

	ULONG	GetColumnCount(ULONG ulId);

	int		GetSortCriteria(ULONG ulId, ULONG uColumnId);
	ULONG	GetStringId(ULONG ulId, ULONG nColumnId);
	DWORD	GetColumnWidth(ULONG ulId, ULONG nColumnId);

	ULONG	GetVisibleColumns(ULONG ulId);
	BOOL	IsSubitemVisible(ULONG ulId, UINT nSubitemId);

	const ContainerColumnInfo *	GetColumnInfo(ULONG ulId);

	void	GetStatsWindowRect(ULONG ulId, RECT *prc);
	void	SetStatsWindowRect(ULONG ulId, RECT rc);

	void	SetSortColumn(ULONG ulId, ULONG uColumnId);
	ULONG	GetSortColumn(ULONG ulId);
	
	void	SetSortDirection(ULONG ulId, ULONG uSortDir);
	ULONG	GetSortDirection(ULONG ulId);
	
protected:
	DWORD	m_nVersionAdmin;
	DWORD	m_nVersion;
	BOOL	m_fDirty;
    BOOL    m_fConfigurableColumns; // = TRUE if we can change the columns

	ULONG		m_cColumnSetsMax;
	ViewInfo *	m_rgViewInfo;	// = ViewInfo[m_cColumnSetsMax]
	RECT *		m_prgrc;		// = Rect[m_cColumnSetsMax]

	// Overide this to provide basic defaults
	virtual HRESULT XferVersion0(IStream *pstm, XferStream::Mode mode, ULONG *pcbSize);
};


inline ULONG ConfigStream::MapColumnToSubitem(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);

    return m_rgViewInfo[ulId].MapColumnToSubitem(nColumnId);
}

inline ULONG ConfigStream::MapSubitemToColumn(ULONG ulId, ULONG nSubitemId)
{
	Assert(ulId < m_cColumnSetsMax);

    return m_rgViewInfo[ulId].MapSubitemToColumn(nSubitemId);
}

inline int ConfigStream::GetSortCriteria(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortCriteria(nColumnId);
}

inline ULONG ConfigStream::GetVisibleColumns(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetVisibleColumns();
}

inline BOOL ConfigStream::IsSubitemVisible(ULONG ulId, UINT nSubitemId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].IsSubitemVisible(nSubitemId);
}

inline ULONG ConfigStream::GetColumnCount(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnCount();
}

inline HRESULT ConfigStream::GetColumnData(ULONG ulId, ULONG cArrayMax, ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnData(cArrayMax, pColData);
}

inline HRESULT ConfigStream::GetColumnData(ULONG ulId, ULONG cColData, ULONG cArrayMax, ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnData(cColData, cArrayMax, pColData);
}

inline HRESULT ConfigStream::SetColumnData(ULONG ulId,
	ULONG cArrayMax,
	ColumnData *pColData)
{
	Assert(ulId < m_cColumnSetsMax);
	SetDirty(TRUE);
	return m_rgViewInfo[ulId].SetColumnData(cArrayMax, pColData);
}

inline const ContainerColumnInfo *	ConfigStream::GetColumnInfo(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnInfo();
}

inline ULONG ConfigStream::GetStringId(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetStringId(nColumnId);
}

inline DWORD ConfigStream::GetColumnWidth(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetColumnWidth(nColumnId);
}

inline void ConfigStream::SetSortColumn(ULONG ulId, ULONG nColumnId)
{
	Assert(ulId < m_cColumnSetsMax);
	m_rgViewInfo[ulId].SetSortColumn(nColumnId);
}

inline ULONG ConfigStream::GetSortColumn(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortColumn();
}

inline void ConfigStream::SetSortDirection(ULONG ulId, ULONG nDir)
{
	Assert(ulId < m_cColumnSetsMax);
	m_rgViewInfo[ulId].SetSortDirection(nDir);
}

inline ULONG ConfigStream::GetSortDirection(ULONG ulId)
{
	Assert(ulId < m_cColumnSetsMax);
	return m_rgViewInfo[ulId].GetSortDirection();
}

#endif _COLUMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\compinfo.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	compinfo.cpp
		Computer info class plus helper functions

	FILE HISTORY:


*/
#include <stdafx.h>
#include <winsock.h>
#include "compinfo.h"

#define STRING_MAX	256

//
//
//
BOOL	
CIpInfoArray::FIsInList(DWORD dwIp)
{
	BOOL fFound = FALSE;

	for (int i = 0; i < GetSize(); i++)
	{
		if (GetAt(i).dwIp == dwIp)
		{
			fFound = TRUE;
			break;
		}
	}

	return fFound;
}


//
//
//

CComputerInfo::CComputerInfo(LPCTSTR pszNameOrIp)
{
	m_strNameOrIp = pszNameOrIp;
	m_nIndex = -1;
}

CComputerInfo::~CComputerInfo()
{

}

HRESULT
CComputerInfo::GetIp(DWORD * pdwIp, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		if (pdwIp)
			*pdwIp = m_arrayIps[nIndex].dwIp;
	}
	else
	{
		if (pdwIp)
			*pdwIp = 0xFFFFFFFF;
	}

	return hr;
}

HRESULT
CComputerInfo::GetIpStr(CString & strIp, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		struct in_addr ipaddr ;

		//
		//  Convert the unsigned long to network byte order
		//
		ipaddr.s_addr = ::htonl( (u_long) m_arrayIps[nIndex].dwIp ) ;
		CHAR * pszAddr = inet_ntoa( ipaddr ) ;

		::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszAddr, -1, strIp.GetBuffer(IP_ADDDRESS_LENGTH_MAX), IP_ADDDRESS_LENGTH_MAX);
		strIp.ReleaseBuffer();
	}
	else
	{
		strIp.Empty();
	}

	return hr;
}

HRESULT
CComputerInfo::GetHostName(CString & strHostName)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		strHostName = m_strHostname;
	}
	else
	{
		strHostName.Empty();
	}

	return hr;
}

HRESULT
CComputerInfo::GetFqdn(CString & strFqdn, int nIndex)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (SUCCEEDED(hr))
	{
		strFqdn = m_arrayIps[nIndex].strFqdn;
	}
	else
	{
		strFqdn.Empty();
	}

	return hr;
}

int
CComputerInfo::GetCount()
{
	return m_nIndex;
}

//
//	Call this function to reset the internal data so that on the next query
//  we will rebuild our data.
//
void
CComputerInfo::Reset()
{
	// set this to -1 so that we will get the data again on the next call
	m_nIndex = -1;
	m_arrayIps.RemoveAll();
	m_strHostname.Empty();
}

HRESULT
CComputerInfo::GetDomain(CString & strDomain)
{
	// not supported right now
	strDomain.Empty();

	return E_NOTIMPL;
}

HRESULT
CComputerInfo::IsLocalMachine(BOOL * pfIsLocal)
{
	HRESULT hr = hrOK;

	if (m_nIndex == -1)
	{
		hr = InitializeData();
	}

	if (pfIsLocal)
	{
		if (SUCCEEDED(hr))
		{
			CString strLocal;
			DWORD	dwSize = STRING_MAX;
			BOOL fSuccess = GetComputerName(strLocal.GetBuffer(dwSize), &dwSize);
			strLocal.ReleaseBuffer();

			if (fSuccess)
			{
				*pfIsLocal = (strLocal.CompareNoCase(m_strHostname) == 0) ? TRUE : FALSE;
			}
		}
		else
		{
			*pfIsLocal = FALSE;
		}
	}

	return hr;
}

COMPUTER_INFO_TYPE
CComputerInfo::GetInputType()
{
    // assume a NetBios name
	COMPUTER_INFO_TYPE enResult = COMPUTER_INFO_TYPE_NB ;
	const TCHAR chDash = '-';
    const TCHAR chDot = '.' ;
	const TCHAR chSlash = '\\' ;
	CString strName( m_strNameOrIp ) ;

	int cch = strName.GetLength() ;

	//  Does the name begin with two slashes??

	if (    cch > 2
		&& strName.GetAt(0) == chSlash
		&& strName.GetAt(1) == chSlash )
	{
		enResult = COMPUTER_INFO_TYPE_NB ;
	}
	else
	{
		//
		//  Scan the name looking for DNS name or IP address
		//
		int i = 0,
			cDots = 0,
			cAlpha = 0,
            cDash = 0;
		TCHAR ch ;
		BOOL bOk = TRUE ;

		for ( ; i < cch ; i++ )
		{
			switch ( ch = strName.GetAt( i ) )
			{
				case chDot:
					if ( ++cDots > 3 )
					{
                        // we keep track of the number of dots,
                        // but we need to be able to handle fully
                        // qualified domain names (FQDN) so more than
                        // 3 dots is ok.
						//bOk = FALSE ;
					}
					break;

				default:
					if ( _istalpha( ch ) )
					{
						cAlpha++;
					}
                    else if ( ch == chDash )
                    {
                        cDash++;
                    }
					else if ( !_istdigit(ch) )
					{
						bOk = FALSE;
					}

					break;
			}
			if ( ! bOk )
			{
				break ;
			}
		}
		if ( bOk )
		{
			if ( cAlpha )
			{
				enResult = COMPUTER_INFO_TYPE_DNS ;
			}
			else if ( cDots == 3 )
			{
				enResult = COMPUTER_INFO_TYPE_IP ;
			}
		}
	}

	return enResult ;
}

// internal functions
HRESULT
CComputerInfo::InitializeData()
{
	HRESULT hr = hrOK;

	switch (GetInputType())
	{
		case COMPUTER_INFO_TYPE_NB:
		case COMPUTER_INFO_TYPE_DNS:
		{
			DWORD dwIp;

			GetHostAddress(m_strNameOrIp, &dwIp);
			GetHostInfo(dwIp);
		}
			break;

		case COMPUTER_INFO_TYPE_IP:
		{
			// convert the string to ansi 
		    CHAR szString [ STRING_MAX ] = {0};
			::WideCharToMultiByte(CP_ACP, 0, m_strNameOrIp, -1, szString, sizeof(szString), NULL, NULL);

			// get the host info after converting the IP string to a DWORD
			GetHostInfo(::ntohl( ::inet_addr( szString ) ) );
		}
			break;
	}

	return hr;
}

HRESULT
CComputerInfo::GetHostInfo 
(
    DWORD	dhipa
)
{
	CString		strFQDN;
	CString		strHostname;
	CString		strTemp;
	CIpInfo		ipInfo;

    //
    //  Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl( (u_long) dhipa ) ;

    HOSTENT * pHostEnt = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
										   sizeof ulAddrInNetOrder,
										   PF_INET ) ;
    if ( pHostEnt == NULL )
    {
        return HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    CHAR * * ppchAlias = pHostEnt->h_aliases ;

    //
    //  Check and copy the host name.
    //
	
    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostEnt->h_name, 
                          lstrlenA(pHostEnt->h_name), 
                          strTemp.GetBuffer(STRING_MAX * 2), 
                          STRING_MAX * 2);

	strTemp.ReleaseBuffer();

    // remove any periods at the end
    while (strTemp[strTemp.GetLength() - 1] == '.')
    {
        strTemp = strTemp.Left(strTemp.GetLength() - 1);
    }

    // gethostbyaddr is returning the hostname only in some cases.  
    // Make another call to get the fqdn
    if (strTemp.Find('.') == -1)
    {
		// this is not a FQDN
        GetHostAddressFQDN(strTemp, &strFQDN, &dhipa);
    }
	else
	{
		strFQDN = strTemp;
	}

    // copy the data into the buffer
	strFQDN.MakeLower();
	int nDot = strFQDN.Find('.');
	m_strHostname = strFQDN.Left(nDot);
	
	// add the primary entry to the array
	ipInfo.dwIp = dhipa;
	ipInfo.strFqdn = strFQDN;

	m_arrayIps.Add(ipInfo);

	// now loop through the h_addr_list
	int iCount = 0;
	while ( (LPDWORD)(pHostEnt->h_addr_list[iCount] ) )
	{
		if (!m_arrayIps.FIsInList(addrFromHostent(pHostEnt, iCount)))
		{
			ipInfo.dwIp = addrFromHostent(pHostEnt, iCount);
			ipInfo.strFqdn.Empty();

			m_arrayIps.Add(ipInfo);
		}

		iCount++;
	}

	m_nIndex = m_arrayIps.GetSize();

    //
    //  Find the first acceptable NetBIOS name among the aliases;
    //  i.e., the first name without a period
    //
    /*
    for ( ; *ppchAlias ; ppchAlias++ )
    {
        if  ( validateNetbiosName( *ppchAlias ) )
        {
            break ;
        }
    }

    //
    //  Empty the NetBIOS name in case we didn't get one.
    //
    pdhsrvi->_chNetbiosName[0] = 0 ;
    
    if ( *ppchAlias )
    {
        //
        //  We found a usable name; copy it to output structure.
        //
        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              *ppchAlias, 
                              lstrlenA(*ppchAlias),
                              pdhsrvi->_chNetbiosName, 
                              sizeof(pdhsrvi->_chNetbiosName));
    }
    */

    return hrOK ;
}

HRESULT 
CComputerInfo::GetHostAddressFQDN
(
    LPCTSTR			pszHostName,
    CString *       pstrFQDN,
    DWORD *			pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;

        LPTSTR pName = pstrFQDN->GetBuffer(STRING_MAX * 2);
        ZeroMemory(pName, STRING_MAX * 2);

        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              pHostent->h_name, 
                              strlen(pHostent->h_name),
                              pName, 
                              STRING_MAX * 2);

        pstrFQDN->ReleaseBuffer();

    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    return hr;
}

DWORD
CComputerInfo::addrFromHostent 
(
    const HOSTENT * pHostent,
    INT				index  
)
{
    return (DWORD) ::ntohl( *((u_long *) pHostent->h_addr_list[index]) );
}


HRESULT
CComputerInfo::GetHostAddress 
(
    LPCTSTR		pszHostName,
    DWORD *		pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR szString [ MAX_PATH ] = {0};

    ::WideCharToMultiByte(CP_ACP, 0, pszHostName, -1, szString, sizeof(szString), NULL, NULL);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdhipa = addrFromHostent( pHostent ) ;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError());
	}

    return hr ;
}

HRESULT 
CComputerInfo::GetLocalHostAddress 
(
    DWORD *		pdhipa
)
{
	HRESULT hr = hrOK;
    CHAR	chHostName [ STRING_MAX * 2 ];

    if ( ::gethostname( chHostName, sizeof(chHostName) ) == 0 )
    {
        CString strTemp = chHostName;
		hr = GetHostAddress( strTemp, pdhipa ) ;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError()) ;
	}

    return hr;
}

HRESULT 
CComputerInfo::GetLocalHostName
(
    CString * pstrName
)
{
	HRESULT hr = hrOK;
    CHAR	chHostName [ STRING_MAX * 2 ] ;

    if ( ::gethostname( chHostName, sizeof (chHostName) ) == 0 )
    {
        LPTSTR pName = pstrName->GetBuffer(STRING_MAX * 2);
		ZeroMemory(pName, STRING_MAX * 2);

        ::MultiByteToWideChar(CP_ACP, 
                              MB_PRECOMPOSED, 
                              chHostName, 
                              strlen(chHostName),
                              pName, 
                              STRING_MAX * 2);

        pstrName->ReleaseBuffer();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::WSAGetLastError()) ;
	}

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\commhelp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       commhelp.cpp
//
//--------------------------------------------------------------------------

#include "commres.h"
#include "common.hm"

// "File common.rc line 63 : Resource - DIALOGEX : IDD_STATS"
static const DWORD rgdw_IDD_STATS[] = 
{
    IDC_STATSDLG_LIST, HIDC_STATSDLG_LIST,
    IDC_STATSDLG_BTN_SELECT_COLUMNS, HIDC_STATSDLG_BTN_SELECT_COLUMNS,
    IDC_STATSDLG_BTN_CLEAR, HIDC_STATSDLG_BTN_CLEAR,
    IDC_STATSDLG_BTN_REFRESH, HIDC_STATSDLG_BTN_REFRESH,
	0,0 
};


// "File common.rc line 78 : Resource - DIALOGEX : IDD_STATS_NARROW"
static const DWORD rgdw_IDD_STATS_NARROW[] = 
{
    IDC_STATSDLG_LIST, HIDC_STATSDLG_LIST,
    IDC_STATSDLG_BTN_SELECT_COLUMNS, HIDC_STATSDLG_BTN_SELECT_COLUMNS,
    IDC_STATSDLG_BTN_CLEAR, HIDC_STATSDLG_BTN_CLEAR,
    IDC_STATSDLG_BTN_REFRESH, HIDC_STATSDLG_BTN_REFRESH,
	0,0 
};


// "File common.rc line 91 : Resource - DIALOGEX : IDD_COMMON_SELECT_COLUMNS"
static const DWORD rgdw_IDD_COMMON_SELECT_COLUMNS[] = 
{
    IDC_DISPLAYED_COLUMNS, HIDC_DISPLAYED_COLUMNS,
    IDC_RESET_COLUMNS,     HIDC_RESET_COLUMNS,
    IDC_MOVEUP_COLUMN,     HIDC_MOVEUP_COLUMN,
    IDC_MOVEDOWN_COLUMN,   HIDC_MOVEDOWN_COLUMN,
    IDC_HIDDEN_COLUMNS,    HIDC_HIDDEN_COLUMNS,
    IDC_ADD_COLUMNS,       HIDC_ADD_COLUMNS,
    IDC_REMOVE_COLUMNS,    HIDC_REMOVE_COLUMNS,
	0,0 
};


// "File common.rc line 110 : Resource - DIALOG : IDD_BUSY"
static const DWORD rgdw_IDD_BUSY[] = 
{
    IDC_SEARCH_ANIMATE, HIDC_SEARCH_ANIMATE,
    IDC_STATIC_DESCRIPTION, HIDC_STATIC_DESCRIPTION,
	0,0 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ctrlgrp.cpp ===
/*--------------------------------------------------------------------------
	ctrlgrp.cpp
		Control group switcher

	Copyright (C) Microsoft Corporation, 1993 - 1999
	All rights reserved.

	Authors:
		matth	Matthew F. Hillman, Microsoft

	History:
		10/14/93	matth	Created.
		26 oct 95	garykac	DBCS_FILE_CHECK
  --------------------------------------------------------------------------*/

//#include "precomp.h"
#include "stdafx.h"

//#ifndef _GUISTD_H
//#include "guistd.h"
//#endif

#ifndef _CTRLGRP_H
#include "ctrlgrp.h"
#endif

//#ifndef	_GLOBALS_H
//#include "globals.h"
//#endif

//#include "richres.h"

/*
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = "ctrlgrp.cpp";
#endif
*/

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// DIALOGEX structures (from MFC 4.0)
#pragma pack(push, 1)
typedef struct
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cdit;
	short x;
	short y;
	short cx;
	short cy;
} DLGTEMPLATEEX;

typedef struct
{
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	short x;
	short y;
	short cx;
	short cy;
	DWORD id;
} DLGITEMTEMPLATEEX;
#pragma pack(pop)

/*!C------------------------------------------------------------------------
	ControlGroupSwitcher

	This class is used to manage switching among groups of controls in a
	parent window.

	Primary APIs are:
	
		Create -- The pwndParent parameter is the window which will be the
		parent of the controls in the control groups.  It is commonly a
		dialog.  The idcAnchor parameter is the id of a control which will
		server as an 'anchor' for the controls.  This means that the controls
		will created in the parent window offset by the position of the
		top left corner of the anchor control.  This control is commonly
		a group box surrounding the area where the groups appear.  The
		cgsStyle parameter specifieds whether the the controls in the groups
		are created right away (cgsPreCreateAll), only when that group is
		shown (cgsCreateOnDemand), or created each time the group is shown
		and destroyed when they are hidden (cgsCreateDestroyOnDemand).

		AddGroup -- Adds a group of controls, which can be shown using
		ShowGroup.  The idGroup parameter identifies the group, and is used
		as the parameter to ShowGroup.  The idd parameter is the id of the
		dialog template with the layout of the controls.  The pfnInit
		parameter, if not NULL, is a function called when the group is
		loaded.  Note that -1 is not a legal value for idGroup (it is a
		distinguised value meaning no group).

		RemoveGroup -- Removes the group specified by idGroup, destroying the
		controls if they have been created.

		ShowGroup -- Show the group specified by idGroup, hiding any other
		group.  If -1, hides all groups.
  --------------------------------------------------------------------------*/

#if 0
BOOL CGControlInfo::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;

	return fFalse;
}

void CGControlInfo::AssertValid() const
{
}

void CGControlInfo::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

//ImplementGenericArrayConstructDestruct(RGControlInfo, CGControlInfo)
//ImplementGenericArrayDebug(RGControlInfo, CGControlInfo)

ControlGroup::ControlGroup(int idGroup, int idd,
						   void (*pfnInit)(CWnd * pwndParent))
	: m_idGroup(idGroup), m_idd(idd), m_pfnInit(pfnInit),
	  m_fLoaded(fFalse), m_fVisible(fFalse)
{
}

ControlGroup::~ControlGroup()
{
	m_rgControls.RemoveAll();
}

#if 0
BOOL ControlGroup::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;

	MarkCObject(pdbc,this,0);
		
	m_rgControls.MarkMem(pdbc,0);

	return fFalse;
}

void ControlGroup::AssertValid() const
{
	m_rgControls.AssertValid();
}

void ControlGroup::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

void ControlGroup::LoadGroup(CWnd * pwndParent, int xOffset, int yOffset)
{
	/*------------------------------------------------------------------------
	This function is mostly stolen from the Knowledge Base code for the
	'multidlg' example.

	That's why it uses mostly raw Windows rather than MFC conventions.
	------------------------------------------------------------------------*/
	
	HWND			hDlg = NULL;
	HGLOBAL         hDlgResMem = NULL;
	HRSRC           hDlgRes = NULL;
	BYTE FAR        *lpDlgRes = NULL;

//	PutAssertCanThrow();
	TRY
		{
		Assert(!m_fLoaded);

		hDlg = pwndParent->m_hWnd;
		Assert(hDlg);

		// Load the resource into memory and get a pointer to it.

		hDlgRes    = FindResource (AfxGetResourceHandle(),
								   MAKEINTRESOURCE(m_idd),
								   RT_DIALOG);
		if (!hDlgRes)
			AfxThrowResourceException();
		hDlgResMem = LoadResource (AfxGetResourceHandle(), hDlgRes);
		if (!hDlgResMem)
			AfxThrowResourceException();
		lpDlgRes   = (BYTE FAR *) LockResource (hDlgResMem);
		if (!lpDlgRes)
			AfxThrowResourceException();

		LoadWin32DialogResource(hDlg, lpDlgRes, xOffset, yOffset);

		m_fLoaded = fTrue;

		// Free the resource which we just parsed.

		UnlockResource (hDlgResMem);
		FreeResource (hDlgResMem);

		// Send the new child an init message
		if (m_pfnInit)
			(*m_pfnInit)(pwndParent);
			}
	CATCH_ALL(e)
		{
		if (hDlgRes && hDlgResMem)
			{
			if (lpDlgRes)
				UnlockResource(hDlgResMem);
			FreeResource(hDlgResMem);
			}
		m_rgControls.RemoveAll();
		THROW_LAST();
		}
	END_CATCH_ALL
}


void ControlGroup::LoadWin32DialogResource(
		HWND hDlg, 
		BYTE FAR *lpDlgRes,
		int	xOffset,
		int	yOffset)
{
	BOOL			fEx;
    RECT            rc;
	SMALL_RECT		srct;
    HFONT			hDlgFont;
    DWORD           style;
	DWORD			exstyle;
    DWORD            dwID;
    WORD			wCurCtrl;
	WORD			wNumOfCtrls;
    LPWSTR           classname;
	WORD FAR *		lpwDlgRes;
	char			pszaClassName[256];
	char 			pszaTitle[256];

	// We need to get the font of the dialog so we can set the font of
	// the child controls.  If the dialog has no font set, it uses the
	// default system font, and hDlgFont equals zero.

	hDlgFont = (HFONT) SendMessage (hDlg, WM_GETFONT, 0, 0L);

	// Figure out if this is a DIALOGEX resource
	fEx = ((DLGTEMPLATEEX *)lpDlgRes)->signature == 0xFFFF;

	// Grab all the stuff we need out of the headers
	if (fEx)
		{
		style = ((DLGTEMPLATEEX *)lpDlgRes)->style;
		wNumOfCtrls = ((DLGTEMPLATEEX *)lpDlgRes)->cdit;
		lpDlgRes += sizeof(DLGTEMPLATEEX);
		}
	else
		{
		style = ((DLGTEMPLATE *)lpDlgRes)->style;
		wNumOfCtrls = ((DLGTEMPLATE *)lpDlgRes)->cdit;
		lpDlgRes += sizeof(DLGTEMPLATE);
		}

	// Skip the variable sized information
	lpwDlgRes = (LPWORD)lpDlgRes;
	if (0xFFFF == *lpwDlgRes)
		lpwDlgRes += 2;					// menu by ordinal, skip ffff & ordinal
	else
		lpwDlgRes += wcslen(lpwDlgRes) + 1;	// Menu by name or no menu at all

	if (0xFFFF == *lpwDlgRes)
		lpwDlgRes += 2;					// classname by ordinal, skip
	else
		lpwDlgRes += wcslen(lpwDlgRes) + 1;

	lpwDlgRes += wcslen(lpwDlgRes) + 1;       // Pass the caption

	// Some fields are present only if DS_SETFONT is specified.

	if (style & DS_SETFONT)
		{
		lpwDlgRes += fEx ? 3 : 1;		// skip point size, (weight, and style)
		lpwDlgRes += wcslen(lpwDlgRes) + 1;       // Pass face name
		}

	// Allocate space in the control info array
	m_rgControls.SetSize(wNumOfCtrls);

	// The rest of the dialog template contains ControlData structures.
	// We parse these structures and call CreateWindow() for each.

	for (wCurCtrl = 0; wCurCtrl < wNumOfCtrls; wCurCtrl++)
		{
		// ControlData coordinates are in dialog units.  We need to convert
		// these to pixels before adding the anchor offset
		// Should be Word Aligned
		Assert(!((ULONG_PTR) lpwDlgRes & (0x1)));
		// Make it DWORD aligned
		if (((ULONG_PTR)(lpwDlgRes)) & (0x2))
			lpwDlgRes += 1;

		// Get the header info we need
		if (fEx)
			{
			style = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->style;
			exstyle = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->exStyle;
			srct = *(SMALL_RECT *)(&((DLGITEMTEMPLATEEX *)lpwDlgRes)->x);
			dwID = ((DLGITEMTEMPLATEEX *)lpwDlgRes)->id;
			lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + sizeof(DLGITEMTEMPLATEEX));
			}
		else
			{
			style = ((DLGITEMTEMPLATE *)lpwDlgRes)->style;
			exstyle = 0;
			srct = *(SMALL_RECT *)(&((DLGITEMTEMPLATE *)lpwDlgRes)->x);
			dwID = ((DLGITEMTEMPLATE *)lpwDlgRes)->id;
			lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + sizeof(DLGITEMTEMPLATE));
			}

		style &= ~WS_VISIBLE;			// Create invisible!

		// use the rc structure as x,y,width,height

		rc.top = srct.Top;
		rc.bottom = srct.Bottom;
		rc.left = srct.Left;
		rc.right = srct.Right;

		MapDialogRect (hDlg, &rc);                    // Convert to pixels.
		rc.left += xOffset;                           // Add the offset.
		rc.top += yOffset;

		// At this point in the ControlData structure (see "Dialog Box
		// Resource" in online help), the class of the control may be
		// described either with text, or as a byte with a pre-defined
		// meaning.

		if (*lpwDlgRes == 0xFFFF)
			{
			lpwDlgRes++; 		// Skip the FFFF
			switch (*lpwDlgRes)
				{
				case 0x0080:
					classname = L"button";		// STRING_OK
					break;
				case 0x0081:
					classname = EDIT_NORMAL_WIDE;
					//$ The strange code below fixes 3D problems
					// on Win95
					//if (g_fWin4 && !g_fWinNT)
						exstyle |= WS_EX_CLIENTEDGE;
					break;
				case 0x0082:
					classname = L"static";		// STRING_OK
					break;
				case 0x0083:
					classname = L"listbox";		// STRING_OK
					exstyle |= WS_EX_CLIENTEDGE;
					break;
				case 0x0084:
					classname = L"scrollbar";	// STRING_OK
					break;
				case 0x0085:
					classname = L"combobox";	// STRING_OK
					break;
				default:
					// Next value is an atom
					AssertSz(fFalse,"Illegal Class Value in Dialog Template");
					//$Review: Can this be any atom or must it be an enumerated
					//    value from above?
				}
			lpwDlgRes++;  // passes the class identifier
			}
		else
			{
			classname = (WCHAR *)lpwDlgRes;
			lpwDlgRes += wcslen(lpwDlgRes) + 1;
			exstyle |= WS_EX_CLIENTEDGE;
			}

		//$32 review: is this correct matt?
		// Be sure to use the UNICODE function, all the data should
		// be in UNICODE
		m_rgControls[wCurCtrl].m_hwnd =
						CreateWindowExW (exstyle, classname, (LPWSTR)lpwDlgRes,
										 style, (int) rc.left, (int) rc.top,
										 (int) rc.right, (int) rc.bottom,
										 hDlg, (HMENU)ULongToPtr(dwID),
										 (HINSTANCE) AfxGetInstanceHandle(),
										 NULL);

		// There is no CreateWindowExW in Win95 so convert the strings to ANSI
		if (m_rgControls[wCurCtrl].m_hwnd == NULL &&
			GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
			{
			if (!WideCharToMultiByte(CP_ACP,0,classname,-1,pszaClassName,256,NULL,NULL) ||
				!WideCharToMultiByte(CP_ACP,0,(LPWSTR)lpwDlgRes, -1, pszaTitle, 256, NULL,NULL))
				{				
				AssertSz(fFalse, "WideCharToMultiByteFailed");
				AfxThrowResourceException();
				}
			m_rgControls[wCurCtrl].m_hwnd = 
						CreateWindowExA(exstyle,pszaClassName, pszaTitle,
										style,(int) rc.left, (int) rc.top,
										(int) rc.right, (int) rc.bottom,
										hDlg, (HMENU)ULongToPtr(dwID),
										(HINSTANCE) AfxGetInstanceHandle(),
										NULL);

			}

		if (!m_rgControls[wCurCtrl].m_hwnd)
			AfxThrowResourceException();

		MaskAccelerator(m_rgControls[wCurCtrl].m_hwnd, fTrue); // Make sure all the accelerators are disabled

		// Pass the window text
		if (0xFFFF == *lpwDlgRes)
			lpwDlgRes += 2;
		else
			lpwDlgRes += wcslen(lpwDlgRes) + 1;

		// skip over creation data
		lpwDlgRes = (LPWORD)((LPBYTE)lpwDlgRes + *lpwDlgRes + 2);
		// see DYNDLG SDK example, this is a size word in Win32


		// Even though the font is the right size (MapDialogRect() did 
		// this), we also need to set the font if it's not the system font.
		if (hDlgFont)
			::SendMessage(m_rgControls[wCurCtrl].m_hwnd,WM_SETFONT,
						  (WPARAM)hDlgFont,(LPARAM)fFalse);
		}
}

void ControlGroup::UnloadGroup()
{
	Assert(m_fLoaded);
	
	m_rgControls.RemoveAll();
	m_fLoaded = fFalse;
}

void ControlGroup::ShowGroup(HDWP& hdwp, BOOL fShow, CWnd * pwnd)
{
	long i,n;
	UINT rgfSwp;
  	HWND hwndInsertAfter = NULL;
	
	if (pwnd)
		hwndInsertAfter = pwnd->m_hWnd;

	Assert((fShow && !m_fVisible) || (m_fVisible && !fShow));
	Assert(m_fLoaded);

	rgfSwp = SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE |(pwnd != NULL ? 0 : SWP_NOZORDER)|
			 (fShow ? SWP_SHOWWINDOW : SWP_HIDEWINDOW);
	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
		{
		HWND hwnd = m_rgControls[i].m_hwnd;
		MaskAccelerator(hwnd, !fShow);
		hdwp = DeferWindowPos(hdwp,hwnd,hwndInsertAfter,0,0,0,0,rgfSwp);
		hwndInsertAfter = hwnd;
		}
	m_fVisible = fShow;
}

void ControlGroup::EnableGroup(BOOL fEnable)
{
	long i,n;

	Assert(m_fLoaded);

	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
	{
		HWND hwnd = m_rgControls[i].m_hwnd;
		::EnableWindow(hwnd, fEnable);
	}
}

void ControlGroup::AddControl(HWND hwnd)
{
	Assert(m_fLoaded);
	
	int nNewIndex = (int)m_rgControls.Add(CGControlInfo());

	m_rgControls[nNewIndex].m_hwnd = hwnd;
}

void ControlGroup::RemoveControl(HWND hwnd)
{
	long i, n;
	
	Assert(m_fLoaded);

	for (i = 0, n = (long)m_rgControls.GetSize(); i < n; i++)
	{
		if (m_rgControls[i].m_hwnd == hwnd)
		{
			m_rgControls.RemoveAt(i);
			return;
		}
	}

	Assert(fFalse);
}

void ControlGroup::MaskAccelerator(HWND hwnd, BOOL fMask)
{
	TCHAR szText[256];
	TCHAR * psz;
	DWORD_PTR dwCtlCode;
	
	// Ignore text of controls which accept text (like edit controls)
	// and of static controls which have the SS_NOPREFIX style.

	dwCtlCode = SendMessage (hwnd, WM_GETDLGCODE, 0, 0L);
	if (DLGC_WANTCHARS & dwCtlCode)
		return;
	if (DLGC_STATIC & dwCtlCode)
		{
		LONG lStyle;
		
		lStyle = GetWindowLong (hwnd, GWL_STYLE);
                
		if (SS_NOPREFIX & lStyle)
			return;
		}

	// DBCS_OK [tatsuw]

	// Don't have a really long label
	Assert(GetWindowTextLength(hwnd) < DimensionOf(szText));
	
	GetWindowText (hwnd, szText, DimensionOf(szText));
	
	// Don't have |s in your text
	Assert((!fMask) || (_tcschr(szText, TEXT('|')) == NULL));
	
	psz = szText;
	while ((psz = _tcschr(psz, fMask ? TEXT('&') : TEXT('|'))) != NULL)
		{
		if (fMask && psz[1] == '&')
			{
			// Special! Ignore double ampersand
			psz++;
			continue;
			}
		*psz = fMask ? TEXT('|') : TEXT('&');
		SetWindowText(hwnd, szText);
		break;
		}
}

#if 0
void RGPControlGroup::AssertValidGen(GEN *pgen) const
{
	ControlGroup * pGroup = *(PControlGroup *)pgen;
	if (pGroup)
		pGroup->AssertValid();
}

void RGPControlGroup::MarkMemGen(IDebugContext *pdbc, GEN *pgen)
{
	ControlGroup * pGroup = *(PControlGroup *)pgen;
	pGroup->MarkMem(pdbc,0);
}
#endif

long RGPControlGroup::GroupIndex(int idGroup) const
{
	long i, n;

	for (i = 0, n = (long)GetSize(); i < n; i++)
		if ((GetAt(i))->IDGroup() == idGroup)
			return i;

	Assert(fFalse);
	return -1;
}

ControlGroupSwitcher::ControlGroupSwitcher()
	: m_iGroup(-1), m_pwndParent(NULL)
{
}

void ControlGroupSwitcher::Create(CWnd * pwndParent, int idcAnchor,
								  int cgsStyle)
{
	m_pwndParent = pwndParent;
	m_idcAnchor = idcAnchor;
	m_cgsStyle = cgsStyle;
	ComputeAnchorOffsets();
}


ControlGroupSwitcher::~ControlGroupSwitcher()
{
	for (long i = 0, n = (long)m_rgpGroups.GetSize(); i < n; i++)
		{
		delete m_rgpGroups[i];
		m_rgpGroups[i] = NULL;
		}
	
	m_rgpGroups.RemoveAll();
}

#if 0
BOOL ControlGroupSwitcher::MarkMem(IDebugContext * pdbc, long cRef)
{
	if (pdbc->MarkMem(this,sizeof(*this),cRef))
		return fTrue;
	
	MarkCObject(pdbc,this,0);

	m_rgpGroups.MarkMem(pdbc,0);

	return fFalse;
}

void ControlGroupSwitcher::AssertValid() const
{
	m_rgpGroups.AssertValid();
}

void ControlGroupSwitcher::Dump(CDumpContext &dc) const
{
}
#endif // DEBUG

void ControlGroupSwitcher::AddGroup(int idGroup, int idd,
									void (*pfnInit)(CWnd * pwndParent))
{
	ControlGroup * pGroupNew = NULL;

	TRY
	{
    	pGroupNew = new ControlGroup(idGroup, idd, pfnInit);
	
        m_rgpGroups.Add(pGroupNew);
	}
	CATCH_ALL(e)
	{
		delete pGroupNew;
		THROW_LAST();
	}
	END_CATCH_ALL

	// In a stable state now.  Possibly load controls which might also throw
	if (m_cgsStyle == cgsPreCreateAll)
		pGroupNew->LoadGroup(m_pwndParent, m_xOffset, m_yOffset);
}

void ControlGroupSwitcher::RemoveGroup(int idGroup)
{
	// Don't remove group being shown!  Show another group first.
	Assert(idGroup != m_iGroup);
	
	long index;
	ControlGroup * pGroup;

	index = m_rgpGroups.GroupIndex(idGroup);
	pGroup = m_rgpGroups[index];
	delete pGroup;
	m_rgpGroups.RemoveAt(index);
}

void ControlGroupSwitcher::EnableGroup(int idGroup, BOOL fEnable)
{
	long index;
	ControlGroup * pGroup;

	if (idGroup == -1)
		idGroup = m_iGroup;

	index = m_rgpGroups.GroupIndex(idGroup);
	pGroup = m_rgpGroups[index];
	
	pGroup->EnableGroup(fEnable);
}

void ControlGroupSwitcher::ShowGroup(int idGroup)
{
	ControlGroup * pGroupOld = NULL;
	ControlGroup * pGroupNew = NULL;
	HDWP hdwp;
	int cWindows;
	
	if (m_iGroup == idGroup)
		return;

	cWindows = 0;
	
	if (m_iGroup != -1)
	{
		pGroupOld = m_rgpGroups.PGroup(m_iGroup);
		Assert(pGroupOld->FVisible());
		cWindows += pGroupOld->CControls();
	}
	
	if (idGroup != -1)
	{
		pGroupNew = m_rgpGroups.PGroup(idGroup);
		if (!pGroupNew->FLoaded())
			pGroupNew->LoadGroup(m_pwndParent, m_xOffset, m_yOffset);
		cWindows += pGroupNew->CControls();
	}

	hdwp = BeginDeferWindowPos(cWindows);
	if (!hdwp)
		AfxThrowResourceException();

	if (m_iGroup != -1)
		{
		pGroupOld->ShowGroup(hdwp,fFalse, NULL);
		if (m_cgsStyle == cgsCreateDestroyOnDemand)
			pGroupOld->UnloadGroup();
		}

	// Indicate we currently have no group, in case below throws
	m_iGroup = -1;

	if (idGroup != -1)
		{
		pGroupNew->ShowGroup(hdwp, fTrue, m_pwndParent->GetDlgItem(m_idcAnchor));
		m_iGroup = idGroup;
		}

	EndDeferWindowPos(hdwp);
}

void ControlGroupSwitcher::ComputeAnchorOffsets()
{
    /*------------------------------------------------------------------------
      Note that anchor offset is computed relative to upper left.
      Intended use: Make an invisible group box where you want your controls.
      ------------------------------------------------------------------------*/
    
    CWnd * pwndAnchor;
    RECT rc;
    
    pwndAnchor = m_pwndParent->GetDlgItem(m_idcAnchor);
    Assert(pwndAnchor);
    
    // compute the offset of the anchor when the window is mapped
    // This offset is used to place the child controls in the dialog.
    
    pwndAnchor->GetWindowRect( &rc );
    MapWindowPoints( HWND_DESKTOP, m_pwndParent->m_hWnd, ( LPPOINT ) &rc, 2 );
    
    m_xOffset = rc.left;
    m_yOffset = rc.top;
    
} // ControlGroupSwitcher::ComputeAnchorOffsets()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dataobj.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dataobj.cpp
        Implementation for data objects in the MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dataobj.h"
#include "extract.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity


// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"SNAPIN_INTERNAL"; 


///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

// MMC required clipboard formats
unsigned int CDataObject::m_cfNodeType          = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CDataObject::m_cfNodeTypeString    = RegisterClipboardFormat(CCF_SZNODETYPE);  
unsigned int CDataObject::m_cfDisplayName       = RegisterClipboardFormat(CCF_DISPLAY_NAME); 
unsigned int CDataObject::m_cfCoClass           = RegisterClipboardFormat(CCF_SNAPIN_CLASSID); 
unsigned int CDataObject::m_cfMultiSel          = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
unsigned int CDataObject::m_cfMultiSelDobj      = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
unsigned int CDataObject::m_cfDynamicExtension  = RegisterClipboardFormat(CCF_MMC_DYNAMIC_EXTENSIONS);
unsigned int CDataObject::m_cfNodeId2           = RegisterClipboardFormat(CCF_NODEID2);

// snpain specific clipboard formats
unsigned int CDataObject::m_cfInternal       = RegisterClipboardFormat(SNAPIN_INTERNAL); 

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations
DEBUG_DECLARE_INSTANCE_COUNTER(CDataObject);

IMPLEMENT_ADDREF_RELEASE(CDataObject)

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IDataObject)
		*ppv = (IDataObject *) this;
	else if (m_spUnknownInner)
	{
		// blind aggregation, we don't know what we're aggregating
		// with, so just pass it down.
		return m_spUnknownInner->QueryInterface(riid, ppv);
	}

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
        }
    else
		return E_NOINTERFACE;
}


STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
	else
	{
		//
		// Call the derived class and see if it can handle
		// this clipboard format
		//
		hr = GetMoreDataHere(lpFormatetc, lpMedium);
	}

	return hr;
}

STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetcIn->cfFormat == m_cfMultiSel)
    {
        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
            return E_FAIL;
        
        //return CreateMultiSelData(lpMedium);

        ASSERT(m_pbMultiSelData != 0);
        ASSERT(m_cbMultiSelData != 0);

        lpMedium->tymed = TYMED_HGLOBAL; 
        lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, 
                                          (m_cbMultiSelData + sizeof(DWORD)));
        if (lpMedium->hGlobal == NULL)
            return STG_E_MEDIUMFULL;

        BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
        *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID); 
        pb += sizeof(DWORD);
        CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

        ::GlobalUnlock(lpMedium->hGlobal);

        hr = S_OK;
    }
    else
    if (lpFormatetcIn->cfFormat == m_cfDynamicExtension)
    {
        if (m_pDynExt)
        {
            // get the data...
            m_pDynExt->BuildMMCObjectTypes(&lpMedium->hGlobal);

            if (lpMedium->hGlobal == NULL)
                return STG_E_MEDIUMFULL;

            hr = S_OK;
        }
    }
    else 
    if (lpFormatetcIn->cfFormat == m_cfNodeId2)
    {
        hr = CreateNodeId2(lpMedium);
    }

    return hr;
}
    
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatEtc)
{
    HRESULT hr = E_INVALIDARG;

    if (lpFormatEtc == NULL)
        return DV_E_FORMATETC;

    if (lpFormatEtc->lindex != -1)
        return DV_E_LINDEX;

    if (lpFormatEtc->tymed != TYMED_HGLOBAL)
        return DV_E_TYMED;

    if (!(lpFormatEtc->dwAspect & DVASPECT_CONTENT))
        return DV_E_DVASPECT;

    // these are our supported clipboard formats.  If it isn't one 
    // of these then return invalid.

    if ( (lpFormatEtc->cfFormat == m_cfNodeType) ||
         (lpFormatEtc->cfFormat == m_cfNodeTypeString) ||
         (lpFormatEtc->cfFormat == m_cfDisplayName) ||
         (lpFormatEtc->cfFormat == m_cfCoClass) ||
         (lpFormatEtc->cfFormat == m_cfInternal) ||
         (lpFormatEtc->cfFormat == m_cfNodeId2) ||
         (lpFormatEtc->cfFormat == m_cfDynamicExtension) )
    {
        hr = S_OK;
    }
	else if ((lpFormatEtc->cfFormat == m_cfMultiSel) ||
			 (lpFormatEtc->cfFormat == m_cfMultiSelDobj))
	{
		// Support multi-selection format only if this
		// is a multi-select data object
		if (m_bMultiSelDobj)
			hr = S_OK;
	}
	else
		hr = QueryGetMoreData(lpFormatEtc);

#ifdef DEBUG
    TCHAR buf[2000];

    ::GetClipboardFormatName(lpFormatEtc->cfFormat, buf, sizeof(buf));

    Trace2("CDataObject::QueryGetData - query format %s returning %lx\n", buf, hr);
#endif
    
    return hr;
}


// Note - Sample does not implement these
STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::GetCanonicalFormatEtc(LPFORMATETC lpFormatEtcIn, LPFORMATETC lpFormatEtcOut)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::SetData(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpMedium, BOOL bRelease)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DAdvise(LPFORMATETC lpFormatEc, DWORD advf,
								  LPADVISESINK pAdvSink, LPDWORD pdwConn)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
	return E_NOTIMPL;
}

STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA *ppEnumAdvise)
{
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;
		    hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Create the node type object in GUID format
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	const GUID* pNodeType = spNode->GetNodeType();
    return Create(reinterpret_cast<const void*>(pNodeType), sizeof(GUID), lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
	OLECHAR szNodeType[128];
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	const GUID* pNodeType = spNode->GetNodeType();
	::StringFromGUID2(*pNodeType,szNodeType,128);
    return Create(szNodeType, ((wcslen(szNodeType)+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager
	CString szDispName;
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();
	szDispName = spNode->GetString(-1);
    return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(wchar_t)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}

HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
    Assert(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        
    Assert(m_pbMultiSelData != 0);
    Assert(m_cbMultiSelData != 0);

    return Create(reinterpret_cast<const void*>(m_pbMultiSelData), 
                  m_cbMultiSelData, lpMedium);
}

HRESULT CDataObject::CreateNodeId2(LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    // Create the node type object in GUID format
	SPITFSNode	spNode;
	spNode = GetDataFromComponentData();

	SPITFSNodeHandler   spHandler;

	spNode->GetHandler(&spHandler);

    if (spHandler)
    {
        CComBSTR bstrId;
        DWORD    dwFlags = 0;

        hr = spHandler->CreateNodeId2(spNode, &bstrId, &dwFlags);
        if (SUCCEEDED(hr) && hr != S_FALSE && bstrId.Length() > 0)
        {
            int nSize = sizeof(SNodeID2) + (bstrId.Length() * sizeof(TCHAR));

            lpMedium->tymed = TYMED_HGLOBAL; 
            lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, nSize);
            if (lpMedium->hGlobal == NULL)
            {
                hr = STG_E_MEDIUMFULL;
            }
            else
            {
                SNodeID2 * pNodeId = reinterpret_cast<SNodeID2*>(::GlobalLock(lpMedium->hGlobal));

                ::ZeroMemory(pNodeId, nSize);

                pNodeId->cBytes = bstrId.Length() * sizeof(TCHAR);
                pNodeId->dwFlags = dwFlags;
                _tcscpy((LPTSTR) pNodeId->id, bstrId);

                ::GlobalUnlock(lpMedium->hGlobal);
            }
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

ITFSNode* CDataObject::GetDataFromComponentData()
{	
	SPITFSNodeMgr	spNodeMgr;
	SPITFSNode		spNode;

	Assert(m_spTFSComponentData);
	m_spTFSComponentData->GetNodeMgr(&spNodeMgr);
	spNodeMgr->FindNode(m_internal.m_cookie, &spNode);
	
	return spNode.Transfer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ctrlgrp.h ===
/*--------------------------------------------------------------------------
	ctrlgrp.h
		Control group switcher

	Copyright (C) Microsoft Corporation, 1993 - 1997
	All rights reserved.

	Authors:
		matth	Matthew F. Hillman, Microsoft

	History:
		10/14/93	matth	Created.
		26 oct 95	garykac	DBCS_FILE_CHECK
  --------------------------------------------------------------------------*/


#ifndef _CTRLGRP_H
#define _CTRLGRP_H

/*
#if defined(_DEBUG) && defined(INLINE)
#undef THIS_FILE
extern char BASED_CODE CTRLGRP_H[];
#define THIS_FILE CTRLGRP_H
#endif
*/
#define INLINE				inline

#define fTrue				TRUE
#define fFalse				FALSE
#define g_fWin4				FALSE
#define g_fWinNT			TRUE
#define EDIT_NORMAL_WIDE	L"EDIT"

class RGControlInfo;

class CGControlInfo
{
	friend class RGControlInfo;
	friend class ControlGroup;
public:	
	CGControlInfo();
	CGControlInfo(const CGControlInfo & cgciCopy);
	~CGControlInfo();
	//DeclareStdDebugMembers()
	
	HWND m_hwnd;
};

//DeclareGenericArrayBegin(RGControlInfo, CGControlInfo, 10)
//	DeclareGenericArrayAccessors(RGControlInfo, CGControlInfo)
//	DeclareGenericArrayConstructDestruct(RGControlInfo, CGControlInfo)
//	DeclareGenericArrayDebug(RGControlInfo, CGControlInfo)
//DeclareGenericArrayEnd

typedef CArray<CGControlInfo, CGControlInfo> tempRGControlInfo;

class RGControlInfo : public tempRGControlInfo
{
};

class ControlGroup : public CObject
{
public:
	// INITIALIZATION
	ControlGroup(int idGroup, int idd, void (*pfnInit)(CWnd * pwndParent));
	~ControlGroup();
	
	//DeclareStdDebugMembers()

public:
	// APIS
	void LoadGroup(CWnd * pwndParent, int xOffset, int yOffset);
	void UnloadGroup();
	void ShowGroup(HDWP& hdwp, BOOL fShow = fTrue, CWnd *pwndParent = NULL);
	void EnableGroup(BOOL fEnable);
	
	int IDGroup() const;
	BOOL FLoaded() const;
	BOOL FVisible() const;
	int CControls() const;

	void AddControl(HWND hwnd);
	void RemoveControl(HWND hwnd);

private:

	static void MaskAccelerator(HWND hwnd, BOOL fMask);

#ifdef WIN16
	void LoadWin16DialogResource(HWND hDlg, BYTE FAR *lpDlgRes, int x, int y);
#else
	void LoadWin32DialogResource(HWND hDlg, BYTE FAR *lpDlgRes, int x, int y);
#endif
	
	int m_idGroup;
	int m_idd;
	void (*m_pfnInit)(CWnd * pwndParent);
	RGControlInfo m_rgControls;
	BOOL m_fLoaded;
	BOOL m_fVisible;
};

typedef ControlGroup * PControlGroup;

//DeclareGenericArrayBegin(RGPControlGroup, PControlGroup, 10)
//	DeclareGenericArrayAccessors(RGPControlGroup, PControlGroup)
//	DeclareGenericArrayDebug(RGPControlGroup, PControlGroup)
//	long GroupIndex(int idGroup) const;
//	PControlGroup PGroup(int idGroup) const;
//DeclareGenericArrayEnd

typedef CArray<PControlGroup, PControlGroup> tempRGPControlGroup;

class RGPControlGroup : public tempRGPControlGroup
{
public:
	long GroupIndex(int idGroup) const;
	PControlGroup PGroup(int idGroup) const;
};

enum
{
	cgsPreCreateAll, cgsCreateOnDemand, cgsCreateDestroyOnDemand
};

class ControlGroupSwitcher : public CObject
{
public:
	// INITIALIZATION
	ControlGroupSwitcher();
	void Create(CWnd * pwndParent, int idcAnchor, int cgsStyle);
	~ControlGroupSwitcher();

	//DeclareStdDebugMembers();

public:
	// APIS
	void AddGroup(int idGroup, int idd, void (*pfnInit)(CWnd * pwndParent));
	void RemoveGroup(int idGroup);
	void ShowGroup(int idGroup);
	int GetCurrentGroupID() const;
	void AddControlToGroup(int idGroup, HWND hwnd);
	void RemoveControlFromGroup(int idGroup, HWND hwnd);
	void EnableGroup(int idGroup, BOOL fEnable);

private:
	void ComputeAnchorOffsets();
	
	RGPControlGroup m_rgpGroups;
	int m_iGroup;
	CWnd * m_pwndParent;
	int m_cgsStyle;
	int m_idcAnchor;
	int m_xOffset;
	int m_yOffset;
};

#ifdef INLINE

INLINE CGControlInfo::CGControlInfo()
	: m_hwnd(NULL)
{
}

INLINE CGControlInfo::CGControlInfo(const CGControlInfo & cgciCopy)
	: m_hwnd(cgciCopy.m_hwnd)
{
}

INLINE CGControlInfo::~CGControlInfo()
{
	//$ REVIEW: Don't destroy windows -- probably already gone (like in dlg)
//	if (m_hwnd)
//		::DestroyWindow(m_hwnd);
}

INLINE int ControlGroup::IDGroup() const
{
	return m_idGroup;
}

INLINE BOOL ControlGroup::FLoaded() const
{
	return m_fLoaded;
}

INLINE BOOL ControlGroup::FVisible() const
{
	return m_fVisible;
}

INLINE BOOL ControlGroup::CControls() const
{
	Assert(FLoaded());
	return (int)m_rgControls.GetSize();
}

INLINE PControlGroup RGPControlGroup::PGroup(int idGroup) const
{
	return GetAt(GroupIndex(idGroup));
}

INLINE int ControlGroupSwitcher::GetCurrentGroupID() const
{
	return m_iGroup;
}

INLINE void ControlGroupSwitcher::AddControlToGroup(int idGroup, HWND hwnd)
{
	m_rgpGroups.PGroup(idGroup)->AddControl(hwnd);
}

INLINE void ControlGroupSwitcher::RemoveControlFromGroup(int idGroup,
														 HWND hwnd)
{
	m_rgpGroups.PGroup(idGroup)->RemoveControl(hwnd);
}

#endif // INLINE

#endif // _CTRLGRP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\guid.c ===
/*----------------------------------------------------------------------------
	dbgguid.c
		Initialize debug GUIDs.

	Copyright (C) Microsoft Corporation, 1993 - 1997
	All rights reserved.

	Authors:
		GaryBu	Gary S. Burd, Microsoft

	History:
		05/27/93	GaryBu	Created.
		27 oct 95	garykac	DBCS_FILE_CHECK	debug file: BEGIN_STRING_OK
 ----------------------------------------------------------------------------*/

#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include "tfsguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dynext.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dynext.cpp
	    dynamic extension helper

    FILE HISTORY:
	
*/

#ifndef _DYNEXT_H
#define _DYNEXT_H

#ifndef _SNAPUTIL_H
#include "snaputil.h"
#endif

class CDynamicExtensions
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	CDynamicExtensions();
	virtual ~CDynamicExtensions();

    HRESULT SetNode(const GUID * guid);
    HRESULT Reset();
    HRESULT Load();
    HRESULT GetNamespaceExtensions(CGUIDArray & aGuids);
    HRESULT BuildMMCObjectTypes(HGLOBAL * phGlobal);

    BOOL    IsLoaded() { return m_bLoaded; }

protected:
    BOOL        m_bLoaded;
    GUID        m_guidNode;
    CGUIDArray  m_aNameSpace;
    CGUIDArray  m_aMenu;
    CGUIDArray  m_aToolbar;
    CGUIDArray  m_aPropSheet;
    CGUIDArray  m_aTask;
};


/*!--------------------------------------------------------------------------
	SearchChildNodesForGuid
		Returns hrOK (and a pointer in ppChild, if that is non-NULL).
		Returns S_FALSE if a node (with the matching GUID) is not found.

		This will return the FIRST node that matches the GUID.  If there
		are more than one node that has a GUID match, then you're on
		your own.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SearchChildNodesForGuid(ITFSNode *pParent, const GUID *pGuid, ITFSNode **ppChild);



#endif // _DYNEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dataobj.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    dataobj.h
	Implementation for data objects in the MMC

    FILE HISTORY:
	
*/

#ifndef _DATAOBJ_H
#define _DATAOBJ_H


#ifndef _COMPDATA_H_
#include "compdata.h"
#endif

#ifndef _EXTRACT_H
#include "extract.h"
#endif

#ifndef _DYNEXT_H
#include "dynext.h"
#endif

class CDataObject :
	public IDataObject
{
public:
	DeclareIUnknownMembers(IMPL)
	DeclareIDataObjectMembers(IMPL)

	// Derived class should override this for custom behavior
	virtual HRESULT QueryGetMoreData(LPFORMATETC lpFormatEtc)
		{ return E_INVALIDARG; }
	virtual HRESULT GetMoreDataHere(LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpMedium)
		{ return DV_E_CLIPFORMAT; }

public:
// Construction/Destruction
	// Normal constructor
    CDataObject() :
		m_cRef(1),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
        m_bMultiSelDobj(FALSE),
        m_pDynExt(NULL)
	{
	    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);
	};

    virtual ~CDataObject() 
	{
	    DEBUG_DECREMENT_INSTANCE_COUNTER(CDataObject);
        if (m_pbMultiSelData)
            delete m_pbMultiSelData;
	};

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;  
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;             // Required by the console
    static unsigned int    m_cfMultiSel;            // Required for multiple selection
    static unsigned int    m_cfMultiSelDobj;        // Required for multiple selection
    static unsigned int    m_cfDynamicExtension;
    static unsigned int    m_cfNodeId2;
    
    static unsigned int    m_cfInternal; 

// Standard IDataObject methods
public:

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) 
    { Assert(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; }
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid) { m_internal.m_clsid = clsid; }
    void SetVirtualIndex(int nIndex) { m_internal.m_index = nIndex; }

    BOOL HasVirtualIndex() { return m_internal.m_index != -1; }
    int  GetVirtualIndex() { return m_internal.m_index; }

    void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
    {
        m_pbMultiSelData = pbMultiSelData;
        m_cbMultiSelData = cbMultiSelData;
    }

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

	HRESULT SetTFSComponentData(ITFSComponentData *pTFSCompData)
	{
		m_spTFSComponentData.Set(pTFSCompData);
		return hrOK;
	}

	void SetInnerIUnknown(IUnknown *punk)
	{
		m_spUnknownInner.Set(punk);
	}

    void SetDynExt(CDynamicExtensions * pDynExt) { m_pDynExt = pDynExt; }
    CDynamicExtensions * GetDynExt() { return m_pDynExt; }

protected:
    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	ITFSNode* GetDataFromComponentData();

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); 
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeId2(LPSTGMEDIUM lpMedium);

    INTERNAL            m_internal;   

// pointer to the ComponentData
private:

    long	            m_cRef;

	SPITFSComponentData	m_spTFSComponentData;

    BYTE*               m_pbMultiSelData;
    UINT                m_cbMultiSelData;
    BOOL                m_bMultiSelDobj;

    CDynamicExtensions *m_pDynExt;

    // pointer to inner unknown
	SPIUnknown	        m_spUnknownInner;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dialog.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dialog.cpp
        base dialog class to handle help
        
    FILE HISTORY:
    	7/10/97     Eric Davison        Created

*/

#include "stdafx.h"
#include "dialog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
	Global help map
 ---------------------------------------------------------------------------*/
PFN_FINDHELPMAP	g_pfnHelpMap = NULL;

/*!--------------------------------------------------------------------------
	SetGlobalHelpMapFunction
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetGlobalHelpMapFunction(PFN_FINDHELPMAP pfnHelpFunction)
{
	g_pfnHelpMap = pfnHelpFunction;
}



IMPLEMENT_DYNAMIC(CBaseDialog, CDialog)

CBaseDialog::CBaseDialog()
{
}

CBaseDialog::CBaseDialog(UINT nIDTemplate, CWnd *pParent)
	: CDialog(nIDTemplate, pParent)
{
}

BEGIN_MESSAGE_MAP(CBaseDialog, CDialog)
	//{{AFX_MSG_MAP(CBaseDialogDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
			
END_MESSAGE_MAP()


HWND FixupIpAddressHelp(HWND hwndItem)
{
	HWND	hwndParent;
	TCHAR	szClassName[32];	 // should be enough to hold "RtrIpAddress"
	
	// If any of these calls fail, bail and pass the call down
	hwndParent = ::GetParent(hwndItem);
	if (hwndParent)
	{
		if (::GetClassName(hwndParent, szClassName, DimensionOf(szClassName)))
		{
			// Ensure that the string is NULL terminated
			szClassName[DimensionOf(szClassName)-1] = 0;
			
			if (lstrcmpi(szClassName, TEXT("IPAddress")) == 0)
			{
				// Ok, this control is part of the IP address
				// control, return the handle of the parent
				hwndItem = hwndParent;
			}
		}
		
	}
	return hwndItem;
}

/*!--------------------------------------------------------------------------
	CBaseDialog::OnHelpInfo
		Brings up the context-sensitive help for the controls.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CBaseDialog::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD *	pdwHelp	= GetHelpMapInternal();

        if (pdwHelp)
        {
		    // Ok to fix the f**king help for the f**king IP address
		    // controls, we will need to add special case code.  If we
		    // can't find the id of our control in our list, then we look
		    // to see if this is the child of the "RtrIpAddress" control, if
		    // so then we change the pHelpInfo->hItemHandle to point to the
		    // handle of the ip address control rather than the control in
		    // the ip addrss control.  *SIGH*
		    dwCtrlId = ::GetDlgCtrlID((HWND) pHelpInfo->hItemHandle);
		    for (i=0; pdwHelp[i]; i+=2)
		    {
			    if (pdwHelp[i] == dwCtrlId)
				    break;
		    }

		    if (pdwHelp[i] == 0)
		    {
			    // Ok, we didn't find the control in our list, so let's
			    // check to see if it's part of the IP address control.
			    pHelpInfo->hItemHandle = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);
		    }

#ifdef DEBUG
			LPCTSTR pszTemp = AfxGetApp()->m_pszHelpFilePath;
#endif
			::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}

/*!--------------------------------------------------------------------------
	CBaseDialog::OnContextMenu
		Brings up the help context menu for those controls that don't
		usually have context menus (i.e. buttons).  Note that this won't
		work for static controls since they just eat up all messages.
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CBaseDialog::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	DWORD * pdwHelp = GetHelpMapInternal();

    if (pdwHelp)
    {
	    ::WinHelp (pWnd->m_hWnd,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_CONTEXTMENU,
		           (ULONG_PTR)pdwHelp);
    }
}

/*!--------------------------------------------------------------------------
	CBaseDialog::GetHelpMapInternal
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
DWORD * CBaseDialog::GetHelpMapInternal()
{
	DWORD	*	pdwHelpMap = NULL;
	DWORD		dwIDD = 0;

//	if (HIWORD(m_lpszTemplateName) == 0)
//		dwIDD = LOWORD((DWORD) m_lpszTemplateName);
	if ((ULONG_PTR) m_lpszTemplateName < 0xFFFF)
		dwIDD = (WORD) m_lpszTemplateName;
	
	// If there is no dialog IDD, give up
	// If there is no global help map function, give up
	if ((dwIDD == 0) ||
		(g_pfnHelpMap == NULL) ||
		((pdwHelpMap = g_pfnHelpMap(dwIDD)) == NULL))
		return GetHelpMap();

	return pdwHelpMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dialog.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dialog.h
        base dialog class to handle help
        
    FILE HISTORY:
    	7/10/97     Eric Davison        Created

*/

#ifndef _DIALOG_H_
#define _DIALOG_H_


//----------------------------------------------------------------------------
//	Class:	CBaseDialog
//
//	This class is used to hold all common dialog code.  Specifically, the
//	help code.  What this requires is that the dialog user override the
//	GetHelpMap function and return the array of help IDs.  CBaseDialog does 
//  NOT free this array up, it is up to the derived class to do so.
//
//	An additional way (which is a hack, but it helps because Kenn is so
//	lazy) is to use the SetGlobalHelpMapFunction().  If we find a global
//	help function, we will use that before calling GetHelpMap().
//
//	The overridden function gets called each time a help request comes in
//  to pass the help IDs to WinHelp.
//----------------------------------------------------------------------------

class CBaseDialog : public CDialog 
{
public:
    DECLARE_DYNAMIC(CBaseDialog)
			
	CBaseDialog();
	CBaseDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	// Use this call to get the actual help map
	// this version will check the global help map first.
	DWORD *		GetHelpMapInternal();
	
    // override this to return the app specific help map
    virtual DWORD * GetHelpMap() { return NULL; }
    
protected:
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

	DECLARE_MESSAGE_MAP()
};

HWND FixupIpAddressHelp(HWND hwndItem);


/*---------------------------------------------------------------------------
	The functions below are used to setup the global help map for use
	by the property pages and the dialog code.
 ---------------------------------------------------------------------------*/
typedef DWORD *	(*PFN_FINDHELPMAP)(DWORD dwIDD);
void	SetGlobalHelpMapFunction(PFN_FINDHELPMAP pfnHelpFunction);

#endif // _COMMON_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\handlers.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    handlers.cpp
        Implementation for non-threaded handlers and background
                threaded handlers.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "handlers.h"

/*---------------------------------------------------------------------------
        ThreadHandler implementation
 ---------------------------------------------------------------------------*/

ThreadHandler::ThreadHandler()
        : m_hThread(NULL),
        m_hwndHidden(NULL),
        m_cRef(1)
{
}

ThreadHandler::~ThreadHandler()
{
    if ( NULL != m_hThread ) {
        VERIFY( ::CloseHandle( m_hThread ));
        m_hThread = NULL;
    }
}

IMPLEMENT_ADDREF_RELEASE(ThreadHandler)

STDMETHODIMP ThreadHandler::QueryInterface(REFIID iid,void **ppv)
{ 
        *ppv = 0; 
        if (iid == IID_IUnknown)
                *ppv = (IUnknown *) this;
        else if (iid == IID_ITFSThreadHandler)
                *ppv = (ITFSThreadHandler *) this; 
        else
                return ResultFromScode(E_NOINTERFACE);
        
        ((IUnknown *) *ppv)->AddRef(); 
        return hrOK;
}



/*!--------------------------------------------------------------------------
        ThreadHandler::StartBackgroundThread
                -
        Author: 
 ---------------------------------------------------------------------------*/
BOOL
ThreadHandler::StartBackgroundThread(ITFSNode * pNode, HWND hWndHidden, ITFSQueryObject *pQuery)
{
        CQueryObject *  pquery = NULL;
        HRESULT         hr = hrOK;
        BOOL            bRes = TRUE;
        CBackgroundThread *     pThread;
        
        // Store the node pointer
        this->m_spNode.Set(pNode);
        
        // Get the data for the hidden window
        m_hwndHidden = hWndHidden;
        Assert(m_hwndHidden);
        Assert(::IsWindow(m_hwndHidden));

        // First create the thread object (it hasn't started yet)
        pThread = CreateThreadObject();
        ASSERT(pThread != NULL);

        // Now that we have everything allocated, register ourselves for msgs
        m_uMsgBase = (INT)::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, TRUE, 0);
        Assert(m_uMsgBase);

        // Initialize and setup the query object
        CORg( pQuery->Init(this, m_hwndHidden, m_uMsgBase) );

        pThread->SetQueryObj(pQuery);
        m_spQuery.Set(pQuery);

        // phew, now start the thread
        bRes = pThread->Start();
        if (bRes)
    {
                if (pThread->m_hThread)
        {
            HANDLE hPseudohandle;

            hPseudohandle = pThread->m_hThread;
            if ( NULL != m_hThread ) {
                VERIFY( ::CloseHandle( m_hThread ));
                m_hThread = NULL;
            }
            BOOL bRet = DuplicateHandle(GetCurrentProcess(), 
                                        hPseudohandle,
                                        GetCurrentProcess(),
                                        &m_hThread,
                                        SYNCHRONIZE,
                                        FALSE,
                                        DUPLICATE_SAME_ACCESS);
                    if (!bRet)
                    {
                            DWORD dwLastErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwLastErr);
                    }
            
            // NOTE:::  ericdav 10/23/97
            // the thread is initially suspended so we can duplicate the handle
            // if the query object exits very quickly, the background thread object
            // may be destroyed before we can duplicate the handle.
            pThread->ResumeThread();
        }
        else
        {
            m_hThread = NULL;
        }
    }

Error:
        if (FHrFailed(hr) || (bRes == FALSE))
        {
                // Need to do some cleanup
                
                ReleaseThreadHandler();
                
                delete pThread;
                
                bRes = FALSE;
        }
        return bRes;
}

/*!--------------------------------------------------------------------------
        ThreadHandler::ReleaseThreadHandler
                -
        Author: 
 ---------------------------------------------------------------------------*/
void ThreadHandler::ReleaseThreadHandler()
{
        if (m_hwndHidden)
        {
                Assert(m_uMsgBase);
                ::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, FALSE, m_uMsgBase);
                m_hwndHidden = NULL;
                m_uMsgBase = 0;
        }
        
        if (m_spQuery)
        {
                // Signal the thread to abort
                m_spQuery->SetAbortEvent();
                m_spQuery.Release();
        }

        if (m_spNode)
        {
                m_spNode.Release();
        }

//  Trace1("%X ReleaseThreadHandler() called\n", GetCurrentThreadId());
}

void ThreadHandler::WaitForThreadToExit()
{
        //$ Review: kennt, should this be INFINITE?
        // Ok, wait for 5 seconds, else just shutdown
        // If we return, we can't do anything about the return value anyway
        if (m_hThread)
    {
            if (WaitForSingleObjectEx(m_hThread, 10000, FALSE) != WAIT_OBJECT_0)
        {
//              Trace1("%X WaitForThreadToExit() Wait failed! \n", GetCurrentThreadId());
        }
        
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }
}


CBackgroundThread* ThreadHandler::CreateThreadObject()
{ 
        return new CBackgroundThread; // override if need derived tipe of object
}

DEBUG_DECLARE_INSTANCE_COUNTER(CHandler);

/*---------------------------------------------------------------------------
        CHandler implementation
 ---------------------------------------------------------------------------*/
CHandler::CHandler(ITFSComponentData *pTFSCompData)
    : CBaseHandler(pTFSCompData),
          CBaseResultHandler(pTFSCompData),
      m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CHandler);

        m_nLockCount = 0;
        m_nState = 0;
        m_dwErr = 0;

        m_bExpanded = FALSE;
}

CHandler::~CHandler()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CHandler);

        Assert(m_nLockCount == 0);
}

IMPLEMENT_ADDREF_RELEASE(CHandler)

STDMETHODIMP CHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    // Is the pointer bad?
    if (ppv == NULL)
                return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
                *ppv = (LPVOID) this;
        else if (riid == IID_ITFSResultHandler)
                *ppv = (ITFSResultHandler *) this;
        else if (riid == IID_ITFSNodeHandler)
                *ppv = (ITFSNodeHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
                ((LPUNKNOWN) *ppv)->AddRef();
                return hrOK;
        }
    else
                return E_NOINTERFACE;
}

void 
CHandler::Lock() 
{ 
        InterlockedIncrement(&m_nLockCount);
}

void 
CHandler::Unlock() 
{ 
        InterlockedDecrement(&m_nLockCount);
}

/*!--------------------------------------------------------------------------
        CHandler::UserNotify
                Implememntation of ITFSNodeHandler::UserNotify
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CHandler::UserNotify
(
        ITFSNode *      pNode, 
        LPARAM          dwParam1, 
        LPARAM          dwParam2
)
{
        HRESULT hr = hrOK;

        switch (dwParam1)
        {
                case TFS_MSG_CREATEPROPSHEET:
                {
                        CPropertyPageHolderBase * pPropSheet = 
                                reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
                        AddPropSheet(pPropSheet);
                }
                        break;

                case TFS_MSG_DELETEPROPSHEET:
                {
                        CPropertyPageHolderBase * pPropSheet = 
                                reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
                        RemovePropSheet(pPropSheet);
                }
                        break;

                default:
                        Panic1("Alert the troops!: invalid arg(%d) to CHandler::UserNotify\n",
                                   dwParam1);                   
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CHandler::UserResultNotify
                Implememntation of ITFSResultHandler::UserResultNotify
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CHandler::UserResultNotify
(
        ITFSNode *      pNode, 
        LONG_PTR                dwParam1, 
        LONG_PTR                dwParam2
)
{
        HRESULT hr = hrOK;

        switch (dwParam1)
        {
                case TFS_MSG_CREATEPROPSHEET:
                {
                        CPropertyPageHolderBase * pPropSheet = 
                                reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
                        AddPropSheet(pPropSheet);
                }
                        break;
                
                case TFS_MSG_DELETEPROPSHEET:
                {
                        CPropertyPageHolderBase * pPropSheet = 
                                reinterpret_cast<CPropertyPageHolderBase *>(dwParam2);
                        RemovePropSheet(pPropSheet);
                }
                        break;

                default:
                        Panic1("Alert the troops!: invalid arg(%d) to CHandler::UserResultNotify\n",
                                   dwParam1);                   
                        break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CHandler::DestroyPropSheets
                Implememntation of DestroyPropSheets
        Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::DestroyPropSheets()
{

    //  Trace1("CHandler destructor - hander has %d prop sheets active\n", m_listPropSheets.GetCount());
    while (!m_listPropSheets.IsEmpty())
    {
        // This handler still has some prop sheets up.
        // Destroy them before we go away.
        CPropertyPageHolderBase * pPropSheet;

        pPropSheet = m_listPropSheets.RemoveHead();
        pPropSheet->ForceDestroy();

    } // while

    return hrOK;
} // CHandler::DestroyPropSheets()


/*!--------------------------------------------------------------------------
        CHandler::HasPropSheets
                Implememntation of CHandler::HasPropSheets
                returns the # of prop sheets this node has open
        Author: EricDav
 ---------------------------------------------------------------------------*/
int
CHandler::HasPropSheetsOpen()
{
        return (int)m_listPropSheets.GetCount();
}

/*!--------------------------------------------------------------------------
        CHandler::GetPropSheet
                Implememntation of CHandler::GetPropSheet
                returns the CPropPageHolderBase of the given index # (zero based)
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::GetOpenPropSheet
(
        int                                                nIndex,
        CPropertyPageHolderBase ** ppPropSheet
)
{
        HRESULT hr = hrOK;

        if (ppPropSheet)
        {
                POSITION pos = m_listPropSheets.FindIndex(nIndex);
                *ppPropSheet = m_listPropSheets.GetAt(pos);
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CHandler::AddPropSheet
                Implememntation of CHandler::AddPropSheet
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::AddPropSheet
(
        CPropertyPageHolderBase * pPropSheet
)
{
        HRESULT hr = hrOK;

        m_listPropSheets.AddTail(pPropSheet);
//  Trace1("CHandler::AddPropSheet - Added page holder %lx\n", pPropSheet);

        return hr;
}

/*!--------------------------------------------------------------------------
        CHandler::RemovePropSheet
                Implememntation of CHandler::RemovePropSheet
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::RemovePropSheet
(
        CPropertyPageHolderBase * pPropSheet
)
{
        HRESULT hr = hrOK;

        POSITION pos = m_listPropSheets.Find(pPropSheet);
        if (pos)
        {
                m_listPropSheets.RemoveAt(pos);
        }
//      else
//      {
//              // prop sheet is not in the list
//              Trace0("CHandler::RemovePropSheet - prop page holder not in list!\n");
//              Assert(FALSE);
//      }

        return hr;
}


/*!--------------------------------------------------------------------------
        CHandler::OnRefresh
                Default implementation for the refresh functionality
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CHandler::OnRefresh
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg,
        LPARAM                  param
)
{
/*
        pNode->DeleteAllChildren();
        Assert(GetChildCount() == 0);
        
        OnEnumerate(pComponentData, pDataObject, bExtension);
        
        AddCurrentChildrenToUI(pComponentData);
*/
    return hrOK;
}

/*!--------------------------------------------------------------------------
        CHandler::BuildSelectedItemList
                Builds a list of selected items in the result pane (can't do 
                multiple selection in the scope pane).
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::BuildSelectedItemList
(
        ITFSComponent * pComponent, 
        CTFSNodeList *  plistSelectedItems
)
{
        RESULTDATAITEM resultDataItem;
        HRESULT hr = hrOK;

        ZeroMemory(&resultDataItem, sizeof(resultDataItem));
        resultDataItem.nState = LVIS_SELECTED;
        resultDataItem.nIndex = -1;
        
        CTFSNodeList listSelectedNodes;
        
    SPIResultData spResultData;

    CORg ( pComponent->GetResultData(&spResultData) );

        //
        // Loop through and build a list of all selected items
        //
        while (TRUE)
        {
                //
                // Gets the Selected items ID
                //
                resultDataItem.mask = RDI_STATE;
                CORg (spResultData->GetNextItem(&resultDataItem)); 
        if (hr == S_FALSE)
                        break;
                
                //
                // Now get the items lparam
                //
                //resultDataItem.mask = RDI_PARAM;
                //CORg (spResultData->GetItem(&resultDataItem));

                ITFSNode * pNode;
                pNode = reinterpret_cast<ITFSNode *>(resultDataItem.lParam);
                Assert(pNode != NULL);

                pNode->AddRef();

                plistSelectedItems->AddTail(pNode);
        }

Error:
        return hr;
}

/*!--------------------------------------------------------------------------
        CHandler::BuildVirtualSelectedItemList
                Builds a list of selected items in the result pane (can't do 
                multiple selection in the scope pane).
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CHandler::BuildVirtualSelectedItemList
(
        ITFSComponent *         pComponent, 
        CVirtualIndexArray *    parraySelectedItems
)
{
        RESULTDATAITEM resultDataItem;
        HRESULT hr = hrOK;

        ZeroMemory(&resultDataItem, sizeof(resultDataItem));
        resultDataItem.nState = LVIS_SELECTED;
        resultDataItem.nIndex = -1;
        
    SPIResultData spResultData;

    CORg ( pComponent->GetResultData(&spResultData) );

        //
        // Loop through and build a list of all selected items
        //
        while (TRUE)
        {
                //
                // Gets the Selected items ID
                //
                resultDataItem.mask = RDI_STATE;
                CORg (spResultData->GetNextItem(&resultDataItem)); 
        if (hr == S_FALSE)
                        break;
                
                //
                // The index of the selected item is in the resultDataItem struct
                //
                parraySelectedItems->Add(resultDataItem.nIndex);
        }

Error:
        return hr;
}

DEBUG_DECLARE_INSTANCE_COUNTER(CMTHandler);

/*---------------------------------------------------------------------------
        CMTHandler implementation
 ---------------------------------------------------------------------------*/
CMTHandler::CMTHandler(ITFSComponentData *pTFSCompData)
    : CHandler(pTFSCompData),
          m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CMTHandler);
}

CMTHandler::~CMTHandler()
{
        DEBUG_DECREMENT_INSTANCE_COUNTER(CMTHandler);
}

IMPLEMENT_ADDREF_RELEASE(CMTHandler)

STDMETHODIMP CMTHandler::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
    // Is the pointer bad?
    if (ppv == NULL)
                return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
                *ppv = (LPVOID) this;
        else if (riid == IID_ITFSResultHandler)
                *ppv = (ITFSResultHandler *) this;
        else if (riid == IID_ITFSNodeHandler)
                *ppv = (ITFSNodeHandler *) this;
        else if (riid == IID_ITFSThreadHandler)
                *ppv = (ITFSThreadHandler *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
        {
                ((LPUNKNOWN) *ppv)->AddRef();
                return hrOK;
        }
    else
                return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
        CMTHandler::DestoryHandler
                This gets called when the node for this handler is told to destroy.
                Free up anything we may be holding onto here.
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTHandler::DestroyHandler(ITFSNode *pNode)
{
        ReleaseThreadHandler();
        WaitForThreadToExit();

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CMTHandler::OnExpand
                Default implementation for the refresh functionality
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnExpand
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT                         hr = hrOK;
        SPITFSNode                      spNode;
        SPITFSNodeHandler       spHandler;
        ITFSQueryObject *       pQuery = NULL;
        
        if (m_bExpanded)
        {
                return hr;
        }

        Lock();

        OnChangeState(pNode);

        pQuery = OnCreateQuery(pNode);
        Assert(pQuery);

        // notify the UI to change icon, if needed
        //Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

        Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
        
        pQuery->Release();

        m_bExpanded = TRUE;

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CMTHandler::OnRefresh
                Default implementation for the refresh functionality
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnRefresh
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg,
        LPARAM                  param
)
{
        HRESULT hr = hrOK;

    if (m_bExpanded == FALSE)
    {
        // we cannot refresh/add items to a node that hasn't been expanded yet.
        return hr;
    }

    BOOL bLocked = IsLocked();
        if (bLocked)
    {
        // cannot do refresh on locked node, the UI should prevent this
                return hr; 
    }
        
    pNode->DeleteAllChildren(TRUE);

        int nVisible, nTotal;
        pNode->GetChildCount(&nVisible, &nTotal);
        Assert(nVisible == 0);
        Assert(nTotal == 0);
        
        m_bExpanded = FALSE;
        OnExpand(pNode, pDataObject, dwType, arg, param); // will spawn a thread to do enumeration

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTHandler::OnNotifyError
                Implementation of ThreadHandler::OnNotifyError
        Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyError
(
        LPARAM                  lParam
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        OnError((DWORD) lParam);
    }
    COM_PROTECT_CATCH

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CMTHandler::OnNotifyHaveData
                -
        Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyHaveData
(
        LPARAM                  lParam
)
{
        // For these nodes, assume that the lParam is a CNodeQueryObject *
        CNodeQueryObject *  pQuery;
        LPQUEUEDATA         pQD;
    ITFSNode *          p;
    HRESULT             hr = hrOK;

    COM_PROTECT_TRY
    {
        pQuery = (CNodeQueryObject *) lParam;
            Assert(pQuery);

        if (pQuery)
            pQuery->AddRef();

            while (pQD = pQuery->RemoveFromQueue())
            {
                    if (pQD->Type == QDATA_PNODE)
                    {
                            // this is the normal case.  The handler just expects nodes
                            // to be handed back from the background thread
                            p = reinterpret_cast<ITFSNode *>(pQD->Data);
                            OnHaveData(m_spNode, p);
                            p->Release();
                    }
                    else
                    {
                            // custom case here.  The user provided their own data 
                            // type.  Call the appropriate hander for this.
                            OnHaveData(m_spNode, pQD->Data, pQD->Type);
                    }

                    delete pQD;
            }

        if (pQuery)
            pQuery->Release();
    }
    COM_PROTECT_CATCH

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CMTHandler::OnNotifyExiting
                Implementation of ThreadHandler::OnNotifyExiting
        Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
CMTHandler::OnNotifyExiting
(
        LPARAM                  lParam
)
{
        CNodeQueryObject *  pQuery;
        HRESULT             hr = hrOK;

    COM_PROTECT_TRY
    {
        pQuery = (CNodeQueryObject *) lParam;
            Assert(pQuery);

        if (pQuery)
            pQuery->AddRef();

        OnChangeState(m_spNode);

            ReleaseThreadHandler();

            Unlock();

        if (pQuery)
            pQuery->Release();
    }
    COM_PROTECT_CATCH

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\dynext.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    dynext.cpp
	    dynamic extension helper

    FILE HISTORY:
	
*/

#include "stdafx.h"
#include "Dynext.h"
#include "tregkey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
const TCHAR g_szNameSpace[] = TEXT("NameSpace");
const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
const TCHAR g_szToolbar[] = TEXT("Toolbar");
const TCHAR g_szExtensions[] = TEXT("Extensions");
const TCHAR g_szTask[] = TEXT("Task");
const TCHAR g_szDynamicExtensions[] = TEXT("Dynamic Extensions");

const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");


CDynamicExtensions::CDynamicExtensions()
{
    m_bLoaded = FALSE;
}

CDynamicExtensions::~CDynamicExtensions()
{
}

HRESULT 
CDynamicExtensions::SetNode(const GUID * guid)
{
    m_guidNode = *guid;

    return hrOK;
}

HRESULT 
CDynamicExtensions::Reset()
{
    HRESULT hr = hrOK;

    m_aNameSpace.RemoveAll();
    m_aMenu.RemoveAll();
    m_aToolbar.RemoveAll();
    m_aPropSheet.RemoveAll();
    m_aTask.RemoveAll();

    m_bLoaded = FALSE;

    return hr;
}

HRESULT 
CDynamicExtensions::Load()
{
    HRESULT     hr = hrOK;
    LONG        lRes;
    CGUIDArray  aDynExtensions;

    Reset();

	OLECHAR szGuid[128] = {0};
	::StringFromGUID2(m_guidNode, szGuid, 128);

	RegKey regkeyNodeTypes;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY, KEY_READ);
	Assert(lRes == ERROR_SUCCESS);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	RegKey regkeyNode;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyNode.Open(regkeyNodeTypes, szGuid, KEY_READ);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

	// open the key for dynamic extensions and enumerate
    RegKey regkeyDynExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyDynExt.Open(regkeyNode, g_szDynamicExtensions, KEY_READ);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

    RegKey regkeyExtensions;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyExtensions.Open(regkeyNode, g_szExtensions, KEY_READ);
	if (lRes != ERROR_SUCCESS)
	{
		return HRESULT_FROM_WIN32(lRes); // failed to open
	}

    CString strKey;
    RegValueIterator iterDynExt;
    iterDynExt.Init(&regkeyDynExt);
    
    while (iterDynExt.Next(&strKey, NULL) == hrOK)
    {
        GUID guid;

        ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
        if (!aDynExtensions.IsInList(guid))
            aDynExtensions.Add(guid);
    }

    // ok, have the list of dynamic extensions, now enumerate the various extension types

    // namespace extensions
    RegKey regkeyNSExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyNSExt.Open(regkeyExtensions, g_szNameSpace, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterNSExt;
        iterNSExt.Init(&regkeyNSExt);

        while (iterNSExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aNameSpace.Add(guid);
        }
    }

    // Menu extensions
    RegKey regkeyMenuExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyMenuExt.Open(regkeyExtensions, g_szContextMenu, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterMenuExt;
        iterMenuExt.Init(&regkeyMenuExt);

        while (iterMenuExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aMenu.Add(guid);
        }
    }

    // toolbar extensions
    RegKey regkeyToolbarExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyToolbarExt.Open(regkeyExtensions, g_szToolbar, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterToolbarExt;
        iterToolbarExt.Init(&regkeyToolbarExt);

        while (iterToolbarExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aToolbar.Add(guid);
        }
    }

    // PropPage extensions
    RegKey regkeyPSExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyPSExt.Open(regkeyExtensions, g_szPropertySheet, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterPSExt;
        iterPSExt.Init(&regkeyPSExt);

        while (iterPSExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aPropSheet.Add(guid);
        }
    }

    // taskpad extensions
    RegKey regkeyTaskExt;
	// Change by kmurthy: Instead of default, now open for Read
	lRes = regkeyTaskExt.Open(regkeyExtensions, g_szTask, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
        // enumerate the ns dynamic extensions
        RegValueIterator iterTaskExt;
        iterTaskExt.Init(&regkeyTaskExt);

        while (iterTaskExt.Next(&strKey, NULL) == hrOK)
        {
            GUID guid;

            ::CLSIDFromString(((LPTSTR) (LPCTSTR) strKey), &guid); 
            if (aDynExtensions.IsInList(guid))
                m_aTask.Add(guid);
        }
    }

    m_bLoaded = TRUE;

    return hr;
}

HRESULT 
CDynamicExtensions::GetNamespaceExtensions(CGUIDArray & aGuids)
{
    HRESULT hr = hrOK;

    aGuids.Copy(m_aNameSpace);

    return hr;
}

HRESULT 
CDynamicExtensions::BuildMMCObjectTypes(HGLOBAL * phGlobal)
{
    HRESULT hr = hrOK;
    HGLOBAL hGlobal = NULL;
    SMMCDynamicExtensions * pDynExt = NULL;
    
    if (phGlobal)
        *phGlobal = NULL;

    COM_PROTECT_TRY
    {
        int i;
        CGUIDArray aOtherDynExt;

        // build our main list of other extension types 
        // other means everything except namespace
        for (i = 0; i < m_aMenu.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aMenu[i]))
                aOtherDynExt.Add(m_aMenu[i]);
        }

        for (i = 0; i < m_aToolbar.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aToolbar[i]))
                aOtherDynExt.Add(m_aToolbar[i]);
        }
        
        for (i = 0; i < m_aPropSheet.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aPropSheet[i]))
                aOtherDynExt.Add(m_aPropSheet[i]);
        }

        for (i = 0; i < m_aTask.GetSize(); i++)
        {
            if (!aOtherDynExt.IsInList(m_aTask[i]))
                aOtherDynExt.Add(m_aTask[i]);
        }

        int nCount = (int)aOtherDynExt.GetSize();
        hGlobal = (SMMCDynamicExtensions *) ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, 
                                                sizeof(SMMCDynamicExtensions) + (nCount * sizeof(GUID)));
        pDynExt = reinterpret_cast<SMMCDynamicExtensions*>(::GlobalLock(hGlobal));
        if (!pDynExt)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    
        ZeroMemory(pDynExt, sizeof(SMMCDynamicExtensions) + (nCount * sizeof(GUID)));

        // now build the real struct
        pDynExt->count = nCount;
        for (i = 0; i < nCount; i++)
        {
            pDynExt->guid[i] = aOtherDynExt[i];
        }

        ::GlobalUnlock(hGlobal);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH
    
    if (SUCCEEDED(hr) && phGlobal)
        *phGlobal = hGlobal;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\handlers.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    handlers.h
        Prototypes for the various handlers

    FILE HISTORY:
        
*/

#ifndef _HANDLERS_H
#define _HANDLERS_H

#ifndef _BASEHAND_H
#include "basehand.h"
#endif

#ifndef _QUERYOBJ_H
#include "queryobj.h"
#endif

#ifndef _PROPPAGE_H
#include "proppage.h"
#endif
 
typedef CArray<int, int> CVirtualIndexArray;

/*---------------------------------------------------------------------------
	Class: ThreadHandler

	This is an abstract base class that anyone who wants to run a
	background thread needs to implement (if they use the hidden window
	mechanism that is).

	This is the class that does all of the background thread management.

	Author: kennt
 ---------------------------------------------------------------------------*/
class ThreadHandler :
   public ITFSThreadHandler
{
public:
	ThreadHandler();
	~ThreadHandler();

	DeclareIUnknownMembers(IMPL)

	// Derived classes should implement this
	DeclareITFSThreadHandlerMembers(PURE)
	
	// Thread management functions
	BOOL	StartBackgroundThread(ITFSNode * pNode, HWND hWndHidden, ITFSQueryObject *pQuery);

	void	WaitForThreadToExit();
	void	ReleaseThreadHandler();
		
protected:
	// override for custom thread creation
	virtual CBackgroundThread* CreateThreadObject();
	
	SPITFSQueryObject	m_spQuery;
	SPITFSNode			m_spNode;
	HWND				m_hwndHidden;		// handle to window to post to
	UINT				m_uMsgBase;
	HANDLE				m_hThread;
	long				m_cRef;
};

typedef CList <CPropertyPageHolderBase *, CPropertyPageHolderBase *> CPropSheetListBase;


/*---------------------------------------------------------------------------
	Class:	CHandler
 ---------------------------------------------------------------------------*/
class CHandler :
		public CBaseHandler,
		public CBaseResultHandler
{
public:
	CHandler(ITFSComponentData *pTFSCompData);
	virtual ~CHandler();

	DeclareIUnknownMembers(IMPL)

	virtual HRESULT OnExpand(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM) { m_bExpanded = TRUE; return hrOK; }

	void Lock();
	void Unlock();
	BOOL IsLocked() { return m_nLockCount > 0;}

	OVERRIDE_NodeHandler_UserNotify();
	OVERRIDE_NodeHandler_DestroyHandler()
			{ return DestroyPropSheets(); }
	OVERRIDE_ResultHandler_UserResultNotify();
	OVERRIDE_ResultHandler_DestroyResultHandler()
			{ return DestroyPropSheets(); }

	// public helpers
	int		HasPropSheetsOpen();
	HRESULT GetOpenPropSheet(int nIndex, CPropertyPageHolderBase ** ppPropSheet);

	virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

protected:
	HRESULT BuildSelectedItemList(ITFSComponent * pComponent, CTFSNodeList * plistSelectedItems);
    HRESULT BuildVirtualSelectedItemList(ITFSComponent * pComponent, CVirtualIndexArray * parraySelectedItems);
    HRESULT RemovePropSheet(CPropertyPageHolderBase * pPageHolder);
	HRESULT AddPropSheet(CPropertyPageHolderBase * pPageHolder);
	HRESULT DestroyPropSheets();

public:
	int		m_nState;		// for general purpose finite state machine implementation
	DWORD	m_dwErr;	// for general purpose error handling
	LONG	m_nLockCount;	// keeps track if a node has been locked (e.g. to spin a thread, etc.)
	BOOL    m_bExpanded;    // whether or not this node has been expanded yet

protected:
   	LONG				m_cRef;
	CPropSheetListBase	m_listPropSheets;
};

/*---------------------------------------------------------------------------
	Class:	CMTHander
 ---------------------------------------------------------------------------*/
class CMTHandler :
	public CHandler,
	public ThreadHandler
{
public:
	CMTHandler(ITFSComponentData *pTFSCompData);
	virtual ~CMTHandler();

    DeclareIUnknownMembers(IMPL)

	STDMETHOD (DestroyHandler) (ITFSNode *pNode);

	virtual HRESULT OnExpand(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

	// query creation - override to create a user-specific query object
	virtual ITFSQueryObject* OnCreateQuery(ITFSNode *pNode) = 0;

	virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

protected:
	virtual int		GetImageIndex(BOOL bOpenIndex) { return -1; }
	
	// the next 3 functions are background thread notification callbacks
	// these override the ThreadHandler::OnNotifyXXX functions
	DeclareITFSThreadHandlerMembers(IMPL)

	virtual void OnChangeState(ITFSNode * pNode) {}
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode) = 0;
	virtual void OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type) { };
	virtual void OnError(DWORD dwErr) { m_dwErr = dwErr; }

protected:
  	LONG		m_cRef;

private:
//	friend class CHiddenWnd;			// to get OnThreadNotification()
};

#endif _HANDLERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\intltime.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include <string.h>

#include "dbgutil.h"
#include "objplus.h"
#include "intltime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// FormatDateTime
//
//  Generates a current local date/time string
//
//
/////////////////////////////////////////////////////////////////////////////
void
InternalFormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate)
{
    int     nLen;
    CString strDate, strTime;
    DWORD   dwFlags = 0;
    
    dwFlags = fLongDate ? DATE_LONGDATE : DATE_SHORTDATE;

    // call once to get the length, and again to format the string
    nLen = GetDateFormat(GetThreadLocale(), dwFlags, psystemtime, NULL, NULL, 0);
    nLen = GetDateFormat(GetThreadLocale(), dwFlags, psystemtime, NULL, strDate.GetBuffer(nLen + 1), nLen + 1);
    strDate.ReleaseBuffer();

    // now the time
    nLen = GetTimeFormat(GetThreadLocale(), 0, psystemtime, NULL, NULL, 0);
    nLen = GetTimeFormat(GetThreadLocale(), 0, psystemtime, NULL, strTime.GetBuffer(nLen + 1), nLen + 1);
    strTime.ReleaseBuffer();

    strOutput = strDate + _T(" ") + strTime;
}

void
FormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate)
{
    InternalFormatDateTime(strOutput, psystemtime, fLongDate);
}

void
FormatDateTime(CString & strOutput, FILETIME * pfiletime, BOOL fLongDate)
{
    FILETIME    localTime;
    SYSTEMTIME  systemtime;

	if (!FileTimeToLocalFileTime(pfiletime, &localTime))
	{
		return;
	}

    if (!FileTimeToSystemTime(&localTime, &systemtime))
    {
        return;
    }

    InternalFormatDateTime(strOutput, &systemtime, fLongDate);
}

void
FormatDateTime(CString & strOutput, CTime & time, BOOL fLongDate)
{
    SYSTEMTIME systemtime;
    struct tm * ptm = time.GetLocalTm(NULL);

    if (ptm != NULL)
    {
	    systemtime.wYear = (WORD) (1900 + ptm->tm_year);
	    systemtime.wMonth = (WORD) (1 + ptm->tm_mon);
	    systemtime.wDayOfWeek = (WORD) ptm->tm_wday;
	    systemtime.wDay = (WORD) ptm->tm_mday;
	    systemtime.wHour = (WORD) ptm->tm_hour;
	    systemtime.wMinute = (WORD) ptm->tm_min;
	    systemtime.wSecond = (WORD) ptm->tm_sec;
	    systemtime.wMilliseconds = 0;

        InternalFormatDateTime(strOutput, &systemtime, fLongDate);
    }
    else
    {
        strOutput.Empty();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CIntlTime
//
//          These allocations cause a phoney "memory leak" error, since
//          they're not freed until after the audit-check.  Anyway
//          around this?
//
/////////////////////////////////////////////////////////////////////////////

// Initialise static members
CIntlTime::INTL_TIME_SETTINGS CIntlTime::m_itsInternationalSettings;
BOOL CIntlTime::m_fIntlOk = CIntlTime::SetIntlTimeSettings();
CString CIntlTime::m_strBadDate("--");
CString CIntlTime::m_strBadTime("--");

/***
 *
 *  CIntlTime::SetIntlTimeSettings
 *
 *  Purpose:
 *
 *      This is a static function which initialises the international
 *      settings (date seperator, etc) of the CIntlTime class.
 *
 *  Returns:
 *
 *      TRUE if the international settings are properly initialised,
 *      or FALSE if they are not.
 *
 */
BOOL CIntlTime::SetIntlTimeSettings ()
{
#ifdef _WIN32
    #define MAXSTR 128

    BOOL fOk;
    TCHAR str[MAXSTR];

    #define GETCSTRINGFIELD(field,cstring)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, cstring.GetBuffer(MAXSTR), MAXSTR);\
         cstring.ReleaseBuffer()
    #define GETINTFIELD(field, integer)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, str, MAXSTR);\
         integer = _ttol(str)
    #define GETBOOLFIELD(field, boolean)\
         ::GetLocaleInfo(GetUserDefaultLCID(), field, str, MAXSTR);\
         boolean=*str == '1'

    fOk = GETCSTRINGFIELD(LOCALE_SDATE, CIntlTime::m_itsInternationalSettings.strDateSeperator);
    fOk &= GETCSTRINGFIELD(LOCALE_STIME, CIntlTime::m_itsInternationalSettings.strTimeSeperator);
    fOk &= GETINTFIELD(LOCALE_IDATE, CIntlTime::m_itsInternationalSettings.nDateFormat);
    ASSERT((CIntlTime::m_itsInternationalSettings.nDateFormat >= 0) && (CIntlTime::m_itsInternationalSettings.nDateFormat <= 2));
    fOk &= GETBOOLFIELD(LOCALE_ITIME, CIntlTime::m_itsInternationalSettings.f24HourClock);
    fOk &= GETBOOLFIELD(LOCALE_ICENTURY, CIntlTime::m_itsInternationalSettings.fCentury);
    fOk &= GETBOOLFIELD(LOCALE_ITLZERO, CIntlTime::m_itsInternationalSettings.fLeadingTimeZero);
    fOk &= GETBOOLFIELD(LOCALE_IDAYLZERO, CIntlTime::m_itsInternationalSettings.fLeadingDayZero);
    fOk &= GETBOOLFIELD(LOCALE_IMONLZERO, CIntlTime::m_itsInternationalSettings.fLeadingMonthZero);
    if (CIntlTime::m_itsInternationalSettings.f24HourClock)
    {
        CIntlTime::m_itsInternationalSettings.strAM = "";
        CIntlTime::m_itsInternationalSettings.strPM = "";
    }
    else
    {
        fOk &= GETCSTRINGFIELD(LOCALE_S1159, CIntlTime::m_itsInternationalSettings.strAM);
        fOk &= GETCSTRINGFIELD(LOCALE_S2359, CIntlTime::m_itsInternationalSettings.strPM);
    }

#ifdef _DEBUG
    if (!fOk)
    {
        Trace0("There was a problem with some of the intl time settings\n");
    }
#endif // _DEBUG

    return(fOk);

#endif // _WIN32

#ifdef _WIN16

    #define MAXSTR 128

    CString strMisc;

    #define GETCSTRINGFIELD(field,cstring,defstring)\
        ::GetProfileString("Intl", field, defstring, cstring.GetBuffer(MAXSTR), MAXSTR);\
        cstring.ReleaseBuffer()
    #define GETINTFIELD(field, integer, defint)\
        integer = ::GetProfileInt("Intl", field, defint)
    #define GETBOOLFIELD(field, boolean, defint)\
        boolean = ::GetProfileInt("Intl", field, defint)==1

    // Get the values.  Assume American defaults in case of failure.

    GETCSTRINGFIELD("sDate", CIntlTime::m_itsInternationalSettings.strDateSeperator, "/");
    GETCSTRINGFIELD("sTime", CIntlTime::m_itsInternationalSettings.strTimeSeperator, ":");
    GETINTFIELD("iDate", CIntlTime::m_itsInternationalSettings.nDateFormat, 0);
    ASSERT((CIntlTime::m_itsInternationalSettings.nDateFormat >= 0) && (CIntlTime::m_itsInternationalSettings.nDateFormat <= 2));
    GETBOOLFIELD("iTime", CIntlTime::m_itsInternationalSettings.f24HourClock, FALSE);
    GETBOOLFIELD("iTLZero", CIntlTime::m_itsInternationalSettings.fLeadingTimeZero, FALSE);
    if (CIntlTime::m_itsInternationalSettings.f24HourClock)
    {
        CIntlTime::m_itsInternationalSettings.strAM = "";
        CIntlTime::m_itsInternationalSettings.strPM = "";
    }
    else
    {
        GETCSTRINGFIELD("s1159", CIntlTime::m_itsInternationalSettings.strAM, "AM");
        GETCSTRINGFIELD("s2359", CIntlTime::m_itsInternationalSettings.strPM, "PM");
    }


    GETCSTRINGFIELD("sShortDate", strMisc, "M/d/yy");
    // These settings are determined from the short date sample, as
    // there is no direct equivalent in the win.ini
    CIntlTime::m_itsInternationalSettings.fCentury = strMisc.Find("yyyy") != -1;
    CIntlTime::m_itsInternationalSettings.fLeadingDayZero = strMisc.Find("dd") != -1;
    CIntlTime::m_itsInternationalSettings.fLeadingMonthZero = strMisc.Find("MM") != -1;

    return(TRUE);

#endif // _WIN16

}

/***
 *
 *  CIntlTime::Reset()
 *
 *  Purpose:
 *
 *      Reset the international settings. Usually in response to
 *      a change in those international settings by the user.
 *
 *  Notes:
 *
 *      This is a publically available static function.
 *
 */
void CIntlTime::Reset()
{
    CIntlTime::m_fIntlOk = CIntlTime::SetIntlTimeSettings();
}

/***
 *
 *  CIntlTime::IsLeapYear
 *
 *  Purpose:
 *
 *      Determine if the given year is/was a leap year
 *
 *  Arguments:
 *
 *      int nYear   The year in question.
 *
 *  Returns:
 *
 *      TRUE if the year is/was a leap year, or FALSE otherwise.
 *
 *  Comments:
 *
 *      A year is a leap year, if is divisible by 4, but not by a 100, unless
 *      it is divisible by 400. e.g. 1900 was not a leap year, but 2000 will
 *      be.
 *
 */
BOOL CIntlTime::IsLeapYear(UINT nYear)
{
    return(!(nYear % 4) && ( (nYear % 100) || !(nYear % 400) ));
}

/***
 *
 *  CIntlTime::IsValidDate
 *
 *  Purpose:
 *
 *      Determine if the given month, day year values are
 *      valid.
 *
 *  Arguments:
 *
 *      int nMonth      Month
 *      int nDay        Day
 *      int nYear       Year
 *
 *  Returns:
 *
 *      TRUE for a valid date, FALSE otherwise.
 *
 */
BOOL CIntlTime::IsValidDate(UINT nMonth, UINT nDay, UINT nYear)
{
    // Sanity Check:
    BOOL fOk = ((nYear <100) || (nYear >= 1970)) &&
                (nYear <= 2037)                  &&
               ((nMonth >= 1) && (nMonth <= 12)) &&
               ((nDay >= 1) && (nDay <= 31));

    // Detailed check of days per month
    if (fOk)
    {
        switch(nMonth)
        {
            case 1:
            case 3:
            case 5:
            case 7:
            case 8:
            case 10:
            case 12:
                break;
            case 4:
            case 6:
            case 9:
            case 11:
                fOk = (nDay <= 30);
                break;
            case 2:
                fOk = (nDay <= (UINT)(IsLeapYear(nYear) ? 29 : 28));
                break;
        }
    }

    return(fOk);
}

/***
 *
 *  CIntlTime::IsValidTime
 *
 *  Purpose:
 *
 *      Determine if the given hour, minute, second values
 *      valid.
 *
 *  Arguments:
 *
 *      int nHour       Hour
 *      int nMinute     Minute
 *      int nSecond     Second
 *
 *  Returns:
 *
 *      TRUE for a valid time, FALSE otherwise.
 *
 */

BOOL CIntlTime::IsValidTime(UINT nHour, UINT nMinute, UINT nSecond)
{
    return ((nHour < 24) && (nMinute < 60) && (nSecond < 60));
}

// Constructors.  m_fInitOk will indicate whether or not the object
// was succesfully constructed.  This can be checked at runtime by
// the IsValid() member function

CIntlTime::CIntlTime()
    :CTime()
{
    // Time set to 0, always bad.
    m_fInitOk = FALSE;
}

CIntlTime::CIntlTime(const CTime &timeSrc)
    :CTime(timeSrc)
{
    m_fInitOk = GetTime() > 0L;
}

CIntlTime::CIntlTime(time_t time)
    :CTime(time)
{
    m_fInitOk = (time > 0);
}

CIntlTime::CIntlTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec)
    :CTime(nYear, nMonth, nDay, nHour, nMin, nSec)
{
    m_fInitOk = IsValidDate(nMonth, nDay, nYear) && IsValidTime(nHour, nMin, nSec);
}

CIntlTime::CIntlTime(WORD wDosDate, WORD wDosTime)
    :CTime(wDosDate, wDosTime)
{
    m_fInitOk = GetTime() != 0L;
}

// Constructor taking a string as an argument. The string can contain
// either a time, a date or both.  If the string is missing the date,
// the current date will be filled in.  If the string is missing the time,
// the current time will be filled in.  As with all constructors, be
// sure the call IsValid() to determine proper contruction.

CIntlTime::CIntlTime(const CString & strTime, int nFormat, time_t * ptmOldValue)
    :CTime(ConvertFromString(strTime, nFormat, ptmOldValue,  &m_fInitOk))
{
}

CIntlTime::CIntlTime(const CIntlTime &timeSrc)
{
    CTime::operator=(timeSrc.GetTime());
    m_fInitOk = timeSrc.IsValid();
}

#ifdef _WIN32
CIntlTime::CIntlTime(const SYSTEMTIME& sysTime)
    : CTime(sysTime)
{
    m_fInitOk = IsValidDate((UINT)sysTime.wMonth, (UINT)sysTime.wDay, (UINT)sysTime.wYear)
             && IsValidTime((UINT)sysTime.wHour, (UINT)sysTime.wMinute, (UINT)sysTime.wSecond);
}

CIntlTime::CIntlTime(const FILETIME& fileTime)
    : CTime(fileTime)
{
    m_fInitOk = GetTime() != 0L;
}

#endif // _WIN32
// Desctructor
CIntlTime::~CIntlTime()
{
}

// Assignment operators.  As with constructors, be sure to check the
// IsValid() member function to determine succesfull assignment, as
// assignment operators do set the m_fInitOk member variable.

const CIntlTime& CIntlTime::operator =(const CString & strValue)
{
    time_t tmValue = ConvertFromString (strValue, CIntlTime::TFRQ_TIME_OR_DATE, NULL, &m_fInitOk);
    if (m_fInitOk)
    {
        CTime::operator=(tmValue);
    }
    return(*this);
}

// Assignment operator taking a time_t argument
const CIntlTime& CIntlTime::operator =(time_t tmValue)
{
    CTime::operator=(tmValue);
    m_fInitOk = (tmValue > 0);
    return(*this);
}

const CIntlTime& CIntlTime::operator =(const CTime & time)
{
    CTime::operator=(time.GetTime());
    m_fInitOk = (GetTime() > 0);
    return(*this);
}

const CIntlTime& CIntlTime::operator =(const CIntlTime & time)
{
    CTime::operator=(time.GetTime());
    m_fInitOk = (GetTime() > 0);
    return(*this);
}

// Conversion operators
CIntlTime::operator const time_t() const
{
    return(GetTime());
}

// Conversion operator that returns the date followed by the time
// in international format as a CString.

CIntlTime::operator const CString() const
{
    return(ConvertToString(TFRQ_TIME_AND_DATE));
}

CIntlTime::operator CString() const
{
    return(ConvertToString(TFRQ_TIME_AND_DATE));
}

/***
 *
 *  CIntlTime::GetDateString()
 *
 *  Purpose:
 *
 *      Represent the current date in a format consistent with the current
 *      international settings in a CString.
 *
 *  Returns:
 *
 *      A CString containing the date in string format, or "--" if
 *      the date is invalid.
 *
 */
const CString CIntlTime::GetDateString() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadDate);
    }

    TCHAR szPct02D[] = _T("%02d");
    TCHAR szPctD[] = _T("%d");
    TCHAR szDay[3], szMonth[16], szYear[8];
    TCHAR *first, *second, *third;
    int i;

    i = GetYear();
    if(!CIntlTime::m_itsInternationalSettings.fCentury)
    {
        i %= 100;
    }
    
    // fix year 2000 problem -- ericdav
    //::_itot(i, szYear, 10);
    ::wsprintf (szYear, szPct02D, i);
    ::wsprintf (szMonth, CIntlTime::m_itsInternationalSettings.fLeadingMonthZero
                         ? szPct02D : szPctD, GetMonth());
    ::wsprintf (szDay, CIntlTime::m_itsInternationalSettings.fLeadingDayZero
                         ? szPct02D : szPctD, GetDay());

    if (CIntlTime::m_itsInternationalSettings.nDateFormat == _DFMT_YMD)
    {
        first = szYear;
        second = szMonth;
        third = szDay;
    }
    else
    {
        third = szYear;
        if (CIntlTime::m_itsInternationalSettings.nDateFormat == _DFMT_DMY)
        {
            first = szDay;
            second = szMonth;
        }
        else
        {
            first = szMonth;
            second = szDay;
        }
    }
    ::wsprintf (strIntl.GetBuffer(80),
                        _T("%s%s%s%s%s"),
                        first,
                        (LPCTSTR)CIntlTime::m_itsInternationalSettings.strDateSeperator,
                        second,
                        (LPCTSTR)CIntlTime::m_itsInternationalSettings.strDateSeperator,
                        third);
    strIntl.ReleaseBuffer();

    return(strIntl);
}

/***
 *
 *  CIntlTime::GetTimeString()
 *
 *  Purpose:
 *
 *      Represent the current time in a format consistent with the current
 *      international settings in a CString.
 *
 *  Returns:
 *
 *      A CString containing the time in string format, or "--" if
 *      the time is invalid.
 *
 */
const CString CIntlTime::GetTimeString() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadTime);
    }

    int hour = GetHour();
    int minute = GetMinute();
    int second = GetSecond();

    // Set AM/PM depending on non-24 hour clock, and the time
    // of day.  Note: a space is prepended for readability.
    CString strAMPM(CIntlTime::m_itsInternationalSettings.f24HourClock
                    ? "" : " " + ((hour < 12)
                        ? CIntlTime::m_itsInternationalSettings.strAM
                        : CIntlTime::m_itsInternationalSettings.strPM)
                   );

    if ((!CIntlTime::m_itsInternationalSettings.f24HourClock) && (!(hour %= 12)))
    {
        hour = 12;
    }

    ::wsprintf (strIntl.GetBuffer(30), CIntlTime::m_itsInternationalSettings.fLeadingTimeZero
                ? _T("%02d%s%02d%s%02d%s") : _T("%d%s%02d%s%02d%s"),
                hour,
                (LPCTSTR)CIntlTime::m_itsInternationalSettings.strTimeSeperator,
                minute,
                (LPCTSTR)CIntlTime::m_itsInternationalSettings.strTimeSeperator,
                second,
                (LPCTSTR)strAMPM);

    strIntl.ReleaseBuffer();
    return(strIntl);
}

const CString CIntlTime::GetMilitaryTime() const
{
    CString strIntl;

    if (!IsValid())
    {
        return(CIntlTime::m_strBadTime);
    }

    int hour = GetHour();
    int minute = GetMinute();
    int second = GetSecond();

    ::wsprintf (strIntl.GetBuffer(30),
                _T("%02d:%02d:%02d"),
                hour,
                minute,
                second);

    strIntl.ReleaseBuffer();
    return(strIntl);
}

/***
 *
 *  CIntlTime::ConvertToString(int nFormat)
 *
 *  Purpose:
 *
 *      Convert the curent time/date to a string
 *
 *  Arguments:
 *
 *      int nFormat     Format request ID, can be one of the following
 *                      values (enumerated in CIntlTime):
 *
 *                      TFRQ_TIME_ONLY      Only give me the time.
 *                      TFRQ_DATE_ONLY      Only give me the date.
 *                      TFRQ_TIME_AND_DATE  Give me the time and the date.
 *
 *  Returns:
 *
 *      A CString containing the time and/or date in international format.
 *
 */
const CString CIntlTime::ConvertToString(int nFormat) const
{
    switch(nFormat)
    {
        case TFRQ_TIME_ONLY:
             return(GetTimeString());

        case TFRQ_DATE_ONLY:
            return(GetDateString());

        case TFRQ_TIME_AND_DATE:
            return(GetDateString() + CString(" ") + GetTimeString());

        case TFRQ_MILITARY_TIME:
            return(GetMilitaryTime());

        case TFRQ_TIME_OR_DATE:
        default:
            Trace1("Invalid time/date format code %d requested.\n", nFormat);
            return(CIntlTime::m_strBadDate);
    }
}

/***
 *
 *  CIntlTime::ConvertFromString
 *
 *  Purpose:
 *
 *      Convert a given CString into a time_t
 *
 *  Arguments:
 *
 *      const CString & str The string to convert
 *      int nFormat     Format request ID, can be one of the following
 *                      values (enumerated in CIntlTime):
 *
 *                      TFRQ_TIME_ONLY      Only give me the time.
 *                      TFRQ_DATE_ONLY      Only give me the date.
 *                      TFRQ_TIME_AND_DATE  Give me the time and the date.
 *                      TFRQ_TIME_OR_DATE   Give me time or date (or both).
 *
 *      time_t * ptmOldValue    This time_t will be used to fill in the fields
 *                      not given in the string.  If it is NULL, the current
 *                      time or date will be used.
 *      BOOL * pfOk     Returns TRUE for succesfull conversion, FALSE
 *                      otherwise.
 *
 *  Returns:
 *
 *      A time_t representing the time/date string, or 0 in case of error.
 *
 *  Notes:
 *
 *      Full validation of all paremeters will be done, e.g. No Feb 29 in
 *      a non-leap year will be accepted.
 *
 *      [CAVEAT] Time, date seperators longer than one character will not
 *      work.
 *
 */
time_t CIntlTime::ConvertFromString (
    const CString & str,
    int nFormat,
    time_t * ptmOldValue,   // If only getting time or date, count on remaining
                            // fields to be provided here (optionally);
    BOOL * pfOk)
{
    #define MAXSTRLEN 40

    TCHAR dtseps[10] ;      // Date/Time separators passed to _tcstok
    TCHAR *pchToken;
    TCHAR szDateString[MAXSTRLEN+1];
    BOOL fGotDate = FALSE;
    BOOL fGotTime = FALSE;
    BOOL fPM = FALSE;
    BOOL fAM = FALSE;
    int i;
    UINT anValues[6] = { 0, 0, 0, 0, 0, 0 };
    CTime tmTmp;

    *pfOk = FALSE;      // Assume failure.

    if (ptmOldValue != NULL)
    {
        tmTmp = *ptmOldValue;
    }
    else
    {
        tmTmp = CTime::GetCurrentTime();
    }

    if (str.GetLength() > MAXSTRLEN)
    {
        // Too long to be a proper time/date string
        return(0);
    }
    ::lstrcpy(szDateString, (LPCTSTR)str);

    int nIndex = 0;

    // If we're looking for something specific, only
    // accept specific seperators (time, date, both, either)
    if ((nFormat == TFRQ_DATE_ONLY) || (nFormat == TFRQ_TIME_AND_DATE) || (nFormat == TFRQ_TIME_OR_DATE))
    {
        dtseps[nIndex++] = '/';
        dtseps[nIndex++] = '-';
        dtseps[nIndex++] = ',';
        dtseps[nIndex++] = CIntlTime::m_itsInternationalSettings.strDateSeperator[0];
    }

    if ((nFormat == TFRQ_TIME_ONLY) || (nFormat == TFRQ_TIME_AND_DATE) || (nFormat == TFRQ_TIME_OR_DATE))
    {
        dtseps[nIndex++] = ':';
        dtseps[nIndex++] = '.';
        dtseps[nIndex++] = ' ';
        dtseps[nIndex++] = CIntlTime::m_itsInternationalSettings.strTimeSeperator[0];
    }

    ASSERT(nIndex != 0);    // Make sure we asked for something.
    if (nIndex == 0)
    {
        // Request type is illegal
        return(0);
    }
    dtseps[nIndex++] = '\0';

    Trace3("CIntlTime::ConvertFromString.  String: %s Format = %d Seps: %s\n", str, nFormat, dtseps);

    i = 0;
    pchToken = ::_tcstok(szDateString, dtseps);
    while (pchToken != NULL)
    {
        if (i > 6)        // 7 fields max (date, time + AM/PM maximum)
        {
            // Too many values, reject the string.
            return(0);
        }

        // Determine if its a number (can't _ttoi, since it will
        // merely return 0 for inappropriate values)

        BOOL fProperNumber = TRUE;
        int l = ::lstrlen(pchToken);
        if ( (l == 0) || (l == 3) || (l > 4) )
        {
            fProperNumber = FALSE;
        }
        else
        {
            int j;
            for (j=0; j < l; ++j)
            {
                if (!isdigit(*(pchToken+j)))
                {
                    fProperNumber = FALSE;
                    break;
                }
            }
        }

        if (!fProperNumber)
        {
            // Ok, this is not a proper numeric field.  Only
            // if it's AM or PM at the end of the string can this
            // string be saved.
            fGotTime = TRUE;
            if ((CIntlTime::m_itsInternationalSettings.f24HourClock) ||
                (::_tcstok(NULL, dtseps) != NULL))
            {
                return(0);
            }

            if (!CIntlTime::m_itsInternationalSettings.strAM.CompareNoCase(pchToken))
            {
                fAM = TRUE;
            }
            else if (!CIntlTime::m_itsInternationalSettings.strPM.CompareNoCase(pchToken))
            {
                fPM = TRUE;
            }
            else
            {
                // Neither AM nor PM
                return(0);
            }
            break;
        }
        else
        {
            // Value is acceptable
            anValues[i++] = (UINT)::_ttoi(pchToken);
        }

        pchToken = ::_tcstok(NULL, dtseps);
    }
    // Now what did we get, exactly?

    ASSERT(!fAM || !fPM); // Make sure we didn't set both somehow.
    if (i == 0)
    {
        // String without values
        return(0);
    }
    switch(i)
    {
        case 1:     // Hour
        case 2:     // Hour, minutes
            Trace0("We got time\n");
            fGotTime = TRUE;
            break;
        case 3:

            // This one might be ambiguous, try to intelligently decide what
            // we have.  First check if only time or date only was requested,
            // then check for out of bounds time values, and lastly check for
            // the presence of a time seperator.

            if (!fGotTime) // If we didn't already have AM/PM
            {
                Trace0("Picking between time and date by seperator\n");
                if (nFormat == TFRQ_DATE_ONLY)
                {
                    fGotDate = TRUE;
                }
                else if (nFormat == TFRQ_TIME_ONLY)
                {
                    fGotTime = TRUE;
                }
                else if ((anValues[0] > 23) || (anValues[1] > 59) || (anValues[2] > 59))
                {
                    fGotDate = TRUE;
                }
                else if (str.Find(CIntlTime::m_itsInternationalSettings.strTimeSeperator) != -1)
                {
                    fGotTime = TRUE;
                }
                else
                {
                    fGotDate = TRUE;
                }
                Trace1("Decided on %s", (fGotDate ?  "date\n" : "time\n"));
            }
            break;
        case 4: // Date, hour
        case 5: // Date, hours, minutes
        case 6: // Date, hours, minutes, seconds
            Trace0("We got date and time\n");
            fGotDate = TRUE;
            fGotTime = TRUE;
            break;
        default:
            ASSERT(0 && "Incorrect number of values!");
            return(0);
    }

    // Was that what we're looking for?
    if ( ((nFormat == TFRQ_DATE_ONLY) && fGotTime) ||
         ((nFormat == TFRQ_TIME_ONLY) && fGotDate) ||
         ((nFormat == TFRQ_TIME_AND_DATE) && (!fGotTime || !fGotDate))
       )
    {
        Trace0("Entry didn't match expectations\n");
        return(0);

    }
    i = 0;

    int h, m, s, D, M, Y;   // Array indices;
    // Now determine where to find what.
    if (fGotDate) // Date always goes first
    {
        switch(CIntlTime::m_itsInternationalSettings.nDateFormat)
        {
            case _DFMT_MDY:
                M = i++;
                D = i++;
                Y = i++;
                break;

            case _DFMT_DMY:
                D = i++;
                M = i++;
                Y = i++;
                break;

            case _DFMT_YMD:
                Y = i++;
                M = i++;
                D = i++;
                break;
        }
        // If only 2 digits are given, determine if we're talking about
        // the 21st or 20th century
        if (anValues[Y] < 100)
        {
            anValues[Y] += (anValues[Y] > 37) ? 1900 : 2000;
        }
        Trace3("Month = %d Day = %d Year = %d\n", anValues[M], anValues[D], anValues[Y]);

        // Validation.
        if (!IsValidDate(anValues[M], anValues[D], anValues[Y]))
        {
            return(0);
        }
    }

    if (fGotTime)
    {
        h = i++;
        m = i++;
        s = i++;

        Trace3("Hours = %d Minutes = %d Seconds = %d\n", anValues[h], anValues[m], anValues[s]);

        // Shouldn't specify AM or PM with 24 hour clock value.
        if ((anValues[h] > 12) && (fAM || fPM))
        {
            return(0);
        }

        // Adjust for AM/PM modifiers
        if (fPM)
        {
            if (anValues[h] != 12)
            {
                anValues[h] += 12;
            }
        }
        else if (fAM)
        {
            if ( anValues[h] == 12)
            {
                anValues[h] -= 12;
            }
        }

        // Sanity Check:
        if (!IsValidTime(anValues[h], anValues[m], anValues[s]))
        {
            return(0);
        }
    }

    // Fill in the missing fields
    CIntlTime tm( fGotDate ? anValues[Y] : tmTmp.GetYear(),
                  fGotDate ? anValues[M] : tmTmp.GetMonth(),
                  fGotDate ? anValues[D] : tmTmp.GetDay(),
                  fGotTime ? anValues[h] : tmTmp.GetHour(),
                  fGotTime ? anValues[m] : tmTmp.GetMinute(),
                  fGotTime ? anValues[s] : tmTmp.GetSecond()
                );

    *pfOk = (tm.GetTime() > (time_t)0);

    return(tm);
}

#ifdef _DEBUG

// Dump to debug device
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlTime& tim)
{
    dc << _T("\nDate Seperator: ") << tim.m_itsInternationalSettings.strDateSeperator;
    dc << _T("\nTime Seperator: ") << tim.m_itsInternationalSettings.strTimeSeperator;
    dc << _T("\nAM String: ")  << tim.m_itsInternationalSettings.strAM;
    dc << _T("\nPM String: ")  << tim.m_itsInternationalSettings.strPM;
    dc << _T("\nDate Format: ") << tim.m_itsInternationalSettings.nDateFormat;
    dc << _T("\n24 Hour Clock: ")  << (tim.m_itsInternationalSettings.f24HourClock ? "TRUE" : "FALSE");
    dc << _T("\n4 Digit Century: ") << (tim.m_itsInternationalSettings.fCentury ? "TRUE" : "FALSE");
    dc << _T("\nTime Leading Zero: ")  << (tim.m_itsInternationalSettings.fLeadingTimeZero ? "TRUE" : "FALSE");
    dc << _T("\nDay Leading Zero ")  << (tim.m_itsInternationalSettings.fLeadingDayZero ? "TRUE" : "FALSE");
    dc << _T("\nMonth Leading Zero: ")  << (tim.m_itsInternationalSettings.fLeadingMonthZero ? "TRUE" : "FALSE");
    dc << _T("\n\ntime_t: ") << tim.GetTime();
    return(dc);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\intlnum.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _INTLNUM_H_
#define _INTLNUM_H_

class CIntlNumber : public CObjectPlus
{
public:
    CIntlNumber()
    {
        m_lValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlNumber(LONG lValue)
    {
        m_lValue = lValue;
        m_fInitOk = TRUE;
    }
    CIntlNumber(const CString & str);

    CIntlNumber(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
    }

    CIntlNumber& operator =(CIntlNumber const &x)
    {
        m_lValue = x.m_lValue;
        m_fInitOk = x.m_fInitOk;
        return(*this);
    }

public:
    // Assignment Operators
    CIntlNumber& operator =(LONG l);
    CIntlNumber& operator =(const CString &str);

    // Shorthand operators.
    CIntlNumber& operator +=(const CIntlNumber& num);
    CIntlNumber& operator +=(const LONG l);
    CIntlNumber& operator -=(const CIntlNumber& num);
    CIntlNumber& operator -=(const LONG l);
    CIntlNumber& operator /=(const CIntlNumber& num);
    CIntlNumber& operator /=(const LONG l);
    CIntlNumber& operator *=(const CIntlNumber& num);
    CIntlNumber& operator *=(const LONG l);

    // Conversion operators
    operator const LONG() const
    {
        return(m_lValue);
    }
    operator const CString() const;

public:
    virtual BOOL IsValid() const
    {
        return(m_fInitOk);
    }

public:
    static void Reset();
    static void SetBadNumber(CString strBadNumber = "--")
    {
        m_strBadNumber = strBadNumber;
    }
    static CString ConvertNumberToString(const LONG l);
    static LONG ConvertStringToNumber(const CString & str, BOOL * pfOk);
    static CString& GetBadNumber()
    {
        return(m_strBadNumber);
    }

private:
    static CString GetThousandSeperator();

private:
    static CString m_strThousandSeperator;
    static CString m_strBadNumber;

private:
    LONG m_lValue;
    BOOL m_fInitOk;

public:
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlNumber& num);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator<<(CArchive& ar, const CIntlNumber& num);
    friend CArchive& AFXAPI operator>>(CArchive& ar, CIntlNumber& num);
};

class CIntlLargeNumber : public CObjectPlus
{
public:
    CIntlLargeNumber()
    {
        m_lLowValue = 0L;
        m_lHighValue = 0L;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(LONG lHighWord, LONG lLowWord)
    {
        m_lLowValue = lLowWord;
        m_lHighValue = lHighWord;
        m_fInitOk = TRUE;
    }
    CIntlLargeNumber(const CString & str);

public:
    // Assignment Operators
    CIntlLargeNumber& operator =(const CString &str);
    operator const CString() { return ConvertNumberToString(); }
    operator CString() { return ConvertNumberToString(); }

public:
    virtual LONG GetLowWord() const { return m_lLowValue; }
    virtual LONG GetHighWord() const { return m_lHighValue; }
    virtual BOOL IsValid() const { return(m_fInitOk); }

private:
    static CString m_strBadNumber;
    CString ConvertNumberToString();
    void ConvertStringToNumber(const CString & str, BOOL * pfOk);

private:
    LONG m_lLowValue;
    LONG m_lHighValue;
    BOOL m_fInitOk;
};

#endif _INTLNUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\intlnum.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#include "objplus.h"
#include "intlnum.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// Initialise static thousand seperator string
//
CString CIntlNumber::m_strThousandSeperator(GetThousandSeperator());
CString CIntlNumber::m_strBadNumber("--");

/***
 * 
 *  CIntlNumber::GetThousandSeperator
 *
 *  Purpose:
 *
 *      Get the thousand seperator string from the registry (win32) or the
 *      win.ini file (win16).
 *
 *  Returns:
 *
 *      A CString containing the system thousand seperator, or the
 *      American default (",") in case of failure.
 *
 */
CString CIntlNumber::GetThousandSeperator()
{
    #define MAXLEN  6

#ifdef _WIN32   

    CString str;

    if (::GetLocaleInfo(GetUserDefaultLCID(), LOCALE_STHOUSAND, str.GetBuffer(MAXLEN), MAXLEN))
    {
         str.ReleaseBuffer();
         return(str);
    }
    Trace0("Couldn't get 1000 seperator from system, using american default");
    str = ",";
    return(str);

#endif // _WIN32

#ifdef _WIN16

    CString str;

    ::GetProfileString("Intl", "sThousand", ",", str.GetBuffer(MAXLEN), MAXLEN);
    str.ReleaseBuffer();
    return(str);

#endif // _WIN16

}

/***
 *
 *  CIntlNumber::Reset()
 *
 *  Purpose:
 *
 *      Reset the international settings. Usually in response to
 *      a change in those international settings by the user.
 *
 *  Notes:
 *
 *      This is a publically available static function.
 *
 */
void CIntlNumber::Reset()
{
    CIntlNumber::m_strThousandSeperator = GetThousandSeperator();
}

/***
 * 
 *  CIntlNumber::ConvertNumberToString
 *
 *  Purpose:
 *
 *      Convert the given long number to a string, inserting thousand
 *      seperators at the appropriate intervals.
 *
 *  Arguments:
 *
 *      const LONG l        The number to convert
 *
 *  Returns:
 *
 *      A CString containing the number in string format.
 *
 */
CString CIntlNumber::ConvertNumberToString(const LONG l)
{
    // Default returned string:
    CString str = CIntlNumber::m_strBadNumber;

    LPTSTR lpOutString = str.GetBuffer(16);
    int outstrlen;
    // Forget about the negative sign for now.
    LONG lNum = (l >= 0) ? l : -l;

    outstrlen = 0;
    do
    {
        lpOutString[outstrlen++] = '0' + (TCHAR)(lNum % 10);
        lNum /= 10;

        // if more digits left and we're on a 1000 boundary (printed 3 digits,
        // or 3 digits + n*(3 digits + 1 comma), then print a 1000 separator.

        if (lNum != 0 && (outstrlen == 3 || outstrlen == 7 || outstrlen == 11))
        {
            lstrcpy (lpOutString + outstrlen, CIntlNumber::m_strThousandSeperator);
            outstrlen += m_strThousandSeperator.GetLength();
        }

    } while (lNum > 0);

    // Add a negative sign if necessary.
    if (l < 0L)
    {
        lpOutString[outstrlen++] = '-';
    }
    lpOutString[outstrlen] = '\0';
    str.ReleaseBuffer();
    str.MakeReverse();

    return(str);
}

/***
 *
 *  CIntlNumber::ConvertStringToNumber
 *
 *  Purpose:
 *
 *      Given a CString, with optional thousand seperators, convert it to
 *      a LONG.
 *
 *  Arguments:
 *
 *      const CString & str The string to convert
 *      BOOL * pfOk         Returns TRUE for successful conversion,
 *                          FALSE for failure.
 *
 *  Returns:
 *
 *      The return value is the number, or 0 if the string contained
 *      invalid characters.
 *
 *  Notes:
 *
 *      If a negative sign is given, it must be the first character of
 *      the string, immediately (no spaces) followed by the number.
 *
 *      Optional thousand seperators can only be placed at the expected
 *      3 digit intervals.  The function will return an error if a thousand
 *      seperator is encountered elsewhere.
 *
 *      [CAVEAT] This function will not accept thousand seperators of longer
 *               than one character.
 *
 *      No leading or trailing spaces will be acceptable.
 *
 */
LONG CIntlNumber::ConvertStringToNumber(const CString & str, BOOL * pfOk)
{
    CString strNumber(str);
    LONG lValue = 0L;
    LONG lBase = 1L;
    *pfOk = FALSE;
    BOOL fNegative = FALSE;
 
    // Empty strings are invalid
    if (strNumber.IsEmpty())
    {
        return(lValue);
    }
   
    int i;

    strNumber.MakeReverse();
    for (i=0; i<strNumber.GetLength(); ++i)
    {
        if ((strNumber[i] >= '0') && (strNumber[i] <= '9'))
        {
            lValue += (LONG)(strNumber[i] - '0') * lBase;
            lBase *= 10;
        }
        // It's not a digit, maybe a thousand seperator?
        // CAVEAT: If a thousand seperator of more than
        //         one character is used, this won't work.
        else if ((strNumber[i] != m_strThousandSeperator[0]) ||
              (i != 3) && (i != 7) && (i != 11))
        {
            // Check for negative sign (at the end only)
            if ((strNumber[i] == '-') && (i == strNumber.GetLength()-1))
            {
                fNegative = TRUE;
            }
            else
            {
                // This is just invalid, since it is not a thousand
                // seperator in the proper location, nor a negative
                // sign.
                Trace1("Invalid character %c encountered in numeric conversion", (BYTE)strNumber[i]);
                return(0L);
            }
        }
    }
         
    if (fNegative)
    {
        lValue = -lValue;
    }
    *pfOk = TRUE;    
    return (lValue);
}

// Constructor taking a CString argument
CIntlNumber::CIntlNumber(const CString & str)
{
    m_lValue = ConvertStringToNumber(str, &m_fInitOk);
}

// Assignment operator
CIntlNumber & CIntlNumber::operator =(LONG l)
{
    m_lValue = l;
    m_fInitOk = TRUE;
    return(*this);
}

// Assignment operator
CIntlNumber & CIntlNumber::operator =(const CString &str)
{
    m_lValue = ConvertStringToNumber(str, &m_fInitOk);
    return(*this);
}

// Conversion operator
CIntlNumber::operator const CString() const
{
    return(IsValid() ? ConvertNumberToString(m_lValue) : CIntlNumber::m_strBadNumber);
}

#ifdef _DEBUG
//
// Dump context to the debugging output
//
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlNumber& num)
{
    dc << num.m_lValue;
    return(dc);
}

#endif // _DEBUG
                     
// Initialise static thousand seperator string
CString CIntlLargeNumber::m_strBadNumber("--");

/***
 * 
 *  CIntlLargeNumber::ConvertNumberToString
 *
 *  Purpose:
 *
 *      Convert the given long number to a string.
 *
 *  Returns:
 *
 *      A CString containing the number in string format.
 *
 */
CString CIntlLargeNumber::ConvertNumberToString()
{    
    CString str;

    TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), m_lHighValue, m_lLowValue);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    str = pch;

    return(str);
}

/***
 *
 *  CIntlLargeNumber::ConvertStringToNumber
 *
 *  Purpose:
 *
 *      Given a CString convert it to LargeInteger.
 */
void CIntlLargeNumber::ConvertStringToNumber(const CString & str, BOOL * pfOk)
{
    *pfOk = FALSE;

    m_lHighValue = m_lLowValue = 0;

    int j = str.GetLength();

    if ( j > 16 || !j )
    {
        //
        // Invalid string
        //
        return;
    }

    TCHAR sz[] = _T("0000000000000000");
    TCHAR *pch;

    ::lstrcpy(sz + 16 - j, (LPCTSTR)str);
    pch = sz + 8;
    ::swscanf(pch, _T("%08lX"), &m_lLowValue);
    *pch = '\0';
    ::swscanf(sz, _T("%08lX"), &m_lHighValue);

    *pfOk = TRUE;    
    return;
}

// Constructor taking a CString argument
CIntlLargeNumber::CIntlLargeNumber(const CString & str)
{
    ConvertStringToNumber(str, &m_fInitOk);
}


// Assignment operator
CIntlLargeNumber & CIntlLargeNumber::operator =(const CString &str)
{
    ConvertStringToNumber(str, &m_fInitOk);
    return(*this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ipaddr.hpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ipaddr.hpp
//
//--------------------------------------------------------------------------

//
//  IPADDR.HPP:  IPADDRESS control implementation file.
//

#if !defined(_IPADDR_HPP_)
#define _IPADDR_HPP_

class CWndIpAddress : public CWnd
{
    DECLARE_DYNAMIC(CWndIpAddress)

protected:
    static WNDPROC m_wproc_super ;
    static BOOL m_b_inited ;

public:

    CWndIpAddress () ;
    ~ CWndIpAddress () ;

    BOOL Create(LPCTSTR lpszText, 
        DWORD dwStyle,
        const RECT& rect, 
        CWnd* pParentWnd, 
        UINT nID = 0xffff
        );

    WNDPROC * GetSuperWndProcAddr() ;

    //  Modification flag handling
    void SetModify ( BOOL bModified ) ;
    BOOL GetModify () const ;

    //   Set focus on a particular sub-field
    void SetFocusField(int iField);
    void ClearAddress () ;
    void SetFieldRange (int dwField, int dwMin, int dwMax);
    void SetReadOnly (BOOL fReadonly = TRUE);
    void SetField(int dwField, BOOL fSet = FALSE, BYTE bValue = 0x00);

    BOOL SetAddress (DWORD dwAddr) ;
    BOOL GetAddress (DWORD * pdwAddr  ) const ;
    BYTE GetMask() const ;
    BOOL SetMask(DWORD dwAddr, BYTE bMask);

	BOOL IsBlank();

    //  One-shot initialization
    static BOOL CreateWindowClass ( HINSTANCE hInstance ) ;  
};



#endif  // _IPADDR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ipaddres.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include <winsock.h>

#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

// CAVEAT: The functions herein require the winsock lib.

// Constructor
CIpAddress::CIpAddress (const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
		::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const LONG l)
{
    m_lIpAddress = l;
    m_fInitOk = TRUE;
    return (*this);
}

// Assignment operator
const CIpAddress & CIpAddress::operator =(const CString & str)
{
    CHAR szString [ MAX_PATH ] = {0};

	if (IsValidIp(str))
	{
#ifdef UNICODE
	    ::WideCharToMultiByte(CP_ACP, 0, str, -1, szString, sizeof(szString), NULL, NULL);
#else
		strcpy (szString, str, str.GetLength());
#endif

		ULONG ul = ::inet_addr( szString );
		m_fInitOk = (ul != INADDR_NONE);
    
		//  Convert the string to network byte order, then to host byte order.
		if (m_fInitOk)
		{
			m_lIpAddress = (LONG)::ntohl(ul) ;
		}
	}
	else
	{
		m_fInitOk = FALSE;
		m_lIpAddress = 0;
	}

    return(*this);
}

BOOL
CIpAddress::IsValidIp(const CString & str)
{
	BOOL fValid = TRUE;

	for (int i = 0; i < str.GetLength(); i++)
	{
		if (str[i] != '.' &&
			!iswdigit(str[i]))
		{
			fValid = FALSE;
			break;
		}
	}

	return fValid;
}

// Conversion operator
CIpAddress::operator const CString&() const
{
    struct in_addr ipaddr ;
    static CString strAddr;

    //  Convert the unsigned long to network byte order
    ipaddr.s_addr = ::htonl( (u_long) m_lIpAddress ) ;

    //  Convert the IP address value to a string
    strAddr = inet_ntoa( ipaddr ) ;

    return(strAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\modeless.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       modeless.cpp
//
//--------------------------------------------------------------------------

// StatsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "modeless.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*---------------------------------------------------------------------------
	ModelessThread implementation
 ---------------------------------------------------------------------------*/

IMPLEMENT_DYNCREATE(ModelessThread, CWinThread)

BEGIN_MESSAGE_MAP(ModelessThread, CWinThread)
END_MESSAGE_MAP()

ModelessThread::ModelessThread()
{
}

ModelessThread::ModelessThread(HWND hWndParent, UINT nIDD, HANDLE hEvent, CDialog *pModelessDlg) :
   m_hwndParent(hWndParent),
   m_pModelessDlg(pModelessDlg),
   m_nIDD(nIDD),
   m_hEvent(hEvent)
{
}

ModelessThread::~ModelessThread()
{
	SetEvent(m_hEvent);
	m_hEvent = 0;
}


int ModelessThread::InitInstance()
{
	CWnd *	pParent = CWnd::FromHandle(m_hwndParent);

	BOOL bReturn = m_pModelessDlg->Create(m_nIDD, pParent);

	if (bReturn)
		m_pMainWnd = m_pModelessDlg;
	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ipaddres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _IPADDRES_H_
#define _IPADDRES_H_

//
// IP Address Conversion Macros
//
#ifndef MAKEIPADDRESS
  #define MAKEIPADDRESS(b1,b2,b3,b4) ((LONG)(((DWORD)(b1)<<24)+((DWORD)(b2)<<16)+((DWORD)(b3)<<8)+((DWORD)(b4))))

  #define GETIP_FIRST(x)             ((x>>24) & 0xff)
  #define GETIP_SECOND(x)            ((x>>16) & 0xff)
  #define GETIP_THIRD(x)             ((x>> 8) & 0xff)
  #define GETIP_FOURTH(x)            ((x)     & 0xff)
#endif // MAKEIPADDRESS

/////////////////////////////////////////////////////////////////////////////
// CIpAddress class

class CIpAddress : public CObjectPlus
{
public:
    // Constructors
    CIpAddress()
    {
        m_lIpAddress = 0L;
        m_fInitOk = FALSE;
    }
    CIpAddress (LONG l)
    {
        m_lIpAddress = l;
        m_fInitOk = TRUE;
    }
    CIpAddress (BYTE b1, BYTE b2, BYTE b3, BYTE b4)
    {
        m_lIpAddress = (LONG)MAKEIPADDRESS(b1,b2,b3,b4);
        m_fInitOk = TRUE;
    }
    CIpAddress(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
    }

    CIpAddress (const CString & str);

    //
    // Assignment operators
    //
    const CIpAddress & operator =(const LONG l);
    const CIpAddress & operator =(const CString & str);
    const CIpAddress & operator =(const CIpAddress& ia)
    {
        m_lIpAddress = ia.m_lIpAddress;
        m_fInitOk = ia.m_fInitOk;
        return *this;
    }

    //
    // Conversion operators
    //
    operator const LONG() const
    {
        return m_lIpAddress;
    }
    operator const CString&() const;

public:
    BOOL IsValid() const
    {
        return m_fInitOk;
    }

protected:
	BOOL IsValidIp(const CString & str);

private:
    LONG m_lIpAddress;
    BOOL m_fInitOk;
};

#endif _IPADDRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\intltime.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _INTLTIME_H_
#define _INTLTIME_H_

//
// Utility functions
//
void FormatDateTime(CString & strOutput, SYSTEMTIME * psystemtime, BOOL fLongDate = FALSE);
void FormatDateTime(CString & strOutput, FILETIME * pfiletime, BOOL fLongDate = FALSE);
void FormatDateTime(CString & strOutput, CTime & time, BOOL fLongDate = FALSE);

//
// CIntlTime class definition
//
class CIntlTime : public CTime
{
//
// Attributes
//
public:
    enum _TIME_FORMAT_REQUESTS
    {
        TFRQ_TIME_ONLY,
        TFRQ_DATE_ONLY,
        TFRQ_TIME_AND_DATE,
        TFRQ_TIME_OR_DATE,
        TFRQ_MILITARY_TIME,
    };

public:
// Same contructors as CTime
    CIntlTime();
    CIntlTime(const CTime &timeSrc);
    CIntlTime(time_t time);
    CIntlTime(int nYear, int nMonth, int nDay, int nHour, int nMin, int nSec);
    CIntlTime(WORD wDosDate, WORD wDosTime);
#ifdef _WIN32
    CIntlTime(const SYSTEMTIME& sysTime);
    CIntlTime(const FILETIME& fileTime);
#endif // _WIN32

// New for CIntlTime
    CIntlTime(const CIntlTime &timeSrc);
    CIntlTime(const CString &strTime, int nFormat = TFRQ_TIME_OR_DATE, time_t * ptmOldValue = NULL);

public:
    virtual ~CIntlTime();

// Operations
public:
    // Assignment operators
    const CIntlTime& operator=(time_t tmValue);
    const CIntlTime& operator=(const CString& strValue);
    const CIntlTime& operator=(const CTime & time);
    const CIntlTime& operator=(const CIntlTime & time);

    // Conversion operators
    operator const time_t() const;
    operator CString() const;
    operator const CString() const;

    const CString IntlFormat(int nFormat) const
    {
        return(ConvertToString(nFormat));
    }

    // Validation checks

    BOOL IsValid() const
    {
        return(m_fInitOk);
    }

    static BOOL IsIntlValid()
    {
        return(CIntlTime::m_fIntlOk);
    }

public:
    // ... Input and output
    #ifdef _DEBUG
        friend CDumpContext& AFXAPI operator<<(CDumpContext& dc, const CIntlTime& tim);
    #endif // _DEBUG

    friend CArchive& AFXAPI operator <<(CArchive& ar, const CIntlTime& tim);
    friend CArchive& AFXAPI operator >>(CArchive& ar, CIntlTime& tim);

// Implementation

public:
    static void Reset();
    static void SetBadDateAndTime(CString strBadDate = "--", CString strBadTime = "--")
    {
        m_strBadDate = strBadDate;
        m_strBadTime = strBadTime;
    }
    static CString& GetBadDate()
    {
        return(m_strBadDate);
    }
    static CString& GetBadTime()
    {
        return(m_strBadTime);
    }
    static time_t ConvertFromString (const CString & str, int nFormat, time_t * ptmOldValue, BOOL * pfOk);
    static BOOL IsLeapYear(UINT nYear); // Complete year value
    static BOOL IsValidDate(UINT nMonth, UINT nDay, UINT nYear);
    static BOOL IsValidTime(UINT nHour, UINT nMinute, UINT nSecond);


private:
    enum _DATE_FORMATS
    {
        _DFMT_MDY,  // Day, month, year
        _DFMT_DMY,  // Month, day, year
        _DFMT_YMD,  // Year, month, day
    };

    typedef struct _INTL_TIME_SETTINGS
    {
        CString strDateSeperator; // String used between date fields
        CString strTimeSeperator; // String used between time fields.
        CString strAM;            // Suffix string used for 12 hour clock AM times
        CString strPM;            // Suffix string used for 12 hour clock PM times
        int nDateFormat;          // see _DATE_FORMATS enum above.
        BOOL f24HourClock;        // TRUE = 24 hours, FALSE is AM/PM
        BOOL fCentury;            // If TRUE, uses 4 digits for the century
        BOOL fLeadingTimeZero;    // If TRUE, uses leading 0 in time format
        BOOL fLeadingDayZero;     // If TRUE, uses leading 0 in day
        BOOL fLeadingMonthZero;   // If TRUE, uses leading 0 in month
    } INTL_TIME_SETTINGS;

    static INTL_TIME_SETTINGS m_itsInternationalSettings;
    static CString m_strBadTime;
    static CString m_strBadDate;

private:
    static BOOL SetIntlTimeSettings();
    static BOOL m_fIntlOk;

private:
    const CString GetDateString() const;
    const CString GetTimeString() const;
    const CString GetMilitaryTime() const;
    const CString ConvertToString(int nFormat) const;

private:
    BOOL m_fInitOk;
};

#endif _INTLTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ipadrcls.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1998 **/
/**********************************************************************/

/*

    ipaddr.cpp:  CWndIpAddress class control implementation     

    FILE HISTORY:
*/

#include "stdafx.h"

#include "ipaddr.hpp"

extern "C"
{
   #include "ipadd.h"
   #include "ipaddr.h"
}

    //  Static class-level data

    //  Super window proc address
WNDPROC CWndIpAddress :: m_wproc_super = NULL ;

    //  Window class initialization flag                  
BOOL CWndIpAddress :: m_b_inited = FALSE ;


WNDPROC * CWndIpAddress :: GetSuperWndProcAddr ()
{
    return & m_wproc_super ;
}


BOOL CWndIpAddress :: CreateWindowClass ( HINSTANCE hInstance )
{
    Trace0("CWndIpAddress::CreateWindowClass\n");
    if ( ! m_b_inited ) 
    {
        m_b_inited = ::IPAddrInit( hInstance )  ;
    }
    return m_b_inited ;
}

IMPLEMENT_DYNAMIC(CWndIpAddress, CWnd)

CWndIpAddress :: CWndIpAddress ()
{
}

CWndIpAddress :: ~ CWndIpAddress ()
{
    DestroyWindow();
}

BOOL CWndIpAddress :: Create ( 
    LPCTSTR			lpszText, 
    DWORD			dwStyle,
    const RECT &	rect, 
    CWnd *			pParentWnd, 
    UINT			nID )
{
    return CWnd::Create( TEXT("IPAddress"), lpszText, dwStyle, rect, pParentWnd, nID);
}

    //  Modification flag handling
void CWndIpAddress :: SetModify ( BOOL bModified )
{
    ::SendMessage( m_hWnd, IP_SETMODIFY, bModified, 0 );
}

BOOL CWndIpAddress :: GetModify () const
{
    return ::SendMessage( m_hWnd, IP_GETMODIFY, 0, 0 ) > 0 ;
}

void CWndIpAddress :: SetFocusField( int iField )
{
    ::SendMessage( m_hWnd, IP_SETFOCUS, iField, 0);
}

void CWndIpAddress::ClearAddress ( )
{
    ::SendMessage( m_hWnd, IP_CLEARADDRESS, 0, 0);
}

BOOL CWndIpAddress :: SetAddress ( DWORD dwAddr )
{
    return ::SendMessage( m_hWnd, IP_SETADDRESS, 0, dwAddr ) > 0 ;
}

BOOL CWndIpAddress :: GetAddress ( DWORD * pdwAddr ) const
{
    return ::SendMessage( m_hWnd, IP_GETADDRESS, 0,(LPARAM) pdwAddr ) > 0 ;
}
    void SetReadOnly (BOOL fReadonly = TRUE);
    void SetField(int dwField, BYTE bValue);

void CWndIpAddress :: SetReadOnly ( BOOL fReadOnly )
{
    ::SendMessage( m_hWnd, IP_SETREADONLY, (WPARAM)fReadOnly, (LPARAM)0 );
}

void CWndIpAddress :: SetField (int dwField, BOOL fSet, BYTE bValue)
{
    ::SendMessage( m_hWnd, IP_SETFIELD, (WPARAM)dwField, fSet 
        ? MAKELPARAM(0, MAKEWORD(0, bValue))
        : (LPARAM)-1
        );
}

BYTE CWndIpAddress :: GetMask () const
{
    DWORD_PTR dw = ::SendMessage( m_hWnd, IP_GETMASK, 0, 0);
    return (BYTE)dw;
}

BOOL CWndIpAddress :: SetMask(DWORD dwAddress, BYTE bMask)
{
    return ::SendMessage( m_hWnd, IP_SETMASK, (WPARAM)bMask, (LPARAM)dwAddress) > 0;
}

BOOL CWndIpAddress :: IsBlank()
{
    return ::SendMessage( m_hWnd, IP_ISBLANK, 0, 0) > 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\ncglobal.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	ncglobal.cpp
        network console global stuff

	FILE HISTORY:
        
*/

// {DA1BDD17-8E54-11d1-93DB-00C04FC3357A}
DEFINE_GUID(GUID_NetConsRootNodeType, 
    0xda1bdd17, 0x8e54, 0x11d1, 0x93, 0xdb, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a);

#define NETCONS_ROOT_TOP            L"NETCONS_ROOT_TOP"
#define NETCONS_ROOT_THIS_MACHINE   L"NETCONS_ROOT_THIS_MACHINE"
#define NETCONS_ROOT_NET_SERVICES   L"NETCONS_ROOT_NET_SERVICES"
#define NETCONS_ROOT_LOAD_CONSOLES  L"NETCONS_ROOT_LOAD_CONSOLES"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\listctrl.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    lcx.cpp
//
// History:
//  07/13/96    Abolade Gbadegesin      Created, based on C code by Steve Cobb
//
// Implements an enhanced list-control.
//============================================================================
#include "stdafx.h"
#include "resource.h"
#include "util.h"
#include "listctrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNAMIC(CListCtrlEx, CListCtrl)

BEGIN_MESSAGE_MAP(CListCtrlEx, CListCtrl)
    //{{AFX_MSG_MAP(CListCtrlEx)
    ON_WM_LBUTTONDOWN()
    ON_WM_CHAR()
    ON_WM_KEYDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::~CListCtrlEx
//
// Destructor. Deletes the image list, if any, and unloads row-information.
//----------------------------------------------------------------------------

CListCtrlEx::~CListCtrlEx(
    ) {

	delete m_pimlChecks;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::GetColumnCount
//
// Called to retrieve the number of columns in any list-control.
//----------------------------------------------------------------------------

INT
CListCtrlEx::GetColumnCount(
    ) {

    return Header_GetItemCount(ListView_GetHeader(m_hWnd));
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::SetColumnText
//
// Sets the text in the header of the column in position 'iCol'.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::SetColumnText(
    INT             iCol,
    LPCTSTR         pszText,
    INT             fmt
    ) {

    LV_COLUMN   lvc;

    lvc.mask = LVCF_FMT | LVCF_TEXT;
    lvc.pszText = (LPTSTR)pszText;
    lvc.fmt = fmt;

    return SetColumn(iCol, &lvc);
}


//----------------------------------------------------------------------------
// Function:    CListCtrlEx::InstallChecks
//
// Installs check-box handling for the list-control.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::InstallChecks(
    ) {

    HICON   hIcon;

    //
    // Make sure the list-control is in report-mode
    //

    if (!(GetStyle() & LVS_REPORT)) { return FALSE; }


    //
    // Allocate a new image-list.
    //

    m_pimlChecks = new CImageList;

    if (!m_pimlChecks) { return FALSE; }

    do {
    
        //
        // Initialize the image-list
        //
    
        if (!m_pimlChecks->Create(
                ::GetSystemMetrics(SM_CXSMICON),
                ::GetSystemMetrics(SM_CYSMICON),
                ILC_MASK, 2, 2
                )) {
    
            break;
        }
    
    
        //
        // Add the icons for the checked and unchecked images
        //
    
        hIcon = ::LoadIcon(
                    AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_COMMON_UNCHECK)
                    );

        if (!hIcon) { break; }

        m_pimlChecks->Add(hIcon); ::DeleteObject(hIcon);

    
        hIcon = ::LoadIcon(
                    AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_COMMON_CHECK)
                    );

        if (!hIcon) { break; }

        m_pimlChecks->Add(hIcon); ::DeleteObject(hIcon);


        //
        // Replace the list-control's current image-list with the new one
        //
    
        m_pimlOldState = SetImageList(m_pimlChecks, LVSIL_STATE);

        return TRUE;
    
    } while(FALSE);


    //
    // If we arrive here, an error occurred, so clean up and fail
    //

    delete m_pimlChecks; m_pimlChecks = NULL;

    return FALSE;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::UninstallChecks
//
// Uninstalls checkbox-handling for the list-control.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::UninstallChecks(
    ) {

    if (!m_pimlChecks) { return; }

    if (m_pimlOldState) { SetImageList(m_pimlOldState, LVSIL_STATE); }

    delete m_pimlChecks; m_pimlChecks = NULL;
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::GetCheck
//
// Returns TRUE if the specified item is checked, FALSE otherwise.
//----------------------------------------------------------------------------

BOOL
CListCtrlEx::GetCheck(
    INT     iItem
    ) {

    return !!(GetItemState(iItem, LVIS_STATEIMAGEMASK) &
                INDEXTOSTATEIMAGEMASK(LCXI_CHECKED));
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::SetCheck
//
// If 'fCheck' is non-zero, checks 'iItem', otherwise clears 'iItem'.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::SetCheck(
    INT     iItem,
    BOOL    fCheck
    ) {

    SetItemState(
        iItem,
        INDEXTOSTATEIMAGEMASK(fCheck ? LCXI_CHECKED : LCXI_UNCHECKED),
        LVIS_STATEIMAGEMASK
        );

    if (GetParent()) {

        NMHDR nmh;

        nmh.code = LVXN_SETCHECK;
        nmh.hwndFrom = m_hWnd;

        ::SendMessage(
            GetParent()->m_hWnd, WM_NOTIFY, GetDlgCtrlID(), (LPARAM)&nmh
            );
    }
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnChar
//
// Handles the 'WM_CHAR' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnChar(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) {

    BOOL    fSet = FALSE;
    BOOL    fClear = FALSE;
    BOOL    fToggle = FALSE;
    INT     iItem;


    //
    // Handle characters with special meaning for us
    //

    switch (nChar) {

        case TEXT(' '): { fToggle = TRUE; break; }

        case TEXT('+'):
        case TEXT('='): { fSet = TRUE; break; }

        case TEXT('-'): { fClear = TRUE; break; }
    }

    if (!fToggle && !fSet && !fClear) {

        CListCtrl::OnChar(nChar, nRepCnt, nFlags);
    }
    else {

        //
        // Change the state of all the selected items
        //

        for (iItem = GetNextItem(-1, LVNI_SELECTED);
             iItem != -1;
             iItem = GetNextItem(iItem, LVNI_SELECTED)) {

            if (fToggle) {

                SetCheck(iItem, !GetCheck(iItem));
            }
            else
            if (fSet) {

                if (!GetCheck(iItem)) { SetCheck(iItem, TRUE); }
            }
            else {

                if (GetCheck(iItem)) { SetCheck(iItem, FALSE); }
            }
        }
    }
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnKeyDown
//
// Handles the 'WM_KEYDOWN' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnKeyDown(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) {

    //
    // We want the left-arrow treated as an up-arrow
    // and the right-arrow treated as a down-arrow.
    //

    if (nChar == VK_LEFT) {

        CListCtrl::OnKeyDown(VK_UP, nRepCnt, nFlags); return;
    }
    else
    if (nChar == VK_RIGHT) {

        CListCtrl::OnKeyDown(VK_DOWN, nRepCnt, nFlags); return;
    }

    CListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}



//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnLButtonDown
//
// Handles the 'WM_LBUTTONDOWN' message, changing an item's checked state 
// when the user clicks the item's check-image.
//----------------------------------------------------------------------------

VOID
CListCtrlEx::OnLButtonDown(
    UINT    nFlags,
    CPoint  pt
    ) {

    INT     iItem;
    UINT    uiFlags;


    //
    // If the left-mouse button is over the check-box icon,
    // we treat it as a toggle on the check-box.
    //

    uiFlags = 0;

    iItem = HitTest(pt, &uiFlags);


    if (iItem != -1 && (uiFlags & LVHT_ONITEMSTATEICON)) {

        SetCheck(iItem, !GetCheck(iItem));

        // Redraw this item
        RedrawItems(iItem, iItem);
    }

    CListCtrl::OnLButtonDown(nFlags, pt);
}




//----------------------------------------------------------------------------
// Function:    AdjustColumnWidth
//
// Called to adjust the width of column 'iCol' so that the string 'pszContent'
// can be displayed in the column without truncation.
//
// If 'NULL' is specified for 'pszContent', the function adjusts the column
// so that the first string in the column is displayed without truncation.
//
// Returns the new width of the column.
//----------------------------------------------------------------------------

INT
AdjustColumnWidth(
    IN      CListCtrl&      listCtrl,
    IN      INT             iCol,
    IN      LPCTSTR         pszContent
    ) {

    INT iWidth, iOldWidth;


    //
    // Compute the minimum width the column needs to be
    //

    if (pszContent) {

        iWidth = listCtrl.GetStringWidth(pszContent);
    }
    else {

        iWidth = listCtrl.GetStringWidth(listCtrl.GetItemText(0, iCol));
    }


    //
    // Adjust 'iWidth' to leave some breathing space
    //

    iWidth += ::GetSystemMetrics(SM_CXSMICON) +
              ::GetSystemMetrics(SM_CXEDGE) * 2;


    //
    // If the column is narrower than 'iWidth', enlarge it.
    //

    iOldWidth = listCtrl.GetColumnWidth(iCol);

    if (iOldWidth < iWidth) {

        listCtrl.SetColumnWidth(iCol, iWidth);

        iOldWidth = iWidth;
    }

    return iOldWidth;
}


INT
AdjustColumnWidth(
    IN  CListCtrl&      listCtrl,
    IN  INT             iCol,
    IN  UINT            idsContent
    ) {

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString sCol;

    sCol.LoadString(idsContent);

    return AdjustColumnWidth(listCtrl, iCol, sCol);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\listctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    lcx.h
//
// History:
//  07/13/96    Abolade Gbadegesin      Created, based on C code by Steve Cobb
//
// Contains declarations for an enhanced list-control.
//============================================================================

#ifndef _LISTCTRL_H_
#define _LISTCTRL_H_

#ifndef _COMMON_UTIL_H_
#include "util.h"
#endif


//
// Notification sent by CListCtrlEx when an item's checked state changes.
//

#define LVXN_SETCHECK   (LVN_LAST + 1)


//----------------------------------------------------------------------------
// Structs:     SLcxRow
//              SLcxColumn
//
// Describes rows and columns in customizable list-controls.
//----------------------------------------------------------------------------

struct SLcxRow {

    UINT        uiRowId;
    UINT        idsTitle;
    BOOL        bEnabled;

};

struct SLcxColumn {

    INT         iSubItem;
    UINT        idsTitle;
    INT         cx;
    BOOL        bEnabled;
    INT         iIndex;

};



//----------------------------------------------------------------------------
// Class:       CListCtrlEx
//
// Controls a list-control which has extended capabilities,
// including the ability to show checkboxes next to its items,
// and the ability to maintain row-information in the registry.
//----------------------------------------------------------------------------

class CListCtrlEx : public CListCtrl
{

	DECLARE_DYNAMIC(CListCtrlEx)

public:

	CListCtrlEx()
			: m_pimlChecks(NULL), m_pimlOldState(NULL)
			{ }

	virtual ~CListCtrlEx( );

	enum {
		LCXI_UNCHECKED  = 1,
		LCXI_CHECKED    = 2
	};

	INT	GetColumnCount( );

	BOOL SetColumnText(INT iCol, LPCTSTR pszText, INT fmt = LVCFMT_LEFT );

	BOOL SetColumnText(INT iCol, UINT nID, INT fmt = LVCFMT_LEFT)
	{
        // Needed for Loadstring
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

		CString sCol;
		sCol.LoadString(nID);
		return SetColumnText(iCol, sCol, fmt);
	}


	//--------------------------------------------------------------------
	// Functions:   InstallChecks
	//              UninstallChecks
	//              GetCheck
	//              SetCheck
	//
	// Checkbox-handling functions.
	//--------------------------------------------------------------------
	
	BOOL InstallChecks( );
    VOID UninstallChecks( );
	BOOL GetCheck(INT iItem );
	VOID SetCheck(  INT iItem, BOOL fCheck );

protected:
	CImageList*     m_pimlChecks;
	CImageList*     m_pimlOldState;
	
	//{{AFX_MSG(CListCtrlEx)
	afx_msg VOID    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg VOID    OnLButtonDown(UINT nFlags, CPoint pt);
	//}}AFX_MSG
	
	DECLARE_MESSAGE_MAP()
};


//----------------------------------------------------------------------------
// Function:    AdjustColumnWidth
//
// Called to adjust the width of column 'iCol' so that the string 'pszContent'
// can be displayed in the column without truncation.
//
// If 'NULL' is specified for 'pszContent', the function adjusts the column
// so that the first string in the column is displayed without truncation.
//
// Returns the new width of the column.
//----------------------------------------------------------------------------

INT
AdjustColumnWidth(
    IN      CListCtrl&      listCtrl,
    IN      INT             iCol,
    IN      LPCTSTR         pszContent
    );

INT
AdjustColumnWidth(
    IN  CListCtrl&      listCtrl,
    IN  INT             iCol,
    IN  UINT            idsContent
    );

#endif // _LISTCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\modeless.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	modeless.h

	Header file for the base class of the Statistics dialogs.

    FILE HISTORY:
	
*/

#ifndef _MODELESS_H
#define _MODELESS_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#include "commres.h"

// forward declarations
struct ColumnData;


class ModelessThread : public CWinThread
{
	DECLARE_DYNCREATE(ModelessThread)
protected:
	ModelessThread();		// protected constructor used by dynamic creation

public:
	ModelessThread(HWND hWndParent, UINT nIdTemplate,
				   HANDLE hEvent,
				   CDialog *pModelessDialog);

// Operations
public:

	// Overrides
	virtual BOOL	InitInstance();
//	virtual int		ExitInstance();


protected:
	virtual ~ModelessThread();

	CDialog *	m_pModelessDlg;
	UINT		m_nIDD;
	HWND		m_hwndParent;

	// Signal this when we are being destroyed
	HANDLE		m_hEvent;

	DECLARE_MESSAGE_MAP()
};


#endif // _MODELESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\objpick.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objpick.h
//
//--------------------------------------------------------------------------

// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#ifndef OBJPICK_H
#define OBJPICK_H

//
// A list of names (e.g., users, groups, machines, and etc)
//

void    FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay);

class CUserInfo
{
public:
    CUserInfo() {};
    CUserInfo(LPCTSTR pName, LPCTSTR pFullName)
        : m_strName(pName), m_strFullName(pFullName) {};

    CUserInfo(CUserInfo & userInfo)
    {
		if (this != &userInfo)
			*this = userInfo;
    }

    CUserInfo & operator = (const CUserInfo & userInfo)
    {
        if (this != &userInfo)
        {
            m_strName = userInfo.m_strName;
            m_strFullName = userInfo.m_strFullName;
        }
        
        return *this;
    }

public:
	CString			m_strName;			// in the form of "domain\username"
	CString			m_strFullName;		// in the form of "firstname lastname"
};

typedef CArray<CUserInfo, CUserInfo&> CUserInfoArray;

class CGetUsers : public CUserInfoArray
{
public:
    CGetUsers(BOOL fMultiselect = FALSE);
    ~CGetUsers();

	BOOL    GetUsers(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

protected:
    BOOL    m_fMultiselect;
};

class CGetComputer 
{
public:
    CGetComputer();
    ~CGetComputer();

    BOOL    GetComputer(HWND hwndOwner);

protected:
    void    ProcessSelectedObjects(IDataObject *pdo);

public:
    CString     m_strComputerName;
};

#endif // GETUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\objpick.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       objpick.cpp
//
//--------------------------------------------------------------------------

// objpick.cpp: implementation of the CGetUser class and the 
//              CGetComputer class using the object picker
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "objpick.h"

#include <iads.h>           
#include <iadsp.h>          // IADsPathname

#include <objsel.h>
#include <adshlp.h>

#include "objplus.h"
#include "ipaddres.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { Trace2("line %u err 0x%x\n", __LINE__, hr); break; }

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, BOOL fMultiselect);
HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker);

DWORD ObjPickGetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName);


//////////////////////////////////////////////////////////////////////
// CGetUsers Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


void    
FormatName(LPCTSTR pszFullName, LPCTSTR pszDomainName, CString & strDisplay)
{
    strDisplay.Format(_T("%s (%s)"), pszFullName, pszDomainName);
}

CGetUsers::CGetUsers(BOOL fMultiselect)
{
    m_fMultiselect = fMultiselect;
}

CGetUsers::~CGetUsers()
{

}

BOOL
CGetUsers::GetUsers(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker, m_fMultiselect);

        //
        // Invoke the modal dialog.
        //
        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            Trace0("User canceled object picker dialog\n");
            fSuccess = FALSE;
            break;
        }

        //
        // Process the user's selections
        //
        Assert(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}

void
CGetUsers::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            Trace1("GlobalLock error %u\n", GetLastError());
            break;
        }

        // create the path name thing
        CComPtr<IADsPathname> spIADsPathname;
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                              IID_IADsPathname, (PVOID *)&spIADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);
        
        hr = spIADsPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );

        for (UINT nCount = 0; nCount < pDsSelList->cItems; nCount++)
        {
            DS_SELECTION * pDsSel = &(pDsSelList->aDsSelection[nCount]);
            Assert(NULL != pDsSel);
        
            LPWSTR pwzADsPath = pDsSel->pwzADsPath;
            Assert( NULL != pwzADsPath );

            hr = spIADsPathname->Set( pwzADsPath, ADS_SETTYPE_FULL );
            if (FAILED(hr))
                continue;

            long lnNumPathElements = 0;
            hr = spIADsPathname->GetNumElements( &lnNumPathElements );
            if (FAILED(hr))
                continue;
        
            CComBSTR sbstrUser, sbstrDomain;
            hr = spIADsPathname->GetElement( 0, &sbstrUser );
            if (FAILED(hr))
                continue;
        
            switch (lnNumPathElements)
            {
                case 1:
                    hr = spIADsPathname->Retrieve( ADS_FORMAT_SERVER, &sbstrDomain );
                    break;

                case 2:  // nt4, nt5 domain
                case 3:  // local domain
                    hr = spIADsPathname->GetElement( 1, &sbstrDomain );
                    break;

                default:
                    Assert(FALSE);
                    hr = E_FAIL;
            }

            if (FAILED(hr))
                continue;

            CUserInfo userTemp;
            CString strDomain;

            strDomain = sbstrDomain;
            strDomain.MakeUpper();

            if (pDsSel->pvarFetchedAttributes[0].vt == VT_EMPTY)
                userTemp.m_strFullName = pDsSel->pwzName;
            else
                userTemp.m_strFullName = V_BSTR(&(pDsSel->pvarFetchedAttributes[0]));
        
            userTemp.m_strName.Format(L"%s\\%s", strDomain, sbstrUser);

            Add(userTemp);
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//////////////////////////////////////////////////////////////////////
// CGetComputer Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CGetComputer::CGetComputer()
{
}

CGetComputer::~CGetComputer()
{
}

BOOL
CGetComputer::GetComputer(HWND hwndParent)
{
    HRESULT             hr = S_OK;
    IDsObjectPicker *   pDsObjectPicker = NULL;
    IDataObject *       pdo = NULL;
    BOOL                fSuccess = TRUE;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) 
        return FALSE;

    do
    {
        //
        // Create an instance of the object picker.  The implementation in
        // objsel.dll is apartment model.
        //
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //
        if (hr == S_FALSE)
        {
            Trace0("User canceled object picker dialog\n");
            fSuccess = FALSE;
            break;
        }

        Assert(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    
    CoUninitialize();

    if (FAILED(hr))
        fSuccess = FALSE;

    return fSuccess;
}


void
CGetComputer::ProcessSelectedObjects(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    BOOL fGotStgMedium = FALSE;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = TRUE;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            Trace1("GlobalLock error %u\n", GetLastError());
            break;
        }

        CString strTemp = pDsSelList->aDsSelection[0].pwzName;
        if (strTemp.Left(2) == _T("\\\\"))
            strTemp = pDsSelList->aDsSelection[0].pwzName[2];

        if (ERROR_SUCCESS != ObjPickNameOrIpToHostname(strTemp, m_strComputerName))
        {
            //we use the name from the object picker if we failed to convert it into hostname
            m_strComputerName = strTemp;
        }

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(IDsObjectPicker *pDsObjectPicker, BOOL fMultiselect)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT | DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                          | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType =
       DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
       | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;
    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly = DSOP_FILTER_USERS;
    aScopeInit[3].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = (fMultiselect) ? DSOP_FLAG_MULTISELECT : 0;

    LPCTSTR attrs[] = {_T("FullName")};

    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = attrs;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);

    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                printf("Initialization failed because of scope %u\n", i);
            }
        }
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 2;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Build a scope init struct for everything except the joined domain.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;


    //
    // scope for the joined domain, make it the default
    //
    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}

//Use WinSock to the host name based on the ip address
DWORD
ObjPickGetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    u_long ulAddrInNetOrder = ::htonl( (u_long) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
                                           sizeof ulAddrInNetOrder,
                                           PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
    }

    // copy the name
    LPTSTR pBuf = strName.GetBuffer(256);
    ZeroMemory(pBuf, 256);

    ::MultiByteToWideChar(CP_ACP, 
                          MB_PRECOMPOSED, 
                          pHostInfo->h_name, 
                          -1, 
                          pBuf, 
                          256);

    strName.ReleaseBuffer();
    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

//Convert any valid name of a machine (IP address, NetBios name or fully qualified DNS name)
//to the host name
DWORD ObjPickNameOrIpToHostname(CString & strNameOrIp, CString & strHostName)
{
    DWORD dwErr = ERROR_SUCCESS;
    CString strTemp;

    CIpAddress ia(strNameOrIp);
    if (ia.IsValid())
    {
        dwErr = ObjPickGetHostName((LONG)ia, strTemp);
    }
    else
    {
         // just want the host name
         int nDot = strNameOrIp.Find('.');
         if (nDot != -1)
         {
             strTemp = strNameOrIp.Left(nDot);
         }
         else
         {
             strTemp = strNameOrIp;
         }
    }

    if (ERROR_SUCCESS == dwErr)
    {
        strHostName = strTemp;
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\proppage.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    proppage.h
        Implementation for property pages in MMC

    FILE HISTORY:
        
*/

#ifndef _PROPPAGE_H
#define _PROPPAGE_H

// proppage.h : header file
//

#include "afxdlgs.h"

///////////////////////////////////////////////////////////////////////////////
// FORWARD DECLARATIONS

class CPropertyPageBase; 
 
typedef CList< CPropertyPageBase*, CPropertyPageBase* > CPropertyPageBaseList;

HWND FindMMCMainWindow();

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

class CPropertyPageHolderBase
{
public:
// construction
    // for scope pane property pages and wizards
	CPropertyPageHolderBase(ITFSNode *		pNode,
							IComponentData *pComponentData,
							LPCTSTR			pszSheetName,
							BOOL			bIsScopePane = TRUE);

    // for result pane property pages only 
    // result pane wizards should use the previous constructor
	CPropertyPageHolderBase(ITFSNode *		pNode,
							IComponent *    pComponent,
							LPCTSTR			pszSheetName,
							BOOL			bIsScopePane = FALSE);

    virtual ~CPropertyPageHolderBase();

// initialization
	// common
	// property sheet only
	virtual HRESULT CreateModelessSheet(LPPROPERTYSHEETCALLBACK pSheetCallback, LONG_PTR hConsoleHandle); 

	// Property sheet, but do everything ourselves
	virtual HRESULT DoModelessSheet(); 

	// wizard only
	virtual HRESULT DoModalWizard();

// helpers
	// common
	void SetSheetWindow(HWND hSheetWindow);
	HWND GetSheetWindow();
	BOOL SetDefaultSheetPos();  // sets the sheet window centered to the MMC main window
    void AddRef();
	void Release();

	DWORD GetRefCount();
	
	// get/set for the node we are working on
	ITFSNode *	GetNode();
	void SetNode(ITFSNode* pNode);
	
	// get/set for the container we refer to
	ITFSNode *	GetContainer();
		
	BOOL IsWizardMode();
	void ForceDestroy();	// forcefull shut down running sheet

	void AddPageToList(CPropertyPageBase* pPage);
	BOOL RemovePageFromList(CPropertyPageBase* pPage, BOOL bDeleteObject);

	// property sheet only

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
	void EnablePeekMessageDuringNotifyConsole(BOOL bEnable)
	{
		m_bPeekMessageDuringNotifyConsole = bEnable;
	};
	
	DWORD NotifyConsole(CPropertyPageBase* pPage);	// notify console of property changes
	void AcknowledgeNotify();						// acknowledge from the console
	virtual void OnPropertyChange(BOOL bScopePane) {}

	// wizard only
	BOOL SetWizardButtons(DWORD dwFlags);
	BOOL SetWizardButtonsFirst(BOOL bValid);
	BOOL SetWizardButtonsMiddle(BOOL bValid); 
	BOOL SetWizardButtonsLast(BOOL bValid);
    BOOL PressButton(int nButton);
    

	virtual DWORD OnFinish() { return 0; } 
	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask); // execute from main thread

	HRESULT AddPageToSheet(CPropertyPageBase* pPage);
	HRESULT RemovePageFromSheet(CPropertyPageBase* pPage);

	HWND SetActiveWindow();

	void IncrementDirty(int cDirty) { m_cDirty += cDirty; };
	BOOL IsDirty() { return m_cDirty != 0; };

    BOOL IsWiz97() { return m_bWiz97; }

protected:
	// common
	HRESULT AddAllPagesToSheet();

private:
	void DeleteAllPages();
	void FinalDestruct();

// attributes
protected:
    BOOL        m_bProcessingNotifyConsole; // Set when inside NotifyConsole function
	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
	BOOL		m_bPeekMessageDuringNotifyConsole; // Set to FALSE by default

	// common
	CString		m_stSheetTitle;			// title for the sheet/wizard window
	CPropertyPageBaseList	m_pageList;	// list of property page objects

	BOOL		m_bWizardMode;		// Wizard Mode (i.e. not modeless property sheet)
	BOOL		m_bCalledFromConsole;	// console told us to put up this page

	BOOL		m_bAutoDelete;		// delete itself when refcount is zero
	BOOL		m_bAutoDeletePages;	// explicitely delete the prop pages

    BOOL        m_bSheetPosSet;
    
    BOOL        m_bWiz97;

	BOOL        m_bTheme;

	SPIComponentData	m_spComponentData;
	SPIComponent    	m_spComponent;

	BOOL		m_bIsScopePane;		// is this sheet for a scope pane node
	DWORD		m_nCreatedCount;	// count of pages actually created
	SPITFSNode	m_spNode;			// node the pages (or wizard) refers to
	SPITFSNode	m_spParentNode;		// node the pages (or wizard) refers to
	
	HWND		m_hSheetWindow;		// window handle to the sheet

	// property sheet only
	LONG_PTR  m_hConsoleHandle;	// handle for notifications to console
	HANDLE	  m_hEventHandle;	// syncronization handle for property notifications

	// wizard only
	SPIPropertySheetCallback m_spSheetCallback;// cached pointer to add/remove pages

	int			m_cDirty;
	BOOL		m_fSetDefaultSheetPos;

private:
	// property sheet only
	// variables to use across thread boundaries
	DWORD				m_dwLastErr;		// generic error code
	CPropertyPageBase*	m_pPropChangePage;	// page for which notification is valid

public:
	HANDLE				m_hThread;

	void SetError(DWORD dwErr) { m_dwLastErr = dwErr;}
	DWORD GetError() { return m_dwLastErr; }

	CPropertyPageBase* GetPropChangePage() 
			{ ASSERT(m_pPropChangePage != NULL); return m_pPropChangePage; }

};

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

class CPropertyPageBase : public CPropertyPage
{
	DECLARE_DYNCREATE(CPropertyPageBase)
// Construction
private:
	CPropertyPageBase(){} // cannot use this constructor
public:
	CPropertyPageBase(UINT nIDTemplate, UINT nIDCaption = 0);
	virtual ~CPropertyPageBase();

// Overrides
public:
	virtual BOOL OnApply();
	virtual void CancelApply();

protected:
// Generated message map functions
	//{{AFX_MSG(CGeneralPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	
    // help messages
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);

    DECLARE_MESSAGE_MAP()

// attributes
public:
	void SetHolder(CPropertyPageHolderBase* pPageHolder);
	CPropertyPageHolderBase* GetHolder();

	PROPSHEETPAGE  m_psp97;
	HPROPSHEETPAGE m_hPage;

	// property seet only
	virtual BOOL OnPropertyChange(BOOL bScopePane, LONG_PTR* pChangeMask) // execute from main thread
						{ return FALSE; /* do not repaint UI */ } 


	
	// Use this call to get the actual help map
	// this version will check the global help map first.
	DWORD *		GetHelpMapInternal();
	
    // override this to return the pointer to the help map
    virtual LPDWORD GetHelpMap() { return NULL; }

	void InitWiz97(BOOL bHideHeader, UINT nIDHeaderTitle, UINT nIDHeaderSubTitle);
protected:
	// These functions set the dirty flag on the current page
	virtual void SetDirty(BOOL bDirty);
	virtual BOOL IsDirty() { return m_bIsDirty; }

private:
	CString                 m_szHeaderTitle;
	CString                 m_szHeaderSubTitle;
	CPropertyPageHolderBase* m_pPageHolder;             // backpointer to holder
	BOOL                    m_bIsDirty;					// dirty flag
};


/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline void	CPropertyPageHolderBase::AddRef()
{
	m_nCreatedCount++;
}

inline DWORD CPropertyPageHolderBase::GetRefCount()
{
	return m_nCreatedCount;
}

inline HWND CPropertyPageHolderBase::GetSheetWindow()
{
	return m_hSheetWindow;
}

inline ITFSNode * CPropertyPageHolderBase::GetNode()
{
	if (m_spNode)
		m_spNode->AddRef();
	return m_spNode;
}

inline void CPropertyPageHolderBase::SetNode(ITFSNode *pNode)
{
	m_spNode.Set(pNode);
	m_spParentNode.Release();
	if (m_spNode)
		m_spNode->GetParent(&m_spParentNode);
}

inline ITFSNode * CPropertyPageHolderBase::GetContainer()
{
	if (m_spParentNode)
		m_spParentNode->AddRef();
	return m_spParentNode;
}

inline BOOL CPropertyPageHolderBase::IsWizardMode()
{
	return m_bWizardMode;
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsFirst(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? PSWIZB_NEXT : 0);
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsMiddle(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_NEXT) : PSWIZB_BACK);
}

inline BOOL CPropertyPageHolderBase::SetWizardButtonsLast(BOOL bValid) 
{ 
	return SetWizardButtons(bValid ? (PSWIZB_BACK|PSWIZB_FINISH) : (PSWIZB_BACK|PSWIZB_DISABLEDFINISH));
}





inline void CPropertyPageBase::SetHolder(CPropertyPageHolderBase *pPageHolder)
{
	Assert((pPageHolder != NULL) && (m_pPageHolder == NULL));
	m_pPageHolder = pPageHolder;
}

inline CPropertyPageHolderBase * CPropertyPageBase::GetHolder()
{
	return m_pPageHolder;
}

inline void CPropertyPageBase::SetDirty(BOOL bDirty)
{
	SetModified(bDirty);
	m_bIsDirty = bDirty;
}

// Use this function for property pages on the Scope pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *pNode,
								  IComponentData *pComponentData,
								  LPCTSTR pszSheetTitle);

// Use this function for property pages on the result pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *   pNode,
										   IComponent * pComponent,
										   LPCTSTR	    pszSheetTitle,
                                           int          nVirtualIndex = -1);

/*!--------------------------------------------------------------------------
	EnableChildControls
		Use this function to enable/disable/hide/show all child controls
		on a page (actually it will work with any child windows, the
		parent does not have to be a property page).
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags);
#define PROPPAGE_CHILD_SHOW		0x00000001
#define PROPPAGE_CHILD_HIDE		0x00000002
#define PROPPAGE_CHILD_ENABLE	0x00000004
#define PROPPAGE_CHILD_DISABLE	0x00000008

/*!--------------------------------------------------------------------------
	MultiEnableWindow
		This function takes a variable length list of control ids,
		that will be enabled/disabled.  The last item in the control
		id list must be 0.

		The reason why I called this MultiEnableWindow instead of
		EnableMultiWindow is that we can grep for EnableWindow and
		still show these calls.
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT	MultiEnableWindow(HWND hWndParent, BOOL fEnable, UINT nCtrlId, ...);

#endif // _PROPPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\queryobj.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    queryobj.cpp
        Implementation for nodes in the MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "queryobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////
//
// CBackgroundThread
//
/////////////////////////////////////////////////////////////////////
DEBUG_DECLARE_INSTANCE_COUNTER(CBackgroundThread);

CBackgroundThread::CBackgroundThread()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBackgroundThread);

	m_bAutoDelete = TRUE;
	::InitializeCriticalSection(&m_cs);
}

CBackgroundThread::~CBackgroundThread()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CBackgroundThread);

//  Trace0("CBackgroundThread::~CBackgroundThread()\n");
	::DeleteCriticalSection(&m_cs);
	m_spQuery.Release();
}

void 
CBackgroundThread::SetQueryObj(ITFSQueryObject *pQuery)
{ 
	Assert(pQuery != NULL);
	m_spQuery.Set(pQuery);
}

BOOL CBackgroundThread::Start()
{
    // NOTE:::  ericdav 10/23/97
    // the thread is initially suspended so we can duplicate the handle
    // if the query object exits very quickly, the background thread object
    // may be destroyed before we can duplicate the handle.  Right after
    // we duplicate the handle, it is started.
	return CreateThread(CREATE_SUSPENDED);
}

int 
CBackgroundThread::Run()
{
	DWORD	dwRet;
	DWORD	dwData;
	BOOL	fAbort = FALSE;
	
	Assert(m_spQuery);
//  Trace0("CBackgroundThread::Run() started\n");

	for (;;)
	{
		try
			{
			if (m_spQuery->Execute() != hrOK)
				break;
			}
		catch(...)
			{
//  		Trace1("%x Caught an exception while executing CQuerObj!\n",
//  			  GetCurrentThreadId());
			fAbort = TRUE;
			}

		//$ Review: kennt
		// Should we sleep a little while at this point? especially
		// since the thread has given us some data to process.

		// Check to see if the abort flag is set
		if (fAbort || FHrOK(m_spQuery->FCheckForAbort()))
		{
			break;
		}
	}

	// Notify the query object that we are exiting
	if (fAbort || FHrOK(m_spQuery->FCheckForAbort()))
		m_spQuery->OnEventAbort();
	else
		m_spQuery->OnThreadExit();

	m_spQuery->DoCleanup();
	
    Trace2("handle=%X id=%X CBackgroundThread::Run() terminated\n",
           m_hThread, m_nThreadID);
	return 0;
}


/*---------------------------------------------------------------------------
	CQueryObject implementation
 ---------------------------------------------------------------------------*/
DEBUG_DECLARE_INSTANCE_COUNTER(CQueryObject);

/*!--------------------------------------------------------------------------
	CQueryObject::CQueryObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CQueryObject::CQueryObject()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CQueryObject);

	m_cRef = 1;
	m_hEventAbort = NULL;
	::InitializeCriticalSection(&m_cs);
}

/*!--------------------------------------------------------------------------
	CQueryObject::~CQueryObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
CQueryObject::~CQueryObject()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CQueryObject);

	Assert(m_cRef == 0);
	::DeleteCriticalSection(&m_cs);
	::CloseHandle(m_hEventAbort);
	m_hEventAbort = 0;
//  Trace1("%X CQueryObject::~CQueryObject()\n", GetCurrentThreadId());
}

IMPLEMENT_ADDREF_RELEASE(CQueryObject)

STDMETHODIMP CQueryObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
		*ppv = (LPVOID) this;
	else if (riid == IID_ITFSQueryObject)
		*ppv = (ITFSQueryObject *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
	{
		((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
	}
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
	CQueryObject::Init
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::Init(ITFSThreadHandler *pHandler, HWND hwndHidden, UINT uMsgBase)
{
	Assert(m_spHandler == NULL);
	m_spHandler.Set(pHandler);

	m_hHiddenWnd = hwndHidden;
	m_uMsgBase = uMsgBase;
	
	m_hEventAbort = ::CreateEvent(NULL,
								  TRUE /*bManualReset*/,
								  FALSE /*signalled*/,
								  NULL);
	if (m_hEventAbort == NULL)
		return HRESULT_FROM_WIN32(GetLastError());
	else
		return hrOK;
}
	
/*!--------------------------------------------------------------------------
	CQueryObject::SetAbortEvent
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::SetAbortEvent()
{
//  Trace1("%X Signalling CQueryObject abort event.\n", GetCurrentThreadId());
	Assert(m_hEventAbort);
	
    ::SetEvent(m_hEventAbort);
	
    OnEventAbort();
	
    // flush out the message queue in case something is wait to be processed
    MSG msg;
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CQueryObject::FCheckForAbort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CQueryObject::FCheckForAbort()
{
//	Assert(m_hEventAbort);

	// we may not be running as a background thread, but somebody may have
	// created this object to do somework...  In which case this isn't valid,
	// and just return ok
	if (!m_hEventAbort)
		return hrOK;

	DWORD dwRet = WaitForSingleObjectEx(m_hEventAbort, 0, FALSE);
#ifdef DEBUG
//  if (dwRet == WAIT_OBJECT_0)
//  	Trace1("%X CQueryObject() detects an abort event!\n", GetCurrentThreadId());
#endif
	return dwRet == WAIT_OBJECT_0 ? hrOK : hrFalse;
}




/*---------------------------------------------------------------------------
	CNodeQueryObject implementation
 ---------------------------------------------------------------------------*/

CNodeQueryObject::~CNodeQueryObject()
{
//  Trace2("%X CNodeQueryObject::~CNodeQueryObject has %d objects\n",
//  	   GetCurrentThreadId(), m_dataQueue.GetCount());
	Assert(m_dataQueue.IsEmpty());
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::AddToQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::AddToQueue(ITFSNode *pNode)
{
	BOOL bSleep = FALSE;

	Lock();
	//::Sleep(1000);
	LPQUEUEDATA pQData = new QUEUEDATA;

	pQData->Type = QDATA_PNODE;
	pQData->Data = reinterpret_cast<LPARAM>(pNode);

	BOOL bRes = NULL != m_dataQueue.AddTail(pQData);
	pNode->AddRef();
	
	if (IsQueueFull())
	{
		bSleep = TRUE;
	}
	Unlock();

	// We have too much data, we've posted a notification to the node
	// so we can go to sleep here.

	// Note the danger here!  The code calling has to be aware that a
	// context switch will occur here (as well as not locking the data
	// structures).
	if (bSleep)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}

	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::AddToQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::AddToQueue(LPARAM Data, LPARAM Type)
{
	BOOL bSleep = FALSE;

	Lock();
	//::Sleep(1000);
	LPQUEUEDATA pQData = new QUEUEDATA;

	pQData->Data = Data;
	pQData->Type = Type;

	BOOL bRes = NULL != m_dataQueue.AddTail(pQData);
	
	if (IsQueueFull())
	{
		bSleep = TRUE;
	}
	Unlock();

	// We have too much data, we've posted a notification to the node
	// so we can go to sleep here.

	// Note the danger here!  The code calling has to be aware that a
	// context switch will occur here (as well as not locking the data
	// structures).
	if (bSleep)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}

	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::RemoveFromQueue
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPQUEUEDATA
CNodeQueryObject::RemoveFromQueue()
{
	Lock();
	LPQUEUEDATA pQD = m_dataQueue.IsEmpty() ? NULL : m_dataQueue.RemoveHead(); 
	Unlock();
	return pQD;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::IsQueueEmpty
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL 
CNodeQueryObject::IsQueueEmpty()
{
	Lock();
	BOOL bRes = m_dataQueue.IsEmpty(); 
	Unlock();
	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::IsQueueFull
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL CNodeQueryObject::IsQueueFull()
{
	Lock();
	BOOL bRes = m_dataQueue.GetCount() >= m_nQueueCountMax;
	Unlock();
	return bRes;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnThreadExit
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::OnThreadExit()
{
	BOOL	fSomethingInQueue = FALSE;
	
	Lock();
	fSomethingInQueue = (m_dataQueue.GetCount() > 0);
	Unlock();

	// If there's anything in the queue, post
	if (fSomethingInQueue)
	{
		PostHaveData((LPARAM) (CNodeQueryObject *) this);
		::Sleep(0);
	}
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnEventAbort
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::OnEventAbort()
{
//  Trace2("%X CNodeQueryObject::OnEventAbort Q has %d nodes.\n", GetCurrentThreadId(), m_dataQueue.GetCount());
	Lock();
    while (!m_dataQueue.IsEmpty())
	{
		LPQUEUEDATA pQD = m_dataQueue.RemoveHead();
		if (pQD->Type == QDATA_PNODE)
		{
			SPITFSNode spNode;
			spNode = reinterpret_cast<ITFSNode *>(pQD->Data);
		}
		else
		{
			// give the query object a chance to clean up this data
			OnEventAbort(pQD->Data, pQD->Type);
		}

		delete pQD;
	}

	Unlock();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::OnCleanup
		DO NOT override this function.  It provides a last cleanup 
		mechanism for the query object.  If you need notification 
		that a thread is exiting, then override the OnThreadExit call.
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP CNodeQueryObject::DoCleanup()
{
	PostMessageToComponentData(WM_HIDDENWND_INDEX_EXITING, (LPARAM) (CNodeQueryObject *) this);

	m_spQuery.Release();

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CNodeQueryObject::PostMessageToComponentData
		Posts a message to the hidden window to get back on the main 
		MMC thread.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL 
CNodeQueryObject::PostMessageToComponentData(UINT uIndex, LPARAM lParam)
{
//	Assert(m_spHandler);
//	Assert(m_hHiddenWnd != NULL);
//	Assert(::IsWindow(m_hHiddenWnd));

	//$ Review: kennt, if the hidden window is bogus, should we still post
	// to it?  This could happen if our ComponentData went away but we were
	// still in our loop, posting away (we haven't had a chance to get the
	// abort signal).
	
	// maybe something like
		
	if (!m_hHiddenWnd)
		return 0;
		
	if (!::IsWindow(m_hHiddenWnd))
	{
//  	Trace2("%X The Hidden window is GONE, tried to send %08x.\n",
//  		  GetCurrentThreadId(), m_uMsgBase+uIndex);
		m_hHiddenWnd = NULL;
		return 0;
	}
	
	//Trace2("%X CBackgroundThread::PostMessageToComponentData(%08x)\n", GetCurrentThreadId(), m_uMsgBase+uIndex);

	if (!m_spHandler)
	{
//  	Trace0("PostMessageToCompData - m_spHandler == NULL, NOT posting a message\n");
		return 0;
	}

	return ::PostMessage(m_hHiddenWnd, m_uMsgBase + uIndex,
						 (WPARAM)(ITFSThreadHandler *)m_spHandler, lParam);
}

/*---------------------------------------------------------------------------
	CNodeTimerQueryObject implementation
 ---------------------------------------------------------------------------*/
HRESULT 
CNodeTimerQueryObject::Execute()
{

  	while (WaitForSingleObjectEx(m_hEventAbort, GetTimerInterval(), FALSE) != WAIT_OBJECT_0)
    {
        // we timed out.  Post a message to the ComponentData...
        AddToQueue(NULL, QDATA_TIMER);
    }

//  Trace0("CNodeTimerQueryObject::Execute - got abort event, exiting.\n");

    return hrFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\objplus.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#define OEMRESOURCE
#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>

#include "objplus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CObjHelper :: CObjHelper ()
  : m_ctor_err( 0 ),
    m_api_err( 0 ),
    m_b_dirty( FALSE ),
    m_time_created( ::GetCurrentTime() )
{
}


void CObjHelper :: ReportError ( LONG errInConstruction )
{
    Trace1("CObjectPlus construction failure, error = %d", errInConstruction);
    m_ctor_err = errInConstruction ;
}

LONG CObjHelper :: SetApiErr ( LONG errApi )
{
    return m_api_err = errApi ;
}

void CObjHelper :: AssertValid () const
{
    ASSERT( QueryError() == 0 ) ;
}

BOOL CObjHelper :: IsValid () const
{
    return QueryError() == 0 ;
}

DWORD CObjHelper :: QueryAge () const
{
    DWORD dwTime = ::GetCurrentTime(),
          dwDiff ;
    if ( dwTime < m_time_created )
    {
        dwDiff = dwTime + (((DWORD) -1) - (m_time_created - 1)) ;   
    }
    else
    {
        dwDiff = dwTime - m_time_created ;
    }

    return dwDiff ;
}


    //  Constructor of extended object
CObjectPlus :: CObjectPlus ()
{
}

    //  Compare one object with another:  default implementation
    //  orders objects by creation time.  Return -1, 0 or 1.

int CObjectPlus :: Compare ( const CObjectPlus * pob ) const
{
    return QueryCreationTime() < pob->QueryCreationTime()
     ? -1
     : QueryCreationTime() != pob->QueryCreationTime() ;
}

CObListIter :: CObListIter ( const CObOwnedList & obList )
    : m_obList( obList )
{
    Reset() ;
}

void CObListIter :: Reset ()
{
    m_pos = m_obList.GetCount() ? m_obList.GetHeadPosition() : NULL ;
}

CObject * CObListIter :: Next ()
{
    return m_pos == NULL
     ? NULL
     : m_obList.GetNext( m_pos ) ;
}

//
//  Subclass of CObList whose default behavior is to destroy
//    its contents during its own destruction
//
CObOwnedList :: CObOwnedList ( int nBlockSize )
    : CObList( nBlockSize ),
    m_b_owned( TRUE )
{
}

CObOwnedList :: ~ CObOwnedList ()
{
    RemoveAll() ;
}

void CObOwnedList :: RemoveAll ()
{
    if ( m_b_owned )
    {
        //
        //  Remove and discard all the objects
        //
        while ( ! IsEmpty() )
        {
            CObject * pob = RemoveHead() ;
            delete pob ;
        }
    }
    else
    {
        //  Just remove the object pointers
        CObList::RemoveAll() ;
    }
}

CObject * CObOwnedList :: Index ( int index )
{
   CObListIter oli( *this ) ;

   CObject * pob ;

   for ( int i = 0 ; (pob = oli.Next()) && i++ < index ; ) ;

   return pob ;
}

CObject * CObOwnedList :: RemoveIndex ( int index )
{
   POSITION pos ;
   CObListIter oli( *this ) ;
   int i ;
   CObject * pob ;

   for ( i = 0, pos = oli.QueryPosition() ;
     (pob = oli.Next()) && i < index ;
     i++, pos = oli.QueryPosition() ) ;

   if ( pob && i == index )
   {
        RemoveAt( pos ) ;
   }
   else
   {
        pob = NULL ;
   }
   return pob ;
}

    //  Remove the first (and hopefully only) occurrence of an object
    //  pointer from this list.
BOOL CObOwnedList :: Remove ( CObject * pob )
{
    POSITION pos = Find( pob ) ;

    if ( pos == NULL )
    return FALSE ;

    RemoveAt( pos ) ;
    return TRUE ;
}

    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
BOOL CObOwnedList :: SetAll ( BOOL bDirty )
{
    int cDirtyItems = 0 ;
    CObListIter oli( *this ) ;
    CObjectPlus * pob ;

    while ( pob = (CObjectPlus *) oli.Next() )
    {
        cDirtyItems += pob->IsDirty() ;
        pob->SetDirty( bDirty ) ;
    }
    SetDirty( bDirty );

    return cDirtyItems > 0 ;
}


int CObOwnedList :: FindElement ( CObject * pobSought ) const
{
   CObListIter oli( *this ) ;
   CObject * pob ;

   for ( int i = 0 ;
     (pob = oli.Next()) && pob != pobSought ;
     i++ ) ;

   return pob ? i : -1 ;
}

    //  Override of CObList::AddTail() to control exception handling.
    //  Returns NULL if addition fails.

POSITION CObOwnedList :: AddTail (
    CObjectPlus * pobj,
    BOOL bThrowException )
{
    POSITION pos = NULL ;

    //  Catch only memory exceptions.
    TRY
    {
        pos = CObList::AddTail( pobj ) ;
    }
    CATCH( CMemoryException, e )
    {
        pos = NULL ;
    }
    END_CATCH

    if ( pos == NULL && bThrowException )
    {
        //  CObList::AddTail() threw an exception. Echo it.
        AfxThrowMemoryException() ;
    }
    return pos ;
}


typedef struct
{
    CObjectPlus * pObj ;            // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc ;  // Pointer to ordering function
} CBOWNEDLIST_SORT_HELPER ;

    //  This static member function is used to quick sort an array of structures
    //  as declared above.  Each element contains the object pointer and a
    //  pointer to the object's member function to be invoked for comparison.

//int CDECL CObOwnedList :: SortHelper (
int _cdecl CObOwnedList :: SortHelper (
    const void * pa,
    const void * pb 
    )
{
    CBOWNEDLIST_SORT_HELPER
    * pHelp1 = (CBOWNEDLIST_SORT_HELPER *) pa,
    * pHelp2 = (CBOWNEDLIST_SORT_HELPER *) pb ;

    return (pHelp1->pObj->*pHelp1->pFunc)( pHelp2->pObj ) ;
}

    //  Sort the list by recreating it entirely.

LONG CObOwnedList :: Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc )
{
    LONG err = 0 ;
    int cItems = (int)GetCount() ;

    if ( cItems < 2 )
    return NO_ERROR ;

    CObListIter obli( *this ) ;
    CObjectPlus * pObNext ;
    BOOL bOwned = SetOwnership( FALSE ) ;
    int i ;

    CBOWNEDLIST_SORT_HELPER * paSortHelpers = NULL ;

    CATCH_MEM_EXCEPTION
    {
    //  Allocate the helper array
    paSortHelpers = new CBOWNEDLIST_SORT_HELPER[ cItems ] ;

    /// Fill the helper array.
    for ( i = 0 ; pObNext = (CObjectPlus *) obli.Next() ; i++ )
    {
        paSortHelpers[i].pFunc = pOrderFunc ;
        paSortHelpers[i].pObj = pObNext ;
    }

    //  Release all object pointer references.  Note that we
    //  forced "owned" to FALSE above.
    RemoveAll() ;

    ASSERT( GetCount() == 0 ) ;

    //  Sort the helper array
    ::qsort( (void *) paSortHelpers,
         cItems,
         sizeof paSortHelpers[0],
         SortHelper ) ;

    //  Refill the list from the helper array.
    for ( i = 0 ; i < cItems ; i++ )
    {
        AddTail( paSortHelpers[i].pObj ) ;
    }

    ASSERT( GetCount() == cItems ) ;
    }
    END_MEM_EXCEPTION(err)

    //  Delete the working array
    delete [] paSortHelpers ;

    //  Restore the object ownership state
    SetOwnership( bOwned ) ;

    return err ;
}

//
//  Subclass of CObArray whose default behavior is to destroy
//    its contents during its own destruction
//
CObOwnedArray :: CObOwnedArray ()
    : CObArray(),
    m_b_owned( TRUE )
{
}
             
CObOwnedArray :: ~ CObOwnedArray ()
{
    RemoveAll() ;
}

void CObOwnedArray :: RemoveAll ()
{
    if ( m_b_owned )
    {
        int i, nElements;

        nElements = (int)GetSize();
        for (i = 0; i < nElements; ++i)
        {
            delete (CObject *)GetAt(i) ;
        }
    }
    //
    //  Just remove the object pointers
    //
    CObArray::RemoveAll() ;
}     



void
CObOwnedArray :: RemoveAt ( 
    int nIndex,
    int nCount
    )
{
    for (int i = 0; i < nCount; ++i)
    {
        delete (CObject *)GetAt(nIndex) ;
    }

    CObArray::RemoveAt(nIndex, nCount);
}


//
//  Set all elements to dirty or clean.  Return TRUE if
//  any element was dirty.
//
BOOL 
CObOwnedArray :: SetAll ( 
    BOOL bDirty 
    )
{
    int cDirtyItems = 0 ;
    CObjectPlus * pob ;
    int i;

    int nElements = (int)GetSize();

    for (i = 0; i < nElements; ++i)
    {
        pob = (CObjectPlus *)GetAt(i);
        cDirtyItems += pob->IsDirty() ;
        pob->SetDirty( bDirty ) ;
    }

    SetDirty( bDirty );

    return cDirtyItems > 0 ;
}


int 
CObOwnedArray :: FindElement ( 
    CObject * pobSought 
    ) const
{
    CObject * pob ;
    int i;
    int nElements = (int)GetSize();

    for ( i = 0, pob = NULL; i < nElements && pob != pobSought; ++i)
    {
        pob = (CObject *)GetAt(i);
    }

    return i < nElements ? i : -1 ;
}

void
CObOwnedArray :: Swap(
    int nIndx1,
    int nIndx2
    )
{
    CObject * pTmp = GetAt(nIndx1);
    SetAt(nIndx1, GetAt(nIndx2));
    SetAt(nIndx2, pTmp);
}

//
// This sort is pretty slow.  Why?
//

void
CObOwnedArray :: QuickSort(
    int nLow,
    int nHigh,    
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    int nUp, nDown;
    CObjectPlus * pBreak;

    if (nLow < nHigh)
    {
        if((nHigh - nLow) == 1) 
        {
            if (((CObjectPlus *)GetAt(nLow)->*pOrderFunc)((CObjectPlus *)GetAt(nHigh)) > 0)
            {
                Swap(nLow, nHigh);
            }
        }
        else 
        {
            pBreak = (CObjectPlus *)GetAt(nHigh);
            do 
            {
                nUp = nLow;
                nDown = nHigh;
                while(nUp < nDown && ((CObjectPlus *)GetAt(nUp)->*pOrderFunc)(pBreak) <= 0)
                {
                    ++nUp;
                }
                while(nDown > nUp && ((CObjectPlus *)GetAt(nDown)->*pOrderFunc)(pBreak) >= 0)
                {
                    --nDown;
                }
                if (nUp < nDown)
                {
                    Swap(nUp, nDown);
                }
            } while (nUp < nDown);

            Swap(nUp, nHigh);
            if ((nUp - nLow) < (nHigh - nUp) ) 
            {
                QuickSort(nLow, nUp - 1, pOrderFunc);
                QuickSort(nUp + 1, nHigh, pOrderFunc);
            }
            else 
            {
                QuickSort(nUp + 1, nHigh, pOrderFunc);
                QuickSort(nLow, nUp - 1, pOrderFunc);
            }
        }
    }
}

/*
LONG 
CObOwnedArray :: Sort ( 
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    LONG err = 0 ;
    int cItems = GetSize() ;

    if ( cItems < 2 )   
    {
        return NO_ERROR ;
    }
    
    QuickSort(0, GetUpperBound(), pOrderFunc);    

    return 0;
}
*/

typedef struct
{
    CObjectPlus * pObj ;            // Pointer to object to be sorted
    CObjectPlus::PCOBJPLUS_ORDER_FUNC  pFunc ;  // Pointer to ordering function
} CBOWNEDARRAY_SORT_HELPER ;

    //  This static member function is used to quick sort an array of structures
    //  as declared above.  Each element contains the object pointer and a
    //  pointer to the object's member function to be invoked for comparison.

//int CDECL CObOwnedArray :: SortHelper (
int _cdecl CObOwnedArray :: SortHelper (
    const void * pa,
    const void * pb 
    )
{
    CBOWNEDARRAY_SORT_HELPER
    * pHelp1 = (CBOWNEDARRAY_SORT_HELPER *) pa,
    * pHelp2 = (CBOWNEDARRAY_SORT_HELPER *) pb ;

    return (pHelp1->pObj->*pHelp1->pFunc)( pHelp2->pObj ) ;
}

    //  Sort the list by recreating it entirely.

LONG 
CObOwnedArray :: Sort ( 
    CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc 
    )
{
    LONG err = 0 ;
    int cItems = (int)GetSize() ;

    if ( cItems < 2 )
    {
        return NO_ERROR ;
    }

    CObjectPlus * pObNext ;
    BOOL bOwned = SetOwnership( FALSE ) ;
    int i ;

    CBOWNEDARRAY_SORT_HELPER * paSortHelpers = NULL ;

    CATCH_MEM_EXCEPTION
    {
        //  Allocate the helper array
        paSortHelpers = new CBOWNEDARRAY_SORT_HELPER[ cItems ] ;

        /// Fill the helper array.
        for ( i = 0 ; i < cItems ; ++i )
        {
            pObNext = (CObjectPlus *) GetAt(i);
            paSortHelpers[i].pFunc = pOrderFunc ;
            paSortHelpers[i].pObj = pObNext ;
        }

        //  Release all object pointer references.  Note that we
        //  forced "owned" to FALSE above.
        RemoveAll() ;

        ASSERT( GetSize() == 0 ) ;

        //  Sort the helper array
        ::qsort( (void *) paSortHelpers,
             cItems,
            sizeof paSortHelpers[0],
            SortHelper ) ;

        //  Refill the list from the helper array.
        for ( i = 0 ; i < cItems ; i++ )
        {
            Add( paSortHelpers[i].pObj ) ;
        }

        ASSERT( GetSize() == cItems ) ;
    }
    END_MEM_EXCEPTION(err)

    //  Delete the working array
    delete [] paSortHelpers ;

    //  Restore the object ownership state
    SetOwnership( bOwned ) ;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\proppage.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    proppage.cpp
        Implementation for property pages in MMC

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dialog.h"   // for FixupIpAddressHelp

#include <prsht.h>

#ifdef DEBUG_ALLOCATOR
	#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE[] = __FILE__;
	#endif
#endif

//////////////////////////////////////////////////////////////////////////
// private helper functions

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								LPARAM lParam /* pass a HWND* for return value*/ )
{
	Assert(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	else if(hParentWnd)
	{
		HWND	hGrandParentWnd = GetParent(hParentWnd);
		// the main window of the MMC console should staitsfy this condition
		if ( ((hGrandParentWnd == GetDesktopWindow()) || (hGrandParentWnd == NULL))  && IsWindowVisible(hParentWnd) )
		{
			HWND* pH = (HWND*)lParam;
			*pH = hParentWnd;
			return FALSE; // stop enumerating
		}
	}
	return TRUE;
}
 


HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	Assert(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
	Assert(hWnd != NULL);
	return hWnd;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyPageHolderBase

CPropertyPageHolderBase::CPropertyPageHolderBase
(
	ITFSNode *		pNode,
	IComponentData *pComponentData,
	LPCTSTR			pszSheetName,
	BOOL			bIsScopePane
)
{
	m_stSheetTitle = pszSheetName;

	// default setting for a self deleting modeless property sheet,
	// automatically deleting all the pages
	m_bWizardMode = TRUE;
	m_bAutoDelete = TRUE;
	m_bAutoDeletePages = TRUE;

	m_nCreatedCount = 0; 
	m_hSheetWindow = NULL;
	m_hConsoleHandle = 0; 
	m_hEventHandle = NULL;
	m_bCalledFromConsole = FALSE;

	m_cDirty = 0;

	// setup from arguments
	SetNode(pNode);
	
	//Assert(pComponentData != NULL);
	m_spComponentData.Set(pComponentData);

	m_pPropChangePage = NULL;
	m_dwLastErr = 0;

    m_bSheetPosSet = FALSE;

    m_bIsScopePane = bIsScopePane;
	m_hThread = NULL;

    m_bWiz97 = FALSE;

	m_bTheme = FALSE;

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
    m_bPeekMessageDuringNotifyConsole = FALSE;
	m_fSetDefaultSheetPos = TRUE;
    m_bProcessingNotifyConsole = FALSE;
}

CPropertyPageHolderBase::CPropertyPageHolderBase
(
	ITFSNode *		pNode,
	IComponent *    pComponent,
	LPCTSTR			pszSheetName,
	BOOL			bIsScopePane
)
{
	m_stSheetTitle = pszSheetName;

	// default setting for a self deleting modeless property sheet,
	// automatically deleting all the pages
	m_bWizardMode = TRUE;
	m_bAutoDelete = TRUE;
	m_bAutoDeletePages = TRUE;

	m_nCreatedCount = 0; 
	m_hSheetWindow = NULL;
	m_hConsoleHandle = 0; 
	m_hEventHandle = NULL;
	m_bCalledFromConsole = FALSE;

	m_cDirty = 0;

	// setup from arguments
	SetNode(pNode);
	
	m_spComponent.Set(pComponent);

	m_pPropChangePage = NULL;
	m_dwLastErr = 0;

    m_bSheetPosSet = FALSE;

    m_bIsScopePane = bIsScopePane;
	m_hThread = NULL;

    m_bWiz97 = FALSE;

	// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
    m_bPeekMessageDuringNotifyConsole = FALSE;
    m_bProcessingNotifyConsole = FALSE;
}

CPropertyPageHolderBase::~CPropertyPageHolderBase()
{
// Remove this assert, we could be dirty if we cancelled the page
//	Assert(m_cDirty == 0);
	FinalDestruct();
	m_spSheetCallback.Release();
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
	if ( NULL != m_hThread ) {
	    VERIFY( ::CloseHandle( m_hThread ));
	    m_hThread = NULL;
	}
}


HRESULT 
CPropertyPageHolderBase::CreateModelessSheet
(
	LPPROPERTYSHEETCALLBACK pSheetCallback, 
	LONG_PTR				hConsoleHandle
)
{
	Assert(pSheetCallback != NULL);
	Assert(m_spSheetCallback == NULL);

	Assert( (hConsoleHandle  != NULL) && (m_hConsoleHandle == NULL) );
	m_hConsoleHandle = hConsoleHandle;

	m_bCalledFromConsole = TRUE;
	m_bWizardMode = FALSE; // we go modeless
	
	// notify the node it has a sheet up
	int nMessage = m_bIsScopePane ? TFS_NOTIFY_CREATEPROPSHEET : 
									TFS_NOTIFY_RESULT_CREATEPROPSHEET;
	if (m_spNode)
		m_spNode->Notify(nMessage, (LPARAM) this);

	// temporarily attach the sheet callback to this object to add pages
	// do not addref, we will not hold on to it;
	m_spSheetCallback = pSheetCallback;
	
	HRESULT hr = AddAllPagesToSheet();
	m_spSheetCallback.Transfer(); // detach
	return hr;
}

HRESULT 
CPropertyPageHolderBase::DoModelessSheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIPropertySheetCallback	spSheetCallback;
	SPIConsole					spConsole;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd;
	int							nMessage;

	m_bWizardMode = FALSE;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    
    Assert(spSheetProvider != NULL);

	// get an interface to a sheet callback
	CORg( spSheetCallback.HrQuery(spSheetProvider) );
	
    Assert(spSheetCallback != NULL);

	m_spSheetCallback.Set(spSheetCallback); // save to add/remove pages
	
	// create a data object for this node
	cookie = m_spNode->GetData(TFS_DATA_COOKIE);

    if (m_bIsScopePane)
    {
	    CORg( m_spComponentData->QueryDataObject(cookie, CCT_SCOPE, &spDataObject) );
	    Assert(spDataObject != NULL);
    }
    else
    {
	    CORg( m_spComponent->QueryDataObject(cookie, CCT_RESULT, &spDataObject) );
	    Assert(spDataObject != NULL);
    }

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(m_stSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages to sheet
	CORg( AddAllPagesToSheet() );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	if (m_bIsScopePane)
    {
        //Assert(m_spComponentData != NULL);
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, TRUE) );
    }
    else
    {
        //Assert(m_spComponent != NULL);
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, FALSE) );
    }

	spSheetProvider->AddExtensionPages();
	
	// for further dynamic page manipulation, don't use the Console's
	// sheet callback interface but resurt to the Win32 API's
	m_spSheetCallback.Release();
	
	hWnd = ::FindMMCMainWindow();
	Assert(hWnd != NULL);
	
    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

    // notify the node it has a sheet up
	nMessage = m_bIsScopePane ? TFS_NOTIFY_CREATEPROPSHEET : 
								TFS_NOTIFY_RESULT_CREATEPROPSHEET;
	m_spNode->Notify(nMessage, (LPARAM) this);

Error:
	return hr;
}

// use this function for property pages on the scope pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *       pNode,
										   IComponentData * pComponentData,
										   LPCTSTR	        pszSheetTitle)
{
	Assert(pComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd = NULL;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    Assert(spSheetProvider != NULL);

	// create a data object for this node
    cookie = pNode->GetData(TFS_DATA_COOKIE);
	CORg( pComponentData->QueryDataObject(cookie, CCT_SCOPE, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(pszSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	// This needs to be fixed.  Right now it only works if there is 
    // one view of the snapin.
    //
    // As of 5/21/99, we no longer need to do this.
    // ----------------------------------------------------------------
    // hWnd = ::FindMMCMainWindow();
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MDIClient", NULL); 
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MMCChildFrm", NULL); 
    // hWnd = ::FindWindowEx(hWnd, NULL, L"MMCView", NULL); 
    // Assert(hWnd != NULL);

	CORg( spSheetProvider->AddPrimaryPages(pComponentData, TRUE, hWnd, TRUE) );

	spSheetProvider->AddExtensionPages();

    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

Error:
	return hr;
}

// Use this function for property pages on the result pane
HRESULT DoPropertiesOurselvesSinceMMCSucks(ITFSNode *   pNode,
										   IComponent * pComponent,
										   LPCTSTR	    pszSheetTitle,
                                           int          nVirtualIndex)
{
	Assert(pComponent != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPIDataObject				spDataObject;
	MMC_COOKIE						cookie;
	HRESULT						hr = hrOK;
	HWND						hWnd;

	// get an interface to a sheet provider
    CORg (::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
           IID_IPropertySheetProvider, reinterpret_cast<void **>(&spSheetProvider)));
    Assert(spSheetProvider != NULL);

	// create a data object for this node
	if (nVirtualIndex == -1)
    {
        cookie = pNode->GetData(TFS_DATA_COOKIE);
    }
    else
    {
        cookie = nVirtualIndex;
    }

	CORg( pComponent->QueryDataObject(cookie, CCT_RESULT, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    // CODEWORK: ericdav -- need to possible set options flag -- 0 for now
    CORg( spSheetProvider->CreatePropertySheet(pszSheetTitle,
								TRUE /* prop page */, cookie, spDataObject, 0) );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle,
	//				HWND hNotifyWindow, BOOL bScopePane);
	// This needs to be fixed.  Right now it only works if there is 
    // one view of the snapin.
    hWnd = ::FindMMCMainWindow();
	hWnd = ::FindWindowEx(hWnd, NULL, L"MDIClient", NULL); 
	hWnd = ::FindWindowEx(hWnd, NULL, L"MMCChildFrm", NULL); 
	hWnd = ::FindWindowEx(hWnd, NULL, L"MMCView", NULL); 
	Assert(hWnd != NULL);

	CORg( spSheetProvider->AddPrimaryPages(pComponent, TRUE, hWnd, FALSE) );

	spSheetProvider->AddExtensionPages();

    CORg( spSheetProvider->Show((LONG_PTR) hWnd, 0) );

Error:
	return hr;
}


HRESULT 
CPropertyPageHolderBase::DoModalWizard()
{
	Assert(m_spComponentData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIPropertySheetProvider	spSheetProvider;
	SPITFSComponentData			spTFSCompData;
	SPIConsole					spConsole;
	SPIPropertySheetCallback	spSheetCallback;
	SPIDataObject				spDataObject;
	HRESULT						hr = hrOK;
	HWND						hWnd;
	MMC_COOKIE					cookie;
    DWORD                       dwOptions = 0;

	m_bWizardMode = TRUE;

	CORg( spTFSCompData.HrQuery(m_spComponentData) );
	CORg( spTFSCompData->GetConsole(&spConsole) );

	// get an interface to a sheet provider
	CORg( spSheetProvider.HrQuery(spConsole) );
	Assert(spSheetProvider != NULL);

	// get an interface to a sheet callback
	CORg( spSheetCallback.HrQuery(spConsole) );
	Assert(spSheetCallback != NULL);

	m_spSheetCallback.Set(spSheetCallback); // save to add/remove pages

	// create a data object for this node
	cookie = m_spNode->GetData(TFS_DATA_COOKIE);
	
	// Create a dummy data object. AddPrimaryPages will call 
	// IextendPropertySheet2::QueryPagesFor() and
	// IextendPropertySheet2::CreatePropertyPages()
	// that will ignore the un-initialized data object
    CORg( m_spComponentData->QueryDataObject(-1, CCT_UNINITIALIZED, &spDataObject) );
	Assert(spDataObject != NULL);

	// create sheet
    dwOptions = (m_bWiz97) ? MMC_PSO_NEWWIZARDTYPE : 0;
    dwOptions &= ~PSH_WIZARDCONTEXTHELP;

    CORg( spSheetProvider->CreatePropertySheet( m_stSheetTitle, FALSE /* wizard*/, cookie, spDataObject, dwOptions) );

	// add pages to sheet
	CORg( AddAllPagesToSheet() );

	// add pages
	// HRESULT AddPrimaryPages(LPUNKNOWN lpUnknown, BOOL bCreateHandle, HWND hNotifyWindow, BOOL bScopePane);
	if (m_bWiz97)
        CORg( spSheetProvider->AddPrimaryPages(spTFSCompData, FALSE, NULL, FALSE) );
    else
        CORg( spSheetProvider->AddPrimaryPages(NULL, FALSE, NULL, FALSE) );


	// for further dynamic page manipulation, don't use the Console's sheet callback interface
	// but resurt to the Win32 API's
	m_spSheetCallback.Release();

	//hWnd = ::FindMMCMainWindow();
    // To Support scripting of the MMC console, we need to get the parent from either the
    // active window or the desktop...
    hWnd = ::GetActiveWindow();
    if (hWnd == NULL)
    {
        hWnd = GetDesktopWindow();
    }

	Assert(hWnd != NULL);
	CORg( spSheetProvider->Show((LONG_PTR)hWnd, 0) );
	
Error:
	return hr;
}


void 
CPropertyPageHolderBase::SetSheetWindow
(
	HWND hSheetWindow
)
{
	Assert(hSheetWindow != NULL);
	Assert( (m_hSheetWindow == NULL) || ((m_hSheetWindow == hSheetWindow)) );
	m_hSheetWindow = hSheetWindow;

	if (!m_hThread)
	{
		HANDLE hPseudohandle;
		
		hPseudohandle = GetCurrentThread();
		BOOL bRet = DuplicateHandle(GetCurrentProcess(), 
									 hPseudohandle,
									 GetCurrentProcess(),
									 &m_hThread,
									 0,
									 FALSE,
									 DUPLICATE_SAME_ACCESS);
		if (!bRet)
		{
			DWORD dwLastErr = GetLastError();
		}

		Trace1("PROPERTY PAGE HOLDER BASE - Thread ID = %lx\n", GetCurrentThreadId());
	}

    if (m_hSheetWindow && m_fSetDefaultSheetPos)
        SetDefaultSheetPos();

    // turn of context sensitive help in the wizard... for some reason
    // mmc turns it on and we don't want it
    if (m_bWizardMode && m_hSheetWindow)
    {
	 DWORD dwWindowStyle;
        CWnd * pWnd = CWnd::FromHandle(m_hSheetWindow);

        if (pWnd)
            pWnd->ModifyStyleEx(WS_EX_CONTEXTHELP, 0, 0);

        dwWindowStyle = GetWindowLong(m_hSheetWindow, GWL_STYLE);
        dwWindowStyle &= ~WS_SYSMENU;
        SetWindowLong(m_hSheetWindow, GWL_STYLE, dwWindowStyle);
    }
}

BOOL
CPropertyPageHolderBase::SetDefaultSheetPos() 
{
    HRESULT                 hr = hrOK;
    HWND                    hwndMMC;
    RECT                    rectSheet, rectMMC, rectWorkArea;
	SPITFSComponentData	    spTFSCompData;
	SPITFSComponent	        spTFSComponent;
	SPIConsole				spConsole;

    int nX, nY;

    if (m_bSheetPosSet)
        return TRUE;

	if (m_bIsScopePane)
    {
        CORg( spTFSCompData.HrQuery(m_spComponentData) );
    	Assert(spTFSCompData);
    	CORg( spTFSCompData->GetConsole(&spConsole) );
    }
    else
    {
        CORg( spTFSComponent.HrQuery(m_spComponent) );
    	Assert(spTFSComponent);
    	CORg( spTFSComponent->GetConsole(&spConsole) );
    }

    spConsole->GetMainWindow(&hwndMMC);
    
    // get the MMC window and the PropSheet
    if (!GetWindowRect(hwndMMC, &rectMMC))
        return FALSE;

    if (!GetWindowRect(m_hSheetWindow, &rectSheet))
        return FALSE;

    nX = rectMMC.left + (((rectMMC.right - rectMMC.left) - (rectSheet.right - rectSheet.left)) / 2);
    nY = rectMMC.top + (((rectMMC.bottom - rectMMC.top) - (rectSheet.bottom - rectSheet.top)) / 2);
    
    // now check to make sure we're visible
    SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);
    
    nX = (nX < 0) ? 1 : nX;
    nY = (nY < 0) ? 1 : nY;

    nX = (nX > (rectWorkArea.right - (rectSheet.right - rectSheet.left))) ? 
        (rectWorkArea.right - (rectSheet.right - rectSheet.left)) :
        nX;

    nY = (nY > (rectWorkArea.bottom - (rectSheet.bottom - rectSheet.top))) ? 
        (rectWorkArea.bottom - (rectSheet.bottom - rectSheet.top)) :
        nY;

    if (!SetWindowPos(m_hSheetWindow, HWND_TOP, nX, nY, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW))
        return FALSE;

    m_bSheetPosSet = TRUE;

Error:
    return hr == hrOK;
}

void 
CPropertyPageHolderBase::Release() 
{ 
	m_nCreatedCount--; 
	if ( m_bAutoDelete && (m_nCreatedCount == 0) )
		delete this;
}

void 
CPropertyPageHolderBase::ForceDestroy()
{
	Assert(!m_bWizardMode); // should never occur on modal wizard
	Assert(m_bAutoDelete); // should be self deleting sheet

	Assert(::IsWindow(m_hSheetWindow));

	HWND hSheetWindow = m_hSheetWindow;
	if (hSheetWindow != NULL)
	{
            // this message will cause the sheet to close all the pages,
            // and eventually the destruction of "this"
            VERIFY( 0 != ::SendNotifyMessage( hSheetWindow, WM_COMMAND, IDCANCEL, 0L ));
            VERIFY( 0 != ::SendNotifyMessage( hSheetWindow, WM_CLOSE, 0, 0L ));
	}
        else
	{
		// explicitely delete "this", there is no sheet created
		delete this;
                return;
	}
} // CPropertyPageHolderBase::ForceDestroy()

DWORD 
CPropertyPageHolderBase::NotifyConsole(CPropertyPageBase* pPage)
{
    MSG msg;

	Assert(m_spNode != NULL);
	if (m_bWizardMode)
	{
		Assert(m_hConsoleHandle == NULL);
		return 0;
	}
	
    //
    // If Ok is hit right after hitting Apply (i.e. before the processing 
    // for Apply has completed),
    // we will enter this function (as a result of DispatchMessage below)
    // before the NotifyConsole for Apply has completed. 
    // In this case we don't want to do any processing, because it will cause
    // an indefinite wait in WaitForSingleObject below. So return.
    if (m_bProcessingNotifyConsole == TRUE)
    {
        return 0;
    }

    m_bProcessingNotifyConsole = TRUE;
	m_pPropChangePage = pPage; // to pass to the main thread
	m_dwLastErr = 0x0;

	Assert(m_hConsoleHandle != NULL);
	if (m_hEventHandle == NULL)
	{
		m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
		Assert(m_hEventHandle != NULL);
	}
	
    MMCPropertyChangeNotify(m_hConsoleHandle, reinterpret_cast<LONG_PTR>(this));
	
    Trace0("before wait\n");
	while ( WAIT_OBJECT_0 != ::WaitForSingleObject(m_hEventHandle, 500) ) 
	{
		
		// by WeiJiang 5/11/98, PeekMessageDuringNotifyConsole flag
		if(m_bPeekMessageDuringNotifyConsole) 
		{	
	        // clean out the message queue while we wait
    	    while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
	}

	Trace0("after wait\n");
	VERIFY(0 != ::ResetEvent(m_hEventHandle));

    m_bProcessingNotifyConsole = FALSE;
	return m_dwLastErr;
}

void 
CPropertyPageHolderBase::AcknowledgeNotify()
{
	Assert(!m_bWizardMode);
	Assert(m_hEventHandle != NULL);
	Trace0("before SetEvent\n");
	VERIFY(0 != ::SetEvent(m_hEventHandle));
	Trace0("after SetEvent\n");
}


BOOL 
CPropertyPageHolderBase::SetWizardButtons
(
	DWORD dwFlags
)
{
	Assert(m_bWizardMode);
	Assert(::IsWindow(m_hSheetWindow));
	return (BOOL)SendMessage(m_hSheetWindow, PSM_SETWIZBUTTONS, 0, dwFlags);
}

BOOL
CPropertyPageHolderBase::PressButton
(
    int nButton
)
{
    Assert(m_bWizardMode);
    Assert(::IsWindow(m_hSheetWindow));
    return (BOOL) SendMessage(m_hSheetWindow, PSM_PRESSBUTTON, nButton, 0);
}

HRESULT 
CPropertyPageHolderBase::AddPageToSheet
(
	CPropertyPageBase* pPage
)
{
	// remove the help button
	if (m_bWiz97)
        pPage->m_psp97.dwFlags &= ~PSP_HASHELP;
    else
        pPage->m_psp.dwFlags &= ~PSP_HASHELP;

	// call the MMC function because we are using MFC based pages
	if (!m_bWizardMode)
	{
		// if we are doing a property sheet then tell MMC to hook
		// the proc because we are running on a separate, non MFC thread.
		// Wizards don't run on a separate thread and therefore
		// don't need to make this call.
		if (m_bWiz97)
           VERIFY(SUCCEEDED(MMCPropPageCallback(&pPage->m_psp97)));
        else
           VERIFY(SUCCEEDED(MMCPropPageCallback(&pPage->m_psp)));
	}

	HPROPSHEETPAGE hPage;

	if (m_bTheme)
	{
		PROPSHEETPAGE_LATEST pspLatest = {0};
		
		if (m_bWiz97)
		{
			CopyMemory(&pspLatest,
					&pPage->m_psp97,
					pPage->m_psp97.dwSize);
		}
		else
		{
			CopyMemory (&pspLatest, 
				&pPage->m_psp,
				pPage->m_psp.dwSize);
		}

		pspLatest.dwSize = sizeof(pspLatest);
		hPage = ::CreatePropertySheetPage(&pspLatest);
	}

	else
	{
		if (m_bWiz97)
			hPage = ::CreatePropertySheetPage(&pPage->m_psp97);
		else
			hPage = ::CreatePropertySheetPage(&pPage->m_psp);
		
	}
    
	if (hPage == NULL)
		return E_UNEXPECTED;
	pPage->m_hPage = hPage;

	if (m_spSheetCallback != NULL)
		return m_spSheetCallback->AddPage(hPage);
	else
	{
		Assert(::IsWindow(m_hSheetWindow));
		return PropSheet_AddPage(m_hSheetWindow, hPage) ? S_OK : E_FAIL;
	}
}

HRESULT 
CPropertyPageHolderBase::RemovePageFromSheet
(
	CPropertyPageBase* pPage
)
{
	Assert(pPage->m_hPage != NULL);
	if (m_spSheetCallback != NULL)
		return m_spSheetCallback->RemovePage(pPage->m_hPage);
	else
	{
		Assert(::IsWindow(m_hSheetWindow));
		return PropSheet_RemovePage(m_hSheetWindow, 0, pPage->m_hPage) ? S_OK : E_FAIL;
	}
}


HRESULT 
CPropertyPageHolderBase::AddAllPagesToSheet()
{
	POSITION pos;
	for( pos = m_pageList.GetHeadPosition(); pos != NULL; )
	{
		CPropertyPageBase* pPropPage = m_pageList.GetNext(pos);
		HRESULT hr = AddPageToSheet(pPropPage);
		Assert(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}


void 
CPropertyPageHolderBase::AddPageToList
(
	CPropertyPageBase* pPage
)
{
	Assert(pPage != NULL);
	pPage->SetHolder(this);
	m_pageList.AddTail(pPage);
}

BOOL 
CPropertyPageHolderBase::RemovePageFromList
(
	CPropertyPageBase*	pPage, 
	BOOL				bDeleteObject
)
{
	Assert(pPage != NULL);
	POSITION pos = m_pageList.Find(pPage);
	if (pos == NULL)
		return FALSE;
	m_pageList.RemoveAt(pos);
	if (bDeleteObject)
		delete pPage;
	return TRUE;
}


void 
CPropertyPageHolderBase::DeleteAllPages()
{
	if (!m_bAutoDeletePages)
		return;
	// assume all pages out of the heap
	while (!m_pageList.IsEmpty())
	{
		delete m_pageList.RemoveTail();
	}
}

void 
CPropertyPageHolderBase::FinalDestruct()
{
	DeleteAllPages();
	if (m_bWizardMode)
		return;

	// if we were a modeless sheet, have to cleanup
	if (m_bCalledFromConsole)
	{
		Assert(m_hConsoleHandle != NULL);
		MMCFreeNotifyHandle(m_hConsoleHandle);

	}

	// Notify the node that this sheet is going away
	//
	int nMessage = m_bIsScopePane
            ? TFS_NOTIFY_DELETEPROPSHEET
            : TFS_NOTIFY_RESULT_DELETEPROPSHEET;
	if (m_spNode)
	{
            m_spNode->Notify(nMessage, (LPARAM) this);
	}
}

HWND
CPropertyPageHolderBase::SetActiveWindow()
{
	return ::SetActiveWindow(m_hSheetWindow);
}

BOOL CPropertyPageHolderBase::OnPropertyChange(BOOL bScopePane, LONG_PTR * pChangeMask)
{ 
	ASSERT(!IsWizardMode());
	CPropertyPageBase* pPage = GetPropChangePage();
	if (pPage == NULL)
		return FALSE;
	return pPage->OnPropertyChange(bScopePane, pChangeMask);
}

/////////////////////////////////////////////////////////////////////////////
// CPropertyPageBase

IMPLEMENT_DYNCREATE(CPropertyPageBase, CPropertyPage)

BEGIN_MESSAGE_MAP(CPropertyPageBase, CPropertyPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
// help overrides
    ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()


CPropertyPageBase::CPropertyPageBase
(
	UINT nIDTemplate, 
	UINT nIDCaption
) :	CPropertyPage(nIDTemplate, nIDCaption)
{
	m_hPage = NULL;
	m_pPageHolder = NULL;
	m_bIsDirty = FALSE;
}


CPropertyPageBase::~CPropertyPageBase()
{

}

int 
CPropertyPageBase::OnCreate
(
	LPCREATESTRUCT lpCreateStruct
)	
{
    if (m_pPageHolder)
        m_pPageHolder->AddRef();
	
    int res = CPropertyPage::OnCreate(lpCreateStruct);
	Assert(res == 0);
	Assert(m_hWnd != NULL);
	Assert(::IsWindow(m_hWnd));
	
    HWND hParent = ::GetParent(m_hWnd);
	Assert(hParent);
	
    if (m_pPageHolder)
        m_pPageHolder->SetSheetWindow(hParent);
	
    return res;
}

void 
CPropertyPageBase::OnDestroy() 
{
	Assert(m_hWnd != NULL);
    
    CPropertyPage::OnDestroy();
	
    if (m_pPageHolder)
        m_pPageHolder->Release();
}

BOOL 
CPropertyPageBase::OnApply()
{
	if (IsDirty())
	{
        if (!m_pPageHolder ||
            m_pPageHolder->NotifyConsole(this) == 0x0)
		{
			SetDirty(FALSE);
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	
	return TRUE;
}

void CPropertyPageBase::CancelApply()
{
	if (m_pPageHolder)
		m_pPageHolder->NotifyConsole(this);
}

// NOTE:  This function must be called for all wizard 97 pages.
//        Since there are different sizes of the psp struct, depending
//        on how the project was compiled (common lib is compiled with 
//        the wiz97 propsheet header and the snapin directory may not)
//        this function should only be called when running wizard 97 pages.
//        This allows us to have snapins that use the same code for both
//        old and new style wizards.
void CPropertyPageBase::InitWiz97(BOOL bHideHeader, 
								  UINT nIDHeaderTitle, 
								  UINT nIDHeaderSubTitle)
{
    // hack to have new struct size with old MFC and new NT 5.0 headers
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
	memcpy(&m_psp97, &m_psp, m_psp.dwSize);
	m_psp97.dwSize = sizeof(PROPSHEETPAGE);

    if (bHideHeader)
	{
		// for first and last page of the wizard
		m_psp97.dwFlags |= PSP_HIDEHEADER;
	}
	else
	{
		// for intermediate pages
		AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_szHeaderTitle.LoadString(nIDHeaderTitle);
		m_szHeaderSubTitle.LoadString(nIDHeaderSubTitle);

		m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
		m_psp97.pszHeaderTitle = (LPCTSTR)m_szHeaderTitle;
		m_psp97.pszHeaderSubTitle = (LPCTSTR)m_szHeaderSubTitle;
	}
}

/*!--------------------------------------------------------------------------
	CPropertyPageBase::OnHelpInfo
		Brings up the context-sensitive help for the controls.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL CPropertyPageBase::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	int		i;
	DWORD	dwCtrlId;

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		DWORD * pdwHelp = GetHelpMapInternal();

        if (pdwHelp)
        {
		    // Ok to fix the f**king help for the f**king IP address
		    // controls, we will need to add special case code.  If we
		    // can't find the id of our control in our list, then we look
		    // to see if this is the child of the "RtrIpAddress" control, if
		    // so then we change the pHelpInfo->hItemHandle to point to the
		    // handle of the ip address control rather than the control in
		    // the ip addrss control.  *SIGH*
		    dwCtrlId = ::GetDlgCtrlID((HWND) pHelpInfo->hItemHandle);
		    for (i=0; pdwHelp[i]; i+=2)
		    {
			    if (pdwHelp[i] == dwCtrlId)
				    break;
		    }

		    if (pdwHelp[i] == 0)
		    {
			    // Ok, we didn't find the control in our list, so let's
			    // check to see if it's part of the IP address control.
			    pHelpInfo->hItemHandle = FixupIpAddressHelp((HWND) pHelpInfo->hItemHandle);
		    }

            ::WinHelp ((HWND)pHelpInfo->hItemHandle,
			           AfxGetApp()->m_pszHelpFilePath,
			           HELP_WM_HELP,
			           (ULONG_PTR)pdwHelp);
        }
	}
	
	return TRUE;
}


/*!--------------------------------------------------------------------------
	CBaseDialog::OnContextMenu
		Brings up the help context menu for those controls that don't
		usually have context menus (i.e. buttons).  Note that this won't
		work for static controls since they just eat up all messages.
	Author: KennT
 ---------------------------------------------------------------------------*/
void CPropertyPageBase::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

   DWORD * pdwHelp = GetHelpMapInternal();

    if (pdwHelp)
    {
        ::WinHelp (pWnd->m_hWnd,
		           AfxGetApp()->m_pszHelpFilePath,
		           HELP_CONTEXTMENU,
		           (ULONG_PTR)pdwHelp);
    }
}


// This can be found in dialog.cpp
extern PFN_FINDHELPMAP	g_pfnHelpMap;


DWORD * CPropertyPageBase::GetHelpMapInternal()
{
	DWORD	*	pdwHelpMap = NULL;
	DWORD		dwIDD = 0;

	if ((ULONG_PTR) m_lpszTemplateName < 0xFFFF)
		dwIDD = (WORD) m_lpszTemplateName;
	
	// If there is no dialog IDD, give up
	// If there is no global help map function, give up
	if ((dwIDD == 0) ||
		(g_pfnHelpMap == NULL) ||
		((pdwHelpMap = g_pfnHelpMap(dwIDD)) == NULL))
		return GetHelpMap();

	return pdwHelpMap;
}


struct EnableChildControlsEnumParam
{
	HWND	m_hWndParent;
	DWORD	m_dwFlags;
};

BOOL CALLBACK EnableChildControlsEnumProc(HWND hWnd, LPARAM lParam)
{
	EnableChildControlsEnumParam *	pParam;

	pParam = reinterpret_cast<EnableChildControlsEnumParam *>(lParam);

	// Enable/disable only if this is an immediate descendent
	if (GetParent(hWnd) == pParam->m_hWndParent)
	{
		if (pParam->m_dwFlags & PROPPAGE_CHILD_SHOW)
			::ShowWindow(hWnd, SW_SHOW);
		else if (pParam->m_dwFlags & PROPPAGE_CHILD_HIDE)
			::ShowWindow(hWnd, SW_HIDE);

		if (pParam->m_dwFlags & PROPPAGE_CHILD_ENABLE)
			::EnableWindow(hWnd, TRUE);
		else if (pParam->m_dwFlags & PROPPAGE_CHILD_DISABLE)
			::EnableWindow(hWnd, FALSE);
	}
	return TRUE;
}

HRESULT EnableChildControls(HWND hWnd, DWORD dwFlags)
{
	EnableChildControlsEnumParam	param;

	param.m_hWndParent = hWnd;
	param.m_dwFlags = dwFlags;
	
	EnumChildWindows(hWnd, EnableChildControlsEnumProc, (LPARAM) &param);
	return hrOK;
}

HRESULT MultiEnableWindow(HWND hWndParent, BOOL fEnable, UINT first, ...)
{
	UINT	nCtrlId = first;
	HWND	hWndCtrl;
	
	va_list	marker;

	va_start(marker, first);

	while (nCtrlId != 0)
	{
		hWndCtrl = ::GetDlgItem(hWndParent, nCtrlId);
		Assert(hWndCtrl);
		if (hWndCtrl)
			::EnableWindow(hWndCtrl, fEnable);

		// get the next item
		nCtrlId = va_arg(marker, UINT);
	}

	
	va_end(marker);

	return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\snapbase.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    snapbase.h
	Common header file included by all snapins derived 
		from these base classes

    FILE HISTORY:
	
*/

const long UNINITIALIZED = -1;

/////////////////////////////////////////////////////////////////////////////
// Helper functions

#include <dbgutil.h>
#include <std.h>
#include <errutil.h>

#include <ipaddr.h>
#include "ipaddr.hpp"
#include "dataobj.h"
#include "compont.h"
#include "proppage.h"
#include "about.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by common.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        222
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         332
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\objplus.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1997 **/
/**********************************************************************/

/*
    FILE HISTORY:

*/

#ifndef _OBJPLUS_H_
#define _OBJPLUS_H_

//
//  Forward declarations
//
class CObjHelper ;
class CObjectPlus ;
class CObOwnedList ;
class CObListIter ;
class CObOwnedArray ;

//
//  Wrappers for the *BROKEN* C8 TRY/CATCH stuff
//
#define CATCH_MEM_EXCEPTION             \
    TRY

#define END_MEM_EXCEPTION(err)          \
    CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

/****************************************************************************
DEBUGAFX.H
****************************************************************************/

//
//  ENUM for special debug output control tokens
//
enum ENUM_DEBUG_AFX { EDBUG_AFX_EOL = -1 } ;

#if defined(_DEBUG)
   #define TRACEFMTPGM      DbgFmtPgm( THIS_FILE, __LINE__ )
   #define TRACEOUT(x)      { afxDump << x ; }
   #define TRACEEOL(x)      { afxDump << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLID(x)    { afxDump << TRACEFMTPGM << x << EDBUG_AFX_EOL ; }
   #define TRACEEOLERR(err,x)   { if (err) TRACEEOLID(x) }

#else
   #define TRACEOUT(x)      { ; }
   #define TRACEEOL(x)      { ; }
   #define TRACEEOLID(x)    { ; }
   #define TRACEEOLERR(err,x)   { ; }
#endif

//
//  Append an EOL onto the debug output stream
//
CDumpContext & operator << ( CDumpContext & out, ENUM_DEBUG_AFX edAfx ) ;

//
//  Format a program name and line number for output (removes the path info)
//
extern const char * DbgFmtPgm ( const char * szFn, int line ) ;

/****************************************************************************
OBJPLUS.H
****************************************************************************/

//
//  Helper class for control of construction and API errors
//
class CObjHelper
{
protected:
     LONG m_ctor_err ;
     LONG m_api_err ;
     DWORD m_time_created ;
     BOOL m_b_dirty ;

     CObjHelper () ;

public:
    void AssertValid () const ;

    virtual BOOL IsValid () const ;

    operator BOOL()
    {
        return (IsValid());
    }

    //
    //  Update the Dirty flag
    //
    void SetDirty ( BOOL bDirty = TRUE )
    {
        m_b_dirty = bDirty ;
    }

    //
    //  Query the Dirty flag
    //
    BOOL IsDirty () const
    {
        return m_b_dirty ;
    }

    //
    //  Return the creation time of this object
    //
    DWORD QueryCreationTime() const
    {
        return m_time_created ;
    }

    //
    //  Return the elapsed time this object has been alive.
    //
    DWORD QueryAge () const ;

    //
    //  Query/set constuction failure
    //
    void ReportError ( LONG errInConstruction ) ;
    LONG QueryError () const
    {
        return m_ctor_err ;
    }

    //
    //  Reset all error conditions.
    //
    void ResetErrors ()
    {
        m_ctor_err = m_api_err = 0 ;
    }

    //
    //  Query/set API errors.
    //
    LONG QueryApiErr () const
    {
        return m_api_err ;
    }

    //
    //  SetApiErr() echoes the error to the caller.for use in expressions.
    //
    LONG SetApiErr ( LONG errApi = 0 ) ;
};

class CObjectPlus : public CObject, public CObjHelper
{
public:
    CObjectPlus () ;

    //
    //  Compare one object with another
    //
    virtual int Compare ( const CObjectPlus * pob ) const ;

    //
    //  Define a typedef for an ordering function.
    //
    typedef int (CObjectPlus::*PCOBJPLUS_ORDER_FUNC) ( const CObjectPlus * pobOther ) const ;

    //
    //  Helper function to release RPC memory from RPC API calls.
    //
    static void FreeRpcMemory ( void * pvRpcData ) ;
};

class CObListIter : public CObjectPlus
{
protected:
    POSITION m_pos ;
    const CObOwnedList & m_obList ;

public:
    CObListIter ( const CObOwnedList & obList ) ;

    CObject * Next () ;

    void Reset () ;

    POSITION QueryPosition () const
    {
        return m_pos ;
    }

    void SetPosition(POSITION pos)
    {
        m_pos = pos;
    }
};

//
//  Object pointer list which "owns" the objects pointed to.
//
class CObOwnedList : public CObList, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedList ( int nBlockSize = 10 ) ;
    virtual ~ CObOwnedList () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;

        return bOld ;
    }

    CObject * Index ( int index ) ;
    CObject * RemoveIndex ( int index ) ;
    BOOL Remove ( CObject * pob ) ;
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Override of CObList::AddTail() to control exception handling.
    //  Returns NULL if addition fails.
    //
    POSITION AddTail ( CObjectPlus * pobj, BOOL bThrowException = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;
};

//
//  Object array which "owns" the objects pointed to.
//
class CObOwnedArray : public CObArray, public CObjHelper
{
protected:
    BOOL m_b_owned ;

    static int _cdecl SortHelper ( const void * pa, const void * pb ) ;

public:
    CObOwnedArray () ;
    virtual ~ CObOwnedArray () ;

    BOOL SetOwnership ( BOOL bOwned = TRUE )
    {
        BOOL bOld = m_b_owned ;
        m_b_owned = bOwned ;
        return bOld ;
    }

    void RemoveAt( int nIndex, int nCount = 1);
    void RemoveAll () ;
    int FindElement ( CObject * pobSought ) const ;

    //
    //  Set all elements to dirty or clean.  Return TRUE if
    //  any element was dirty.
    //
    BOOL SetAll ( BOOL bDirty = FALSE ) ;

    //
    //  Sort the list elements according to the
    //    given ordering function.
    //
    LONG Sort ( CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc ) ;

private:

    void QuickSort(
        int nLow,
        int nHigh,
        CObjectPlus::PCOBJPLUS_ORDER_FUNC pOrderFunc
        );

    void Swap(
        int nIndex1,
        int nIndex2
        );
};

#endif  // _OBJPLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\queryobj.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    queryobj.h
        Implementation for the background thread and query objects

    FILE HISTORY:
        
*/

#ifndef _QUERYOBJ_H
#define _QUERYOBJ_H

#ifndef _TFSINT_H
#include <tfsint.h>
#endif

#define IMPL

// NOTE:  Do not define any data types of this value.  This range is reservered
// for internal values for ITFSNode pointers.
#define QDATA_PNODE		0xabcdef29
#define QDATA_TIMER     0xabcdef2a

typedef struct QueueData_tag
{
	LPARAM Data;
	LPARAM Type;
}
QUEUEDATA, * LPQUEUEDATA;

class CBackgroundThread;
class CQueryObject;

//////////////////////////////////////////////////////////////////////
//
// CBackgroundThread
//
//////////////////////////////////////////////////////////////////////
class CBackgroundThread : public CWinThread
{
public:
	CBackgroundThread();
	virtual ~CBackgroundThread();
	
	void	SetQueryObj(ITFSQueryObject* pQuery);
	BOOL	Start();
	
	virtual BOOL InitInstance() { return TRUE; }	// MFC override
	virtual int Run();								// MFC override

	void	Lock() { ::EnterCriticalSection(&m_cs); }
	void	Unlock() { ::LeaveCriticalSection(&m_cs); }

private:
	CRITICAL_SECTION	m_cs;	// critical section to sync access to data

	SPITFSQueryObject	m_spQuery;
};


/*---------------------------------------------------------------------------
	Class:	CQueryObj

	This is the generic query object.  If you want to do something real
	with this, derive a class from this and do it yourself.
 ---------------------------------------------------------------------------*/

class CQueryObject :
    public ITFSQueryObject
{
public:
	CQueryObject();
	virtual ~CQueryObject();

	DeclareIUnknownMembers(IMPL)
	DeclareITFSQueryObjectMembers(IMPL)

protected:
	// Query objects will now have to perform the locking
	// functions themselves
	void Lock()	{ ::EnterCriticalSection(&m_cs); }
	void Unlock() { ::LeaveCriticalSection(&m_cs); }

	CRITICAL_SECTION	m_cs;
	HANDLE				m_hEventAbort;
	LONG				m_cRef;

	SPITFSThreadHandler	m_spHandler;
	SPITFSQueryObject	m_spQuery;

	HWND				m_hHiddenWnd;
	UINT				m_uMsgBase;
};


//////////////////////////////////////////////////////////////////////
//
// CNodeList 
// collection of nodes
//
//////////////////////////////////////////////////////////////////////
typedef CList<LPQUEUEDATA, LPQUEUEDATA> CQueueDataListBase;
typedef CList<ITFSNode *, ITFSNode *> CNodeListBase;

class CNodeList : public CNodeListBase
{
public:
	BOOL RemoveNode(ITFSNode* p)
	{
		POSITION pos = Find(p);
		if (pos == NULL)
			return FALSE;
		RemoveAt(pos);
		return TRUE;
	}
	void DeleteAllNodes() 
	{	
		while (!IsEmpty()) 
			RemoveTail()->Release();
	}
	BOOL HasNode(ITFSNode* p)
	{
		return NULL != Find(p);
	}
};

/*---------------------------------------------------------------------------
	Class:	CNodeQueryObject
 ---------------------------------------------------------------------------*/
class CNodeQueryObject : public CQueryObject
{
public:
	CNodeQueryObject() { m_nQueueCountMax = 1; } // default to notification on 
												 // every item enumed from thread
	virtual ~CNodeQueryObject();
	BOOL AddToQueue(ITFSNode* pNode);
	BOOL AddToQueue(LPARAM Data, LPARAM Type);

	LPQUEUEDATA RemoveFromQueue();
	BOOL IsQueueEmpty();
	BOOL IsQueueFull();
	
	STDMETHOD(OnThreadExit)();
	STDMETHOD(OnEventAbort());
	STDMETHOD(DoCleanup());

	BOOL	PostHaveData(LPARAM lParam);	
	BOOL	PostError(DWORD dwErr);
	virtual void OnEventAbort(LPARAM Data, LPARAM Type) { };

private:
	// communication with ComponentData object 
	BOOL PostMessageToComponentData(UINT uMsg, LPARAM lParam);

protected:
	int					m_nQueueCountMax;
	CQueueDataListBase	m_dataQueue;
};

/*---------------------------------------------------------------------------
	Class:	CNodeQueryObject
 ---------------------------------------------------------------------------*/
class CNodeTimerQueryObject : public CNodeQueryObject
{
public:
	virtual ~CNodeTimerQueryObject() { };

    STDMETHOD (Execute)(void);

    void    SetTimerInterval(DWORD dwTimerInterval) { m_dwTimerInterval = dwTimerInterval; }
    DWORD   GetTimerInterval() { return m_dwTimerInterval; }

private:

protected:
    DWORD   m_dwTimerInterval;
};

/*---------------------------------------------------------------------------
	Inlined functions
 ---------------------------------------------------------------------------*/

inline BOOL CNodeQueryObject::PostHaveData(LPARAM lParam)
{
	return PostMessageToComponentData(WM_HIDDENWND_INDEX_HAVEDATA, lParam);
}

inline BOOL CNodeQueryObject::PostError(DWORD dwErr)
{
	return PostMessageToComponentData(WM_HIDDENWND_INDEX_ERROR, dwErr);
}

inline STDMETHODIMP CQueryObject::Execute()
{
	return hrFalse;
}

// This function is called when the thread exits, this gives
// the query object a last chance to send a data notification
// to the node
inline STDMETHODIMP CQueryObject::OnThreadExit()
{
	return hrOK;
}

inline HANDLE CQueryObject::GetAbortEventHandle()
{
	return m_hEventAbort;
}

inline STDMETHODIMP CQueryObject::OnEventAbort()
{
	return hrOK;
}

inline STDMETHODIMP CQueryObject::DoCleanup()
{
	return hrOK;
}
	

#endif _QUERYOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

    FILE HISTORY:
        
*/

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <mmc.h>

extern LPCWSTR g_lpszNullString;

extern enum FOLDER_TYPES;

// New Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

#include "snapbase.h"
#include "resource.h"
#include "commres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\task.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Task.cpp
        Implementation of the task holder/enumerator object
		
    FILE HISTORY:
	
*/
#include <stdafx.h>
#include "task.h"

DEBUG_DECLARE_INSTANCE_COUNTER(CTaskList);

CTaskList::CTaskList()
    : m_uIndex(0),
      m_cRef(1)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CTaskList);
}


CTaskList::~CTaskList()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CTaskList);
}


IMPLEMENT_ADDREF_RELEASE(CTaskList)

STDMETHODIMP CTaskList::QueryInterface(REFIID riid, LPVOID *ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
    // Is the pointer bad?
    if (ppv == NULL)
		return E_INVALIDARG;

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    //  This is the non-delegating IUnknown implementation
    if (riid == IID_IUnknown)
        *ppv = (LPVOID) this;
	else if (riid == IID_IEnumTASK)
		*ppv = (IEnumTASK *) this;

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN) *ppv)->AddRef();
		return hrOK;
    }
    else
		return E_NOINTERFACE;
}

/*!--------------------------------------------------------------------------
    CTaskList::Next
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Next
(
    ULONG celt, 
    MMC_TASK * rgelt, 
    ULONG * pceltFetched
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {

        // caller alloc's array of MMC_TASKs
        // callee fills MMC_TASK elements (via CoTaskMemAlloc)

        if ((rgelt == NULL) || (pceltFetched == NULL))
            return E_INVALIDARG;
    
        Assert(!IsBadWritePtr (rgelt, celt*sizeof(MMC_TASK)));
        Assert(!IsBadWritePtr (pceltFetched, sizeof(ULONG)));

        ULONG nTaskNumber = (ULONG)m_arrayTasks.GetSize();
        for (ULONG i = 0; i < celt; i++) 
        {
            if (m_uIndex >= nTaskNumber) // cannot fetch anymore
            {
                if (pceltFetched != NULL)
                    *pceltFetched = i;
                return S_FALSE;   // failure
            }
            
            if (FillTask(&rgelt[i], m_uIndex))
            {
                m_uIndex++;
            }
            else
            {
                if (pceltFetched)
                    *pceltFetched = i;
                return S_FALSE;   // failure
            }
        }
        
        // if we get here all is well
        if (pceltFetched)
            *pceltFetched = celt;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Skip
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Skip
(
    ULONG celt
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex += celt;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Reset
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Reset()
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex = 0;

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::Clone
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CTaskList::Clone
(
    IEnumTASK ** ppEnumTASK
)
{
    CTaskList * pEnumTasks = NULL;
    SPIEnumTask spEnumTasks;
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        if (ppEnumTASK == NULL)
            return E_INVALIDARG;

        *ppEnumTASK = NULL;
    
        // clone maintaining state info 
        pEnumTasks = new CTaskList;
        spEnumTasks = pEnumTasks;

        pEnumTasks->_Clone(m_uIndex, m_arrayTasks); 
        CORg (pEnumTasks->QueryInterface(IID_IEnumTASK, (void**)ppEnumTASK));

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::AddTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::AddTask
(
    LPOLESTR        pszMouseOverBitmapResource,
    LPOLESTR        pszMouseOffBitmapResource,
    LPOLESTR        pszText,
    LPOLESTR        pszHelpString,
    MMC_ACTION_TYPE mmcAction,
    long            nCommandID
)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;

    COM_PROTECT_TRY
    {
        mmcTask.sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
		mmcTask.sDisplayObject.uBitmap.szMouseOverBitmap = pszMouseOverBitmapResource;
        mmcTask.sDisplayObject.uBitmap.szMouseOffBitmap = pszMouseOffBitmapResource;
        mmcTask.szText = pszText;
        mmcTask.szHelpString = pszHelpString;
        mmcTask.eActionType = mmcAction;
        mmcTask.nCommandID = nCommandID;

        m_arrayTasks.Add(mmcTask);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::AddTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::AddTask
(
    LPOLESTR        pszMouseOverBitmapResource,
    LPOLESTR        pszMouseOffBitmapResource,
    LPOLESTR        pszText,
    LPOLESTR        pszHelpString,
    MMC_ACTION_TYPE mmcAction,
    LPOLESTR        pszActionURLorScript
)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;

    COM_PROTECT_TRY
    {
        mmcTask.sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
		mmcTask.sDisplayObject.uBitmap.szMouseOverBitmap = pszMouseOverBitmapResource;
        mmcTask.sDisplayObject.uBitmap.szMouseOffBitmap = pszMouseOffBitmapResource;
        mmcTask.szText = pszText;
        mmcTask.szHelpString = pszHelpString;
        mmcTask.eActionType = mmcAction;

        switch (mmcTask.eActionType) 
        {
            case MMC_ACTION_LINK:
                mmcTask.szActionURL = pszActionURLorScript;
                break;
            case MMC_ACTION_SCRIPT:
                mmcTask.szScript = pszActionURLorScript;
                break;
            default:
                Assert (FALSE);  // bad task
                break;
        }

        m_arrayTasks.Add(mmcTask);

    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CTaskList::FillTask
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
CTaskList::FillTask
(
    MMC_TASK *  pmmcTask,
    int         nIndex
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        // right now we only support bitmap display types
        pmmcTask->sDisplayObject.eDisplayType = m_arrayTasks[nIndex].sDisplayObject.eDisplayType;

        switch (m_arrayTasks[nIndex].sDisplayObject.eDisplayType)
        {
            case MMC_TASK_DISPLAY_TYPE_BITMAP:
                {
                    pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOverBitmap)+1));
                    if (pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap) 
                    {
                        lstrcpy (pmmcTask->sDisplayObject.uBitmap.szMouseOverBitmap, m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOverBitmap);
                    }
                     
                    pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOffBitmap)+1));
                    if (pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap) 
                    {
                        lstrcpy (pmmcTask->sDisplayObject.uBitmap.szMouseOffBitmap, m_arrayTasks[nIndex].sDisplayObject.uBitmap.szMouseOffBitmap);
                    }
                }
                break;

            default:
                Panic0("unsupported display type in task");
                break;
        }

        //
        // Add button text
        //
        pmmcTask->szText = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szText)+1));
        if (pmmcTask->szText) 
        {
            lstrcpy (pmmcTask->szText, m_arrayTasks[nIndex].szText);
        
            //
            // Add help string
            //
            pmmcTask->szHelpString = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szHelpString)+1));
            if (pmmcTask->szHelpString) 
            {
               lstrcpy (pmmcTask->szHelpString, m_arrayTasks[nIndex].szHelpString);
            }
        }
        
        pmmcTask->eActionType = m_arrayTasks[nIndex].eActionType;
        
        switch (pmmcTask->eActionType) 
        {
            case MMC_ACTION_ID:
                pmmcTask->nCommandID = m_arrayTasks[nIndex].nCommandID;
                break;

            case MMC_ACTION_LINK:
                pmmcTask->szActionURL = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szActionURL)+1));
                if (pmmcTask->szActionURL) 
                {
                    lstrcpy (pmmcTask->szActionURL, m_arrayTasks[nIndex].szActionURL);
                }
                break;

            case MMC_ACTION_SCRIPT:
                pmmcTask->szScript = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(m_arrayTasks[nIndex].szScript)+1));
                if (pmmcTask->szActionURL) 
                {
                    lstrcpy (pmmcTask->szScript, m_arrayTasks[nIndex].szScript);
                }
                break;

            default:
                Assert (FALSE);  // bad task
                break;
        }

    }
    COM_PROTECT_CATCH

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

/*!--------------------------------------------------------------------------
    CTaskList::_Clone
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CTaskList::_Clone
(   
    int                 nIndex, 
    CTaskListArray &    arrayTasks
)
{
    HRESULT     hr = hrOK;

    COM_PROTECT_TRY
    {
        m_uIndex = nIndex;

        m_arrayTasks.RemoveAll();
        m_arrayTasks.Append(arrayTasks);
    }
    COM_PROTECT_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\snaputil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    snaputil.h  
        various utility routines 

    FILE HISTORY:
	
*/

#ifndef _SNAPUTIL_H
#define _SNAPUTIL_H

#ifdef __cplusplus

typedef CArray<GUID, const GUID&> CTFSGUIDArrayBase;

class CGUIDArray : public CTFSGUIDArrayBase
{
public:
    void AddUnique(const GUID& guid)
    {
        for (INT_PTR i = GetUpperBound(); i >= 0; --i)
        {
            if (GetAt(i) == guid)
                break;
        }

        if (i < 0)
            Add(guid);
    }

    BOOL IsInList(GUID & guid)
    {
        for (int i = 0; i < GetSize(); i++)
        {
            if (GetAt(i) == guid)
                return TRUE;
        }

        return FALSE;
    }
};
#endif	// __cplusplus



#ifdef __cplusplus
extern "C"
{
#endif
	
/*!--------------------------------------------------------------------------
	IsLocalMachine
		Returns TRUE if the machine name passed in is the local machine,
		or if pszMachineName is NULL.

		Returns FALSE otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	IsLocalMachine(LPCTSTR pszMachineName);

/*!--------------------------------------------------------------------------
	FUseTaskpadsByDefault
		Returns TRUE if we are to use taskpads by default.

		We check the
			HKLM\Software\Microsoft\MMC
				TFSCore_StopTheInsanity : REG_DWORD :
					= 1, don't use taskpads by default
					= 0 (or not there), use taskpads by default
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	FUseTaskpadsByDefault(LPCTSTR pszMachineName);

#ifdef __cplusplus
};
#endif

UINT	CalculateStringWidth(HWND hWndParent, LPCTSTR pszString);



/*---------------------------------------------------------------------------
	IP address validation function

    This will return 0 (for success) or a string constant if the input
    is bogus.

    ipAddress and ipMask are assumed to be in host order.
 ---------------------------------------------------------------------------*/
UINT    CheckIPAddressAndMask(DWORD ipAddress, DWORD ipMask, DWORD dwFlags);

#define IPADDRESS_TEST_ALL      (0xFFFFFFFF)

// This test is to test the address only.  Tests involving the masks
// are not performed.
#define IPADDRESS_TEST_ADDRESS_ONLY \
                                    (IPADDRESS_TEST_NORMAL_RANGE | \
                                    IPADDRESS_TEST_NOT_127 )

// Tests to see that the mask is non-contiguous
// if this fail, function returns IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK
#define IPADDRESS_TEST_NONCONTIGUOUS_MASK   0x00000001

// Tests to see that the address is not longer than the mask
// e.g. 172.31.248.1 / 255.255.255.0
// Returns IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC
#define IPADDRESS_TEST_TOO_SPECIFIC         0x00000002

// Tests to to see that the ipaddress falls into the normal range
//    1.0.0.0 <= ipaddress < 224.0.0.0
// Returns IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE
#define IPADDRESS_TEST_NORMAL_RANGE         0x00000004

// Tests that ths is not a 127.x.x.x address
// Returns IDS_COMMON_ERR_IPADDRESS_127
#define IPADDRESS_TEST_NOT_127              0x00000008

// Tests that the ipaddress is not the same as the mask
// Retursn IDS_COMMOON_ERR_IPADDRESS_NOT_EQ_MASK
#define IPADDRESS_TEST_ADDR_NOT_EQ_MASK     0x00000010



#endif _SNAPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\statsdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       statsdlg.cpp
//
//--------------------------------------------------------------------------

// StatsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "StatsDlg.h"
#include "coldlg.h"
#include "modeless.h"   // ModelessThread

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BEGIN_MESSAGE_MAP(CStatsListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CStatsListCtrl)
    ON_WM_KEYDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CStatsListCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    BOOL fControlDown;
    BOOL fShiftDown;

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    switch(nChar)
    {
        case 'c':
        case 'C':
        case VK_INSERT:
            if (fControlDown)
                CopyToClipboard();
            break;
    }

	CListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CStatsListCtrl::CopyToClipboard()
{
    CString     strText, strLine, strData;
    int         nCount = GetItemCount();
    int         nColumns = 0;
    TCHAR       szBuffer[256];
    LV_COLUMN   ColumnInfo = {0};
    
    ColumnInfo.mask = LVCF_TEXT;
    ColumnInfo.pszText = szBuffer;
    ColumnInfo.cchTextMax = sizeof(szBuffer);

    // build up the column info
    while (GetColumn(nColumns, &ColumnInfo))
    {
        if (!strLine.IsEmpty())
            strLine += _T(",");

        strLine += ColumnInfo.pszText;

        nColumns++;
    }

    strLine += _T("\r\n");
    strData += strLine;
    strLine.Empty();

    // now get the other data
    for (int i = 0; i < nCount; i++)
    {
        for (int j = 0; j < nColumns; j++)
        {
            if (!strLine.IsEmpty())
                strLine += _T(",");
            
            strText = GetItemText(i, j);
    
            strLine += strText;
        }

        strLine += _T("\r\n");

        strData += strLine;
        strLine.Empty();
    }
 
    int nLength = strData.GetLength() + 1;
    nLength *= sizeof(TCHAR);

    HGLOBAL hMem = GlobalAlloc(GPTR, nLength);
    if (hMem)
    {
        memcpy (hMem, strData, nLength);
    
        if (!OpenClipboard())
	    {
		    GlobalFree(hMem);
            return;
	    }

        EmptyClipboard();

        SetClipboardData(CF_UNICODETEXT, hMem);

        CloseClipboard();
    }
}

/*!--------------------------------------------------------------------------
   StatsDialog::StatsDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
StatsDialog::StatsDialog(DWORD dwOptions) :
   m_dwOptions(dwOptions),
   m_ulId(0),
   m_pConfig(NULL),
   m_bAfterInitDialog(FALSE)
{
   m_sizeMinimum.cx = m_sizeMinimum.cy = 0;

   m_hEventThreadKilled = ::CreateEvent(NULL, FALSE, FALSE, NULL);
   Assert(m_hEventThreadKilled);

   // Initialize the array of buttons
   ::ZeroMemory(m_rgBtn, sizeof(m_rgBtn));
   m_rgBtn[INDEX_CLOSE].m_ulId = IDCANCEL;
   m_rgBtn[INDEX_REFRESH].m_ulId = IDC_STATSDLG_BTN_REFRESH;
   m_rgBtn[INDEX_SELECT].m_ulId = IDC_STATSDLG_BTN_SELECT_COLUMNS;
   m_rgBtn[INDEX_CLEAR].m_ulId = IDC_STATSDLG_BTN_CLEAR;

   // Bug 134785 - create the ability to default to an ascending
   // rather than a descending sort.
   m_fSortDirection = !((dwOptions & STATSDLG_DEFAULTSORT_ASCENDING) != 0);
   m_fDefaultSortDirection = m_fSortDirection;

   // Multiply text header width with 2 for width of columns
   m_ColWidthMultiple = 2;
   m_ColWidthAdder = 0;
}


/*!--------------------------------------------------------------------------
   StatsDialog::~StatsDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
StatsDialog::~StatsDialog()
{
   if (m_hEventThreadKilled)
      ::CloseHandle(m_hEventThreadKilled);
   m_hEventThreadKilled = 0;
}

/*!--------------------------------------------------------------------------
   StatsDialog::DoDataExchange
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::DoDataExchange(CDataExchange* pDX)
{
   CBaseDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(StatsDialog)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   DDX_Control(pDX, IDC_STATSDLG_LIST, m_listCtrl);
   //}}AFX_DATA_MAP
}



BEGIN_MESSAGE_MAP(StatsDialog, CBaseDialog)
   //{{AFX_MSG_MAP(StatsDialog)
      ON_COMMAND(IDC_STATSDLG_BTN_REFRESH, OnRefresh)
      ON_COMMAND(IDC_STATSDLG_BTN_SELECT_COLUMNS, OnSelectColumns)
      ON_WM_MOVE()
      ON_WM_SIZE()
      ON_WM_GETMINMAXINFO()
      ON_WM_CONTEXTMENU()
      ON_NOTIFY(LVN_COLUMNCLICK, IDC_STATSDLG_LIST, OnNotifyListControlClick)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// StatsDialog message handlers




/*!--------------------------------------------------------------------------
   StatsDialog::SetColumnInfo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT StatsDialog::SetColumnInfo(const ContainerColumnInfo *pColumnInfo, UINT cColumnInfo)
{
   if (m_pConfig)
   {
      m_pConfig->InitViewInfo(m_ulId, TRUE, cColumnInfo, m_fDefaultSortDirection, pColumnInfo);
   }
   else
   {
      m_viewInfo.InitViewInfo(cColumnInfo, TRUE, m_fDefaultSortDirection, pColumnInfo);
   }
   return hrOK;
}

/*!--------------------------------------------------------------------------
   StatsDialog::MapColumnToSubitem
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
int StatsDialog::MapColumnToSubitem(UINT nColumnId)
{
   if (m_pConfig)
      return m_pConfig->MapColumnToSubitem(m_ulId, nColumnId);
   else
      return m_viewInfo.MapColumnToSubitem(nColumnId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::MapSubitemToColumn
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
int StatsDialog::MapSubitemToColumn(UINT nSubitemId)
{
   if (m_pConfig)
      return m_pConfig->MapSubitemToColumn(m_ulId, nSubitemId);
   else
      return m_viewInfo.MapSubitemToColumn(nSubitemId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::IsSubitemVisible
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::IsSubitemVisible(UINT nSubitemId)
{
   if (m_pConfig)
      return m_pConfig->IsSubitemVisible(m_ulId, nSubitemId);
   else
      return m_viewInfo.IsSubitemVisible(nSubitemId);
}

/*!--------------------------------------------------------------------------
   StatsDialog::RefreshData
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT StatsDialog::RefreshData(BOOL fGrabNewData)
{
   return hrOK;
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnInitDialog
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::OnInitDialog()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
        
    RECT  rcWnd, rcBtn;
    
    CBaseDialog::OnInitDialog();
    
    m_bAfterInitDialog = TRUE;
    
    // If this is the first time, get the location of the buttons and
    // list control relative to the edge of the screen
    if (m_sizeMinimum.cx == 0)
    {
        ::GetWindowRect(GetSafeHwnd(), &rcWnd);
        //    m_sizeMinimum.cx = rcWnd.right - rcWnd.left;
        //    m_sizeMinimum.cy = rcWnd.bottom - rcWnd.top;
        m_sizeMinimum.cx = 100;
        m_sizeMinimum.cy = 100;
        
        ::GetClientRect(GetSafeHwnd(), &rcWnd);
        
        // what are the button locations?
        for (int i=0; i<INDEX_COUNT; i++)
        {
            ::GetWindowRect(GetDlgItem(m_rgBtn[i].m_ulId)->GetSafeHwnd(),
                            &rcBtn);
            ScreenToClient(&rcBtn);
            m_rgBtn[i].m_rc.left = rcWnd.right - rcBtn.left;
            m_rgBtn[i].m_rc.right = rcWnd.right - rcBtn.right;
            m_rgBtn[i].m_rc.top = rcWnd.bottom - rcBtn.top;
            m_rgBtn[i].m_rc.bottom = rcWnd.bottom - rcBtn.bottom;
        }
        
        // what is the list control location?
        // The list control top, left is locked in position
        ::GetWindowRect(GetDlgItem(IDC_STATSDLG_LIST)->GetSafeHwnd(), &rcBtn);
        ScreenToClient(&rcBtn);
        m_rcList.left = rcBtn.left;
        m_rcList.top = rcBtn.top;
        
        // The bottom, right corner follows the expansion
        m_rcList.right = rcWnd.right - rcBtn.right;
        m_rcList.bottom = rcWnd.bottom - rcBtn.bottom;
    }

    // If we have a preferred position and size do that
    if (m_pConfig)
    {
        m_pConfig->GetStatsWindowRect(m_ulId, &m_rcPosition);
        m_fSortDirection = m_pConfig->GetSortDirection(m_ulId);
    }
    if (m_pConfig && (m_rcPosition.top != m_rcPosition.bottom))
    {
        MoveWindow(m_rcPosition.left, m_rcPosition.top,
                   m_rcPosition.right - m_rcPosition.left,
                   m_rcPosition.bottom - m_rcPosition.top);
    }
    
    if (m_dwOptions & STATSDLG_FULLWINDOW)
    {
        RECT  rcClient;
        
        // Resize the list control if needed
        GetClientRect(&rcClient);
        OnSize(SIZE_MAXIMIZED,  rcClient.right - rcClient.left,
               rcClient.bottom - rcClient.top);
        
        // Disable the buttons also
        for (int i=0; i<INDEX_COUNT; i++)
        {
            GetDlgItem(m_rgBtn[i].m_ulId)->ShowWindow(SW_HIDE);
            
            if (i != INDEX_CLOSE)
                GetDlgItem(m_rgBtn[i].m_ulId)->EnableWindow(FALSE);
        }
    }
    
    // If we do not have the select columns then we hide and disable
    // the select columns button.
    if ((m_dwOptions & STATSDLG_SELECT_COLUMNS) == 0)
    {
        GetDlgItem(m_rgBtn[INDEX_SELECT].m_ulId)->ShowWindow(SW_HIDE);
        GetDlgItem(m_rgBtn[INDEX_SELECT].m_ulId)->EnableWindow(FALSE);
    }
    
    // If we do not have the clear button then we hide and disable
    // the clear button.
    if ((m_dwOptions & STATSDLG_CLEAR) == 0)
    {
        GetDlgItem(m_rgBtn[INDEX_CLEAR].m_ulId)->ShowWindow(SW_HIDE);
        GetDlgItem(m_rgBtn[INDEX_CLEAR].m_ulId)->EnableWindow(FALSE);
    }
    
    ListView_SetExtendedListViewStyle(GetDlgItem(IDC_STATSDLG_LIST)->GetSafeHwnd(), LVS_EX_FULLROWSELECT);
    
    // Now initialize the headers
    LoadHeaders();
    
    RefreshData(TRUE);
    
    if (m_pConfig)
    {
        Sort( m_pConfig->GetSortColumn(m_ulId) );
    }
    
    if ((m_dwOptions & STATSDLG_FULLWINDOW) == 0)
    {
        GetDlgItem(IDCANCEL)->SetFocus();
        return FALSE;
    }
    
   return TRUE;
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnOK
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnOK()
{
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnCancel
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnCancel()
{
   DeleteAllItems();
   
   DestroyWindow();

   // Explicitly kill this thread.
   AfxPostQuitMessage(0);
}

/*!--------------------------------------------------------------------------
   StatsDialog::PostNcDestroy
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::PostNcDestroy()
{
   // Make sure that this is NULL since this is how we detect that
   // the dialog is showing
   m_hWnd = NULL;
   m_bAfterInitDialog = FALSE;
}

/*!--------------------------------------------------------------------------
   StatsDialog::PreCreateWindow
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
BOOL StatsDialog::PreCreateWindow(CREATESTRUCT& cs)
{
   // Have to refresh the event
   Verify( ResetEvent(m_hEventThreadKilled) );
   return CBaseDialog::PreCreateWindow(cs);
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnRefresh
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnRefresh()
{
   if ((m_dwOptions & STATSDLG_VERTICAL) == 0)
   {
      DeleteAllItems();
   }

   RefreshData(TRUE);
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnSelectColumns
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnSelectColumns()
{
   // We should bring up the columns dialog
   ColumnDlg   columnDlg(NULL);
   ColumnData *pColumnData;
   ULONG    cColumns;
   ULONG    cVisible;
   int         i;
   DWORD    dwWidth;

   if (m_pConfig)
   {
      cColumns = m_pConfig->GetColumnCount(m_ulId);
      cVisible = m_pConfig->GetVisibleColumns(m_ulId);
   }
   else
   {
      cColumns = m_viewInfo.GetColumnCount();
      cVisible = m_viewInfo.GetVisibleColumns();
   }

   pColumnData = (ColumnData *) alloca(sizeof(ColumnData) * cColumns);

   if (m_pConfig)
      m_pConfig->GetColumnData(m_ulId, cColumns, pColumnData);
   else
      m_viewInfo.GetColumnData(cColumns, pColumnData);

   // Save the column width information
   if ((m_dwOptions & STATSDLG_VERTICAL) == 0)
   {
      for (i=0; i<(int) cVisible; i++)
      {
         dwWidth = m_listCtrl.GetColumnWidth(i);
         if (m_pConfig)
            pColumnData[m_pConfig->MapColumnToSubitem(m_ulId, i)].m_dwWidth = dwWidth;
         else
            pColumnData[m_viewInfo.MapColumnToSubitem(i)].m_dwWidth = dwWidth;
      }
   }

   columnDlg.Init(m_pConfig ?
                  m_pConfig->GetColumnInfo(m_ulId) :
                  m_viewInfo.GetColumnInfo(),
               cColumns,
               pColumnData
              );

   if (columnDlg.DoModal() == IDOK)
   {
      if (m_dwOptions & STATSDLG_VERTICAL)
      {
         //$ HACK HACK
         // To save the column info for vertical columns we will save the
         // width data in the first two "columns"
         pColumnData[0].m_dwWidth = m_listCtrl.GetColumnWidth(0);
         pColumnData[1].m_dwWidth = m_listCtrl.GetColumnWidth(1);
      }
      
      // Set the information back in
      if (m_pConfig)
         m_pConfig->SetColumnData(m_ulId, cColumns, pColumnData);
      else
         m_viewInfo.SetColumnData(cColumns, pColumnData);

      // Clear out the data
      DeleteAllItems();
      
      // Remove all of the columns
      if (m_dwOptions & STATSDLG_VERTICAL)
      {
         m_listCtrl.DeleteColumn(1);
         m_listCtrl.DeleteColumn(0);
      }
      else
      {
         for (i=(int) cVisible; --i >= 0; )
            m_listCtrl.DeleteColumn(i);
      }

      // Readd all of the columns
      LoadHeaders();
      
      // Do a refresh
      RefreshData(FALSE);
   }
}

void StatsDialog::OnMove(int x, int y)
{
   if (!m_bAfterInitDialog)
      return;
   
   GetWindowRect(&m_rcPosition);
   if (m_pConfig)
      m_pConfig->SetStatsWindowRect(m_ulId, m_rcPosition);
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnSize
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnSize(UINT nType, int cx, int cy)
{
   RECT  rcWnd;
   RECT  rcBtn;
   RECT  rcDlg;
   
   if (nType == SIZE_MINIMIZED)
      return;

   if (m_dwOptions & STATSDLG_FULLWINDOW)
   {
      // If we're full window, resize the list control to fill
      // the entire client area
      ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), IDC_STATSDLG_LIST), NULL,
                  0, 0, cx, cy, SWP_NOZORDER);
   }
   else if (m_sizeMinimum.cx)
   {

      ::GetClientRect(GetSafeHwnd(), &rcDlg);

      // reposition the buttons

      // The widths are caluclated opposite of the normal order
      // since the positions are relative to the right and bottom.
      for (int i=0; i<INDEX_COUNT; i++)
      {
         ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), m_rgBtn[i].m_ulId),
                     NULL,
                     rcDlg.right - m_rgBtn[i].m_rc.left,
                     rcDlg.bottom - m_rgBtn[i].m_rc.top,
                     m_rgBtn[i].m_rc.left - m_rgBtn[i].m_rc.right,
                     m_rgBtn[i].m_rc.top - m_rgBtn[i].m_rc.bottom,
                     SWP_NOZORDER);
      }

      // resize the list control

      ::SetWindowPos(::GetDlgItem(GetSafeHwnd(), IDC_STATSDLG_LIST),
                  NULL,
                  m_rcList.left,
                  m_rcList.top,
                  rcDlg.right - m_rcList.right - m_rcList.left,
                  rcDlg.bottom - m_rcList.bottom - m_rcList.top,
                  SWP_NOZORDER);
   }
   

   if (m_bAfterInitDialog)
   {
      GetWindowRect(&m_rcPosition);
      if (m_pConfig)
         m_pConfig->SetStatsWindowRect(m_ulId, m_rcPosition);
   }
}

/*!--------------------------------------------------------------------------
   StatsDialog::OnGetMinMaxInfo
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnGetMinMaxInfo(MINMAXINFO *pMinMax)
{
   pMinMax->ptMinTrackSize.x = m_sizeMinimum.cx;
   pMinMax->ptMinTrackSize.y = m_sizeMinimum.cy;
}

/*!--------------------------------------------------------------------------
   StatsDialog::LoadHeaders
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::LoadHeaders()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    ULONG cVis;
    ULONG i, iPos;
    ULONG ulId;
    CString  st;
    DWORD dwWidth;
    ColumnData  rgColumnData[2];  // used for vertical format
    
    // Load those headers that we have data for
    
    // Go through the column data finding the headers that we have
    if (m_pConfig)
        cVis = m_pConfig->GetVisibleColumns(m_ulId);
    else
        cVis = m_viewInfo.GetVisibleColumns();
    
    if (m_dwOptions & STATSDLG_VERTICAL)
    {
        if (m_pConfig)
            m_pConfig->GetColumnData(m_ulId, 2, rgColumnData);
        else
            m_viewInfo.GetColumnData(2, rgColumnData);
        
        // For the vertical format, the data is on a column
        // Thus we add two columns and fill in the data for the
        // first column
        st.LoadString(IDS_STATSDLG_DESCRIPTION);
        dwWidth = rgColumnData[0].m_dwWidth;
        if (dwWidth == AUTO_WIDTH)
        {
            dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
        }
        m_listCtrl.InsertColumn(0, st, rgColumnData[0].fmt, dwWidth, 0);
        
        st.LoadString(IDS_STATSDLG_DETAILS);
        dwWidth = rgColumnData[1].m_dwWidth;
        if (dwWidth == AUTO_WIDTH)
        {
            dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
        }  
        m_listCtrl.InsertColumn(1, st, rgColumnData[1].fmt, dwWidth, 1);
        
        // Now go through and add the rows for each of our "columns"
        for (i=0; i<cVis; i++)
        {
            // Now get the info for iPos
            if (m_pConfig)
                ulId = m_pConfig->GetStringId(m_ulId, i);
            else
                ulId = m_viewInfo.GetStringId(i);
            st.LoadString(ulId);
            Assert(st.GetLength());
            
            m_listCtrl.InsertItem(i, _T(""));
            m_listCtrl.SetItemText(i, 0, (LPCTSTR) st);
        }
    }
    else
    {
        // For the normal horizontal format, the data is on a row
        // so we need to add the various columnar data
        for (i=0; i<cVis; i++)
        {
			int fmt = LVCFMT_LEFT;

            iPos = MapColumnToSubitem(i);
            
            // Now get the info for iPos
            if (m_pConfig)
                ulId = m_pConfig->GetStringId(m_ulId, i);
            else
                ulId = m_viewInfo.GetStringId(i);

            st.LoadString(ulId);
            Assert(st.GetLength());
            
            if (m_pConfig)
			{
                dwWidth = m_pConfig->GetColumnWidth(m_ulId, i);
				m_pConfig->GetColumnData(m_ulId, i, 1, rgColumnData);
				fmt = rgColumnData[0].fmt;
			}
            else
			{
                dwWidth = m_viewInfo.GetColumnWidth(i);
				m_viewInfo.GetColumnData(i, 1, rgColumnData);
				fmt = rgColumnData[0].fmt;
			}
			
            if (dwWidth == AUTO_WIDTH)
            {
                dwWidth = m_ColWidthAdder + static_cast<DWORD>(m_ColWidthMultiple*m_listCtrl.GetStringWidth((LPCTSTR) st));
            }  
            m_listCtrl.InsertColumn(i, st, fmt, dwWidth, iPos);
        }
    }
}

HRESULT StatsDialog::AddToContextMenu(CMenu* pMenu)
{
   return S_OK;
}


/*!--------------------------------------------------------------------------
   StatsDialog::OnContextMenu
      -
   Author: KennT
 ---------------------------------------------------------------------------*/
void StatsDialog::OnContextMenu(CWnd *pWnd, CPoint pos)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());	
    CMenu menu;
    CString  st;
    
    if ((m_dwOptions & STATSDLG_CONTEXTMENU) == 0)
        return;
    
    if (pWnd->GetDlgCtrlID() != IDC_STATSDLG_LIST)
        return;
    
    // Bring up a context menu if we need to
    menu.CreatePopupMenu();
    
    st.LoadString(IDS_STATSDLG_MENU_REFRESH);
    menu.AppendMenu(MF_STRING, IDC_STATSDLG_BTN_REFRESH, st);
    
    if (m_dwOptions & STATSDLG_SELECT_COLUMNS)
    {
        st.LoadString(IDS_STATSDLG_MENU_SELECT);
        menu.AppendMenu(MF_STRING, IDC_STATSDLG_BTN_SELECT_COLUMNS, st);
    }
    
    //virtual override to add additional context menus
    AddToContextMenu(&menu);
    
    menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                        pos.x,
                        pos.y,
                        this,
                        NULL);
}


void StatsDialog::OnNotifyListControlClick(NMHDR *pNmHdr, LRESULT *pResult)
{
   NM_LISTVIEW *  pnmlv = reinterpret_cast<NM_LISTVIEW *>(pNmHdr);

   if (m_pConfig)
      m_pConfig->SetSortColumn(m_ulId, pnmlv->iSubItem);

   // Call through to the user to sort
   Sort(pnmlv->iSubItem);

   if (m_pConfig)
      m_pConfig->SetSortDirection(m_ulId, m_fSortDirection);
}


void StatsDialog::Sort(UINT nColumn)
{
   // Default is to do nothing
}

void StatsDialog::PreDeleteAllItems()
{
}

void StatsDialog::DeleteAllItems()
{
   PreDeleteAllItems();
   m_listCtrl.DeleteAllItems();
}

void StatsDialog::PostRefresh()
{
   if (GetSafeHwnd())
      PostMessage(WM_COMMAND, IDC_STATSDLG_BTN_REFRESH);
}

/*!--------------------------------------------------------------------------
   StatsDialog::SetColumnWidths
      Loops through all items and calculates the max width for columns
        in a listbox.
   Author: EricDav
 ---------------------------------------------------------------------------*/
void StatsDialog::SetColumnWidths(UINT uNumColumns)
{
    // Set the default column widths to the width of the widest column
    int * aColWidth = (int *) alloca(uNumColumns * sizeof(int));
    int nRow, nCol;
    CString strTemp;
    
    ZeroMemory(aColWidth, uNumColumns * sizeof(int));

    // for each item, loop through each column and calculate the max width
    for (nRow = 0; nRow < m_listCtrl.GetItemCount(); nRow++)
    {
        for (nCol = 0; nCol < (int) uNumColumns; nCol++)
        {
            strTemp = m_listCtrl.GetItemText(nRow, nCol);
            if (aColWidth[nCol] < m_listCtrl.GetStringWidth(strTemp))
                aColWidth[nCol] = m_listCtrl.GetStringWidth(strTemp);
        }
    }
    
    // now update the column widths based on what we calculated
    for (nCol = 0; nCol < (int) uNumColumns; nCol++)
    {
        // GetStringWidth doesn't seem to report the right thing,
        // so we have to add a fudge factor of 15.... oh well.
        m_listCtrl.SetColumnWidth(nCol, aColWidth[nCol] + 15);
    }
}


void StatsDialog::SetConfigInfo(ConfigStream *pConfig, ULONG ulId)
{
   m_pConfig = pConfig;
   m_ulId = ulId;
}

void StatsDialog::SetPosition(RECT rc)
{
   m_rcPosition = rc;
}

void StatsDialog::GetPosition(RECT *prc)
{
   *prc = m_rcPosition;
}

void CreateNewStatisticsWindow(StatsDialog *pWndStats,
                        HWND hWndParent,
                        UINT  nIDD)
{                         
   ModelessThread *  pMT;

   // If the dialog is still up, don't create a new one
   if (pWndStats->GetSafeHwnd())
   {
      ::SetActiveWindow(pWndStats->GetSafeHwnd());
      return;
   }

   pMT = new ModelessThread(hWndParent,
                      nIDD,
                      pWndStats->GetSignalEvent(),
                      pWndStats);
   pMT->CreateThread();
}

void WaitForStatisticsWindow(StatsDialog *pWndStats)
{
   if (pWndStats->GetSafeHwnd())
   {
      // Post a cancel to that window
      // Do an explicit post so that it executes on the other thread
      pWndStats->PostMessage(WM_COMMAND, IDCANCEL, 0);

      // Now we need to wait for the event to be signalled so that
      // its memory can be cleaned up
      WaitForSingleObject(pWndStats->GetSignalEvent(), INFINITE);
   }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\snaputil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    FILE HISTORY:
        
*/

#include "stdafx.h"

#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include "tfschar.h"
#include "tregkey.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


#if _WIN32_WINNT < 0x0500

//
// CODEWORK This was taken from winbase.h.  MFC requires _WIN32_WINNT=0x4000 whereas
// winbase.h only includes this for _WIN32_WINNT=0x5000.  JonN 1/14/99
//
extern "C" {
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
WINBASEAPI
BOOL
WINAPI
GetComputerNameExA (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
WINBASEAPI
BOOL
WINAPI
GetComputerNameExW (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerNameEx  GetComputerNameExW
#else
#define GetComputerNameEx  GetComputerNameExA
#endif // !UNICODE
} // extern "C"
#endif



/*!--------------------------------------------------------------------------
	IsLocalMachine
		Returns TRUE if the machine name passed in is the local machine,
		or if pszMachineName is NULL.

        This compares the NetBIOS name and the DNS (fully-qualified) name.

		Returns FALSE otherwise.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	IsLocalMachine(LPCTSTR pszMachineName)
{
	static TCHAR	s_szLocalMachineName[MAX_PATH*2+1] = _T("");
	static TCHAR	s_szDnsLocalMachineName[MAX_PATH*2+1] = _T("");

	if ((pszMachineName == NULL) || (*pszMachineName == 0))
		return TRUE;

    // Bypass the beginning slashes
    if ((pszMachineName[0] == _T('\\')) && (pszMachineName[1] == _T('\\')))
        pszMachineName += 2;

    // Check again (for degenerate case of "\\")
    if (*pszMachineName == 0)
        return TRUE;

	if (s_szLocalMachineName[0] == 0)
	{
		DWORD dwSize = MAX_PATH*2;
		GetComputerName(s_szLocalMachineName, &dwSize);
		s_szLocalMachineName[MAX_PATH*2] = 0;
	}

    if (s_szDnsLocalMachineName[0] == 0)
    {
		DWORD dwSize = MAX_PATH*2;
		GetComputerNameEx(ComputerNameDnsFullyQualified,
                          s_szDnsLocalMachineName,
                          &dwSize);
		s_szDnsLocalMachineName[MAX_PATH*2] = 0;
    }
    
	return (StriCmp(pszMachineName, s_szLocalMachineName) == 0) ||
            (StriCmp(pszMachineName, s_szDnsLocalMachineName) == 0);
}

/*!--------------------------------------------------------------------------
	FUseTaskpadsByDefault
		See comments in header file.
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL	FUseTaskpadsByDefault(LPCTSTR pszMachineName)
{
	static DWORD	s_dwStopTheInsanity = 42;
	RegKey	regkeyMMC;
	DWORD	dwErr;

	if (s_dwStopTheInsanity == 42)
	{
		// Set the default to TRUE (i.e. do not use taskpads by default)
		// ------------------------------------------------------------
		s_dwStopTheInsanity = 1;
		
		dwErr = regkeyMMC.Open(HKEY_LOCAL_MACHINE,
							   _T("Software\\Microsoft\\MMC"),
							   KEY_READ, pszMachineName);
		if (dwErr == ERROR_SUCCESS)
		{
			dwErr = regkeyMMC.QueryValue(_T("TFSCore_StopTheInsanity"), s_dwStopTheInsanity);
			if (dwErr != ERROR_SUCCESS)
				s_dwStopTheInsanity = 1;
		}
	}
		
	return !s_dwStopTheInsanity;
}


UINT	CalculateStringWidth(HWND hWndParent, LPCTSTR pszString)
{
	// Create a dummy list control, set this text width and use
	// that to determine the width of the string as used by MMC.

	// Create a dummy list control (that will be attached to the window)

	CListCtrl	listctrl;
	CRect		rect(0,0,0,0);
	UINT		nSize;
	HWND		hWnd;

	CString s_szHiddenWndClass = AfxRegisterWndClass(
			0x0,  //UINT nClassStyle, 
			NULL, //HCURSOR hCursor,        
			NULL, //HBRUSH hbrBackground, 
			NULL  //HICON hIcon
	);

	hWnd = ::CreateWindowEx(
					0x0,    //DWORD dwExStyle, 
					s_szHiddenWndClass,     //LPCTSTR lpszClassName, 
					NULL,   //LPCTSTR lpszWindowName, 
					0x0,    //DWORD dwStyle, 
					0,              //int x, 
					0,              //int y, 
					0,              //int nWidth, 
					0,              //int nHeight, 
					NULL,   //HWND hwndParent, 
					NULL,   //HMENU nIDorHMenu,
					AfxGetInstanceHandle(),
					NULL    //LPVOID lpParam = NULL
					);

	
	listctrl.Create(0, rect, CWnd::FromHandle(hWnd), 0);

	nSize = listctrl.GetStringWidth(pszString);

	// Now destroy the window that we created
	listctrl.DestroyWindow();

	SendMessage(hWnd, WM_CLOSE, 0, 0);

	return nSize;
}

/*!--------------------------------------------------------------------------
	SearchChildNodesForGuid
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT SearchChildNodesForGuid(ITFSNode *pParent, const GUID *pGuid, ITFSNode **ppChild)
{
	HRESULT		hr = hrFalse;
	SPITFSNodeEnum	spNodeEnum;
	SPITFSNode	spNode;

	// Enumerate through all of the child nodes and return the
	// first node that matches the GUID.

	CORg( pParent->GetEnum(&spNodeEnum) );

	while ( spNodeEnum->Next(1, &spNode, NULL) == hrOK )
	{
		if (*(spNode->GetNodeType()) == *pGuid)
			break;
		
		spNode.Release();
	}

	if (spNode)
	{
		if (ppChild)
			*ppChild = spNode.Transfer();
		hr = hrOK;
	}


Error:
	return hr;
}



/*!--------------------------------------------------------------------------
	CheckIPAddressAndMask
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
UINT CheckIPAddressAndMask(DWORD ipAddress, DWORD ipMask, DWORD dwFlags)
{
    if (dwFlags & IPADDRESS_TEST_NONCONTIGUOUS_MASK)
    {
        DWORD   dwNewMask;
        
        // Hmm... how to do this?
        dwNewMask = 0;
        for (int i = 0; i < sizeof(ipMask)*8; i++)
        {            
            dwNewMask |= 1 << i;
            
            if (dwNewMask & ipMask)
            {
                dwNewMask &= ~(1 << i);
                break;
            }
        }

        // At this point dwNewMask is 000..0111
        // ~dwNewMask is 111..1000
        //  ~ipMask is   001..0111 (if noncontiguous)
        // ~dwNewMask & ~ipMask is 001..0000
        // So if this is non-zero then the mask is noncontiguous
        if (~dwNewMask & ~ipMask)
        {
            return IDS_COMMON_ERR_IPADDRESS_NONCONTIGUOUS_MASK;
        }
    }

    if (dwFlags & IPADDRESS_TEST_TOO_SPECIFIC)
    {
        if (ipAddress != (ipAddress & ipMask))
            return IDS_COMMON_ERR_IPADDRESS_TOO_SPECIFIC;
    }

    if (dwFlags & IPADDRESS_TEST_NORMAL_RANGE)
    {
        if ((ipAddress < MAKEIPADDRESS(1,0,0,0)) ||
            (ipAddress >= MAKEIPADDRESS(224,0,0,0)))
            return IDS_COMMON_ERR_IPADDRESS_NORMAL_RANGE;
    }

    if (dwFlags & IPADDRESS_TEST_NOT_127)
    {
        if ((ipAddress & 0xFF000000) == MAKEIPADDRESS(127,0,0,0))
            return IDS_COMMON_ERR_IPADDRESS_127;
    }

    if (dwFlags & IPADDRESS_TEST_ADDR_NOT_EQ_MASK)
    {
        if (ipAddress == ipMask)
            return IDS_COMMON_ERR_IPADDRESS_NOT_EQ_MASK;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\statsdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
   statsdlg.h

   Header file for the base class of the Statistics dialogs.

    FILE HISTORY:
   
*/

#ifndef _STATSDLG_H
#define _STATSDLG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#ifndef _DIALOG_H_
#include "dialog.h"
#endif

#ifndef _COLUMN_H
#include "column.h"
#endif

#include "commres.h"

// forward declarations
struct ColumnData;
class ConfigStream;

class CStatsListCtrl : public CListCtrl
{
public:
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
   
    void CopyToClipboard();

    DECLARE_MESSAGE_MAP();
};

/*---------------------------------------------------------------------------
   These are the available options (they get passed in through
   the StatsDialog constructor).

   STATSDLG_FULLWINDOW
   Makes the list control fill the entire window

   STATSDLG_CONTEXTMENU
   Provides a context menu over the list control.

   STATSDLG_SELECT_COLUMNS
   Allows the user the ability to change the available column set

   STATSDLG_VERTICAL
   The data is displayed with the column headers going vertical rather
   than horizontal.  The user has to be aware of this when writing the
   RefreshData() code.

 ---------------------------------------------------------------------------*/

#define STATSDLG_FULLWINDOW      0x00000001
#define STATSDLG_CONTEXTMENU  0x00000002
#define STATSDLG_SELECT_COLUMNS  0x00000004
#define STATSDLG_VERTICAL     0x00000008
#define STATSDLG_CLEAR        0x00000010
#define STATSDLG_DEFAULTSORT_ASCENDING	0x00010000

class StatsDialog : public CBaseDialog
{
public:
   StatsDialog(DWORD dwOptions);
   virtual ~StatsDialog();

   HRESULT SetColumnInfo(const ContainerColumnInfo *pColumnInfo, UINT cColumnInfo);

   int MapColumnToSubitem(UINT nColumnId);
   BOOL IsSubitemVisible(UINT nSubitemId);
   int MapSubitemToColumn(UINT nSubitemId);

   HANDLE   GetSignalEvent()
         { return m_hEventThreadKilled; }

   void  UnloadHeaders();
    void LoadHeaders();
    
    // sets the width of the columns to the maximum of the text
    void    SetColumnWidths(UINT uNumColumns);
    
   // Posts the command to do a refresh
   void  PostRefresh();

   // Override this to implement the actual insertion of data
   virtual HRESULT RefreshData(BOOL fGrabNewData);

   // This is called prior to deleting all items from the list control
   // This allows for the removal of any private data items
   virtual void PreDeleteAllItems();

   // Override this to implement sorting
   virtual void Sort(UINT nColumn);

   // MFC Overrides
   virtual BOOL OnInitDialog();
   virtual void OnOK();
   virtual void OnCancel();
   virtual void PostNcDestroy();
   virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

   // Sets the configuration info location and the column id
   // for this dialog
   void  SetConfigInfo(ConfigStream *pConfig, ULONG ulId);

   // Sets the preferred size and position
   void  SetPosition(RECT rc);
   void  GetPosition(RECT *prc);

   virtual HRESULT AddToContextMenu(CMenu* pMenu);

   // Deletes all items from the list control
   void  DeleteAllItems();

   // copy data to the clipboard
   void  CopyData();

	//{{AFX_DATA(ColumnDlg)
   CStatsListCtrl      m_listCtrl;
	//}}AFX_DATA

	//{{AFX_VIRTUAL(ColumnDlg)
protected:
	virtual VOID                DoDataExchange(CDataExchange* pDX);
	//}}AFX_VIRTUAL

   DWORD       m_dwOptions;
   ConfigStream * m_pConfig;
   ULONG       m_ulId;     // id to be used when saving/getting info
   ViewInfo    m_viewInfo;
   BOOL        m_bAfterInitDialog;
   BOOL        m_fSortDirection;
   BOOL        m_fDefaultSortDirection;

   RECT  m_rcPosition;

   // These hold the position of the buttons relative to the
   // right and bottom of the dialog.  They are used to hold
   // the resizing information.
   RECT  m_rcList;

   // This holds the minimum size rectangle
   SIZE  m_sizeMinimum;

   // This is used by the thread and the handler (the thread signals
   // the handler that it has cleaned up after itself).
   HANDLE   m_hEventThreadKilled;

protected:
   // These hold the position of the buttons relative to the
   // right and bottom of the dialog.  They are used to hold
   // the resizing information.
   enum
   {
      INDEX_CLOSE = 0,
      INDEX_REFRESH = 1,
      INDEX_SELECT = 2,
        INDEX_CLEAR = 3,
      INDEX_COUNT = 4,  // this is the number of enums
   };
   struct StatsDialogBtnInfo
   {
      ULONG m_ulId;
      RECT  m_rc;
   };

   StatsDialogBtnInfo   m_rgBtn[INDEX_COUNT];
   float m_ColWidthMultiple;
   DWORD m_ColWidthAdder;
   
protected:
	//{{AFX_MSG(StatsDialog)
    virtual afx_msg void OnRefresh();
    afx_msg void OnSelectColumns();
    afx_msg void OnMove(int x, int y);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnGetMinMaxInfo(MINMAXINFO *pMinMax);
    afx_msg void OnContextMenu(CWnd *pWnd, CPoint pos);
    afx_msg void OnNotifyListControlClick(NMHDR *pNmHdr, LRESULT *pResult);
	//}}AFX_MSG

    DECLARE_MESSAGE_MAP();
};

void CreateNewStatisticsWindow(StatsDialog *pWndStats,
                        HWND hWndParent,
                        UINT  nIDD);
void WaitForStatisticsWindow(StatsDialog *pWndStats);

#endif // _STATSDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\timeofday.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	timeofday.cpp
		Implementation of convenient functions to start timeofday dialog

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "timeofday.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// hour map ( one bit for an hour of a week )
static BYTE		bitSetting[8] = { 0x80, 0x40, 0x20, 0x10, 0x8, 0x4, 0x2, 0x1};

//+---------------------------------------------------------------------------
//
// Function:  ReverseHourMap
//
// Synopsis:  reverse each byte in the hour map
//
// we have to do this because LogonUI changes the way HourMap is stored(they
// reversed all the bit. We need to do this so our conversion code can leave
// intact.
//
// Arguments: [in] BYTE* map - hour map
//            [in] INT nByte - how many bytes are in this hour map
//
// History:   byao  4/10/98 10:33:57 PM
//
//+---------------------------------------------------------------------------
void ReverseHourMap(BYTE *map, int nByte)
{
    int i, j, temp;

    for (i=0; i<nByte; i++)
    {
        temp = 0;
        for (j=0;j<8;j++)
        {
            // set the value temp
            if ( map[i] & bitSetting[j] )
            {
                temp |= bitSetting[7-j];
            }
        }
        map[i] = (BYTE) temp;
    }
}

void ShiftHourMap(BYTE* map, int nByte, int nShiftByte)
{
    ASSERT(nShiftByte);
    ASSERT(nByte > abs(nShiftByte));

    nShiftByte = (nByte + nShiftByte) % nByte;

    BYTE*   pTemp = (BYTE*)_alloca(nShiftByte);

    // put the tail to the buffer
    memmove(pTemp, map + nByte - nShiftByte, nShiftByte);
    // shift the body to right
    memmove(map + nShiftByte, map, nByte - nShiftByte);
    // put the tail back to the head
    memcpy(map, pTemp, nShiftByte);
}

HRESULT	OpenTimeOfDayDlgEx(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD   dwFlags
)
{
    PFN_LOGONSCHEDULEDIALOGEX		pfnLogonScheduleDialog = NULL;
    HMODULE						hLogonScheduleDLL      = NULL;
    HRESULT						hr = S_OK;
 
    // ReverseHourMap() will reverse each byte of the hour map, basically
    // reverse every bit in the byte.
    // we have to do this because LogonUI changes the way HourMap is stored(they
    // reversed all the bit. We need to do this so our conversion code can leave
    // intact.
    //
    // We reverse it here so it can be understood by the LogonSchedule api
    //
    ReverseHourMap(*pprgbData,21);

    hLogonScheduleDLL = LoadLibrary(LOGHOURSDLL);
    if ( NULL == hLogonScheduleDLL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AfxMessageBox(IDS_ERR_TOD_LOADLOGHOURDLL);
        goto L_ERR;
	}

	// load the API pointer
    pfnLogonScheduleDialog = (PFN_LOGONSCHEDULEDIALOGEX) GetProcAddress(hLogonScheduleDLL, DIALINHOURSEXAPI);

    if ( NULL == pfnLogonScheduleDialog )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        AfxMessageBox(IDS_ERR_TOD_FINDLOGHOURSAPI);

        goto L_ERR;
    }

    //
    // now we do have this DLL, call the API
    //
    hr = pfnLogonScheduleDialog(hwndParent, pprgbData, pszTitle, dwFlags);
    if (FAILED(hr)) goto L_ERR;

    // We need to reverse it first so our conversion code can understand it.
    //
    ReverseHourMap(*pprgbData,21);

L_ERR:
    if(hLogonScheduleDLL != NULL)
        FreeLibrary(hLogonScheduleDLL);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\task.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	Task.h
        Prototypes for the task holder/enumerator object
		
    FILE HISTORY:
	
*/

#ifndef _TASK_H
#define _TASK_H

typedef CArray<MMC_TASK, MMC_TASK&> CTaskListArray;

class CTaskList : public IEnumTASK
{
public:
    CTaskList();
    virtual ~CTaskList();

	DeclareIUnknownMembers(IMPL)

    // IEnumTASK members
    STDMETHOD(Next)(ULONG celt, MMC_TASK * rgelt, ULONG * pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumTASK ** ppEnumTask);

public:
    // helpers
    HRESULT     AddTask(LPOLESTR        pszMouseOverBitmapResource,
                        LPOLESTR        pszMouseOffBitmapResource,
                        LPOLESTR        pszText,
                        LPOLESTR        pszHelpString,
                        MMC_ACTION_TYPE mmcAction,
                        long            nCommandID);

    HRESULT     AddTask(LPOLESTR        pszMouseOverBitmapResource,
                        LPOLESTR        pszMouseOffBitmapResource,
                        LPOLESTR        pszText,
                        LPOLESTR        pszHelpString,
                        MMC_ACTION_TYPE mmcAction,
                        LPOLESTR        pszActionURLorScript);
protected:
    HRESULT     _Clone(int m_nIndex, CTaskListArray & arrayTasks);
    BOOL        FillTask(MMC_TASK *  pmmcTask, int nIndex);

protected:
    CTaskListArray  m_arrayTasks;
    ULONG           m_uIndex;
    long            m_cRef;
};

#endif _TASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\timeofday.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	timeofday.h
		Definition of timeofday convenient functions 

    FILE HISTORY:
        
*/
#ifndef ___TIME_OF_DAY_H__
#define ___TIME_OF_DAY_H__

#define	LOGHOURSDLL _T("loghours.dll")
#define DIALINHOURSEXAPI "DialinHoursDialogEx"

///////////////////////////////////////////////////////////////////////////////
// Flags for LogonScheduleDialogEx and DialinHoursDialogEx
///////////////////////////////////////////////////////////////////////////////
// The input data is in GMT
#define SCHED_FLAG_INPUT_GMT        0x00000000  // default

// The input data is in local time.
#define SCHED_FLAG_INPUT_LOCAL_TIME 0x00000001

// hour map is an array of bit, each bit maps to a hour
// total 1 week(7 days), 7 * 24 = 21 BYTES
void ReverseHourMap(BYTE *map, int nByte);
void ShiftHourMap(BYTE *map, int nByte, int nShiftByte);

HRESULT	OpenTimeOfDayDlgEx(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD	dwFlags
);

typedef HRESULT (APIENTRY *PFN_LOGONSCHEDULEDIALOGEX)(
                        HWND hwndParent,       // parent window
                        BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                        LPCTSTR pszTitle,     // dialog title
                        DWORD	dwFlags
);
#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addbootp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddBootp.h
		Dialog to add a bootp entry

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry dialog

class CAddBootpEntry : public CBaseDialog
{
// Construction
public:
	CAddBootpEntry(ITFSNode * pNode, LPCTSTR pServerAddress, CWnd* pParent = NULL);   // standard constructor
	~CAddBootpEntry();

// Dialog Data
	//{{AFX_DATA(CAddBootpEntry)
	enum { IDD = IDD_BOOTP_NEW };
	CButton	m_buttonOk;
	CEdit	m_editImageName;
	CEdit	m_editFileName;
	CEdit	m_editFileServer;
	CString	m_strFileName;
	CString	m_strFileServer;
	CString	m_strImageName;
	//}}AFX_DATA

	DWORD GetBootpTable();
	DWORD AddBootpEntryToTable();
	DWORD SetBootpTable();

	void HandleActivation();

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddBootpEntry::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddBootpEntry)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddBootpEntry)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnChangeEditBootpFileName();
	afx_msg void OnChangeEditBootpFileServer();
	afx_msg void OnChangeEditBootpImageName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CString		m_strServerAddress;
	WCHAR *		m_pBootpTable;
	int			m_nBootpTableLength;
	SPITFSNode  m_spNode;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDBOOTP_H__7B0D5D17_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addexcl.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AddExcl.cpp
		Dialog to add an exclusion range

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "scope.h"
#include "mscope.h"
#include "addexcl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion dialog

CAddExclusion::CAddExclusion(ITFSNode * pScopeNode,
                             BOOL       bMulticast,
							 CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddExclusion::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddExclusion)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_spScopeNode.Set(pScopeNode);
    m_bMulticast = bMulticast;
}


void CAddExclusion::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddExclusion)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_FROM, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_TO, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CAddExclusion, CBaseDialog)
	//{{AFX_MSG_MAP(CAddExclusion)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion message handlers

BOOL CAddExclusion::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddExclusion::OnOK() 
{
	CDhcpIpRange dhcpExclusionRange;
	DWORD dwStart, dwEnd, dwError = 0;

	m_ipaStart.GetAddress(&dwStart);
	dhcpExclusionRange.SetAddr(dwStart, TRUE);

	m_ipaEnd.GetAddress(&dwEnd);
	if (!dwEnd)
		dwEnd = dwStart;

	dhcpExclusionRange.SetAddr(dwEnd, FALSE);

	BEGIN_WAIT_CURSOR;
	dwError = IsValidExclusion(dhcpExclusionRange);
	if (dwError != 0)
	{
		::DhcpMessageBox(dwError);
		return;
	}

    dwError = AddExclusion(dhcpExclusionRange);
	END_WAIT_CURSOR;
    
    if (dwError != 0)
	{
		::DhcpMessageBox(dwError);
		return;
	}

	m_ipaStart.ClearAddress();
	m_ipaEnd.ClearAddress();

	m_ipaStart.SetFocus();

	//CBaseDialog::OnOK();
}

DWORD 
CAddExclusion::IsValidExclusion(CDhcpIpRange & dhcpExclusionRange)
{
    if (m_bMulticast)
    {
        CDhcpMScope * pScope = GETHANDLER(CDhcpMScope, m_spScopeNode);
        return pScope->IsValidExclusion(dhcpExclusionRange);
    }
    else
    {
        CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
        return pScope->IsValidExclusion(dhcpExclusionRange);
    }
}

DWORD 
CAddExclusion::AddExclusion(CDhcpIpRange & dhcpExclusionRange)
{
    if (m_bMulticast)
    {
        CDhcpMScope * pScope = GETHANDLER(CDhcpMScope, m_spScopeNode);
        return pScope->AddExclusion(dhcpExclusionRange, TRUE);
    }
    else
    {
        CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
        return pScope->AddExclusion(dhcpExclusionRange, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addexcl.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddExcl.h
		dialog to add an exclusion range

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddExclusion dialog

class CAddExclusion : public CBaseDialog
{
// Construction
public:
	CAddExclusion(ITFSNode * pScopeNode, 
                  BOOL       bMulticast = FALSE,
				  CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddExclusion)
	enum { IDD = IDD_EXCLUSION_NEW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    CWndIpAddress m_ipaStart;     //  Start Address
    CWndIpAddress m_ipaEnd;       //  End Address

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddExclusion::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddExclusion)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	DWORD IsValidExclusion(CDhcpIpRange & dhcpExclusionRange);
    DWORD AddExclusion(CDhcpIpRange & dhcpExclusionRange);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddExclusion)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	SPITFSNode		m_spScopeNode;
    BOOL            m_bMulticast;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDEXCL_H__7B0D5D15_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addbootp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	AddBootp.cpp
		dialog to add a bootp entry
	
	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "addbootp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry dialog


CAddBootpEntry::CAddBootpEntry
(
	ITFSNode *  pNode,	
	LPCTSTR		pServerAddress,
	CWnd*		pParent /*=NULL*/
)
	: CBaseDialog(CAddBootpEntry::IDD, pParent),
	  m_pBootpTable(NULL)
{
	//{{AFX_DATA_INIT(CAddBootpEntry)
	m_strFileName = _T("");
	m_strFileServer = _T("");
	m_strImageName = _T("");
	//}}AFX_DATA_INIT

	m_strServerAddress = pServerAddress;
	m_spNode.Set(pNode);
}

CAddBootpEntry::~CAddBootpEntry()
{
	if (m_pBootpTable)
		free(m_pBootpTable);
}

void CAddBootpEntry::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddBootpEntry)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_EDIT_BOOTP_IMAGE_NAME, m_editImageName);
	DDX_Control(pDX, IDC_EDIT_BOOTP_FILE_NAME, m_editFileName);
	DDX_Control(pDX, IDC_EDIT_BOOTP_FILE_SERVER, m_editFileServer);
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_NAME, m_strFileName);
	DDX_Text(pDX, IDC_EDIT_BOOTP_FILE_SERVER, m_strFileServer);
	DDX_Text(pDX, IDC_EDIT_BOOTP_IMAGE_NAME, m_strImageName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddBootpEntry, CBaseDialog)
	//{{AFX_MSG_MAP(CAddBootpEntry)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_NAME, OnChangeEditBootpFileName)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_FILE_SERVER, OnChangeEditBootpFileServer)
	ON_EN_CHANGE(IDC_EDIT_BOOTP_IMAGE_NAME, OnChangeEditBootpImageName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddBootpEntry message handlers

BOOL CAddBootpEntry::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	HandleActivation();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD CAddBootpEntry::GetBootpTable()
{
	DWORD dwError = 0;
	LPDHCP_SERVER_CONFIG_INFO_V4 pServerConfig = NULL;

    BEGIN_WAIT_CURSOR;
    dwError = ::DhcpServerGetConfigV4(m_strServerAddress, &pServerConfig);
    END_WAIT_CURSOR;

	if (dwError != ERROR_SUCCESS)
	{
		::DhcpMessageBox(dwError);
		return dwError;
	}

	Assert(pServerConfig);

	if (m_pBootpTable)
	{
		delete m_pBootpTable;
		m_pBootpTable = NULL;
	}

	m_nBootpTableLength = pServerConfig->cbBootTableString;
	
	if (m_nBootpTableLength > 0)
	{
		m_pBootpTable = (WCHAR *) malloc(m_nBootpTableLength);
		if (!m_pBootpTable)
			return ERROR_NOT_ENOUGH_MEMORY;

		// copy the bootp table into our local storage so we can modify it
		::CopyMemory(m_pBootpTable, pServerConfig->wszBootTableString, m_nBootpTableLength);
	}

	// release the rpc memory
	::DhcpRpcFreeMemory(pServerConfig);

	return dwError;
}

DWORD CAddBootpEntry::AddBootpEntryToTable()
{
	UpdateData();

	// calculate the length of the new entry.  Entries are stored as:
	// Image,FileServer,FileName<NULL>
	// So the length is the length of the three strings plus 3 characters
	// (two separators and a terminator).  There is also a null terminator
	// for the entire string.
	int nNewBootpEntrySize = (m_strImageName.GetLength() + 
							  m_strFileServer.GetLength() + 
							  m_strFileName.GetLength() + 3) * sizeof(WCHAR);

	int nNewBootpTableLength, nStartIndex;
	nNewBootpTableLength = m_nBootpTableLength + nNewBootpEntrySize;

	WCHAR * pNewBootpTable;
	if (m_nBootpTableLength > 0)
	{
		nStartIndex = m_nBootpTableLength/sizeof(WCHAR) - 1;
		pNewBootpTable = (WCHAR *) realloc(m_pBootpTable, nNewBootpTableLength);
	}
	else
	{
		nStartIndex = 0;
		nNewBootpEntrySize += sizeof(WCHAR);  // for the entire string terminator
		nNewBootpTableLength += sizeof(WCHAR);
		pNewBootpTable = (WCHAR *) malloc(nNewBootpEntrySize);
	}

	if (pNewBootpTable == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	// format the new entry
	CString strNewEntry;
	strNewEntry.Format(_T("%s,%s,%s"), 
					   (LPCTSTR)m_strImageName,
					   (LPCTSTR)m_strFileServer,
					   (LPCTSTR)m_strFileName);
	
	// copy in the new entry
	CopyMemory(&pNewBootpTable[nStartIndex], 
		       strNewEntry, 
			   strNewEntry.GetLength() * sizeof(WCHAR));


	// set the null terminator for this entry and the entire list
	pNewBootpTable[(nNewBootpTableLength/sizeof(WCHAR)) - 2] = '\0';
	pNewBootpTable[(nNewBootpTableLength/sizeof(WCHAR)) - 1] = '\0';

	m_pBootpTable = pNewBootpTable;
	m_nBootpTableLength = nNewBootpTableLength;

	return ERROR_SUCCESS;
}

DWORD CAddBootpEntry::SetBootpTable()
{
	DWORD dwError = 0;
	DHCP_SERVER_CONFIG_INFO_V4 dhcpServerInfo;

	::ZeroMemory(&dhcpServerInfo, sizeof(dhcpServerInfo));

	dhcpServerInfo.cbBootTableString = m_nBootpTableLength;
	dhcpServerInfo.wszBootTableString = m_pBootpTable;

	BEGIN_WAIT_CURSOR;
    dwError = ::DhcpServerSetConfigV4(m_strServerAddress,
									  Set_BootFileTable,
									  &dhcpServerInfo);
    END_WAIT_CURSOR;

	if (dwError != ERROR_SUCCESS)
	{
		::DhcpMessageBox(dwError);
	}

	return dwError;
}

void CAddBootpEntry::OnOK() 
{
	// If we haven't gotten the information yet, then do so now
	if (m_pBootpTable == NULL)
	{
		if (GetBootpTable() != ERROR_SUCCESS)
			return;
	}

	// Add whatever the user entered to the table
	if (AddBootpEntryToTable() != ERROR_SUCCESS)
		return;

	// write the table out 
	if (SetBootpTable() != ERROR_SUCCESS)
		return;

	m_editImageName.SetWindowText(_T(""));
	m_editFileName.SetWindowText(_T(""));
	m_editFileServer.SetWindowText(_T(""));

	m_editImageName.SetFocus();

	// tell the bootp folder to update it's contents
	// this is the easy way to update the info... we could create
	// and individual entry and add it, but we'll just let the 
	// refresh mechanism handle it
	CDhcpBootp * pBootp = GETHANDLER(CDhcpBootp, m_spNode);

	pBootp->OnRefresh(m_spNode, NULL, 0, 0, 0);
}

void CAddBootpEntry::OnChangeEditBootpFileName() 
{
	HandleActivation();
}

void CAddBootpEntry::OnChangeEditBootpFileServer() 
{
	HandleActivation();
}

void CAddBootpEntry::OnChangeEditBootpImageName() 
{
	HandleActivation();
}

void CAddBootpEntry::HandleActivation()
{
	UpdateData();

	if ( (m_strImageName.GetLength() > 0) &&
		 (m_strFileName.GetLength() > 0) &&
	     (m_strFileServer.GetLength() > 0) )
	{
		m_buttonOk.EnableWindow(TRUE);
	}
	else
	{
		m_buttonOk.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\xstream.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	xstream.h
		
    FILE HISTORY:
        
*/

#ifndef _XSTREAM_H
#define _XSTREAM_H


struct ColumnData
{
	ColumnData()
	{
		fmt = LVCFMT_LEFT;
	}
	// This value may be positive or negative.  If >0, then this column
	// is visible.  If <0 then the column is invisible.  In either case
	// the absolute value is the relative position of the column (this
	// position is used only for the "select columns" dialog.
	// If the value is ==0 then it's an error.
	LONG	m_nPosition;

	// Width of the column
	DWORD	m_dwWidth;

	// Format of the column:
	// LVCFMT_LEFT  Text is left-aligned. 
	// LVCFMT_RIGHT Text is right-aligned 
	int fmt;
};



class XferStream
{
public:
	enum Mode
	{
		MODE_READ,
		MODE_WRITE,
		MODE_SIZE
	};

	XferStream(IStream *pstm, Mode mode);

	HRESULT	XferDWORD(ULONG ulId, DWORD *pdwData);
	HRESULT XferCString(ULONG ulId, CString *pstData);
	HRESULT XferLARGEINTEGER(ULONG ulId, LARGE_INTEGER *pliData);
	HRESULT XferRect(ULONG ulId, RECT *prc);

	HRESULT	XferDWORDArray(ULONG ulId, ULONG *pcArray, DWORD *pdwArray);
	HRESULT	XferColumnData(ULONG ulId, ULONG *pcData, ColumnData *pdwData);

    HRESULT	XferDWORDArray(ULONG ulId, CDWordArray * pdwArray);
    HRESULT	XferCStringArray(ULONG ulId, CStringArray * pstrArray);

	DWORD	GetSize() { return m_dwSize; };

private:
	HRESULT	_XferCString(CString * pstData);
	HRESULT	_XferLONG(LONG *plData);
	HRESULT	_XferDWORD(DWORD *pdwData);
	HRESULT _XferBytes(LPBYTE pData, ULONG cbLength);
	HRESULT	_XferObjectId(ULONG *pulId);

	DWORD		m_dwSize;
	SPIStream	m_spstm;
	XferStream::Mode m_mode;
};

#define XFER_DWORD			    0x0001
#define XFER_STRING			    0x0002
#define XFER_COLUMNDATA		    0x0003
#define XFER_LARGEINTEGER       0x0004
#define XFER_RECT				0x0005

#define XFER_ARRAY			    0x8000
#define XFER_DWORD_ARRAY	    (XFER_DWORD | XFER_ARRAY)
#define XFER_COLUMNDATA_ARRAY   (XFER_COLUMNDATA | XFER_ARRAY)
#define XFER_STRING_ARRAY       (XFER_STRING | XFER_ARRAY)

#define XFER_TAG(id,type)	    (((id) << 16) | (type))

#define XFER_TYPE_FROM_TAG(x)	( 0x0000FFFF & (x) )
#define XFER_ID_FROM_TAG(x)		( 0x0000FFFF & ( (x) >> 16 ))

#endif _XSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addres.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	AddRes.cpp
		Dialog to add a reservation

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "scope.h"
#include "addres.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RADIO_CLIENT_TYPE_BOTH  0
#define RADIO_CLIENT_TYPE_DHCP  1
#define RADIO_CLIENT_TYPE_BOOTP 2

/////////////////////////////////////////////////////////////////////////////
// CAddReservation dialog


CAddReservation::CAddReservation(ITFSNode *     pScopeNode,
                                 LARGE_INTEGER  liVersion,
								 CWnd*          pParent /*=NULL*/)
	: CBaseDialog(CAddReservation::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddReservation)
	m_nClientType = -1;
	//}}AFX_DATA_INIT

	m_spScopeNode.Set(pScopeNode);
	m_pScopeObject = GETHANDLER(CDhcpScope, pScopeNode);
	m_bChange = FALSE;  // We are creating new clients, not changing
    m_liVersion = liVersion;

    // the default client type is BOTH
    m_nClientType = RADIO_CLIENT_TYPE_BOTH;
}

void CAddReservation::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddReservation)
	DDX_Control(pDX, IDC_STATIC_CLIENT_TYPE, m_staticClientType);
	DDX_Control(pDX, IDC_EDIT_CLIENT_UID, m_editClientUID);
	DDX_Control(pDX, IDC_EDIT_CLIENT_NAME, m_editClientName);
	DDX_Control(pDX, IDC_EDIT_CLIENT_COMMENT, m_editClientComment);
	DDX_Radio(pDX, IDC_RADIO_TYPE_BOTH, m_nClientType);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_RESERVATION_IP, m_ipaAddress);
}


BEGIN_MESSAGE_MAP(CAddReservation, CBaseDialog)
	//{{AFX_MSG_MAP(CAddReservation)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddReservation message handlers

BOOL CAddReservation::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    m_editClientName.LimitText( STRING_LENGTH_MAX ) ;
    m_editClientComment.LimitText( STRING_LENGTH_MAX ) ;

	FillInSubnetId();
	
    if (m_liVersion.QuadPart < DHCP_SP2_VERSION)
    {
        m_staticClientType.ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_DHCP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOOTP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOTH)->ShowWindow(SW_HIDE);
    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddReservation::OnOK() 
{
	DWORD err = 0;
	CDhcpClient dhcpClient;

    UpdateData();

    if ( m_bChange ) 
    {   
        err = UpdateClient(&dhcpClient);
    }
    else
    {
        err = CreateClient(&dhcpClient);
    }

    if ( err == ERROR_SUCCESS )
    {
        //
        // the dialog only gets dismissed if we're editing an
        // existing client (because we may want to add more than
        // one client)
        //
        if (m_bChange)
        {
            CBaseDialog::OnOK();
        }
        else
        {
            //
            // Get ready for the next client to be added.
            //
            m_editClientUID.SetWindowText(_T(""));
            m_editClientName.SetWindowText(_T(""));
            m_editClientComment.SetWindowText(_T(""));
            FillInSubnetId();

            //
            // And continue on...
            //
        }
    }
    else
    {
        // don't put up another error box for this case, 
        // we already asked the user
        if (err != IDS_UID_MAY_BE_WRONG)
        {
            ::DhcpMessageBox(err);
        }

		return;
    }

	//CBaseDialog::OnOK();
}

//
//  For new clients, fill in what we can on the ip address control (i.e.
//  the subnet id portion
//
void 
CAddReservation::FillInSubnetId()
{
    DWORD dwIp = m_pScopeObject->GetAddress() & m_pScopeObject->QuerySubnetMask();

    m_ipaAddress.ClearAddress();
    int i = 0;
    while (i < sizeof(dwIp))
    {
        if (!dwIp)
        {
            break;
        }
        m_ipaAddress.SetField(i, TRUE, HIBYTE(HIWORD(dwIp)));
        dwIp <<= 8;

        ++i;
    }
    
	if (i < sizeof(dwIp))
    {
        m_ipaAddress.SetFocusField(i);
    }
}

//
//  Construct the client structure from the dialog's edit controls.             
//
LONG 
CAddReservation::BuildClient
(
	CDhcpClient * pClient
)
{
    DWORD				err = 0;
    CString				str;
    DATE_TIME			dt;
    DHCP_IP_ADDRESS		dhipa;
    CByteArray			cabUid;
	int					i;
	BOOL				fValidUID = TRUE;

    CATCH_MEM_EXCEPTION
    {
        do
        {
            dt.dwLowDateTime  = DHCP_DATE_TIME_ZERO_LOW;
            dt.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

            pClient->SetExpiryDateTime( dt );

            m_ipaAddress.GetAddress( &dhipa );
            if ( dhipa == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_IPADDR ;
                m_ipaAddress.SetFocusField(-1);
                 break ;
            }

			m_editClientUID.GetWindowText(str);
			if (str.IsEmpty())
			{
                err = IDS_ERR_INVALID_UID ;
                m_editClientUID.SetSel(0,-1);
                m_editClientUID.SetFocus();
                break ; 
            }
			
			// 
            // Since the rest of the Windows UI displays MAC addresses as
            // 00-00-00-00-00-00, we must strip out the dashes before
            // processing the mac address
            //
            int nLength = str.GetLength();
	        LPTSTR pstrSource = str.GetBuffer(nLength);
	        LPTSTR pstrDest = pstrSource;
	        LPTSTR pstrEnd = pstrSource + nLength;

	        while (pstrSource < pstrEnd)
	        {
		        if (*pstrSource != '-')
		        {
			        *pstrDest = *pstrSource;
			        pstrDest = _tcsinc(pstrDest);
		        }
		        pstrSource = _tcsinc(pstrSource);
	        }
	        *pstrDest = '\0';

            str.ReleaseBuffer();

            //
			// Client UIDs should be 48 bits (6 bytes or 12 hex characters)
			//
			if (str.GetLength() != 6 * 2)
				fValidUID = FALSE;
			
			for (i = 0; i < str.GetLength(); i++)
			{
				if (!wcschr(rgchHex, str[i]))
					fValidUID = FALSE;
			}

			if (!::UtilCvtHexString(str, cabUid) && fValidUID)
			{
				err = IDS_ERR_INVALID_UID ;
                m_editClientUID.SetSel(0,-1);
                m_editClientUID.SetFocus();
                break ; 
			}

            // UIDs must be <= 255 bytes
            if (cabUid.GetSize() > 255)
            {
                err = IDS_UID_TOO_LONG;
                break;
            }

            if (!fValidUID)
			{
				if (IDYES != AfxMessageBox(IDS_UID_MAY_BE_WRONG, MB_ICONQUESTION | MB_YESNO))
				{
    	            m_editClientUID.SetSel(0,-1);
	                m_editClientUID.SetFocus();
					err = IDS_UID_MAY_BE_WRONG;
					break;
				}
			}

			pClient->SetHardwareAddress( cabUid ) ;

            m_editClientName.GetWindowText( str ) ;
            if ( str.GetLength() == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_NAME ;
                m_editClientName.SetFocus();
                break ;
            }

            //
            // Convert client name to oem
            //
            pClient->SetName( str ) ;
            m_editClientComment.GetWindowText( str ) ;
            pClient->SetComment( str ) ;

            //
            // Can't change IP address in change mode
            //
            ASSERT ( !m_bChange || dhipa == pClient->QueryIpAddress() ) ;

            pClient->SetIpAddress( dhipa ) ;

            // 
            // Set the client type
            //
            if (m_liVersion.QuadPart >= DHCP_SP2_VERSION)
            {
                switch (m_nClientType)
                {
                    case RADIO_CLIENT_TYPE_DHCP:
                        pClient->SetClientType(CLIENT_TYPE_DHCP);
                        break;
                    
                    case RADIO_CLIENT_TYPE_BOOTP:
                        pClient->SetClientType(CLIENT_TYPE_BOOTP);
                        break;

                    case RADIO_CLIENT_TYPE_BOTH:
                        pClient->SetClientType(CLIENT_TYPE_BOTH);
                        break;

                    default:
                        Assert(FALSE);  // should never get here
                        break;
                }
            }

        }
        while ( FALSE ) ;
    }
    END_MEM_EXCEPTION( err ) ;

    return err ;
}

//
//  Creates a new reservation for this scope
//
LONG 
CAddReservation::CreateClient
(
	CDhcpClient * pClient
)
{
    LONG err = BuildClient(pClient);
    if ( err == 0 ) 
    {
        BEGIN_WAIT_CURSOR;
        err = m_pScopeObject->CreateReservation(pClient);
        END_WAIT_CURSOR;
    }

    return err ;
}

LONG 
CAddReservation::UpdateClient
(
	CDhcpClient * pClient
)
{
    LONG err = BuildClient(pClient) ;
    if ( err == 0 ) 
    {
         err = m_pScopeObject->SetClientInfo(pClient);
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\common\xstream.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	xstream.cpp
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "tfschar.h"
#include "xstream.h"

/*!--------------------------------------------------------------------------
	XferStream::XferStream
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
XferStream::XferStream(IStream *pstm, Mode mode)
{
	m_spstm.Set(pstm);
	m_mode = mode;
	m_dwSize = 0;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORD
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORD(ULONG ulId, DWORD *pdwData)
{
	ULONG	id;
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD );

	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD)
		return E_INVALIDARG;

	CORg( _XferDWORD(pdwData) );
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferCString
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferCString(ULONG ulId, CString *pstData)
{
	HRESULT	hr = hrOK;
	ULONG	cbLength;
	LPWSTR	pswzData;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_STRING );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_STRING)
		return E_INVALIDARG;

    CORg( _XferCString(pstData) );

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferLARGEINTEGER
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferLARGEINTEGER(ULONG ulId, LARGE_INTEGER *pliData)
{
	ULONG	id;
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );

	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_LARGEINTEGER );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_LARGEINTEGER)
		return E_INVALIDARG;

	CORg( _XferDWORD(&pliData->LowPart) );
	CORg( _XferLONG(&pliData->HighPart) );
	
Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORDArray
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORDArray(ULONG ulId, ULONG *pcArray, DWORD *pdwArray)
{
	HRESULT	hr = hrOK;
	ULONG	i;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD_ARRAY)
		return E_INVALIDARG;

	CORg( _XferDWORD(pcArray) );

	for (i=0; i<*pcArray; i++)
	{
		// Xfer each dword
		hr = _XferDWORD(pdwArray+i);
		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferCStringArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferCStringArray(ULONG ulId, CStringArray *pstrArray)
{
	HRESULT	hr = hrOK;
	ULONG	i, cArray;
	LPWSTR	pswzData;

	CORg( _XferObjectId(&ulId) );

    Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_STRING_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_STRING_ARRAY)
		return E_INVALIDARG;

	if (m_mode == XferStream::MODE_WRITE)
    {
		cArray = (ULONG)pstrArray->GetSize();
    }

	CORg( _XferDWORD(&cArray) );

	if (m_mode == XferStream::MODE_READ)
    {
        pstrArray->SetSize(cArray);
    }

    for (i = 0; i < cArray; i++)
	{
        _XferCString( &((*pstrArray)[i]) );
		if (!FHrSucceeded(hr))
			break;
    }

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferDWORDArray
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferDWORDArray(ULONG ulId, CDWordArray * pdwArray)
{
	HRESULT	hr = hrOK;
	ULONG	i, cArray;

	CORg( _XferObjectId(&ulId) );
	
    Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_DWORD_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_DWORD_ARRAY)
		return E_INVALIDARG;

	if (m_mode == XferStream::MODE_WRITE)
    {
		cArray = (ULONG)pdwArray->GetSize();
    }

	CORg( _XferDWORD(&cArray) );

	if (m_mode == XferStream::MODE_READ)
    {
        pdwArray->SetSize(cArray);
    }

	for (i = 0; i < cArray; i++)
	{
		// Xfer each dword
		hr = _XferDWORD( &((*pdwArray)[i]) );
		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}




/*!--------------------------------------------------------------------------
	XferStream::_XferObjectId
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferObjectId(ULONG *pulId)
{
	ULONG	id = 0;
	HRESULT	hr = hrOK;
	
	if (m_mode == XferStream::MODE_WRITE)
		id = *pulId;
	hr = _XferDWORD(&id);
	*pulId = id;

	return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferDWORD
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferDWORD(DWORD *pdw)
{
	ULONG	cbBytes;
	HRESULT	hr = hrOK;

	switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = m_spstm->Read(pdw, sizeof(DWORD), &cbBytes);
			Assert(cbBytes == sizeof(DWORD));
			if (cbBytes != sizeof(DWORD))
				hr = E_FAIL;
			break;
		case XferStream::MODE_WRITE:
			hr = m_spstm->Write(pdw, sizeof(DWORD), &cbBytes);
			Assert(cbBytes == sizeof(DWORD));	
			break;
		case XferStream::MODE_SIZE:
			m_dwSize += sizeof(DWORD);
			break;
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}
	
	return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferLONG
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferLONG(LONG * pdl)
{
	return _XferDWORD((DWORD *) pdl);
}

/*!--------------------------------------------------------------------------
	XferStream::_XferCString
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferCString(CString * pstData)
{
	HRESULT	hr = hrOK;
    ULONG   cbLength;
    LPWSTR  pswzData;

    Assert(pstData);
    
    switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = _XferDWORD(&cbLength);

			if (FHrSucceeded(hr))
			{
				pswzData = (LPWSTR) alloca(cbLength);
				hr = _XferBytes((LPBYTE) pswzData, cbLength);
				
				if (FHrSucceeded(hr))
					*pstData = W2CT(pswzData);
			}
			
			break;

		case XferStream::MODE_SIZE:
		case XferStream::MODE_WRITE:
			cbLength = (pstData->GetLength()+1) * sizeof(WCHAR);
			// round the length up to a multiple of 4
			cbLength  = (cbLength + 3) & 0xFFFFFFFC;
			
			hr = _XferDWORD(&cbLength);

			if (FHrSucceeded(hr))
			{
				pswzData = (LPWSTR) alloca(cbLength);
				StrCpyWFromT(pswzData, (LPCTSTR) *pstData);
			
				hr = _XferBytes((LPBYTE) pswzData, cbLength);
			}
			break;
			
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}

    return hr;
}


/*!--------------------------------------------------------------------------
	XferStream::_XferBytes
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::_XferBytes(LPBYTE pData, ULONG cbLength)
{
	ULONG	cbBytes;
	HRESULT	hr = hrOK;

	switch (m_mode)
	{
		case XferStream::MODE_READ:
			hr = m_spstm->Read(pData, cbLength, &cbBytes);
			Assert(cbBytes == cbLength);
			break;
		case XferStream::MODE_WRITE:
			hr = m_spstm->Write(pData, cbLength, &cbBytes);
			Assert(cbBytes == cbLength);	
			break;
		case XferStream::MODE_SIZE:
			m_dwSize += cbLength;
			break;
		default:
			hr = E_INVALIDARG;
			Panic1("Unknown XferStream mode! %d\n", m_mode);
			break;
	}
	
	return hr;
}
/*!--------------------------------------------------------------------------
	XferStream::XferColumnData
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferColumnData(ULONG ulId, ULONG *pcData, ColumnData *pData)
{
	HRESULT	hr = hrOK;
	ULONG	i;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_COLUMNDATA_ARRAY );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_COLUMNDATA_ARRAY)
		return E_INVALIDARG;

	CORg( _XferDWORD(pcData) );

	for (i=0; i<*pcData; i++)
	{
		// Xfer each dword
		hr = _XferLONG(&(pData[i].m_nPosition));
		Assert(pData[i].m_nPosition != 0);
		if (FHrSucceeded(hr))
			hr = _XferDWORD(&(pData[i].m_dwWidth));

		if (!FHrSucceeded(hr))
			break;
	}

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	XferStream::XferRect
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT XferStream::XferRect(ULONG ulId, RECT *prc)
{
	HRESULT	hr = hrOK;

	CORg( _XferObjectId(&ulId) );
	Assert( XFER_TYPE_FROM_TAG(ulId) == XFER_RECT );
	if (XFER_TYPE_FROM_TAG(ulId) != XFER_RECT)
		return E_INVALIDARG;

	CORg( _XferDWORD((DWORD *) &(prc->top)) );
	CORg( _XferDWORD((DWORD *) &(prc->left)) );
	CORg( _XferDWORD((DWORD *) &(prc->bottom)) );
	CORg( _XferDWORD((DWORD *) &(prc->right)) );

Error:
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addtoss.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addtoss.h
		The add scope to superscope dialog
		
    FILE HISTORY:
        
*/

#if !defined(AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_)
#define AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope dialog

class CAddScopeToSuperscope : public CBaseDialog
{
// Construction
public:
	CAddScopeToSuperscope(ITFSNode * pScopeNode, 
                          LPCTSTR    pszTitle = NULL, 
                          CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddScopeToSuperscope)
	enum { IDD = IDD_ADD_TO_SUPERSCOPE };
	CButton	m_buttonOk;
	CListBox	m_listSuperscopes;
	//}}AFX_DATA

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddScopeToSuperscope::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddScopeToSuperscope)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    void SetButtons();

	// Generated message map functions
	//{{AFX_MSG(CAddScopeToSuperscope)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListSuperscopes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    SPITFSNode m_spScopeNode;
    CString    m_strTitle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDTOSS_H__B5DA3C60_F6FE_11D0_BBF3_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	AddRes.h
		Dialog to add a reservation

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
#define AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddReservation dialog

class CAddReservation : public CBaseDialog
{
// Construction
public:
	CAddReservation(ITFSNode *	    pNode,
                    LARGE_INTEGER   liVersion,
					CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddReservation)
	enum { IDD = IDD_RESERVATION_NEW };
	CStatic	m_staticClientType;
	CEdit	m_editClientUID;
	CEdit	m_editClientName;
	CEdit	m_editClientComment;
	int		m_nClientType;
	//}}AFX_DATA

    CWndIpAddress m_ipaAddress;       //  Reservation Address

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddReservation::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddReservation)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void FillInSubnetId();
	LONG CreateClient(CDhcpClient * pClient);
	LONG UpdateClient(CDhcpClient * pClient);
	LONG BuildClient(CDhcpClient * pClient);

	// Generated message map functions
	//{{AFX_MSG(CAddReservation)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	SPITFSNode			m_spScopeNode;
	CDhcpScope *		m_pScopeObject;
	BOOL				m_bChange;       // changing existing entry or creating new
    LARGE_INTEGER       m_liVersion;     // version of the server we are talking to
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDRES_H__7B0D5D16_B501_11D0_AB8E_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Classes.h
		This file contains all of the prototypes for the 
		option class dialog.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "classes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses dialog


CDhcpClasses::CDhcpClasses(CClassInfoArray * pClassArray, LPCTSTR pszServer, DWORD dwType, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDhcpClasses::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpClasses)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_dwType = dwType;
    m_strServer = pszServer;
    m_pClassInfoArray = pClassArray;
}


void CDhcpClasses::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpClasses)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDhcpClasses, CBaseDialog)
	//{{AFX_MSG_MAP(CDhcpClasses)
	ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
	ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
	ON_BN_CLICKED(IDC_BUTTON_NEW, OnButtonNew)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_CLASSES, OnItemchangedListClasses)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_CLASSES, OnDblclkListClasses)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses message handlers

BOOL CDhcpClasses::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString strTitle;

	if (m_dwType == CLASS_TYPE_VENDOR)
    {
        strTitle.LoadString(IDS_VENDOR_CLASSES);
    }
    else
    {
        strTitle.LoadString(IDS_USER_CLASSES);
    }
	
    this->SetWindowText(strTitle);

    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    LV_COLUMN lvColumn;
    CString   strText;

    strText.LoadString(IDS_NAME);

    ListView_SetExtendedListViewStyle(pListCtrl->GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 125;
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    
    pListCtrl->InsertColumn(0, &lvColumn);

    strText.LoadString(IDS_COMMENT);
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    lvColumn.cx = 175;
    pListCtrl->InsertColumn(1, &lvColumn);
       
    UpdateList();

    UpdateButtons();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDhcpClasses::OnButtonDelete() 
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);
    CString strMessage;

    AfxFormatString1(strMessage, IDS_CONFIRM_CLASS_DELETE, pClassInfo->strName);
    
    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        DWORD dwError = ::DhcpDeleteClass((LPTSTR) ((LPCTSTR) m_strServer),
                                          0,
                                          (LPTSTR) ((LPCTSTR) pClassInfo->strName));
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return;
        }
        else
        {
            m_pClassInfoArray->RemoveClass(pClassInfo->strName);
            UpdateList();
            UpdateButtons();
        }
    }
}

void CDhcpClasses::OnButtonEdit() 
{
    CDhcpModifyClass dlgModify(m_pClassInfoArray, m_strServer, FALSE, m_dwType);
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);

    // Find the selected item
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);

    CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);

    dlgModify.m_EditValueParam.pValueName = (LPTSTR) ((LPCTSTR) pClassInfo->strName);
	dlgModify.m_EditValueParam.pValueComment = (LPTSTR) ((LPCTSTR) pClassInfo->strComment);
	dlgModify.m_EditValueParam.pValueData = pClassInfo->baData.GetData();
	dlgModify.m_EditValueParam.cbValueData = (UINT)pClassInfo->baData.GetSize();

    if (dlgModify.DoModal() == IDOK)
    {
        // need to refresh the view.
        UpdateList();
        UpdateButtons();
    }
}

void CDhcpClasses::OnButtonNew() 
{
    CDhcpModifyClass dlgModify(m_pClassInfoArray, m_strServer, TRUE, m_dwType);

    if (dlgModify.DoModal() == IDOK)
    {
        // need to refresh the view.
        UpdateList();
        UpdateButtons();
    }
}

void CDhcpClasses::OnOK() 
{
	CBaseDialog::OnOK();
}

void CDhcpClasses::UpdateList()
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    pListCtrl->DeleteAllItems();

    for (int i = 0; i < m_pClassInfoArray->GetSize(); i++)
    {
        // add the appropriate classes depending on what we are looking at
        if ( (m_dwType == CLASS_TYPE_VENDOR &&
              (*m_pClassInfoArray)[i].bIsVendor) ||
             (m_dwType == CLASS_TYPE_USER &&
              !(*m_pClassInfoArray)[i].bIsVendor) )
        {
            int nPos = pListCtrl->InsertItem(i, (*m_pClassInfoArray)[i].strName);
            pListCtrl->SetItemText(nPos, 1, (*m_pClassInfoArray)[i].strComment);
            pListCtrl->SetItemData(nPos, (LPARAM) &(*m_pClassInfoArray)[i]);
        }
    }
}

void CDhcpClasses::UpdateButtons()
{
    CListCtrl * pListCtrl = (CListCtrl *) GetDlgItem(IDC_LIST_CLASSES);
    BOOL bEnable = TRUE;
    CWnd * pCurFocus = GetFocus();

    if (pListCtrl->GetSelectedCount() == 0)
    {
        bEnable = FALSE;
    }

    CWnd * pEdit = GetDlgItem(IDC_BUTTON_EDIT);
    CWnd * pDelete = GetDlgItem(IDC_BUTTON_DELETE);

    if ( !bEnable &&
         ((pCurFocus == pEdit) ||
          (pCurFocus == pDelete)) )
    {
        GetDlgItem(IDCANCEL)->SetFocus();
        SetDefID(IDCANCEL);

        ((CButton *) pEdit)->SetButtonStyle(BS_PUSHBUTTON);
        ((CButton *) pDelete)->SetButtonStyle(BS_PUSHBUTTON);
    }

    // disable delete if this is the dynamic bootp class
    int nSelectedItem = pListCtrl->GetNextItem(-1, LVNI_SELECTED);
    if (nSelectedItem != -1)
    {
        CClassInfo * pClassInfo = (CClassInfo *) pListCtrl->GetItemData(nSelectedItem);
    
        if (pClassInfo->IsSystemClass() ||
			pClassInfo->IsRRASClass() ||
			pClassInfo->IsDynBootpClass())
        {
            bEnable = FALSE;
        }
    }

    pDelete->EnableWindow(bEnable);
    pEdit->EnableWindow(bEnable);
}

void CDhcpClasses::OnItemchangedListClasses(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	
    UpdateButtons();
	
	*pResult = 0;
}

void CDhcpClasses::OnDblclkListClasses(NMHDR* pNMHDR, LRESULT* pResult) 
{
    if (GetDlgItem(IDC_BUTTON_EDIT)->IsWindowEnabled())
        OnButtonEdit();
    
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addtoss.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	addtoss.cpp
		The add scope to superscope dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "AddToSS.h"
#include "server.h"
#include "scope.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope dialog


CAddScopeToSuperscope::CAddScopeToSuperscope
(
    ITFSNode * pScopeNode,
    LPCTSTR    pszTitle,
    CWnd* pParent /*=NULL*/
)	: CBaseDialog(CAddScopeToSuperscope::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddScopeToSuperscope)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_strTitle = pszTitle;
    m_spScopeNode.Set(pScopeNode);
}


void CAddScopeToSuperscope::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddScopeToSuperscope)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_LIST_SUPERSCOPES, m_listSuperscopes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddScopeToSuperscope, CBaseDialog)
	//{{AFX_MSG_MAP(CAddScopeToSuperscope)
	ON_LBN_SELCHANGE(IDC_LIST_SUPERSCOPES, OnSelchangeListSuperscopes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddScopeToSuperscope message handlers

BOOL CAddScopeToSuperscope::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    SPITFSNode      spServerNode;
    SPITFSNode      spCurrentNode;
    SPITFSNodeEnum  spNodeEnum;
    ULONG           nNumReturned = 0;

    m_spScopeNode->GetParent(&spServerNode);
    spServerNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
			// found a superscope
			//
			CString strName;
            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);
            
            strName = pSuperscope->GetName();

            m_listSuperscopes.AddString(strName);
		}

		spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    SetButtons();

    if (!m_strTitle.IsEmpty())
        SetWindowText(m_strTitle);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddScopeToSuperscope::OnOK() 
{
    DWORD   err;
    CString strSuperscope;
    
    // Get the currently selected node
    int nCurSel = m_listSuperscopes.GetCurSel();
    Assert(nCurSel != LB_ERR);
    
    m_listSuperscopes.GetText(nCurSel, strSuperscope);
    
    if (strSuperscope.IsEmpty())
        Assert(FALSE);

    // now try to set this scope as part of the superscope
    CDhcpScope * pScope = GETHANDLER(CDhcpScope, m_spScopeNode);
    
    BEGIN_WAIT_CURSOR;
    err = pScope->SetSuperscope(strSuperscope, FALSE);
    END_WAIT_CURSOR;

    if (err != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(err);
        return;
    }

    // that worked, now move the UI stuff around.
    SPITFSNode      spServerNode;
    SPITFSNode      spCurrentNode;
    SPITFSNodeEnum  spNodeEnum;
    ULONG           nNumReturned = 0;

    m_spScopeNode->GetParent(&spServerNode);
    spServerNode->GetEnum(&spNodeEnum);

    // remove the scope from the UI
    spServerNode->RemoveChild(m_spScopeNode);
    pScope->SetInSuperscope(FALSE);

    // find the superscope we want to add this scope to and refresh it so that
    // the scope shows up in that node
    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_SUPERSCOPE)
        {
			// found a superscope
			CString strName;
            CDhcpSuperscope * pSuperscope = GETHANDLER(CDhcpSuperscope, spCurrentNode);
            
            strName = pSuperscope->GetName();
    
            // is this the one?
            if (strName.Compare(strSuperscope) == 0)
            {
                // this is the one we are adding to.  Force a refresh.
                pSuperscope->OnRefresh(spCurrentNode, NULL, 0, 0, 0);
                break;
            }
		}

		// go to the next one
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

    CBaseDialog::OnOK();
}

void CAddScopeToSuperscope::OnSelchangeListSuperscopes() 
{
    SetButtons();	
}

void CAddScopeToSuperscope::SetButtons()
{
    if (m_listSuperscopes.GetCurSel() != LB_ERR)
    {
        m_buttonOk.EnableWindow(TRUE);
    }
    else
    {
        m_buttonOk.EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addserv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
        addserv.cpp
                The add server dialog
                
    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "AddServ.h"

#include <objpick.h> // for CGetComputer

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CALLBACK AddServerCompareFunc
(
    LPARAM lParam1, 
    LPARAM lParam2, 
    LPARAM lParamSort
)
{
    return ((CAddServer *) lParamSort)->HandleSort(lParam1, lParam2);
}

/////////////////////////////////////////////////////////////////////////////
// CAddServer dialog


CAddServer::CAddServer(CWnd* pParent /*=NULL*/)
        : CBaseDialog(CAddServer::IDD, pParent)
{
        //{{AFX_DATA_INIT(CAddServer)
        //}}AFX_DATA_INIT

    ResetSort();
}


void CAddServer::DoDataExchange(CDataExchange* pDX)
{
        CBaseDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAddServer)
        DDX_Control(pDX, IDC_RADIO_AUTHORIZED_SERVERS, m_radioAuthorizedServer);
        DDX_Control(pDX, IDOK, m_buttonOk);
        DDX_Control(pDX, IDC_RADIO_ANY_SERVER, m_radioAnyServer);
        DDX_Control(pDX, IDC_EDIT_ADD_SERVER_NAME, m_editServer);
        DDX_Control(pDX, IDC_BUTTON_BROWSE_SERVERS, m_buttonBrowse);
        DDX_Control(pDX, IDC_LIST_AUTHORIZED_SERVERS, m_listctrlServers);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddServer, CBaseDialog)
        //{{AFX_MSG_MAP(CAddServer)
        ON_BN_CLICKED(IDC_BUTTON_BROWSE_SERVERS, OnButtonBrowseServers)
        ON_BN_CLICKED(IDC_RADIO_ANY_SERVER, OnRadioAnyServer)
        ON_BN_CLICKED(IDC_RADIO_AUTHORIZED_SERVERS, OnRadioAuthorizedServers)
        ON_EN_CHANGE(IDC_EDIT_ADD_SERVER_NAME, OnChangeEditAddServerName)
        ON_WM_TIMER()
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_AUTHORIZED_SERVERS, OnItemchangedListAuthorizedServers)
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_AUTHORIZED_SERVERS, OnColumnclickListAuthorizedServers)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddServer message handlers

BOOL CAddServer::OnInitDialog() 
{
    CBaseDialog::OnInitDialog();
        
    LV_COLUMN lvColumn;
    CString   strText;

    strText.LoadString(IDS_NAME);

    ListView_SetExtendedListViewStyle(m_listctrlServers.GetSafeHwnd(), LVS_EX_FULLROWSELECT);

    lvColumn.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = 175;
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    
    m_listctrlServers.InsertColumn(0, &lvColumn);

    strText.LoadString(IDS_IP_ADDRESS);
    lvColumn.pszText = (LPTSTR) (LPCTSTR) strText;
    lvColumn.cx = 100;
    m_listctrlServers.InsertColumn(1, &lvColumn);

    m_editServer.SetFocus();
    m_radioAnyServer.SetCheck(TRUE);

    UpdateControls();
    
    FillListCtrl();

    m_lSelSrv.RemoveAll();

    return FALSE;  // return TRUE unless you set the focus to a control
                      // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddServer::OnOK() 
{
    GetInfo();

    CleanupTimer();

    CBaseDialog::OnOK();
}

void CAddServer::OnCancel() 
{
    CleanupTimer();
    
    CBaseDialog::OnCancel();
}

void CAddServer::OnButtonBrowseServers() 
{
    CGetComputer dlgGetComputer;
    BOOL success;

    success = dlgGetComputer.GetComputer(::FindMMCMainWindow());
    
    // Return the focus back to this window
    SetFocus();

    if ( !success ) {
        return;
    }

    m_editServer.SetWindowText(dlgGetComputer.m_strComputerName);
}

void CAddServer::OnRadioAnyServer() 
{
        UpdateControls();
}

void CAddServer::OnRadioAuthorizedServers() 
{
    UpdateControls();
}

void CAddServer::OnChangeEditAddServerName() 
{
    UpdateControls();
}

void CAddServer::OnTimer(UINT nIDEvent) 
{
    if (m_pServerList->IsInitialized())
    {
        m_radioAuthorizedServer.EnableWindow(TRUE);

        CleanupTimer();

        FillListCtrl();
    }
}

void CAddServer::OnItemchangedListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    UpdateControls();

        *pResult = 0;
}



void CAddServer::FillListCtrl()
{
    CServerInfo ServerInfo;
    CString     strIp;
    int         nItem = 0;

    m_listctrlServers.DeleteAllItems();

    if (m_pServerList->IsInitialized())
    {
        // fill the list control with data
        POSITION pos = m_pServerList->GetHeadPosition();

        // walk the list and add items to the list control
        while (pos != NULL)
        {
            POSITION lastpos = pos;

            // get the next item
            ServerInfo = m_pServerList->GetNext(pos);

            UtilCvtIpAddrToWstr(ServerInfo.m_dwIp, &strIp);

            nItem = m_listctrlServers.InsertItem(nItem, ServerInfo.m_strName);
            m_listctrlServers.SetItemText(nItem, 1, strIp);

            // save off the position value for sorting later
            m_listctrlServers.SetItemData(nItem, (DWORD_PTR) lastpos);
        }

        if (m_listctrlServers.GetItemCount() > 0)
        {
            // select the first one by default
            m_listctrlServers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
        }

        Sort(COLUMN_NAME);

        if (m_listctrlServers.GetItemCount() > 0)
        {
            // select the first one by default
            m_listctrlServers.SetItemState(0, LVIS_SELECTED, LVIS_SELECTED);
        }

    }
    else
    {
        // put some text in the list control and start a timer
        // so we can periodically check to see if initialization completes
        CString strMessage;

        strMessage.LoadString(IDS_ADD_SERVER_LOADING);
        m_listctrlServers.InsertItem(0, strMessage);

        ::SetTimer(GetSafeHwnd(), ADD_SERVER_TIMER_ID, 500, NULL);
    }
}

void CAddServer::UpdateControls()
{
    BOOL fAnyServer = TRUE;
    BOOL fAuthorizedServer = FALSE;
    BOOL fEnableOk = FALSE;

    if (!m_pServerList->IsInitialized())
    {
        m_radioAuthorizedServer.EnableWindow(FALSE);
    }

    if (!m_radioAnyServer.GetCheck())
    {
        // enable the auth server list
        fAnyServer = FALSE;
        fAuthorizedServer = TRUE;

        // check to see if something is selected
        fEnableOk = ( m_listctrlServers.GetSelectedCount() > 0 );
    }
    else
    {
        // check to see if the edit box is empty
        CString strText;
        m_editServer.GetWindowText(strText);
        if (!strText.IsEmpty())
        {
            fEnableOk = TRUE;
        }
    }

    m_editServer.EnableWindow(fAnyServer);
    m_buttonBrowse.EnableWindow(fAnyServer);

    m_listctrlServers.EnableWindow(fAuthorizedServer);

    m_buttonOk.EnableWindow(fEnableOk);
}

//  BOOL CAddServer::GetInfo(CString & strName, CString & strIp)
void CAddServer::GetInfo()
{
    SelectedServer SelSrv;

    // Clear the list
    m_lSelSrv.RemoveAll();


    if (!m_radioAnyServer.GetCheck()) {
        // check to see if something is selected

        POSITION        pos;
        int             nItem;

        pos = m_listctrlServers.GetFirstSelectedItemPosition();
        if ( NULL == pos ) {
            return;
        }
        while ( NULL != pos ) {
            nItem = m_listctrlServers.GetNextSelectedItem( pos );
            SelSrv.strName = m_listctrlServers.GetItemText( nItem, 0 );
            SelSrv.strIp = m_listctrlServers.GetItemText( nItem, 1 );

            m_lSelSrv.AddTail( SelSrv );
            
        } // while 
        
    } // if auth list
    else {
        m_editServer.GetWindowText( SelSrv.strName );

        DWORD dwIpAddress = 0;
        DWORD err = ERROR_SUCCESS;
        DHC_HOST_INFO_STRUCT hostInfo;

        BEGIN_WAIT_CURSOR

        switch (::UtilCategorizeName( SelSrv.strName )) {
        case HNM_TYPE_IP:
            dwIpAddress = ::UtilCvtWstrToIpAddr( SelSrv.strName ) ;
            SelSrv.strName.Empty();
            break ;
            
        case HNM_TYPE_NB:
        case HNM_TYPE_DNS:
            err = ::UtilGetHostAddress( SelSrv.strName, &dwIpAddress ) ;
            break ;
            
        default:
            err = IDS_ERR_BAD_HOST_NAME ;
            break;
        }

        END_WAIT_CURSOR

        if (err == ERROR_SUCCESS)
        {
            BEGIN_WAIT_CURSOR

            // get the FQDN for this machine and set it.
            err = ::UtilGetHostInfo( dwIpAddress, &hostInfo );

            // Make sure we do not use 127.0.0.1
            if (( INADDR_LOOPBACK ==  dwIpAddress ) &&
                ( NO_ERROR == err )) {
                ::UtilGetLocalHostAddress( &dwIpAddress );
                ::UtilGetHostInfo( dwIpAddress, &hostInfo );
            } // if

            END_WAIT_CURSOR

            CString strTemp = hostInfo._chHostName;

            if (!strTemp.IsEmpty())
                SelSrv.strName = hostInfo._chHostName;
        }

        ::UtilCvtIpAddrToWstr(dwIpAddress, &SelSrv.strIp);

        m_lSelSrv.AddTail( SelSrv );
    } // else specified server

} // CAddServer::GetInfo()

void CAddServer::CleanupTimer()
{
    KillTimer(ADD_SERVER_TIMER_ID);
}


void CAddServer::OnColumnclickListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult) 
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // sort depending on what column was clicked;
    Sort(pNMListView->iSubItem);
    
        *pResult = 0;
}

void CAddServer::Sort(int nCol) 
{
    if (m_nSortColumn == nCol)
    {
        // if the user is clicking the same column again, reverse the sort order
        m_aSortOrder[nCol] = m_aSortOrder[nCol] ? FALSE : TRUE;
    }
    else
    {
        m_nSortColumn = nCol;
    }

    m_listctrlServers.SortItems(AddServerCompareFunc, (LPARAM) this);
}

int CAddServer::HandleSort(LPARAM lParam1, LPARAM lParam2) 
{
    int nCompare = 0;
    CServerInfo ServerInfo1, ServerInfo2;

    ServerInfo1 = m_pServerList->GetAt((POSITION) lParam1);
    ServerInfo2 = m_pServerList->GetAt((POSITION) lParam2);

    switch (m_nSortColumn)
    {
        case COLUMN_NAME:
            {
                nCompare = ServerInfo1.m_strName.CompareNoCase(ServerInfo2.m_strName);
            }

            // if the names are the same, fall back to the IP address
            if (nCompare != 0)
            {
                break;
            }


        case COLUMN_IP:
            {
                if (ServerInfo1.m_dwIp > ServerInfo2.m_dwIp)
                    nCompare = 1;
                else
                if (ServerInfo1.m_dwIp < ServerInfo2.m_dwIp)
                    nCompare = -1;
            }
            break;
    }

    if (m_aSortOrder[m_nSortColumn] == FALSE)
    {
        // descending
        return -nCompare;
    }
    else
    {
        // ascending
        return nCompare;
    }
}

void CAddServer::ResetSort()
{
    m_nSortColumn = -1; 

    for (int i = 0; i < COLUMN_MAX; i++)
    {
        m_aSortOrder[i] = TRUE; // ascending
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\addserv.h ===
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
        addserv.h
                The add server dialog
                
    FILE HISTORY:
        
*/

#if !defined _ADDSERV_H
#define _ADDSERV_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _SERVBROW_H
#include "servbrow.h"
#endif

#define ADD_SERVER_TIMER_ID     500

typedef struct SelServer {
    CString strName;
    CString strIp;
} SelectedServer;

typedef CList<SelectedServer, SelectedServer> CSelectedServerList;

/////////////////////////////////////////////////////////////////////////////
// CAddServer dialog

class CAddServer : public CBaseDialog
{
// Construction
public:
    CAddServer(CWnd* pParent = NULL);   // standard constructor

    // Dialog Data
    //{{AFX_DATA(CAddServer)
    enum { IDD = IDD_ADD_SERVER };
    CButton m_radioAuthorizedServer;
    CButton m_buttonOk;
    CButton m_radioAnyServer;
    CEdit   m_editServer;
    CButton m_buttonBrowse;
    CListCtrl       m_listctrlServers;
    //}}AFX_DATA
    
    void SetServerList(CAuthServerList * pServerList) { m_pServerList = pServerList; }
    int HandleSort(LPARAM lParam1, LPARAM lParam2);
    void ResetSort();
    
    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CAddServer::IDD); }
    
    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddServer)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL
    
    // Implementation
protected:
    void FillListCtrl();
    void UpdateControls();
    void GetInfo();
    void CleanupTimer();

    void Sort(int nCol);

    // Generated message map functions
    //{{AFX_MSG(CAddServer)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnButtonBrowseServers();
    afx_msg void OnRadioAnyServer();
    afx_msg void OnRadioAuthorizedServers();
    virtual void OnCancel();
    afx_msg void OnChangeEditAddServerName();
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnItemchangedListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnclickListAuthorizedServers(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

public:
    CSelectedServerList m_lSelSrv;   

private:
    CAuthServerList *   m_pServerList;
    int                 m_nSortColumn;
    BOOL                m_aSortOrder[COLUMN_MAX];
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSERV_H__B8909EC0_08BE_11D3_847A_00104BCA42CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classed.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       REGBINED.H
*
*  VERSION:     4.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  05 Mar 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_REGBINED
#define _INC_REGBINED

#ifdef __cplusplus
extern "C" {
#endif

#define HEM_SETBUFFER                   (WM_USER + 1)

//
//  HexEdit context menu identifier and items.  The IDKEY_* identifier
//  correspond to the WM_CHAR message that it corresponds to.  For example,
//  IDKEY_COPY would send a control-c to the HexEdit_OnChar routine.
//

//  Surrogate AfxMessageBox replacement for error message filtering.
int DhcpMessageBox(DWORD dwIdPrompt, 
 				   UINT nType, 
				   const TCHAR * pszSuffixString,
				   UINT nHelpContext);

#define IDM_HEXEDIT_CONTEXT             108

#define IDKEY_COPY                      3
#define IDKEY_PASTE                     22
#define IDKEY_CUT                       24
#define ID_SELECTALL                    0x0400

#define HEXEDIT_CLASSNAME               TEXT("HEX")
#define MAXDATA_LENGTH		            256
		// Max length of a value data item

typedef struct _EDITVALUEPARAM {
    LPCTSTR pServer;
    LPTSTR pValueName;
    LPTSTR pValueComment;
    PBYTE pValueData;
    UINT cbValueData;
}   EDITVALUEPARAM, FAR *LPEDITVALUEPARAM;

//
//  Reference data for the HexEdit window.  Because we only ever expect one
//  instance of this class to exist, we can safely create one instance of this
//  structure now to avoid allocating and managing the structure later.
//

typedef struct _HEXEDITDATA {
    UINT Flags;
    PBYTE pBuffer;
    int cbBuffer;
    int cxWindow;                       //  Width of the window
    int cyWindow;                       //  Height of the window
    HFONT hFont;                        //  Font being used for output
    LONG FontHeight;                    //  Height of the above font
    LONG FontMaxWidth;                  //  Maximum width of the above font
    int LinesVisible;                   //  Number of lines can be displayed
    int MaximumLines;                   //  Total number of lines
    int FirstVisibleLine;               //  Line number of top of display
    int xHexDumpStart;
    int xHexDumpByteWidth;
    int xAsciiDumpStart;
    int CaretIndex;
    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    int xPrevMessagePos;                //  Cursor point on last mouse message
    int yPrevMessagePos;                //  Cursor point on last mouse message
}   HEXEDITDATA;

BOOL
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
RegisterHexEditClass(
    HINSTANCE hInstance
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _INC_REGBINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classed.c ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP.
*
*  TITLE:       CLASSED.C
*
*  VERSION:     5.01
*
*  AUTHOR:      Tracy Sharpe
*
*  DATE:        05 Mar 1994
*
*  Binary edit dialog for use by the Registry Editor.
*
*  Hexadecimal editor control for use by the Registry Editor.  Little attempt
*  is made to make this a generic control-- only one instance is assumed to
*  ever exist.
*
*  02 Oct 1997 modified to work with the DHCP snapin
*
*******************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <string.h>
#include <mbstring.h>
#include <tchar.h>
#include "resource.h"
#include "classed.h"
#include "dhcpapi.h"
#include "helparr.h"

//
//  Following structure and data are used to move the controls of the
//  EditBinaryValue dialog so that the HexEdit control fills up the appropriate
//  amount of space based on the system metrics.
//

typedef struct _MOVEWND {
    int ControlID;
    UINT SetWindowPosFlags;
}   MOVEWND;

const TCHAR s_HexEditClassName[] = HEXEDIT_CLASSNAME;

const TCHAR s_HexEditClipboardFormatName[] = TEXT("RegEdit_HexData");

const TCHAR s_HexWordFormatSpec[] = TEXT("%04X");
const TCHAR s_HexByteFormatSpec[] = TEXT("%02X");

COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;

PTSTR g_pHelpFileName;

HINSTANCE g_hInstance;

const MOVEWND s_EditBinaryValueMoveWnd[] = {
    IDOK,               SWP_NOSIZE | SWP_NOZORDER,
    IDCANCEL,           SWP_NOSIZE | SWP_NOZORDER,
    IDC_VALUENAME,      SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUEDATA,      SWP_NOMOVE | SWP_NOZORDER,
    IDC_VALUECOMMENT,   SWP_NOMOVE | SWP_NOZORDER
};

//  Number of bytes that are displayed per line.  NOTE:  Assumptions have been
//  made that this is power of two.
#define BYTES_PER_HEXEDIT_LINE          8
#define BYTES_PER_HEXEDIT_LINE_MASK     0x0007

//
//  This font is used by the HexEdit window for all output.  The lfHeight
//  member is calculated later based on the system configuration.
//

LOGFONT s_HexEditFont = {
    0,                                  //  lfHeight
    0,                                  //  lfWidth
    0,                                  //  lfEscapement
    0,                                  //  lfOrientation
    FW_NORMAL,                          //  lfWeight
    FALSE,                              //  lfItalic
    FALSE,                              //  lfUnderline
    FALSE,                              //  lfStrikeout
    ANSI_CHARSET,                       //  lfCharSet
    OUT_DEFAULT_PRECIS,                 //  lfOutPrecision
    CLIP_DEFAULT_PRECIS,                //  lfClipPrecision
    DEFAULT_QUALITY,                    //  lfQuality
    FIXED_PITCH | FF_DONTCARE,          //  lfPitchAndFamily
    TEXT("Courier")                     //  lfFaceName
};

//  Set if window has input focus, clear if not.
#define HEF_FOCUS                       0x00000001
#define HEF_NOFOCUS                     0x00000000
//  Set if dragging a range with mouse, clear if not.
#define HEF_DRAGGING                    0x00000002
#define HEF_NOTDRAGGING                 0x00000000
//  Set if editing ASCII column, clear if editing hexadecimal column.
#define HEF_CARETINASCIIDUMP            0x00000004
#define HEF_CARETINHEXDUMP              0x00000000
//
#define HEF_INSERTATLOWNIBBLE           0x00000008
#define HEF_INSERTATHIGHNIBBLE          0x00000000
//  Set if caret should be shown at the end of the previous line instead of at
//  the beginning of it's real caret line, clear if not.
#define HEF_CARETATENDOFLINE            0x00000010

HEXEDITDATA s_HexEditData;

typedef struct _HEXEDITCLIPBOARDDATA {
    DWORD cbSize;
    BYTE Data[1];
}   HEXEDITCLIPBOARDDATA, *LPHEXEDITCLIPBOARDDATA;

UINT s_HexEditClipboardFormat;

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    );

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    );

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    );

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    );

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_PaintRect(
    HWND hWnd,
    HDC hDC,
    LPRECT lpUpdateRect
    );

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    );

int
PASCAL
HexEdit_HitTest(
    HEXEDITDATA * pHexEditData,
    int x,
    int y
    );

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    );

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    );

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    );

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    );

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    );

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    );

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    );

/*******************************************************************************
*
*  EditBinaryValueDlgProc
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

BOOL
CALLBACK
EditBinaryValueDlgProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    HEXEDITDATA *    pHexEditData;
    DWORD            dwErr;
    DHCP_CLASS_INFO  ClassInfo;

    switch (Message) {

        case WM_INITDIALOG:
            return EditBinaryValue_OnInitDialog(hWnd, (HWND)(wParam), lParam);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDOK:
                    lpEditValueParam = (LPEDITVALUEPARAM) GetWindowLongPtr(hWnd, DWLP_USER);
                    
                    pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(hWnd, IDC_VALUEDATA), GWLP_USERDATA);

                    if (pHexEditData->cbBuffer == 0)
                    {
                        // user didn't enter any data to describe the class
                        TCHAR szText[1024], szCaption[1024];

                        LoadString(g_hInstance, IDS_CLASSID_NO_DATA, szText, sizeof(szText)/sizeof(TCHAR));
                        LoadString(g_hInstance, IDS_SNAPIN_DESC, szCaption, sizeof(szCaption)/sizeof(TCHAR));

                        MessageBox(hWnd, szText, szCaption, MB_OK | MB_ICONSTOP);
                        
                        SetFocus(GetDlgItem(hWnd, IDC_VALUEDATA));

                        break;
                    }

                    lpEditValueParam->cbValueData = pHexEditData->cbBuffer;

                    GetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName, 256);
                    if ( _tcslen(lpEditValueParam->pValueName) == 0)
                    {
                        TCHAR szText[1024], szCaption[1024];

                        LoadString(g_hInstance, IDS_CLASSID_NO_NAME, szText, sizeof(szText)/sizeof(TCHAR));
                        LoadString(g_hInstance, IDS_SNAPIN_DESC, szCaption, sizeof(szCaption)/sizeof(TCHAR));

                        MessageBox(hWnd, szText, szCaption, MB_OK | MB_ICONSTOP);
                     
                        SetFocus(GetDlgItem(hWnd, IDC_VALUENAME));

                        break;
                    }

                    GetDlgItemText(hWnd, IDC_VALUECOMMENT, lpEditValueParam->pValueComment, 256);
                    
                    // Everything looks good so far, let's try to create the class on the server
                    ClassInfo.ClassName = lpEditValueParam->pValueName;
                    ClassInfo.ClassComment = lpEditValueParam->pValueComment;
                    ClassInfo.ClassDataLength = lpEditValueParam->cbValueData;
                    ClassInfo.ClassData = lpEditValueParam->pValueData;

                    dwErr = DhcpCreateClass((LPTSTR) lpEditValueParam->pServer,
                                            0, 
                                            &ClassInfo);
                    if (dwErr != ERROR_SUCCESS)
                    {
                        DhcpMessageBox(dwErr, MB_OK, NULL, -1);
                        return FALSE;
                    }

                    //  FALL THROUGH

                case IDCANCEL:
                    EndDialog(hWnd, GET_WM_COMMAND_ID(wParam, lParam));
                    break;

                default:
                    return FALSE;

            }
            break;

        case WM_HELP:
            WinHelp(((LPHELPINFO) lParam)-> hItemHandle, g_pHelpFileName,
                HELP_WM_HELP, (ULONG_PTR) (LPVOID) g_aHelpIDs_IDD_CLASSID_NEW);
            break;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, g_pHelpFileName, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPVOID) g_aHelpIDs_IDD_CLASSID_NEW);
            break;

        default:
            return FALSE;

    }

    return TRUE;

}

/*******************************************************************************
*
*  EditBinaryValue_OnInitDialog
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd,
*     hFocusWnd,
*     lParam,
*
*******************************************************************************/

BOOL
PASCAL
EditBinaryValue_OnInitDialog(
    HWND hWnd,
    HWND hFocusWnd,
    LPARAM lParam
    )
{

    LPEDITVALUEPARAM lpEditValueParam;
    RECT Rect;
    int HexEditIdealWidth;
    int dxChange;
    HWND hControlWnd;
    UINT Counter;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(hWnd, IDC_VALUEDATA), GWLP_USERDATA);

    SetWindowLongPtr(hWnd, DWLP_USER, lParam);
    lpEditValueParam = (LPEDITVALUEPARAM) lParam;

    SetDlgItemText(hWnd, IDC_VALUENAME, lpEditValueParam->pValueName);

    SendDlgItemMessage(hWnd, IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        lpEditValueParam-> cbValueData, (LPARAM) lpEditValueParam-> pValueData);

    //
    //  Figure out how big the "ideally" size HexEdit should be-- this means
    //  displaying the address, hex dump, ASCII dump, and potentially a scroll
    //  bar.
    //

    GetWindowRect(GetDlgItem(hWnd, IDC_VALUEDATA), &Rect);

    HexEditIdealWidth = pHexEditData->xAsciiDumpStart +
        pHexEditData->FontMaxWidth * (BYTES_PER_HEXEDIT_LINE + 1) +
        GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

    dxChange = HexEditIdealWidth - (Rect.right - Rect.left);

    //
    //  Resize the dialog box.
    //

    GetWindowRect(hWnd, &Rect);

    MoveWindow(hWnd, Rect.left, Rect.top, Rect.right - Rect.left + dxChange,
        Rect.bottom - Rect.top, FALSE);

    //
    //  Resize or move the controls as necessary.
    //

    for (Counter = 0; Counter < (sizeof(s_EditBinaryValueMoveWnd) /
        sizeof(MOVEWND)); Counter++) {

        hControlWnd = GetDlgItem(hWnd,
            s_EditBinaryValueMoveWnd[Counter].ControlID);

        GetWindowRect(hControlWnd, &Rect);

        if (s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags & SWP_NOSIZE) {

            MapWindowPoints(NULL, hWnd, (LPPOINT) &Rect, 2);
            Rect.left += dxChange;

        }

        else
            Rect.right += dxChange;

        SetWindowPos(hControlWnd, NULL, Rect.left, Rect.top, Rect.right -
            Rect.left, Rect.bottom - Rect.top,
            s_EditBinaryValueMoveWnd[Counter].SetWindowPosFlags);

    }

    SetFocus(GetDlgItem(hWnd, IDC_VALUENAME));

    return TRUE;

    UNREFERENCED_PARAMETER(hFocusWnd);

}

/*******************************************************************************
*
*  RegisterHexEditClass
*
*  DESCRIPTION:
*     Register the HexEdit window class with the system.
*
*  PARAMETERS:
*     (none).
*
*******************************************************************************/

BOOL
PASCAL
RegisterHexEditClass(
    HINSTANCE hInstance
    )
{

    WNDCLASS WndClass;

    g_hInstance = hInstance;

    s_HexEditClipboardFormat =
        RegisterClipboardFormat(s_HexEditClipboardFormatName);

    WndClass.style = CS_DBLCLKS;
    WndClass.lpfnWndProc = HexEditWndProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = g_hInstance;
    WndClass.hIcon = NULL;
    WndClass.hCursor = LoadCursor(NULL, IDC_IBEAM);
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = s_HexEditClassName;

    return (RegisterClass(&WndClass) != 0);

}

/*******************************************************************************
*
*  HexEditWndProc
*
*  DESCRIPTION:
*     Callback procedure for the HexEdit window.
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Message,
*     wParam,
*     lParam,
*     (returns),
*
*******************************************************************************/

LRESULT
PASCAL
HexEditWndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HEXEDITDATA * pHexEditData;

    switch (Message) {

        HANDLE_MSG(hWnd, WM_NCCREATE, HexEdit_OnNcCreate);
        HANDLE_MSG(hWnd, WM_SIZE, HexEdit_OnSize);
        HANDLE_MSG(hWnd, WM_VSCROLL, HexEdit_OnVScroll);
        HANDLE_MSG(hWnd, WM_PAINT, HexEdit_OnPaint);
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_LBUTTONDBLCLK, HexEdit_OnLButtonDown);
        HANDLE_MSG(hWnd, WM_MOUSEMOVE, HexEdit_OnMouseMove);
        HANDLE_MSG(hWnd, WM_LBUTTONUP, HexEdit_OnLButtonUp);
        HANDLE_MSG(hWnd, WM_CHAR, HexEdit_OnChar);
        HANDLE_MSG(hWnd, WM_KEYDOWN, HexEdit_OnKey);

        case WM_SETFOCUS:
            HexEdit_OnSetFocus(hWnd);
            break;

        case WM_KILLFOCUS:
            HexEdit_OnKillFocus(hWnd);
            break;

        case WM_TIMER:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            HexEdit_OnMouseMove(hWnd, pHexEditData->xPrevMessagePos,
                pHexEditData->yPrevMessagePos, 0);
            break;

        case WM_GETDLGCODE:
            return (LPARAM) (DLGC_WANTCHARS | DLGC_WANTARROWS | DLGC_WANTTAB);

        case WM_ERASEBKGND:
            return TRUE;

        case WM_NCDESTROY:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            if (pHexEditData)
            {
                DeleteObject(pHexEditData->hFont);
                free(pHexEditData);
            }
            break;

        case WM_CONTEXTMENU:
            HexEdit_OnContextMenu(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        //  Message: HEM_SETBUFFER
        //  wParam:  Number of bytes in the buffer.
        //  lParam:  Pointer to the buffer.
        case HEM_SETBUFFER:
            pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
            pHexEditData->pBuffer = (PBYTE) lParam;
            pHexEditData->cbBuffer = (int) wParam;

            pHexEditData->CaretIndex = 0;
            pHexEditData->MinimumSelectedIndex = 0;
            pHexEditData->MaximumSelectedIndex = 0;

            pHexEditData->FirstVisibleLine = 0;

            HexEdit_SetScrollInfo(hWnd);
            InvalidateRgn(hWnd, NULL, TRUE);
            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);

    }

    return 0;

}

/*******************************************************************************
*
*  HexEdit_OnNcCreate
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnNcCreate(
    HWND hWnd,
    LPCREATESTRUCT lpCreateStruct
    )
{

    HDC hDC;
    HFONT hPrevFont;
    TEXTMETRIC TextMetric;
    RECT    rect;
    BOOL    fDone = FALSE;
    int     nPoint = 10;  // starting point size
    int HexEditIdealWidth;

    HEXEDITDATA * pHexEditData = malloc(sizeof(HEXEDITDATA));
    if (!pHexEditData)
        return FALSE;

    memset( pHexEditData, 0, sizeof( *pHexEditData ));

    SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pHexEditData);

    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);

    hDC = GetDC(hWnd);
    if (hDC)
    {
        GetWindowRect(hWnd, &rect);

        while (!fDone)
        {
            s_HexEditFont.lfHeight = -(nPoint * GetDeviceCaps(hDC, LOGPIXELSY) / 72);

            if ((pHexEditData->hFont = CreateFontIndirect(&s_HexEditFont)) != NULL) 
            {
                hPrevFont = SelectObject(hDC, pHexEditData->hFont);
                GetTextMetrics(hDC, &TextMetric);
                SelectObject(hDC, hPrevFont);

                pHexEditData->FontHeight = TextMetric.tmHeight;

                pHexEditData->LinesVisible = pHexEditData->cyWindow /
                    pHexEditData->FontHeight;

                pHexEditData->FontMaxWidth = TextMetric.tmMaxCharWidth;

                pHexEditData->xHexDumpByteWidth = pHexEditData->FontMaxWidth * 3;
                pHexEditData->xHexDumpStart = pHexEditData->FontMaxWidth * 11 / 2;
                pHexEditData->xAsciiDumpStart = pHexEditData->xHexDumpStart +
                    BYTES_PER_HEXEDIT_LINE * pHexEditData->xHexDumpByteWidth +
                    pHexEditData->FontMaxWidth * 3 / 2;

                // check to make sure we have room 
                HexEditIdealWidth = pHexEditData->xAsciiDumpStart +
                    pHexEditData->FontMaxWidth * (BYTES_PER_HEXEDIT_LINE) +
                    GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXEDGE) * 2;

                if (HexEditIdealWidth < (rect.right - rect.left) ||
                    (nPoint < 5) )
                {
                    fDone = TRUE;
                }
                else
                {
                    // try a smaller size
                    DeleteObject(pHexEditData->hFont);
                    pHexEditData->hFont = NULL;
                    nPoint--;
                }
            }
            else
            {
                break;
            }
        }

        ReleaseDC(hWnd, hDC);
    }

    if (pHexEditData->hFont == NULL)
        return FALSE;

    return (BOOL) DefWindowProc(hWnd, WM_NCCREATE, 0, (LPARAM) lpCreateStruct);

}

/*******************************************************************************
*
*  HexEdit_OnSize
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSize(
    HWND hWnd,
    UINT State,
    int cx,
    int cy
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    
    pHexEditData->cxWindow = cx;
    pHexEditData->cyWindow = cy;

    pHexEditData->LinesVisible = cy / pHexEditData->FontHeight;

    HexEdit_SetScrollInfo(hWnd);

    UNREFERENCED_PARAMETER(State);
    UNREFERENCED_PARAMETER(cx);

}

/*******************************************************************************
*
*  HexEdit_SetScrollInfo
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetScrollInfo(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    SCROLLINFO ScrollInfo;

    pHexEditData->MaximumLines = (pHexEditData->cbBuffer +
        BYTES_PER_HEXEDIT_LINE) / BYTES_PER_HEXEDIT_LINE - 1;

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    ScrollInfo.nMin = 0;
    ScrollInfo.nMax = pHexEditData->MaximumLines;
    ScrollInfo.nPage = pHexEditData->LinesVisible;
    ScrollInfo.nPos = pHexEditData->FirstVisibleLine;

    SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

}

/*******************************************************************************
*
*  HexEdit_OnVScroll
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnVScroll(
    HWND hWnd,
    HWND hCtlWnd,
    UINT Code,
    int Position
    )
{

    int NewFirstVisibleLine;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    SCROLLINFO ScrollInfo;

    NewFirstVisibleLine = pHexEditData->FirstVisibleLine;

    switch (Code) {

        case SB_LINEUP:
            NewFirstVisibleLine--;
            break;

        case SB_LINEDOWN:
            NewFirstVisibleLine++;
            break;

        case SB_PAGEUP:
            NewFirstVisibleLine -= pHexEditData->LinesVisible;
            break;

        case SB_PAGEDOWN:
            NewFirstVisibleLine += pHexEditData->LinesVisible;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewFirstVisibleLine = Position;
            break;

    }

    //
    //  Change the scroll bar position.  Note that SetScrollInfo will take into
    //  account the clipping between zero and the maximum value.  It will also
    //  return the final scroll bar position.
    //

    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = SIF_POS;
    ScrollInfo.nPos = NewFirstVisibleLine;

    NewFirstVisibleLine = SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

    if (pHexEditData->FirstVisibleLine != NewFirstVisibleLine) {

        ScrollWindowEx(hWnd, 0, (pHexEditData->FirstVisibleLine -
            NewFirstVisibleLine) * pHexEditData->FontHeight, NULL, NULL, NULL,
            NULL, SW_INVALIDATE);

        pHexEditData->FirstVisibleLine = NewFirstVisibleLine;

        HexEdit_SetCaretPosition(hWnd);

    }

    UNREFERENCED_PARAMETER(hCtlWnd);

}

/*******************************************************************************
*
*  HexEdit_OnPaint
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnPaint(
    HWND hWnd
    )
{

    PAINTSTRUCT PaintStruct;

    BeginPaint(hWnd, &PaintStruct);

    HexEdit_PaintRect(hWnd, PaintStruct.hdc, &PaintStruct.rcPaint);

    EndPaint(hWnd, &PaintStruct);

}

/*******************************************************************************
*
*  HexEdit_PaintRect
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_PaintRect(
    HWND hWnd,
    HDC hDC,
    LPRECT lpUpdateRect
    )
{

    HFONT hPrevFont;
    int CurrentByteIndex;
    BYTE Byte;
    int CurrentLine;
    int LastLine;
    int BytesOnLastLine;
    int BytesOnLine;
    BOOL fUsingHighlight;
    int Counter;
    TCHAR Buffer[5];                     //  Room for four hex digits plus null
    RECT TextRect;
    RECT AsciiTextRect;
    int x;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pHexEditData->hFont)
        hPrevFont = SelectFont(hDC, pHexEditData->hFont);

    SetBkColor(hDC, g_clrWindow);
    SetTextColor(hDC, g_clrWindowText);

    //
    //  Figure out the range of lines of the control that must be painted.
    //  Using this information we can compute the offset into the buffer to
    //  start reading from.
    //

    CurrentLine = lpUpdateRect-> top / pHexEditData->FontHeight;

    TextRect.bottom = CurrentLine * pHexEditData->FontHeight;
    AsciiTextRect.bottom = TextRect.bottom;

    CurrentByteIndex = (pHexEditData->FirstVisibleLine + CurrentLine) *
        BYTES_PER_HEXEDIT_LINE;

    LastLine = lpUpdateRect->bottom / pHexEditData->FontHeight;

    //
    //  Figure out if there's enough in the buffer to fill up the entire window
    //  and the last line that we paint.
    //

    if (LastLine >= pHexEditData->MaximumLines -
        pHexEditData->FirstVisibleLine) {

        LastLine = pHexEditData->MaximumLines - pHexEditData->FirstVisibleLine;

        BytesOnLastLine = pHexEditData->cbBuffer % BYTES_PER_HEXEDIT_LINE;

    }

    else
        BytesOnLastLine = BYTES_PER_HEXEDIT_LINE;

    BytesOnLine = BYTES_PER_HEXEDIT_LINE;
    fUsingHighlight = FALSE;

    //
    //  Loop through each of the lines to be displayed.
    //

    while (CurrentLine <= LastLine) {

        //
        //  If we're on the last line of the display and this is at the end
        //  of the buffer, we may not have a complete line to paint.
        //

        if (CurrentLine == LastLine)
            BytesOnLine = BytesOnLastLine;

        TextRect.top = TextRect.bottom;
        TextRect.bottom += pHexEditData->FontHeight;

        TextRect.left = 0;
        TextRect.right = pHexEditData->xHexDumpStart;

        x = TextRect.right + pHexEditData->FontMaxWidth / 2;

        wsprintf(Buffer, s_HexWordFormatSpec, CurrentByteIndex);
        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, Buffer, 4,
            NULL);

        AsciiTextRect.top = AsciiTextRect.bottom;
        AsciiTextRect.bottom += pHexEditData->FontHeight;
        AsciiTextRect.right = pHexEditData->xAsciiDumpStart;

        for (Counter = 0; Counter < BytesOnLine; Counter++,
            CurrentByteIndex++) {

            //
            //  Determine what colors to use to paint the current byte.
            //

            if (CurrentByteIndex >= pHexEditData->MinimumSelectedIndex) {

                if (CurrentByteIndex >= pHexEditData->MaximumSelectedIndex) {

                    if (fUsingHighlight) {

                        fUsingHighlight = FALSE;

                        SetBkColor(hDC, g_clrWindow);
                        SetTextColor(hDC, g_clrWindowText);

                    }

                }

                else {

                    if (!fUsingHighlight) {

                        fUsingHighlight = TRUE;

                        SetBkColor(hDC, g_clrHighlight);
                        SetTextColor(hDC, g_clrHighlightText);

                    }

                }

            }

            Byte = pHexEditData->pBuffer[CurrentByteIndex];

            //
            //  Paint the hexadecimal representation.
            //

            TextRect.left = TextRect.right;
            TextRect.right += pHexEditData->xHexDumpByteWidth;

            wsprintf(Buffer, s_HexByteFormatSpec, Byte);

            ExtTextOut(hDC, x, TextRect.top, ETO_OPAQUE, &TextRect,
                Buffer, 2, NULL);

            x += pHexEditData->xHexDumpByteWidth;

            //
            //  Paint the ASCII representation.
            //

            AsciiTextRect.left = AsciiTextRect.right;
            AsciiTextRect.right += pHexEditData->FontMaxWidth;

            Buffer[0] = (TCHAR) (((Byte & 0x7F) >= ' ') ? Byte : '.');

            ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
                &AsciiTextRect, Buffer, 1, NULL);

        }

        //
        //  Paint any leftover strips between the hexadecimal and ASCII columns
        //  and the ASCII column and the right edge of the window.
        //

        if (fUsingHighlight) {

            fUsingHighlight = FALSE;

            SetBkColor(hDC, g_clrWindow);
            SetTextColor(hDC, g_clrWindowText);

        }

        TextRect.left = TextRect.right;
        TextRect.right = pHexEditData->xAsciiDumpStart;

        ExtTextOut(hDC, TextRect.left, TextRect.top, ETO_OPAQUE, &TextRect,
            NULL, 0, NULL);

        AsciiTextRect.left = AsciiTextRect.right;
        AsciiTextRect.right = pHexEditData->cxWindow;

        ExtTextOut(hDC, AsciiTextRect.left, AsciiTextRect.top, ETO_OPAQUE,
            &AsciiTextRect, NULL, 0, NULL);

        CurrentLine++;

    }

    //
    //  Paint any remaining space in the control by filling it with the
    //  background color.
    //

    if (TextRect.bottom < lpUpdateRect-> bottom) {

        TextRect.left = 0;
        TextRect.right = pHexEditData->cxWindow;
        TextRect.top = TextRect.bottom;
        TextRect.bottom = lpUpdateRect-> bottom;

        ExtTextOut(hDC, 0, TextRect.top, ETO_OPAQUE, &TextRect, NULL, 0, NULL);

    }

    if (pHexEditData->hFont)
        SelectFont(hDC, hPrevFont);

}

/*******************************************************************************
*
*  HexEdit_OnSetFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnSetFocus(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags |= HEF_FOCUS;

    CreateCaret(hWnd, NULL, 0, pHexEditData->FontHeight);
    HexEdit_SetCaretPosition(hWnd);
    ShowCaret(hWnd);

}

/*******************************************************************************
*
*  HexEdit_OnKillFocus
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKillFocus(
    HWND hWnd
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (pHexEditData->Flags & HEF_FOCUS) {

        pHexEditData->Flags &= ~HEF_FOCUS;

        DestroyCaret();

    }

}

/*******************************************************************************
*
*  HexEdit_OnLButtonDown
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     fDoubleClick, TRUE if this is a double-click message, else FALSE.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonDown(
    HWND hWnd,
    BOOL fDoubleClick,
    int x,
    int y,
    UINT KeyFlags
    )
{

    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    int NewCaretIndex;

    if (fDoubleClick) {

        if (pHexEditData->CaretIndex + 1 <= pHexEditData->cbBuffer)
        {
            HexEdit_ChangeCaretIndex(hWnd, pHexEditData->CaretIndex + 1, TRUE);
        }
        return;

    }

    NewCaretIndex = HexEdit_HitTest(pHexEditData, x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, (KeyFlags & MK_SHIFT));

    //
    //  If we don't already have the focus, try to get it.
    //

    if (!(pHexEditData->Flags & HEF_FOCUS))
        SetFocus(hWnd);

    SetCapture(hWnd);
    pHexEditData->Flags |= HEF_DRAGGING;

    pHexEditData->xPrevMessagePos = x;
    pHexEditData->yPrevMessagePos = y;

    SetTimer(hWnd, 1, 400, NULL);

    UNREFERENCED_PARAMETER(fDoubleClick);

}

/*******************************************************************************
*
*  HexEdit_OnMouseMove
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnMouseMove(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{

    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);
    int NewCaretIndex;

    if (!(pHexEditData->Flags & HEF_DRAGGING))
        return;

    NewCaretIndex = HexEdit_HitTest(pHexEditData, x, y);

    HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, TRUE);

    pHexEditData->xPrevMessagePos = x;
    pHexEditData->yPrevMessagePos = y;

    {

    int i, j;

    i = y < 0 ? -y : y - pHexEditData->cyWindow;
    j = 400 - ((UINT)i << 4);
    if (j < 100)
        j = 100;
    SetTimer(hWnd, 1, j, NULL);

    }

    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_OnLButtonUp
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     KeyFlags, state of various virtual keys.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnLButtonUp(
    HWND hWnd,
    int x,
    int y,
    UINT KeyFlags
    )
{
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!(pHexEditData->Flags & HEF_DRAGGING))
        return;

    KillTimer(hWnd, 1);

    ReleaseCapture();
    pHexEditData->Flags &= ~HEF_DRAGGING;

    UNREFERENCED_PARAMETER(x);
    UNREFERENCED_PARAMETER(y);
    UNREFERENCED_PARAMETER(KeyFlags);

}

/*******************************************************************************
*
*  HexEdit_HitTest
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     x, x-coordinate of the cursor relative to the client area.
*     y, y-coordinate of the cursor relative to the client area.
*     (returns), index of "hit" byte.
*
*******************************************************************************/

int
PASCAL
HexEdit_HitTest(
    HEXEDITDATA * pHexEditData,
    int x,
    int y
    )
{

    int HitLine;
    int BytesOnHitLine;
    int HitByte;

    //
    //  Figure out which line the user clicked on and how many bytes are on that
    //  line.
    //

    if (y < 0)
        HitLine = -1;

    else if (y >= pHexEditData->cyWindow)
        HitLine = pHexEditData->LinesVisible + 1;

    else
        HitLine = y / pHexEditData->FontHeight;

    HitLine += pHexEditData->FirstVisibleLine;

    if (HitLine >= pHexEditData->MaximumLines) {

        HitLine = pHexEditData->MaximumLines;

        BytesOnHitLine = (pHexEditData->cbBuffer) %
            BYTES_PER_HEXEDIT_LINE;
    }

    else {

        if (HitLine < 0)
            HitLine = 0;

        BytesOnHitLine = BYTES_PER_HEXEDIT_LINE;

    }

    //
    // Calculate the possible HitByte on the current line.
    //

    if (x < pHexEditData->xHexDumpStart)
        x = pHexEditData->xHexDumpStart;

    if (x >= pHexEditData->xHexDumpStart && x <
        pHexEditData->xHexDumpStart + pHexEditData->xHexDumpByteWidth *
        BYTES_PER_HEXEDIT_LINE + pHexEditData->FontMaxWidth) {

        x -= pHexEditData->xHexDumpStart;

        HitByte = x / pHexEditData->xHexDumpByteWidth;

        pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;

    }

    else {

        HitByte = (x - (pHexEditData->xAsciiDumpStart -
            pHexEditData->FontMaxWidth / 2)) / pHexEditData->FontMaxWidth;

        pHexEditData->Flags |= HEF_CARETINASCIIDUMP;

    }

    //
    //  We allow the user to "hit" the first byte of any line via two ways:
    //      *  clicking before the first byte on that line.
    //      *  clicking beyond the last byte/character of either display of the
    //         previous line.
    //
    //  We would like to see the latter case so that dragging in the control
    //  works naturally-- it's possible to drag to the end of the line to select
    //  the entire range.
    //

    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

    if (HitByte >= BytesOnHitLine) {

        if (BytesOnHitLine == BYTES_PER_HEXEDIT_LINE) {

            HitByte = BYTES_PER_HEXEDIT_LINE;
            pHexEditData->Flags |= HEF_CARETATENDOFLINE;

        }

        else {
             HitByte = BytesOnHitLine;
        }

    }

    return HitLine * BYTES_PER_HEXEDIT_LINE + HitByte;

}

/*******************************************************************************
*
*  HexEdit_OnKey
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnKey(
    HWND hWnd,
    UINT VirtualKey,
    BOOL fDown,
    int cRepeat,
    UINT Flags
    )
{
    BOOL fControlDown;
    BOOL fShiftDown;
    int NewCaretIndex;
    UINT ScrollCode;
    BOOL bPrevious = FALSE;
    HWND hTabWnd;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fControlDown = (GetKeyState(VK_CONTROL) < 0);
    fShiftDown = (GetKeyState(VK_SHIFT) < 0);

    NewCaretIndex = pHexEditData->CaretIndex;

    switch (VirtualKey) {

        case VK_TAB:
            if (fShiftDown && !fControlDown)
            {
                // tab to the previous control
                bPrevious = TRUE;
            }
            else 
            if (!fShiftDown && !fControlDown)
            {
                // tab to the next control
                bPrevious = FALSE;
            }

            hTabWnd = GetNextDlgTabItem(GetParent(hWnd), hWnd, bPrevious);
            SetFocus(hTabWnd);
            
            break;

        case VK_UP:
            if (fControlDown)
                break;

            NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;
            goto onkey_CheckLowerBound;

        case VK_DOWN:
            if (fControlDown)
                break;

            NewCaretIndex += BYTES_PER_HEXEDIT_LINE;

            if (NewCaretIndex / BYTES_PER_HEXEDIT_LINE >
                pHexEditData->MaximumLines) {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    goto onkey_MoveToEndOfBuffer;

                break;

            }

            goto onkey_CheckUpperBound;

        case VK_HOME:
            if (fControlDown)
                NewCaretIndex = 0;

            else {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    NewCaretIndex -= BYTES_PER_HEXEDIT_LINE;

                else
                    NewCaretIndex &= (~BYTES_PER_HEXEDIT_LINE_MASK);

            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

            goto onkey_ChangeCaretIndex;

        case VK_END:
            if (fControlDown) {

onkey_MoveToEndOfBuffer:
                pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
                NewCaretIndex = pHexEditData->cbBuffer;

            }

            else {

                if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
                    break;

                NewCaretIndex = (NewCaretIndex &
                    (~BYTES_PER_HEXEDIT_LINE_MASK)) + BYTES_PER_HEXEDIT_LINE;

                if (NewCaretIndex > pHexEditData->cbBuffer)
                    NewCaretIndex = pHexEditData->cbBuffer;

                else
                    pHexEditData->Flags |= HEF_CARETATENDOFLINE;

            }

            goto onkey_ChangeCaretIndex;

        case VK_PRIOR:
        case VK_NEXT:
            NewCaretIndex -= pHexEditData->FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            ScrollCode = ((VirtualKey == VK_PRIOR) ? SB_PAGEUP : SB_PAGEDOWN);

            HexEdit_OnVScroll(hWnd, NULL, ScrollCode, 0);

            NewCaretIndex += pHexEditData->FirstVisibleLine *
                BYTES_PER_HEXEDIT_LINE;

            if (VirtualKey == VK_PRIOR)
                goto onkey_CheckLowerBound;

            else
                goto onkey_CheckUpperBound;

        case VK_LEFT:
            if (fControlDown)
            {
                // toggle back and forth between hex and ascii
                if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
                    pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;
                else
                    pHexEditData->Flags |= HEF_CARETINASCIIDUMP;
            
                goto onkey_ChangeCaretIndex;
            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex--;

onkey_CheckLowerBound:
            if (NewCaretIndex < 0)
                break;

            goto onkey_ChangeCaretIndex;

        case VK_RIGHT:
            if (fControlDown)
            {
                // toggle back and forth between hex and ascii
                if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
                    pHexEditData->Flags &= ~HEF_CARETINASCIIDUMP;
                else
                    pHexEditData->Flags |= HEF_CARETINASCIIDUMP;
            
                goto onkey_ChangeCaretIndex;
            }

            pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
            NewCaretIndex++;

onkey_CheckUpperBound:
            if (NewCaretIndex > pHexEditData->cbBuffer)
                NewCaretIndex = pHexEditData->cbBuffer;

onkey_ChangeCaretIndex:
            HexEdit_ChangeCaretIndex(hWnd, NewCaretIndex, fShiftDown);
            break;

        case VK_DELETE:
            if (!fControlDown) {

                if (fShiftDown)
                    HexEdit_OnChar(hWnd, IDKEY_CUT, 0);
                else
                    HexEdit_DeleteRange(hWnd, VK_DELETE);

            }
            break;

        case VK_INSERT:
            if (fShiftDown) {

                if (!fControlDown)
                    HexEdit_OnChar(hWnd, IDKEY_PASTE, 0);

            }

            else if (fControlDown)
                HexEdit_OnChar(hWnd, IDKEY_COPY, 0);
            break;

    }
}

/*******************************************************************************
*
*  HexEdit_OnChar
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     Char,
*     cRepeat,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnChar(
    HWND hWnd,
    TCHAR Char,
    int cRepeat
    )
{

    PBYTE pCaretByte;
    BYTE NewCaretByte;
    int PrevCaretIndex;
    RECT UpdateRect;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    //  Check for any special control characters.
    //

    switch (Char) {

        case IDKEY_COPY:
            HexEdit_OnCopy(hWnd);
            return;

        case IDKEY_PASTE:
            PrevCaretIndex = pHexEditData->CaretIndex;

            if (HexEdit_OnPaste(hWnd))
                goto UpdateDisplay;

            return;

        case IDKEY_CUT:
            if (!HexEdit_OnCopy(hWnd))
                return;
            //  FALL THROUGH

        case VK_BACK:
            HexEdit_DeleteRange(hWnd, VK_BACK);
            return;

        case VK_TAB:
            return;
    }

    //
    //  Validate and convert the typed character depending on the "column" the
    //  user is typing in.
    //

    if (pHexEditData->Flags & HEF_CARETINASCIIDUMP) {

        if (Char < ' ') {

            MessageBeep(MB_OK);
            return;

        }

        NewCaretByte = (BYTE) Char;

    }

    else {

        Char = (TCHAR) CharLower((LPTSTR) Char);

        if (Char >= '0' && Char <= '9')
            NewCaretByte = (BYTE) (Char - '0');

        else if (Char >= 'a' && Char <= 'f')
            NewCaretByte = (BYTE) (Char - 'a' + 10);

        else {

            MessageBeep(MB_OK);
            return;

        }

    }

    if (!(pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)) {

        //
        //  Check to see if we're inserting while a range is selected.  If so,
        //  delete the range and insert at the start of the range.
        //

        if (pHexEditData->MinimumSelectedIndex !=
            pHexEditData->MaximumSelectedIndex)
            HexEdit_DeleteRange(hWnd, 0);

        //
        //  Verify that we aren't overruning the value data buffer.
        //

        if (pHexEditData->cbBuffer >= MAXDATA_LENGTH) {

            MessageBeep(MB_OK);
            return;

        }

        //
        //  Make room for the new byte by shifting all bytes after the insertion
        //  point down one byte.
        //

        pCaretByte = pHexEditData->pBuffer + pHexEditData->CaretIndex;

        MoveMemory(pCaretByte + 1, pCaretByte, pHexEditData->cbBuffer -
            pHexEditData->CaretIndex);

        pHexEditData->cbBuffer++;

        HexEdit_SetScrollInfo(hWnd);

        if (pHexEditData->Flags & HEF_CARETINASCIIDUMP)
            *pCaretByte = NewCaretByte;

        else {

            pHexEditData->Flags |= HEF_INSERTATLOWNIBBLE;

            *pCaretByte = NewCaretByte << 4;

        }

    }

    else {

        pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

        *(pHexEditData->pBuffer + pHexEditData->CaretIndex) |= NewCaretByte;

    }

    PrevCaretIndex = pHexEditData->CaretIndex;

    if (!(pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)) {

        pHexEditData->CaretIndex++;

        pHexEditData->MinimumSelectedIndex = pHexEditData->CaretIndex;
        pHexEditData->MaximumSelectedIndex = pHexEditData->CaretIndex;

    }

UpdateDisplay:
    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;
    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = pHexEditData->cxWindow;
    UpdateRect.top = (PrevCaretIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;
    UpdateRect.bottom = pHexEditData->cyWindow;

    SendMessage(GetParent(hWnd), WM_COMMAND,
                MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID), EN_CHANGE), (LPARAM)hWnd);

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_SetCaretPosition
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_SetCaretPosition(
    HWND hWnd
    )
{

    int CaretByte;
    int xCaret;
    int yCaret;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    CaretByte = pHexEditData->CaretIndex % BYTES_PER_HEXEDIT_LINE;

    yCaret = (pHexEditData->CaretIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (pHexEditData->Flags & HEF_CARETATENDOFLINE) {

        CaretByte = BYTES_PER_HEXEDIT_LINE;
        yCaret -= pHexEditData->FontHeight;

    }

    //
    //  Figure out which "column" the user is editing in and thus should have
    //  the caret.
    //

    if (pHexEditData->Flags & HEF_CARETINASCIIDUMP) {

        xCaret = pHexEditData->xAsciiDumpStart + CaretByte *
            pHexEditData->FontMaxWidth;

    }

    else {

        xCaret = pHexEditData->xHexDumpStart + CaretByte *
            pHexEditData->xHexDumpByteWidth;

        if (pHexEditData->Flags & HEF_INSERTATLOWNIBBLE)
            xCaret += pHexEditData->FontMaxWidth * 3 / 2;

    }

    SetCaretPos(xCaret, yCaret);

}

/*******************************************************************************
*
*  HexEdit_EnsureCaretVisible
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_EnsureCaretVisible(
    HWND hWnd
    )
{

    int CaretLine;
    int LastVisibleLine;
    int Delta;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (!(pHexEditData->Flags & HEF_FOCUS))
        return;

    CaretLine = pHexEditData->CaretIndex / BYTES_PER_HEXEDIT_LINE;

    //
    //  Check if caret should really be displayed at the end of the previous
    //  line.
    //

    if (pHexEditData->Flags & HEF_CARETATENDOFLINE)
        CaretLine--;

    LastVisibleLine = pHexEditData->FirstVisibleLine +
        pHexEditData->LinesVisible - 1;

    if (CaretLine > LastVisibleLine)
        Delta = LastVisibleLine;

    else if (CaretLine < pHexEditData->FirstVisibleLine)
        Delta = pHexEditData->FirstVisibleLine;

    else
        Delta = -1;

    if (Delta != -1) {

        ScrollWindowEx(hWnd, 0, (Delta - CaretLine) * pHexEditData->FontHeight,
            NULL, NULL, NULL, NULL, SW_INVALIDATE);

        pHexEditData->FirstVisibleLine += CaretLine - Delta;

        HexEdit_SetScrollInfo(hWnd);

    }

    HexEdit_SetCaretPosition(hWnd);

}

/*******************************************************************************
*
*  HexEdit_ChangeCaretIndex
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     NewCaretIndex,
*     fExtendSelection,
*
*******************************************************************************/

VOID
PASCAL
HexEdit_ChangeCaretIndex(
    HWND hWnd,
    int NewCaretIndex,
    BOOL fExtendSelection
    )
{

    int PrevMinimumSelectedIndex;
    int PrevMaximumSelectedIndex;
    int Swap;
    int UpdateRectCount;
    RECT UpdateRect[2];
    BOOL fPrevRangeEmpty;
    HDC hDC;
    int Index;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

    PrevMinimumSelectedIndex = pHexEditData->MinimumSelectedIndex;
    PrevMaximumSelectedIndex = pHexEditData->MaximumSelectedIndex;

    if (fExtendSelection) {

        if (pHexEditData->CaretIndex == pHexEditData->MaximumSelectedIndex)
            pHexEditData->MaximumSelectedIndex = NewCaretIndex;

        else
            pHexEditData->MinimumSelectedIndex = NewCaretIndex;

        if (pHexEditData->MinimumSelectedIndex >
            pHexEditData->MaximumSelectedIndex) {

            Swap = pHexEditData->MinimumSelectedIndex;
            pHexEditData->MinimumSelectedIndex =
                pHexEditData->MaximumSelectedIndex;
            pHexEditData->MaximumSelectedIndex = Swap;

        }

    }

    else {

        pHexEditData->MinimumSelectedIndex = NewCaretIndex;
        pHexEditData->MaximumSelectedIndex = NewCaretIndex;

    }

    pHexEditData->CaretIndex = NewCaretIndex;

    UpdateRectCount = 0;

    if (pHexEditData->MinimumSelectedIndex > PrevMinimumSelectedIndex) {

        UpdateRect[0].top = PrevMinimumSelectedIndex;
        UpdateRect[0].bottom = pHexEditData->MinimumSelectedIndex;

        UpdateRectCount++;

    }

    else if (pHexEditData->MinimumSelectedIndex < PrevMinimumSelectedIndex) {

        UpdateRect[0].top = pHexEditData->MinimumSelectedIndex;
        UpdateRect[0].bottom = PrevMinimumSelectedIndex;

        UpdateRectCount++;

    }

    if (pHexEditData->MaximumSelectedIndex > PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = PrevMaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = pHexEditData->MaximumSelectedIndex;

        UpdateRectCount++;

    }

    else if (pHexEditData->MaximumSelectedIndex < PrevMaximumSelectedIndex) {

        UpdateRect[UpdateRectCount].top = pHexEditData->MaximumSelectedIndex;
        UpdateRect[UpdateRectCount].bottom = PrevMaximumSelectedIndex;

        UpdateRectCount++;

    }

    if (fPrevRangeEmpty = (PrevMinimumSelectedIndex ==
        PrevMaximumSelectedIndex)) {

        UpdateRect[0].top = pHexEditData->MinimumSelectedIndex;
        UpdateRect[0].bottom = pHexEditData->MaximumSelectedIndex;

        UpdateRectCount = 1;

    }

    if (pHexEditData->MinimumSelectedIndex ==
        pHexEditData->MaximumSelectedIndex) {

        if (!fPrevRangeEmpty) {

            UpdateRect[0].top = PrevMinimumSelectedIndex;
            UpdateRect[0].bottom = PrevMaximumSelectedIndex;

            UpdateRectCount = 1;

        }

        else
            UpdateRectCount = 0;

    }

    if (UpdateRectCount) {

        HideCaret(hWnd);

        hDC = GetDC(hWnd);
        if (hDC)
        {
            for (Index = 0; Index < UpdateRectCount; Index++) 
            {

                UpdateRect[Index].top = (UpdateRect[Index].top /
                    BYTES_PER_HEXEDIT_LINE - pHexEditData->FirstVisibleLine) *
                    pHexEditData->FontHeight;
                UpdateRect[Index].bottom = (UpdateRect[Index].bottom /
                    BYTES_PER_HEXEDIT_LINE - pHexEditData->FirstVisibleLine + 1) *
                    pHexEditData->FontHeight;

                if (UpdateRect[Index].top >= pHexEditData->cyWindow ||
                    UpdateRect[Index].bottom < 0)
                    continue;

                if (UpdateRect[Index].top < 0)
                    UpdateRect[Index].top = 0;

                if (UpdateRect[Index].bottom > pHexEditData->cyWindow)
                    UpdateRect[Index].bottom = pHexEditData->cyWindow;

                HexEdit_PaintRect(hWnd, hDC, &UpdateRect[Index]);
            }
    
            ReleaseDC(hWnd, hDC);
        }

        ShowCaret(hWnd);

    }


    HexEdit_EnsureCaretVisible(hWnd);

}

/*******************************************************************************
*
*  HexEdit_DeleteRange
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

VOID
PASCAL
HexEdit_DeleteRange(
    HWND hWnd,
    UINT SourceKey
    )
{

    int MinimumSelectedIndex;
    int MaximumSelectedIndex;
    PBYTE pMinimumSelectedByte;
    int Length;
    RECT UpdateRect;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    pHexEditData->Flags &= ~HEF_CARETATENDOFLINE;

    MinimumSelectedIndex = pHexEditData->MinimumSelectedIndex;
    MaximumSelectedIndex = pHexEditData->MaximumSelectedIndex;

    //
    //  Check to see if a range is selected.  If not, then artificially create
    //  one based on the key that caused this routine to be called.
    //

    if (MinimumSelectedIndex == MaximumSelectedIndex) {

        if (SourceKey == VK_DELETE || pHexEditData->Flags &
            HEF_INSERTATLOWNIBBLE) {

            pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;

            MaximumSelectedIndex++;

            if (MaximumSelectedIndex > pHexEditData->cbBuffer)
                return;

        }

        else if (SourceKey == VK_BACK) {

            MinimumSelectedIndex--;

            if (MinimumSelectedIndex < 0)
                return;

        }

        else
            return;

    }

    //
    //  Compute where to start deleting from and the number of bytes to delete.
    //

    pMinimumSelectedByte = pHexEditData->pBuffer + MinimumSelectedIndex;

    Length = MaximumSelectedIndex - MinimumSelectedIndex;

    //
    //  Delete the bytes and update all appropriate window data.
    //

    MoveMemory(pMinimumSelectedByte, pMinimumSelectedByte + Length,
        pHexEditData->cbBuffer - MaximumSelectedIndex);

    pHexEditData->cbBuffer -= Length;

    pHexEditData->CaretIndex = MinimumSelectedIndex;
    pHexEditData->MinimumSelectedIndex = MinimumSelectedIndex;
    pHexEditData->MaximumSelectedIndex = MinimumSelectedIndex;

    HexEdit_SetScrollInfo(hWnd);

    HexEdit_EnsureCaretVisible(hWnd);

    UpdateRect.left = 0;
    UpdateRect.right = pHexEditData->cxWindow;
    UpdateRect.top = (MinimumSelectedIndex / BYTES_PER_HEXEDIT_LINE -
        pHexEditData->FirstVisibleLine) * pHexEditData->FontHeight;
    UpdateRect.bottom = pHexEditData->cyWindow;

    SendMessage(GetParent(hWnd), WM_COMMAND,
                MAKEWPARAM(GetWindowLongPtr(hWnd, GWLP_ID), EN_CHANGE), (LPARAM)hWnd);

    InvalidateRect(hWnd, &UpdateRect, FALSE);

}

/*******************************************************************************
*
*  HexEdit_OnCopy
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnCopy(
    HWND hWnd
    )
{

    BOOL fSuccess;
    int cbClipboardData;
    LPBYTE lpStartByte;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fSuccess = FALSE;

    cbClipboardData = pHexEditData->MaximumSelectedIndex -
        pHexEditData->MinimumSelectedIndex;

    if (cbClipboardData != 0) {

        lpStartByte = pHexEditData->pBuffer +
            pHexEditData->MinimumSelectedIndex;

        if (OpenClipboard(hWnd)) {

            if ((hClipboardData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                cbClipboardData + sizeof(HEXEDITCLIPBOARDDATA) - 1)) != NULL) {

                lpClipboardData = (LPHEXEDITCLIPBOARDDATA)
                    GlobalLock(hClipboardData);
                CopyMemory(lpClipboardData-> Data, lpStartByte,
                    cbClipboardData);
                lpClipboardData-> cbSize = cbClipboardData;
                GlobalUnlock(hClipboardData);

                EmptyClipboard();
                SetClipboardData(s_HexEditClipboardFormat, hClipboardData);

                fSuccess = TRUE;

            }

            CloseClipboard();

        }

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnPaste
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*
*******************************************************************************/

BOOL
PASCAL
HexEdit_OnPaste(
    HWND hWnd
    )
{

    BOOL fSuccess;
    HANDLE hClipboardData;
    LPHEXEDITCLIPBOARDDATA lpClipboardData;
    PBYTE pCaretByte;
    DWORD cbSize;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    fSuccess = FALSE;

    if (pHexEditData->Flags & HEF_INSERTATLOWNIBBLE) {

        pHexEditData->Flags &= ~HEF_INSERTATLOWNIBBLE;
        pHexEditData->CaretIndex++;

    }

    if (OpenClipboard(hWnd)) {

        if ((hClipboardData = GetClipboardData(s_HexEditClipboardFormat)) !=
            NULL) {

            lpClipboardData = (LPHEXEDITCLIPBOARDDATA)
                GlobalLock(hClipboardData);

            if (pHexEditData->cbBuffer + lpClipboardData-> cbSize <=
                MAXDATA_LENGTH) {

                if (pHexEditData->MinimumSelectedIndex !=
                    pHexEditData->MaximumSelectedIndex)
                    HexEdit_DeleteRange(hWnd, VK_BACK);

                //
                //  Make room for the new bytes by shifting all bytes after the
                //  the insertion point down the necessary amount.
                //

                pCaretByte = pHexEditData->pBuffer + pHexEditData->CaretIndex;
                cbSize = lpClipboardData-> cbSize;

                MoveMemory(pCaretByte + cbSize, pCaretByte,
                    pHexEditData->cbBuffer - pHexEditData->CaretIndex);
                CopyMemory(pCaretByte, lpClipboardData-> Data, cbSize);

                pHexEditData->cbBuffer += cbSize;
                pHexEditData->CaretIndex += cbSize;

                HexEdit_SetScrollInfo(hWnd);

                fSuccess = TRUE;

            }

            GlobalUnlock(hClipboardData);

        }

        CloseClipboard();

    }

    return fSuccess;

}

/*******************************************************************************
*
*  HexEdit_OnContextMenu
*
*  DESCRIPTION:
*
*  PARAMETERS:
*     hWnd, handle of HexEdit window.
*     x, horizontal position of the cursor.
*     y, vertical position of the cursor.
*
*******************************************************************************/

VOID
PASCAL
HexEdit_OnContextMenu(
    HWND hWnd,
    int x,
    int y
    )
{

    HMENU hContextMenu;
    HMENU hContextPopupMenu;
    int MenuCommand;
    HEXEDITDATA * pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    //
    //  Give us the focus if we don't already have it.
    //

    if (!(pHexEditData->Flags & HEF_FOCUS))
        SetFocus(hWnd);

    //
    //  Load the HexEdit context menu from our resources.
    //

    if ((hContextMenu = LoadMenu(g_hInstance,
        MAKEINTRESOURCE(IDM_HEXEDIT_CONTEXT))) == NULL)
        return;

    hContextPopupMenu = GetSubMenu(hContextMenu, 0);

    //
    //  Disable editing menu options as appropriate.
    //

    if (pHexEditData->MinimumSelectedIndex ==
        pHexEditData->MaximumSelectedIndex) {

        EnableMenuItem(hContextPopupMenu, IDKEY_COPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, IDKEY_CUT, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hContextPopupMenu, VK_DELETE, MF_BYCOMMAND | MF_GRAYED);

    }

    if (!IsClipboardFormatAvailable(s_HexEditClipboardFormat))
        EnableMenuItem(hContextPopupMenu, IDKEY_PASTE, MF_BYCOMMAND |
            MF_GRAYED);

    if (pHexEditData->MinimumSelectedIndex == 0 &&
        pHexEditData->MaximumSelectedIndex == pHexEditData->cbBuffer)
        EnableMenuItem(hContextPopupMenu, ID_SELECTALL, MF_BYCOMMAND |
            MF_GRAYED);

    //
    //  Display and handle the selected command.
    //

    MenuCommand = TrackPopupMenuEx(hContextPopupMenu, TPM_RETURNCMD |
        TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_TOPALIGN, x, y, hWnd, NULL);

    DestroyMenu(hContextMenu);

    switch (MenuCommand) {

        case IDKEY_COPY:
        case IDKEY_PASTE:
        case IDKEY_CUT:
        case VK_DELETE:
            HexEdit_OnChar(hWnd, (TCHAR) MenuCommand, 0);
            break;

        case ID_SELECTALL:
            pHexEditData->MinimumSelectedIndex = 0;
            pHexEditData->MaximumSelectedIndex = pHexEditData->cbBuffer;
            pHexEditData->CaretIndex = pHexEditData->cbBuffer;
            HexEdit_SetCaretPosition(hWnd);
            InvalidateRect(hWnd, NULL, FALSE);
            break;

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classmod.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ClassMod.h
		This file contains all of the prototypes for the 
		option class modification dialog.

    FILE HISTORY:
        
*/

#if !defined _CLASSMOD_H
#define _CLASSMOD_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if !defined _CLASSED_H
    #include "classed.h"
#endif

#define     CLASS_TYPE_VENDOR  0
#define     CLASS_TYPE_USER    1

// CWnd based control for hex editor
class CWndHexEdit : public CWnd
{
    DECLARE_DYNAMIC(CWndHexEdit)

protected:
    static WNDPROC m_wproc_super ;
    static BOOL m_b_inited ;

public:

    CWndHexEdit () ;
    ~ CWndHexEdit () ;

    BOOL Create(LPCTSTR lpszText, 
        DWORD dwStyle,
        const RECT& rect, 
        CWnd* pParentWnd, 
        UINT nID = 0xffff
        );

    WNDPROC * GetSuperWndProcAddr() ;

    //  One-shot initialization
    static BOOL CreateWindowClass ( HINSTANCE hInstance );  
};

class CClassInfo
{
public:
    CClassInfo() {};
    CClassInfo(CClassInfo & classInfo)
    {
        *this = classInfo;
    }

    CClassInfo & operator = (const CClassInfo & ClassInfo)
    {
        strName = ClassInfo.strName;
        strComment = ClassInfo.strComment;
        bIsVendor = ClassInfo.bIsVendor;
        
        baData.RemoveAll();
        baData.Copy(ClassInfo.baData);

        return *this;
    }

    BOOL IsDynBootpClass()
    {
        BOOL fResult = FALSE;

	    if (baData.GetSize() == (int) strlen(DHCP_BOOTP_CLASS_TXT))
	    {
		    // now mem compare
		    if (memcmp(baData.GetData(), DHCP_BOOTP_CLASS_TXT, (size_t)baData.GetSize()) == 0)
		    {
			    // found it!
                fResult = TRUE;
            }
        }

        return fResult;
    }

    BOOL IsRRASClass()
    {
        BOOL fResult = FALSE;

	    if (baData.GetSize() == (int) strlen(DHCP_RAS_CLASS_TXT))
	    {
		    // now mem compare
		    if (memcmp(baData.GetData(), DHCP_RAS_CLASS_TXT, (size_t)baData.GetSize()) == 0)
		    {
			    // found it!
                fResult = TRUE;
            }
        }

        return fResult;
    }

    BOOL IsSystemClass()
    {
        BOOL fResult = FALSE;

		// check to see if this is one of the default clasess, if so disable
		if ( ((size_t) baData.GetSize() == strlen(DHCP_MSFT50_CLASS_TXT)) ||
			 ((size_t) baData.GetSize() == strlen(DHCP_MSFT98_CLASS_TXT)) ||
			 ((size_t) baData.GetSize() == strlen(DHCP_MSFT_CLASS_TXT)) )
		{
			if ( (memcmp(baData.GetData(), DHCP_MSFT50_CLASS_TXT, (size_t)baData.GetSize()) == 0) ||
				 (memcmp(baData.GetData(), DHCP_MSFT98_CLASS_TXT, (size_t)baData.GetSize()) == 0) ||
				 (memcmp(baData.GetData(), DHCP_MSFT_CLASS_TXT, (size_t)baData.GetSize()) == 0) )
			{
				fResult = TRUE;
			}
		}

        return fResult;
	}


public:    
    CString     strName;
    CString     strComment;
    BOOL        bIsVendor;
    CByteArray  baData;
};

typedef CArray<CClassInfo, CClassInfo&> CClassInfoArrayBase;

class CClassInfoArray : public CClassInfoArrayBase
{
public:
    CClassInfoArray();
    ~CClassInfoArray();

    DWORD   RefreshData(LPCTSTR pServer);
    BOOL    RemoveClass(LPCTSTR pClassName);
    DWORD   ModifyClass(LPCTSTR pServer, CClassInfo & ClassInfo);
    DWORD	AddClass(LPCTSTR pServer, CClassInfo & ClassInfo);
	BOOL    IsValidClass(LPCTSTR pClassName);
};


/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass dialog

class CDhcpModifyClass : public CBaseDialog
{
// Construction
public:
	CDhcpModifyClass(CClassInfoArray * pClassArray, LPCTSTR pszServer, BOOL bCreate, DWORD dwType, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpModifyClass)
	enum { IDD = IDD_CLASSID_NEW };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    CWndHexEdit	m_hexData;       //  Hex Data

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpModifyClass::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpModifyClass)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDhcpModifyClass)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeValuename();
	afx_msg void OnChangeValuecomment();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    afx_msg void OnChangeValueData();

    void    SetDirty(BOOL bDirty) { m_bDirty = bDirty; }

public:
    EDITVALUEPARAM      m_EditValueParam;

protected:
    HEXEDITDATA *       m_pHexEditData;
    CString             m_strName;
    CString             m_strComment;
    BYTE                m_buffer[MAXDATA_LENGTH];
    
    DWORD               m_dwType;

    CClassInfoArray *   m_pClassInfoArray;
    CString             m_strServer;

    BOOL                m_bDirty;
    BOOL                m_bCreate;   // are we creating or modifing a class
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSMOD_H__3995264F_96A1_11D1_93E0_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	Classes.h
		This file contains all of the prototypes for the 
		option class dialog.

    FILE HISTORY:
        
*/

#if !defined _CLASSES_H
#define _CLASSES_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _CLASSMOD_H
#include "classmod.h"
#endif 

/////////////////////////////////////////////////////////////////////////////
// CDhcpClasses dialog

class CDhcpClasses : public CBaseDialog
{
// Construction
public:
	CDhcpClasses(CClassInfoArray * pClassArray, LPCTSTR pszServer, DWORD dwType, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDhcpClasses)
	enum { IDD = IDD_CLASSES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpClasses::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDhcpClasses)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDhcpClasses)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonEdit();
	afx_msg void OnButtonNew();
	virtual void OnOK();
	afx_msg void OnItemchangedListClasses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListClasses(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void UpdateList();
    void UpdateButtons();

protected:
    CClassInfoArray *   m_pClassInfoArray;
    CString             m_strServer;

    DWORD               m_dwType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLASSES_H__3995264E_96A1_11D1_93E0_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\croot.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        croot.h
                DHCP root node information (the root node is not displayed
                in the MMC framework but contains information such as 
                all of the servers in this snapin).
                
    FILE HISTORY:
        
*/

#ifndef _CROOT_H
#define _CROOT_H

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#define COMPUTERNAME_LEN_MAX                    255

/*---------------------------------------------------------------------------
        Class:  CDhcpRootHandler
 ---------------------------------------------------------------------------*/
class CDhcpRootHandler : public CDhcpHandler
{
// Interface
public:
    CDhcpRootHandler(ITFSComponentData *pCompData);

    // Node handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();
    
    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
    OVERRIDE_BaseHandlerNotify_OnRemoveChildren();

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
        // helper routines
        void    CreateLocalDhcpServer();
        HRESULT AddServer(LPCWSTR pServerIp, LPCTSTR pServerName, BOOL bNewServer, DWORD dwServerOptions = 0x00000000, DWORD dwRefreshInterval = 0xffffffff, BOOL bExtension = FALSE);
        HRESULT GetGroupName(CString * pstrGroupName);
        HRESULT SetGroupName(LPCTSTR pszGroupName);

        BOOL    IsServerInList(ITFSNode * pRootNode, DHCP_IP_ADDRESS dhcpIpAddressNew, CString & strName);
        DWORD   LoadOldServerList(ITFSNode * pRootNode);
    HRESULT AddServerSortedIp(ITFSNode * pNewNode, BOOL bNewServer);
    HRESULT AddServerSortedName(ITFSNode * pNewNode, BOOL bNewServer);

public:
        // CDhcpHandler overrides
        virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:
        // Command handlers
        HRESULT OnCreateNewServer(ITFSNode * pNode);
        HRESULT OnBrowseServers(ITFSNode * pNode);
        HRESULT OnImportOldList(ITFSNode * pNode);
    BOOL    OldServerListExists();
    // helpers
    HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
        HRESULT RemoveOldEntries(ITFSNode * pRootNode, DHCP_IP_ADDRESS dhcpAddress);

    void    UpdateResultMessage(ITFSNode * pNode);

private:
    BOOL        m_bMachineAdded;
    BOOL        m_fViewMessage;
};

#endif _CROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\classmod.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ClassMod.cpp
		This file contains all of the prototypes for the 
		option class modification dialog.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ClassMod.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*---------------------------------------------------------------------------
	Class CWndHexEdit implementation
 ---------------------------------------------------------------------------*/
//  Static class-level data

//  Super window proc address
WNDPROC CWndHexEdit::m_wproc_super = NULL;

//  Window class initialization flag                  
BOOL CWndHexEdit::m_b_inited = FALSE;

WNDPROC * 
CWndHexEdit::GetSuperWndProcAddr()
{
    return &m_wproc_super;
}


BOOL 
CWndHexEdit::CreateWindowClass ( HINSTANCE hInstance )
{
    Trace0("CWndHexEdit::CreateWindowClass\n");
    if ( ! m_b_inited ) 
    {
        m_b_inited = ::RegisterHexEditClass( hInstance )  ;
    }
    return m_b_inited ;
}

IMPLEMENT_DYNAMIC(CWndHexEdit, CWnd)

CWndHexEdit::CWndHexEdit()
{
}

CWndHexEdit::~CWndHexEdit()
{
    DestroyWindow();
}

BOOL 
CWndHexEdit::Create 
( 
    LPCTSTR			lpszText, 
    DWORD			dwStyle,
    const RECT &	rect, 
    CWnd *			pParentWnd, 
    UINT			nID 
)
{
    return CWnd::Create( TEXT("HEX"), lpszText, dwStyle, rect, pParentWnd, nID);
}

/*---------------------------------------------------------------------------
	Class CClassInfoArray implementation
 ---------------------------------------------------------------------------*/
CClassInfoArray::CClassInfoArray()
{

}

CClassInfoArray::~CClassInfoArray()
{

}

DWORD
CClassInfoArray::RefreshData(LPCTSTR pServer)
{
    DWORD                   dwErr;
    HRESULT                 hr = hrOK;
    DHCP_RESUME_HANDLE      dhcpResumeHandle = NULL;
    LPDHCP_CLASS_INFO_ARRAY pClassInfoArray = NULL;
    DWORD                   dwRead = 0, dwTotal = 0;
    CClassInfo              ClassInfo;
    UINT                    i, j;

    Assert(pServer != NULL);
    if (pServer == NULL)
        return ERROR_INVALID_PARAMETER;

    // clear all of the old entries
    RemoveAll();

    dwErr = ::DhcpEnumClasses((LPTSTR) pServer,
                              0,
                              &dhcpResumeHandle,
                              0xFFFFFFFF,
                              &pClassInfoArray,
                              &dwRead,
                              &dwTotal);
    
	Trace3("CClassInfoArray::RefreshData - DhcpEnumClasses returned %d, dwRead %d, dwTotal %d.\n", dwErr, dwRead, dwTotal);

    if (dwErr == ERROR_NO_MORE_ITEMS)
        return ERROR_SUCCESS;

    if (dwErr != ERROR_SUCCESS)
        return dwErr;

    Assert(pClassInfoArray);

    for (i = 0; i < pClassInfoArray->NumElements; i++)
    {
        COM_PROTECT_TRY
        {
            // fill in our internal class info structure
            ClassInfo.strName = pClassInfoArray->Classes[i].ClassName;
            ClassInfo.strComment = pClassInfoArray->Classes[i].ClassComment;
            ClassInfo.bIsVendor = pClassInfoArray->Classes[i].IsVendor;
            
            ClassInfo.baData.RemoveAll();

            // now copy out the data
            for (j = 0; j < pClassInfoArray->Classes[i].ClassDataLength; j++)
            {
                ClassInfo.baData.Add(pClassInfoArray->Classes[i].ClassData[j]);
            }

            Add(ClassInfo);
        }
        COM_PROTECT_CATCH
    }

    if (pClassInfoArray)
        ::DhcpRpcFreeMemory(pClassInfoArray);

    if (dwErr == ERROR_NO_MORE_ITEMS)
        dwErr = ERROR_SUCCESS;
    
    return dwErr;
}

BOOL
CClassInfoArray::RemoveClass(LPCTSTR pClassName)
{
    BOOL bRemoved = FALSE;
    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).strName.CompareNoCase(pClassName) == 0)
        {
            RemoveAt(i);
            bRemoved = TRUE;
            break;
        }
    }

    return bRemoved;
}

DWORD
CClassInfoArray::ModifyClass(LPCTSTR pServer, CClassInfo & classInfo)
{
	DWORD dwError = 0;
    DHCP_CLASS_INFO     dhcpClassInfo;

    dhcpClassInfo.ClassName = (LPWSTR) ((LPCTSTR) classInfo.strName);
    dhcpClassInfo.ClassComment = (LPWSTR) ((LPCTSTR) classInfo.strComment);
    dhcpClassInfo.ClassDataLength = (DWORD) classInfo.baData.GetSize();
    dhcpClassInfo.ClassData = classInfo.baData.GetData();
    dhcpClassInfo.IsVendor = classInfo.bIsVendor;

    dwError = ::DhcpModifyClass((LPWSTR) ((LPCTSTR) pServer), 0, &dhcpClassInfo);
	if (dwError == ERROR_SUCCESS)
	{
		for (int i = 0; i < GetSize(); i++)
		{
			if (GetAt(i).strName.CompareNoCase(classInfo.strName) == 0)
			{
				m_pData[i].strComment = classInfo.strComment;
				m_pData[i].baData.RemoveAll();
				for (int j = 0; j < classInfo.baData.GetSize(); j++)
				{
					m_pData[i].baData.Add(classInfo.baData[j]);
				}

				break;
			}
		}
	}

    return dwError;
}

BOOL 
CClassInfoArray::IsValidClass(LPCTSTR pClassName)
{
    BOOL bExists = FALSE;
    if (pClassName == NULL)
        return TRUE;

    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).strName.CompareNoCase(pClassName) == 0)
        {
            bExists = TRUE;
            break;
        }
    }

    return bExists;
}

DWORD
CClassInfoArray::AddClass(LPCTSTR pServer, CClassInfo & classInfo)
{
	DWORD dwError = 0;
    DHCP_CLASS_INFO     dhcpClassInfo;

    dhcpClassInfo.ClassName = (LPWSTR) ((LPCTSTR) classInfo.strName);
    dhcpClassInfo.ClassComment = (LPWSTR) ((LPCTSTR) classInfo.strComment);
    dhcpClassInfo.ClassDataLength = (DWORD) classInfo.baData.GetSize();
    dhcpClassInfo.ClassData = classInfo.baData.GetData();
    dhcpClassInfo.IsVendor = classInfo.bIsVendor;

    dwError = ::DhcpCreateClass((LPWSTR) ((LPCTSTR) pServer), 0, &dhcpClassInfo);
    if (dwError == ERROR_SUCCESS)
	{
		Add(classInfo);
	}

	return dwError;
}

/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass dialog


CDhcpModifyClass::CDhcpModifyClass(CClassInfoArray * pClassArray, LPCTSTR pszServer, BOOL bCreate, DWORD dwType, CWnd* pParent /*=NULL*/)
	: CBaseDialog(CDhcpModifyClass::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDhcpModifyClass)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_strServer = pszServer;
    m_pClassInfoArray = pClassArray;

    m_pHexEditData = NULL;
    m_bDirty = FALSE;

    m_dwType = dwType;

    m_bCreate = bCreate;
}


void CDhcpModifyClass::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDhcpModifyClass)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_VALUEDATA, m_hexData);
}


BEGIN_MESSAGE_MAP(CDhcpModifyClass, CBaseDialog)
	//{{AFX_MSG_MAP(CDhcpModifyClass)
	ON_EN_CHANGE(IDC_VALUENAME, OnChangeValuename)
	ON_EN_CHANGE(IDC_VALUECOMMENT, OnChangeValuecomment)
	//}}AFX_MSG_MAP
	ON_EN_CHANGE(IDC_VALUEDATA, OnChangeValueData)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpModifyClass message handlers

BOOL CDhcpModifyClass::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();

    CString strTitle;

    // initialze the name and comment
    if (!m_bCreate)
    {
        int len;

        SetDlgItemText(IDC_VALUENAME, m_EditValueParam.pValueName);
        SetDlgItemText(IDC_VALUECOMMENT, m_EditValueParam.pValueComment);

        ((CEdit *) GetDlgItem(IDC_VALUENAME))->SetReadOnly(TRUE);

        // initialize the hexedit data
        // since the data can grow, we need to supply a buffer big enough
        // If it exceeds the size, limit it to the buffer size
        ZeroMemory(m_buffer, sizeof(m_buffer));

        len = ( m_EditValueParam.cbValueData <= sizeof( m_buffer ))
            ? m_EditValueParam.cbValueData
            : sizeof( m_buffer );
        memcpy( m_buffer, m_EditValueParam.pValueData, len );
        m_EditValueParam.cbValueData = len;

        strTitle.LoadString(IDS_EDIT_CLASS_TITLE);
    }
    else
    {
        // we're creating a new class. No data yet.
        m_EditValueParam.cbValueData = 0;
        memset(m_buffer, 0, sizeof(m_buffer));

        strTitle.LoadString(IDS_NEW_CLASS_TITLE);
    }

    this->SetWindowText(strTitle);

    SendDlgItemMessage(IDC_VALUEDATA, HEM_SETBUFFER, (WPARAM)
        m_EditValueParam.cbValueData, (LPARAM) m_buffer);

    SetDirty(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDhcpModifyClass::OnChangeValuename() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnChangeValuecomment() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnChangeValueData() 
{
    SetDirty(TRUE);
}

void CDhcpModifyClass::OnOK() 
{
	DWORD			    dwError = 0;	
    DHCP_CLASS_INFO     dhcpClassInfo;

    GetDlgItemText(IDC_VALUENAME, m_strName);
    GetDlgItemText(IDC_VALUECOMMENT, m_strComment);
	
    m_pHexEditData = (HEXEDITDATA *) GetWindowLongPtr(GetDlgItem(IDC_VALUEDATA)->GetSafeHwnd(), GWLP_USERDATA);
    Assert(m_pHexEditData);

    if (m_strName.IsEmpty())
    {
        // user didn't enter any data to describe the class
        AfxMessageBox(IDS_CLASSID_NO_NAME);
    
        GetDlgItem(IDC_VALUENAME)->SetFocus();
        return;
    }

    if (m_pHexEditData->cbBuffer == 0)
    {
        // user didn't enter any data to describe the class
        AfxMessageBox(IDS_CLASSID_NO_DATA);
    
        GetDlgItem(IDC_VALUEDATA)->SetFocus();
        return;
    }

    CClassInfo ClassInfo;

    ClassInfo.strName = m_strName;
    ClassInfo.strComment = m_strComment;
    ClassInfo.bIsVendor = (m_dwType == CLASS_TYPE_VENDOR) ? TRUE : FALSE;

    // now the data
    for (int i = 0; i < m_pHexEditData->cbBuffer; i++)
    {
        ClassInfo.baData.Add(m_pHexEditData->pBuffer[i]);
    }

    if (m_bCreate)
    {
        // create the class now
		dwError = m_pClassInfoArray->AddClass(m_strServer, ClassInfo);
        if (dwError != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(dwError);
            return;
        }
    }
    else
    {
        if (m_bDirty)
        {
            // we are modifing a class and something has changed.  Update now.
            BEGIN_WAIT_CURSOR;

			dwError = m_pClassInfoArray->ModifyClass(m_strServer, ClassInfo);
            if (dwError != ERROR_SUCCESS)
            {
		        DhcpMessageBox(dwError);

                GetDlgItem(IDC_VALUENAME)->SetFocus();
                return;
            }

            END_WAIT_CURSOR;
        }
    }

	CBaseDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcpcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        dhcpcomp.cpp
                This file contains the derived implementations from CComponent
                and CComponentData for the DHCP admin snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dhcpcomp.h"
#include "croot.h"
#include "server.h"
#include "servbrow.h"

#include <util.h>       // for InitWatermarkInfo

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DHCPSNAP_HELP_FILE_NAME   "dhcpsnap.chm"

LARGE_INTEGER gliDhcpsnapVersion;
CAuthServerList g_AuthServerList;

WATERMARKINFO g_WatermarkInfoServer = {0};
WATERMARKINFO g_WatermarkInfoScope = {0};

UINT aColumns[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{
        {IDS_ROOT_NAME,           IDS_STATUS,       0,                  0,          0,           0,               0},
        {IDS_DHCPSERVER_NAME,     IDS_STATUS,       IDS_DESCRIPTION,    0,          0,           0,               0},
        {IDS_BOOT_IMAGE,          IDS_FILE_NAME,    IDS_FILE_SERVER,    0,          0,           0,               0},
        {IDS_SUPERSCOPE_NAME,     IDS_STATUS,       IDS_DESCRIPTION,    0,          0,           0,               0},
        {IDS_SCOPE_NAME,          0,                0,                  0,          0,           0,               0},
        {IDS_SCOPE_NAME,          0,                0,                  0,          0,           0,               0},
        {IDS_START_IP_ADDR,       IDS_END_IP_ADDR,  IDS_DESCRIPTION,    0,          0,           0,               0},
        {IDS_CLIENT_IP_ADDR,      IDS_NAME,         IDS_LEASE,          IDS_TYPE,   IDS_UID, IDS_COMMENT, 0},
        {IDS_CLIENT_IP_ADDR,      IDS_NAME,         IDS_LEASE_START,    IDS_LEASE,  IDS_CLIENT_ID, 0, 0},
        {IDS_RESERVATIONS_FOLDER, 0,                0,                  0,          0,           0,               0},
        {IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,           0,               0},
        {IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,           0,               0},
        {IDS_OPTION_NAME,         IDS_VENDOR,       IDS_VALUE,          IDS_CLASS,  0,           0,               0},
        {IDS_NAME,                IDS_COMMENT,      0,                  0,          0,           0,               0},
        {0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
int aColumnWidths[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{       
        {200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ROOT
        {250       ,150       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SERVER
        {175       ,175       ,175       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_BOOTP_TABLE
        {200       ,150       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SUPERSCOPE
        {150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SCOPE
        {150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_MSCOPE
        {150       ,150       ,250       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ADDRESS_POOL
        {125       ,125       ,200       ,75        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_ACTIVE_LEASES
        {125       ,125       ,200       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_MSCOPE_LEASES
        {200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_RESERVATIONS
        {175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_RESERVATION_CLIENT
        {175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SCOPE_OPTIONS
    {175       ,100       ,200       ,150       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // DHCPSNAP_SERVER_OPTIONS
    {175       ,200       ,200       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}  // DHCPSNAP_CLASSID_HOLDER
};

// array to hold all of the possible toolbar buttons
MMCBUTTON g_SnapinButtons[] =
{
 { TOOLBAR_IDX_ADD_SERVER,        IDS_ADD_SERVER,                TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_REFRESH,           IDS_REFRESH,                   TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_CREATE_SCOPE,      IDS_CREATE_NEW_SCOPE,          TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_CREATE_SUPERSCOPE, IDS_CREATE_NEW_SUPERSCOPE,     TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_DEACTIVATE,        IDS_DEACTIVATE,                TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ACTIVATE,          IDS_ACTIVATE,                  TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_BOOTP,         IDS_CREATE_NEW_BOOT_IMAGE,     TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_RESERVATION,   IDS_CREATE_NEW_RESERVATION,    TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_ADD_EXCLUSION,     IDS_CREATE_NEW_EXCLUSION,      TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_GLOBAL,     IDS_CREATE_OPTION_GLOBAL,      TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_SCOPE,      IDS_CREATE_OPTION_SCOPE,       TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
 { TOOLBAR_IDX_OPTION_RESERVATION,IDS_CREATE_OPTION_RESERVATION, TBSTATE_HIDDEN, TBSTYLE_BUTTON, NULL, NULL },
};

// array to hold resource IDs for the toolbar button text
int g_SnapinButtonStrings[TOOLBAR_IDX_MAX][2] =
{
    {IDS_TB_TEXT_ADD_SERVER,         IDS_TB_TOOLTIP_ADD_SERVER},         // TOOLBAR_IDX_ADD_SERVER
    {IDS_TB_TEXT_REFRESH,            IDS_TB_TOOLTIP_REFRESH},            // TOOLBAR_IDX_REFRESH
    {IDS_TB_TEXT_CREATE_SCOPE,       IDS_TB_TOOLTIP_CREATE_SCOPE},       // TOOLBAR_IDX_CREATE_SCOPE
    {IDS_TB_TEXT_CREATE_SUPERSCOPE,  IDS_TB_TOOLTIP_CREATE_SUPERSCOPE},  // TOOLBAR_IDX_CREATE_SUPERSCOPE
    {IDS_TB_TEXT_DEACTIVATE,         IDS_TB_TOOLTIP_DEACTIVATE},         // TOOLBAR_IDX_DEACTIVATE
    {IDS_TB_TEXT_ACTIVATE,           IDS_TB_TOOLTIP_ACTIVATE},           // TOOLBAR_IDX_ACTIVATE
    {IDS_TB_TEXT_ADD_BOOTP,          IDS_TB_TOOLTIP_ADD_BOOTP},          // TOOLBAR_IDX_ADD_BOOTP
    {IDS_TB_TEXT_ADD_RESERVATION,    IDS_TB_TOOLTIP_ADD_RESERVATION},    // TOOLBAR_IDX_ADD_RESERVATION
    {IDS_TB_TEXT_ADD_EXCLUSION,      IDS_TB_TOOLTIP_ADD_EXCLUSION},      // TOOLBAR_IDX_ADD_EXCLUSION
    {IDS_TB_TEXT_OPTION_GLOBAL,      IDS_TB_TOOLTIP_OPTION_GLOBAL},      // TOOLBAR_IDX_OPTION_GLOBAL
    {IDS_TB_TEXT_OPTION_SCOPE,       IDS_TB_TOOLTIP_OPTION_SCOPE},       // TOOLBAR_IDX_OPTION_SCOPE
    {IDS_TB_TEXT_OPTION_RESERVATION, IDS_TB_TOOLTIP_OPTION_RESERVATION}, // TOOLBAR_IDX_OPTION_RESERVATION
};

#define HI HIDDEN
#define EN ENABLED

// default states for the toolbar buttons (only scope pane items have toolbar buttons)
MMC_BUTTON_STATE g_SnapinButtonStates[DHCPSNAP_NODETYPE_MAX][TOOLBAR_IDX_MAX] =
{
        {EN, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
        {HI, HI, EN, EN, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SERVER
        {HI, HI, HI, HI, HI, HI, EN, HI, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_TABLE
        {HI, HI, EN, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SUPERSCOPE
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SCOPE
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE
        {HI, HI, HI, HI, HI, HI, HI, HI, EN, HI, HI, HI}, // DHCPSNAP_ADDRESS_POOL
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASES
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE_LEASES
        {HI, HI, HI, HI, HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_RESERVATIONS
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, EN}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SCOPE_OPTIONS
        {HI, HI, HI, HI, HI, HI, HI, HI, HI, EN, HI, HI}, // DHCPSNAP_SERVER_OPTIONS
    {HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_CLASSID_HOLDER
};

MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
        MMC_VERB_OPEN,
    MMC_VERB_COPY,
        MMC_VERB_PASTE,
        MMC_VERB_DELETE,
        MMC_VERB_PROPERTIES,
        MMC_VERB_RENAME,
        MMC_VERB_REFRESH,
        MMC_VERB_PRINT
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStates[DHCPSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
        {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SERVER
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_BOOTP_TABLE
        {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SUPERSCOPE
        {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_SCOPE
        {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_MSCOPE
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ADDRESS_POOL
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ACTIVE_LEASES
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_MSCOPE_LEASES
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_RESERVATIONS
        {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SCOPE_OPTIONS
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_SERVER_OPTIONS
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_CLASSID_HOLDER
        {HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_ACTIVE_LEASE
        {HI, HI, HI, HI, HI, HI, EN, HI}, // DHCPSNAP_ALLOCATION_RANGE
        {HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_EXCLUSION_RANGE
        {HI, HI, HI, EN, HI, HI, EN, HI}, // DHCPSNAP_BOOTP_ENTRY
    {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_OPTION_ITEM
    {HI, HI, HI, EN, EN, HI, EN, HI}, // DHCPSNAP_CLASSID
    {HI, HI, HI, EN, HI, HI, EN, HI}  // DHCPSNAP_MCAST_LEASE
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[DHCPSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ROOT
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SERVER
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_TABLE
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SUPERSCOPE
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_SCOPE
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_ADDRESS_POOL
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASES
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_MSCOPE_LEASES
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_RESERVATIONS
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_RESERVATION_CLIENT
    {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SCOPE_OPTIONS
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_SERVER_OPTIONS
        {HI, HI, HI, EN, HI, HI, HI, HI}, // DHCPSNAP_CLASSID_HOLDER
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ACTIVE_LEASE
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_ALLOCATION_RANGE
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_EXCLUSION_RANGE
        {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_BOOTP_ENTRY
    {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_OPTION_ITEM
    {HI, HI, HI, HI, HI, HI, HI, HI}, // DHCPSNAP_CLASSID
    {HI, HI, HI, HI, HI, HI, HI, HI}  // DHCPSNAP_MCAST_LEASE
};

// Help ID array for help on scope items
DWORD g_dwMMCHelp[DHCPSNAP_NODETYPE_MAX] =
{
        DHCPSNAP_HELP_ROOT,                 // DHCPSNAP_ROOT
        DHCPSNAP_HELP_SERVER,               // DHCPSNAP_SERVER
        DHCPSNAP_HELP_BOOTP_TABLE,          // DHCPSNAP_BOOTP_TABLE
        DHCPSNAP_HELP_SUPERSCOPE,           // DHCPSNAP_SUPERSCOPE
        DHCPSNAP_HELP_SCOPE,                // DHCPSNAP_SCOPE
        DHCPSNAP_HELP_MSCOPE,               // DHCPSNAP_MSCOPE
        DHCPSNAP_HELP_ADDRESS_POOL,         // DHCPSNAP_ADDRESS_POOL
        DHCPSNAP_HELP_ACTIVE_LEASES,        // DHCPSNAP_ACTIVE_LEASES
        DHCPSNAP_HELP_ACTIVE_LEASES,        // DHCPSNAP_MSCOPE_LEASES
        DHCPSNAP_HELP_RESERVATIONS,         // DHCPSNAP_RESERVATIONS
        DHCPSNAP_HELP_RESERVATION_CLIENT,   // DHCPSNAP_RESERVATION_CLIENT
    DHCPSNAP_HELP_SCOPE_OPTIONS,        // DHCPSNAP_SCOPE_OPTIONS
        DHCPSNAP_HELP_GLOBAL_OPTIONS,       // DHCPSNAP_SERVER_OPTIONS
        DHCPSNAP_HELP_CLASSID_HOLDER,       // DHCPSNAP_CLASSID_HOLDER
        DHCPSNAP_HELP_ACTIVE_LEASE,         // DHCPSNAP_ACTIVE_LEASE
        DHCPSNAP_HELP_ALLOCATION_RANGE,     // DHCPSNAP_ALLOCATION_RANGE
        DHCPSNAP_HELP_EXCLUSION_RANGE,      // DHCPSNAP_EXCLUSION_RANGE
        DHCPSNAP_HELP_BOOTP_ENTRY,          // DHCPSNAP_BOOTP_ENTRY
    DHCPSNAP_HELP_OPTION_ITEM,          // DHCPSNAP_OPTION_ITEM
    DHCPSNAP_HELP_CLASSID,              // DHCPSNAP_CLASSID
    DHCPSNAP_HELP_MCAST_LEASE           // DHCPSNAP_MCAST_LEASE
};

// help mapper for dialogs and property pages
struct ContextHelpMap
{
    UINT            uID;
    const DWORD *   pdwMap;
};

ContextHelpMap g_uContextHelp[DHCPSNAP_NUM_HELP_MAPS] =
{
    {IDD_ADD_SERVER,                    g_aHelpIDs_IDD_ADD_SERVER},
    {IDD_ADD_TO_SUPERSCOPE,             g_aHelpIDs_IDD_ADD_TO_SUPERSCOPE},
    {IDD_BINARY_EDITOR,                 g_aHelpIDs_IDD_BINARY_EDITOR},
    {IDD_BOOTP_NEW,                     g_aHelpIDs_IDD_BOOTP_NEW},
    {IDD_BROWSE_SERVERS,                g_aHelpIDs_IDD_BROWSE_SERVERS},
    {IDD_CLASSES,                       g_aHelpIDs_IDD_CLASSES},
    {IDD_CLASSID_NEW,                   g_aHelpIDs_IDD_CLASSID_NEW},
    {IDD_CREDENTIALS,                   g_aHelpIDs_IDD_CREDENTIALS},
    {IDD_DATA_ENTRY_BINARY,             g_aHelpIDs_IDD_DATA_ENTRY_BINARY},
    {IDD_DATA_ENTRY_BINARY_ARRAY,       g_aHelpIDs_IDD_DATA_ENTRY_BINARY_ARRAY},
    {IDD_DATA_ENTRY_DWORD,              g_aHelpIDs_IDD_DATA_ENTRY_DWORD},
    {IDD_DATA_ENTRY_IPADDRESS,          g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS},
    {IDD_DATA_ENTRY_IPADDRESS_ARRAY,    g_aHelpIDs_IDD_DATA_ENTRY_IPADDRESS_ARRAY},
    {IDD_DATA_ENTRY_NONE,               NULL},
    {IDD_DATA_ENTRY_STRING,             g_aHelpIDs_IDD_DATA_ENTRY_STRING},
    {IDD_DATA_ENTRY_ROUTE_ARRAY,        g_aHelpIDs_IDD_DATA_ENTRY_ROUTE_ARRAY},    
    {IDD_DEFAULT_VALUE,                 g_aHelpIDs_IDD_DEFAULT_VALUE},
    {IDD_DEFINE_PARAM,                  g_aHelpIDs_IDD_DEFINE_PARAM},
    {IDD_EXCLUSION_NEW,                 g_aHelpIDs_IDD_EXCLUSION_NEW},
    {IDD_GET_SERVER,                    g_aHelpIDs_IDD_GET_SERVER},
    {IDD_GET_SERVER_CONFIRM,            g_aHelpIDs_IDD_GET_SERVER_CONFIRM},
    {IDD_IP_ARRAY_EDIT,                 g_aHelpIDs_IDD_IP_ARRAY_EDIT},
    {IDD_RECONCILIATION,                g_aHelpIDs_IDD_RECONCILIATION},
    {IDD_RESERVATION_NEW,               g_aHelpIDs_IDD_RESERVATION_NEW},
    {IDD_SERVER_BINDINGS,               g_aHelpIDs_IDD_SERVER_BINDINGS},
    {IDD_STATS_NARROW,                  NULL},
    {IDP_BOOTP_GENERAL,                 g_aHelpIDs_IDP_BOOTP_GENERAL},
    {IDP_DNS_INFORMATION,               g_aHelpIDs_IDP_DNS_INFORMATION},
    {IDP_MSCOPE_GENERAL,                g_aHelpIDs_IDP_MSCOPE_GENERAL},
    {IDP_MSCOPE_LIFETIME,               g_aHelpIDs_IDP_MSCOPE_LIFETIME},
    {IDP_OPTION_ADVANCED,               g_aHelpIDs_IDP_OPTION_ADVANCED},
    {IDP_OPTION_BASIC,                  g_aHelpIDs_IDP_OPTION_BASIC},
    {IDP_RESERVED_CLIENT_GENERAL,       g_aHelpIDs_IDP_RESERVED_CLIENT_GENERAL},
    {IDP_SCOPE_ADVANCED,                g_aHelpIDs_IDP_SCOPE_ADVANCED},
    {IDP_SCOPE_GENERAL,                 g_aHelpIDs_IDP_SCOPE_GENERAL},
    {IDP_SERVER_ADVANCED,               g_aHelpIDs_IDP_SERVER_ADVANCED},
    {IDP_SERVER_GENERAL,                g_aHelpIDs_IDP_SERVER_GENERAL},
    {IDP_SUPERSCOPE_GENERAL,            g_aHelpIDs_IDP_SUPERSCOPE_GENERAL},
    {IDD_ADD_ROUTE_DIALOG,              g_aHelpIDs_IDD_ADD_ROUTE_DIALOG},
    {IDD_ROUTE_ARRAY_EDIT,              g_aHelpIDs_IDD_ROUTE_ARRAY_EDIT},
    {IDD_STRING_ARRAY_EDIT,             g_aHelpIDs_IDD_STRING_ARRAY_EDIT},
};

CDhcpContextHelpMap     g_dhcpContextHelpMap;

DWORD * DhcpGetHelpMap(UINT uID) 
{
    DWORD * pdwMap = NULL;
    g_dhcpContextHelpMap.Lookup(uID, pdwMap);
    return pdwMap;
}

UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,    ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN},
    {IDI_ICON02,        ICON_IDX_ACTIVE_LEASES_LEAF},
    {IDI_ICON03,        ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED},
    {IDI_ICON04,        ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY},
    {IDI_ICON05,        ICON_IDX_ACTIVE_LEASES_LEAF_BUSY},
    {IDI_ICON06,        ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY},
    {IDI_ICON07,        ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON08,    ICON_IDX_ACTIVE_LEASES_LEAF_LOST_CONNECTION},
    {IDI_ICON09,        ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON10,        ICON_IDX_ADDR_POOL_FOLDER_OPEN},
    {IDI_ICON11,        ICON_IDX_ADDR_POOL_LEAF},
    {IDI_ICON12,        ICON_IDX_ADDR_POOL_FOLDER_CLOSED},
    {IDI_ICON13,        ICON_IDX_ADDR_POOL_FOLDER_OPEN_BUSY},
    {IDI_ICON14,        ICON_IDX_ADDR_POOL_LEAF_BUSY},
    {IDI_ICON15,        ICON_IDX_ADDR_POOL_FOLDER_CLOSED_BUSY},
    {IDI_ICON16,        ICON_IDX_ADDR_POOL_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON17,        ICON_IDX_ADDR_POOL_LEAF_LOST_CONNECTION},
    {IDI_ICON18,        ICON_IDX_ADDR_POOL_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON19,        ICON_IDX_ALLOCATION_RANGE},
    {IDI_ICON20,        ICON_IDX_BOOTP_ENTRY},
        {IDI_ICON21,    ICON_IDX_BOOTP_TABLE_CLOSED},
        {IDI_ICON22,    ICON_IDX_BOOTP_TABLE_OPEN},
        {IDI_ICON87,    ICON_IDX_BOOTP_TABLE_OPEN_LOST_CONNECTION},
        {IDI_ICON88,    ICON_IDX_BOOTP_TABLE_OPEN_BUSY},
        {IDI_ICON89,    ICON_IDX_BOOTP_TABLE_CLOSED_LOST_CONNECTION},
        {IDI_ICON90,    ICON_IDX_BOOTP_TABLE_CLOSED_BUSY},
    {IDI_ICON23,        ICON_IDX_CLIENT},
    {IDI_ICON24,        ICON_IDX_CLIENT_DNS_REGISTERING},
    {IDI_ICON25,        ICON_IDX_CLIENT_EXPIRED},
    {IDI_ICON26,        ICON_IDX_CLIENT_RAS},
    {IDI_ICON27,        ICON_IDX_CLIENT_OPTION_FOLDER_OPEN},
    {IDI_ICON28,        ICON_IDX_CLIENT_OPTION_LEAF},
    {IDI_ICON29,        ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED},
    {IDI_ICON30,        ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON31,        ICON_IDX_CLIENT_OPTION_LEAF_BUSY},
    {IDI_ICON32,        ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON33,        ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON34,        ICON_IDX_CLIENT_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON35,        ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON36,        ICON_IDX_EXCLUSION_RANGE},
    {IDI_ICON37,        ICON_IDX_FOLDER_CLOSED},
    {IDI_ICON38,        ICON_IDX_FOLDER_OPEN},
    {IDI_ICON39,        ICON_IDX_RES_CLIENT},
    {IDI_ICON40,        ICON_IDX_RES_CLIENT_BUSY},
    {IDI_ICON41,    ICON_IDX_RES_CLIENT_LOST_CONNECTION},
    {IDI_ICON42,    ICON_IDX_RESERVATIONS_FOLDER_OPEN},
    {IDI_ICON43,        ICON_IDX_RESERVATIONS_FOLDER_CLOSED},
    {IDI_ICON44,        ICON_IDX_RESERVATIONS_FOLDER_OPEN_BUSY},
    {IDI_ICON45,        ICON_IDX_RESERVATIONS_FOLDER_CLOSED_BUSY},
    {IDI_ICON46,        ICON_IDX_RESERVATIONS_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON47,        ICON_IDX_RESERVATIONS_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON48,        ICON_IDX_SCOPE_OPTION_FOLDER_OPEN},
    {IDI_ICON49,        ICON_IDX_SCOPE_OPTION_LEAF},
    {IDI_ICON50,        ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED},
    {IDI_ICON51,        ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON52,        ICON_IDX_SCOPE_OPTION_LEAF_BUSY},
    {IDI_ICON53,        ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON54,        ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON55,        ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON56,        ICON_IDX_SCOPE_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON57,        ICON_IDX_SERVER},
    {IDI_ICON58,        ICON_IDX_SERVER_WARNING},
    {IDI_ICON59,        ICON_IDX_SERVER_BUSY},
    {IDI_ICON60,        ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON61,        ICON_IDX_SERVER_GROUP},
    {IDI_ICON62,        ICON_IDX_SERVER_ROGUE},
    {IDI_ICON63,        ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON64,        ICON_IDX_SERVER_NO_ACCESS},
    {IDI_ICON65,        ICON_IDX_SERVER_ALERT},
    {IDI_ICON66,        ICON_IDX_SERVER_OPTION_FOLDER_OPEN},
    {IDI_ICON67,        ICON_IDX_SERVER_OPTION_LEAF},
    {IDI_ICON68,        ICON_IDX_SERVER_OPTION_FOLDER_CLOSED},
    {IDI_ICON69,        ICON_IDX_SERVER_OPTION_FOLDER_OPEN_BUSY},
    {IDI_ICON70,        ICON_IDX_SERVER_OPTION_LEAF_BUSY},
    {IDI_ICON71,        ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_BUSY},
    {IDI_ICON72,        ICON_IDX_SERVER_OPTION_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON73,        ICON_IDX_SERVER_OPTION_LEAF_LOST_CONNECTION},
    {IDI_ICON74,        ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON75,        ICON_IDX_SCOPE_FOLDER_OPEN},
    {IDI_ICON91,        ICON_IDX_SCOPE_FOLDER_OPEN_BUSY},
        {IDI_ICON92,    ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY},                                     
    {IDI_ICON76,        ICON_IDX_SCOPE_FOLDER_OPEN_WARNING},
    {IDI_ICON77,    ICON_IDX_SCOPE_FOLDER_CLOSED_WARNING},
    {IDI_ICON78,        ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON79,        ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON80,        ICON_IDX_SCOPE_FOLDER_OPEN_ALERT},
    {IDI_ICON81,        ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN},
    {IDI_ICON82,        ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED},
    {IDI_ICON83,        ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON84,        ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON85,        ICON_IDX_SCOPE_FOLDER_CLOSED},
    {IDI_ICON86,        ICON_IDX_SCOPE_FOLDER_CLOSED_ALERT},
        {IDI_DHCP_SNAPIN, ICON_IDX_APPLICATION},
    {0, 0}
};

/*!--------------------------------------------------------------------------
        FilterOption
                Filters returns whether or not to filter out the given option.
                Some options we don't want the user to see.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
FilterOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Filter out subnet mask, lease duration,
    // T1, and T2
    //
    return (id == 1  ||  // Subnet mask
                        id == 51 ||  // Client Lease Time
                        id == 58 ||  // Time between addr assignment  to RENEWING state
                        id == 59 ||  // Time from addr assignment to REBINDING state
                        id == 81);   // Client DNS name registration
}

/*!--------------------------------------------------------------------------
        FilterUserClassOption
                Filters returns whether or not to filter out the given option for
        a user class. Some options we don't want the user to see.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
FilterUserClassOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Filter out subnet mask, 
    // T1, and T2
    //
    return (id == 1  ||  // Subnet mask
                        id == 58 ||  // Time between addr assignment  to RENEWING state
                        id == 59 ||  // Time from addr assignment to REBINDING state
                        id == 81);   // Client DNS name registration
}


/*!--------------------------------------------------------------------------
        IsBasicOption
                Returns whether the given option is what we've defined as a 
                basic option.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsBasicOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Basic Options are:
        //      Router
        //      DNS Server
        //      Domain Name
        //      WINS/NBNS Servers
        //      WINS/NBT Node Type
    //
    return (id == 3  || 
                        id == 6  || 
                        id == 15 || 
                        id == 44 || 
                        id == 46);
}

/*!--------------------------------------------------------------------------
        IsAdvancedOption
                Returns whether the given option is what we've defined as an
                advanced option.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsAdvancedOption
(
    DHCP_OPTION_ID id
)
{
    //
    // All non-basic and non-custom options are advanced.
    //
    return (id < 128 && !IsBasicOption(id)); 
}

/*!--------------------------------------------------------------------------
        IsCustomOption
                Returns whether the given option is a user defined option.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
IsCustomOption
(
    DHCP_OPTION_ID id
)
{
    //
    // Custom options are anything with an id > 128
        //
    return (id > 128);
}

/*!--------------------------------------------------------------------------
        GetSystemMessage
                Use FormatMessage() to get a system error message
        Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
GetSystemMessage 
(
    UINT        nId,
    TCHAR *     chBuffer,
    int         cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  dhcp server error messages.
    //

    if ( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibraryEx( _T("netmsg.dll"), NULL,  LOAD_LIBRARY_AS_DATAFILE);
    }
    else 
        if ( nId >= 20000 && nId <= 20099 )
    {
                // DHCP Server error 
        hdll = LoadLibraryEx( _T("dhcpsapi.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
    }
        else
        if (nId >= 0x5000 && nId < 0x50FF)
        {
                // It's an ADSI error.  
                hdll = LoadLibraryEx( _T("activeds.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
                nId |= 0x80000000;
        }
    else 
        if( nId >= 0x40000000L )
    {
        hdll = LoadLibraryEx( _T("ntdll.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
    }

    if ( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if ( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? 0 : ::GetLastError() ;
}

/*!--------------------------------------------------------------------------
        LoadMessage
                Loads the error message from the correct DLL.
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT        nIdPrompt,
    TCHAR *     chMsg,
    int         nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_DHCP_DOWN;
    }
    else if (nIdPrompt == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        nIdPrompt = IDS_ERR_RPC_NO_ENTRY;      
    }

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if ( (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MESG_MAX) || 
                 (nIdPrompt >= WSABASEERR && nIdPrompt < WSABASEERR + 2000)
       )
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize ) != 0 ;
    }
    else
        {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, sizeof(chBuff)/sizeof(TCHAR) ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}

/*!--------------------------------------------------------------------------
        DhcpMessageBox
                Puts up a message box with the corresponding error text.
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
DhcpMessageBox 
(
    DWORD                       dwIdPrompt,
    UINT                        nType,
    const TCHAR *       pszSuffixString,
    UINT                        nHelpContext 
)
{
    TCHAR chMesg [4000] ;
    BOOL bOk ;

    UINT        nIdPrompt = (UINT) dwIdPrompt;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
        DhcpMessageBoxEx
                Puts up a message box with the corresponding error text.
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
DhcpMessageBoxEx
(
    DWORD       dwIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000];
    CString     strMessage;
    BOOL        bOk;

    UINT        nIdPrompt = (UINT) dwIdPrompt;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}

/*---------------------------------------------------------------------------
        Class CDhcpComponent implementation
 ---------------------------------------------------------------------------*/
CDhcpComponent::CDhcpComponent()
{
        m_pbmpToolbar = NULL;
        InitCommonControls();
}

CDhcpComponent::~CDhcpComponent()
{
    if (m_pbmpToolbar)
    {
        delete m_pbmpToolbar;
        m_pbmpToolbar = NULL;
    }
}

STDMETHODIMP CDhcpComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    
    // Set the images
    HICON       hIcon;
    HRESULT     hr;
    LPOLESTR    pszGuid = NULL;
    long        lViewOptions = 0;
    CLSID       clsid;

    CORg (GetResultViewType(cookie, &pszGuid, &lViewOptions));
    CLSIDFromString(pszGuid, &clsid);
    CoTaskMemFree( pszGuid );

    // if the result pane is not the message view then add the icons
    if (clsid != CLSID_MessageView)
    {
        for (int i = 0; i < ICON_IDX_MAX; i++)
        {
            hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
            {
                // call mmc
                hr = m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
            }
        }
    }
    
Error:
        return S_OK;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::QueryDataObject
                For multiple select we need to add things to the data object.....
        In order to do this we need to call into the result handler for 
        the node
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponent::QueryDataObject
(
    MMC_COOKIE          cookie, 
    DATA_OBJECT_TYPES   type,
    LPDATAOBJECT*       ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    SPITFSNode spRootNode;

    // this is a special case for multiple select.  We need to build a list
    // of GUIDs and the code to do this is in the handler...
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        SPITFSNode spNode;
        SPITFSResultHandler spResultHandler;

        CORg (GetSelectedNode(&spNode));
        CORg (spNode->GetResultHandler(&spResultHandler));

        spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
    }
    else
    if (cookie == MMC_WINDOW_COOKIE)
    {
        // this cookie needs the text for the static root node, so build the DO with
        // the root node cookie
        m_spNodeMgr->GetRootNode(&spRootNode);
        CORg (m_spComponentData->QueryDataObject((MMC_COOKIE) spRootNode->GetData(TFS_DATA_COOKIE), type, ppDataObject));
    }
    else
    {
        // Delegate it to the IComponentData
        Assert(m_spComponentData != NULL);
        CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::SetControlbar
                -
        Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpComponent::SetControlbar
(
        LPCONTROLBAR    pControlbar
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    SPIToolbar  spToolbar;

    COM_PROTECT_TRY
    {
        if (pControlbar)
        {
            // Create the Toolbar
            GetToolbar(&spToolbar);

            if (!spToolbar)
            {
                        CORg(pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&spToolbar)));
                        
                if (!spToolbar)
                    goto Error;

                SetToolbar(spToolbar);

                        // Add the bitmap
                m_pbmpToolbar = new CBitmap;
                        m_pbmpToolbar->LoadBitmap(IDB_TOOLBAR);
                        hr = spToolbar->AddBitmap(TOOLBAR_IDX_MAX, *m_pbmpToolbar, 16, 16, RGB(192, 192, 192));
                        ASSERT(SUCCEEDED(hr));

                        // Add the buttons to the toolbar
                        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
                {
                    CString strText, strTooltip;
                
                    strText.LoadString(g_SnapinButtonStrings[i][0]);
                    strTooltip.LoadString(g_SnapinButtonStrings[i][1]);

                    g_SnapinButtons[i].lpButtonText = (LPOLESTR) ((LPCTSTR) strText);
                    g_SnapinButtons[i].lpTooltipText = (LPOLESTR) ((LPCTSTR) strTooltip);

                    hr = spToolbar->InsertButton(i, &g_SnapinButtons[i]);
                            ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }
    COM_PROTECT_CATCH

    // store the control bar away for future use
Error:
    m_spControlbar.Set(pControlbar);

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::ControlbarNotify
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponent::ControlbarNotify
(
        MMC_NOTIFY_TYPE event, 
        LPARAM                  arg, 
        LPARAM                  param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
        SPINTERNAL                  spInternal;
        SPITFSNode          spNode;
    MMC_COOKIE          cookie;
    LPDATAOBJECT        pDataObject;
    SPIDataObject       spDataObject;
    DHCPTOOLBARNOTIFY   dhcpToolbarNotify;
        SPIControlBar       spControlbar;
    SPIToolbar          spToolbar;
    SPITFSNodeHandler   spNodeHandler;
    SPITFSResultHandler spResultHandler;
    BOOL                bScope;
    BOOL                bSelect;

    COM_PROTECT_TRY
    {
        CORg(GetControlbar(&spControlbar));
        Assert(spControlbar != NULL);

        CORg(GetToolbar(&spToolbar));
        Assert(spToolbar != NULL);

        // set the controlbar and toolbar pointers in the notify struct
        dhcpToolbarNotify.pControlbar = spControlbar;
        dhcpToolbarNotify.pToolbar = spToolbar;
        
        switch (event)
        {
            case MMCN_SELECT:
                // extract the node information from the data object
                bScope = LOWORD(arg);
                bSelect = HIWORD(arg);
    
                if (!bScope)
                {
                    Assert(param);
                    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
                    if (pDataObject == NULL)
                        return hr;

                    if ( IS_SPECIAL_DATAOBJECT(pDataObject) ||
                         IsMMCMultiSelectDataObject(pDataObject) )
                    {
                        // CODEWORK:  Do we need to do anything special to the toolbar
                        // during multiselect?  Disable our toolbar buttons?
                        GetSelectedNode(&spNode);
                    }
                    else
                    {
                        CORg(ExtractNodeFromDataObject(m_spNodeMgr,
                                                                                   m_spTFSComponentData->GetCoClassID(),
                                                                                   pDataObject, 
                                                       FALSE,
                                                                                   &spNode,
                                                       NULL, 
                                                       &spInternal));

                        if (spInternal->m_type == CCT_RESULT)
                        {
                            // a result item was selected
                            cookie = spNode->GetData(TFS_DATA_COOKIE);
                        }
                        else
                        {
                            // a scope item in the result pane was selected
                            cookie = NULL;
                        }
                    }
                    
                    if (spNode)
                    {
                        CORg( spNode->GetResultHandler(&spResultHandler) );

                        dhcpToolbarNotify.event = event;
                        dhcpToolbarNotify.id = param;
                        dhcpToolbarNotify.bSelect = bSelect;

                        if (spResultHandler)
                                        CORg( spResultHandler->UserResultNotify(spNode, DHCP_MSG_CONTROLBAR_NOTIFY, (LPARAM) &dhcpToolbarNotify) );
                    }
                }
                else
                {
                    dhcpToolbarNotify.cookie = 0;
                    dhcpToolbarNotify.event = event;
                    dhcpToolbarNotify.id = 0;
                    dhcpToolbarNotify.bSelect = bSelect;

                    // check to see if an item is being deselected
                    Assert(param);
                    pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
                    if (pDataObject == NULL)
                        return hr;

                    CORg(ExtractNodeFromDataObject(m_spNodeMgr,
                                                                               m_spTFSComponentData->GetCoClassID(),
                                                                               pDataObject, 
                                                   FALSE,
                                                                               &spNode,
                                                   NULL, 
                                                   &spInternal));

                    CORg( spNode->GetHandler(&spNodeHandler) );
        
            
                    if (spNodeHandler)
                                    CORg( spNodeHandler->UserNotify(spNode, DHCP_MSG_CONTROLBAR_NOTIFY, (LPARAM) &dhcpToolbarNotify) );
                }
                break;

            case MMCN_BTN_CLICK:
                Assert(arg);
                pDataObject = reinterpret_cast<LPDATAOBJECT>(arg);
                if (pDataObject == NULL)
                    return hr;

                if ( IS_SPECIAL_DATAOBJECT(pDataObject) )
                {
                    // get a data object for the selected node.
                    GetSelectedNode(&spNode);

                    CORg(QueryDataObject((MMC_COOKIE) spNode->GetData(TFS_DATA_COOKIE), CCT_SCOPE, &spDataObject));
                    spNode.Release();                

                    pDataObject = spDataObject;
                }

                CORg(ExtractNodeFromDataObject(m_spNodeMgr,
                                                                           m_spTFSComponentData->GetCoClassID(),
                                                                           pDataObject, 
                                               FALSE,
                                                                           &spNode,
                                               NULL, 
                                               &spInternal));

                if (spInternal)
                {
                    switch (spInternal->m_type)
                    {
                        case CCT_RESULT:
                            cookie = spNode->GetData(TFS_DATA_COOKIE);
                            CORg( spNode->GetResultHandler(&spResultHandler) );
                                    
                            dhcpToolbarNotify.cookie = cookie;
                            dhcpToolbarNotify.event = event;
                            dhcpToolbarNotify.id = param;
                            dhcpToolbarNotify.bSelect = TRUE;

                            if (spResultHandler)
                                            CORg( spResultHandler->UserResultNotify(spNode, 
                                                                        DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                                        (LPARAM) &dhcpToolbarNotify) );

                            break;

                        case CCT_SCOPE:
                            CORg( spNode->GetHandler(&spNodeHandler) );
                                    
                            dhcpToolbarNotify.cookie = 0;
                            dhcpToolbarNotify.event = event;
                            dhcpToolbarNotify.id = param;
                            dhcpToolbarNotify.bSelect = TRUE;

                            if (spNodeHandler)
                                            CORg( spNodeHandler->UserNotify(spNode, 
                                                                DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                                (LPARAM) &dhcpToolbarNotify) );
                            break;
    
                        default:
                            Assert(FALSE);
                            break;
                    }
                }
                break;

            case MMCN_DESELECT_ALL:
                // what are we supposed to do here???
                break;

            default:
                Panic1("CDhcpComponent::ControlbarNotify - Unknown event %d", event);
                break;

        }
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnSnapinHelp
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponent::OnSnapinHelp
(
        LPDATAOBJECT    pDataObject,
        LPARAM                  arg, 
        LPARAM                  param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = hrOK;

    HtmlHelpA(NULL, DHCPSNAP_HELP_FILE_NAME, HH_DISPLAY_TOPIC, 0);

        return hr;
}

/*---------------------------------------------------------------------------
        Class CDhcpComponentData implementation
 ---------------------------------------------------------------------------*/
CDhcpComponentData::CDhcpComponentData()
{
    gliDhcpsnapVersion.LowPart = DHCPSNAP_MINOR_VERSION;
        gliDhcpsnapVersion.HighPart = DHCPSNAP_MAJOR_VERSION;

    // initialize our global help map
    for (int i = 0; i < DHCPSNAP_NUM_HELP_MAPS; i++)
    {
        g_dhcpContextHelpMap.SetAt(g_uContextHelp[i].uID, (LPDWORD) g_uContextHelp[i].pdwMap);
    }
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnInitialize
                -
        Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HICON   hIcon;

    // thread deletes itself
    CStandaloneAuthServerWorker * pWorker = new CStandaloneAuthServerWorker();
    pWorker->CreateThread();

    // initialize icon images with MMC
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnDestroy
                -
        Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CDhcpComponentData::OnDestroy()
{
        m_spNodeMgr.Release();

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnInitializeNodeMgr
                -
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnInitializeNodeMgr
(
        ITFSComponentData *     pTFSCompData, 
        ITFSNodeMgr *           pNodeMgr
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // For now create a new node handler for each new node,
        // this is rather bogus as it can get expensive.  We can
        // consider creating only a single node handler for each
        // node type.
        CDhcpRootHandler *      pHandler = NULL;
        SPITFSNodeHandler       spHandler;
        SPITFSNode                      spNode;
        HRESULT                         hr = hrOK;

        try
        {
                pHandler = new CDhcpRootHandler(pTFSCompData);

                // Do this so that it will get released correctly
                spHandler = pHandler;
        }
        catch(...)
        {
                hr = E_OUTOFMEMORY;
        }
        CORg( hr );
        
        // Create the root node for this sick puppy
        CORg( CreateContainerTFSNode(&spNode,
                                                                 &GUID_DhcpRootNodeType,
                                                                 pHandler,
                                                                 pHandler,               /* result handler */
                                                                 pNodeMgr) );

        // Need to initialize the data for the root node
        pHandler->InitializeNode(spNode);       

        CORg( pNodeMgr->SetRootNode(spNode) );
        m_spRootNode.Set(spNode);

    // setup watermark info
    if (g_WatermarkInfoServer.hHeader == NULL)
    {
        // haven't been initialized yet
        InitWatermarkInfo(AfxGetInstanceHandle(),
                          &g_WatermarkInfoServer,      
                          IDB_SRVWIZ_BANNER,        // Header ID
                          IDB_SRVWIZ_WATERMARK,     // Watermark ID
                          NULL,                     // hPalette
                          FALSE);                   // bStretch

        InitWatermarkInfo(AfxGetInstanceHandle(),
                          &g_WatermarkInfoScope,      
                          IDB_SCPWIZ_BANNER,        // Header ID
                          IDB_SCPWIZ_WATERMARK,     // Watermark ID
                          NULL,                     // hPalette
                          FALSE);                   // bStretch
    }

    pTFSCompData->SetHTMLHelpFileName(_T(DHCPSNAP_HELP_FILE_NAME));
    
        // disable taskpads by default
        pTFSCompData->SetTaskpadState(TASKPAD_ROOT_INDEX, FALSE);
    pTFSCompData->SetTaskpadState(TASKPAD_SERVER_INDEX, FALSE);


Error:  
        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnCreateComponent
                -
        Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnCreateComponent
(
        LPCOMPONENT *ppComponent
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);

        HRESULT                   hr = hrOK;
        CDhcpComponent *  pComp = NULL;

        try
        {
                pComp = new CDhcpComponent;
        }
        catch(...)
        {
                hr = E_OUTOFMEMORY;
        }

        if ( NULL != pComp )
        {
            pComp->Construct( m_spNodeMgr,
                              static_cast<IComponentData *>(this),
                              m_spTFSComponentData );
            *ppComponent = static_cast<IComponent *>(pComp);
        }
        else {
            hr = E_OUTOFMEMORY;
        }
        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::GetCoClassID
                -
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CDhcpComponentData::GetCoClassID()
{
        return &CLSID_DhcpSnapin;
}

/*!--------------------------------------------------------------------------
        CDhcpComponentData::OnCreateDataObject
                -
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpComponentData::OnCreateDataObject
(
        MMC_COOKIE                      cookie, 
        DATA_OBJECT_TYPES       type, 
        IDataObject **          ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

        CDataObject *   pObject = NULL;
        SPIDataObject   spDataObject;
        
        pObject = new CDataObject;
        spDataObject = pObject; // do this so that it gets released correctly
                                                
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

        pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                                                        reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CDhcpComponentData::GetClassID
(
        CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_DhcpSnapin;

    return hrOK;
}

STDMETHODIMP 
CDhcpComponentData::IsDirty()
{
        return m_spRootNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP 
CDhcpComponentData::Load
(
        IStream *pStm
)
{
        HRESULT         hr = hrOK;
        LARGE_INTEGER   liSavedVersion;
        CString         str;
    
        ASSERT(pStm);

    CStringArray    strArrayIp;
    CStringArray    strArrayName;
    CDWordArray     dwArrayServerOptions;
    CDWordArray     dwArrayRefreshInterval;
        CDWordArray     dwArrayColumnInfo;
    DWORD           dwFileVersion;
    CDhcpRootHandler * pRootHandler;
    DWORD           dwFlags = 0;
    int             i, j;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_VERSION, &dwFileVersion));
        if (dwFileVersion < DHCPSNAP_FILE_VERSION)
        {
            AFX_MANAGE_STATE(AfxGetStaticModuleState());
                AfxMessageBox(_T("This console file was saved with a previous version of the snapin and is not compatible.  The settings could not be restored."));
                return hr;
        }

    // Read the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(DHCPSTRM_TAG_VERSIONADMIN, &liSavedVersion));
        if (liSavedVersion.QuadPart < gliDhcpsnapVersion.QuadPart)
        {
                // File is an older version.  Warn the user and then don't
                // load anything else
                Assert(FALSE);
        }

        // Read the root node name
    CORg(xferStream.XferCString(DHCPSTRM_TAB_SNAPIN_NAME, &str));
        Assert(m_spRootNode);
        pRootHandler = GETHANDLER(CDhcpRootHandler, m_spRootNode);
        pRootHandler->SetDisplayName(str);
    
    // now read all of the server information
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_IP, &strArrayIp));
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_OPTIONS, &dwArrayServerOptions));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));

        // now load the column information
        for (i = 0; i < NUM_SCOPE_ITEMS; i++)
        {
                CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

                for (j = 0; j < MAX_COLUMNS; j++)
                {
            // mmc now saves column widths for us, but we don't want to change the
            // format of this file, so just don't set our internal struct
                        //aColumnWidths[i][j] = dwArrayColumnInfo[j];
                }

        }

    // now create the servers based on the information
    for (i = 0; i < strArrayIp.GetSize(); i++)
        {
                //
                // now create the server object
                //
                pRootHandler->AddServer((LPCWSTR) strArrayIp[i], 
                                strArrayName[i],
                                FALSE, 
                                dwArrayServerOptions[i], 
                                dwArrayRefreshInterval[i]);
        }

    // read in flags (for taskpads)
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_SNAPIN_OPTIONS, &dwFlags));

    if (!FUseTaskpadsByDefault(NULL))
        dwFlags = 0;

        // disable taskpads, the default is off
    //m_spTFSComponentData->SetTaskpadState(TASKPAD_ROOT_INDEX, dwFlags & TASKPAD_ROOT_FLAG);
    //m_spTFSComponentData->SetTaskpadState(TASKPAD_SERVER_INDEX, dwFlags & TASKPAD_SERVER_FLAG);

Error:
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CDhcpComponentData::Save
(
        IStream *pStm, 
        BOOL     fClearDirty
)
{
        HRESULT                 hr = hrOK;
    CStringArray        strArrayIp;
    CStringArray        strArrayName;
    CDWordArray         dwArrayServerOptions;
    CDWordArray         dwArrayRefreshInterval;
        CDWordArray             dwArrayColumnInfo;
        CString                 str;
    DWORD                       dwFileVersion = DHCPSNAP_FILE_VERSION;
        CDhcpRootHandler * pRootHandler;
        SPITFSNodeEnum  spNodeEnum;
    SPITFSNode          spCurrentNode;
    ULONG                       nNumReturned = 0;
    int             nNumServers = 0, nVisibleCount = 0;
    int                         i, j, nCount = 0;
    CDhcpServer *   pServer;
    DWORD           dwFlags = 0;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    

    // Write the version # of the file format
    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_VERSION, &dwFileVersion));
        
    // Write the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(DHCPSTRM_TAG_VERSIONADMIN, &gliDhcpsnapVersion));

        // write the root node name
    Assert(m_spRootNode);
        pRootHandler = GETHANDLER(CDhcpRootHandler, m_spRootNode);
        str = pRootHandler->GetDisplayName();

    CORg(xferStream.XferCString(DHCPSTRM_TAB_SNAPIN_NAME, &str));

        //
        // Build our array of servers
        //
        hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

    strArrayIp.SetSize(nNumServers);
    strArrayName.SetSize(nNumServers);
    dwArrayServerOptions.SetSize(nNumServers);
    dwArrayRefreshInterval.SetSize(nNumServers);
        dwArrayColumnInfo.SetSize(MAX_COLUMNS);

        //
        // loop and save off all the server's attributes
        //
    m_spRootNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                pServer = GETHANDLER(CDhcpServer, spCurrentNode);

        // query the server for it's options:
        // auto refresh, bootp and classid visibility
        // NOTE: the audit logging state is also kept in here, but
        // it will get updated when the server node is enumerated
        dwArrayServerOptions[nCount] = pServer->GetServerOptions();
        pServer->GetAutoRefresh(NULL, &dwArrayRefreshInterval[nCount]);

                // put the information in our array
                strArrayIp[nCount] = pServer->GetIpAddress();
        strArrayName[nCount] = pServer->GetName();

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
        }

    // now write out all of the server information
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_IP, &strArrayIp));
    CORg(xferStream.XferCStringArray(DHCPSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_OPTIONS, &dwArrayServerOptions));
    CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));

        // now save the column information
        for (i = 0; i < NUM_SCOPE_ITEMS; i++)
        {
                CORg(xferStream.XferDWORDArray(DHCPSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

                for (j = 0; j < MAX_COLUMNS; j++)
                {
                        dwArrayColumnInfo[j] = aColumnWidths[i][j];
                }
        }

        if (fClearDirty)
        {
                m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
        }

    // save off taskpad states

    // root node taskpad state
    if (m_spTFSComponentData->GetTaskpadState(TASKPAD_ROOT_INDEX))
        dwFlags |= TASKPAD_ROOT_FLAG;

    // server node taskpad state
    if (m_spTFSComponentData->GetTaskpadState(TASKPAD_SERVER_INDEX))
        dwFlags |= TASKPAD_SERVER_FLAG;

    CORg(xferStream.XferDWORD(DHCPSTRM_TAG_SNAPIN_OPTIONS, &dwFlags));

Error:
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CDhcpComponentData::GetSizeMax
(
        ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10240);

    return S_OK;
}

STDMETHODIMP 
CDhcpComponentData::InitNew()
{
        return hrOK;
}

HRESULT 
CDhcpComponentData::FinalConstruct()
{
        HRESULT                         hr = hrOK;
        
        hr = CComponentData::FinalConstruct();
        
        if (FHrSucceeded(hr))
        {
                m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
        }
        return hr;
}

void 
CDhcpComponentData::FinalRelease()
{
    DhcpDsCleanup();
        CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\cred.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000   **/
/**********************************************************************/

/*
	cred.cpp
		This file contains all of the prototypes for the 
		credentials dialog used for DDNS.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "cred.h"
#include "lsa.h"			// RtlEncodeW/RtlDecodeW

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCredentials dialog


CCredentials::CCredentials(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CCredentials::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCredentials)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCredentials::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCredentials)
	DDX_Control(pDX, IDOK, m_buttonOk);
	DDX_Control(pDX, IDC_EDIT_CRED_USERNAME, m_editUsername);
	DDX_Control(pDX, IDC_EDIT_CRED_PASSWORD2, m_editPassword2);
	DDX_Control(pDX, IDC_EDIT_CRED_PASSWORD, m_editPassword);
	DDX_Control(pDX, IDC_EDIT_CRED_DOMAIN, m_editDomain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCredentials, CBaseDialog)
	//{{AFX_MSG_MAP(CCredentials)
	ON_EN_CHANGE(IDC_EDIT_CRED_USERNAME, OnChangeEditCredUsername)
	ON_EN_CHANGE(IDC_EDIT_CRED_DOMAIN, OnChangeEditCredDomain)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCredentials message handlers
BOOL CCredentials::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
    CString strUsername, strDomain, dummyPasswd;
    LPTSTR pszUsername, pszDomain;

    pszUsername = strUsername.GetBuffer(MAX_PATH);
    pszDomain = strDomain.GetBuffer(MAX_PATH);

	// call the DHCP api to get the current username and domain
    DWORD err = DhcpServerQueryDnsRegCredentials((LPWSTR) ((LPCTSTR) m_strServerIp),
                                                 MAX_PATH,
                                                 pszUsername,
                                                 MAX_PATH,
                                                 pszDomain);

    strUsername.ReleaseBuffer();
    strDomain.ReleaseBuffer();

    if (err == ERROR_SUCCESS)
    {
        m_editUsername.SetWindowText(strUsername);
        m_editDomain.SetWindowText(strDomain);


        // set the password fields to something
        dummyPasswd = _T("xxxxxxxxxx");
        m_editPassword.SetWindowText( dummyPasswd  );
        m_editPassword2.SetWindowText( dummyPasswd );
    }
    else
    {
        ::DhcpMessageBox(err);
    }

    m_fNewUsernameOrDomain = FALSE;

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCredentials::OnOK() 
{
    CString strUsername, strDomain, strPassword1, strPassword2, dummyPasswd;

    dummyPasswd = _T("xxxxxxxxxx");

    // grab the username and domain
    m_editUsername.GetWindowText(strUsername);
    m_editDomain.GetWindowText(strDomain);

    // grab the passwords and make sure they match
    m_editPassword.GetWindowText(strPassword1);
    m_editPassword2.GetWindowText(strPassword2);

    if (strPassword1.Compare(strPassword2) != 0)
    {
        // passwords don't match
        AfxMessageBox(IDS_PASSWORDS_DONT_MATCH);
        m_editPassword.SetFocus();
        return;
    }

    //
    // run through the following code if user changed passwd.
    //

    if ( strPassword2 != dummyPasswd )
    {

        // encode the password
        unsigned char ucSeed = DHCP_ENCODE_SEED;
        LPTSTR pszPassword = strPassword1.GetBuffer((strPassword1.GetLength() + 1) * sizeof(TCHAR));

        RtlEncodeW(&ucSeed, pszPassword);

        // send to the DHCP api.
        DWORD err = ERROR_SUCCESS;

        err = DhcpServerSetDnsRegCredentials((LPWSTR) ((LPCTSTR) m_strServerIp), 
                                         (LPWSTR) ((LPCTSTR) strUsername), 
                                         (LPWSTR) ((LPCTSTR) strDomain), 
                                         (LPWSTR) ((LPCTSTR) pszPassword));
        if (err != ERROR_SUCCESS)
        {
            // something failed, notify the user
            ::DhcpMessageBox(err);
            return;
        }
    }
	
	CBaseDialog::OnOK();
}

void CCredentials::OnChangeEditCredUsername() 
{
    if (!m_fNewUsernameOrDomain)
    {
        m_fNewUsernameOrDomain = TRUE;

        m_editPassword.SetWindowText(_T(""));
        m_editPassword2.SetWindowText(_T(""));
    }
}

void CCredentials::OnChangeEditCredDomain() 
{
    if (!m_fNewUsernameOrDomain)
    {
        m_fNewUsernameOrDomain = TRUE;

        m_editPassword.SetWindowText(_T(""));
        m_editPassword2.SetWindowText(_T(""));
    }
}

void CCredentials::SetServerIp(LPCTSTR pszServerIp)
{
    m_strServerIp = pszServerIp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\croot.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        croot.cpp
                DHCP root node information (the root node is not displayed
                in the MMC framework but contains information such as 
                all of the servers in this snapin).
                
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "croot.h"
#include "server.h"
#include "tregkey.h"
#include "service.h"
#include "servbrow.h"  // CAuthServerList
#include "ncglobal.h"  // network console global defines

#include "addserv.h"   // add server dialog
#include <clusapi.h>
#include "cluster.h"   // cluster routines

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

#define ROOT_MESSAGE_MAX_STRING  6

typedef enum _ROOT_MESSAGES
{
    ROOT_MESSAGE_NO_SERVERS,
    ROOT_MESSAGE_MAX
};

UINT g_uRootMessages[ROOT_MESSAGE_MAX][ROOT_MESSAGE_MAX_STRING] =
{
    {IDS_ROOT_MESSAGE_TITLE, Icon_Information, IDS_ROOT_MESSAGE_BODY1, IDS_ROOT_MESSAGE_BODY2, IDS_ROOT_MESSAGE_BODY3, 0},
};



/*---------------------------------------------------------------------------
        CDhcpRootHandler::CDhcpRootHandler
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpRootHandler::CDhcpRootHandler(ITFSComponentData *pCompData) 
    : CDhcpHandler(pCompData)
{
    m_bMachineAdded = FALSE;
    m_fViewMessage = TRUE;
}

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strTemp;
        strTemp.LoadString(IDS_ROOT_NODENAME);

        SetDisplayName(strTemp);

        // Make the node immediately visible
        //pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, 0);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_APPLICATION);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_APPLICATION);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ROOT);

        SetColumnStringIDs(&aColumns[DHCPSNAP_ROOT][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_ROOT][0]);

    return hrOK;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::GetString
                Implementation of ITFSNodeHandler::GetString
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpRootHandler::GetString
(
        ITFSNode *      pNode, 
        int                     nCol
)
{
        if (nCol == 0 || nCol == -1)
                return GetDisplayName();
        else
                return NULL;
}

HRESULT
CDhcpRootHandler::SetGroupName(LPCTSTR pszGroupName)
{
        CString strSnapinBaseName, strGroupName, szBuf;
        {
                AFX_MANAGE_STATE(AfxGetStaticModuleState());
                strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);
        }
        
    strGroupName = pszGroupName;
    if (strGroupName.IsEmpty())
        szBuf = strSnapinBaseName;
    else
            szBuf.Format(_T("%s [%s]"), strSnapinBaseName, strGroupName);
        
        SetDisplayName(szBuf);

        return hrOK;
}

HRESULT
CDhcpRootHandler::GetGroupName(CString * pstrGroupName) 
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        CString strSnapinBaseName, strDisplayName;
        strSnapinBaseName.LoadString(IDS_ROOT_NODENAME);

        int nBaseLength = strSnapinBaseName.GetLength() + 1; // For the space
        strDisplayName = GetDisplayName();

        if (strDisplayName.GetLength() == nBaseLength)
                pstrGroupName->Empty();
        else
                *pstrGroupName = strDisplayName.Right(strDisplayName.GetLength() - nBaseLength);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnExpand
                Handles enumeration of a scope item
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnExpand
(
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg, 
        LPARAM                  param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CDhcpHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
                int nVisible, nTotal;
                hr = pNode->GetChildCount(&nVisible, &nTotal);

        // only possibly add the local machine if the list is currently empty
        if (nTotal == 0)
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }
    }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;
        CString strMenuItem;

        if (type == CCT_SCOPE)
        {
                // these menu items go in the new menu, 
                // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuItem.LoadString(IDS_ADD_SERVER);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_ADD_SERVER,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     0 );
                    ASSERT( SUCCEEDED(hr) );

                    strMenuItem.LoadString(IDS_BROWSE_SERVERS);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuItem, 
                                                                     IDS_BROWSE_SERVERS,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     0 );
                    ASSERT( SUCCEEDED(hr) );

            if (OldServerListExists())
            {
                // these menu items go in the new menu, 
                        // only visible from scope pane
                        strMenuItem.LoadString(IDS_IMPORT_OLD_LIST);
                        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                         strMenuItem, 
                                                                         IDS_IMPORT_OLD_LIST,
                                                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                         0 );
                        ASSERT( SUCCEEDED(hr) );
            }
        }
    }

        return hr; 
}

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::AddMenuItems
                Over-ride this to add our view menu item
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;
        CString strMenuItem;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_MESSAGE_VIEW);
                hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                 strMenuItem, 
                                                                 IDS_MESSAGE_VIEW,
                                                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_fViewMessage) ? MF_CHECKED : 0 );
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_ADD_SERVER:
                        hr = OnCreateNewServer(pNode);
                        break;

                case IDS_BROWSE_SERVERS:
                        hr = OnBrowseServers(pNode);
                        break;

                case IDS_IMPORT_OLD_LIST:
                        hr = OnImportOldList(pNode);
                        break;

        default:
            break;
        }

        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::Command
                Handles commands for the current view
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::Command
(
    ITFSComponent * pComponent, 
        MMC_COOKIE              cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = S_OK;
    SPITFSNode spNode;

        switch (nCommandID)
        {
        case MMCC_STANDARD_VIEW_SELECT:
            break;

        case IDS_MESSAGE_VIEW:
            m_fViewMessage = !m_fViewMessage;
            m_spNodeMgr->GetRootNode(&spNode);
            UpdateResultMessage(spNode);
            break;

        // this may have come from the scope pane handler, so pass it up
        default:
            hr = HandleScopeCommand(cookie, nCommandID, pDataObject);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::HasPropertyPages
                Implementation of ITFSNodeHandler::HasPropertyPages
        NOTE: the root node handler has to over-ride this function to 
        handle the snapin manager property page (wizard) case!!!
        
        Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::HasPropertyPages
(
        ITFSNode *                      pNode,
        LPDATAOBJECT            pDataObject, 
        DATA_OBJECT_TYPES   type, 
        DWORD               dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        HRESULT hr = hrOK;
        
        if (dwType & TFS_COMPDATA_CREATE)
        {
                // This is the case where we are asked to bring up property
                // pages when the user is adding a new snapin.  These calls
                // are forwarded to the root node to handle.
                hr = hrFalse;
        }
        else
        {
                // we have property pages in the normal case
                hr = hrFalse;
        }
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpRootHandler::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = hrOK;
        HPROPSHEETPAGE hPage;

        Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
        
        if (dwType & TFS_COMPDATA_CREATE)
        {
                //
                // We are loading this snapin for the first time, put up a property
                // page to allow them to name this thing.
                // 
        }
        else
        {
                //
                // Object gets deleted when the page is destroyed
                //
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        return hrOK;
}

HRESULT
CDhcpRootHandler::OnRemoveChildren(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;

   
    if (!m_bExpanded)
        return hr;

    m_bExpanded = FALSE;

    // do the default handling
    hr = CDhcpHandler::OnRemoveChildren(pNode, pDataObject, arg, param);


    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));

    // walk the list of child nodes and remove each node
    while (nNumReturned)
    {
        CORg (pNode->RemoveChild(spCurrentNode));

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

 Error:
    return hr;
}


/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnGetResultViewType
                Return the result view that this node is going to support
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    return CDhcpHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);
}

/*!--------------------------------------------------------------------------
        CDhcpRootHandler::OnResultSelect
                For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpRootHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT hr = hrOK;
    SPITFSNode spRootNode;

    if ( 0 == HIWORD( arg )) {
        return S_FALSE;
    }

    CORg(CDhcpHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    UpdateResultMessage(spRootNode);

Error:
    return hr;
}

void CDhcpRootHandler::UpdateResultMessage(ITFSNode * pNode)
{
    HRESULT hr = hrOK;
    int nMessage = ROOT_MESSAGE_NO_SERVERS;   // default
    int nVisible, nTotal;
    int i;
    CString strTitle, strBody, strTemp;

    if (!m_fViewMessage)
    {
        ClearMessage(pNode);
    }
    else
    {
        CORg(pNode->GetChildCount(&nVisible, &nTotal));

        if (nTotal > 0)
                {
                        ClearMessage(pNode);
                }
                else
                {
            nMessage = ROOT_MESSAGE_NO_SERVERS;

                        // now build the text strings
                        // first entry is the title
                        strTitle.LoadString(g_uRootMessages[nMessage][0]);

                        // second entry is the icon
                        // third ... n entries are the body strings

                        for (i = 2; g_uRootMessages[nMessage][i] != 0; i++)
                        {
                                strTemp.LoadString(g_uRootMessages[nMessage][i]);
                                strBody += strTemp;
                        }

                        ShowMessage(pNode, strTitle, strBody, (IconIdentifier) g_uRootMessages[nMessage][1]);
                }
    }

Error:
    return;
}

/*---------------------------------------------------------------------------
        Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnCreateNewServer
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnCreateNewServer
(
     ITFSNode *      pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
    HRESULT hr = hrOK;

    CAddServer dlgAddServer;
    BOOL       fServerAdded = FALSE;

    dlgAddServer.SetServerList(&g_AuthServerList);
    if (dlgAddServer.DoModal() == IDOK)
    {
        while ( !dlgAddServer.m_lSelSrv.IsEmpty()) {
            SelectedServer SelSrv = dlgAddServer.m_lSelSrv.RemoveHead();

            if ( !IsServerInList( pNode, ::UtilCvtWstrToIpAddr( SelSrv.strIp ),
                                 SelSrv.strName )) {
                AddServer( SelSrv.strIp, SelSrv.strName, TRUE );
                fServerAdded = TRUE;
            }
        } // while 
    } // if 

    if (fServerAdded) {
        UpdateResultMessage(pNode);
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnBrowseServers
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnBrowseServers
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
    HRESULT         hr = hrOK;
    CServerBrowse   dlgBrowse;
    BOOL            fServerAdded = FALSE;

    BEGIN_WAIT_CURSOR;
    
    if (!g_AuthServerList.IsInitialized())
    {
        hr = g_AuthServerList.Init();
        hr = g_AuthServerList.EnumServers();
    }

    dlgBrowse.SetServerList(&g_AuthServerList);
    
    END_WAIT_CURSOR;

    if (dlgBrowse.DoModal() == IDOK)
    {
        for (int i = 0; i < dlgBrowse.m_astrName.GetSize(); i++)
        {
            if (IsServerInList(pNode, ::UtilCvtWstrToIpAddr(dlgBrowse.m_astrIp[i]), dlgBrowse.m_astrName[i]))
            {
                DhcpMessageBox(IDS_ERR_HOST_ALREADY_CONNECTED);
            }
            else
            {
                AddServer(dlgBrowse.m_astrIp[i], 
                          dlgBrowse.m_astrName[i],
                          TRUE);
                fServerAdded = TRUE;
            }
        }
    }

    if (fServerAdded)
        UpdateResultMessage(pNode);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OnImportOldList
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::OnImportOldList
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        DWORD err = LoadOldServerList(pNode);
        if (err)
                ::DhcpMessageBox(err);

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::CreateLocalDhcpServer
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpRootHandler::CreateLocalDhcpServer()
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        
        CString strName;

        // Create the local machine 
        //
        strName.LoadString (IDS_LOOPBACK_IP_ADDR);
        AddServer(strName, NULL, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::AddServer
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpRootHandler::AddServer
(
        LPCWSTR                  pServerIp,
    LPCTSTR          pServerName,
        BOOL                     bNewServer,
    DWORD            dwServerOptions,
    DWORD                        dwRefreshInterval,
    BOOL             bExtension
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT                         hr = hrOK;
        CDhcpServer *           pDhcpServer = NULL;
        SPITFSNodeHandler       spHandler;
        SPITFSNode                      spNode, spRootNode;

        // Create a handler for the node
        try
        {
                pDhcpServer = new CDhcpServer(m_spTFSCompData, pServerIp);
        pDhcpServer->SetName(pServerName);
                
                // Do this so that it will get released correctly
                spHandler = pDhcpServer;
        }
        catch(...)
        {
                hr = E_OUTOFMEMORY;
        }
        CORg( hr );
        
        //
        // Create the server container information
        // 
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpServerNodeType,
                                                   pDhcpServer,
                                                   pDhcpServer,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pDhcpServer->InitializeNode((ITFSNode *) spNode);
    
    // tell the server to set the name differently in the extension case
    if (dwServerOptions & SERVER_OPTION_EXTENSION)
    {
        m_bMachineAdded = TRUE;
        pDhcpServer->SetExtensionName();
    }

    // Mask out the auto refresh option because we set it next
    pDhcpServer->SetServerOptions(dwServerOptions & ~SERVER_OPTION_AUTO_REFRESH);

    // if we got a valid refresh interval, then set it.
        if (dwRefreshInterval != 0xffffffff)
                pDhcpServer->SetAutoRefresh(spNode, dwServerOptions & SERVER_OPTION_AUTO_REFRESH, dwRefreshInterval);

    AddServerSortedName(spNode, bNewServer);

        if (bNewServer)
    {
        // need to get our node descriptor
            CORg(m_spNodeMgr->GetRootNode(&spRootNode));
                spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
        return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::IsServerInList
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpRootHandler::IsServerInList
(
        ITFSNode *              pRootNode,
        DHCP_IP_ADDRESS dhcpIpAddressNew,
        CString &               strName
)
{
        HRESULT                         hr = hrOK;
        SPITFSNodeEnum          spNodeEnum;
        SPITFSNode                      spCurrentNode;
        ULONG                           nNumReturned = 0;
        DHCP_IP_ADDRESS         dhcpIpAddressCurrent;
        BOOL                            bFound = FALSE;
        CString                         strCurrentName;

        // get the enumerator for this node
        pRootNode->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        while (nNumReturned)
        {
                // walk the list of servers and see if it already exists
                CDhcpServer * pServer = GETHANDLER(CDhcpServer, spCurrentNode);
                pServer->GetIpAddress(&dhcpIpAddressCurrent);

                //if (dhcpIpAddressCurrent == dhcpIpAddressNew)
                strCurrentName = pServer->GetName();
                if (!strCurrentName.IsEmpty() && 
                        strName.CompareNoCase(strCurrentName) == 0)
                {
                        bFound = TRUE;
                        break;
                }

                // get the next Server in the list
                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        return bFound;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::OldServerListExists
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpRootHandler::OldServerListExists()
{
    RegKey      rk;
    LONG        err;
    BOOL        bExists = TRUE;
    CStringList strList;

    err = rk.Open(HKEY_CURRENT_USER, DHCP_REG_USER_KEY_NAME);
        if (err != ERROR_SUCCESS)
        {
                // the key doesn't exist, so there's nothing to import...
                // just return ok
                bExists = FALSE;
        }

    err = rk.QueryValue(DHCP_REG_VALUE_HOSTS, strList);
    if (err != ERROR_SUCCESS)
        bExists = FALSE;

    return bExists;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::LoadOldServerList
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpRootHandler::LoadOldServerList
(
        ITFSNode * pNode
)
{
    RegKey              rk;
    CStringList strList ;
    CString *   pstr ;
    POSITION    pos ;
    LONG                err;
        BOOL            bServerAdded = FALSE;
        CString         strName;
    DHC_HOST_INFO_STRUCT hostInfo;
        
        err = rk.Open(HKEY_CURRENT_USER, DHCP_REG_USER_KEY_NAME);
        if (err == ERROR_FILE_NOT_FOUND)
        {
                // the key doesn't exist, so there's nothing to import...
                // just return ok
                return ERROR_SUCCESS;
        }
        else 
        if (err)
                return err;

        do
    {
        if ( err = rk.QueryValue( DHCP_REG_VALUE_HOSTS, strList ) )
        {
            break ;
        }

        pos = strList.GetHeadPosition();

        if (pos == NULL)
            break;

        for ( ; pos && (pstr = & strList.GetNext(pos)); /**/ )
        {
                        DHCP_IP_ADDRESS dhcpIpAddress = UtilCvtWstrToIpAddr(*pstr);

            err = ::UtilGetHostInfo(dhcpIpAddress, &hostInfo);
            if (err == ERROR_SUCCESS)
            {
                strName = hostInfo._chHostName;
            }

                        // check to see if the server already is in the list
                        // if not then add
                        if (!IsServerInList(pNode, dhcpIpAddress, strName))
                        {
                // is this a local machine addr?  Convert to real IP
                if ((dhcpIpAddress & 0xFF000000) == 127)
                {
                    UtilGetLocalHostAddress(&dhcpIpAddress);
                    UtilCvtIpAddrToWstr(dhcpIpAddress, pstr);
                }   

                AddServer(*pstr, strName, TRUE, 0, DHCPSNAP_REFRESH_INTERVAL_DEFAULT);
                                bServerAdded = TRUE;
                        }
        }
    }
    while ( FALSE ) ;

    //
    //  Set the dirty flag if we added anything to the list
    //
    if (bServerAdded)
                pNode->SetData(TFS_DATA_DIRTY, TRUE);

    //
    // This isn't really an error -- it just means that we didn't
    // find the key name in the list
    //
    if (err == ERROR_FILE_NOT_FOUND)
    {
        Trace0("Didn't find old addresses registry key -- starting from scratch");
        err = ERROR_SUCCESS;
    }

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::AddServerSortedIp
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
        HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
        ULONG           nNumReturned = 0;
        DHCP_IP_ADDRESS dhcpIpAddressCurrent = 0;
        DHCP_IP_ADDRESS dhcpIpAddressTarget;

    CDhcpServer *   pServer;

    // get our target address
        pServer = GETHANDLER(CDhcpServer, pNewNode);
        pServer->GetIpAddress(&dhcpIpAddressTarget);

    // need to get our node descriptor
        CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
        CORg(spRootNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
                // walk the list of servers and see if it already exists
                pServer = GETHANDLER(CDhcpServer, spCurrentNode);
                pServer->GetIpAddress(&dhcpIpAddressCurrent);

                if (dhcpIpAddressCurrent > dhcpIpAddressTarget)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next Server in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::AddServerSortedName
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::AddServerSortedName
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
        HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
        ULONG           nNumReturned = 0;
    CString         strTarget, strCurrent;

    CDhcpServer *   pServer;

    // get our target address
        pServer = GETHANDLER(CDhcpServer, pNewNode);
        strTarget = pServer->GetName();

    // need to get our node descriptor
        CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
        CORg(spRootNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
                // walk the list of servers and see if it already exists
                pServer = GETHANDLER(CDhcpServer, spCurrentNode);
                strCurrent = pServer->GetName();

                if (strTarget.CompareNoCase(strCurrent) < 0)
                {
            // Found where we need to put it, break out
            break;
                }

                // get the next Server in the list
                spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpRootHandler::CheckMachine
                Checks to see if the DHCP server service is running on the local
        machine.  If it is, it adds it to the list of servers.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);
        BOOL    fInCluster = FALSE;
    CString strLocalIp, strLocalName, strIp;
    DHC_HOST_INFO_STRUCT hostInfo;
    DHCP_IP_ADDRESS dhcpAddress;

    if (!bExtension)
    {
        // just check the local machine
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();

        UtilGetLocalHostAddress(&dhcpAddress);
    }
    else
    {
        // get the machine name from the data object
        strMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);

        UtilGetHostAddress(strMachineName, &dhcpAddress);
                RemoveOldEntries(pRootNode, dhcpAddress);
    }

        fInCluster = ::FIsComputerInRunningCluster(strMachineName);
    if (fInCluster)
    {
        if (GetClusterResourceIp(strMachineName, _T("DHCP Service"), strIp) == ERROR_SUCCESS)
        {
            dhcpAddress = ::UtilCvtWstrToIpAddr(strIp);
        }
    }

        if (fInCluster)
        {
                // get the resource name for the IP address we just got
                UtilGetHostInfo(dhcpAddress, &hostInfo);
                strMachineName = hostInfo._chHostName;
        }

    // check to see if the service is running
        BOOL bServiceRunning;
        DWORD dwError = ::TFSIsServiceRunning(strMachineName, _T("DHCPServer"), &bServiceRunning);
        if (dwError != ERROR_SUCCESS ||
        !bServiceRunning)
        {
                // The following condition could happen to get here:
        //  o The service is not installed.
        //  o Couldn't access for some reason.
        //  o The service isn't running.
                
        // Don't add to the list.
                
        return hrOK;
        }

    if (!fInCluster)
        {
                UtilGetHostInfo(dhcpAddress, &hostInfo);
                strMachineName = hostInfo._chHostName;
        }

    // OK.  The service is installed, so lets and add it to the list.
    if (IsServerInList(pRootNode, dhcpAddress, strMachineName))
        return hr;

    // looks good, add to list
    UtilCvtIpAddrToWstr(dhcpAddress, &strLocalIp);

    DWORD dwFlags = SERVER_OPTION_SHOW_ROGUE;

    if (bExtension)
        dwFlags |= SERVER_OPTION_EXTENSION;

    AddServer(strLocalIp, strMachineName, TRUE, dwFlags, DHCPSNAP_REFRESH_INTERVAL_DEFAULT, bExtension);

    m_bMachineAdded = TRUE;

    return hr;
}

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CDhcpRootHandler::RemoveOldEntries(ITFSNode * pNode, DHCP_IP_ADDRESS dhcpAddress)
{
        HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
        SPITFSNode      spCurrentNode;
        ULONG           nNumReturned = 0;
        CDhcpServer *   pServer;

    // get the enumerator for this node
        CORg(pNode->GetEnum(&spNodeEnum));

        CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
        while (nNumReturned)
        {
                // walk the list of servers and see if it already exists
                pServer = GETHANDLER(CDhcpServer, spCurrentNode);

                DHCP_IP_ADDRESS ipaddrCurrent;

                pServer->GetIpAddress(&ipaddrCurrent);

                //if (ipaddrCurrent != dhcpAddress)
                {
                        CORg (pNode->RemoveChild(spCurrentNode));
                }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\cred.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000   **/
/**********************************************************************/

/*
	cred.h
		This file contains all of the prototypes for the 
		credentials dialog used for DDNS.

    FILE HISTORY:
        
*/

#if !defined(AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_)
#define AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CCredentials dialog

class CCredentials : public CBaseDialog
{
// Construction
public:
	CCredentials(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCredentials)
	enum { IDD = IDD_CREDENTIALS };
	CButton	m_buttonOk;
	CEdit	m_editUsername;
	CEdit	m_editPassword2;
	CEdit	m_editPassword;
	CEdit	m_editDomain;
	//}}AFX_DATA

    void SetServerIp(LPCTSTR pszServerIp);

    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CCredentials::IDD); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCredentials)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    BOOL    m_fNewUsernameOrDomain;
    CString m_strServerIp;

	// Generated message map functions
	//{{AFX_MSG(CCredentials)
	afx_msg void OnChangeEditCredUsername();
	afx_msg void OnChangeEditCredDomain();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CRED_H__BDDD51D7_F6E6_4D9F_BBC2_102F1712538F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcphand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        dhcphand.cpp
                DHCP specifc handler base classes

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dhcphand.h"
#include "snaputil.h"  // For CGUIDArray
#include "extract.h"   // For ExtractInternalFormat
#include "nodes.h"
#include "classmod.h"

STDMETHODIMP
CMTDhcpHandler::DestroyHandler( ITFSNode *pNode )
{
    // Destroy any open property sheets
    DestroyPropSheets();

    return CMTHandler::DestroyHandler( pNode );

} // CMTDhcpHandler::DestroyHandler()

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CMTDhcpHandler::HandleScopeCommand
(
        MMC_COOKIE      cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
                        SPINTERNAL                  spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
                        if (spInternal)
                                dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
            CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CMTDhcpHandler::HandleScopeMenus
(
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
                        SPINTERNAL                  spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
                        if (spInternal)
                                dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
            CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CMTDhcpHandler::Command
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::Command
(
    ITFSComponent * pComponent, 
        MMC_COOKIE              cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
        CMTDhcpHandler::AddMenuItems
                Over-ride this to add our view menu item
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}

/*---------------------------------------------------------------------------
        CMTDhcpHandler::OnChangeState
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTDhcpHandler::OnChangeState
(
        ITFSNode * pNode
)
{
        // Increment the state to the next position
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
                case unableToLoad:
                        {
                                m_nState = loading;
                                m_dwErr = 0;
                        }
                        break;

                case loading:
                        {
                                m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                
                if (m_dwErr)
                {
                    CString strTitle, strBody;
                    IconIdentifier icon;

                    GetErrorMessages(strTitle, strBody, &icon);

                    if (!strBody.IsEmpty())
                        ShowMessage(pNode, strTitle, strBody, icon);
                    else
                        ClearMessage(pNode);
                }
                else
                {
                    ClearMessage(pNode);
                }

                m_fSilent = FALSE;
                        }
                        break;
        
                default:
                        ASSERT(FALSE);
        }

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));

        SendUpdateToolbar(pNode, m_bSelected);
    }

    // Now check and see if there is a new image for this state for this handler
        int nImage, nOpenImage;

        nImage = GetImageIndex(FALSE);
        nOpenImage = GetImageIndex(TRUE);

        if (nImage >= 0)
                pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

        if (nOpenImage >= 0)
                pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
        
        VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));
}

 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::GetErrorMessages
                Default message view text for errors
        Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTDhcpHandler::GetErrorMessages
(
    CString & strTitle, 
    CString & strBody, 
    IconIdentifier * icon
)
{
    TCHAR chMesg [4000] = {0};
    BOOL bOk ;

    UINT nIdPrompt = (UINT) m_dwErr;
    CString strTemp;

    strTitle.LoadString(IDS_SERVER_MESSAGE_CONNECT_FAILED_TITLE);

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));

    AfxFormatString1(strBody, IDS_SERVER_MESSAGE_CONNECT_FAILED_BODY, chMesg);

    strTemp.LoadString(IDS_SERVER_MESSAGE_CONNECT_FAILED_REFRESH);
    strBody += strTemp;

    if (icon)
        *icon = Icon_Error;
}


 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::UpdateStandardVerbs
                Tells the IComponent to update the verbs for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateStandardVerbs
(
    ITFSNode * pNode,
    LONG_PTR   dwNodeType
)
{
    HRESULT                             hr = hrOK;
    SPIComponentData    spCompData;
        SPIConsole                      spConsole;
    IDataObject*                pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     reinterpret_cast<LONG_PTR>(pNode), 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
        
Error:
    return;
}

 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::SendUpdateToolbar
                Tells the IComponent to update the verbs for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::SendUpdateToolbar
(
    ITFSNode * pNode,
    BOOL       fSelected
)
{
    HRESULT                             hr = hrOK;
    SPIComponentData    spCompData;
        SPIConsole                      spConsole;
    IDataObject*                pDataObject = NULL;
    CToolbarInfo *      pToolbarInfo = NULL;

    COM_PROTECT_TRY
    {
        m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );

        pToolbarInfo = new CToolbarInfo;

        pToolbarInfo->spNode.Set(pNode);
        pToolbarInfo->fSelected = fSelected;
        
        CORg ( spConsole->UpdateAllViews(pDataObject, 
                                         reinterpret_cast<LONG_PTR>(pToolbarInfo), 
                                         DHCPSNAP_UPDATE_TOOLBAR) ); 

    }
    COM_PROTECT_CATCH

    COM_PROTECT_ERROR_LABEL; 

    if (pDataObject)
        pDataObject->Release();              

    if (pToolbarInfo)
        delete pToolbarInfo;

    return;
}


 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::ExpandNode
                Expands/compresses this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData    spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    if (!m_fExpandSync)
    {
        m_spNodeMgr->GetComponentData(&spCompData);

            CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
            CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnCreateDataObject
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
        MMC_COOKIE              cookie, 
        DATA_OBJECT_TYPES       type, 
        IDataObject **          ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

        CDataObject *       pObject = NULL;
        SPIDataObject       spDataObject;

    pObject = new CDataObject;
        spDataObject = pObject; // do this so that it gets released correctly
                                                
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

        pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                                                        reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CMTDhcpHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
        CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
            {
                    SPITFSNode   spCurNode;
            const GUID * pGuid1;

                    spCurNode = listSelectedNodes.RemoveHead();
            pGuid1 = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid1);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        pGuid = new GUID[UINT(rgGuids.GetSize())];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::SaveColumns
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()))
        return hr;

    if (IsMessageView())
        return hr;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        hr = spHeaderCtrl->GetColumnWidth(nCol, &nColWidth);
        if (SUCCEEDED(hr) && 
            (nColWidth != 0) &&
            aColumnWidths[dwNodeType][nCol] != nColWidth)
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
                spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnExpandSync
                Handles the MMCN_EXPANDSYNC notifcation 
        We need to do syncronous enumeration.  We'll fire off the background 
        thread like before, but we'll wait for it to exit before we return.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnExpandSync
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    HRESULT hr = hrOK;
    MSG msg;

    m_fExpandSync = TRUE;

    hr = OnExpand(pNode, pDataObject, CCT_SCOPE, arg, lParam);

    // wait for the background thread to exit
    WaitForSingleObject(m_hThread, INFINITE);
    
    // The background thread posts messages to a hidden window to 
    // pass data back to the main thread. The messages won't go through since we are
    // blocking the main thread.  The data goes on a queue in the query object
    // which the handler has a pointer to so we can just fake the notification.
    if (m_spQuery.p)
        OnNotifyHaveData((LPARAM) m_spQuery.p);

    // Tell MMC we handled this message
    MMC_EXPANDSYNC_STRUCT * pES = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(lParam);
    if (pES)
        pES->bHandled = TRUE;

    m_fExpandSync = FALSE;

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultSelect
                Handles the MMCN_SELECT notifcation 
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnResultSelect
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    SPINTERNAL          spInternal;
    BOOL            bMultiSelect = FALSE;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnRefresh
                Default implementation for the refresh functionality
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnRefresh
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg,
        LPARAM                  param
)
{
    HRESULT hr = hrOK;
    
    if (m_bExpanded == FALSE)
    {
        // we cannot refresh/add items to a node that hasn't been expanded yet.
        return hr;
    }

    BOOL bLocked = IsLocked();
    if (bLocked)
    {
        // cannot do refresh on locked node, the UI should prevent this
        return hr; 
    }
    
    pNode->DeleteAllChildren(TRUE);
    
    int nVisible, nTotal;
    pNode->GetChildCount(&nVisible, &nTotal);
    Assert(nVisible == 0);
    Assert(nTotal == 0);
    
    m_bExpanded = FALSE;
    OnExpand(pNode, pDataObject, dwType, arg, param); // will spawn a thread to do enumeration
    
    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()) && m_bSelected)
    {
        // tell the taskpad to update
        SPIConsole  spConsole;
        
        m_spTFSCompData->GetConsole(&spConsole);
        spConsole->SelectScopeItem(m_spNode->GetData(TFS_DATA_SCOPEID));
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultUpdateView
                Implementation of ITFSResultHandler::OnResultUpdateView
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMTDhcpHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
        HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
            SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        spNode.Set(reinterpret_cast<ITFSNode *>(data));

        UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE));
    }
    else 
    if (hint == DHCPSNAP_UPDATE_TOOLBAR)
    {
        SPIToolbar spToolbar;
        CToolbarInfo * pToolbarInfo;

        CORg (pComponent->GetToolbar(&spToolbar));

        pToolbarInfo = reinterpret_cast<CToolbarInfo *>(data);

        if (pToolbarInfo && spToolbar)
        {
            UpdateToolbar(spToolbar, pToolbarInfo->spNode->GetData(TFS_DATA_TYPE), pToolbarInfo->fSelected);
        }
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultContextHelp
                Implementation of ITFSResultHandler::OnResultContextHelp
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTDhcpHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
            UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
            if (nLen == 0)
        {
                    hr = E_FAIL;
            goto Error;
        }

            szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

                hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
                ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::UpdateStandardVerbs
                Updates the standard verbs depending upon the state of the node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];      
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::EnableVerbs
                Enables the toolbar buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTDhcpHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

        pConsoleVerb->SetDefaultVerb(m_verbDefault);
}


 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::UpdateToolbar
                Updates the toolbar depending upon the state of the node
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTDhcpHandler::UpdateToolbar
(
    IToolbar *  pToolbar,
    LONG_PTR    dwNodeType,
    BOOL        bSelect
)
{
    // Enable/disable toolbar buttons
    int i;
    BOOL aEnable[TOOLBAR_IDX_MAX];

    switch (m_nState)
    {
        case loaded:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = TRUE);
            break;
        
        case notLoaded:
        case loading:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
            break;

        case unableToLoad:
            for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);
            aEnable[TOOLBAR_IDX_REFRESH] = TRUE;
            break;
    }

    // if we are deselecting, then disable all
    if (!bSelect)
        for (i = 0; i < TOOLBAR_IDX_MAX; aEnable[i++] = FALSE);

    EnableToolbar(pToolbar,
                  g_SnapinButtons,
                  ARRAYLEN(g_SnapinButtons),
                  g_SnapinButtonStates[dwNodeType],
                  aEnable);
}

 /*!--------------------------------------------------------------------------
        CMTDhcpHandler::UserResultNotify
                We override this to handle toolbar notification
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::UserResultNotify
(
        ITFSNode *      pNode, 
        LPARAM          dwParam1, 
        LPARAM          dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnResultControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserResultNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::UserNotify
                We override this to handle toolbar notification
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTDhcpHandler::UserNotify
(
        ITFSNode *      pNode, 
        LPARAM          dwParam1, 
        LPARAM          dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultRefresh
                Call into the MTHandler to do a refresh
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
        HRESULT     hr = hrOK;
    SPITFSNode  spNode;

        CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultControlbarNotify
                Our implementation of the toobar handlers
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    // mark this node as selected
    m_bSelected = pToolbarNotify->bSelect;
    
    SPITFSNode          spParent;
    SPITFSNodeHandler   spNodeHandler;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            // forward the button click to the parent because our result pane
            // items don't have any functions for the toolbar
            // our result pane items only use the standard verbs
            CORg(pNode->GetParent(&spParent));
            CORg(spParent->GetHandler(&spNodeHandler));

            if (spNodeHandler)
                            CORg( spNodeHandler->UserNotify(spParent, 
                                                (LPARAM) DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                (LPARAM) pToolbarNotify) );
            break;

        case MMCN_SELECT:
            if (pNode->IsContainer())
            {
                hr = OnUpdateToolbarButtons(pNode, 
                                            pToolbarNotify);
            }
            break;

        default:
            Assert(FALSE);
            break;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnControlbarNotify
                Our implementation of the toobar handlers
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;
    
    // mark this node as selected
    m_bSelected = pToolbarNotify->bSelect;
    
    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            hr = OnToolbarButtonClick(pNode, 
                                      pToolbarNotify);
            break;

        case MMCN_SELECT:
            hr = OnUpdateToolbarButtons(pNode, 
                                        pToolbarNotify);
            break;

        default:
            Assert(FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnToolbarButtonClick
                Default implementation of OnToolbarButtonClick
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnToolbarButtonClick
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    // forward this command to the normal command handler
    return OnCommand(pNode, (long) pToolbarNotify->id, (DATA_OBJECT_TYPES) 0, NULL, 0);    
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnUpdateToolbarButtons
                Default implementation of OnUpdateToolbarButtons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        BOOL    bAttach = FALSE;
    
        // check to see if we should attach this toolbar
        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
        {
            if (g_SnapinButtonStates[pNode->GetData(TFS_DATA_TYPE)][i] == ENABLED)
            {
                bAttach = TRUE; 
                break;
            }
        }

        // attach the toolbar and enable the appropriate buttons
        if (pToolbarNotify->pControlbar)
        {
            if (bAttach)
            {
                pToolbarNotify->pControlbar->Attach(TOOLBAR, pToolbarNotify->pToolbar);
                UpdateToolbar(pToolbarNotify->pToolbar, pNode->GetData(TFS_DATA_TYPE), pToolbarNotify->bSelect);
            }
            else
            {
                pToolbarNotify->pControlbar->Detach(pToolbarNotify->pToolbar);
            }
        }
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::EnableToolbar
                Enables the toolbar buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTDhcpHandler::EnableToolbar
(
    LPTOOLBAR           pToolbar, 
    MMCBUTTON           rgSnapinButtons[], 
    int                 nRgSize,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pToolbar == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
        {
            if (ButtonState[i] == ENABLED)
            {
                // unhide this button before enabling
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         FALSE);
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         ButtonState[i], 
                                         bState[i]);
            }
            else
            {
                // hide this button
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         TRUE);
            }
        }
    }
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnRefreshStats
                Default implementation for the Stats refresh functionality
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnRefreshStats
(
        ITFSNode *              pNode,
        LPDATAOBJECT    pDataObject,
        DWORD                   dwType,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT                         hr = hrOK;
        SPITFSNode                      spNode;
        SPITFSNodeHandler       spHandler;
        ITFSQueryObject *       pQuery = NULL;
        
//    if (m_bExpanded == FALSE)
//    {
        // we cannot get statistics if the node hasn't been expanded yet
//        return hr;
//    }

    // only do stats refresh if the server was loaded correctly.
    if (m_nState == unableToLoad)
        return hr;

    BOOL bLocked = IsLocked();
        if (bLocked)
    {
        // cannot refresh stats if this node is locked
                return hr; 
    }

    Lock();

        //OnChangeState(pNode);

        pQuery = OnCreateQuery(pNode);
        Assert(pQuery);

        // notify the UI to change icon, if needed
        //Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

        Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
        
        pQuery->Release();

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnResultUpdateOptions
                Updates the result pane of any of the option nodes
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTDhcpHandler::OnResultUpdateOptions
(
    ITFSComponent *     pComponent,
        ITFSNode *                  pNode,
    CClassInfoArray *   pClassInfoArray,
    COptionValueEnum *  aEnum[],
    int                 aImages[],
    int                 nCount
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    CDhcpOption *       pOption;

    //
    // Walk the list of children to see if there's anything
        // to put in the result pane
        //
    SPITFSNodeEnum  spNodeEnum;
    ITFSNode *      pCurrentNode;
    ULONG           nNumReturned = 0;
    SPIResultData   spResultData;
    int             i;

    if (IsMessageView())
        return hr;

    CORg ( pComponent->GetResultData(&spResultData) );

    spResultData->DeleteAllRsltItems();

    pNode->DeleteAllChildren( TRUE );

    for (i = 0; i < nCount; i++)
    {
        while (pOption = aEnum[i]->Next())
        {
            BOOL bValid = TRUE;
            BOOL bAdded = FALSE;

            pNode->GetEnum(&spNodeEnum);

                spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
            while (nNumReturned)
                {
                // so the node gets release correctly
                SPITFSNode spCurNode;
                spCurNode = pCurrentNode;

                        //
                        // All containers go into the scope pane and automatically get 
                        // put into the result pane for us by the MMC
                        //
                    CDhcpOptionItem * pCurOption = GETHANDLER(CDhcpOptionItem, pCurrentNode);
        
                if (!pCurrentNode->IsContainer())
                        {
                    if ( lstrlen(pCurOption->GetClassName()) > 0 && 
                         !pClassInfoArray->IsValidClass(pCurOption->GetClassName()) )
                    {
                        // user class is no longer valid
                        bValid = FALSE;
                        Trace2("CMTDhcpHandler::OnResultUpdateOptions - Filtering option %d, user class %s\n", pCurOption->GetOptionId(), pOption->GetClassName());
                        break;
                    }
                    else
                    if ( pOption->IsVendor() &&
                         !pClassInfoArray->IsValidClass(pOption->GetVendor()) )
                    {
                        // the vendor class for this option has gone away
                        bValid = FALSE;
                        Trace2("CMTDhcpHandler::OnResultUpdateOptions - Filtering option %d, vendor class %s\n", pCurOption->GetOptionId(), pOption->GetVendor());
                        break;
                    }
                    else
                    if ( pCurOption->GetOptionId() == pOption->QueryId() &&
                         (lstrcmp(pCurOption->GetVendor(), pOption->GetVendor()) == 0) &&
                         (lstrcmp(pCurOption->GetClassName(), pOption->GetClassName()) == 0) )
                    {
                        // option has already been created, just need to re-add to the result pane
                        // update the value in case it has changed
                        bAdded = TRUE;
                        break;
                    }
                        }

                spNodeEnum->Next(1, &pCurrentNode, &nNumReturned);
                }

            if (!bAdded && bValid)
            {
                CDhcpOptionItem *   pOptionItem;
                SPITFSNode          spNode;

                if ( lstrlen(pOption->GetClassName()) > 0 && 
                     !pClassInfoArray->IsValidClass(pOption->GetClassName()) )
                {
                    // the user class for this option has gone away
                }
                else
                if ( pOption->IsVendor() &&
                     !pClassInfoArray->IsValidClass(pOption->GetVendor()) )
                {
                    // the vendor class for this option has gone away
                }
                else
                {
                    // option hasn't been added to the UI yet.  Make it so.
                    pOptionItem = new CDhcpOptionItem(m_spTFSCompData, pOption, aImages[i]);

                    CORg (CreateLeafTFSNode(&spNode,
                                            &GUID_DhcpOptionNodeType,
                                            pOptionItem,
                                            pOptionItem,
                                            m_spNodeMgr));

                        // Tell the handler to initialize any specific data
                        pOptionItem->InitializeNode(spNode);

                    // extra addref to keep the node alive while it is on the list
                        spNode->SetVisibilityState(TFS_VIS_HIDE);
                        pNode->AddChild(spNode);
                    pOptionItem->Release();

                    AddResultPaneItem(pComponent, spNode);
                }
            }

            spNodeEnum.Set(NULL);
        }
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        Class:  CDhcpHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CDhcpHandler::HandleScopeCommand
(
        MMC_COOKIE      cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
                        SPINTERNAL                  spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
                        if (spInternal)
                                dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
            CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CDhcpHandler::HandleScopeMenus
(
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
                        SPINTERNAL                  spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
                        if (spInternal)
                                dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
            CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpHandler::Command
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::Command
(
    ITFSComponent * pComponent, 
        MMC_COOKIE              cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
        CDhcpHandler::AddMenuItems
                Over-ride this to add our view menu item
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}

 
 /*!--------------------------------------------------------------------------
        CDhcpHandler::SaveColumns
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    if (m_spTFSCompData->GetTaskpadState(GetTaskpadIndex()))
        return hr;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        hr = spHeaderCtrl->GetColumnWidth(nCol, &nColWidth);
        if (SUCCEEDED(hr) &&
            (nColWidth != 0) &&
            aColumnWidths[dwNodeType][nCol] != nColWidth)
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
                spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CMTDhcpHandler::OnCreateDataObject
                -
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
        MMC_COOKIE                      cookie, 
        DATA_OBJECT_TYPES       type, 
        IDataObject **          ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

        CDataObject *   pObject = NULL;
        SPIDataObject   spDataObject;
        
        pObject = new CDataObject;
        spDataObject = pObject; // do this so that it gets released correctly
                                                
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

        pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                                                        reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CDhcpHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
        CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
            {
                    SPITFSNode   spCurNode;
                    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = ( GUID * ) spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT) (rgGuids.GetSize() * sizeof(GUID));
        
        pGuid = new GUID[(UINT)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

 /*---------------------------------------------------------------------------
        CDhcpHandler::OnResultDelete
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        HRESULT hr = hrOK;

        Trace0("CDhcpHandler::OnResultDelete received\n");

        // translate this call to the parent and let it handle deletion 
        // of result pane items
        SPITFSNode spNode, spParent;
        SPITFSResultHandler spParentRH;

        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        CORg (spNode->GetParent(&spParent));

        if (spParent == NULL)
                return hr;

        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
        return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::OnResultContextHelp
                Implementation of ITFSResultHandler::OnResultContextHelp
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
            UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
            if (nLen == 0)
        {
                    hr = E_FAIL;
            goto Error;
        }

        szHelpFilePath.ReleaseBuffer();
            szHelpFilePath += g_szDefaultHelpTopic;

                hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
                ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
        CDhcpHandler::UserResultNotify
                We override this to handle toolbar notification
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::UserResultNotify
(
        ITFSNode *      pNode, 
        LPARAM          dwParam1, 
        LPARAM          dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnResultControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserResultNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::UserNotify
                We override this to handle toolbar notification
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpHandler::UserNotify
(
        ITFSNode *      pNode, 
        LPARAM          dwParam1, 
        LPARAM          dwParam2
)
{
    HRESULT hr = hrOK;

    switch (dwParam1)
    {
        case DHCP_MSG_CONTROLBAR_NOTIFY:
            hr = OnControlbarNotify(pNode, reinterpret_cast<LPDHCPTOOLBARNOTIFY>(dwParam2));
            break;

        default:
            // we don't handle this message.  Forward it down the line...
            hr = CHandler::UserNotify(pNode, dwParam1, dwParam2);
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::OnResultControlbarNotify
                On a result pane notification all we can do is enable/hide buttons.
        We cannot attach/detach toolbars.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnResultControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    SPITFSNode          spParent;
    SPITFSNodeHandler   spNodeHandler;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            // forward the button click to the parent because our result pane
            // items don't have any functions for the toolbar
            // our result pane items only use the standard verbs
            CORg(pNode->GetParent(&spParent));
            CORg(spParent->GetHandler(&spNodeHandler));

            if (spNodeHandler)
                            CORg( spNodeHandler->UserNotify(spParent, 
                                                DHCP_MSG_CONTROLBAR_NOTIFY, 
                                                (LPARAM) pToolbarNotify) );
            break;

        case MMCN_SELECT:
            if (!pNode->IsContainer())
            {
                // use the parent's toolbar info
                SPITFSNode spParentNode;
                pNode->GetParent(&spParentNode);
                
                hr = OnUpdateToolbarButtons(spParentNode, 
                                            pToolbarNotify);
            }
            else
            {
                hr = OnUpdateToolbarButtons(pNode, 
                                            pToolbarNotify);
            }

            break;

        default:
            Assert(FALSE);
            break;
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::OnControlbarNotify
                Our implementation of the toobar handlers
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnControlbarNotify
(
    ITFSNode *          pNode, 
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    switch (pToolbarNotify->event)
    {
        case MMCN_BTN_CLICK:
            hr = OnToolbarButtonClick(pNode, 
                                      pToolbarNotify);
            break;

        case MMCN_SELECT:
            hr = OnUpdateToolbarButtons(pNode, 
                                        pToolbarNotify);
            break;

        default:
            Assert(FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::OnToolbarButtonClick
                Default implementation of OnToolbarButtonClick
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnToolbarButtonClick
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    // forward this command to the normal command handler
    return OnCommand(pNode, (long) pToolbarNotify->id, (DATA_OBJECT_TYPES) 0, NULL, 0);    
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::OnUpdateToolbarButtons
                Default implementation of OnUpdateToolbarButtons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpHandler::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    LONG_PTR dwNodeType = pNode->GetData(TFS_DATA_TYPE);

    if (pToolbarNotify->bSelect)
    {
        BOOL bAttach = FALSE;

        // check to see if we should attach this toolbar
        for (int i = 0; i < TOOLBAR_IDX_MAX; i++)
        {
            if (g_SnapinButtonStates[pNode->GetData(TFS_DATA_TYPE)][i] == ENABLED)
            {
                bAttach = TRUE; 
                break;
            }
        }

        // attach the toolbar and enable the appropriate buttons
        if (pToolbarNotify->pControlbar)
        {
            if (bAttach)
            {
                // attach the toolbar and enable the appropriate buttons
                pToolbarNotify->pControlbar->Attach(TOOLBAR, pToolbarNotify->pToolbar);

                EnableToolbar(pToolbarNotify->pToolbar,
                              g_SnapinButtons,
                              ARRAYLEN(g_SnapinButtons),
                              g_SnapinButtonStates[dwNodeType]);
            }
            else
            {
                pToolbarNotify->pControlbar->Detach(pToolbarNotify->pToolbar);
            }
        }
    }
    else
    {
        // disable the buttons
        EnableToolbar(pToolbarNotify->pToolbar,
                      g_SnapinButtons,
                      ARRAYLEN(g_SnapinButtons),
                      g_SnapinButtonStates[dwNodeType],
                      FALSE);
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpHandler::EnableToolbar
                Enables the toolbar buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpHandler::EnableToolbar
(
    LPTOOLBAR           pToolbar, 
    MMCBUTTON           rgSnapinButtons[], 
    int                 nRgSize,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState
)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
        {
            if (ButtonState[i] == ENABLED)
            {
                // unhide this button before enabling
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         FALSE);
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         ButtonState[i], 
                                         bState);
            }
            else
            {
                // hide this button
                pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, 
                                         HIDDEN, 
                                         TRUE);
            }

        }
    }
}


/*!--------------------------------------------------------------------------
        CDhcpHandler::OnResultSelect
                Handles the MMCN_SELECT notifcation 
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpHandler::OnResultSelect
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
        CMTDhcpHandler::EnableVerbs
                Enables the toolbar buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

        pConsoleVerb->SetDefaultVerb(m_verbDefault);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcpcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dhcpcomp.h
		This file contains the derived prototypes from CComponent
		and CComponentData for the DHCP admin snapin.

    FILE HISTORY:
        
*/

#ifndef _DHCPCOMP_H
#define _DHCPCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#ifndef _SERVBROW_H
#include "servbrow.h"
#endif

#include <ntverp.h>

#define COLORREF_PINK	0x00FF00FF

extern CAuthServerList g_AuthServerList;

#ifdef __cplusplus
extern "C" {
#endif

extern   WATERMARKINFO   g_WatermarkInfoServer;
extern   WATERMARKINFO   g_WatermarkInfoScope;

BOOL FilterOption(DHCP_OPTION_ID id);
BOOL FilterUserClassOption(DHCP_OPTION_ID id);
BOOL IsBasicOption(DHCP_OPTION_ID id);
BOOL IsAdvancedOption(DHCP_OPTION_ID id);
BOOL IsCustomOption(DHCP_OPTION_ID id);

//  Use FormatMessage() to get a system error message
LONG GetSystemMessage ( UINT nId, TCHAR * chBuffer, int cbBuffSize ) ;

BOOL LoadMessage (UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);

//  Surrogate AfxMessageBox replacement for error message filtering.
int DhcpMessageBox(DWORD dwIdPrompt, 
 				   UINT nType = MB_OK, 
				   const TCHAR * pszSuffixString = NULL,
				   UINT nHelpContext = -1);

int DhcpMessageBoxEx(DWORD   dwIdPrompt, 
 				     LPCTSTR pszPrefixMessage,
                     UINT    nType = (UINT) MB_OK, 
  				     UINT    nHelpContext = -1);

#ifdef __cplusplus
} // extern "C"
#endif

#define TASKPAD_ROOT_FLAG       0x00000001
#define TASKPAD_SERVER_FLAG     0x00000002

#define TASKPAD_ROOT_INDEX      0x00000000
#define TASKPAD_SERVER_INDEX    0x00000001

enum DHCPSTRM_TAG
{
	DHCPSTRM_TAG_VERSION =		            XFER_TAG(1, XFER_DWORD),
	DHCPSTRM_TAG_VERSIONADMIN =	            XFER_TAG(2, XFER_LARGEINTEGER),
    DHCPSTRM_TAB_SNAPIN_NAME =              XFER_TAG(3, XFER_STRING),
    DHCPSTRM_TAG_SERVER_IP =		        XFER_TAG(4, XFER_STRING_ARRAY),
	DHCPSTRM_TAG_SERVER_NAME =		        XFER_TAG(5, XFER_STRING_ARRAY),
	DHCPSTRM_TAG_SERVER_OPTIONS =	        XFER_TAG(6, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_SERVER_REFRESH_INTERVAL =	XFER_TAG(7, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_COLUMN_INFO =				XFER_TAG(8, XFER_DWORD_ARRAY),
	DHCPSTRM_TAG_SNAPIN_OPTIONS =		    XFER_TAG(9, XFER_DWORD)
};

/////////////////////////////////////////////////////////////////////////////
// CDhcpComponentData

class CDhcpComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
	
BEGIN_COM_MAP(CDhcpComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet2)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CDhcpComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
	SPITFSNode		m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CDhcpComponent
class CDhcpComponent : 
	public TFSComponent
{
public:
	CDhcpComponent();
	~CDhcpComponent();

	STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param); 
    STDMETHOD(QueryDataObject)(MMC_COOKIE           cookie, 
                               DATA_OBJECT_TYPES    type,
                               LPDATAOBJECT*        ppDataObject);
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
    CBitmap*			m_pbmpToolbar;  // Imagelist for toolbar
};

/*---------------------------------------------------------------------------
	This is how the DHCP snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the 
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CDhcpComponentDataPrimary : public CDhcpComponentData,
	public CComCoClass<CDhcpComponentDataPrimary, &CLSID_DhcpSnapin>
{
public:
	DECLARE_REGISTRY(CDhcpComponentDataPrimary, 
					 _T("DhcpSnapin.DhcpSnapin.1"), 
					 _T("DhcpSnapin.DhcpSnapin"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

	STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_DhcpSnapin; }
};


class CDhcpComponentDataExtension : public CDhcpComponentData,
    public CComCoClass<CDhcpComponentDataExtension, &CLSID_DhcpSnapinExtension>
{
public:
	DECLARE_REGISTRY(CDhcpComponentDataExtension, 
					 _T("DhcpSnapinExtension.DhcpSnapinExtension.1"), 
					 _T("DhcpSnapinExtension.DhcpSnapinExtension"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_DhcpSnapinExtension; }
};


/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CDhcpAbout : 
	public CAbout,
    public CComCoClass<CDhcpAbout, &CLSID_DhcpSnapinAbout>
{
public:
DECLARE_REGISTRY(CDhcpAbout, _T("DhcpSnapin.About.1"), 
							 _T("DhcpSnapin.About"), 
							 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CDhcpAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CDhcpAbout)

STDMETHODIMP GetSnapinVersion (LPOLESTR *lpVersion)
{
   CString version(LVER_PRODUCTVERSION_STR);

   *lpVersion = (LPOLESTR)CoTaskMemAlloc(( version.GetLength() + 1 ) * sizeof( WCHAR ));

   if ( *lpVersion == NULL )
   {
      return E_OUTOFMEMORY;
   }

   wcscpy( *lpVersion, ( LPCWSTR ) version );

   return S_OK;
}

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return 0; }
	virtual UINT GetAboutIconId()		 { return IDI_DHCP_SNAPIN; }

	virtual UINT GetSmallRootId()		 { return IDB_ROOT_SMALL; }
	virtual UINT GetSmallOpenRootId()	 { return IDB_ROOT_SMALL; }
	virtual UINT GetLargeRootId()		 { return IDB_ROOT_LARGE; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 


};
    
#endif _DHCPCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcpsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        dhcpsnap.cpp
                DHCP snapin entry points/registration functions
                
                Note: Proxy/Stub Information
                        To build a separate proxy/stub DLL, 
                        run nmake -f Snapinps.mak in the project directory.

        FILE HISTORY:
        
*/

#include "stdafx.h"
#include "initguid.h"
#include "dhcpcomp.h"
#include "classed.h"
#include "ncglobal.h"  // network console global defines
#include "cmptrmgr.h"  // computer management snapin NODETYPE
#include "ipaddr.h"
#include "locale.h"    // setlocall function call

#include <ntverp.h>

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
        OBJECT_ENTRY(CLSID_DhcpSnapin, CDhcpComponentDataPrimary)
        OBJECT_ENTRY(CLSID_DhcpSnapinExtension, CDhcpComponentDataExtension)
        OBJECT_ENTRY(CLSID_DhcpSnapinAbout, CDhcpAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CDhcpSnapinApp
//
BEGIN_MESSAGE_MAP(CDhcpSnapinApp, CWinApp)
    //{{AFX_MSG_MAP(CDhcpSnapinApp)
    //ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    //ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    //ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    //ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpFinder)
    ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()

CDhcpSnapinApp theApp;

BOOL CDhcpSnapinApp::InitInstance()
{
        _Module.Init(ObjectMap, m_hInstance);

    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;
        
    // register the window class for the hex editor (class ID)
    ::RegisterHexEditClass(m_hInstance);

    //
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
                Trace0("InitInstance: Winsock initialized!\n");
    }
        else
        {
                m_bWinsockInited = FALSE;
        }

    // set the default locale for the c runtime to system locale
    setlocale(LC_ALL, "");

        ::IPAddrInit(m_hInstance);
        return CWinApp::InitInstance();
}

int CDhcpSnapinApp::ExitInstance()
{
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNTS;

    //
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

        return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
     AFX_MANAGE_STATE(AfxGetStaticModuleState());
     
     //
     // registers object, typelib and all interfaces in typelib
     //
     HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
     ASSERT(SUCCEEDED(hr));
     
     if (FAILED(hr))
       return hr;
    
    CString strDesc, strExtDesc, strRootDesc, strVersion;
    CString strIndirect, strPrefix;

    strPrefix = L"@dhcpsnap.dll,-";
    strDesc.LoadString(IDS_SNAPIN_DESC);
    strExtDesc.LoadString(IDS_SNAPIN_EXTENSION_DESC);
    strRootDesc.LoadString(IDS_ROOT_DESC);
    strVersion = LVER_PRODUCTVERSION_STRING;

    //
    // register the snapin into the console snapin list
    // Register CLSID_DhcpSnapin as Standalone, so that it
    // shows up in the MMC available snapins list.
    //
    strIndirect.Format( L"%ws%u", strPrefix, IDS_SNAPIN_DESC );
    hr = RegisterSnapinGUID( &CLSID_DhcpSnapin, 
                             &GUID_DhcpRootNodeType, 
                             &CLSID_DhcpSnapinAbout,
                             strDesc, 
                             strVersion,
                             TRUE,         // Standalone
                             strIndirect );
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
      return hr;
    
    strIndirect.Format( L"%ws%u", strPrefix, IDS_SNAPIN_EXTENSION_DESC );
    hr = RegisterSnapinGUID( &CLSID_DhcpSnapinExtension, 
                             NULL, 
                             &CLSID_DhcpSnapinAbout,
                             strExtDesc, 
                             strVersion, 
                             FALSE,
                             strIndirect );
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
                return hr;
    
    
    //
    // register the snapin nodes into the console node list
    //
    hr = RegisterNodeTypeGUID( &CLSID_DhcpSnapin, 
                               &GUID_DhcpRootNodeType, 
                               strRootDesc );
    ASSERT(SUCCEEDED(hr));
    
#ifdef  __NETWORK_CONSOLE__
    
    hr = RegisterAsRequiredExtensionGUID( &GUID_NetConsRootNodeType, 
                                          &CLSID_DhcpSnapinExtension,
                                          strExtDesc,
                                          EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                          &CLSID_DhcpSnapinExtension );  // doesn't matter what this is,
    // just needs to be non-null
    ASSERT(SUCCEEDED(hr));
    
#endif
    // extending computer management snapin
    hr = RegisterAsRequiredExtensionGUID( &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                          &CLSID_DhcpSnapinExtension,
                                          strExtDesc,
                                          EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                          &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS );  // doesn't matter what this is
    // just needs to be non-null
        ASSERT(SUCCEEDED(hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
        HRESULT hr  = _Module.UnregisterServer();
        ASSERT(SUCCEEDED(hr));
        
        if (FAILED(hr))
                return hr;
        
        // un register the snapin 
        //
        hr = UnregisterSnapinGUID(&CLSID_DhcpSnapin);
        ASSERT(SUCCEEDED(hr));
        
        if (FAILED(hr))
                return hr;

        hr = UnregisterSnapinGUID(&CLSID_DhcpSnapinExtension);
        ASSERT(SUCCEEDED(hr));
        
        if (FAILED(hr))
                return hr;
    
    // unregister the snapin nodes 
        //
        hr = UnregisterNodeTypeGUID(&GUID_DhcpRootNodeType);
        
        ASSERT(SUCCEEDED(hr));
        
#ifdef  __NETWORK_CONSOLE__
        hr = UnregisterAsExtensionGUID(&GUID_NetConsRootNodeType, 
                                   &CLSID_DhcpSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
#endif  
        hr = UnregisterAsExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                   &CLSID_DhcpSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);

    DEBUG_VERIFY_INSTANCE_COUNT(CTaskList);
    DEBUG_VERIFY_INSTANCE_COUNT(CDhcpActiveLease);

    DEBUG_VERIFY_INSTANCE_COUNT(CDhcpOptionItem);
    DEBUG_VERIFY_INSTANCE_COUNT(COptionsConfig);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcphand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        dhcphand.h
                Header file for dhcp specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _DHCPHAND_H
#define _DHCPHAND_H

#define DHCP_IP_ADDRESS_INVALID  ((DHCP_IP_ADDRESS)0)

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

#include <atlcom.h>
#include <atlbase.h>

class CClassInfoArray;
class COptionValueEnum;

class CToolbarInfo
{
public:
    CToolbarInfo() : fSelected(FALSE) {};
    SPITFSNode  spNode;
    BOOL        fSelected;
};

/*---------------------------------------------------------------------------
        Class:  CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
    virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
    LPCTSTR GetDisplayName() { return m_strDisplayName; }
    void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
    CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
        Class:  CDhcpHandler
 ---------------------------------------------------------------------------*/
class CDhcpHandler : 
        public CHandler,
        public CHandlerEx
{
public:
    CDhcpHandler(ITFSComponentData *pCompData) 
        : CHandler(pCompData), 
          m_verbDefault(MMC_VERB_OPEN) {};
    ~CDhcpHandler() {};
    
    // base handler virtual function over-rides
    virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
    
    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    
    // Toolbar functionality        
    OVERRIDE_NodeHandler_UserNotify();
    OVERRIDE_ResultHandler_UserResultNotify();
    
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    // menu stuff
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, 
                               LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE cookie, 
                             LPDATAOBJECT pDataObject, 
                             LPCONTEXTMENUCALLBACK pContextMenuCallback,
                             long * pInsertionAllowed);

    // toolbar stuff
    virtual HRESULT OnControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnResultControlbarNotify(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    virtual HRESULT OnToolbarButtonClick(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);

    void EnableToolbar(LPTOOLBAR        pToolbar, 
                       MMCBUTTON        rgSnapinButtons[], 
                       int              nRgSize,
                       MMC_BUTTON_STATE ButtonState[],
                       BOOL             bState = TRUE);

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

    virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);

public:
    // This is the default verb, by default it is set to MMC_VERB_OPEN
        MMC_CONSOLE_VERB        m_verbDefault;
};

/*---------------------------------------------------------------------------
        Class:  CMTDhcpHandler
 ---------------------------------------------------------------------------*/
class CMTDhcpHandler :
                public CMTHandler,
                public CHandlerEx /*,
                                    public IResultDataCompareEx */
{
public:

//     BEGIN_COM_MAP( CMTDhcpHandler )
//         COM_INTERFACE_ENTRY( IResultDataCompareEx )
//         COM_INTERFACE_ENTRY( IDispatch )
//     END_COM_MAP()

    // enumeration for node states, to handle icon changes
    typedef enum
    {
        notLoaded = 0, // initial state, valid only if server never contacted
        loading,
        loaded,
        unableToLoad
    } nodeStateType;

    CMTDhcpHandler(ITFSComponentData *pCompData) 
        : CMTHandler(pCompData), 
          m_verbDefault(MMC_VERB_OPEN),
          m_bSelected(FALSE),
          m_fSilent(FALSE),
          m_fExpandSync(FALSE)
    {  m_nState = notLoaded; }
    
        ~CMTDhcpHandler() {};
    
    // base handler virtual function over-rides
    virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    OVERRIDE_BaseHandlerNotify_OnExpandSync();
    
    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Toolbar functionality        
    OVERRIDE_NodeHandler_UserNotify();
    OVERRIDE_ResultHandler_UserResultNotify();


    OVERRIDE_NodeHandler_DestroyHandler();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    virtual HRESULT OnControlbarNotify( ITFSNode * pNode, 
                                        LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnResultControlbarNotify( ITFSNode * pNode,
                                              LPDHCPTOOLBARNOTIFY pToolbarNotify);

    virtual HRESULT OnToolbarButtonClick( ITFSNode * pNode,
                                          LPDHCPTOOLBARNOTIFY pToolbarNotify);
    virtual HRESULT OnUpdateToolbarButtons( ITFSNode * pNode,
                                            LPDHCPTOOLBARNOTIFY pToolbarNotify);

    // menu stuff
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    HRESULT HandleScopeCommand( MMC_COOKIE cookie, int nCommandID,
                                LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus( MMC_COOKIE  cookie, LPDATAOBJECT pDataObject, 
                              LPCONTEXTMENUCALLBACK pContextMenuCallback, 
                              long * pInsertionAllowed);

    void EnableToolbar(LPTOOLBAR        pToolbar, 
                       MMCBUTTON        rgSnapinButtons[], 
                       int              nRgSize,
                       MMC_BUTTON_STATE ButtonState[],
                       BOOL             Enable[]);

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
    
    // for statistics notification
    HRESULT OnRefreshStats(ITFSNode *   pNode,
                           LPDATAOBJECT pDataObject,
                           DWORD                dwType,
                           LPARAM               arg,
                           LPARAM               param);
    virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
    HRESULT OnResultUpdateOptions(ITFSComponent *     pComponent,
                                  ITFSNode *          pNode,
                                  CClassInfoArray *   pClassInfoArray,
                                  COptionValueEnum *  aEnum[],
                                  int                 aImages[],
                                  int                 nCount);
    
protected:
    virtual void GetErrorMessages(CString & strTitle, CString & strBody, IconIdentifier * icon);
    virtual void OnChangeState(ITFSNode* pNode);
    virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
    {
        if (pNewNode->IsContainer())
        {
            // assume all the child containers are derived from this class
            //((CDHCPMTContainer*)pNode)->SetServer(GetServer());
        }
        pParentNode->AddChild(pNewNode);
    }

    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    void    SendUpdateToolbar(ITFSNode * pNode, BOOL fSelected);
    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb,
                                       LONG_PTR dwNodeType, 
                                       BOOL bMultiSelect = FALSE);
    virtual void    UpdateToolbar(IToolbar * pToolbar, LONG_PTR dwNodeType, 
                                  BOOL bSelect);
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);
    void    ExpandNode(ITFSNode * pNode, BOOL fExpand);

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    BOOL        m_bSelected;
    BOOL        m_fSilent;
    BOOL        m_fExpandSync;

    // This is the default verb, by default it is set to MMC_VERB_OPEN
    MMC_CONSOLE_VERB        m_verbDefault;
};

/*---------------------------------------------------------------------------
        Class:  CDHCPQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CDHCPQueryObj : public CNodeQueryObject
{
public:
    CDHCPQueryObj
    (
         ITFSComponentData *     pTFSCompData, 
         ITFSNodeMgr *           pNodeMgr
     ) : m_dwErr(0)
    {
        m_spTFSCompData.Set(pTFSCompData); 
        m_spNodeMgr.Set(pNodeMgr);
    }

    CQueueDataListBase & GetQueue() { return m_dataQueue; }
    
public:
    CString                          m_strServer;
    SPITFSComponentData  m_spTFSCompData;
    SPITFSNodeMgr            m_spNodeMgr;
    DWORD                            m_dwErr;
};

#endif _DHCPHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgbined.h ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    DLGBINED
        Binary Editor dialog    

    FILE HISTORY:

*/

#ifndef _DLGBINED_H
#define _DLGBINED_H

/////////////////////////////////////////////////////////////////////////////
// CDlgBinEd dialog

class CDlgBinEd : public CBaseDialog
{
// Construction
public:
    CDlgBinEd( CDhcpOption * pdhcType, 
           DHCP_OPTION_SCOPE_TYPE dhcScopeType,
           CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CDlgBinEd)
    enum { IDD = IDD_BINARY_EDITOR };
    CButton m_butn_hex;
    CButton m_butn_decimal;
    CStatic m_static_unit_size;
    CStatic m_static_option_name;
    CStatic m_static_application;
    CListBox    m_list_values;
    CEdit   m_edit_value;
    CButton m_butn_delete;
    CButton m_butn_add;
    CButton m_button_Up;
    CButton m_button_Down;
    //}}AFX_DATA

// Implementation
    CDhcpOption *           m_p_type ;
    DHCP_OPTION_SCOPE_TYPE  m_option_type ;
    CDWordArray             m_dw_array ;
    CDWordDWordArray        m_dwdw_array ;
    BOOL                    m_b_decimal ;
    BOOL                    m_b_changed ;

    //  Handle changes in the dialog
    void HandleActivation () ;

    //  Fill the list box
    void Fill ( INT cFocus = -1, BOOL bToggleRedraw = TRUE ) ;

    //  Convert the existing values into an array for dialog manipualation
    void FillArray () ;

    //  Safely extract the edit value.
    int GetEditValue () ;

    BOOL ConvertValue ( DWORD dwValue, CString & strValue ) ;
    BOOL ConvertValue ( DWORD_DWORD dwdwValue, CString & strValue ) ;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDlgBinEd::IDD); }

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CDlgBinEd)
    afx_msg void OnClickedRadioDecimal();
    afx_msg void OnClickedRadioHex();
    virtual BOOL OnInitDialog();
    afx_msg void OnClickedButnAdd();
    afx_msg void OnClickedButnDelete();
    afx_msg void OnClickedButnDown();
    afx_msg void OnClickedButnUp();
    afx_msg void OnSelchangeListValues();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnChangeEditValue();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif _DLGBINED_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dhcpsnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	global.h
		Global defines for the DHCP snapin


	FILE HISTORY:
        
*/

// message that gets posted to statistics windows to update their stats
#define WM_NEW_STATS_AVAILABLE  WM_USER + 100

// percentage of addresses in use to generate a warning for a scope
#define SCOPE_WARNING_LEVEL		90

// Defines for help from the help menu and F1 help for scope pane items
#define DHCPSNAP_HELP_BASE				    0xA0000000
#define DHCPSNAP_HELP_SNAPIN			    DHCPSNAP_HELP_BASE + 1
#define DHCPSNAP_HELP_ROOT				    DHCPSNAP_HELP_BASE + 2
#define DHCPSNAP_HELP_SERVER			    DHCPSNAP_HELP_BASE + 3
#define DHCPSNAP_HELP_SCOPE				    DHCPSNAP_HELP_BASE + 4
#define DHCPSNAP_HELP_SUPERSCOPE		    DHCPSNAP_HELP_BASE + 5
#define DHCPSNAP_HELP_BOOTP_TABLE		    DHCPSNAP_HELP_BASE + 6
#define DHCPSNAP_HELP_GLOBAL_OPTIONS	    DHCPSNAP_HELP_BASE + 7
#define DHCPSNAP_HELP_ADDRESS_POOL		    DHCPSNAP_HELP_BASE + 8
#define DHCPSNAP_HELP_ACTIVE_LEASES		    DHCPSNAP_HELP_BASE + 9
#define DHCPSNAP_HELP_RESERVATIONS		    DHCPSNAP_HELP_BASE + 10
#define DHCPSNAP_HELP_SCOPE_OPTIONS		    DHCPSNAP_HELP_BASE + 11
#define DHCPSNAP_HELP_RESERVATION_CLIENT	DHCPSNAP_HELP_BASE + 12
#define DHCPSNAP_HELP_ACTIVE_LEASE      	DHCPSNAP_HELP_BASE + 13
#define DHCPSNAP_HELP_ALLOCATION_RANGE	    DHCPSNAP_HELP_BASE + 14
#define DHCPSNAP_HELP_EXCLUSION_RANGE	    DHCPSNAP_HELP_BASE + 15
#define DHCPSNAP_HELP_BOOTP_ENTRY       	DHCPSNAP_HELP_BASE + 16
#define DHCPSNAP_HELP_OPTION_ITEM       	DHCPSNAP_HELP_BASE + 17
#define DHCPSNAP_HELP_CLASSID_HOLDER       	DHCPSNAP_HELP_BASE + 18
#define DHCPSNAP_HELP_CLASSID            	DHCPSNAP_HELP_BASE + 19
#define DHCPSNAP_HELP_MSCOPE            	DHCPSNAP_HELP_BASE + 20
#define DHCPSNAP_HELP_MCAST_LEASE         	DHCPSNAP_HELP_BASE + 21

// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// some defines for options that we get/set explicitly
#define MADCAP_OPTION_LEASE_TIME        1
#define OPTION_LEASE_DURATION		    51
#define OPTION_DNS_REGISTATION		    81

// HRESULT Mapping
#define WIN32_FROM_HRESULT(hr)         (0x0000FFFF & (hr))

// Dynamic DNS defines
#define DHCP_DYN_DNS_DEFAULT            DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED;

// notification and struct for toolbars
#define DHCP_MSG_CONTROLBAR_NOTIFY  100

typedef struct _DHCP_TOOLBAR_NOTIFY
{
    MMC_COOKIE       cookie;
    LPTOOLBAR        pToolbar;
    LPCONTROLBAR     pControlbar;
    MMC_NOTIFY_TYPE  event;
    LONG_PTR         id;
    BOOL             bSelect;
} DHCPTOOLBARNOTIFY, * LPDHCPTOOLBARNOTIFY;

//
//  Registry constants-- key and value names
//
#define DHCP_REG_USER_KEY_NAME _T("Software\\Microsoft\\DHCP Admin Tool")
#define DHCP_REG_VALUE_HOSTS   _T("KnownHosts")

// multicast address defines
#define MCAST_ADDRESS_MIN       0xE0000000
#define MCAST_ADDRESS_MAX       0xEFFFFFFF
#define MCAST_SCOPED_RANGE_MIN  0xEF000000
#define MCAST_SCOPED_RANGE_MIX  0xEFFFFFFF

// macro to get the handler for a node. This is a DHCP snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

// used for notifing views to update
// must not conflict with the RESULT_PANE notifications in tfsnode.h
#define DHCPSNAP_UPDATE_OPTIONS  0x10000000
#define DHCPSNAP_UPDATE_TOOLBAR  0x20000000

// Version Suff
#define DHCPSNAP_MAJOR_VERSION   0x00000001
#define DHCPSNAP_MINOR_VERSION	 0x00000000

extern LARGE_INTEGER gliDhcpsnapVersion;

#define DHCPSNAP_FILE_VERSION    0x00000002

// defines for maximum lease time entries
#define HOURS_MAX   23
#define MINUTES_MAX 59

// constants for time conversion
#define MILLISEC_PER_SECOND			1000
#define MILLISEC_PER_MINUTE			(60 * MILLISEC_PER_SECOND)
#define MILLISEC_PER_HOUR			(60 * MILLISEC_PER_MINUTE)

#define DHCPSNAP_REFRESH_INTERVAL_DEFAULT	(10 * MILLISEC_PER_MINUTE) // 10 minutes in milliseconds

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// some global defines we need
#define STRING_LENGTH_MAX		 256

#define EDIT_ARRAY_MAX			 2048
#define EDIT_STRING_MAX			 STRING_LENGTH_MAX
#define EDIT_ID_MAX				 3

// The maximum length of names supported by the server
// Typically this is the scope name, sscope name, etc.
#define MAX_NAME_LENGTH                  255

#define IP_ADDDRESS_LENGTH_MAX   16
#define DHCP_INFINIT_LEASE  0xffffffff  // Inifinite lease LONG value

// DHCP Server version defines
#define DHCP_NT4_VERSION    0x0000000400000000
#define DHCP_SP2_VERSION	0x0000000400000001
#define DHCP_NT5_VERSION	0x0000000500000000
#define DHCP_NT51_VERSION   0x0000000500000006

// Note - These are offsets into my toolbar image list
typedef enum _TOOLBAR_IMAGE_INDICIES
{
    TOOLBAR_IDX_ADD_SERVER,
	TOOLBAR_IDX_REFRESH,
	TOOLBAR_IDX_CREATE_SCOPE,
	TOOLBAR_IDX_CREATE_SUPERSCOPE,
    TOOLBAR_IDX_DEACTIVATE,
	TOOLBAR_IDX_ACTIVATE,
	TOOLBAR_IDX_ADD_BOOTP,
	TOOLBAR_IDX_ADD_RESERVATION,
	TOOLBAR_IDX_ADD_EXCLUSION,
	TOOLBAR_IDX_OPTION_GLOBAL,
	TOOLBAR_IDX_OPTION_SCOPE,
	TOOLBAR_IDX_OPTION_RESERVATION,
    TOOLBAR_IDX_MAX
} TOOLBAR_IMAGE_INDICIES, * LPTOOLBAR_IMAGE_INDICIES;

typedef enum _ICON_IMAGE_INDICIES
{
    ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN,
    ICON_IDX_ACTIVE_LEASES_LEAF,
    ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED,
    ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY,
    ICON_IDX_ACTIVE_LEASES_LEAF_BUSY,
    ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY,
    ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_ACTIVE_LEASES_LEAF_LOST_CONNECTION,
    ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_ADDR_POOL_FOLDER_OPEN,
    ICON_IDX_ADDR_POOL_LEAF,                                //10
    ICON_IDX_ADDR_POOL_FOLDER_CLOSED,
    ICON_IDX_ADDR_POOL_FOLDER_OPEN_BUSY,
    ICON_IDX_ADDR_POOL_LEAF_BUSY,
    ICON_IDX_ADDR_POOL_FOLDER_CLOSED_BUSY,
    ICON_IDX_ADDR_POOL_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_ADDR_POOL_LEAF_LOST_CONNECTION,
    ICON_IDX_ADDR_POOL_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_ALLOCATION_RANGE,
    ICON_IDX_BOOTP_ENTRY,
	ICON_IDX_BOOTP_TABLE_CLOSED,							//20
	ICON_IDX_BOOTP_TABLE_OPEN,
	ICON_IDX_BOOTP_TABLE_CLOSED_BUSY,
	ICON_IDX_BOOTP_TABLE_OPEN_BUSY,
	ICON_IDX_BOOTP_TABLE_CLOSED_LOST_CONNECTION,
	ICON_IDX_BOOTP_TABLE_OPEN_LOST_CONNECTION,
    ICON_IDX_CLIENT,
    ICON_IDX_CLIENT_DNS_REGISTERING,
    ICON_IDX_CLIENT_EXPIRED,
    ICON_IDX_CLIENT_RAS,
    ICON_IDX_CLIENT_OPTION_FOLDER_OPEN,						//30
    ICON_IDX_CLIENT_OPTION_LEAF,
    ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED,
    ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_BUSY,
    ICON_IDX_CLIENT_OPTION_LEAF_BUSY,                       
    ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_BUSY,
    ICON_IDX_CLIENT_OPTION_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_CLIENT_OPTION_LEAF_LOST_CONNECTION,
    ICON_IDX_CLIENT_OPTION_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_EXCLUSION_RANGE,
    ICON_IDX_FOLDER_CLOSED,									//40
    ICON_IDX_FOLDER_OPEN,
    ICON_IDX_RES_CLIENT,
    ICON_IDX_RES_CLIENT_BUSY,
    ICON_IDX_RES_CLIENT_LOST_CONNECTION,                    
    ICON_IDX_RESERVATIONS_FOLDER_OPEN,
    ICON_IDX_RESERVATIONS_FOLDER_CLOSED,
    ICON_IDX_RESERVATIONS_FOLDER_OPEN_BUSY,
    ICON_IDX_RESERVATIONS_FOLDER_CLOSED_BUSY,
	ICON_IDX_RESERVATIONS_FOLDER_OPEN_LOST_CONNECTION,		
    ICON_IDX_RESERVATIONS_FOLDER_CLOSED_LOST_CONNECTION,	//50
    ICON_IDX_SCOPE_OPTION_FOLDER_OPEN,
    ICON_IDX_SCOPE_OPTION_LEAF,
    ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED,
    ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_BUSY,                 
    ICON_IDX_SCOPE_OPTION_LEAF_BUSY,
    ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_BUSY,
    ICON_IDX_SCOPE_OPTION_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_SCOPE_OPTION_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_SCOPE_OPTION_LEAF_LOST_CONNECTION,				
    ICON_IDX_SERVER,										//60
    ICON_IDX_SERVER_ALERT,
    ICON_IDX_SERVER_BUSY,
    ICON_IDX_SERVER_CONNECTED,
    ICON_IDX_SERVER_GROUP,                                  
    ICON_IDX_SERVER_ROGUE,
    ICON_IDX_SERVER_LOST_CONNECTION,
    ICON_IDX_SERVER_NO_ACCESS,
    ICON_IDX_SERVER_WARNING,
    ICON_IDX_SERVER_OPTION_FOLDER_OPEN,						
    ICON_IDX_SERVER_OPTION_LEAF,							//70
    ICON_IDX_SERVER_OPTION_FOLDER_CLOSED,
    ICON_IDX_SERVER_OPTION_FOLDER_OPEN_BUSY,
    ICON_IDX_SERVER_OPTION_LEAF_BUSY,
    ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_BUSY,              
    ICON_IDX_SERVER_OPTION_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_SERVER_OPTION_LEAF_LOST_CONNECTION,
    ICON_IDX_SERVER_OPTION_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_SCOPE_FOLDER_OPEN,
    ICON_IDX_SCOPE_FOLDER_OPEN_BUSY,
	ICON_IDX_SCOPE_FOLDER_CLOSED_BUSY,						//80
    ICON_IDX_SCOPE_FOLDER_OPEN_WARNING,						
    ICON_IDX_SCOPE_FOLDER_CLOSED_WARNING,					
    ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_SCOPE_FOLDER_OPEN_ALERT,
    ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN,                    
    ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED,
    ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION,
    ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION,
    ICON_IDX_SCOPE_FOLDER_CLOSED,							//90
    ICON_IDX_SCOPE_FOLDER_CLOSED_ALERT,						
	ICON_IDX_APPLICATION,									
    ICON_IDX_MAX
} ICON_IMAGE_INDICIES, * LPICON_IMAGE_INDICIES; 

// Constants used in for column information
const int MAX_COLUMNS = 7;
const int NUM_CONSOLE_VERBS = 8;
const int NUM_SCOPE_ITEMS = 14;

// Sample folder types
enum NODETYPES
{
// scope pane items
    DHCPSNAP_ROOT,
    DHCPSNAP_SERVER,
	DHCPSNAP_BOOTP_TABLE,
    DHCPSNAP_SUPERSCOPE,
    DHCPSNAP_SCOPE,
    DHCPSNAP_MSCOPE,
    DHCPSNAP_ADDRESS_POOL,
    DHCPSNAP_ACTIVE_LEASES,
    DHCPSNAP_MSCOPE_LEASES,
    DHCPSNAP_RESERVATIONS,
    DHCPSNAP_RESERVATION_CLIENT,
    DHCPSNAP_SCOPE_OPTIONS,
    DHCPSNAP_GLOBAL_OPTIONS,
    DHCPSNAP_CLASSID_HOLDER,
    
// result pane items
    DHCPSNAP_ACTIVE_LEASE,
    DHCPSNAP_ALLOCATION_RANGE,
    DHCPSNAP_EXCLUSION_RANGE,
    DHCPSNAP_BOOTP_ENTRY,
    DHCPSNAP_OPTION_ITEM,
    DHCPSNAP_CLASSID,
    DHCPSNAP_MCAST_LEASE,
    DHCPSNAP_NODETYPE_MAX
};

//  GUIDs are defined in guids.cpp
extern const CLSID      CLSID_DhcpSnapin;					// In-Proc server GUID
extern const CLSID      CLSID_DhcpSnapinExtension;			// In-Proc server GUID
extern const CLSID      CLSID_DhcpSnapinAbout;				// In-Proc server GUID
extern const GUID       GUID_DhcpRootNodeType;				// Root NodeType GUID 
extern const GUID       GUID_DhcpServerNodeType;			// Server NodeType GUID
extern const GUID       GUID_DhcpScopeNodeType;				// Scope NodeType GUID
extern const GUID       GUID_DhcpMScopeNodeType;		    // MScope NodeType GUID
extern const GUID       GUID_DhcpBootpNodeType;				// Bootp NodeType GUID
extern const GUID       GUID_DhcpGlobalOptionsNodeType;     // GlobalOptions NodeType GUID
extern const GUID       GUID_DhcpClassIdHolderNodeType;     // ClassId Scope NodeType GUID
extern const GUID       GUID_DhcpSuperscopeNodeType;        // Superscope NodeType GUID
extern const GUID       GUID_DhcpAddressPoolNodeType;       // AddressPool NodeType GUID
extern const GUID       GUID_DhcpActiveLeasesNodeType;      // ActiveLeases NodeType GUID
extern const GUID       GUID_DhcpReservationsNodeType;      // Reservations NodeType GUID
extern const GUID       GUID_DhcpScopeOptionsNodeType;      // ScopeOptions NodeType GUID
extern const GUID       GUID_DhcpReservationClientNodeType; // Reservation Client NodeType GUID
extern const GUID       GUID_DhcpAllocationNodeType;		// Allocation range NodeType GUID 
extern const GUID       GUID_DhcpExclusionNodeType;			// Exlusion range NodeType GUID 
extern const GUID       GUID_DhcpBootpEntryNodeType;		// BootpEntry NodeType GUID 
extern const GUID       GUID_DhcpActiveLeaseNodeType;		// ActiveLease NodeType GUID 
extern const GUID       GUID_DhcpOptionNodeType;			// Option NodeType GUID 
extern const GUID       GUID_DhcpClassIdNodeType;			// ClassId (result pane) NodeType GUID 
extern const GUID       GUID_DhcpMCastLeaseNodeType;    	// Multicast lease (result pane) NodeType GUID 
extern const GUID       GUID_DhcpMCastAddressPoolNodeType;  // AddressPool NodeType GUID (multicast scope)
extern const GUID       GUID_DhcpMCastActiveLeasesNodeType; // ActiveLeases NodeType GUID (multicast scope)

// arrays used to hold all of the result pane column information
extern UINT aColumns[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[DHCPSNAP_NODETYPE_MAX][MAX_COLUMNS];

// arrays for toolbar information
extern MMCBUTTON        g_SnapinButtons[TOOLBAR_IDX_MAX];
extern int              g_SnapinButtonStrings[TOOLBAR_IDX_MAX][2];
extern MMC_BUTTON_STATE g_SnapinButtonStates[DHCPSNAP_NODETYPE_MAX][TOOLBAR_IDX_MAX];

// arrays for console verbs
extern MMC_CONSOLE_VERB g_ConsoleVerbs[NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[DHCPSNAP_NODETYPE_MAX][NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[DHCPSNAP_NODETYPE_MAX][NUM_CONSOLE_VERBS];

// array for help
extern DWORD g_dwMMCHelp[DHCPSNAP_NODETYPE_MAX];

// icon image map
extern UINT g_uIconMap[ICON_IDX_MAX + 1][2];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

// CDhcpSnapinApp definition
class CDhcpSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

    DECLARE_MESSAGE_MAP()

public:
	BOOL m_bWinsockInited;
};

extern CDhcpSnapinApp theApp;

// help stuff here
typedef CMap<UINT, UINT, DWORD *, DWORD *> CDhcpContextHelpMap;
extern CDhcpContextHelpMap g_dhcpContextHelpMap;

#define DHCPSNAP_NUM_HELP_MAPS  41

extern DWORD * DhcpGetHelpMap(UINT uID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgbined.cpp ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    DLGBINED
        Binary Editor dialog    

    FILE HISTORY:

*/

#include "stdafx.h"
#include "dlgbined.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDlgBinEd dialog

CDlgBinEd::CDlgBinEd
(
   CDhcpOption * pdhcType,
   DHCP_OPTION_SCOPE_TYPE dhcScopeType,
   CWnd* pParent /*=NULL*/
)
   : CBaseDialog(CDlgBinEd::IDD, pParent),
     m_p_type( pdhcType ),
     m_b_decimal( TRUE ),
     m_b_changed( FALSE ),
     m_option_type( dhcScopeType )
{
    //{{AFX_DATA_INIT(CDlgBinEd)
    //}}AFX_DATA_INIT

    ASSERT( m_p_type != NULL ) ;
}

void 
CDlgBinEd::DoDataExchange
(
    CDataExchange* pDX
)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgBinEd)
    DDX_Control(pDX, IDC_RADIO_HEX, m_butn_hex);
    DDX_Control(pDX, IDC_RADIO_DECIMAL, m_butn_decimal);
    DDX_Control(pDX, IDC_STATIC_UNIT_SIZE, m_static_unit_size);
    DDX_Control(pDX, IDC_STATIC_OPTION_NAME, m_static_option_name);
    DDX_Control(pDX, IDC_STATIC_APPLICATION, m_static_application);
    DDX_Control(pDX, IDC_LIST_VALUES, m_list_values);
    DDX_Control(pDX, IDC_EDIT_VALUE, m_edit_value);
    DDX_Control(pDX, IDC_BUTN_DELETE, m_butn_delete);
    DDX_Control(pDX, IDC_BUTN_ADD, m_butn_add);
    DDX_Control(pDX, IDC_BUTN_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTN_DOWN, m_button_Down);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgBinEd, CBaseDialog)
    //{{AFX_MSG_MAP(CDlgBinEd)
    ON_BN_CLICKED(IDC_RADIO_DECIMAL, OnClickedRadioDecimal)
    ON_BN_CLICKED(IDC_RADIO_HEX, OnClickedRadioHex)
    ON_BN_CLICKED(IDC_BUTN_ADD, OnClickedButnAdd)
    ON_BN_CLICKED(IDC_BUTN_DELETE, OnClickedButnDelete)
    ON_BN_CLICKED(IDC_BUTN_DOWN, OnClickedButnDown)
    ON_BN_CLICKED(IDC_BUTN_UP, OnClickedButnUp)
    ON_LBN_SELCHANGE(IDC_LIST_VALUES, OnSelchangeListValues)
    ON_EN_CHANGE(IDC_EDIT_VALUE, OnChangeEditValue)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgBinEd message handlers

BOOL 
CDlgBinEd::OnInitDialog()
{
    CBaseDialog::OnInitDialog();
    CString str ;
    CString strNum ;
    DWORD err = 0 ;
    int cUnitSize = 1 ;
    int cStrId = m_option_type == DhcpDefaultOptions
           ? IDS_INFO_TITLE_DEFAULT_OPTIONS
           : (m_option_type == DhcpGlobalOptions
                        ? IDS_INFO_TITLE_GLOBAL_OPTIONS
                        : IDS_INFO_TITLE_SCOPE_OPTIONS  ) ;

    switch ( m_p_type->QueryValue().QueryDataType() )
    {
        case DhcpWordOption:
            cUnitSize = 2 ;
            break ;

        case DhcpDWordOption:
            cUnitSize = 4 ;
            break ;

        case DhcpDWordDWordOption:
            cUnitSize = 8 ;
            break ;
    }

    CATCH_MEM_EXCEPTION
    {

        strNum.Format(_T("%d"), cUnitSize);
        m_static_unit_size.SetWindowText( strNum ) ;

        m_static_option_name.SetWindowText( m_p_type->QueryName() ) ;

        str.LoadString( cStrId ) ;
        m_static_application.SetWindowText( str ) ;

        //
        //  Fill the internal list from the current value.
        //
        FillArray() ;
        Fill( 0, TRUE ) ;

        //
        //  Set focus on the new value edit control.
        //
        m_edit_value.SetFocus() ;
        m_edit_value.SetModify( FALSE );

        //
        //  Fiddle with the buttons.
        //
        HandleActivation() ;
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
        EndDialog(-1);
    }
    return FALSE;  // return TRUE  unless you set the focus to a control
} // CDlgBinEd::OnInitDialog()

//
//  Convert the existing values into an array for dialog manipualation
//
void 
CDlgBinEd::FillArray()
{
    //
    //  Fill the internal list from the current value.
    //
    INT cMax;
    DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

	switch ( optionType )
    {
        case DhcpBinaryDataOption :
        case DhcpEncapsulatedDataOption :
            cMax = (INT)m_p_type->QueryValue().QueryBinaryArray()->GetSize() ;
            break;

        default:
            cMax = (INT)m_p_type->QueryValue().QueryUpperBound() ;
            break;
    }

    for ( INT i = 0 ; i < cMax ; i++ )
    {
        if (optionType == DhcpDWordDWordOption)
        {
            m_dwdw_array.SetAtGrow( i, m_p_type->QueryValue().QueryDwordDword( i ) ) ;
        }
        else
        {
            m_dw_array.SetAtGrow( i, (DWORD) m_p_type->QueryValue().QueryNumber( i ) ) ;
        }
    }
}

BOOL 
CDlgBinEd :: ConvertValue 
( 
    DWORD dwValue, 
    CString & strValue 
)
{
    const TCHAR * pszMaskHex = _T("%#x");
    const TCHAR * pszMaskDec = _T("%u");
    const TCHAR * pszMask = m_b_decimal
                 ? pszMaskDec
                 : pszMaskHex;
    TCHAR szNum [ STRING_LENGTH_MAX ] ;

    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        ::wsprintf( szNum, pszMask, dwValue ) ;
        strValue = szNum ;
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }
    
	return err == 0 ;
}

BOOL 
CDlgBinEd :: ConvertValue 
( 
    DWORD_DWORD dwdwValue, 
    CString &   strValue 
)
{
    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        ::UtilConvertDwordDwordToString(&dwdwValue, &strValue, m_b_decimal);
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }
    
	return err == 0 ;
}

//
//  Fill the list box
//
void 
CDlgBinEd::Fill 
( 
    INT cFocus, 
    BOOL bToggleRedraw 
)
{
    if ( bToggleRedraw )
    {
        m_list_values.SetRedraw( FALSE ) ;
    }

    m_list_values.ResetContent() ;

    CString strValue ;
    DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();
    INT cMax = (INT)((optionType == DhcpDWordDWordOption)
		     ? m_dwdw_array.GetSize()
		     : m_dw_array.GetSize());
    INT i ;
    DWORD_DWORD LongIntValue;
    DWORD       LongValue;

    for ( i = 0 ; i < cMax ; i++ )
    {
        switch (optionType)
        {
            case DhcpDWordDWordOption:
                if ( ! ConvertValue( m_dwdw_array.GetAt( i ), strValue ) )
                {
                    continue ;
                }
                break;

            default:
                if ( ! ConvertValue( m_dw_array.GetAt( i ), strValue ) )
                {
                    continue ;
                }
                break;
        }

        m_list_values.AddString( strValue ) ;
    }

    if ( cFocus >= 0 && cFocus < cMax )
    {
        m_list_values.SetCurSel( cFocus ) ;
    }
    else {
	m_list_values.SetCurSel( 0 );
    }

    if ( bToggleRedraw )
    {
        m_list_values.SetRedraw( TRUE ) ;
        m_list_values.Invalidate() ;
    }

    // convert the value being edited
    m_edit_value.GetWindowText( strValue );
    if ( !strValue.IsEmpty()) {
	DWORD maxVal;

	if ( DhcpByteOption == optionType ) {
	    maxVal = 0xff;
	}
	else  if ( DhcpWordOption == optionType ) {
			maxVal = 0xffff;
	}
	else {
	    maxVal = 0xffffffff;
	}
	
	if ( DhcpDWordDWordOption == optionType ) {
	    UtilConvertStringToDwordDword( strValue, &LongIntValue );
	    UtilConvertDwordDwordToString( &LongIntValue, &strValue,
					   m_b_decimal );
	}
	else {
	    FGetCtrlDWordValue( m_edit_value.GetSafeHwnd(), &LongValue,
				0, maxVal );
	    ConvertValue( LongValue, strValue );
	}

	m_edit_value.SetWindowText( strValue );
    } // if
} // CDlgBinEd::Fill()

//
//  Handle changes in the dialog
//
void 
CDlgBinEd::HandleActivation()
{
    INT cSel = m_list_values.GetCurSel();
    INT cMax = (m_p_type->QueryValue().QueryDataType() == DhcpDWordDWordOption)
	? (INT)m_dwdw_array.GetSize()
	: (INT)m_dw_array.GetSize() ;

    BOOL bModified = m_edit_value.GetWindowTextLength() > 0;

    m_button_Up.EnableWindow( cSel >= 1 ) ;
    m_button_Down.EnableWindow( cSel + 1 < cMax ) ;
    m_butn_add.EnableWindow( bModified ) ;
    m_butn_delete.EnableWindow( cSel >= 0 ) ;
    m_butn_hex.SetCheck( m_b_decimal == 0 ) ;
    m_butn_decimal.SetCheck( m_b_decimal > 0 ) ;

    // check if the focus in on a disabled control
    // If yes, put the focus back to list box
    if ( !::IsWindowEnabled( ::GetFocus())) {
        m_list_values.SetFocus();
    }

} // CDlgBinEd::HandleActivation()

void 
CDlgBinEd::OnClickedRadioDecimal()
{
    m_b_decimal = TRUE ;
    Fill() ;
    HandleActivation() ;
}

void 
CDlgBinEd::OnClickedRadioHex()
{
    m_b_decimal = FALSE ;
    Fill() ;
    HandleActivation() ;
}


void 
CDlgBinEd::OnClickedButnAdd()
{
    INT             cFocus = m_list_values.GetCurSel() ;
    DWORD           dwValue;
    DWORD_DWORD     dwdw;
    DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

    DWORD dwMask = 0xFFFFFFFF ;
    ASSERT(m_p_type);
    
	switch ( optionType )
    {
        case DhcpBinaryDataOption :
        case DhcpEncapsulatedDataOption :
        case DhcpByteOption:
            dwMask = 0xFF ;
            break ;
    
		case DhcpWordOption:
            dwMask = 0xFFFF ;
            break ;
    } // switch
    
    if (optionType == DhcpDWordDWordOption)
    {
        CString         strValue;

        m_edit_value.GetWindowText(strValue);

        UtilConvertStringToDwordDword(strValue, &dwdw);
    }
    else
    {
	    if (!FGetCtrlDWordValue(m_edit_value.m_hWnd, &dwValue, 0, dwMask))
            return;
    }

    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        if ( cFocus < 0 )
        {
            cFocus = 0 ;
        }

        (optionType == DhcpDWordDWordOption) ? 
            m_dwdw_array.InsertAt( cFocus, dwdw ) : m_dw_array.InsertAt( cFocus, dwValue ) ;
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
    }
    else
    {
        m_b_changed = TRUE ;
    }

    //
    // Refill listbox, update controls. clear the edit control
    //
    m_edit_value.SetWindowText(_T(""));
    m_edit_value.SetFocus();
    Fill( cFocus ) ;
    HandleActivation() ;

} // CDlgBinEd::OnClickedButnAdd()

void 
CDlgBinEd::OnClickedButnDelete()
{
    INT cFocus = m_list_values.GetCurSel() ;

    if ( cFocus < 0 )
    {
        return ;
    }

    DWORD err = 0 ;
    CString strValue ;
    DWORD dwValue;
    DWORD_DWORD dwdw;
    DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

    CATCH_MEM_EXCEPTION
    {
        if (optionType == DhcpDWordDWordOption) 
        {
            dwdw = m_dwdw_array.GetAt( cFocus ) ;
            m_dwdw_array.RemoveAt( cFocus ) ;
            ConvertValue( dwdw, strValue ) ;
        }
        else
        {
            dwValue = m_dw_array.GetAt( cFocus ) ;
            m_dw_array.RemoveAt( cFocus ) ;
            ConvertValue( dwValue, strValue ) ;
        }

    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }
    else
    {
        m_b_changed = TRUE ;
    }

    cFocus--;
    if ( cFocus < 0 ) {
	cFocus = 0;
    }
    m_edit_value.SetWindowText( strValue ) ;
    m_edit_value.SetFocus();
    Fill( cFocus ) ;
    HandleActivation() ;
}

void 
CDlgBinEd::OnClickedButnDown()
{
   INT cFocus = m_list_values.GetCurSel() ;
   INT cItems = m_list_values.GetCount() ;

   if ( cFocus < 0 || cFocus + 1 >= cItems )
   {
        return ;
   }

   DWORD dwValue ;
   DWORD err = 0 ;
   DWORD_DWORD dwdw;
   DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

   CATCH_MEM_EXCEPTION
   {
        if (optionType == DhcpDWordDWordOption) 
        {
            dwdw = m_dwdw_array.GetAt( cFocus ) ;
            m_dwdw_array.RemoveAt( cFocus ) ;
            m_dwdw_array.InsertAt( cFocus + 1, dwdw ) ;
        }
        else
        {
            dwValue = m_dw_array.GetAt( cFocus ) ;
            m_dw_array.RemoveAt( cFocus ) ;
            m_dw_array.InsertAt( cFocus + 1, dwValue ) ;
        }
   }
   END_MEM_EXCEPTION(err)

   if ( err )
   {
	   ::DhcpMessageBox( err ) ;
   }
   else
   {
        m_b_changed = TRUE ;
   }

   Fill( cFocus + 1 ) ;
   HandleActivation() ;
}

void 
CDlgBinEd::OnClickedButnUp()
{
   INT cFocus = m_list_values.GetCurSel() ;
   INT cItems = m_list_values.GetCount() ;

   if ( cFocus <= 0 )
   {
       return ;
   }

   DWORD dwValue  ;
   DWORD err = 0 ;
   DWORD_DWORD dwdw;
   DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

   CATCH_MEM_EXCEPTION
   {
        if (optionType == DhcpDWordDWordOption) 
        {
            dwdw = m_dwdw_array.GetAt( cFocus ) ;
            m_dwdw_array.RemoveAt( cFocus ) ;
            m_dwdw_array.InsertAt( cFocus - 1, dwdw ) ;
        }
        else
        {
            dwValue = m_dw_array.GetAt( cFocus ) ;
            m_dw_array.RemoveAt( cFocus ) ;
            m_dw_array.InsertAt( cFocus - 1, dwValue ) ;
        }
   }
   END_MEM_EXCEPTION(err)

   if ( err )
   {
       ::DhcpMessageBox( err ) ;
   }
   else
   {
       m_b_changed = TRUE ;
   }

   Fill( cFocus - 1 ) ;
   HandleActivation() ;

}

void 
CDlgBinEd::OnSelchangeListValues()
{
    HandleActivation() ;
}

void 
CDlgBinEd::OnOK()
{
    DWORD err = 0 ;

    if ( m_b_changed )
    {
        CDhcpOptionValue & cValue = m_p_type->QueryValue() ;
        DHCP_OPTION_DATA_TYPE optionType = m_p_type->QueryValue().QueryDataType();

        CATCH_MEM_EXCEPTION
        {
            if (optionType == DhcpDWordDWordOption) 
            {
                cValue.SetUpperBound( (INT)m_dwdw_array.GetSize() ) ;
                for ( int i = 0 ; i < m_dwdw_array.GetSize() ; i++ )
                {
                     cValue.SetDwordDword( m_dwdw_array.GetAt( i ), i ) ;
                }
            }
            else
            {
                cValue.SetUpperBound( (INT)m_dw_array.GetSize() ) ;
                for ( int i = 0 ; i < m_dw_array.GetSize() ; i++ )
                {
                     cValue.SetNumber( m_dw_array.GetAt( i ), i ) ;
                }
            }
        }
        END_MEM_EXCEPTION( err ) ;

        if ( err )
        {
            ::DhcpMessageBox( err ) ;
            EndDialog( -1 ) ;
        }
        else
        {
            m_p_type->SetDirty() ;
            CBaseDialog::OnOK();
        }
    }
    else
    {
        OnCancel() ;
    }
}

void 
CDlgBinEd::OnCancel()
{
    CBaseDialog::OnCancel();
}

void 
CDlgBinEd::OnChangeEditValue()
{
    HandleActivation() ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgdefop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    dlgdefop.cpp
        Default options dialog

    FILE HISTORY:

*/

#include "stdafx.h"
#include "scope.h"
#include "dlgdefop.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpDefOptionDlg dialog

CDhcpDefOptionDlg::CDhcpDefOptionDlg
(
    COptionList * polValues,
    CDhcpOption * pdhcType,
    LPCTSTR       pszVendor,  // Vendor Name
    CWnd* pParent /*=NULL*/
) : CBaseDialog(CDhcpDefOptionDlg::IDD, pParent),
    m_pol_types( polValues ),
    m_p_type_base( pdhcType ),
    m_p_type( NULL )
{
    //{{AFX_DATA_INIT(CDhcpDefOptionDlg)
    //}}AFX_DATA_INIT
    m_strVendor = pszVendor;
}

CDhcpDefOptionDlg::~CDhcpDefOptionDlg ()
{
    delete m_p_type ;
}

CDhcpOption *
CDhcpDefOptionDlg::RetrieveParamType()
{
    CDhcpOption * pdhcParamType = m_p_type ;
    m_p_type = NULL ;
    return pdhcParamType ;
}


void
CDhcpDefOptionDlg::DoDataExchange
(
    CDataExchange* pDX
)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDhcpDefOptionDlg)
    DDX_Control(pDX, IDC_STATIC_ID, m_static_id);
    DDX_Control(pDX, IDC_STATIC_DATATYPE, m_static_DataType);
    DDX_Control(pDX, IDC_CHECK_ARRAY, m_check_array);
    DDX_Control(pDX, IDC_EDIT_NAME, m_edit_name);
    DDX_Control(pDX, IDC_EDIT_TYPE_ID, m_edit_id);
    DDX_Control(pDX, IDC_EDIT_TYPE_COMMENT, m_edit_comment);
    DDX_Control(pDX, IDC_COMBO_DATA_TYPE, m_combo_data_type);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDhcpDefOptionDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CDhcpDefOptionDlg)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_WM_KILLFOCUS()
    ON_WM_CLOSE()
	ON_CBN_SELCHANGE(IDC_COMBO_DATA_TYPE, OnSelchangeComboDataType)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpDefOptionDlg message handlers

int
CDhcpDefOptionDlg::OnCreate
(
    LPCREATESTRUCT lpCreateStruct
)
{
    if (CBaseDialog::OnCreate(lpCreateStruct) == -1)
    {
        return -1;
    }

    return 0;
}

void
CDhcpDefOptionDlg::OnDestroy()
{
    CBaseDialog::OnDestroy();
}

BOOL
CDhcpDefOptionDlg::OnInitDialog()
{
    CBaseDialog::OnInitDialog();
    DWORD err = 0 ;

    m_edit_name.LimitText( EDIT_STRING_MAX ) ;
    m_edit_id.LimitText( EDIT_ID_MAX ) ;
    m_edit_comment.LimitText( EDIT_STRING_MAX ) ;

    //
    //  If this is an update of an existing type, don't allow editing
    //  of the data type or id field.
    //
    if ( m_p_type_base )
    {
        m_edit_id.SetReadOnly() ;
        m_static_id.EnableWindow(FALSE);
        m_combo_data_type.EnableWindow( FALSE ) ;
        m_static_DataType.EnableWindow(FALSE);
    }

    CATCH_MEM_EXCEPTION
    {
		// update the vendor name info if necessary
		if (!m_strVendor.IsEmpty())
			GetDlgItem(IDC_STATIC_CLASS_NAME)->SetWindowText(m_strVendor);

        //
        //   Load the data type names combo box
        //   Set the dialog title properly.
        //
        CString strDataType ;
        CString strTitle ;

        strTitle.LoadString( m_p_type_base
                         ? IDS_INFO_TITLE_CHANGE_OPT_TYPE
                         : IDS_INFO_TITLE_ADD_OPTION_TYPES ) ;

        SetWindowText( strTitle ) ;

        for ( int iDataType = DhcpByteOption ;
              iDataType <= DhcpEncapsulatedDataOption ;
              iDataType++ )
        {
            strDataType.LoadString( IDS_INFO_TYPOPT_BYTE2 + iDataType ) ;
            int nIndex = m_combo_data_type.AddString( strDataType ) ;
            m_combo_data_type.SetItemData(nIndex, iDataType);
        }

        //
        //  If this is "change" mode, create the working type by
        //  copy-constructing the base option type object.
        //
        if ( m_p_type_base )
        {
            m_p_type = new CDhcpOption( *m_p_type_base ) ;
			//err = m_p_type->QueryError();

			//
			//  Set the "array" checkbox state properly, but disable it.
			//
			m_check_array.SetCheck( m_p_type->IsArray() ? 1 : 0 ) ;
			m_check_array.EnableWindow( FALSE ) ;
        }
    }
    END_MEM_EXCEPTION( err )

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }
    else if ( m_p_type_base )
    {
        Set() ;
    }
    else
    {
        m_combo_data_type.SetCurSel(0) ;
    }

    return FALSE ;  // return TRUE  unless you set the focus to a control
}

void
CDhcpDefOptionDlg::OnKillFocus
(
    CWnd* pNewWnd
)
{
    CBaseDialog::OnKillFocus(pNewWnd);
}

void CDhcpDefOptionDlg::OnOK()
{
    LONG err = m_p_type
             ? UpdateType()
             : AddType() ;

    //
    //  Discard the OK click if there was an error.
    //
    if ( err == 0 )
    {
        CBaseDialog::OnOK();
    }
    else
    {
        ::DhcpMessageBox( err ) ;
    }
}

//
//  Set the data values for the controls based upon the current selection
//   in the combo box.
//
void
CDhcpDefOptionDlg::Set()
{
    if ( m_p_type == NULL )
    {
        return ;
    }

    DWORD err ;

    CATCH_MEM_EXCEPTION
    {
        //
        //  Set the control values
        //
        CString strnumId;
		strnumId.Format(_T("%d"), m_p_type->QueryId() );
        CString strValue ;

        DHCP_OPTION_DATA_TYPE enType = m_p_type->QueryValue().QueryDataType() ;

        m_p_type->QueryValue().QueryDisplayString( strValue ) ;

        m_combo_data_type.SetCurSel( enType ) ;

        m_edit_name.SetWindowText( m_p_type->QueryName() ) ;
        m_edit_name.SetModify( FALSE ) ;
        m_edit_id.SetWindowText( strnumId ) ;
        m_edit_id.SetModify( FALSE ) ;
        m_edit_comment.SetWindowText( m_p_type->QueryComment() ) ;
        m_edit_comment.SetModify( FALSE ) ;
    }
    END_MEM_EXCEPTION(err)
}


DHCP_OPTION_DATA_TYPE
CDhcpDefOptionDlg::QueryType() const
{
    return  (DHCP_OPTION_DATA_TYPE) m_combo_data_type.GetCurSel() ;
}

//
//   Update the displayed type based upon the current values of
//   the controls.  Does nothing if the controls have not changed.
//   The Boolean parameter indicates that the user has requested an
//   update.  This differentiates the other case where the controls
//   are dirty and the user has closed the dialog or changed primary
//   selection.
//
LONG
CDhcpDefOptionDlg::UpdateType()
{
    ASSERT( m_p_type != NULL ) ;

    //
    //  If there isn't a current type object, return now.
    //
    if ( m_p_type == NULL )
    {
        return 0 ;
    }

    LONG err = 0 ;
    DHCP_OPTION_DATA_TYPE
       enType = m_p_type->QueryValue().QueryDataType(),
       enDlg = QueryType() ;

    CString str ;

    BOOL bChangedType    = enType != enDlg,
         bChangedName    = m_edit_name.GetModify() != 0,
         bChangedComment = m_edit_comment.GetModify() != 0,
         bChangedId      = m_edit_id.GetModify() != 0,
         bChanged        = bChangedType
                            || bChangedName
                            || bChangedComment
                            || bChangedId ;

    CATCH_MEM_EXCEPTION
    {
        do
        {
            if ( ! bChanged )
            {
                break ;
            }

            if ( bChangedId && m_p_type_base )
            {
                //
                // Identifier of an existing option cannot be changed.
                //
                err = IDS_ERR_CANT_CHANGE_ID ;
                break ;
            }

            if ( bChangedType )
            {
                if ( err = m_p_type->QueryValue().SetDataType( enDlg ) )
                {
                    break ;
                }
            }

            if ( bChangedName )
            {
                m_edit_name.GetWindowText( str ) ;
                m_p_type->SetName( str ) ;
            }

            if ( ::wcslen( m_p_type->QueryName() ) == 0 )
            {
                err = IDS_ERR_OPTION_NAME_REQUIRED ;
                break ;
            }

            if ( bChangedComment )
            {
                m_edit_comment.GetWindowText( str ) ;
                m_p_type->SetComment( str ) ;
            }
        }
        while ( FALSE ) ;
    }
    END_MEM_EXCEPTION(err)

    if ( bChanged && err == 0 )
    {
        m_p_type->SetDirty( TRUE ) ;
    }

    return err ;
}

LONG
CDhcpDefOptionDlg::AddType()
{
    ASSERT( m_p_type == NULL ) ;

    LONG err = 0 ;
    CDhcpOption * pdhcType = NULL ;
    TCHAR szT[32];
	DWORD dwId;
    CString strName, strComment ;
    DHCP_OPTION_TYPE dhcpOptType = m_check_array.GetCheck() & 1
                         ? DhcpArrayTypeOption
                         : DhcpUnaryElementTypeOption ;

    CATCH_MEM_EXCEPTION
    {
        do
        {
			m_edit_id.GetWindowText(szT, sizeof(szT)/sizeof(szT[0]));
			if (!FCvtAsciiToInteger(szT, OUT &dwId))
			{
				err = IDS_ERR_INVALID_NUMBER;
				m_edit_id.SetFocus();
                break;
			}
			ASSERT(dwId >= 0);
			
			if (( dwId < 2 ) || 
			    ( dwId > 255))
			{
				err = IDS_ERR_INVALID_OPTION_ID;
				m_edit_id.SetFocus();
                break;
			}

            // only restrict options in the default vendor class
			if (m_strVendor.IsEmpty() &&
                (dwId == OPTION_DNS_REGISTATION) )
			{
				// this range is reserved
				err = IDS_ERR_RESERVED_OPTION_ID;
				m_edit_id.SetFocus();
                break;
			}

            if ( m_pol_types->FindId(dwId, m_strVendor.IsEmpty() ? NULL : (LPCTSTR) m_strVendor) )
            {
                err = IDS_ERR_ID_ALREADY_EXISTS ;
                break ;
            }

            m_edit_comment.GetWindowText( strComment ) ;
            m_edit_name.GetWindowText( strName ) ;

            if ( strName.GetLength() == 0 )
            {
                err = IDS_ERR_OPTION_NAME_REQUIRED ;
                break ;
            }

            pdhcType = new CDhcpOption( dwId,
									    QueryType(),
									    strName,
									    strComment,
									    dhcpOptType ) ;
            if ( pdhcType == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                break ;
            }

            pdhcType->SetVendor(m_strVendor);

        } while ( FALSE ) ;
    }
    END_MEM_EXCEPTION(err)

    if ( err )
    {
        delete pdhcType ;
    }
    else
    {
        m_p_type = pdhcType ;
        m_p_type->SetDirty() ;
    }

    return err ;
}

void
CDhcpDefOptionDlg::OnClose()
{
    CBaseDialog::OnClose();
}

void CDhcpDefOptionDlg::OnSelchangeComboDataType()
{
    // presently the server doesn't support Encapsulated,
    // binary or string array options, so disable the array checkbox.

    BOOL bEnable = TRUE;
    int nCurSel = m_combo_data_type.GetCurSel();
    LRESULT nDataType = m_combo_data_type.GetItemData(nCurSel);

    if (nDataType == DhcpEncapsulatedDataOption ||
        nDataType == DhcpBinaryDataOption ) {
        bEnable = FALSE;
    }

    m_check_array.EnableWindow(bEnable);
} // CDhcpDefOptionDlg::OnSelchangeComboDataType()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgdval.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    dlgdval.cpp
        Default value dialog

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dlgdval.h"
#include "dlgdefop.h"
#include "dlgiparr.h"
#include "dlgbined.h"
#include "strarrdlg.h"
#include "routearrayeditor.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDhcpDefValDlg dialog

CDhcpDefValDlg::CDhcpDefValDlg
( 
    ITFSNode *		pServerNode, 
    COptionList *	polTypes, 
    CWnd*			pParent /*=NULL*/
)
    : CBaseDialog(CDhcpDefValDlg::IDD, pParent),
      m_pol_values( polTypes ),
      m_p_edit_type( NULL ),
      m_b_dirty( FALSE )
{
    //{{AFX_DATA_INIT(CDhcpDefValDlg)
    //}}AFX_DATA_INIT

    m_combo_class_iSel = LB_ERR;
    m_combo_name_iSel = LB_ERR;
    m_spNode.Set(pServerNode);

    ASSERT( m_pol_values != NULL );
}

CDhcpDefValDlg::~CDhcpDefValDlg () 
{
}

void 
CDhcpDefValDlg::DoDataExchange
(
    CDataExchange* pDX
)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDhcpDefValDlg)
    DDX_Control(pDX, IDC_EDIT_COMMENT, m_edit_comment);
    DDX_Control(pDX, IDC_BUTN_VALUE, m_butn_edit_value);
    DDX_Control(pDX, IDC_STATIC_VALUE_DESC, m_static_value_desc);
    DDX_Control(pDX, IDC_EDIT_VALUE_STRING, m_edit_string);
    DDX_Control(pDX, IDC_EDIT_VALUE_NUM, m_edit_num);
    DDX_Control(pDX, IDC_EDIT_VALUE_ARRAY, m_edit_array);
    DDX_Control(pDX, IDC_COMBO_OPTION_NAME, m_combo_name);
    DDX_Control(pDX, IDC_COMBO_OPTION_CLASS, m_combo_class);
    DDX_Control(pDX, IDC_BUTN_OPTION_PRO, m_butn_prop);
    DDX_Control(pDX, IDC_BUTN_NEW_OPTION, m_butn_new);
    DDX_Control(pDX, IDC_BUTN_DELETE, m_butn_delete);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_VALUE, m_ipa_value);
}

BEGIN_MESSAGE_MAP(CDhcpDefValDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CDhcpDefValDlg)
    ON_BN_CLICKED(IDC_BUTN_DELETE, OnClickedButnDelete)
    ON_BN_CLICKED(IDC_BUTN_NEW_OPTION, OnClickedButnNewOption)
    ON_BN_CLICKED(IDC_BUTN_OPTION_PRO, OnClickedButnOptionPro)
    ON_CBN_SELCHANGE(IDC_COMBO_OPTION_CLASS, OnSelendokComboOptionClass)
    ON_CBN_SETFOCUS(IDC_COMBO_OPTION_CLASS, OnSetfocusComboOptionClass)
    ON_CBN_SETFOCUS(IDC_COMBO_OPTION_NAME, OnSetfocusComboOptionName)
    ON_CBN_SELCHANGE(IDC_COMBO_OPTION_NAME, OnSelchangeComboOptionName)
    ON_BN_CLICKED(IDC_BUTN_VALUE, OnClickedButnValue)
    ON_BN_CLICKED(IDC_HELP, OnClickedHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpDefValDlg message handlers

void 
CDhcpDefValDlg::OnClickedButnDelete()
{
    DWORD err = 0 ;
    int cSel = m_combo_name.GetCurSel() ;
    BOOL fPresentInOldValues;
    
    //
    //  Make sure there's a new data type.
    //
    if ( m_p_edit_type == NULL ) 
    {
        return ;
    }

    ASSERT( m_pol_values != NULL ) ;

    //
    //  Remove the focused type.
    //

    fPresentInOldValues = ( NULL != m_pol_values->Find( m_p_edit_type ));
    m_pol_values->Remove( m_p_edit_type ) ;
    m_ol_values_new.Remove( m_p_edit_type ) ;

    if( fPresentInOldValues )
    {
        CATCH_MEM_EXCEPTION
        {
            m_ol_values_defunct.AddTail( m_p_edit_type ) ;
            m_b_dirty = TRUE ;
        }
        END_MEM_EXCEPTION(err);
    }
    
    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
    }
    else
    {
        if ( m_pol_values->GetCount() == 0 ) 
        {
            cSel = -1 ;
        }
        else
        {
            cSel = cSel > 0 ? cSel - 1 : 0 ;
        }

        Fill() ;
        m_combo_name.SetCurSel( cSel ) ;
        HandleActivation() ;
    }
}

void
CDhcpDefValDlg::GetCurrentVendor(CString & strVendor)
{
    if (m_combo_class_iSel == 0)
        strVendor.Empty();
    else
        m_combo_class.GetLBText(m_combo_class_iSel, strVendor);
}

void 
CDhcpDefValDlg::OnClickedButnNewOption()
{
    CString strVendor;

    GetCurrentVendor(strVendor);

    CDhcpDefOptionDlg dlgDefOpt( m_pol_values, NULL, strVendor, this);

    if ( dlgDefOpt.DoModal() == IDOK ) 
    {
        CDhcpOption * pNewOption = dlgDefOpt.RetrieveParamType();
        LONG err = UpdateList( pNewOption, TRUE ) ;
        if ( err ) 
        {
            ::DhcpMessageBox( err ) ;
        }
        else
        {
            // select the new item
            CString strName;
             
            pNewOption->QueryDisplayName(strName);

            int nIndex = m_combo_name.FindString(-1, strName);
            if (nIndex == CB_ERR)
            {
	            m_combo_name.SetCurSel(0);
            }
            else
            {
                m_combo_name.SetCurSel(nIndex);
            }

	        m_combo_name_iSel = m_combo_name.GetCurSel();
	        
            HandleActivation() ;

            return;
        }
    }
}

LONG 
CDhcpDefValDlg::UpdateList 
( 
    CDhcpOption * pdhcType, 
    BOOL		  bNew 
) 
{
    LONG err = 0 ;
    POSITION posOpt ;
    CString strName;
    //
    //  Remove and discard the old item if there is one.
    //
    if ( ! bNew ) 
    {
        posOpt = m_pol_values->Find( m_p_edit_type ) ;

        ASSERT( posOpt != NULL ) ;
        m_pol_values->RemoveAt( posOpt ) ;
        delete m_p_edit_type ;
    }

    m_p_edit_type = NULL ;

    //
    //  (Re-)add the item; sort the list, update the dialog,
    //     set focus to the given item.
    //
    CATCH_MEM_EXCEPTION
    {
        m_pol_values->AddTail( pdhcType ) ;
        m_ol_values_new.AddTail( pdhcType ) ;
        m_b_dirty = TRUE ;
        
	pdhcType->SetDirty() ;
        m_pol_values->SetDirty() ;
        m_pol_values->SortById() ;
        Fill() ;

        pdhcType->QueryDisplayName(strName);
        if (m_combo_name.SelectString (-1, strName ) == CB_ERR) 
		{
            m_combo_name.SetCurSel ( 0); // this should not happen, but just in case
        }

        HandleActivation() ;
    } 
    END_MEM_EXCEPTION(err) ;

    return err ;
}

void 
CDhcpDefValDlg::OnClickedButnOptionPro()
{
    CString strVendor;

    GetCurrentVendor(strVendor);

    CDhcpDefOptionDlg dlgDefOpt( m_pol_values, m_p_edit_type, strVendor, this);

    if ( dlgDefOpt.DoModal() == IDOK ) 
    {
        LONG err = UpdateList( dlgDefOpt.RetrieveParamType(), FALSE ) ;
        if ( err ) 
        {
            ::DhcpMessageBox( err ) ;
        }
    }
}

void 
CDhcpDefValDlg::OnSetfocusComboOptionClass()
{
    m_combo_class_iSel = (int) ::SendMessage (m_combo_class.m_hWnd, LB_GETCURSEL, 0, 0L);
}

void 
CDhcpDefValDlg::OnSetfocusComboOptionName()
{
    m_combo_name_iSel = (int) ::SendMessage(m_combo_name.m_hWnd, CB_GETCURSEL, 0, 0L);
}

void 
CDhcpDefValDlg::OnSelendokComboOptionClass()
{
    ASSERT(m_combo_class_iSel >= 0);
    if (!HandleValueEdit())
    {
		m_combo_class.SetCurSel(m_combo_class_iSel);
        return;
    }

    m_combo_class.GetCount();
    m_combo_class_iSel = m_combo_class.GetCurSel();

    // fill in the appropriate data for the new option class
    Fill();

    m_combo_name.SetCurSel(0);
    m_combo_name_iSel = m_combo_name.GetCurSel();

    // update the controls based on whatever option is now selected
    HandleActivation() ;   
}

void 
CDhcpDefValDlg::OnSelchangeComboOptionName()
{
    if (m_combo_name_iSel < 0)
	{
		m_combo_name.SetCurSel(0);
		m_combo_name_iSel = m_combo_name.GetCurSel();
		HandleActivation() ;
		
		return;
	}
    
    int nCurSel = m_combo_name_iSel;
	if (!HandleValueEdit())
    {
		m_combo_name.SetCurSel(nCurSel);
    
		return;
    }
    
	m_combo_name_iSel = (int) ::SendMessage(m_combo_name.m_hWnd, CB_GETCURSEL, 0, 0L);
    HandleActivation() ;
}

void 
CDhcpDefValDlg::OnCancel()
{
    // remove any options that were added to the list
    // since we are canceling out and not saving the list
    CDhcpOption * pCurOption = NULL;
    m_ol_values_new.Reset();

    while (pCurOption = m_ol_values_new.Next())
    {
        m_pol_values->Remove(pCurOption);
    }

    CBaseDialog::OnCancel();
}

void 
CDhcpDefValDlg::OnOK()
{
    if (!HandleValueEdit())
        return;
    
    if ( m_b_dirty ) 
    {
        BEGIN_WAIT_CURSOR;

        //
        //   Update the types; tell the routine to display all errors.
        //
		CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spNode);

		pServer->UpdateOptionList( m_pol_values,
								  &m_ol_values_defunct,
								   this );

        m_ol_values_new.RemoveAll();

        END_WAIT_CURSOR;
    }

    CBaseDialog::OnOK();
}

void 
CDhcpDefValDlg::OnClickedButnValue()
{
    if ( m_p_edit_type == NULL || 
         (( m_p_edit_type->IsArray() &&
	    m_p_edit_type->QueryDataType() == DhcpEncapsulatedDataOption ) || 
           ( m_p_edit_type->IsArray() &&
	     m_p_edit_type->QueryDataType() == DhcpBinaryDataOption ))) {
        ASSERT( FALSE ) ;
        return ;
    }
        
    INT_PTR cDlgResult = IDCANCEL ;

    DHCP_OPTION_DATA_TYPE enType = m_p_edit_type->QueryValue().QueryDataType() ;

    if ( enType == DhcpIpAddressOption )
    {
        CDhcpIpArrayDlg dlgIpArray( m_p_edit_type, DhcpDefaultOptions, this ) ;
        cDlgResult = dlgIpArray.DoModal() ;
    }
    else if ( enType == DhcpStringDataOption ) {
	CDhcpStringArrayEditor dlgStrArray( m_p_edit_type, 
					    DhcpDefaultOptions, this );
	cDlgResult = dlgStrArray.DoModal();
    }

    // Special case for static routes array option 249
    else if (( enType == DhcpBinaryDataOption) && 
	     ( DHCP_OPTION_ID_CSR == m_p_edit_type->QueryId())) {
	CDhcpRouteArrayEditor dlgRouteArray( m_p_edit_type,
					     DhcpDefaultOptions, this );
	cDlgResult = dlgRouteArray.DoModal();
    }
    else
    {
        CDlgBinEd dlgBinArray( m_p_edit_type, DhcpDefaultOptions, this ) ;
        cDlgResult = dlgBinArray.DoModal() ;
    }

    if ( cDlgResult == IDOK ) 
    {
        m_b_dirty = TRUE ;
        m_pol_values->SetDirty() ;
        HandleActivation( TRUE ) ;
    }
} // CDhcpDefValDlg::OnClickedButnValue()

void 
CDhcpDefValDlg::OnClickedHelp()
{
}

CDhcpOption * 
CDhcpDefValDlg::GetOptionTypeByIndex 
( 
    int iSel 
) 
{
    CString		  strVendor;
    CDhcpOption * pdhcType;    
    
    m_pol_values->Reset();
    
    GetCurrentVendor(strVendor);
    
    for ( int i = -1 ; pdhcType = m_pol_values->Next() ; )
    {
        //
        //  If we are looking at Vendor options, make sure the option is a vendor option
        //  If standard options is the class, make sure that it's not a vendor option
        //  and we aren't filtering it out (it's an option we want the user to set).
        //
	//  The option list is sorted by ID, so we need to make sure we have the correct vendor
	//  for the given option
	//
	
        if ( (m_combo_class_iSel != 0 && pdhcType->IsVendor() &&
	      strVendor.CompareNoCase(pdhcType->GetVendor()) == 0 ) ||
             (m_combo_class_iSel == 0 && !pdhcType->IsVendor() &&
	      !::FilterOption(pdhcType->QueryId())) )
        {
            i++ ; 
        }

        if ( i == iSel ) 
        {
            break ;
        }
    }

    return pdhcType ;
}

//
//  Check the state of the controls
//
void 
CDhcpDefValDlg::HandleActivation 
( 
    BOOL bForce 
)
{
    int iSel = m_combo_name.GetCurSel() ;

    CDhcpOption * pdhcType = 
	( iSel >= 0 )
	? GetOptionTypeByIndex( iSel )
	: NULL ;

    if ( pdhcType == NULL ) {
        m_edit_string.ShowWindow( SW_HIDE ) ;
        m_edit_num.ShowWindow( SW_HIDE ) ;
        m_edit_array.ShowWindow( SW_HIDE ) ;
        m_ipa_value.ShowWindow( SW_HIDE ) ;
        m_static_value_desc.SetWindowText(_T(""));
        m_edit_comment.SetWindowText(_T("")) ;
        m_butn_delete.EnableWindow( FALSE ) ;
        m_butn_prop.EnableWindow( FALSE ) ;
	
        // in case we just disabled the control with focus, move to the
        // next control in the tab order
        CWnd * pFocus = GetFocus();
        while (!pFocus || !pFocus->IsWindowEnabled()) {
            NextDlgCtrl();
            pFocus = GetFocus();
        }

        // if the buttons are enabled, make sure they are the default
        if (!m_butn_delete.IsWindowEnabled()) {
            m_butn_delete.SetButtonStyle(BS_PUSHBUTTON);
            m_butn_prop.SetButtonStyle(BS_PUSHBUTTON);
	    
            SetDefID(IDOK);
        }
	
        m_p_edit_type = NULL;
	
        return ;
    } // if 

    if  ( pdhcType == m_p_edit_type && ! bForce ) {
        return ;
    }
    
    m_p_edit_type = pdhcType ;
    
    DWORD err = 0 ;
    DHCP_OPTION_DATA_TYPE enType = m_p_edit_type->QueryValue().QueryDataType() ;
    BOOL bNumber = FALSE;
    BOOL bString = FALSE;
    BOOL bArray = m_p_edit_type->IsArray();
    BOOL bIpAddr = FALSE ;

    if (enType == DhcpEncapsulatedDataOption ||
        enType == DhcpBinaryDataOption) {
        bArray = TRUE;
    }
    
    CATCH_MEM_EXCEPTION {
        CString strValue, strDataType ;
	
        strDataType.LoadString( IDS_INFO_TYPOPT_BYTE + enType ) ;
        m_static_value_desc.SetWindowText( strDataType ) ;
        m_edit_comment.SetWindowText( m_p_edit_type->QueryComment() ) ;
        m_p_edit_type->QueryValue().QueryDisplayString( strValue, TRUE ) ;
	

	// special case for option 249, classless static routes.
	if (( pdhcType->QueryId() == DHCP_OPTION_ID_CSR ) &&
	    ( pdhcType->QueryValue().QueryDataType() ==
	      DhcpBinaryDataOption )) {
	    pdhcType->QueryValue().QueryRouteArrayDisplayString( strValue );
	}

        //
        //  If it's an array, set the multi-line edit control, else
        //  fill the appropriate single control.
        //
        if ( bArray ) {

	    m_edit_array.FmtLines( TRUE );
            m_edit_array.SetWindowText( strValue ) ;
        }
        else {
            switch ( pdhcType->QueryValue().QueryDataType()) {
	    case DhcpByteOption:
	    case DhcpWordOption:
	    case DhcpDWordOption:        
	    case DhcpDWordDWordOption:
		m_edit_num.SetWindowText( strValue ) ;
		m_edit_num.SetModify(FALSE);
		bNumber = TRUE ;
		break; 
		
	    case DhcpStringDataOption:
		m_edit_string.SetWindowText( strValue ) ;
		m_edit_string.SetModify(FALSE);
		bString = TRUE ;
		break ;
		
	    case DhcpIpAddressOption: 
		{
		    DWORD dwIP = m_p_edit_type->QueryValue().QueryIpAddr();
		    if (dwIP != 0L) {
			m_ipa_value.SetAddress( dwIP ) ;
		    }
		    else {
			m_ipa_value.ClearAddress();
		    }
		    
		    m_ipa_value.SetModify(FALSE);
		    bIpAddr = TRUE ;
		}
		break ;
		
	    default:
		Trace2("Default values: type %d has bad data type = %d\n",
		       (int) pdhcType->QueryId(),
		       (int) pdhcType->QueryValue().QueryDataType() );
		
		strValue.LoadString( IDS_INFO_TYPNAM_INVALID ) ;
		m_edit_array.SetWindowText( strValue ) ;
		bArray = TRUE ;
		break ;
            } // switch
        } // else
      
        m_butn_edit_value.ShowWindow(bArray  ? SW_NORMAL : SW_HIDE );
        m_edit_num.ShowWindow(       bNumber ? SW_NORMAL : SW_HIDE ) ;
        m_edit_string.ShowWindow(    bString ? SW_NORMAL : SW_HIDE ) ;
        m_ipa_value.ShowWindow(      bIpAddr ? SW_NORMAL : SW_HIDE ) ;
        m_edit_array.ShowWindow(     bArray  ? SW_NORMAL : SW_HIDE ) ;

        //
        //  See comment at top of file about this manifest.
        //
        BOOL bEnableDelete = ( m_p_edit_type->IsVendor() ||
                               ( !m_p_edit_type->IsVendor() &&
				(( m_p_edit_type->QueryId() > DHCP_MAX_BUILTIN_OPTION_ID ) &&
				 ( m_p_edit_type->QueryId() != DHCP_OPTION_ID_CSR ))));
        m_butn_delete.EnableWindow( bEnableDelete ) ;
        m_butn_prop.EnableWindow( TRUE ) ;

    } END_MEM_EXCEPTION( err ) ;
   
    if ( err ) {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }
} // CDhcpDefValDlg::HandleActivation()

//
//  (Re-)Fill the combo box(es)
//
void 
CDhcpDefValDlg::Fill()
{
    ASSERT( m_pol_values != NULL ) ;

    m_combo_name.ResetContent() ;
    
    CDhcpOption * pdhcType ;
    CString strName ;
    
    m_pol_values->Reset();

    while ( pdhcType = m_pol_values->Next()) {
        //
        // Add option, unless it's one of our hidden
        // options (subnet mask, T1, T2, etc).
        // There are no filtered options for vendor specific.
        //
        if (m_combo_class_iSel == 0) {
            if ((!::FilterOption(pdhcType->QueryId())) &&
                (!pdhcType->IsVendor())) {
                pdhcType->QueryDisplayName( strName );
                m_combo_name.AddString( strName );
            }
        }
        else {
            CString strCurVendor;
            
            GetCurrentVendor(strCurVendor);
	    
            if (pdhcType->GetVendor() &&
                strCurVendor.CompareNoCase(pdhcType->GetVendor()) == 0) {
                pdhcType->QueryDisplayName( strName );
                m_combo_name.AddString( strName );
            }
        } // else
    } // while
} // CDhcpDefValDlg::Fill()

//
//  Handle edited data
//
BOOL 
CDhcpDefValDlg::HandleValueEdit()
{
    if ( m_p_edit_type == NULL ) 
    {
        return TRUE ;
    }

    CDhcpOptionValue & dhcValue = m_p_edit_type->QueryValue() ;
    DHCP_OPTION_DATA_TYPE dhcType = dhcValue.QueryDataType() ;
    DHCP_IP_ADDRESS dhipa ;
    CString strEdit ;
    LONG err = 0 ;
    BOOL bModified = FALSE ;

    if ( m_p_edit_type->IsArray() ) 
    {
        bModified = m_edit_array.GetModify() ;
        if ( bModified ) 
        {
            err = IDS_ERR_ARRAY_EDIT_NOT_SUPPORTED ;
        }
    }
    else
    {
        switch ( dhcType )
        {
            case DhcpByteOption:
            case DhcpWordOption:
            case DhcpDWordOption:
                if ( ! m_edit_num.GetModify() )
                {
                    break ;
                }

                {
                    DWORD dwResult;
                    DWORD dwMask = 0xFFFFFFFF;
                    if (dhcType == DhcpByteOption)
			        {
                        dwMask = 0xFF;
                    }
                    else if (dhcType == DhcpWordOption)
				    {
                        dwMask = 0xFFFF;
				    }
                
                    if (!FGetCtrlDWordValue(m_edit_num.m_hWnd, &dwResult, 0, dwMask))
                        return FALSE;
                
                    bModified = TRUE ;
                
                    (void)dhcValue.SetNumber(dwResult, 0 ) ; 
                    ASSERT(err == FALSE);
                }
                break ;

            case DhcpDWordDWordOption:
                if ( !m_edit_num.GetModify() )
                {
                    break;
                }

                {
                    DWORD_DWORD dwdwResult;
                    CString strValue;
                
                    m_edit_num.GetWindowText(strValue);
                
                    UtilConvertStringToDwordDword(strValue, &dwdwResult);
            
                    bModified = TRUE ;
            
                    (void)dhcValue.SetDwordDword(dwdwResult, 0 ) ; 
                    ASSERT(err == FALSE);
                }

                break;

            case DhcpStringDataOption:
                if ( ! m_edit_string.GetModify() )
                {
                    break ;
                }
                
                bModified = TRUE ;
                m_edit_string.GetWindowText( strEdit ) ;
                err = dhcValue.SetString( strEdit, 0 ) ;
                
                break ;

            case DhcpIpAddressOption:
                if ( ! m_ipa_value.GetModify() ) 
                {
                    break ;
                }
                
                bModified = TRUE ;
                
                if ( ! m_ipa_value.GetAddress( & dhipa ) )
                {
                    err = ERROR_INVALID_PARAMETER ;
                    break; 
                }
                
                err = dhcValue.SetIpAddr( dhipa, 0 ) ; 
                break ;

            case DhcpEncapsulatedDataOption:
            case DhcpBinaryDataOption:
                if ( ! m_edit_array.GetModify() ) 
                {
                    break ;
                }
                err = IDS_ERR_BINARY_DATA_NOT_SUPPORTED ;
                break ; 

            //case DhcpEncapsulatedDataOption:
              //  Trace0("CDhcpDefValDlg:: encapsulated data type not supported in HandleValueEdit");
                //break; 

            default:
                Trace0("CDhcpDefValDlg:: invalid value type in HandleValueEdit");
                ASSERT( FALSE ) ;
                err = ERROR_INVALID_PARAMETER ;
                break;
        }
    }

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
    }
    else if ( bModified )
    {
         m_pol_values->SetDirty() ;
         m_b_dirty = TRUE ;
         m_p_edit_type->SetDirty() ;
         HandleActivation( TRUE ) ;
    }
    return err == 0 ;
}

BOOL 
CDhcpDefValDlg::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    DWORD err = 0 ;
    CString strTitle ;
    
    m_edit_string.LimitText( EDIT_STRING_MAX ) ;
    m_edit_string.ShowWindow( SW_HIDE );
    m_edit_num.ShowWindow( SW_HIDE );
    m_edit_num.LimitText( 25/*EDIT_ID_MAX*/ ) ;
    m_edit_array.LimitText( EDIT_ARRAY_MAX ) ;
    m_edit_array.ShowWindow( SW_HIDE );
    m_edit_array.SetReadOnly() ;

    m_butn_edit_value.ShowWindow( SW_HIDE );
    m_ipa_value.ShowWindow( SW_HIDE ) ;
    m_static_value_desc.SetWindowText(_T("")) ;
    m_edit_comment.SetWindowText(_T("")) ;

    CATCH_MEM_EXCEPTION
    {
        if ( m_pol_values->SetAll( FALSE ) ) 
        {
            Trace0("CDhcpDefValDlg::OnInitDialog: newly created list was dirty");
        }

        //
        //  Add the two types of options we can define--either 
        //  DHCP default or vendor specific
        //
        strTitle.LoadString( IDS_INFO_NAME_DHCP_DEFAULT ) ;
        m_combo_class.AddString( strTitle ) ;
        
        // now add any vendor classes that are defined
        CClassInfoArray ClassInfoArray;
        CDhcpServer * pServer = GETHANDLER(CDhcpServer, m_spNode);

        pServer->GetClassInfoArray(ClassInfoArray);

        for (int i = 0; i < ClassInfoArray.GetSize(); i++)
        {
            if (ClassInfoArray[i].bIsVendor)
            {
                m_combo_class.AddString( ClassInfoArray[i].strName ) ;
            }

        }
        
        m_combo_class.SetCurSel( 0 );
        m_combo_class_iSel = 0;

        //
        //  Fill the list box.
        //
        Fill() ;

        //
        //  Select the first item.
        //
        m_combo_name.SetCurSel( 0 ) ;
        HandleActivation() ;
    }   
    END_MEM_EXCEPTION( err ) 

    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
        EndDialog( -1 ) ;
    }

    return FALSE ;
} // CD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgdval.h ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1998 **/
/**********************************************************************/

/*
    dlgdval.h
        default values dialog

    FILE HISTORY:

*/

#ifndef _DLGDVAL_H
#define _DLGDVAL_H

#ifndef _SCOPE_H
#include "scope.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpDefValDlg dialog

class CDhcpDefValDlg : public CBaseDialog
{
private:
    int 	    m_combo_class_iSel;
    int		    m_combo_name_iSel;
    SPITFSNode	    m_spNode;

// Construction
public:
    CDhcpDefValDlg(ITFSNode * pServerNode,
		   COptionList * polTypes, 
		   CWnd* pParent = NULL);  // standard constructor
    
    ~ CDhcpDefValDlg () ;

// Dialog Data
    //{{AFX_DATA(CDhcpDefValDlg)
    enum { IDD = IDD_DEFAULT_VALUE };
    CEdit       m_edit_comment;
    CButton     m_butn_edit_value;
    CStatic     m_static_value_desc;
    CEdit       m_edit_string;
    CEdit       m_edit_num;
    CEdit       m_edit_array;
    CComboBox   m_combo_name;
    CComboBox   m_combo_class;
    CButton     m_butn_prop;
    CButton     m_butn_new;
    CButton     m_butn_delete;
    //}}AFX_DATA

    CWndIpAddress m_ipa_value ;         //  IP Address control

// Implementation

    //  Return TRUE if the lists were fiddled during execution
    BOOL QueryDirty () { return m_b_dirty ; }

    void GetCurrentVendor(CString & strVendor);

    // Context Help Support
    virtual DWORD * GetHelpMap() {
	return DhcpGetHelpMap(CDhcpDefValDlg::IDD); 
    }

protected:

     //  The current list of types and values
    COptionList * m_pol_values ;

    // list of new options - only used to clear new options on cancel
    COptionList m_ol_values_new ;

    //  The list of deleted type/values
    COptionList m_ol_values_defunct ;

    //  Pointer to type being displayed
    CDhcpOption * m_p_edit_type ;

    //  TRUE if lists have been fiddled.
    BOOL m_b_dirty ;

    //  Check the state of the controls
    void HandleActivation ( BOOL bForce = FALSE ) ;

    //  Fill the combo boxe(s)
    void Fill () ;

    // Given the listbox index, get a pointer to the option
    CDhcpOption * GetOptionTypeByIndex ( int iSel );

    //  Handle edited data
    BOOL HandleValueEdit () ;

    LONG UpdateList ( CDhcpOption * pdhcType, BOOL bNew ) ;


    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CDhcpDefValDlg)
    afx_msg void OnClickedButnDelete();
    afx_msg void OnClickedButnNewOption();
    afx_msg void OnClickedButnOptionPro();
    afx_msg void OnSelendokComboOptionClass();
    afx_msg void OnSetfocusComboOptionClass();
    afx_msg void OnSetfocusComboOptionName();
    afx_msg void OnSelchangeComboOptionName();
    virtual void OnCancel();
    virtual void OnOK();
    afx_msg void OnClickedButnValue();
    afx_msg void OnClickedHelp();
    virtual BOOL OnInitDialog();
    
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif _DLGDVAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgdefop.h ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    dlgdefop.h
        Default options dialog

    FILE HISTORY:

*/

#ifndef _DLGDEFOP_H
#define _DLGDEFOP_H

//
// This value should be based on spreadsheet information
//
#define DHCP_MAX_BUILTIN_OPTION_ID 76
#define DHCP_MIN_BUILTIN_OPTION_ID 0

/////////////////////////////////////////////////////////////////////////////
// CDhcpDefOptionDlg dialog

class CDhcpDefOptionDlg : public CBaseDialog
{
// Construction
public:
	CDhcpDefOptionDlg( COptionList * polValues, 
					   CDhcpOption * pdhcType = NULL,	//  Type to edit if "change" mode
                       LPCTSTR       pszVendor = NULL,  //  Vendor Name
	                   CWnd* pParent = NULL); // standard constructor

    ~ CDhcpDefOptionDlg () ;

// Dialog Data
	//{{AFX_DATA(CDhcpDefOptionDlg)
	enum { IDD = IDD_DEFINE_PARAM };
	CStatic	m_static_DataType;
	CStatic	m_static_id;
	CButton	m_check_array;
	CEdit   m_edit_name;
	CEdit   m_edit_id;
	CEdit   m_edit_comment;
	CComboBox       m_combo_data_type;
	//}}AFX_DATA

// Implementation

        CDhcpOption * RetrieveParamType () ;

protected:

	//  The applicable scope
	CDhcpScope * m_pob_scope ;

	//  The current list of types and values
	COptionList * m_pol_types ;

	//   The new or copy-constructed option type.
	CDhcpOption * m_p_type ;

	//   The object on which it was based or NULL (if "create" mode).
	CDhcpOption * m_p_type_base ;

    // Vendor name for this option
    CString    m_strVendor;

	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support

	//  Set the control data values based upon the type
	void Set () ;

	DHCP_OPTION_DATA_TYPE QueryType () const ;

	//  Update the displayed type based upon the current values of
	//   the controls.  Does nothing if the controls have not changed.
	LONG UpdateType () ;

	//  Drain the controls to create a new type object.  Set focus onto
	//  it when operation completes.
	LONG AddType () ;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpDefOptionDlg::IDD); }

	// Generated message map functions
	//{{AFX_MSG(CDhcpDefOptionDlg)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	virtual void OnOK();
	afx_msg void OnClickedRadioTypeDecNum();
	afx_msg void OnClickedRadioTypeHexNum();
	afx_msg void OnClickedRadioTypeIp();
	afx_msg void OnClickedRadioTypeString();
	afx_msg void OnClose();
	afx_msg void OnSelchangeComboDataType();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif _DLGDEFOP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgiparr.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1995 - 1999 **/
/**********************************************************************/

/*
    dhcpipar.cpp
        IP Array dialog

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dlgiparr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDhcpIpArrayDlg dialog

CDhcpIpArrayDlg::CDhcpIpArrayDlg(
    CDhcpOption * pdhcType, 
    DHCP_OPTION_SCOPE_TYPE  dhcScopeType,
    CWnd* pParent /*=NULL*/
    )
    : CBaseDialog(CDhcpIpArrayDlg::IDD, pParent),
      m_p_type( pdhcType ),
      m_option_type( dhcScopeType )
{
    //{{AFX_DATA_INIT(CDhcpIpArrayDlg)
    //}}AFX_DATA_INIT

    ASSERT( m_p_type != NULL ) ;
}

void 
CDhcpIpArrayDlg::DoDataExchange(
    CDataExchange* pDX
    )
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDhcpIpArrayDlg)
    DDX_Control(pDX, IDC_BUTN_RESOLVE, m_butn_resolve);
    DDX_Control(pDX, IDC_STATIC_OPTION_NAME, m_static_option_name);
    DDX_Control(pDX, IDC_STATIC_APPLICATION, m_static_application);
    DDX_Control(pDX, IDC_LIST_IP_ADDRS, m_list_ip_addrs);
    DDX_Control(pDX, IDC_EDIT_SERVER_NAME, m_edit_server);
    DDX_Control(pDX, IDC_BUTN_ADD, m_butn_add);
    DDX_Control(pDX, IDC_BUTN_DELETE, m_butn_delete);
    DDX_Control(pDX, IDC_BUTN_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTN_DOWN, m_button_Down);
    //}}AFX_DATA_MAP

    //  The IP address custom control

    DDX_Control(pDX, IDC_IPADDR_NEW, m_ipa_new );
}

BEGIN_MESSAGE_MAP(CDhcpIpArrayDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CDhcpIpArrayDlg)
    ON_BN_CLICKED(IDC_BUTN_ADD, OnClickedButnAdd)
    ON_BN_CLICKED(IDC_BUTN_DELETE, OnClickedButnDelete)
    ON_BN_CLICKED(IDC_BUTN_DOWN, OnClickedButnDown)
    ON_BN_CLICKED(IDC_BUTN_UP, OnClickedButnUp)
    ON_BN_CLICKED(IDC_HELP, OnClickedHelp)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRS, OnSelchangeListIpAddrs)
    ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
    ON_BN_CLICKED(IDC_BUTN_RESOLVE, OnClickedButnResolve)
    ON_COMMAND(EN_SETFOCUS, OnSetFocusEditIpAddr)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDhcpIpArrayDlg message handlers

BOOL 
CDhcpIpArrayDlg::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    DWORD err = 0 ;
    int cStrId = m_option_type == DhcpDefaultOptions 
           ? IDS_INFO_TITLE_DEFAULT_OPTIONS
           : (m_option_type == DhcpGlobalOptions 
                    ? IDS_INFO_TITLE_GLOBAL_OPTIONS
                    : IDS_INFO_TITLE_SCOPE_OPTIONS  ) ;
    CString str ;

    CATCH_MEM_EXCEPTION
    {
        m_static_option_name.SetWindowText( m_p_type->QueryName() ) ;

        str.LoadString( cStrId ) ;     
        m_static_application.SetWindowText( str ) ;

        //
        //  Fill the internal list from the current value.
        //
        INT cMax = m_p_type->QueryValue().QueryUpperBound() ;
        for (int i = 0; i < cMax; i++)
            {
            if (m_p_type->QueryValue().QueryIpAddr(i))
                {
                m_dw_array.Add((DWORD) m_p_type->QueryValue().QueryIpAddr( i ) ) ;    
                }
            }

        //
        //  Fill the list box without toggling redraw
        //
        Fill( 0, FALSE ) ; 

        //
        //  Set focus on the new IP address control.
        //
        m_ipa_new.SetFocus() ;

        m_ipa_new.SetModify( FALSE ) ;
        m_edit_server.SetModify( FALSE ) ;

        //
        //  Set proper button states.
        //
        HandleActivation() ;
    }
    END_MEM_EXCEPTION( err ) ;
    
    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
        EndDialog(-1);
    }

    return FALSE ;
}

void 
CDhcpIpArrayDlg :: Fill ( 
    INT cFocus, 
    BOOL bToggleRedraw 
    ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CString strIp;

    if ( bToggleRedraw ) 
    {
        m_list_ip_addrs.SetRedraw( FALSE ) ;
    }

    m_list_ip_addrs.ResetContent() ;
    if (m_dw_array.GetSize())
    {
        for ( INT i = 0 ; i < m_dw_array.GetSize() ; i++ ) 
        {
            ASSERT(m_dw_array.GetAt(i));
            ::UtilCvtIpAddrToWstr( m_dw_array.GetAt(i), &strIp ) ;
            m_list_ip_addrs.AddString( strIp ) ;
        }
    }
    else
    {
        // Set the string to "<None>" iff the list is empty
        strIp.LoadString(IDS_INFO_FORMAT_IP_NONE);
        m_list_ip_addrs.AddString( strIp ) ;
    }
    
    if ( cFocus >= 0 )
    {
        m_list_ip_addrs.SetCurSel( cFocus ) ;
    }

    if ( bToggleRedraw ) 
    {
        m_list_ip_addrs.SetRedraw( TRUE ) ;
        m_list_ip_addrs.Invalidate() ;
    }
}


void 
CDhcpIpArrayDlg :: HandleActivation () 
{
    INT cItems = m_list_ip_addrs.GetCount() ;
    INT cFocus = m_list_ip_addrs.GetCurSel() ;

    m_button_Up.EnableWindow(cFocus > 0) ;
    m_button_Down.EnableWindow(cFocus < cItems - 1) ;
    m_butn_delete.EnableWindow(m_dw_array.GetSize()>0) ;
    m_butn_resolve.EnableWindow( m_edit_server.GetModify() ) ;

    // check if the focus in on a disabled control
    // If yes, put the focus back to list box
    if ( !::IsWindowEnabled( ::GetFocus())) {
        m_list_ip_addrs.SetFocus();
    }

} // CDhcpIpArrayDlg::HandleActivation()

void 
CDhcpIpArrayDlg::OnOK()
{
    INT cItems = (INT)m_dw_array.GetSize() ;
    DWORD err = 0 ;

    // Check for special case standard options 21 and 33
    if (( !m_p_type->IsVendor()) &&
        (( 21 == m_p_type->QueryId()) ||
         ( 33 == m_p_type->QueryId())) &&
        ( 0 != cItems % 2 )) {
        ::DhcpMessageBox( IDS_ERR_OPTION_ADDR_PAIRS );
        return;
    } // if

    CATCH_MEM_EXCEPTION 
    {
        CDhcpOptionValue * pdhcValue = & m_p_type->QueryValue() ;
        pdhcValue->SetUpperBound( cItems ) ;
        for ( INT i = 0 ; i < cItems ; i++ ) 
        {
            pdhcValue->SetIpAddr( m_dw_array.GetAt(i), i ) ;
        }
        pdhcValue->SetIpAddr(0, i);     // 0.0.0.0 IP Terminator

        m_p_type->SetDirty() ;
    }
    END_MEM_EXCEPTION(err)

    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
        OnCancel() ;
    }
    else
    {
        CBaseDialog::OnOK();
    }
}

void 
CDhcpIpArrayDlg::OnCancel()
{
    CBaseDialog::OnCancel();
}

void 
CDhcpIpArrayDlg::OnClickedButnAdd()
{
   INT cFocus = m_list_ip_addrs.GetCurSel() ;
   DWORD dhipa ;

    m_ipa_new.GetAddress( & dhipa ) ;
    // Empty IP address
    if (!dhipa)
        return;

   DWORD err = 0 ;

   CATCH_MEM_EXCEPTION
   {
        if ( cFocus < 0 ) 
        {
           cFocus = 0 ;
        }
        m_dw_array.InsertAt( cFocus, dhipa ) ;
   }
   END_MEM_EXCEPTION(err)

   if ( err ) 
   {
        ::DhcpMessageBox( err ) ;
   }

   //
   // Refill listbox, update controls.
   //
   m_ipa_new.ClearAddress();
   m_ipa_new.SetFocus();

   Fill( cFocus ) ;
   HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnClickedButnDelete()
{
   INT cFocus = m_list_ip_addrs.GetCurSel() ;
   if ( cFocus < 0)
   {
        return ;    
   }

   DHCP_IP_ADDRESS dhipa = m_dw_array.GetAt( cFocus ) ;
   if (!dhipa)
        return;
   m_dw_array.RemoveAt( cFocus ) ;
   m_ipa_new.SetAddress( dhipa ) ; 
   m_ipa_new.SetFocus();
   Fill( cFocus ) ;     
   HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnClickedButnDown()
{
    INT cFocus = m_list_ip_addrs.GetCurSel() ;
    INT cItems = m_list_ip_addrs.GetCount() ;

    if ( cFocus < 0 || cFocus + 1 >= cItems ) 
    {
        return ;    
    }

    DHCP_IP_ADDRESS dhipa  ;

    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        dhipa = m_dw_array.GetAt( cFocus ) ;
        m_dw_array.RemoveAt( cFocus ) ;
        m_dw_array.InsertAt( cFocus + 1, dhipa ) ;
    }
    END_MEM_EXCEPTION(err)

    if ( err ) 
    {    
        ::DhcpMessageBox( err ) ;
    }
   
    Fill( cFocus + 1 ) ;     
    HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnClickedButnUp()
{
    INT cFocus = m_list_ip_addrs.GetCurSel() ;
    INT cItems = m_list_ip_addrs.GetCount() ;

    if ( cFocus <= 0 ) 
    {
        return ;    
    }

    DHCP_IP_ADDRESS dhipa  ;

    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {    
        dhipa = m_dw_array.GetAt( cFocus ) ;
        m_dw_array.RemoveAt( cFocus ) ;
        m_dw_array.InsertAt( cFocus - 1, dhipa ) ;
    }
    END_MEM_EXCEPTION(err)

    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
    }
   
    Fill( cFocus - 1 ) ;     
    HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnClickedHelp()
{
}

void
CDhcpIpArrayDlg::OnSetFocusEditIpAddr()
{
// REVIEW t-danmo
// Add code to change the default push button
}

void 
CDhcpIpArrayDlg::OnSelchangeListIpAddrs()
{
    HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnChangeEditServerName()
{
    HandleActivation() ; 
}

void 
CDhcpIpArrayDlg::OnClickedButnResolve()
{
    CString strHost ;
    DHCP_IP_ADDRESS dhipa ;
    DWORD err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        m_edit_server.GetWindowText( strHost ) ;
    }
    END_MEM_EXCEPTION( err ) ;

    if ( err == 0 ) 
    {
        if ( strHost.GetLength() == 0 ) 
        {
            err = IDS_ERR_BAD_HOST_NAME ;
        }
        else
        {
            err = ::UtilGetHostAddress( strHost, & dhipa ) ;
        }
        if ( err == 0 ) 
        {
            m_ipa_new.SetAddress( dhipa ) ;
        }
    }

    if ( err ) 
    {
        ::DhcpMessageBox( err ) ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgiparr.h ===
/**********************************************************************/
/**               Microsoft Windows NT                               **/
/**            Copyright(c) Microsoft Corporation, 1991 - 1999 **/
/**********************************************************************/

/*
    dhcpipar.h
        IP array editor

    FILE HISTORY:

*/

#ifndef _DLGIPARR_H
#define _DLGIPARR_H

/////////////////////////////////////////////////////////////////////////////
// CDhcpIpArrayDlg dialog

class CDhcpIpArrayDlg : public CBaseDialog
{
// Construction
public:
    CDhcpIpArrayDlg( CDhcpOption * pdhcType, // The type being edited
            DHCP_OPTION_SCOPE_TYPE dhcScopeType,
            CWnd* pParent = NULL);  // standard constructor

// Dialog Data
    //{{AFX_DATA(CDhcpIpArrayDlg)
    enum { IDD = IDD_IP_ARRAY_EDIT };
    CButton m_butn_resolve;
    CStatic m_static_option_name;
    CStatic m_static_application;
    CListBox    m_list_ip_addrs;
    CEdit   m_edit_server;
    CButton m_butn_add;
    CButton m_butn_delete;
    CButton m_button_Up;
    CButton m_button_Down;
    //}}AFX_DATA

    CWndIpAddress m_ipa_new ;

// Implementation
    CDhcpOption * m_p_type ;
    CDWordArray m_dw_array ;
    DHCP_OPTION_SCOPE_TYPE m_option_type ;

    //  Handle changes in the dialog
    void HandleActivation () ;

    //  Fill the list box
    void Fill ( INT cFocus = -1, BOOL bToggleRedraw = TRUE ) ;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDhcpIpArrayDlg::IDD); }

protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

    // Generated message map functions
    //{{AFX_MSG(CDhcpIpArrayDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnClickedButnAdd();
    afx_msg void OnClickedButnDelete();
    afx_msg void OnClickedButnDown();
    afx_msg void OnClickedButnUp();
    afx_msg void OnClickedHelp();
    afx_msg void OnSelchangeListIpAddrs();
    afx_msg void OnChangeEditServerName();
    afx_msg void OnClickedButnResolve();
	afx_msg void OnSetFocusEditIpAddr();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif _DLGIPARR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgrecon.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	dlgrecon.h
		Reconcile dialog
		
    FILE HISTORY:
        
*/

#ifndef _DLGRECON_H
#define _DLGRECON_H

#ifndef _BUSYDLG_H
#include "busydlg.h"
#endif

/*---------------------------------------------------------------------------
    CScopeReconInfo
 ---------------------------------------------------------------------------*/
class CScopeReconInfo 
{
public:
    CScopeReconInfo()
        : m_pScanList(NULL),
          m_dwScopeId(0xFFFFFFFF)
    {};

    ~CScopeReconInfo()
    {
    }

    CScopeReconInfo(CScopeReconInfo & ScopeReconInfo)
    {
        *this = ScopeReconInfo;
    }

    CScopeReconInfo & operator = (const CScopeReconInfo & ScopeReconInfo)
    {
        if (this != &ScopeReconInfo)
        {
            m_dwScopeId = ScopeReconInfo.m_dwScopeId;
            m_strName = ScopeReconInfo.m_strName;
            m_pScanList = ScopeReconInfo.m_pScanList;
        }
        
        return *this;
    }

    void FreeScanList()
    {
        if (m_pScanList)
        {
		    ::DhcpRpcFreeMemory(m_pScanList);
		    m_pScanList = NULL;
        }
    }

public:
    DWORD               m_dwScopeId;
    CString             m_strName;
    LPDHCP_SCAN_LIST    m_pScanList;
};

typedef CArray<CScopeReconInfo, CScopeReconInfo&> CScopeReconArrayBase;

class CScopeReconArray : public CScopeReconArrayBase
{
public:
    ~CScopeReconArray()
    {
        for (int i = 0; i < GetSize(); i++)
            GetAt(i).FreeScanList();
    }
};

/*---------------------------------------------------------------------------
    CReconcileWorker
 ---------------------------------------------------------------------------*/
class CReconcileWorker : public CDlgWorkerThread
{
public:
    CReconcileWorker(CDhcpServer * pServer, CScopeReconArray * pScopeReconArray);
    ~CReconcileWorker();

    void    OnDoAction();

protected:
    void    CheckAllScopes();
    void    CheckMScopes();
    void    CheckScopes();
    DWORD   ScanScope(CString & strName, DWORD dwScopeId);

public:
    CDhcpServer *   m_pServer;
    
    BOOL            m_fReconcileAll;
    BOOL            m_fMulticast;
    
    DWORD           m_dwScopeId;
    CString         m_strName;

    CScopeReconArray * m_pScopeReconArray;
};



/////////////////////////////////////////////////////////////////////////////
// CReconcileDlg dialog

class CReconcileDlg : public CBaseDialog
{
// Construction
public:
    CReconcileDlg(ITFSNode * pServerNode,
                  BOOL  fReconcileAll = FALSE,
				  CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CReconcileDlg)
	enum { IDD = IDD_RECONCILIATION };
	CListCtrl	m_listctrlAddresses;
	//}}AFX_DATA

    BOOL    m_bMulticast;
    
    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CReconcileDlg::IDD); }

// Implementation
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	void SetOkButton(BOOL bListBuilt);
    void AddItemToList(CScopeReconInfo & scopeReconInfo);

    // Generated message map functions
    //{{AFX_MSG(CReconcileDlg)
    virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

	SPITFSNode			m_spNode;
	BOOL				m_bListBuilt;
    BOOL                m_fReconcileAll;

    CScopeReconArray    m_ScopeReconArray;
};

#endif _DLGRECON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dlgrecon.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	dlgrecon.cpp
		Reconcile dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "dlgrecon.h"
#include "server.h"
#include "scope.h"
#include "mscope.h"
#include "busydlg.h"

/*---------------------------------------------------------------------------
    CReconcileWorker
 ---------------------------------------------------------------------------*/
CReconcileWorker::CReconcileWorker(CDhcpServer * pServer, CScopeReconArray * pScopeReconArray)
    : m_pServer(pServer),
      m_pScopeReconArray(pScopeReconArray)
{
}

CReconcileWorker::~CReconcileWorker()
{
}

void
CReconcileWorker::OnDoAction()
{
    // are we fixing or checking?
    if (m_pScopeReconArray->GetSize() > 0)
    {
        // walk the scope list looking for scopes with inconsistencies
        for (int i = 0; i < m_pScopeReconArray->GetSize(); i++)
        {
            CScopeReconInfo ScopeReconInfo = m_pScopeReconArray->GetAt(i);

            // does this scope have an inconsistencies?
            if (ScopeReconInfo.m_pScanList->NumScanItems > 0)
            {
                if (ScopeReconInfo.m_strName.IsEmpty())
                {
                    // normal scope
                    m_dwErr = m_pServer->ScanDatabase(TRUE, &ScopeReconInfo.m_pScanList, ScopeReconInfo.m_dwScopeId);
                }
                else
                {
                    // multicast scope
                    m_dwErr = m_pServer->ScanDatabase(TRUE, &ScopeReconInfo.m_pScanList, (LPWSTR) (LPCTSTR) ScopeReconInfo.m_strName);
                }
            }
        }

    }
    else
    {
        // are we checking all of the scopes?
        if (m_fReconcileAll)
        {
            // get list of all scopes, mscopes and check each one.
            CheckAllScopes();
        }
        else
        {
            // we are only checking one scope, info is provided
            m_dwErr = ScanScope(m_strName, m_dwScopeId);
        }
    }
}

void
CReconcileWorker::CheckAllScopes()
{
    LARGE_INTEGER liVersion;

    m_pServer->GetVersion(liVersion);

    if (liVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        CheckMScopes();
    }

    // now check all other scopes
    CheckScopes();
}

void
CReconcileWorker::CheckMScopes()
{
	DWORD						dwError = ERROR_MORE_DATA;
	DWORD						dwElementsRead = 0, dwElementsTotal = 0;
	LPDHCP_MSCOPE_TABLE			pMScopeTable = NULL;
    DHCP_RESUME_HANDLE          resumeHandle;

	//
	// for this server, enumerate all of it's subnets
	// 
	while (dwError == ERROR_MORE_DATA)
	{
		dwError = ::DhcpEnumMScopes((LPWSTR) m_pServer->GetIpAddress(),
									&resumeHandle,
									-1, 
									&pMScopeTable,
									&dwElementsRead,
									&dwElementsTotal);
		
        if (dwElementsRead && dwElementsTotal && pMScopeTable)
		{
			//
			// loop through all of the subnets that were returned
			//
			for (DWORD i = 0; i < pMScopeTable->NumElements; i++)
			{
                CString strName = pMScopeTable->pMScopeNames[i];

                DWORD err = ScanScope(strName, 0);
                if (err != ERROR_SUCCESS)
                {
                    dwError = err;
                    break;
                }
            }

			//
			// Free up the RPC memory
			//
			::DhcpRpcFreeMemory(pMScopeTable);

			dwElementsRead = 0;
			dwElementsTotal = 0;
			pMScopeTable = NULL;
        }
    }

    if (dwError != ERROR_NO_MORE_ITEMS && 
        dwError != ERROR_SUCCESS &&
        dwError != ERROR_MORE_DATA)
	{
        m_dwErr = dwError;
    }
    else
    {
        m_dwErr = ERROR_SUCCESS;
    }
}

void 
CReconcileWorker::CheckScopes()
{
	DWORD						dwError = ERROR_MORE_DATA;
	DWORD						dwElementsRead = 0, dwElementsTotal = 0;
	LPDHCP_IP_ARRAY				pdhcpIpArray = NULL;
    DHCP_RESUME_HANDLE          resumeHandle;

	//
	// for this server, enumerate all of it's subnets
	// 
	while (dwError == ERROR_MORE_DATA)
	{
		dwError = ::DhcpEnumSubnets((LPWSTR) m_pServer->GetIpAddress(),
									&resumeHandle,
									-1, 
									&pdhcpIpArray,
									&dwElementsRead,
									&dwElementsTotal);

        if (dwElementsRead && dwElementsTotal && pdhcpIpArray)
		{
			for (DWORD i = 0; i < pdhcpIpArray->NumElements; i++)
			{
                // check this scope
                CString strEmpty;
                DWORD err = ScanScope(strEmpty, pdhcpIpArray->Elements[i]);
                if (err != ERROR_SUCCESS)
                {
                    dwError = err;
                    break;
                }
            }

			//
			// Free up the RPC memory
			//
			::DhcpRpcFreeMemory(pdhcpIpArray);

			dwElementsRead = 0;
			dwElementsTotal = 0;
			pdhcpIpArray = NULL;
		}
    }

    if (dwError != ERROR_NO_MORE_ITEMS && 
        dwError != ERROR_SUCCESS &&
        dwError != ERROR_MORE_DATA)
	{
        m_dwErr = dwError;
    }
    else
    {
        m_dwErr = ERROR_SUCCESS;
    }
}

DWORD 
CReconcileWorker::ScanScope(CString & strName, DWORD dwScopeId)
{
    DWORD err = 0;

    CScopeReconInfo ScopeReconInfo;

    ScopeReconInfo.m_dwScopeId = dwScopeId;
    ScopeReconInfo.m_strName = strName;

    // check the scope.  If the name is empty then is is a normal scope
    // otherwise it is a multicast scope
    err = (strName.IsEmpty()) ? m_pServer->ScanDatabase(FALSE, &ScopeReconInfo.m_pScanList, ScopeReconInfo.m_dwScopeId) : 
                                m_pServer->ScanDatabase(FALSE, &ScopeReconInfo.m_pScanList, (LPWSTR) (LPCTSTR) ScopeReconInfo.m_strName);

    if (err == ERROR_SUCCESS)
    {
        m_pScopeReconArray->Add(ScopeReconInfo);
    }

    return err;
}

/////////////////////////////////////////////////////////////////////////////
// CReconcileDlg dialog

CReconcileDlg::CReconcileDlg
(
	ITFSNode * pServerNode,
    BOOL       fReconcileAll,
    CWnd* pParent /*=NULL*/
)
    : CBaseDialog(CReconcileDlg::IDD, pParent),
	  m_bListBuilt(FALSE),
      m_bMulticast(FALSE),
      m_fReconcileAll(fReconcileAll)
{
    //{{AFX_DATA_INIT(CReconcileDlg)
	//}}AFX_DATA_INIT

	m_spNode.Set(pServerNode);
}

void 
CReconcileDlg::DoDataExchange(CDataExchange* pDX)
{
    CBaseDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CReconcileDlg)
	DDX_Control(pDX, IDC_LIST_RECONCILE_IP_ADDRESSES, m_listctrlAddresses);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CReconcileDlg, CBaseDialog)
    //{{AFX_MSG_MAP(CReconcileDlg)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReconcileDlg message handlers

BOOL 
CReconcileDlg::OnInitDialog()
{
    CBaseDialog::OnInitDialog();

    if (m_fReconcileAll)
    {
        CString strText;

        // set the dialog title
        strText.LoadString(IDS_RECONCILE_ALL_SCOPES_TITLE);
        SetWindowText(strText);
    }
	    
    // setup the listctrl
    CString strTemp;
    
    // add the scope column
    strTemp.LoadString(IDS_SCOPE_FOLDER);
    m_listctrlAddresses.InsertColumn(0, strTemp, LVCFMT_LEFT, 150);

    // add the address column
    strTemp.LoadString(IDS_IP_ADDRESS);
    m_listctrlAddresses.InsertColumn(1, strTemp, LVCFMT_LEFT, 150);
    
	SetOkButton(m_bListBuilt);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CReconcileDlg::SetOkButton(BOOL bListBuilt)
{
	CWnd * pWnd = GetDlgItem(IDOK);
	CString strButton;

	if (bListBuilt)
	{
		strButton.LoadString(IDS_RECONCILE_DATABASE);
	}
	else
	{
		strButton.LoadString(IDS_CHECK_DATABASE);
	}

	pWnd->SetWindowText(strButton);
}

void CReconcileDlg::OnOK() 
{
	DWORD err = 0;
    CDhcpScope * pScope;
    CDhcpMScope * pMScope;
    CDhcpServer * pServer;
	
    if (m_fReconcileAll)
    {
        pServer = GETHANDLER(CDhcpServer, m_spNode);
    }
    else
    {
        if (m_bMulticast)
        {
            pMScope = GETHANDLER(CDhcpMScope, m_spNode);
            pServer = pMScope->GetServerObject();
        }
        else
        {
            pScope = GETHANDLER(CDhcpScope, m_spNode);
            pServer = pScope->GetServerObject();
        }
    }
	
    if (m_bListBuilt)
	{
        // we've built a list of inconsistencies.  Tell the 
        // dhcp server to reconcile them.
        //
        CReconcileWorker * pWorker = new CReconcileWorker(pServer, &m_ScopeReconArray);
        CLongOperationDialog dlgBusy(pWorker, IDR_SEARCH_AVI);

        dlgBusy.LoadTitleString(IDS_SNAPIN_DESC);
        dlgBusy.LoadDescriptionString(IDS_FIXING_SCOPES);

        dlgBusy.DoModal();
        if (pWorker->GetError() != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(pWorker->GetError());
        }
		else
		{
			m_bListBuilt = FALSE;
            m_listctrlAddresses.DeleteAllItems();
			SetOkButton(m_bListBuilt);
		}
	}
	else
	{
        //
        // First we scan the whole database to see if
        // there are IP addresses that need to be resolved.
        //
		m_listctrlAddresses.DeleteAllItems();    
        m_ScopeReconArray.RemoveAll();

        CReconcileWorker * pWorker = new CReconcileWorker(pServer, &m_ScopeReconArray);
        CLongOperationDialog dlgBusy(pWorker, IDR_SEARCH_AVI);
    
        dlgBusy.LoadTitleString(IDS_SNAPIN_DESC);
        dlgBusy.LoadDescriptionString(IDS_CHECKING_SCOPES);
    
        pWorker->m_fReconcileAll = m_fReconcileAll;
        pWorker->m_fMulticast = m_bMulticast;
        if (!m_fReconcileAll)
        {
            if (m_bMulticast)
            {
                pWorker->m_strName = pMScope->GetName();
            }
            else
            {
                pWorker->m_dwScopeId = pScope->GetAddress();
            }
        }

        dlgBusy.DoModal();

        if (pWorker->GetError() != ERROR_SUCCESS)
        {
            ::DhcpMessageBox(pWorker->GetError());
			return;
        }

        // walk the list and build the display
        for (int i = 0; i < m_ScopeReconArray.GetSize(); i++)
        {
            if (m_ScopeReconArray[i].m_pScanList->NumScanItems > 0)
            {
                //
                // There are items to be reconciled.
                // Present the list of ip addresses
                // that didn't match, and let 
                // the user decide to add them
                // or not.
                //
                AddItemToList(m_ScopeReconArray[i]);

			    m_bListBuilt = TRUE;
			    SetOkButton(m_bListBuilt);
            }
        }

        if (!m_bListBuilt)
        {
            AfxMessageBox(IDS_MSG_NO_RECONCILE, MB_ICONINFORMATION);
        }

	}
	
	//CBaseDialog::OnOK();
}

void 
CReconcileDlg::AddItemToList(CScopeReconInfo & scopeReconInfo)
{
    CString strScope;
	CString strAddress;
    int     nItem = 0;

    // get the scope string
    if (scopeReconInfo.m_strName.IsEmpty())
    {
        // normal scope
        ::UtilCvtIpAddrToWstr(scopeReconInfo.m_dwScopeId, &strScope);
    }
    else
    {
        // multicast scope
        strScope = scopeReconInfo.m_strName;
    }

    // convert the inconsistent address
	for (DWORD j = 0; j < scopeReconInfo.m_pScanList->NumScanItems; j++)
	{
	    ::UtilCvtIpAddrToWstr(scopeReconInfo.m_pScanList->ScanItems[j].IpAddress, &strAddress);
	    
        nItem = m_listctrlAddresses.InsertItem(nItem, strScope);
        m_listctrlAddresses.SetItemText(nItem, 1, strAddress);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dnsprop.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	dnsprop.h
		The dynamic dns properties page
		
    FILE HISTORY:
        
*/

#if !defined _DNSPROP_H
#define _DNSPROP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CDnsPropRegistration dialog

class CDnsPropRegistration : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CDnsPropRegistration)

// Construction
public:
	CDnsPropRegistration();
	~CDnsPropRegistration();

// Dialog Data
	//{{AFX_DATA(CDnsPropRegistration)
	enum { IDD = IDP_DNS_INFORMATION };
	BOOL	m_fEnableDynDns;
	BOOL	m_fGarbageCollect;
	BOOL	m_fUpdateDownlevel;
	int		m_nRegistrationType;
	//}}AFX_DATA

	DHCP_OPTION_SCOPE_TYPE	m_dhcpOptionType;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CDnsPropRegistration::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDnsPropRegistration)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
	void UpdateControls();

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDnsPropRegistration)
	afx_msg void OnRadioAlways();
	afx_msg void OnRadioClient();
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckEnableDynDns();
	afx_msg void OnCheckGarbageCollect();
	afx_msg void OnCheckUpdateDownlevel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	DWORD	m_dwFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _DNSPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\dnsprop.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	dnsprop.cpp
		The dynamic DNS property page
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "DnsProp.h"
#include "server.h"
#include "scope.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDnsPropRegistration property page

IMPLEMENT_DYNCREATE(CDnsPropRegistration, CPropertyPageBase)

CDnsPropRegistration::CDnsPropRegistration() : CPropertyPageBase(CDnsPropRegistration::IDD)
{
	//{{AFX_DATA_INIT(CDnsPropRegistration)
	m_fEnableDynDns = FALSE;
	m_fGarbageCollect = FALSE;
	m_fUpdateDownlevel = FALSE;
	m_nRegistrationType = -1;
	//}}AFX_DATA_INIT
}

CDnsPropRegistration::~CDnsPropRegistration()
{
}

void CDnsPropRegistration::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDnsPropRegistration)
	DDX_Check(pDX, IDC_CHECK_ENABLE_DYN_DNS, m_fEnableDynDns);
	DDX_Check(pDX, IDC_CHECK_GARBAGE_COLLECT, m_fGarbageCollect);
	DDX_Check(pDX, IDC_CHECK_UPDATE_DOWNLEVEL, m_fUpdateDownlevel);
	DDX_Radio(pDX, IDC_RADIO_CLIENT, m_nRegistrationType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDnsPropRegistration, CPropertyPageBase)
	//{{AFX_MSG_MAP(CDnsPropRegistration)
	ON_BN_CLICKED(IDC_RADIO_ALWAYS, OnRadioAlways)
	ON_BN_CLICKED(IDC_RADIO_CLIENT, OnRadioClient)
	ON_BN_CLICKED(IDC_CHECK_ENABLE_DYN_DNS, OnCheckEnableDynDns)
	ON_BN_CLICKED(IDC_CHECK_GARBAGE_COLLECT, OnCheckGarbageCollect)
	ON_BN_CLICKED(IDC_CHECK_UPDATE_DOWNLEVEL, OnCheckUpdateDownlevel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDnsPropRegistration message handlers

void CDnsPropRegistration::OnRadioAlways() 
{
	DWORD dwFlags = m_dwFlags;

	UpdateControls();

	if (dwFlags != m_dwFlags)
		SetDirty(TRUE);
}

void CDnsPropRegistration::OnRadioClient() 
{
	DWORD dwFlags = m_dwFlags;

	UpdateControls();

	if (dwFlags != m_dwFlags)
		SetDirty(TRUE);
}


BOOL CDnsPropRegistration::OnInitDialog() 
{
	m_fEnableDynDns = (m_dwFlags & DNS_FLAG_ENABLED) ? TRUE : FALSE;
	m_fUpdateDownlevel = (m_dwFlags & DNS_FLAG_UPDATE_DOWNLEVEL) ? TRUE : FALSE;
	m_fGarbageCollect = (m_dwFlags & DNS_FLAG_CLEANUP_EXPIRED) ? TRUE : FALSE;

	m_nRegistrationType = (m_dwFlags & DNS_FLAG_UPDATE_BOTH_ALWAYS) ? 1 : 0;

	CPropertyPageBase::OnInitDialog();

	UpdateControls();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CDnsPropRegistration::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	SPITFSNode      spNode;
	DWORD			dwFlags = m_dwFlags;
    DWORD           dwError;
    
	BEGIN_WAIT_CURSOR;

    spNode = GetHolder()->GetNode();

	switch (m_dhcpOptionType)
	{
		case DhcpGlobalOptions:
		{
			CDhcpServer * pServer = GETHANDLER(CDhcpServer, spNode);
			dwError = pServer->SetDnsRegistration(dwFlags);
		    if (dwError != ERROR_SUCCESS)
            {
                GetHolder()->SetError(dwError);
            }
			break;
		}

		case DhcpSubnetOptions:
		{
			CDhcpScope * pScope = GETHANDLER(CDhcpScope, spNode);
			dwError = pScope->SetDnsRegistration(dwFlags);
		    if (dwError != ERROR_SUCCESS)
            {
                GetHolder()->SetError(dwError);
            }
			break;
		}
		
		case DhcpReservedOptions:
		{	
			CDhcpReservationClient * pClient = GETHANDLER(CDhcpReservationClient, spNode);
			dwError = pClient->SetDnsRegistration(spNode, dwFlags);
		    if (dwError != ERROR_SUCCESS)
            {
                GetHolder()->SetError(dwError);
            }
			break;
		}
		
		default:
			Assert(FALSE);
			break;
	}
	
    END_WAIT_CURSOR;

	return FALSE;
}


BOOL CDnsPropRegistration::OnApply() 
{
	UpdateData();

	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

	return bRet;
}

void CDnsPropRegistration::OnCheckEnableDynDns() 
{
	DWORD dwFlags = m_dwFlags;

	UpdateControls();

	if (dwFlags != m_dwFlags)
		SetDirty(TRUE);
}

void CDnsPropRegistration::OnCheckGarbageCollect() 
{
	DWORD dwFlags = m_dwFlags;

	UpdateControls();

	if (dwFlags != m_dwFlags)
		SetDirty(TRUE);
}

void CDnsPropRegistration::OnCheckUpdateDownlevel() 
{
	DWORD dwFlags = m_dwFlags;

	UpdateControls();

	if (dwFlags != m_dwFlags)
		SetDirty(TRUE);
}

void CDnsPropRegistration::UpdateControls()
{
	UpdateData();

	if (m_fEnableDynDns)
	{
		GetDlgItem(IDC_RADIO_CLIENT)->EnableWindow(TRUE);
		GetDlgItem(IDC_RADIO_ALWAYS)->EnableWindow(TRUE);
		GetDlgItem(IDC_CHECK_GARBAGE_COLLECT)->EnableWindow(TRUE);
		GetDlgItem(IDC_CHECK_UPDATE_DOWNLEVEL)->EnableWindow(TRUE);

		m_dwFlags = DNS_FLAG_ENABLED;

		if (m_nRegistrationType == 1)
		{
			// user has selected to always update client information
			m_dwFlags |= DNS_FLAG_UPDATE_BOTH_ALWAYS;
		}

		if (m_fGarbageCollect)
		{
			m_dwFlags |= DNS_FLAG_CLEANUP_EXPIRED;
		}

		if (m_fUpdateDownlevel)
		{
			m_dwFlags |= DNS_FLAG_UPDATE_DOWNLEVEL;
		}
	}
	else
	{
		// turn off everything.  If DynDns is turned off then
		// all other flags are ignored.
		GetDlgItem(IDC_RADIO_CLIENT)->EnableWindow(FALSE);
		GetDlgItem(IDC_RADIO_ALWAYS)->EnableWindow(FALSE);
		GetDlgItem(IDC_CHECK_GARBAGE_COLLECT)->EnableWindow(FALSE);
		GetDlgItem(IDC_CHECK_UPDATE_DOWNLEVEL)->EnableWindow(FALSE);

		m_dwFlags = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\listview.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	listview.cpp
		Individual option property page
	
	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ListView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyListCtrl

IMPLEMENT_DYNCREATE(CMyListCtrl, CListCtrl)

BEGIN_MESSAGE_MAP(CMyListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CMyListCtrl)
	ON_WM_LBUTTONDOWN()
    ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyListCtrl construction/destruction

CMyListCtrl::CMyListCtrl()
{
	m_bFullRowSel = TRUE;
}

CMyListCtrl::~CMyListCtrl()
{
}

BOOL CMyListCtrl::PreCreateWindow(CREATESTRUCT& cs)
{
	// default is report view and full row selection
	cs.style &= ~LVS_TYPEMASK;
	cs.style |= (LVS_REPORT | LVS_SHAREIMAGELISTS | LVS_SINGLESEL | LVS_SHOWSELALWAYS);
	m_bFullRowSel = TRUE;

	return(CListCtrl::PreCreateWindow(cs));
}

BOOL CMyListCtrl::SetFullRowSel(BOOL bFullRowSel)
{
	// full row selection is the only extended style this
	// class supports...
	BOOL bRet = FALSE;

	if (!m_hWnd)
		return bRet;

	if (bFullRowSel)
		bRet = ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT);
	else
		bRet = ListView_SetExtendedListViewStyle(m_hWnd, 0);

	return(bRet);
}

BOOL CMyListCtrl::GetFullRowSel()
{
	return(m_bFullRowSel);
}

BOOL CMyListCtrl::SelectItem(int nItemIndex)
{
	LV_ITEM lvItem;

	ZeroMemory(&lvItem, sizeof(lvItem));

	lvItem.iItem = nItemIndex;
	lvItem.mask = LVIF_STATE;
	lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
	lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
	
	return SetItem(&lvItem);
}

BOOL CMyListCtrl::IsSelected(int nItemIndex)
{
	return GetItemState(nItemIndex, LVIS_SELECTED);
}

BOOL CMyListCtrl::CheckItem(int nItemIndex)
{
	// this just toggles the check mark state
	UINT uState = GetItemState(nItemIndex, LVIS_STATEIMAGEMASK);
	UINT uCheckMask = INDEXTOSTATEIMAGEMASK(LISTVIEWEX_CHECKED);
	
	uState = (uState == uCheckMask) ? LISTVIEWEX_NOT_CHECKED : LISTVIEWEX_CHECKED;

	return SetItemState(nItemIndex,
				INDEXTOSTATEIMAGEMASK(uState), LVIS_STATEIMAGEMASK);
}

BOOL CMyListCtrl::SetCheck(int nItemIndex, BOOL fCheck)
{
	// this just toggles the check mark state
	UINT uState;
	
    uState = (fCheck) ? LISTVIEWEX_CHECKED : LISTVIEWEX_NOT_CHECKED;

	return SetItemState(nItemIndex,
				INDEXTOSTATEIMAGEMASK(uState), LVIS_STATEIMAGEMASK);
}

UINT CMyListCtrl::GetCheck(int nItemIndex)
{
	// return 1 for checked item, 0 for unchecked
	UINT uState = GetItemState(nItemIndex, LVIS_STATEIMAGEMASK);
	UINT uCheckMask = INDEXTOSTATEIMAGEMASK(LISTVIEWEX_CHECKED);

	return uState == uCheckMask;
}

int CMyListCtrl::AddItem
(
	LPCTSTR		pName,
    LPCTSTR     pType,
    LPCTSTR     pComment,
	UINT		uState 
)
{
	// insert items
	LV_ITEM lvi;
    int     nItem;

	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.iItem = GetItemCount();
	lvi.iSubItem = 0;
	lvi.pszText = (LPTSTR) pName;
	lvi.iImage = 0;
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	lvi.state = INDEXTOSTATEIMAGEMASK(uState);

	nItem = InsertItem(&lvi);

    SetItemText(nItem, 1, pType);
    SetItemText(nItem, 2, pComment);

    return nItem;

}

int CMyListCtrl::AddItem
(
	LPCTSTR		pName,
    LPCTSTR     pComment,
	UINT		uState 
)
{
	// insert items
	LV_ITEM lvi;
    int     nItem;

	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.iItem = GetItemCount();
	lvi.iSubItem = 0;
	lvi.pszText = (LPTSTR) pName;
	lvi.iImage = 0;
	lvi.stateMask = LVIS_STATEIMAGEMASK;
	lvi.state = INDEXTOSTATEIMAGEMASK(uState);

	nItem = InsertItem(&lvi);

    SetItemText(nItem, 1, pComment);

    return nItem;

}


int CMyListCtrl::GetSelectedItem()
{
	// NOTE:  This list object assumes single selection and will return the 
	//        first selection in the list.  Returns -1 for nothing selected.
	int nSelectedItem = -1;

	for (int i = 0; i < GetItemCount(); i++)
	{
		UINT uState = GetItemState(i, LVIS_SELECTED);

		if (uState)
		{
			// item is selected
			nSelectedItem = i;
			break;
		}
	}

	return nSelectedItem;
}

void CMyListCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
	UINT uFlags = 0;
	int nHitItem = HitTest(point, &uFlags);

	// only check the item if the user clicks on the state icon.
	// if the user clicks outside the text and icon, we get
	// a LVHT_ONITEM message which is:
	// LVHT_ONITEMSTATEICON | LVHT_ONITEMICON | LVHT_ONITEMLABEL
	// so we need to filter out the state icon hit
	
	BOOL bHit = FALSE;
	if ((uFlags & LVHT_ONITEMSTATEICON) &&
		!((uFlags & LVHT_ONITEMICON) ||
		  (uFlags & LVHT_ONITEMLABEL)) )
	{
		bHit = TRUE;
	}

	if (bHit)
		CheckItem(nHitItem);
	else	
		CListCtrl::OnLButtonDown(nFlags, point);
}

//----------------------------------------------------------------------------
// Function:    CListCtrlEx::OnChar
//
// Handles the 'WM_CHAR' message for the list-control.
// This allows users to change items' checked-states using the keyboard.
//----------------------------------------------------------------------------

VOID
CMyListCtrl::OnChar(
    UINT    nChar,
    UINT    nRepCnt,
    UINT    nFlags
    ) 
{
    BOOL    fSet = FALSE;
    BOOL    fClear = FALSE;
    BOOL    fToggle = FALSE;
    INT     iItem;

    //
    // Handle characters with special meaning for us
    //

    switch (nChar) {

        case TEXT(' '): { fToggle = TRUE; break; }

        case TEXT('+'):
        case TEXT('='): { fSet = TRUE; break; }

        case TEXT('-'): { fClear = TRUE; break; }
    }

    if (!fToggle && !fSet && !fClear) 
    {
        CListCtrl::OnChar(nChar, nRepCnt, nFlags);
    }
    else 
    {
        //
        // Change the state of all the selected items
        //

        for (iItem = GetNextItem(-1, LVNI_SELECTED);
             iItem != -1;
             iItem = GetNextItem(iItem, LVNI_SELECTED)) 
        {
            if (fToggle) 
            {
                SetCheck(iItem, !GetCheck(iItem));
            }
            else
            if (fSet) 
            {
                if (!GetCheck(iItem)) 
                {
                    SetCheck(iItem, TRUE); 
                }
            }
            else 
            {
                if (GetCheck(iItem)) 
                { 
                    SetCheck(iItem, FALSE); 
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\miscres.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	miscres.h
		Misc resource IDs
		
    FILE HISTORY:
        
*/

#define IDC_DATA_ENTRY_DWORD            0x5000
#define IDC_DATA_ENTRY_IPADDRESS        0x5001
#define IDC_DATA_ENTRY_IPADDRESS_ARRAY  0x5002
#define IDC_DATA_ENTRY_STRING           0x5003
#define IDC_DATA_ENTRY_BINARY_ARRAY     0x5004
#define IDC_DATA_ENTRY_NONE             0x5005
#define IDC_DATA_ENTRY_BINARY           0x5006
#define IDC_DATA_ENTRY_ROUTE_ARRAY      0x5007
#define IDC_DATA_ENTRY_STRING_ARRAY     0x5008

#define IDC_CHECKLIST_OPTIONS           0x5100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\listview.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	listview.h
		Individual option property page
	
	FILE HISTORY:
        
*/

#ifndef _LISTVIEW_H
#define _LISTVIEW_H

#define LISTVIEWEX_NOT_CHECKED	1
#define LISTVIEWEX_CHECKED		2

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMyListCtrl : public CListCtrl
{
	DECLARE_DYNCREATE(CMyListCtrl)

// Construction
public:
	CMyListCtrl();

// Attributes
protected:
	BOOL m_bFullRowSel;

public:
	BOOL SetFullRowSel(BOOL bFillRowSel);
	BOOL GetFullRowSel();
	
	int  AddItem(LPCTSTR pName, LPCTSTR pType, LPCTSTR pComment, UINT uState);
	int  AddItem(LPCTSTR pName, LPCTSTR pComment, UINT uState);
	BOOL SelectItem(int nItemIndex);
	BOOL IsSelected(int nItemIndex);
	BOOL CheckItem(int nItemIndex);
	BOOL SetCheck(int nItemIndex, BOOL fCheck);
    UINT GetCheck(int nItemIndex);
	
    int  GetSelectedItem();

// Overrides
protected:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyListCtrl)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyListCtrl();

// Generated message map functions
protected:
	//{{AFX_MSG(CMyListCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg VOID OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif _LISTVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\general.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	general.cpp
		General classes for the DHCP snapin

    FILE HISTORY:

*/

#include "stdafx.h"
#include "options.h"
#include "nodes.h"

const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\dhcpconcepts.chm::/sag_dhcptopnode.htm");

/////////////////////////////////////////////////////////////////////
//
// CTimerArray implementation
//
/////////////////////////////////////////////////////////////////////
CTimerMgr::CTimerMgr()
{

}

CTimerMgr::~CTimerMgr()
{
    CTimerDesc * pTimerDesc;

    for (INT_PTR i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer != 0)
            FreeTimer(i);

        delete pTimerDesc;
    }

}

int
CTimerMgr::AllocateTimer
(
    ITFSNode *      pNode,
    CDhcpServer *   pServer,
    UINT            uTimerValue,
    TIMERPROC       TimerProc
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc = NULL;

    // look for an empty slot
    for (INT_PTR i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == 0)
            break;
    }

    // did we find one?  if not allocate one
    if (i < 0)
    {
        pTimerDesc = new CTimerDesc;
        Add(pTimerDesc);
        i = GetUpperBound();
    }

    //
    // fix null pointer dereference
    //

    if ( pTimerDesc == NULL )
    {
        return -1;
    }

    pTimerDesc->uTimer = SetTimer(NULL, (UINT) i, uTimerValue, TimerProc);
    if (pTimerDesc->uTimer == 0)
        return -1;

    pTimerDesc->spNode.Set(pNode);
    pTimerDesc->pServer = pServer;
    pTimerDesc->timerProc = TimerProc;

    return (int)i;
}

void
CTimerMgr::FreeTimer
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc;

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    pTimerDesc = GetAt((int) uEventId);
    ::KillTimer(NULL, pTimerDesc->uTimer);

    pTimerDesc->spNode.Release();
    pTimerDesc->pServer = NULL;
    pTimerDesc->uTimer = 0;
}

CTimerDesc *
CTimerMgr::GetTimerDesc
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // the caller of this function should lock the timer mgr
    // while accessing this pointer
    CTimerDesc * pTimerDesc;

    for (INT_PTR i = GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == uEventId)
            return pTimerDesc;
    }

    return NULL;
}

void
CTimerMgr::ChangeInterval
(
    UINT_PTR    uEventId,
    UINT        uNewInterval
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    CTimerDesc   tempTimerDesc;
    CTimerDesc * pTimerDesc;

    pTimerDesc = GetAt((int) uEventId);

    // kill the old timer
    ::KillTimer(NULL, pTimerDesc->uTimer);

    // set a new one with the new interval
    pTimerDesc->uTimer = ::SetTimer(NULL, (UINT) uEventId, uNewInterval, pTimerDesc->timerProc);
}

/////////////////////////////////////////////////////////////////////
//
// CDhcpClient implementation
//
/////////////////////////////////////////////////////////////////////
CDhcpClient::CDhcpClient
(
    const DHCP_CLIENT_INFO * pdhcClientInfo
)
   : m_bReservation( FALSE )
{
    Assert(pdhcClientInfo);

    InitializeData(pdhcClientInfo);

    m_bClientType = CLIENT_TYPE_UNSPECIFIED;
}

CDhcpClient::CDhcpClient
(
    const DHCP_CLIENT_INFO_V4 * pdhcClientInfo
)
   : m_bReservation( FALSE )
{
    Assert(pdhcClientInfo);

    InitializeData(reinterpret_cast<const DHCP_CLIENT_INFO *>(pdhcClientInfo));

    m_bClientType = pdhcClientInfo->bClientType;
}

void
CDhcpClient::InitializeData
(
    const DHCP_CLIENT_INFO * pdhcClientInfo
)
{
    DWORD err = 0;

    CATCH_MEM_EXCEPTION
    {
        m_dhcpIpAddress = pdhcClientInfo->ClientIpAddress;
        m_dhcpIpMask = pdhcClientInfo->SubnetMask;
        m_dtExpires = pdhcClientInfo->ClientLeaseExpires;

        if ( pdhcClientInfo->ClientName )
        {
            m_strName = pdhcClientInfo->ClientName;
        }

		if ( pdhcClientInfo->ClientComment )
        {
            m_strComment = pdhcClientInfo->ClientComment;
        }

		if ( pdhcClientInfo->OwnerHost.HostName )
        {
            m_strHostName = pdhcClientInfo->OwnerHost.HostName;
        }

        if ( pdhcClientInfo->OwnerHost.NetBiosName )
        {
            m_strHostNetbiosName = pdhcClientInfo->OwnerHost.NetBiosName;
        }

        //
        //  Convert the hardware addres
        //
        for ( DWORD i = 0 ; i < pdhcClientInfo->ClientHardwareAddress.DataLength ; i++ )
        {
            m_baHardwareAddress.SetAtGrow( i, pdhcClientInfo->ClientHardwareAddress.Data[i] ) ;
        }
    }
    END_MEM_EXCEPTION( err ) ;
}


CDhcpClient::~CDhcpClient()
{
}

CDhcpClient::CDhcpClient()
  : m_dhcpIpAddress( 0 ),
    m_dhcpIpMask( 0 ),
    m_dhcpIpHost( 0 ),
    m_bReservation( FALSE )
{
    m_dtExpires.dwLowDateTime  = DHCP_DATE_TIME_ZERO_LOW ;
    m_dtExpires.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH ;
}

void
CDhcpClient::SetHardwareAddress
(
	const CByteArray & caByte
)
{
    INT_PTR cMax = caByte.GetSize();
    m_baHardwareAddress.SetSize( cMax );

    for ( int i = 0 ; i < cMax ; i++ )
    {
        m_baHardwareAddress.SetAt( i, caByte.GetAt( i ) );
    }
}


/////////////////////////////////////////////////////////////////////
//
// CDhcpIpRange implementation
//
/////////////////////////////////////////////////////////////////////

CDhcpIpRange::CDhcpIpRange
(
    DHCP_IP_RANGE dhcpIpRange
)
{
    *this = dhcpIpRange;
	m_RangeType = DhcpIpRanges;
}

CDhcpIpRange::CDhcpIpRange()
{
    m_dhcpIpRange.StartAddress = DHCP_IP_ADDRESS_INVALID;
    m_dhcpIpRange.EndAddress   = DHCP_IP_ADDRESS_INVALID;
	m_RangeType = DhcpIpRanges;
}

CDhcpIpRange::~CDhcpIpRange()
{
}

//
//  Sort helper function
//
/*int
CDhcpIpRange::OrderByAddress
(
    const CObjectPlus * pobIpRange
) const
{
    const CDhcpIpRange * pipr = (CDhcpIpRange *) pobIpRange;

    //
    //  Derive a comparison result for the end address
    //
    int iEndResult = QueryAddr( FALSE ) < QueryAddr( FALSE )
           ? -1
           : QueryAddr( FALSE ) != QueryAddr( FALSE );

    //
    //  Use start address as major sort key, end address as minor.
    //
    return QueryAddr( TRUE ) < pipr->QueryAddr( TRUE )
            ? -1
            : ( QueryAddr( TRUE ) != pipr->QueryAddr( TRUE )
                  ? 1
                  : iEndResult );
}
*/

CDhcpIpRange &
CDhcpIpRange::operator =
(
    const DHCP_IP_RANGE dhcpIpRange
)
{
    m_dhcpIpRange = dhcpIpRange;

    return *this;
}

DHCP_IP_ADDRESS
CDhcpIpRange::SetAddr
(
    DHCP_IP_ADDRESS dhcpIpAddress,
    BOOL			bStart
)
{
    DHCP_IP_ADDRESS dhcpIpAddressOld;

    if ( bStart )
    {
        dhcpIpAddressOld = m_dhcpIpRange.StartAddress;
        m_dhcpIpRange.StartAddress = dhcpIpAddress;
    }
    else
    {
        dhcpIpAddressOld = m_dhcpIpRange.EndAddress;
        m_dhcpIpRange.EndAddress = dhcpIpAddress;
    }

    return dhcpIpAddressOld;
}

BOOL
CDhcpIpRange::IsOverlap
(
    DHCP_IP_RANGE dhcpIpRange
)
{
    BOOL bOverlap = FALSE;

    if (m_dhcpIpRange.StartAddress <= dhcpIpRange.StartAddress)
    {
        if (m_dhcpIpRange.StartAddress == dhcpIpRange.StartAddress)
        {
            bOverlap = TRUE;
        }
        else
		if (m_dhcpIpRange.EndAddress >= dhcpIpRange.StartAddress)
        {
            bOverlap = TRUE;
        }
    }
    else
	if (m_dhcpIpRange.StartAddress <= dhcpIpRange.EndAddress)
    {
        bOverlap = TRUE;
    }

    return bOverlap;
}

//
//  Return TRUE if this range is an improper subset of the given range.
//
BOOL
CDhcpIpRange::IsSubset
(
    DHCP_IP_RANGE dhcpIpRange
)
{
    return (dhcpIpRange.StartAddress <= m_dhcpIpRange.StartAddress) &&
           (dhcpIpRange.EndAddress >= m_dhcpIpRange.EndAddress);
}

//
//  Return TRUE if this range is an improper superset of the given range.
//
BOOL
CDhcpIpRange::IsSuperset
(
    DHCP_IP_RANGE dhcpIpRange
)
{
    return (dhcpIpRange.StartAddress >= m_dhcpIpRange.StartAddress) &&
           (dhcpIpRange.EndAddress <= m_dhcpIpRange.EndAddress);
}

void
CDhcpIpRange::SetRangeType(UINT uRangeType)
{
	m_RangeType = uRangeType;
}

UINT
CDhcpIpRange::GetRangeType()
{
	return m_RangeType;
}


/////////////////////////////////////////////////////////////////////
//
// CDhcpOptionValue implementation
//
/////////////////////////////////////////////////////////////////////
CDhcpOptionValue::CDhcpOptionValue
(
    DHCP_OPTION_DATA_TYPE	dhcpOptionDataType,
    INT						cUpperBound
)
    : m_dhcpOptionDataType( dhcpOptionDataType ),
      m_nUpperBound( -1 ),
	  m_pdhcpOptionDataStruct(NULL)
{
    m_dhcpOptionValue.pCObj = NULL;

	LONG err = InitValue( dhcpOptionDataType, cUpperBound );
	if ( err )
    {
        ASSERT(FALSE);
		//ReportError( err );
    }
}

//
//  Copy constructor.
//
CDhcpOptionValue::CDhcpOptionValue
(
    const CDhcpOptionValue & cOptionValue
)
    : m_dhcpOptionDataType( DhcpByteOption ),
      m_nUpperBound( -1 ),
	  m_pdhcpOptionDataStruct(NULL)
{
    DWORD err = 0;
	
	m_dhcpOptionValue.pCObj = NULL;

    err = SetData(&cOptionValue);
    if ( err )
    {
		ASSERT(FALSE);
        //ReportError( err );
    }
}

CDhcpOptionValue::CDhcpOptionValue
(
    const CDhcpOptionValue * pdhcpValue
)
    : m_dhcpOptionDataType( DhcpByteOption ),
      m_nUpperBound( -1 ),
	  m_pdhcpOptionDataStruct(NULL)
{
    LONG err = 0;
    m_dhcpOptionValue.pCObj = NULL;

    ASSERT( pdhcpValue != NULL );

    err = SetData(pdhcpValue);
    if (err)
	{
        ASSERT(FALSE);
		//ReportError( err );
    }
}

CDhcpOptionValue::CDhcpOptionValue
(
    const DHCP_OPTION & dhpType
)
    : m_dhcpOptionDataType( DhcpByteOption ),
      m_nUpperBound( -1 ),
	  m_pdhcpOptionDataStruct(NULL)
{
    LONG err = 0;
	m_dhcpOptionValue.pCObj = NULL;

    err = SetData((const LPDHCP_OPTION_DATA) &dhpType.DefaultValue);
    if ( err )
    {
        ASSERT(FALSE);
        //ReportError( err );
    }
}

CDhcpOptionValue::CDhcpOptionValue
(
    const DHCP_OPTION_VALUE & dhpOptionValue
)
    : m_dhcpOptionDataType( DhcpByteOption ),
      m_nUpperBound( -1 ),
	  m_pdhcpOptionDataStruct(NULL)
{
    LONG err = 0;
	m_dhcpOptionValue.pCObj = NULL;

	err = SetData((const LPDHCP_OPTION_DATA) &dhpOptionValue.Value);
    if ( err )
    {
        ASSERT(FALSE);
        //ReportError( err );
    }
}

CDhcpOptionValue::~ CDhcpOptionValue ()
{
    FreeValue();

	if (m_pdhcpOptionDataStruct)
		FreeOptionDataStruct();
}


CDhcpOptionValue & CDhcpOptionValue::operator =
(
    const CDhcpOptionValue & dhpValue
)
{
    SetData(&dhpValue);

    return *this;
}

BOOL
CDhcpOptionValue::SetDataType
(
    DHCP_OPTION_DATA_TYPE	dhcType,
    INT						cUpperBound
)
{
    if ( dhcType > DhcpEncapsulatedDataOption )
    {
        return FALSE;
    }

    InitValue( dhcType, cUpperBound );

    return TRUE;
}

void
CDhcpOptionValue::SetUpperBound
(
    INT cNewBound
)
{
    if (cNewBound <= 0)
        cNewBound = 1;

    if (m_dhcpOptionDataType != DhcpBinaryDataOption &&
        m_dhcpOptionDataType != DhcpEncapsulatedDataOption)
    {
        m_nUpperBound = cNewBound;
    }

	switch ( m_dhcpOptionDataType )
    {
        case DhcpByteOption:
        case DhcpWordOption:
        case DhcpDWordOption:
        case DhcpIpAddressOption:
            m_dhcpOptionValue.paDword->SetSize( cNewBound );
            break;

        case DhcpStringDataOption:
            m_dhcpOptionValue.paString->SetSize( cNewBound );
            break;

        case DhcpDWordDWordOption:
            m_dhcpOptionValue.paDwordDword->SetSize( cNewBound );
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            m_dhcpOptionValue.paBinary->SetSize( cNewBound );
            break;

        default:
            Trace0("CDhcpOptionValue: attempt to set upper bound on invalid value type");
            ASSERT( FALSE );
            break;
    }

}

BOOL
CDhcpOptionValue::IsValid () const
{
    return m_nUpperBound > 0;
}

void
CDhcpOptionValue::FreeValue ()
{
    //
    //  If there's not a value, return now.
    //
    if ( m_dhcpOptionValue.pCObj == NULL || m_nUpperBound < 0  )
    {
        m_dhcpOptionValue.pCObj = NULL;
        return;
    }

    switch ( m_dhcpOptionDataType )
    {
        case DhcpByteOption:
        case DhcpWordOption:
        case DhcpDWordOption:
        case DhcpIpAddressOption:
            delete m_dhcpOptionValue.paDword;
            break;

        case DhcpStringDataOption:
            delete m_dhcpOptionValue.paString;
            break;

        case DhcpDWordDWordOption:
            delete m_dhcpOptionValue.paDwordDword;
            break;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
            delete m_dhcpOptionValue.paBinary;
            break;

        default:
            ASSERT( FALSE );
            delete m_dhcpOptionValue.pCObj;
            break;
    }

    m_nUpperBound = -1;
    m_dhcpOptionDataType = DhcpByteOption;
    m_dhcpOptionValue.pCObj = NULL;
}

//
//  Initialize the data value properly
//
LONG
CDhcpOptionValue::InitValue
(
    DHCP_OPTION_DATA_TYPE	dhcDataType,		  //  The type of value
    INT						cUpperBound,          //  Maximum upper bound
    BOOL					bProvideDefaultValue  //  Should an empty default value be provided?
)
{
    LONG err = 0;

    //
    //  Release any older value.
    //
    FreeValue();

    //
    //  Initialize the new value
    //
    m_dhcpOptionDataType = dhcDataType;
    m_nUpperBound = cUpperBound <= 0 ? 1 : cUpperBound;

    CATCH_MEM_EXCEPTION
    {
        switch ( m_dhcpOptionDataType )
        {
            case DhcpByteOption:
            case DhcpWordOption:
            case DhcpDWordOption:
            case DhcpIpAddressOption:
                m_dhcpOptionValue.paDword = new CDWordArray;
                if ( bProvideDefaultValue)
                {
                    m_dhcpOptionValue.paDword->SetAtGrow( 0, 0 );
                }
                break;

            case DhcpStringDataOption:
                m_dhcpOptionValue.paString = new CStringArray;
                if ( bProvideDefaultValue )
                {
                    m_dhcpOptionValue.paString->SetAtGrow( 0, _T("") );
                }
                break;

            case DhcpDWordDWordOption:
                m_dhcpOptionValue.paDwordDword = new CDWordDWordArray;
                if ( bProvideDefaultValue )
                {
		    DWORD_DWORD dwdwValue;
		    dwdwValue.DWord1 = 0;
		    dwdwValue.DWord2 = 0;
                    m_dhcpOptionValue.paDwordDword->SetAtGrow( 0, dwdwValue );
                }
                break;

            case DhcpBinaryDataOption:
            case DhcpEncapsulatedDataOption:
                m_dhcpOptionValue.paBinary = new CByteArray;
                if ( bProvideDefaultValue )
                {
                    m_dhcpOptionValue.paBinary->SetAtGrow( 0, 0 );
                }
                break;

            default:
                err = IDS_INVALID_OPTION_DATA;
                break;
        }
    }
    END_MEM_EXCEPTION(err)

    return err;
}

void CDhcpOptionValue::RemoveAll()
{

    // Remove all the entries for this option value
    LONG err = 0;
    err = InitValue( QueryDataType(), QueryUpperBound(), TRUE );

    ASSERT( err == 0 );
} // CDhcpOptionValue::RemoveAll()

LONG
CDhcpOptionValue::SetData
(
    const DHCP_OPTION_DATA * podData
)
{
    LONG err = 0;

    if ( err = InitValue( podData->Elements[0].OptionType,
                          podData->NumElements,
                          FALSE ) )
    {
        return err;
    }

    CATCH_MEM_EXCEPTION
    {
        for ( INT i = 0; i < m_nUpperBound; i++ )
        {
            const DHCP_OPTION_DATA_ELEMENT * pElem = &podData->Elements[i];

            switch ( m_dhcpOptionDataType )
            {
                case DhcpByteOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pElem->Element.ByteOption );
                    break;

                case DhcpWordOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pElem->Element.WordOption );
                    break;

				case DhcpDWordOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pElem->Element.DWordOption );
                    break;

				case DhcpIpAddressOption:
                    m_dhcpOptionValue.paDword->Add(pElem->Element.IpAddressOption );
                    break;

                case DhcpDWordDWordOption:
                {
                    /*
                    CByteArray * paByte = m_dhcpOptionValue.paBinary;

                    paByte->SetSize( (sizeof (DWORD) / sizeof (BYTE)) * 2 );

                    DWORD dw = pElem->Element.DWordDWordOption.DWord1;

                    for ( INT j = 0; j < 4; j++ )
                    {
                        paByte->SetAtGrow(j, (UCHAR)(dw & 0xff) );
                        dw >>= 8;
                    }
                    dw = pElem->Element.DWordDWordOption.DWord2;

                    for ( ; j < 8; j++ )
                    {
                        paByte->SetAtGrow(j, (UCHAR)(dw & 0xff) );
                        dw >>= 8;
                    }
                    */

                    m_dhcpOptionValue.paDwordDword->SetAtGrow(i, pElem->Element.DWordDWordOption);
                }
                break;

                case DhcpStringDataOption:
                {
                    CString strTemp;

                    if ( pElem->Element.StringDataOption == NULL )
                    {
                        strTemp = _T("");
                    }
                    else
					{
						strTemp = pElem->Element.StringDataOption;
					}
                    m_dhcpOptionValue.paString->SetAtGrow(i, strTemp);
                }
                break;

                case DhcpBinaryDataOption:
                case DhcpEncapsulatedDataOption:
                {
                    CByteArray * paByte = m_dhcpOptionValue.paBinary;
                    INT c = pElem->Element.BinaryDataOption.DataLength;
                    paByte->SetSize( c );
                    for ( INT j = 0; j < c; j++ )
                    {
                        paByte->SetAtGrow(j, pElem->Element.BinaryDataOption.Data[j] );
                    }
                }
                break;

                default:
                    err = IDS_INVALID_OPTION_DATA;
            }  // End switch

            if ( err )
            {
               break;
            }
        }   // End for
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::SetData
(
    const CDhcpOptionValue * pOptionValue
)
{
    LONG err = 0;

    if ( err = InitValue( pOptionValue->QueryDataType(),
                          pOptionValue->QueryUpperBound(),
                          FALSE ) )
    {
        return err;
    }

    CATCH_MEM_EXCEPTION
    {
        for ( INT i = 0; i < m_nUpperBound; i++ )
        {
            switch ( m_dhcpOptionDataType )
            {
                case DhcpByteOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pOptionValue->m_dhcpOptionValue.paDword->GetAt(i));
                    break;

                case DhcpWordOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pOptionValue->m_dhcpOptionValue.paDword->GetAt(i));
                    break;

				case DhcpDWordOption:
                    m_dhcpOptionValue.paDword->SetAtGrow(i, pOptionValue->m_dhcpOptionValue.paDword->GetAt(i));
                    break;

				case DhcpIpAddressOption:
                    m_dhcpOptionValue.paDword->Add(pOptionValue->m_dhcpOptionValue.paDword->GetAt(i));
                    break;

                case DhcpDWordDWordOption:
                {
                    /*
                    CByteArray * paByte = m_dhcpOptionValue.paBinary;

                    paByte->SetSize( (sizeof (DWORD) / sizeof (BYTE)) * 2 );
                    for ( INT j = 0; j < 8; j++ )
                    {
                        paByte->SetAtGrow(j, pOptionValue->m_dhcpOptionValue.paBinary->GetAt(j));
                    }
                    */
                    m_dhcpOptionValue.paDwordDword->Add(pOptionValue->m_dhcpOptionValue.paDwordDword->GetAt(i));
                }
                break;

                case DhcpStringDataOption:
                {
                    m_dhcpOptionValue.paString->SetAtGrow(i, pOptionValue->m_dhcpOptionValue.paString->GetAt(i));
                }
                break;

                case DhcpBinaryDataOption:
                case DhcpEncapsulatedDataOption:
                {
                    CByteArray * paByte = m_dhcpOptionValue.paBinary;
                    INT_PTR c = pOptionValue->m_dhcpOptionValue.paBinary->GetSize();
                    paByte->SetSize( c );
                    for ( INT_PTR j = 0; j < c; j++ )
                    {
                        paByte->SetAtGrow(j, pOptionValue->m_dhcpOptionValue.paBinary->GetAt(j));
                    }
                }
                break;

                default:
                    err = IDS_INVALID_OPTION_DATA;
            }  // End switch

            if ( err )
            {
               break;
            }
        }   // End for
    }
    END_MEM_EXCEPTION(err)

    return err;
}

INT
CDhcpOptionValue::QueryBinary
(
    INT index
) const
{
    if ( m_dhcpOptionValue.paBinary->GetUpperBound() < index )
    {
        return -1;
    }

    return m_dhcpOptionValue.paBinary->GetAt( index );
}

const CByteArray *
CDhcpOptionValue::QueryBinaryArray ()  const
{
    return m_dhcpOptionValue.paBinary;
}

//
//  Return a string representation of the current value.
//
//  If fLineFeed is true, seperate each individual value
//  by a linefeed.  Otherwise, by a comma.
//
LONG
CDhcpOptionValue::QueryDisplayString
(
    CString &	strResult,
	BOOL		fLineFeed
) const
{
    CString strBuf;
    INT i, c;

    LONG err = 0;

    LPCTSTR pszDwordDwordMask   = _T("0x%08lX%08lX");
    LPCTSTR pszMaskDec			= _T("%ld");
    LPCTSTR pszMaskHex			= _T("0x%x");
    LPCTSTR pszMaskStr1			= _T("%s");
    LPCTSTR pszMaskStr2			= _T("\"%s\"");
    LPCTSTR pszMaskBin			= _T("%2.2x");
    LPCTSTR pszMask;
    LPCTSTR pszMaskEllipsis		= _T("...");
    LPCTSTR pszSepComma			= _T(", ");
    LPCTSTR pszSepLF			= _T("\r\n");

    CATCH_MEM_EXCEPTION {
	strResult.Empty();
	
        for ( i = 0; i < m_nUpperBound; i++ ) {
	    strBuf.Empty();
	    
            if ( i ) {
                strResult += fLineFeed ? pszSepLF : pszSepComma;
            }
	    
            switch ( QueryDataType()) {
	    case DhcpByteOption:
	    case DhcpWordOption:
	    case DhcpDWordOption:
		pszMask = pszMaskHex;
		strBuf.Format(pszMask, QueryNumber(i));
		break;
		
	    case DhcpStringDataOption:
		pszMask = m_nUpperBound > 1
		    ? pszMaskStr2
		    : pszMaskStr1;
		strBuf.Format( pszMask, m_dhcpOptionValue.paString->ElementAt( i ));
		break;
		
	    case DhcpIpAddressOption:
		if (!QueryIpAddr(i)) {
		    // Set the string to "<None>" iff the list is empty
		    if (!i)
			strResult.LoadString (IDS_INFO_FORMAT_IP_NONE);
		    break;
		}
		::UtilCvtIpAddrToWstr(QueryIpAddr(i), &strBuf);
		break;
		
	    case DhcpDWordDWordOption: {
		DWORD_DWORD dwdwValue = QueryDwordDword(i);
		
		pszMask = pszDwordDwordMask;
		strBuf.Format(pszMask, dwdwValue.DWord1, dwdwValue.DWord2);
	    }
		break;
		
	    case DhcpBinaryDataOption:
	    case DhcpEncapsulatedDataOption:
		for ( c = 0; c < m_dhcpOptionValue.paBinary->GetSize(); c++ ) {
		    if (c) {
			strBuf += _T(" ");
		    }
		    
		    DWORD dwValue = (BYTE) m_dhcpOptionValue.paBinary->GetAt( c );
		    CString strTemp;
		    strTemp.Format(pszMaskBin, dwValue);
		    
		    strBuf += strTemp;
		} // for
                    break;

                default:
                    strResult.LoadString(IDS_INFO_TYPNAM_INVALID);
                    break;
            } // switch
            strResult += strBuf;
        } // for 
    } // CATCH....
    END_MEM_EXCEPTION(err)

    return err;
}

//
//  Return a string representation of the current value.
//
//
LONG
CDhcpOptionValue::QueryRouteArrayDisplayString
(
    CString &	strResult
) const
{
	BOOL		fLineFeed = FALSE;
    CString strBuf;
    INT i, c;

    LONG err = 0;

    LPCTSTR pszDwordDwordMask   = _T("0x%08lX%08lX");
    LPCTSTR pszMaskDec			= _T("%ld");
    LPCTSTR pszMaskHex			= _T("0x%x");
    LPCTSTR pszMaskStr1			= _T("%s");
    LPCTSTR pszMaskStr2			= _T("\"%s\"");
    LPCTSTR pszMaskBin			= _T("%2.2x");
    LPCTSTR pszMask;
    LPCTSTR pszMaskEllipsis		= _T("...");
    LPCTSTR pszSepComma			= _T(", ");
    LPCTSTR pszSepLF			= _T("\r\n");

    CATCH_MEM_EXCEPTION
    {
        strResult.Empty();

        int bEmpty = TRUE;
        for ( i = 0; i < m_nUpperBound; i++ )
        {
            if ( i )
            {
                strResult += fLineFeed ? pszSepLF : pszSepComma;
            }

            int nDataSize = (int)m_dhcpOptionValue.paBinary->GetSize();
            LPBYTE pData = (LPBYTE) m_dhcpOptionValue.paBinary->GetData();
            
            // convert pData to list of ip addresses as per RFC
            while( nDataSize > sizeof(DWORD) )
            {
                // first 1 byte contains the # of bits in subnetmask
                nDataSize --;
                BYTE nBitsMask = *pData ++;
                DWORD Mask = (~0);
                if( nBitsMask < 32 ) Mask <<= (32-nBitsMask);
                
                // based on the # of bits, the next few bytes contain
                // the subnet address for the 1-bits of subnet mask
                int nBytesDest = (nBitsMask+7)/8;
                if( nBytesDest > 4 ) nBytesDest = 4;
                
                DWORD Dest = 0;
                memcpy( &Dest, pData, nBytesDest );
                pData += nBytesDest;
                nDataSize -= nBytesDest;
                
                // subnet address is obviously in network order.
                Dest = ntohl(Dest);
                
                // now the four bytes would be the router address
                DWORD Router = 0;
                if( nDataSize < sizeof(DWORD) )
                {
                    Assert( FALSE ); break;
                }
                
                memcpy(&Router, pData, sizeof(DWORD));
                Router = ntohl( Router );
                
                pData += sizeof(DWORD);
                nDataSize -= sizeof(DWORD);
                
                // now fill the list box..
                CString strDest, strMask, strRouter;
                
                ::UtilCvtIpAddrToWstr(Dest, &strDest);
                ::UtilCvtIpAddrToWstr(Mask, &strMask);
                ::UtilCvtIpAddrToWstr(Router, &strRouter);

                strBuf += strDest;
                strBuf += fLineFeed ? pszSepLF : pszSepComma;
                strBuf += strMask;
                strBuf += fLineFeed ? pszSepLF : pszSepComma;
                strBuf += strRouter;
                bEmpty = FALSE;

		strBuf += pszSepLF;
            }
            
            strResult += strBuf;
        }

        if( bEmpty )
        {
            strResult.LoadString( IDS_INFO_FORMAT_IP_NONE );
        }
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::SetString
(
    LPCTSTR	 pszNewValue,
    INT		 index
)
{
    if ( m_dhcpOptionDataType != DhcpStringDataOption )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( m_dhcpOptionValue.paString != NULL );

    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        m_dhcpOptionValue.paString->SetAtGrow( index, pszNewValue );
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::RemoveString
(
    INT		 index
)
{
    if ( m_dhcpOptionDataType != DhcpStringDataOption )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( m_dhcpOptionValue.paString != NULL );

    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        m_dhcpOptionValue.paString->RemoveAt( index );
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::SetNumber
(
    INT nValue,
    INT index
)
{
    if (   m_dhcpOptionDataType != DhcpByteOption
        && m_dhcpOptionDataType != DhcpWordOption
        && m_dhcpOptionDataType != DhcpDWordOption
        && m_dhcpOptionDataType != DhcpIpAddressOption
        && m_dhcpOptionDataType != DhcpBinaryDataOption
        && m_dhcpOptionDataType != DhcpEncapsulatedDataOption
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( m_dhcpOptionValue.paDword != NULL );

    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        if ( m_dhcpOptionDataType != DhcpBinaryDataOption &&
             m_dhcpOptionDataType != DhcpEncapsulatedDataOption)
        {
            m_dhcpOptionValue.paDword->SetAtGrow( index, (DWORD) nValue );
        }
        else
        {
            m_dhcpOptionValue.paBinary->SetAtGrow( index, (BYTE) nValue );
        }
   }
   END_MEM_EXCEPTION(err)

   return err;
}

LONG
CDhcpOptionValue::RemoveNumber
(
    INT index
)
{
    if (   m_dhcpOptionDataType != DhcpByteOption
        && m_dhcpOptionDataType != DhcpWordOption
        && m_dhcpOptionDataType != DhcpDWordOption
        && m_dhcpOptionDataType != DhcpIpAddressOption
        && m_dhcpOptionDataType != DhcpBinaryDataOption
        && m_dhcpOptionDataType != DhcpEncapsulatedDataOption
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT( m_dhcpOptionValue.paDword != NULL );

    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        if ( m_dhcpOptionDataType != DhcpBinaryDataOption &&
             m_dhcpOptionDataType != DhcpEncapsulatedDataOption )
        {
            m_dhcpOptionValue.paDword->RemoveAt( index );
        }
        else
        {
            m_dhcpOptionValue.paBinary->RemoveAt( index );
        }
   }
   END_MEM_EXCEPTION(err)

   return err;
}

LONG
CDhcpOptionValue::QueryNumber
(
    INT index
) const
{
    if (   m_dhcpOptionDataType != DhcpByteOption
        && m_dhcpOptionDataType != DhcpWordOption
        && m_dhcpOptionDataType != DhcpDWordOption
        && m_dhcpOptionDataType != DhcpIpAddressOption
        && m_dhcpOptionDataType != DhcpBinaryDataOption
        && m_dhcpOptionDataType != DhcpEncapsulatedDataOption
       )
    {
        return -1;
    }

    LONG cResult;

    if ( m_dhcpOptionDataType == DhcpBinaryDataOption ||
         m_dhcpOptionDataType == DhcpEncapsulatedDataOption )
    {
        ASSERT( m_dhcpOptionValue.paBinary != NULL );
        cResult = index < m_dhcpOptionValue.paBinary->GetSize()
             ? m_dhcpOptionValue.paBinary->GetAt( index )
             : -1;
    }
    else
    {
        ASSERT( m_dhcpOptionValue.paDword != NULL );
        cResult = index < m_dhcpOptionValue.paDword->GetSize()
            ? m_dhcpOptionValue.paDword->GetAt( index )
            : -1;
    }

    return cResult;
}

LPCTSTR
CDhcpOptionValue::QueryString
(
    INT index
) const
{
    if ( m_dhcpOptionDataType != DhcpStringDataOption )
    {
        return NULL;
    }

    const CString & str = m_dhcpOptionValue.paString->ElementAt( index );

    return str;
}

DHCP_IP_ADDRESS
CDhcpOptionValue::QueryIpAddr
(
    INT index
) const
{
    return (DHCP_IP_ADDRESS) QueryNumber( index );
}

LONG
CDhcpOptionValue::SetIpAddr
(
    DHCP_IP_ADDRESS dhcIpAddr,
    INT				index
)
{
    return SetNumber( (INT) dhcIpAddr, index );
}

LONG
CDhcpOptionValue::RemoveIpAddr
(
    INT		index
)
{
    return RemoveNumber( index );
}

BOOL
CDhcpOptionValue :: CreateBinaryData
(
    const DHCP_BINARY_DATA *	podBin,
	DHCP_BINARY_DATA *			pobData
)
{
    //
    //  Note: CObject::operator new asserts if data length is zero
    //
    pobData->Data = new BYTE [ podBin->DataLength + 1 ] ;
    if ( pobData == NULL )
    {
        return FALSE ;
    }

    pobData->DataLength = podBin->DataLength ;

    ::memcpy( pobData->Data, podBin->Data, pobData->DataLength ) ;

    return TRUE ;
}

BOOL
CDhcpOptionValue :: CreateBinaryData
(
    const CByteArray * paByte,
    DHCP_BINARY_DATA * pobData
)
{
    //
    //  Note: CObject::operator new asserts if data length is zero
    //
    pobData->Data = new BYTE [ (UINT) (paByte->GetSize() + 1) ] ;
    if ( pobData == NULL )
    {
        return NULL ;
    }

    pobData->DataLength = (DWORD) paByte->GetSize() ;

    for ( INT i = 0 ; i < paByte->GetSize() ; i++ )
    {
        pobData->Data[i] = paByte->GetAt( i ) ;
    }

    return TRUE ;
}

DWORD_DWORD
CDhcpOptionValue::QueryDwordDword
(
    int index
) const
{
   return m_dhcpOptionValue.paDwordDword->ElementAt( index );
}

LONG
CDhcpOptionValue::SetDwordDword
(
    DWORD_DWORD     dwdwValue,
    int             index
)
{
    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        m_dhcpOptionValue.paDwordDword->SetAtGrow( index, dwdwValue );
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::RemoveDwordDword
(
    int             index
)
{
    LONG err = 0;

    CATCH_MEM_EXCEPTION
    {
        m_dhcpOptionValue.paDwordDword->RemoveAt( index );
    }
    END_MEM_EXCEPTION(err)

    return err;
}

LONG
CDhcpOptionValue::CreateOptionDataStruct
(
//    const CDhcpOptionValue * pdhcpOptionValue,
	LPDHCP_OPTION_DATA *	 ppOptionData,
    BOOL					 bForceType
)
{
    DHCP_OPTION_DATA * podNew = NULL ;
    DHCP_OPTION_DATA_ELEMENT * podeNew ;
    LONG err = 0 ;

    FreeOptionDataStruct() ;

    INT cElem = QueryUpperBound();
    INT cElemMin = cElem ? cElem : 1;
	INT i, cBytes ;

    TCHAR * pwcsz ;

    if ( cElem < 0 || (cElem < 1 && ! bForceType) )
    {
        //ASSERT( FALSE ) ;
        return ERROR_INVALID_PARAMETER ;
    }

    CATCH_MEM_EXCEPTION
    {
        //
        //  Allocate the base structure and the array of elements.
        //
        cBytes = sizeof *podNew + (cElemMin * sizeof *podeNew) ;
        podNew = (DHCP_OPTION_DATA *) new BYTE [ cBytes ] ;
        podeNew = (DHCP_OPTION_DATA_ELEMENT *) ( ((BYTE *) podNew) + sizeof *podNew ) ;

        ::ZeroMemory(podNew, cBytes);

        podNew->NumElements = cElem;
        podNew->Elements = podeNew;

        //
        //  Initialize each element.  If we're forcing an option type def,
        //  just initialize to empty data.
        //
        if ( cElem == 0 && bForceType )
        {
            podNew->NumElements = 1 ;
            podeNew[0].OptionType = QueryDataType() ;

			switch ( podeNew[0].OptionType )
            {
                case DhcpByteOption:
                case DhcpWordOption:
                case DhcpDWordOption:
                case DhcpIpAddressOption:
                case DhcpDWordDWordOption:
                    podeNew[0].Element.DWordDWordOption.DWord1 = 0 ;
                    podeNew[0].Element.DWordDWordOption.DWord2 = 0 ;
                    break ;

                case DhcpStringDataOption:
                    podeNew[0].Element.StringDataOption = new WCHAR [1] ;
                    podeNew[0].Element.StringDataOption[0] = 0 ;
                    break ;

                case DhcpBinaryDataOption:
                case DhcpEncapsulatedDataOption:
                    podeNew[0].Element.BinaryDataOption.DataLength = 0 ;
                    podeNew[0].Element.BinaryDataOption.Data = new BYTE [1] ;
                    break ;

				default:
                    err = IDS_INVALID_OPTION_DATA ;
            }
        }
        else
        for ( i = 0 ; i < cElem ; i++ )
        {
            podeNew[i].OptionType = QueryDataType() ;

            switch ( podeNew[i].OptionType )
            {
                case DhcpByteOption:
                    podeNew[i].Element.ByteOption = (BYTE) QueryNumber( i ) ;
                    break ;

				case DhcpWordOption:
                    podeNew[i].Element.WordOption = (WORD) QueryNumber( i )  ;
                    break ;

				case DhcpDWordOption:
                    podeNew[i].Element.DWordOption = QueryNumber( i )  ;
                    break ;

				case DhcpDWordDWordOption:
                    podeNew[i].Element.DWordDWordOption = QueryDwordDword( i );
                    break ;

				case DhcpIpAddressOption:
                    podeNew[i].Element.IpAddressOption = QueryIpAddr( i ) ;
                    break ;

				case DhcpStringDataOption:
				{
					//CString * pstrTemp = new CString (QueryString(i));
					CString strTemp = QueryString(i);
					int nLength = strTemp.GetLength() + 1;
					TCHAR * pString = new TCHAR[nLength];

					::ZeroMemory(pString, nLength * sizeof(TCHAR));

					::CopyMemory(pString, strTemp, strTemp.GetLength() * sizeof(TCHAR));

                    podeNew[i].Element.StringDataOption = pString;
					break;
				}

                case DhcpBinaryDataOption:
                case DhcpEncapsulatedDataOption:
                    podNew->NumElements = 1;

                    if ( !CreateBinaryData(QueryBinaryArray(),
										   &podeNew[i].Element.BinaryDataOption) )
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY ;
                        break ;
                    }
                    break ;

				default:
                    err = IDS_INVALID_OPTION_DATA ;
            }

            if ( err )
            {
                break ;
            }
        }
    }
    END_MEM_EXCEPTION(err)

    if ( err == 0 )
    {
       m_pdhcpOptionDataStruct = podNew;
	   *ppOptionData = podNew;
    }

    return err ;
}

LONG
CDhcpOptionValue::FreeOptionDataStruct()
{
    LONG err = 0;

    if ( m_pdhcpOptionDataStruct == NULL )
    {
        return 0 ;
    }

	//
    //  We must deconstruct the struct build in CreateData()
    //
    INT cElem = m_pdhcpOptionDataStruct->NumElements ;

    for ( INT i = 0 ; i < cElem ; i++ )
    {
        switch ( m_pdhcpOptionDataStruct->Elements[i].OptionType )
        {
            case DhcpByteOption:
            case DhcpWordOption:
            case DhcpDWordOption:
            case DhcpDWordDWordOption:
            case DhcpIpAddressOption:
                break;

            case DhcpStringDataOption:
                delete m_pdhcpOptionDataStruct->Elements[i].Element.StringDataOption ;
                break ;

            case DhcpBinaryDataOption:
            case DhcpEncapsulatedDataOption:
                delete m_pdhcpOptionDataStruct->Elements[i].Element.BinaryDataOption.Data ;
                break ;

            default:
                err = IDS_INVALID_OPTION_DATA ;
                break;
        }
        if ( err )
        {
            break ;
        }
    }

    //
    //  Finally, delete the main structure
    //
    delete m_pdhcpOptionDataStruct ;
    m_pdhcpOptionDataStruct = NULL ;

    return err ;
}

/////////////////////////////////////////////////////////////////////
//
// CDhcpOption implementation
//
/////////////////////////////////////////////////////////////////////
//
//  Normal constructor: just wrapper the data given
//
CDhcpOption::CDhcpOption
(
    const DHCP_OPTION & dhpOption
)
    : m_dhcpOptionValue( dhpOption ),
      m_dhcpOptionId( dhpOption.OptionID ),
      m_dhcpOptionType( dhpOption.OptionType ),
      m_bDirty(FALSE),
	  m_dwErr(0)
{
    LONG err = 0 ;

    CATCH_MEM_EXCEPTION
    {
        if ( !(SetName(dhpOption.OptionName) &&
			   SetComment(dhpOption.OptionComment) ) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
    }
    END_MEM_EXCEPTION(err)

	if ( err )
    {
        ASSERT(FALSE);
        //ReportError( err ) ;
    }
}

//
//  Constructor taking just a value structure.  We must query
//  the scope for the name, etc.
//
CDhcpOption::CDhcpOption
(
    const DHCP_OPTION_VALUE &   dhcpOptionValue,
    LPCTSTR                     pszVendor,
    LPCTSTR                     pszUserClass
)
    : m_dhcpOptionValue( dhcpOptionValue ),
      m_dhcpOptionId( dhcpOptionValue.OptionID ),
      m_bDirty(FALSE),
	  m_dwErr(0),
      m_strVendor(pszVendor),
      m_strClassName(pszUserClass)
{
}

//
// Copy constructor
//
CDhcpOption::CDhcpOption
(
    const CDhcpOption & dhcpOption
)
  : m_dhcpOptionId( dhcpOption.m_dhcpOptionId ),
    m_dhcpOptionType( dhcpOption.m_dhcpOptionType ),
    m_strName( dhcpOption.m_strName ),
    m_strComment( dhcpOption.m_strComment ),
    m_dhcpOptionValue( dhcpOption.QueryDataType() ),
    m_bDirty(FALSE),
    m_dwErr(0),
    m_strVendor( dhcpOption.m_strVendor ),
    m_strClassName ( dhcpOption.m_strClassName )
{
    m_dhcpOptionValue = dhcpOption.QueryValue();
}

//
//  Constructor using a base type and an overriding value.
//
CDhcpOption::CDhcpOption
(
    const CDhcpOption & dhpType,
	const DHCP_OPTION_VALUE & dhcOptionValue
)
    : m_dhcpOptionId( dhpType.m_dhcpOptionId ),
      m_dhcpOptionType( dhpType.QueryOptType() ),
      m_strName( dhpType.m_strName ),
      m_strComment( dhpType.m_strComment ),
      m_dhcpOptionValue( dhcOptionValue ),
      m_bDirty(FALSE),
      m_dwErr(0),
      m_strVendor(dhpType.m_strVendor),
      m_strClassName(dhpType.m_strClassName)
{
}

//
// Constructor for dynamic instances
//
CDhcpOption::CDhcpOption
(
    DHCP_OPTION_ID			nId,
    DHCP_OPTION_DATA_TYPE	dhcType,
    LPCTSTR					pszOptionName,
    LPCTSTR					pszComment,
    DHCP_OPTION_TYPE		dhcOptType
)
    : m_dhcpOptionId( nId ),
      m_dhcpOptionType( dhcOptType ),
      m_dhcpOptionValue( dhcType, TRUE ),
      m_strName( pszOptionName ),
      m_strComment( pszComment ),
      m_bDirty(FALSE),
      m_dwErr(0)
{
}

CDhcpOption::~ CDhcpOption ()
{
}

INT
CDhcpOption::MaxSizeOfType
(
    DHCP_OPTION_DATA_TYPE dhcType
)
{
    INT nResult = -1 ;

    switch ( dhcType )
    {
        case DhcpByteOption:
            nResult = sizeof(CHAR) ;
            break ;

        case DhcpWordOption:
            nResult = sizeof(WORD) ;
            break ;

        case DhcpDWordOption:
            nResult = sizeof(DWORD) ;
            break ;

        case DhcpIpAddressOption:
            nResult = sizeof(DHCP_IP_ADDRESS) ;
            break ;

        case DhcpDWordDWordOption:
            nResult = sizeof(DWORD_DWORD);
            break ;

        case DhcpBinaryDataOption:
        case DhcpEncapsulatedDataOption:
        case DhcpStringDataOption:
            nResult = STRING_LENGTH_MAX ;
            break ;

        default:
            break;
    }
    return nResult ;
}

void
CDhcpOption::SetOptType
(
    DHCP_OPTION_TYPE dhcOptType
)
{
    m_dhcpOptionType = dhcOptType;
}

LONG
CDhcpOption::Update
(
    const CDhcpOptionValue & dhpOptionValue
)
{
    m_dhcpOptionValue = dhpOptionValue;

    return 0;
}

BOOL
CDhcpOption::SetName
(
    LPCTSTR pszName
)
{
    m_strName = pszName;
    return TRUE;
}

BOOL
CDhcpOption::SetComment
(
    LPCTSTR pszComment
)
{
    m_strComment = pszComment;
    return TRUE;
}

void
CDhcpOption::QueryDisplayName
(
    CString & cStr
) const
{
	cStr.Format(_T("%3.3d %s"), (int) QueryId(), (LPCTSTR) m_strName);
}

/*---------------------------------------------------------------------------
	Class COptionValueEnum
        Enumerates the options for a given level.  Generates a list of
        nodes.
	Author: EricDav
 ---------------------------------------------------------------------------*/
COptionValueEnum::COptionValueEnum()
{
}

/*---------------------------------------------------------------------------
	COptionValueEnum::Init()
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionValueEnum::Init
(
    LPCTSTR                     pServer,
    LARGE_INTEGER &             liVersion,
    DHCP_OPTION_SCOPE_INFO &    dhcpOptionScopeInfo
)
{
    m_strServer = pServer;
    m_liVersion.QuadPart = liVersion.QuadPart;

    m_dhcpOptionScopeInfo = dhcpOptionScopeInfo;

    return 0;
}

/*---------------------------------------------------------------------------
	COptionValueEnum::Copy()
		Copies another value enum
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
COptionValueEnum::Copy(COptionValueEnum * pEnum)
{
    CDhcpOption * pOption = NULL;

    pEnum->Reset();
    while (pOption = pEnum->Next())
    {
        AddTail(pOption);
    }

    m_liVersion.QuadPart = pEnum->m_liVersion.QuadPart;
    m_dhcpOptionScopeInfo = pEnum->m_dhcpOptionScopeInfo;
}

/*---------------------------------------------------------------------------
	COptionValueEnum::Remove()
		removes an option from the list
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
COptionValueEnum::Remove(DHCP_OPTION_ID optionId, LPCTSTR pszVendor, LPCTSTR pszClass)
{
    CDhcpOption * pOption = NULL;

    Reset();
    while (pOption = Next())
    {
        if ( pOption->QueryId() == optionId &&
             (lstrcmp(pOption->GetVendor(), pszVendor) == 0) &&
             (lstrcmp(pOption->GetClassName(), pszClass) == 0) )
        {
            COptionList::Remove(pOption);
            delete pOption;
            break;
        }
    }
}

/*---------------------------------------------------------------------------
	COptionValueEnum::Enum()
		Calls the appropriate enum function depending upon version
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionValueEnum::Enum()
{
    DWORD dwErr;

    RemoveAll();

    if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        // enumerate standard plus the vendor and class ID based options
        dwErr = EnumOptionsV5();
    }
    else
    {
        // Enumerate the standard options
        dwErr = EnumOptions();
    }

    // reset our position pointer to the head
    Reset();

    return dwErr;
}

/*---------------------------------------------------------------------------
	COptionValueEnum::EnumOptions()
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionValueEnum::EnumOptions()
{
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues = NULL;
	DWORD dwOptionsRead = 0, dwOptionsTotal = 0;
	DWORD err = ERROR_SUCCESS;
    HRESULT hr = hrOK;
    DHCP_RESUME_HANDLE dhcpResumeHandle = NULL;

	err = ::DhcpEnumOptionValues((LPWSTR) ((LPCTSTR) m_strServer),
								 &m_dhcpOptionScopeInfo,
								 &dhcpResumeHandle,
								 0xFFFFFFFF,
								 &pOptionValues,
								 &dwOptionsRead,
								 &dwOptionsTotal);
	
    Trace4("Server %s - DhcpEnumOptionValues returned %lx, read %d, Total %d.\n", m_strServer, err, dwOptionsRead, dwOptionsTotal);
	
	if (dwOptionsRead && dwOptionsTotal && pOptionValues)
	{
		for (DWORD i = 0; i < dwOptionsRead; i++)
		{
			//
			// Filter out the "special" option values that we don't want the
			// user to see.
			//
			// CODEWORK: don't filter vendor specifc options... all vendor
            // specifc options are visible.
            //
			if (FilterOption(pOptionValues->Values[i].OptionID))
				continue;
			
			//
			// Create the result pane item for this element
			//
            CDhcpOption * pOption = new CDhcpOption(pOptionValues->Values[i], NULL, NULL);

            AddTail(pOption);
		}

		::DhcpRpcFreeMemory(pOptionValues);
	}

	if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

    return err;
}

/*---------------------------------------------------------------------------
	COptionValueEnum::EnumOptionsV5()
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
COptionValueEnum::EnumOptionsV5()
{
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues = NULL;
    LPDHCP_ALL_OPTION_VALUES  pAllOptions = NULL;
    DWORD dwNumOptions, err, i;

    err = ::DhcpGetAllOptionValues((LPWSTR) ((LPCTSTR) m_strServer),
                                   0,
								   &m_dhcpOptionScopeInfo,
								   &pAllOptions);
	
    Trace2("Server %s - DhcpGetAllOptionValues (Global) returned %lx\n", m_strServer, err);

    if (err == ERROR_NO_MORE_ITEMS || err == ERROR_SUCCESS)
    {
	    if (pAllOptions == NULL)
	    {
		    // This happens when stressing the server.  Perhaps when server is OOM.
		    err = ERROR_OUTOFMEMORY;
            return err;
	    }

        // get the list of options (vendor and non-vendor) defined for
        // the NULL class (no class)
        for (i = 0; i < pAllOptions->NumElements; i++)
        {
            CreateOptions(pAllOptions->Options[i].OptionsArray,
                          pAllOptions->Options[i].ClassName,
                          pAllOptions->Options[i].VendorName);
        }

        if (pAllOptions)
            ::DhcpRpcFreeMemory(pAllOptions);
	}

    if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

	return err;
}

/*---------------------------------------------------------------------------
	COptionValueEnum::CreateOptions()
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
COptionValueEnum::CreateOptions
(
    LPDHCP_OPTION_VALUE_ARRAY pOptionValues,
    LPCTSTR                   pClassName,
    LPCTSTR                   pszVendor
)
{
    HRESULT hr = hrOK;
    SPITFSNode spNode;
    CDhcpOptionItem * pOptionItem;
    CString     strDynBootpClassName;

    if (pOptionValues == NULL)
        return hr;

    Trace1("COptionValueEnum::CreateOptions - Creating %d options\n", pOptionValues->NumElements);

    COM_PROTECT_TRY
    {
        for (DWORD i = 0; i < pOptionValues->NumElements; i++)
        {
	        //
	        // Filter out the "special" option values that we don't want the
	        // user to see.
	        //
	        // don't filter vendor specifc options... all vendor
            // specifc options are visible.
            //
            // also don't filter out class based options
            // except for dynamic bootp class

	        if ( (FilterOption(pOptionValues->Values[i].OptionID) &&
                  pClassName == NULL &&
                  !pszVendor) ||
                 (FilterOption(pOptionValues->Values[i].OptionID) &&
                  (pClassName && m_strDynBootpClassName.CompareNoCase(pClassName) == 0) &&
                  !pszVendor) )
            {
		        continue;
            }
		
	        //
	        // Create the option
	        //
            CDhcpOption * pOption = new CDhcpOption(pOptionValues->Values[i], pszVendor, pClassName);

            AddTail(pOption);
        }
    }
    COM_PROTECT_CATCH

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
// CDhcpDefaultOptionsOnServer implementation
//
/////////////////////////////////////////////////////////////////////
LPCTSTR pszResourceName = _T("DHCPOPT") ;
LPCTSTR pszResourceType = _T("TEXT") ;
const int cchFieldMax = 500 ;

OPT_TOKEN aOptToken [] =
{
    { DhcpIpAddressOption,        _T("IP Addr")       },
    { DhcpIpAddressOption,        _T("IPAddr")        },
    { DhcpIpAddressOption,        _T("IP Address")    },
    { DhcpIpAddressOption,        _T("IP Pairs")      },
    { DhcpByteOption,             _T("byte")          },
    { DhcpByteOption,             _T("boolean")       },
    { DhcpByteOption,             _T("octet")         },
    { DhcpWordOption,             _T("short")         },
    { DhcpDWordOption,            _T("long")          },
    { DhcpDWordDWordOption,       _T("double")        },
    { DhcpStringDataOption,       _T("string")        },
    { DhcpBinaryDataOption,       _T("binary")        },
    { DhcpEncapsulatedDataOption, _T("encapsulated")  },
    { -1,                         _T("generated")     },
    { -1,                         NULL                }
};

CDhcpDefaultOptionsOnServer::CDhcpDefaultOptionsOnServer()
{
	m_pos = NULL;
}

CDhcpDefaultOptionsOnServer::~CDhcpDefaultOptionsOnServer()
{
	RemoveAll();
}

LONG
CDhcpDefaultOptionsOnServer::RemoveAll()
{
	//
	// Clean the list of all old entries
	//
	while (!m_listOptions.IsEmpty())
	{
		delete m_listOptions.RemoveHead();
	}

	return 0;
}

CDhcpOption *
CDhcpDefaultOptionsOnServer::First()
{
	Reset();
	return Next();
}

CDhcpOption *
CDhcpDefaultOptionsOnServer::Next()
{
    return m_pos == NULL ? NULL : m_listOptions.GetNext( m_pos ) ;
}

void
CDhcpDefaultOptionsOnServer::Reset()
{
    m_pos = m_listOptions.GetCount() ? m_listOptions.GetHeadPosition() : NULL ;
}

CDhcpOption *
CDhcpDefaultOptionsOnServer::Find
(
	DHCP_OPTION_ID	dhcpOptionId,
    LPCTSTR         pszVendor
)
{
	POSITION pos = m_listOptions.GetHeadPosition();
	CDhcpOption* pCurrent;
	CDhcpOption* pFound = NULL;
    CString      strVendor = pszVendor;

	while (pos != NULL)
	{
	    pCurrent = m_listOptions.GetNext(pos);

		// check the options IDs and the vendor classes match
        if ( (pCurrent->QueryId() == dhcpOptionId) &&
             ( (!pszVendor && !pCurrent->GetVendor()) ||
               (pCurrent->GetVendor() && (strVendor.CompareNoCase(pCurrent->GetVendor()) == 0) ) ) )
		{
			pFound = pCurrent;
			break;
		}
	}

	return pFound;
}

// Sorts the options by ID
LONG
CDhcpDefaultOptionsOnServer::SortById()
{
    return m_listOptions.SortById();
}

LONG
CDhcpDefaultOptionsOnServer::Enumerate
(
	LPCWSTR         pServer,
    LARGE_INTEGER   liVersion
)
{
    if (liVersion.QuadPart >= DHCP_NT5_VERSION)
    {
        return EnumerateV5(pServer);
    }
    else
    {
        return EnumerateV4(pServer);
    }
}

LONG
CDhcpDefaultOptionsOnServer::EnumerateV4
(
	LPCWSTR         pServer
)
{
    //
    // Use new API to get the param types
    //
    LPDHCP_OPTION_ARRAY pOptionsArray = NULL;
    DHCP_RESUME_HANDLE	dhcpResumeHandle = NULL;
    LPDHCP_OPTION Options, pCurOption;
    DWORD i;
    DWORD dwNumOptions;
	DWORD dwOptionsRead;
	LONG  err;

    err = ::DhcpEnumOptions(pServer,
							&dhcpResumeHandle,
							0xFFFFFFFF,			// get all.
							&pOptionsArray,
							&dwOptionsRead,
							&m_dwOptionsTotal );
    if ( err )
    {
		return err;
    }

    //
    //  Discard all the old data
    //
    RemoveAll() ;

	if (pOptionsArray == NULL)
	{
		// This happens when stressing the server.  Perhaps when server is OOM.
		return ERROR_OUTOFMEMORY;
	}

	try
    {
        Options = pOptionsArray->Options;
        dwNumOptions = pOptionsArray->NumElements;
		
		if ((dwNumOptions > 0) && (Options == NULL))
		{
			ASSERT(FALSE && _T("Data Inconsistency"));
			return ERROR_OUTOFMEMORY;	// Just in case
		}

        for(i = 0; i < dwNumOptions; i++)
        {
            //
            //  Create the new type object.
            //
			pCurOption = Options + i;
            CDhcpOption * pdhcpOption = new CDhcpOption(*pCurOption);

	        //
            //  Add the new host to the list.
            //
	        m_listOptions.AddTail(pdhcpOption);
        }
    }
    catch (...)
	{
       err = ERROR_NOT_ENOUGH_MEMORY;
	}

    ::DhcpRpcFreeMemory(pOptionsArray);
    pOptionsArray = NULL;

	Reset();

	return err;
}

LONG
CDhcpDefaultOptionsOnServer::EnumerateV5
(
	LPCWSTR         pServer
)
{
    //
    // Use new API to get the param types
    //
    LPDHCP_OPTION       Options, pCurOption;
    DWORD               i;
    DWORD               dwNumOptions = 0;
	DWORD               dwOptionsRead = 0;
    DWORD               dwFlags = 0;
    LONG                err = 0;
    LPDHCP_ALL_OPTIONS  pAllOptions = NULL;


    err = ::DhcpGetAllOptions((LPWSTR) pServer,
                              dwFlags,
                              &pAllOptions);

    if ( err )
    {
        if ( NULL != pAllOptions ) {
            ::DhcpRpcFreeMemory( pAllOptions );
        }
        return err;
    }

    //
    //  Discard all the old data
    //
    RemoveAll() ;

    if (pAllOptions == NULL)
    {
        // This happens when stressing the server.  Perhaps when server is OOM.
        return ERROR_OUTOFMEMORY;
    }

    try
    {
        // first pull out the non-vendor options
        if (pAllOptions->NonVendorOptions != NULL)
        {
            Options = pAllOptions->NonVendorOptions->Options;
            dwNumOptions = pAllOptions->NonVendorOptions->NumElements;
        }
        if ((dwNumOptions > 0) && (Options == NULL))
        {
            ASSERT(FALSE && _T("Data Inconsistency"));
            ::DhcpRpcFreeMemory( pAllOptions );
            return ERROR_OUTOFMEMORY;	// Just in case
        }

        for (i = 0; i < dwNumOptions; i++)
        {
            //
            //  Create the new type object.
            //
            pCurOption = Options + i;
            CDhcpOption * pdhcpOption = new CDhcpOption(*pCurOption);

            //
            //  Add the new host to the list.
            //
            m_listOptions.AddTail(pdhcpOption);
        }

        // now the vendor options
        for (i = 0; i < pAllOptions->NumVendorOptions; i++)
        {
            pCurOption = &pAllOptions->VendorOptions[i].Option;

            CDhcpOption * pdhcpOption = new CDhcpOption(*pCurOption);

            pdhcpOption->SetVendor(pAllOptions->VendorOptions[i].VendorName);

            //
            //  Add the new host to the list.
            //
            m_listOptions.AddTail(pdhcpOption);
        }
    }
    catch (...)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (pAllOptions)
        ::DhcpRpcFreeMemory(pAllOptions);

    SortById();
    Reset();

    return err;
}

/////////////////////////////////////////////////////////////////////
//
// CDhcpDefaultOptionsMasterList implementation
//
/////////////////////////////////////////////////////////////////////
CDhcpDefaultOptionsMasterList::CDhcpDefaultOptionsMasterList()
{
	m_pos = NULL;
}

CDhcpDefaultOptionsMasterList::~CDhcpDefaultOptionsMasterList()
{
	//
	// Delete all entries in the list
	//
	while (!m_listOptions.IsEmpty())
	{
		delete m_listOptions.RemoveHead();
	}
}

CDhcpOption *
CDhcpDefaultOptionsMasterList::First()
{
	Reset();
	return Next();
}

CDhcpOption *
CDhcpDefaultOptionsMasterList::Next()
{
    return m_pos == NULL ? NULL : m_listOptions.GetNext( m_pos ) ;
}

void
CDhcpDefaultOptionsMasterList::Reset()
{
    m_pos = m_listOptions.GetCount() ? m_listOptions.GetHeadPosition() : NULL ;
}

int
CDhcpDefaultOptionsMasterList::GetCount()
{
    return (int)m_listOptions.GetCount();
}

long
CDhcpDefaultOptionsMasterList::BuildList()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LONG			err = 0 ;
    CDhcpOption *	pOption;
    HRSRC			hRes = NULL ;
    HGLOBAL			hText = NULL ;
    LPTSTR			pszText = NULL ;
    LPCTSTR			pcszText ;
    size_t			cchText = 0;
    UINT            uBufSize = 0;
    LPTSTR *		szParms;
	TCHAR			szUnknown[] = _T("(Unknown)");  // This is just to prevent a GP fault (should not be in resource)

    CATCH_MEM_EXCEPTION
    {
        do
        {
            //
            // IMPORTANT!!! There is no way to determine from the .mc file how many
            //              options are defined.  This number is therefore hard-coded
            //              here, and should reflect the highest parameter number in
            //              the .mc file.
            //

			// The extra 16 entries are for safety
			// when calling FormatMessage().
            szParms = new LPTSTR[IDS_OPTION_MAX + 16];

            Trace0("BuildList - Now building list of option parameters\n");

            CString strOptionText;

			// Initialize the extra entries to something that will not GP fault.
			for (int i = 0; i < 16; i++)
			{
				szParms[IDS_OPTION_MAX+i] = szUnknown;
			}

			//
            // Don't mess with the order of the ID definitions!!!
            //
            for (i = 0; i < IDS_OPTION_MAX; ++i)
            {
                if (strOptionText.LoadString(IDS_OPTION1 + i))
                {
                    ASSERT(strOptionText.GetLength() > 0);

                    uBufSize += strOptionText.GetLength();
                    szParms[i] = new TCHAR[strOptionText.GetLength()+1];

                    ::_tcscpy(szParms[i], (LPCTSTR)strOptionText);
                }
                else
                {
                    //
                    // Failed to load the string from the resource
                    // for some reason.
                    //
					CString strTemp;
					strTemp.LoadString(IDS_OPTION1 + i);
					Trace1("BuildList - WARNING: Failed to load option text %s\n", strTemp);
                    err = ::GetLastError();
					szParms[i] = szUnknown; // Prevent from GP faulting
                    break;
                }
            }

            if (err != ERROR_SUCCESS)
            {
                break;
            }

            // allocate a buffer big enough to hold the data
            uBufSize *= sizeof(TCHAR);
            uBufSize *= 2;

            pszText = (LPTSTR) malloc(uBufSize);
            if (pszText == NULL)
            {
                err = ERROR_OUTOFMEMORY;
                break;
            }

			//
			// Since we are a COM object, get our instance handle to use so that FormatMessage
			// looks in the right place for our resources.
			//
			HINSTANCE hInst = _Module.GetModuleInstance();

            while (cchText == 0)
            {
                cchText = ::FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
					  FORMAT_MESSAGE_ARGUMENT_ARRAY,
					  (HMODULE) hInst,		// hModule
					  DHCP_OPTIONS,			// dwMessageId loaded from a system dll
					  0L,				// dwLanguageId
					  OUT (LPTSTR)pszText,
					  uBufSize/sizeof(TCHAR),
					  (va_list *)szParms);

                if (cchText == 0)
                {
                    err = ::GetLastError();
			        Trace1("BuildList - FormatMessage failed - error %d\n", err);

                    // grow the buffer and try again
                    uBufSize += uBufSize/2;
                    LPTSTR pTemp = (LPTSTR) realloc(pszText, uBufSize);
                    if ( NULL == pTemp )
                    {
                        err = ERROR_OUTOFMEMORY;
                        break;
                    }
                    else {
                        pszText = pTemp;
                    }
                }
                else
                {
                    // done
                    break;
                }
            }

            //
            //  Walk the resource, parsing each line.  If the line converts
            //  to a tangible type, add it to the list.
            //
            for ( pcszText = pszText ;  pcszText ; )
            {
                scanNextParamType( &pcszText, &pOption);

                if ( pOption )
                {
                    m_listOptions.AddTail(pOption) ;
                }
            }

        } while ( FALSE ) ;
    }
    END_MEM_EXCEPTION( err )

    for (int i = 0; i < IDS_OPTION_MAX; ++i)
    {
		if (szParms[i] != szUnknown)
			delete[] szParms[i];
    }

    delete[] szParms;
    free(pszText);

	Reset();

	return NOERROR;
}


BOOL
CDhcpDefaultOptionsMasterList::scanNextParamType
(
    LPCTSTR *	     ppszText,
    CDhcpOption * *  ppOption
)
{
    TCHAR		szField [ cchFieldMax ] ;
    TCHAR		szName  [ cchFieldMax ] ;
    TCHAR		szComment [ cchFieldMax ] ;
    BOOL		bResult = TRUE ;
    BOOL		bArray = FALSE ;
    int eofld, cch, itype, cbLgt ;
    LPCTSTR		pszText = *ppszText ;
    CDhcpOption * pOption = NULL ;
    const DWORD INVALID_OPTION_ID = 0xFFFF;
    DHCP_OPTION_ID did = INVALID_OPTION_ID;
    DHCP_OPTION_DATA_TYPE dtype = (DHCP_OPTION_DATA_TYPE)0;

    for ( eofld = OPTF_OPTION ;
          pszText = scanNextField( pszText, szField, sizeof szField ) ;
          eofld++ )
    {
        cch = ::_tcslen( szField ) ;

        switch ( eofld )
        {
            case OPTF_OPTION:
                if ( cch > 0 && allDigits( szField ) )
                {
                    did = (DHCP_OPTION_ID) ::_ttoi( szField ) ;
                }
                else {
                    bResult = FALSE;
                }
                break ;

            case OPTF_NAME:
                if ( ::_tcslen( szField ) == 0 )
                {
                    bResult = FALSE;
                    break ;
                }
                ::_tcscpy( szName, szField ) ;
                break ;

            case OPTF_TYPE:
                if ( (itype = recognizeToken( aOptToken, szField )) < 0 )
                {
                    Trace2("options CSV ID %d, cannot reconize type %s\n", did, szField);
                    bResult = FALSE ;
                    break ;
                }
                dtype = (DHCP_OPTION_DATA_TYPE) itype ;
                break ;

            case OPTF_ARRAY_FLAG:
                bArray = szField[0] == 'y' || szField[0] == 'Y' ;
                break ;

            case OPTF_LENGTH:
                cbLgt = ::_ttoi( szField ) ;
                break ;
            case OPTF_DESCRIPTION:
                ::_tcscpy( szComment, szField ) ;
                break ;

            case OPTF_REMARK:
            case OPTF_MAX:
                break ;
        }

        if ( eofld == OPTF_REMARK || ! bResult )
        {
            pszText = skipToNextLine( pszText ) ;
            if ( *pszText == 0 )
            {
                pszText = NULL ;
            }
            break;
        }
    }

    if (( bResult ) && ( INVALID_OPTION_ID != did ))
    {
        pOption = new CDhcpOption( did,
                                   dtype,
                                   szName,
                                   szComment,
                                   bArray ? DhcpArrayTypeOption :
                                   DhcpUnaryElementTypeOption ) ;
    }

    if ( bResult )
    {
        *ppOption = pOption ;
    }
    else
    {
        delete pOption ;
        *ppOption = NULL ;
    }

    *ppszText = pszText ;
    return pszText != NULL ;
}

LPCTSTR
CDhcpDefaultOptionsMasterList::scanNextField
(
    LPCTSTR pszLine,
    LPTSTR	pszOut,
    int		cFieldSize
)
{
    //
    // Skip junk; return NULL if end-of-buffer.
    //
    if ( ! skipWs( & pszLine ) )
    {
        return NULL ;
    }

    int cch = 0 ;
    BOOL bDone = FALSE ;
    LPTSTR pszField = pszOut ;
    TCHAR ch ;

    if ( *pszLine == '\"' )
    {
        //
        //  Quoted string.
        //
        while ( ch = *++pszLine )
        {
            if ( ch == '\r' )
            {
                continue ;
            }
            if ( ch == '\n' || ch == '\"' || cch == cFieldSize )
            {
                break ;
            }
            *pszField++ = ch ;
            cch++ ;
        }
        if ( ch == '\"' )
        {
            pszLine++ ;
        }
    }
    else
    while ( ! bDone )
    {
        ch = *pszLine++ ;

        ASSERT( ch != 0 ) ;

        switch ( ch )
        {
            case '\n':
                pszLine-- ;  // Don't scan past the NL
            case ',':
            case '\r':
                bDone = TRUE ;
                break ;
            default:
                if ( cch < cFieldSize )
                {
                    *pszField++ = ch ;
                    cch++ ;
                }
                break ;
        }
    }

    //
    //  Trim spaces off the end of the field.
    //
    while ( pszField > pszOut && *(pszField-1) == ' ' )
    {
        pszField-- ;
    }
    *pszField = 0 ;
    return pszLine ;
}

BOOL
CDhcpDefaultOptionsMasterList::allDigits
(
    LPCTSTR psz
)
{
    for ( ; *psz ; psz++ )
    {
        if ( ! isdigit( *psz ) )
        {
            return FALSE ;
        }
    }

    return TRUE ;
}

int
CDhcpDefaultOptionsMasterList::recognizeToken
(
    OPT_TOKEN * apToken,
    LPCTSTR		pszToken
)
{
    int i ;
    for ( i = 0 ;
          apToken[i].pszOptTypeName && ::lstrcmpi( apToken[i].pszOptTypeName, pszToken ) != 0 ;
           i++ ) ;

    return apToken[i].eOptType ;
}

LPCTSTR
CDhcpDefaultOptionsMasterList::skipToNextLine
(
    LPCTSTR pszLine
)
{
    for ( ; *pszLine && *pszLine != '\n' ; pszLine++ ) ;
    if ( *pszLine )
    {
        pszLine++ ;   // Don't overscan buffer delimiter.
    }
    return pszLine ;
}

BOOL
CDhcpDefaultOptionsMasterList::skipWs
(
    LPCTSTR * ppszLine
)
{
     LPCTSTR pszLine ;
     BOOL bResult = FALSE ;

     for ( pszLine = *ppszLine ; *pszLine ; pszLine++ )
     {
        switch ( *pszLine )
        {
            case ' ':
            case '\r':
            case '\t':
                break ;
            default:
                bResult = TRUE ;
                break ;
        }
        if ( bResult )
        {
            break ;
        }
     }

     *ppszLine = pszLine ;
     return *pszLine != 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscope.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        mscope.cpp
        This file contains the implementation for the multicast scope node.
                
    FILE HISTORY:
    9/25/97     EricDav     Created    

*/

#include "stdafx.h"
#include "server.h"         // Server definition
#include "nodes.h"              // Result pane node definitions
#include "mscope.h"     // mscope definition
#include "addexcl.h"
#include "mscopepp.h"   // properties of the mScope
#include "dlgrecon.h"   // reconcile dialog


/*---------------------------------------------------------------------------
        GetLangTag
                Sets the language tag based on the name
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
GetLangTag
(
    CString & strLangTag
)
{
    char b1[32], b2[32];
    static char buff[80];

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO639LANGNAME, b1, sizeof(b1));

    GetLocaleInfoA(LOCALE_SYSTEM_DEFAULT, LOCALE_SISO3166CTRYNAME, b2, sizeof(b2));

    ZeroMemory(buff, sizeof(buff));

    if (_stricmp(b1, b2))
        sprintf(buff, "%s-%s", b1, b2);
    else
        strcpy(buff, b1);

    strLangTag = buff;
}

/*---------------------------------------------------------------------------
        Class CDhcpMScope implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpMScope::CDhcpMScope
(
        ITFSComponentData* pTFSComponentData
) : CMTDhcpHandler(pTFSComponentData)
{
}

CDhcpMScope::~CDhcpMScope()
{
}

/*!--------------------------------------------------------------------------
        CDhcpMScope::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::InitializeNode
(
        ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strDisplayName;
    
    BuildDisplayName(&strDisplayName, m_SubnetInfo.SubnetName);
    SetDisplayName(strDisplayName);
    
    if (m_SubnetInfo.SubnetState == DhcpSubnetDisabled)
    {
        m_strState.LoadString(IDS_SCOPE_INACTIVE);
    }
    else
    {
        m_strState.LoadString(IDS_SCOPE_ACTIVE);
    }

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_MSCOPE);
    
    SetColumnStringIDs(&aColumns[DHCPSNAP_MSCOPE][0]);
    SetColumnWidths(&aColumnWidths[DHCPSNAP_MSCOPE][0]);
    
    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpMScope::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();
    
    CString strNode, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    // id string is server name, scope name and guid.
    strNode = GetServerObject()->GetName();
    strNode += GetName() + strGuid;

    strId = strNode;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CDhcpMScope::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    switch (m_nState)
    {
        // TODO: these need to be updated with new busy state icons
        case loading:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY : ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY : ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY;
            return nIndex;

        case notLoaded:
        case loaded:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_OPEN : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_CLOSED : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED;
            break;

        case unableToLoad:
            if (bOpenImage)
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_OPEN_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN_LOST_CONNECTION;
            else
                nIndex = (IsEnabled()) ? ICON_IDX_SCOPE_FOLDER_CLOSED_LOST_CONNECTION : ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED_LOST_CONNECTION;
            return nIndex;

        default:
                        ASSERT(FALSE);
    }

    if (m_spServerNode && IsEnabled())
    {
        CDhcpServer * pServer = GetServerObject();
        LPDHCP_MCAST_MIB_INFO pMibInfo = pServer->DuplicateMCastMibInfo();
            
        if (!pMibInfo)
            return nIndex;

        LPMSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

            // walk the list of scopes and find our info
            for (UINT i = 0; i < pMibInfo->Scopes; i++)
            {
                    // Find our scope stats
                    if ( (m_SubnetInfo.SubnetName.CompareNoCase(pScopeMibInfo[i].MScopeName) == 0) &&
                 (m_SubnetInfo.SubnetAddress == pScopeMibInfo[i].MScopeId) )
                    {
                            int nPercentInUse;
                
                if ((pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree) == 0)
                    nPercentInUse = 0;
                else
                    nPercentInUse = (pScopeMibInfo[i].NumAddressesInuse * 100) / (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
        
                            // look to see if this scope meets the warning or red flag case
                            if (pScopeMibInfo[i].NumAddressesFree == 0)
                            {
                                    // red flag case, no addresses free, this is the highest
                                    // level of warning, so break out of the loop if we set this.
                    if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_FOLDER_OPEN_ALERT;
                    else
                        nIndex = ICON_IDX_SCOPE_FOLDER_CLOSED_ALERT;
                                    break;
                            }
                            else
                            if (nPercentInUse >= SCOPE_WARNING_LEVEL)
                            {
                                    // warning condition if Num Addresses in use is greater than
                                    // some pre-defined threshold.
                    if (bOpenImage)
                        nIndex = ICON_IDX_SCOPE_FOLDER_OPEN_WARNING;
                    else
                        nIndex = ICON_IDX_SCOPE_FOLDER_CLOSED_WARNING;
                            }

                            break;
                    }
            }

            pServer->FreeDupMCastMibInfo(pMibInfo);
    }

    return nIndex;
}

/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpMScope::OnAddMenuItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpMScope::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG    fFlags = 0, fLoadingFlags = 0;
    HRESULT hr = S_OK;
    CString strMenuText;
    
    if ( m_nState != loaded )
    {
        fFlags |= MF_GRAYED;
    }
    
    if ( m_nState == loading)
    {
        fLoadingFlags = MF_GRAYED;
    }
    
    if (type == CCT_SCOPE)
    {
        //
        // these menu items go in the new menu, 
        // only visible from scope pane
        //
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuText.LoadString(IDS_SCOPE_SHOW_STATISTICS);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuText, 
                                     IDS_SCOPE_SHOW_STATISTICS,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     fFlags );
            ASSERT( SUCCEEDED(hr) );
            
            // separator
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuText, 
                                     0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     MF_SEPARATOR);
            ASSERT( SUCCEEDED(hr) );
            
            // reconcile 
            strMenuText.LoadString(IDS_SCOPE_RECONCILE);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuText, 
                                     IDS_SCOPE_RECONCILE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     fFlags );
            ASSERT( SUCCEEDED(hr) );
            
            // separator
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuText, 
                                     0,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     MF_SEPARATOR);
            ASSERT( SUCCEEDED(hr) );
            
            // activate/deactivate
            if (m_SubnetInfo.SubnetState == DhcpSubnetDisabled)
            {
                strMenuText.LoadString(IDS_SCOPE_ACTIVATE);
                hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                         strMenuText, 
                                         IDS_SCOPE_ACTIVATE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                         fFlags );
                ASSERT( SUCCEEDED(hr) );
            }
            else
            {
                strMenuText.LoadString(IDS_SCOPE_DEACTIVATE);
                hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                         strMenuText, 
                                         IDS_SCOPE_DEACTIVATE,
                                         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                         fFlags );
                ASSERT( SUCCEEDED(hr) );
            }
        }
    }
    
    return hr; 
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpMScope::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
    HRESULT hr = S_OK;

    switch (nCommandId)
    {
    case IDS_ACTIVATE:
    case IDS_DEACTIVATE:
    case IDS_SCOPE_ACTIVATE:
    case IDS_SCOPE_DEACTIVATE:
        OnActivateScope(pNode);
        break;
                
    case IDS_REFRESH:
        OnRefresh(pNode, pDataObject, dwType, 0, 0);
        break;

    case IDS_SCOPE_SHOW_STATISTICS:
        OnShowScopeStats(pNode);
        break;

    case IDS_SCOPE_RECONCILE:
        OnReconcileScope(pNode);
        break;

    case IDS_DELETE:
        OnDelete(pNode);
        break;

    default:
        break;
    }

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpMScope::CreatePropertyPages
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider,
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle, 
        DWORD                                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    DWORD               dwError;
    DWORD               dwDynDnsFlags;
    SPIComponentData    spComponentData;
    LARGE_INTEGER       liVersion;
    CDhcpServer *       pServer;
    DHCP_IP_RANGE       dhcpIpRange;

    //
    // Create the property page
    //
    m_spNodeMgr->GetComponentData(&spComponentData);
    
    CMScopeProperties * pScopeProp = 
        new CMScopeProperties(pNode, spComponentData, m_spTFSCompData, NULL);
    
    // Get the Server version and set it in the property sheet
    pServer = GetServerObject();
    pServer->GetVersion(liVersion);
    
    pScopeProp->SetVersion(liVersion);
    
    // Set scope specific data in the prop sheet
    pScopeProp->m_pageGeneral.m_SubnetInfo = m_SubnetInfo;
    
    BEGIN_WAIT_CURSOR;
    
    ZeroMemory(&dhcpIpRange, sizeof(dhcpIpRange));
    dwError = GetIpRange(&dhcpIpRange);
    if (dwError != ERROR_SUCCESS)
    {
        ::DhcpMessageBox(dwError);
        goto Cleanup;
    }

    pScopeProp->m_pageGeneral.m_ScopeCfg.m_dwStartAddress = dhcpIpRange.StartAddress;
    pScopeProp->m_pageGeneral.m_ScopeCfg.m_dwEndAddress = dhcpIpRange.EndAddress;
    
    pScopeProp->m_pageGeneral.m_uImage = GetImageIndex(FALSE);
    
    dwError = GetLeaseTime(&pScopeProp->m_pageGeneral.m_ScopeCfg.m_dwLeaseTime);
    
    END_WAIT_CURSOR;
    
    GetLifetime(&pScopeProp->m_pageLifetime.m_Expiry);
    
    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpProvider != NULL);
    
    return pScopeProp->CreateModelessSheet(lpProvider, handle);

Cleanup:
    delete pScopeProp;
    return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::OnPropertyChange
(       
        ITFSNode *              pNode, 
        LPDATAOBJECT    pDataobject, 
        DWORD                   dwType, 
        LPARAM                  arg, 
        LPARAM                  lParam
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CMScopeProperties * pScopeProp = reinterpret_cast<CMScopeProperties *>(lParam);

        LONG_PTR changeMask = 0;

        // tell the property page to do whatever now that we are back on the
        // main thread
        pScopeProp->OnPropertyChange(TRUE, &changeMask);

        pScopeProp->AcknowledgeNotify();

        if (changeMask)
                pNode->ChangeNode(changeMask);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpMScope::GetString
                Returns string information for display in the result pane columns
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpMScope::GetString
(
    ITFSNode *  pNode,
    int         nCol
)
{
    switch (nCol) {
    case 0:
        return GetDisplayName();
        
    case 1:
        return m_strState;
        
    case 2:
        return m_SubnetInfo.SubnetComment;
    }
    
    return NULL;
}


STDMETHODIMP
CDhcpMScope::DestroyHandler( ITFSNode *pNode )
{
    // Cleanup the stats dialog
    WaitForStatisticsWindow( &m_dlgStats );

    return CMTDhcpHandler::DestroyHandler( pNode );
    
} // CDhcpMScope::DestoryHandler()

/*---------------------------------------------------------------------------
        CDhcpMScope::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CDhcpMScope::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        return nCompare;
}

/*!--------------------------------------------------------------------------
        CDhcpServer::OnDelete
                The base handler calls this when MMC sends a MMCN_DELETE for a 
                scope pane item.  We just call our delete command handler.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::OnDelete
(
        ITFSNode *      pNode, 
        LPARAM          arg, 
        LPARAM          lParam
)
{
        return OnDelete(pNode);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpMScope::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*!--------------------------------------------------------------------------
        CDhcpMScope::OnUpdateToolbarButtons
                We override this function to show/hide the correct
        activate/deactivate buttons
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::OnUpdateToolbarButtons
(
    ITFSNode *          pNode,
    LPDHCPTOOLBARNOTIFY pToolbarNotify
)
{
    HRESULT hr = hrOK;

    if (pToolbarNotify->bSelect)
    {
        UpdateToolbarStates();
    }

    CMTDhcpHandler::OnUpdateToolbarButtons(pNode, pToolbarNotify);

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpMScope::UpdateToolbarStates
            Description
    Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpMScope::UpdateToolbarStates()
{
        if (( m_SubnetInfo.SubnetState == DhcpSubnetDisabled) ||
                ( m_SubnetInfo.SubnetState == DhcpSubnetDisabledSwitched ))
        {
        g_SnapinButtonStates[DHCPSNAP_MSCOPE][TOOLBAR_IDX_ACTIVATE] = ENABLED;
        g_SnapinButtonStates[DHCPSNAP_MSCOPE][TOOLBAR_IDX_DEACTIVATE] = HIDDEN;
    }
    else
    {
        g_SnapinButtonStates[DHCPSNAP_MSCOPE][TOOLBAR_IDX_ACTIVATE] = HIDDEN;
        g_SnapinButtonStates[DHCPSNAP_MSCOPE][TOOLBAR_IDX_DEACTIVATE] = ENABLED;
    }
}


/*---------------------------------------------------------------------------
        Command Handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CDhcpmScope::OnActivateScope
                Message handler for the scope activate/deactivate menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::OnActivateScope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    DWORD               err = 0;
        int                 nOpenImage, nClosedImage;
        DHCP_SUBNET_STATE   dhcpOldState = m_SubnetInfo.SubnetState;
        
    if (m_SubnetInfo.SubnetState == DhcpSubnetEnabled)
    {
        // if they want to disable the scope, confirm
        if (AfxMessageBox(IDS_SCOPE_DISABLE_CONFIRM, MB_YESNO) != IDYES)
        {
            return err;
        }
    }

    m_SubnetInfo.SubnetState = (m_SubnetInfo.SubnetState == DhcpSubnetDisabled) ? 
                                                            DhcpSubnetEnabled : DhcpSubnetDisabled;

        // Tell the scope to update it's state
        err = SetInfo();
        if (err != 0)
        {
                ::DhcpMessageBox(err);
                m_SubnetInfo.SubnetState = dhcpOldState;
        }
        else
        {
        // update the icon and the status text
        if (m_SubnetInfo.SubnetState == DhcpSubnetDisabled)
        {
            nOpenImage = ICON_IDX_SCOPE_INACTIVE_FOLDER_OPEN;
            nClosedImage = ICON_IDX_SCOPE_INACTIVE_FOLDER_CLOSED;
            m_strState.LoadString(IDS_SCOPE_INACTIVE);
        }
        else
        {
            nOpenImage = GetImageIndex(TRUE);
            nClosedImage = GetImageIndex(FALSE);
            m_strState.LoadString(IDS_SCOPE_ACTIVE);
        }

                pNode->SetData(TFS_DATA_IMAGEINDEX, nClosedImage);
                pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
       
        VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM)));

        // Update the toolbar button
        UpdateToolbarStates();

        SendUpdateToolbar(pNode, TRUE);
        }

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnReconcileScope
                Reconciles the active leases database for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::OnReconcileScope
(
        ITFSNode *      pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        CReconcileDlg dlgRecon(pNode);
        
        dlgRecon.m_bMulticast = TRUE;
    dlgRecon.DoModal();

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnShowScopeStats()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::OnShowScopeStats
(
        ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strScopeAddress;

    // Fill in some information in the stats object.
    // CreateNewStatisticsWindow handles the case if the window is 
    // already visible.
    m_dlgStats.SetNode(pNode);
    m_dlgStats.SetServer(GetServerIpAddress());
    m_dlgStats.SetScopeId(GetScopeId());
    m_dlgStats.SetName(GetName());
    
    CreateNewStatisticsWindow(&m_dlgStats,
                              ::FindMMCMainWindow(),
                              IDD_STATS_NARROW);
    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnDelete()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT     hr = S_OK;
    SPITFSNode  spParent;

    BOOL fAbortDelete = FALSE;
    BOOL fDeactivated = FALSE;

    LONG err = 0 ;

    CDhcpMScope *pMScope;
    
    // Any property sheets open?
    pMScope = GETHANDLER( CDhcpMScope, pNode );
    if ( pMScope->HasPropSheetsOpen()) {
        AfxMessageBox( IDS_MSG_CLOSE_PROPSHEET );
        
        return S_FALSE;
    }

    if (::DhcpMessageBox( IsEnabled() ?
                          IDS_MSG_DELETE_ACTIVE : IDS_MSG_DELETE_SCOPE, 
                          MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION) == IDYES) {
        pNode->GetParent(&spParent);
        
        CDhcpServer * pServer = GETHANDLER(CDhcpServer, spParent);
        err = pServer->DeleteMScope(pNode);

        // delete the statistics window
        WaitForStatisticsWindow( &m_dlgStats );
    } // if 
    
    return hr;
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------
        CDhcpMScope:OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpMScope::OnHaveData
(
        ITFSNode * pParentNode, 
        ITFSNode * pNewNode
)
{
    LPARAM dwType = pNewNode->GetData(TFS_DATA_TYPE);

    UpdateToolbarStates();

    switch (dwType)
    {
        case DHCPSNAP_MSCOPE_LEASES:
            pParentNode->AddChild(pNewNode);
            m_spActiveLeases.Set(pNewNode);
            break;

        case DHCPSNAP_ADDRESS_POOL:
            pParentNode->AddChild(pNewNode);
            m_spAddressPool.Set(pNewNode);
            break;
    }

    // now tell the view to update themselves
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnHaveData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpMScope::OnHaveData
(
        ITFSNode * pParentNode, 
        LPARAM     Data,
        LPARAM     Type
)
{
        // This is how we get non-node data back from the background thread.

        if (Type == DHCP_QDATA_SUBNET_INFO)
        {
        LONG_PTR changeMask = 0;
        LPDHCP_MSCOPE_INFO pdhcpSubnetInfo = reinterpret_cast<LPDHCP_MSCOPE_INFO>(Data);

        // update the scope name and state based on the info
        if (pdhcpSubnetInfo->MScopeName &&
            m_SubnetInfo.SubnetName.CompareNoCase(pdhcpSubnetInfo->MScopeName) != 0)
        {
            SetName(pdhcpSubnetInfo->MScopeName);

            changeMask = SCOPE_PANE_CHANGE_ITEM;
        }

        // update the comment
        if (m_SubnetInfo.SubnetComment.CompareNoCase(pdhcpSubnetInfo->MScopeComment) != 0)
        {
            SetComment(pdhcpSubnetInfo->MScopeComment);
        }

        if (m_SubnetInfo.SubnetState != pdhcpSubnetInfo->MScopeState)
        {
            DHCP_SUBNET_STATE dhcpOldState = m_SubnetInfo.SubnetState;
            
            m_SubnetInfo.SubnetState = pdhcpSubnetInfo->MScopeState;

                    pParentNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
                    pParentNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));
                    
            // Update the toolbar button
            UpdateToolbarStates();

            SendUpdateToolbar(pParentNode, TRUE);

            changeMask = SCOPE_PANE_CHANGE_ITEM;
        }

        // Update our internal struct
        m_SubnetInfo.Set(pdhcpSubnetInfo);

        if (pdhcpSubnetInfo)
            ::DhcpRpcFreeMemory(pdhcpSubnetInfo);

        if (changeMask)
            VERIFY(SUCCEEDED(pParentNode->ChangeNode(changeMask)));
        }
}

/*---------------------------------------------------------------------------
        CDhcpMScope::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CDhcpMScope::OnCreateQuery(ITFSNode * pNode)
{
        CDhcpMScopeQueryObj* pQuery = new CDhcpMScopeQueryObj(m_spTFSCompData, m_spNodeMgr);
        
    if ( pQuery == NULL )
        return pQuery;

        pQuery->m_strServer = GetServerObject(pNode)->GetIpAddress();
    pQuery->m_strName = GetName();
    
        return pQuery;
}

/*---------------------------------------------------------------------------
        CDhcpMScopeQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CDhcpMScopeQueryObj::Execute()
{
    HRESULT             hr = hrOK;
    DWORD               dwReturn;
    LPDHCP_MSCOPE_INFO  pMScopeInfo = NULL;

    dwReturn = ::DhcpGetMScopeInfo(((LPWSTR) (LPCTSTR)m_strServer),
                                                                   ((LPWSTR) (LPCTSTR)m_strName),
                                                                   &pMScopeInfo);

        if (dwReturn == ERROR_SUCCESS && pMScopeInfo)
    {
        AddToQueue((LPARAM) pMScopeInfo, DHCP_QDATA_SUBNET_INFO);
    }
    else
    {
        Trace1("CDhcpMScopeQueryObj::Execute - DhcpGetMScopeInfo failed! %d\n", dwReturn);
        PostError(dwReturn);
        return hrFalse;
    }

    CreateSubcontainers();
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::CreateSubcontainers()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScopeQueryObj::CreateSubcontainers()
{
        HRESULT hr = hrOK;
    SPITFSNode spNode;

        //
        // create the address pool Handler
        //
        CMScopeAddressPool *pAddressPool = new CMScopeAddressPool(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpMCastAddressPoolNodeType,
                                                   pAddressPool,
                                                   pAddressPool,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pAddressPool->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
    pAddressPool->Release();

    spNode.Set(NULL);

        //
        // create the Active Leases Handler
        //
        CMScopeActiveLeases *pActiveLeases = new CMScopeActiveLeases(m_spTFSCompData);
        CreateContainerTFSNode(&spNode,
                                                   &GUID_DhcpMCastActiveLeasesNodeType,
                                                   pActiveLeases,
                                                   pActiveLeases,
                                                   m_spNodeMgr);

        // Tell the handler to initialize any specific data
        pActiveLeases->InitializeNode((ITFSNode *) spNode);

        // Add the node as a child to this node
    AddToQueue(spNode);
        pActiveLeases->Release();

    return hr;
}

/*---------------------------------------------------------------------------
    Helper functions
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMScope::BuildDisplayName
(
        CString * pstrDisplayName,
        LPCTSTR   pName
)
{
        if (pstrDisplayName)
        {
                CString strStandard, strName;

                strName = pName;

                strStandard.LoadString(IDS_MSCOPE_FOLDER);
                
                *pstrDisplayName = strStandard + _T(" [") + strName + _T("] ");
        }

        return hrOK;
}

HRESULT 
CDhcpMScope::SetName
(
        LPCWSTR pName
)
{
        if (pName != NULL)      
        {
                m_SubnetInfo.SubnetName = pName;
        }

        CString strDisplayName;
        
        //
        // Create the display name for this scope
        // Convert DHCP_IP_ADDRES to a string and initialize this object
        //
        
        BuildDisplayName(&strDisplayName, pName);

        SetDisplayName(strDisplayName);
        
        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetServerIpAddress()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPCWSTR
CDhcpMScope::GetServerIpAddress()
{
        CDhcpServer * pServer = GetServerObject();

        return pServer->GetIpAddress();
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetServerIpAddress
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpMScope::GetServerIpAddress(DHCP_IP_ADDRESS * pdhcpIpAddress)
{
        CDhcpServer * pServer = GetServerObject();

        pServer->GetIpAddress(pdhcpIpAddress);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetServerVersion
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpMScope::GetServerVersion
(
        LARGE_INTEGER& liVersion
)
{
        CDhcpServer * pServer = GetServerObject();
        pServer->GetVersion(liVersion);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::InitMScopeInfo()
                Updates the scope's information
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::InitMScopeInfo
(
    LPDHCP_MSCOPE_INFO pMScopeInfo
)
{
    HRESULT hr = hrOK;

    m_SubnetInfo.Set(pMScopeInfo);

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::InitMScopeInfo()
                Updates the scope's information
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpMScope::InitMScopeInfo
(
    CSubnetInfo & subnetInfo
)
{
    HRESULT hr = hrOK;

    m_SubnetInfo = subnetInfo;

    return hr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetInfo()
                Updates the scope's information
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetInfo
(
    LPCTSTR pNewName
)
{
    DWORD err = ERROR_SUCCESS;
    DHCP_MSCOPE_INFO dhcpMScopeInfo = {0};

    dhcpMScopeInfo.MScopeName = (pNewName) ? (LPWSTR) pNewName : (LPTSTR) ((LPCTSTR) m_SubnetInfo.SubnetName);
    dhcpMScopeInfo.MScopeComment = (LPTSTR) ((LPCTSTR) m_SubnetInfo.SubnetComment);
        
    dhcpMScopeInfo.MScopeId = m_SubnetInfo.SubnetAddress;
    dhcpMScopeInfo.MScopeAddressPolicy = m_SubnetInfo.MScopeAddressPolicy;
    dhcpMScopeInfo.MScopeState = m_SubnetInfo.SubnetState;
    dhcpMScopeInfo.MScopeFlags = 0;
    dhcpMScopeInfo.ExpiryTime = m_SubnetInfo.ExpiryTime;
    dhcpMScopeInfo.TTL = m_SubnetInfo.TTL;

    // gotta fill in the language ID based on the name
    GetLangTag(m_SubnetInfo.LangTag);
    dhcpMScopeInfo.LangTag = (LPWSTR) ((LPCTSTR) m_SubnetInfo.LangTag);

        GetServerIpAddress(&dhcpMScopeInfo.PrimaryHost.IpAddress);

        // Review : ericdav - do we need to fill these in?
        dhcpMScopeInfo.PrimaryHost.NetBiosName = NULL;
        dhcpMScopeInfo.PrimaryHost.HostName = NULL;

    err = ::DhcpSetMScopeInfo(GetServerIpAddress(),
                                      (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName),  
                              &dhcpMScopeInfo,
                                                          FALSE);

    // update the scope name if we are changing the name
    if (err == ERROR_SUCCESS &&
        pNewName)
    {
        m_SubnetInfo.SubnetName = pNewName;
    }

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetLeaseTime
                Gets the lease time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::GetLeaseTime
(
        LPDWORD pdwLeaseTime
)
{
    //
    // Check option -- the lease duration
    //
    DWORD dwLeaseTime = 0;
    DWORD err = ERROR_SUCCESS;
    DHCP_OPTION_VALUE * poptValue = NULL;
    err = GetOptionValue(MADCAP_OPTION_LEASE_TIME, &poptValue);

    if (err != ERROR_SUCCESS)
    {
        Trace1("CDhcpScope::GetLeaseTime - couldn't get lease duration!! %d \n", err);
        
        dwLeaseTime = 0;
    }
    else
        {
                if (poptValue->Value.Elements != NULL)
                        dwLeaseTime = poptValue->Value.Elements[0].Element.DWordOption;

        if (poptValue)
                    ::DhcpRpcFreeMemory(poptValue);
    }

        *pdwLeaseTime = dwLeaseTime;

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetLeaseTime
                Sets the lease time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetLeaseTime
(
        DWORD dwLeaseTime
)
{
        DWORD err = 0;

        //
    // Set lease duration 
        //
    CDhcpOption dhcpOption (MADCAP_OPTION_LEASE_TIME,  DhcpDWordOption , _T(""), _T(""));
    dhcpOption.QueryValue().SetNumber(dwLeaseTime);
    
        err = SetOptionValue(&dhcpOption);

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetLifetime
                Gets the madcap scope lifetime
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::GetLifetime
(
    DATE_TIME * pdtLifetime
)
{
    DWORD err = ERROR_SUCCESS;

    if (pdtLifetime)
    {
        pdtLifetime->dwLowDateTime = m_SubnetInfo.ExpiryTime.dwLowDateTime;
        pdtLifetime->dwHighDateTime = m_SubnetInfo.ExpiryTime.dwHighDateTime;
    }

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetLifetime
                Sets the madcap scope lifetime
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetLifetime
(
    DATE_TIME * pdtLifetime
)
{
        DWORD err = 0;

    if (pdtLifetime)
    {
        m_SubnetInfo.ExpiryTime.dwLowDateTime = pdtLifetime->dwLowDateTime;
        m_SubnetInfo.ExpiryTime.dwHighDateTime = pdtLifetime->dwHighDateTime;
    }

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetTTL
                Gets the TTL for this multicast scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::GetTTL
(
        LPBYTE pbTTL
)
{
    DWORD err = 0;

        if (pbTTL)
        *pbTTL = m_SubnetInfo.TTL;

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetTTL
                Sets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetTTL
(
        BYTE TTL
)
{
        DWORD err = 0;

    m_SubnetInfo.TTL = TTL;

    return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::DeleteClient
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::DeleteClient
(
        DHCP_IP_ADDRESS dhcpClientIpAddress
)
{
        DWORD            dwErr = ERROR_SUCCESS;
    DHCP_SEARCH_INFO dhcpClientInfo;
        
        dhcpClientInfo.SearchType = DhcpClientIpAddress;
        dhcpClientInfo.SearchInfo.ClientIpAddress = dhcpClientIpAddress;
        
        dwErr = ::DhcpDeleteMClientInfo((LPWSTR) GetServerIpAddress(),
                                                                    &dhcpClientInfo);

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetOptionValue
                Sets the least time for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetOptionValue 
(
    CDhcpOption *                       pdhcType
)
{
    DWORD                                       err = 0;
    DHCP_OPTION_DATA *          pdhcOptionData;
    DHCP_OPTION_SCOPE_INFO      dhcScopeInfo;
    CDhcpOptionValue *          pcOptionValue = NULL;

    ZeroMemory( & dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        pcOptionValue = new CDhcpOptionValue( & pdhcType->QueryValue() ) ;
        if ( pcOptionValue )
                {
            dhcScopeInfo.ScopeType = DhcpMScopeOptions;
            dhcScopeInfo.ScopeInfo.MScopeInfo = (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName);

            pcOptionValue->CreateOptionDataStruct(&pdhcOptionData, TRUE);

            err = (DWORD) ::DhcpSetOptionValue(GetServerIpAddress(),
                                                                                           pdhcType->QueryId(),
                                                                                           &dhcScopeInfo,
                                                                                           pdhcOptionData);
        }

        delete pcOptionValue ;
    }
    END_MEM_EXCEPTION(err) ;

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpScope::GetOptionValue 
                Gets an option value for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::GetOptionValue 
(
    DHCP_OPTION_ID                      OptionID,
    DHCP_OPTION_VALUE **        ppdhcOptionValue
)
{
    DWORD err = 0 ;
    DHCP_OPTION_SCOPE_INFO dhcScopeInfo ;

    ZeroMemory( &dhcScopeInfo, sizeof(dhcScopeInfo) );

    CATCH_MEM_EXCEPTION
    {
        dhcScopeInfo.ScopeType = DhcpMScopeOptions;
        dhcScopeInfo.ScopeInfo.MScopeInfo = (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName);

        err = (DWORD) ::DhcpGetOptionValue(GetServerIpAddress(),
                                                                                   OptionID,
                                                                                   &dhcScopeInfo,
                                                                                   ppdhcOptionValue );
    }
    END_MEM_EXCEPTION(err) ;

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::RemoveValue 
                Removes an option 
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpMScope::RemoveOptionValue 
(
    DHCP_OPTION_ID                      dhcOptId
)
{
    DWORD dwErr = ERROR_SUCCESS;
    DHCP_OPTION_SCOPE_INFO dhcScopeInfo;

    ZeroMemory( &dhcScopeInfo, sizeof(dhcScopeInfo) );

    dhcScopeInfo.ScopeType = DhcpMScopeOptions;
    dhcScopeInfo.ScopeInfo.MScopeInfo = (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName);

    dwErr =  ::DhcpRemoveOptionValue(GetServerIpAddress(),
                                                                     dhcOptId,
                                                                         &dhcScopeInfo);

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::AddElement
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::AddElement
(
        LPDHCP_SUBNET_ELEMENT_DATA_V4 pdhcpSubnetElementData
)
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = ::DhcpAddMScopeElement((LPWSTR) GetServerIpAddress(),
                                                                   (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName),
                                                                   pdhcpSubnetElementData);
    return dwErr;
}

/*---------------------------------------------------------------------------
    CDhcpMScope::RemoveElement
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::RemoveElement
(
        LPDHCP_SUBNET_ELEMENT_DATA_V4 pdhcpSubnetElementData,
        BOOL                                          bForce
)
{
    DWORD dwErr = ERROR_SUCCESS;

    dwErr = ::DhcpRemoveMScopeElement((LPWSTR) GetServerIpAddress(),
                                                                      (LPWSTR) ((LPCTSTR) m_SubnetInfo.SubnetName),
                                                                      pdhcpSubnetElementData,
                                      bForce ? DhcpFullForce : DhcpNoForce);

    return dwErr;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::GetIpRange()
                returns the scope's allocation range.  Connects to the server
                to get the information
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::GetIpRange
(
        DHCP_IP_RANGE * pdhipr
)
{
        BOOL    bAlloced = FALSE;
    DWORD   dwError = ERROR_SUCCESS;

        pdhipr->StartAddress = 0;
        pdhipr->EndAddress = 0;

        CMScopeAddressPool * pAddressPool = GetAddressPoolObject();

        if (pAddressPool == NULL)
        {
                // the address pool folder isn't there yet...
                // Create a temporary one for now...
                pAddressPool = new CMScopeAddressPool(m_spTFSCompData);
                bAlloced = TRUE;        
        }
        
        // Get a query object from the address pool handler
        CMScopeAddressPoolQueryObj * pQueryObject = 
                reinterpret_cast<CMScopeAddressPoolQueryObj *>(pAddressPool->OnCreateQuery(m_spAddressPool));

        // if we created an address pool handler, then free it up now
        if (bAlloced)
        {
                pQueryObject->m_strServer = GetServerIpAddress();
                pQueryObject->m_strName = GetName();
                pAddressPool->Release();
        }

        // tell the query object to get the ip ranges
        pQueryObject->EnumerateIpRanges();

    // check to see if there was any problems getting the information
    dwError = pQueryObject->m_dwError;
    if (dwError != ERROR_SUCCESS)
    {
        return dwError;
    }

    LPQUEUEDATA pQD;
        while (pQD = pQueryObject->RemoveFromQueue())
        {
                Assert (pQD->Type == QDATA_PNODE);
                SPITFSNode p;
                p = reinterpret_cast<ITFSNode *>(pQD->Data);
                delete pQD;

                CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, p);

                pdhipr->StartAddress = pAllocRange->QueryAddr(TRUE);
                pdhipr->EndAddress = pAllocRange->QueryAddr(FALSE);

                p.Release();
        }

        pQueryObject->Release();

    return dwError;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::UpdateIpRange()
                This function updates the IP range on the server.  We also need 
                to remove any exclusion ranges that fall outside of the new
                allocation range.
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpMScope::UpdateIpRange
(
        DHCP_IP_RANGE * pdhipr
)
{
        return SetIpRange(pdhipr, TRUE);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::QueryIpRange()
                Returns the scope's allocation range (doesn't talk to the server
                directly, only returns internally cached information).
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpMScope::QueryIpRange
(
        DHCP_IP_RANGE * pdhipr
)
{
        pdhipr->StartAddress = 0;
        pdhipr->EndAddress = 0;

    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    m_spAddressPool->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {
                        // found the address
                        //
                        CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, spCurrentNode);

                        pdhipr->StartAddress = pAllocRange->QueryAddr(TRUE);
                        pdhipr->EndAddress = pAllocRange->QueryAddr(FALSE);
                }

                spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetIpRange
                Set's the allocation range for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetIpRange
(
        DHCP_IP_RANGE * pdhcpIpRange,
        BOOL                    bUpdateOnServer
)
{
        CDhcpIpRange dhcpIpRange = *pdhcpIpRange;

        return SetIpRange(dhcpIpRange, bUpdateOnServer);
}

/*---------------------------------------------------------------------------
        CDhcpMScope::SetIpRange
                Set's the allocation range for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::SetIpRange 
(
    const CDhcpIpRange & dhcpIpRange,
        BOOL  bUpdateOnServer
)
{
        DWORD err = 0;
        
        if (bUpdateOnServer)
        {
                DHCP_SUBNET_ELEMENT_DATA_V4 dhcSubElData;
                DHCP_IP_RANGE               dhipOldRange;

                err = GetIpRange(&dhipOldRange);
        if (err != ERROR_SUCCESS)
        {
            return err;
        }

                dhcSubElData.ElementType = DhcpIpRanges;
                dhcSubElData.Element.IpRange = &dhipOldRange;

                // 
                // First update the information on the server
                //
                //  Remove the old IP range;  allow "not found" error in new scope.
                //
                (void)RemoveElement(&dhcSubElData);

                //if ( err == 0 || err == ERROR_FILE_NOT_FOUND )
                //{
                DHCP_IP_RANGE dhcpNewIpRange = dhcpIpRange;     
                    dhcSubElData.Element.IpRange = &dhcpNewIpRange;

            if ( (err = AddElement( & dhcSubElData )) == 0 )
                        {
                                //m_ip_range = dhipr ;
                        }
            else
            {
                Trace1("SetIpRange - AddElement failed %lx\n", err);

                // something bad happened, try to put the old range back
                dhcSubElData.Element.IpRange = &dhipOldRange;
                if (AddElement(&dhcSubElData) != ERROR_SUCCESS)
                {
                    Trace0("SetIpRange - cannot return ip range back to old state!!");
                }
            }
                //}
        }

        //
        // Find the address pool folder and update the UI object
        //
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;

    if (m_spAddressPool == NULL) 
                return err;

    m_spAddressPool->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {
                        // found the address
                        //
                        CDhcpAllocationRange * pAllocRange = GETHANDLER(CDhcpAllocationRange, spCurrentNode);

                        // now set them
                        //
                        pAllocRange->SetAddr(dhcpIpRange.QueryAddr(TRUE), TRUE);
                        pAllocRange->SetAddr(dhcpIpRange.QueryAddr(FALSE), FALSE);
                
                        // tell the UI to update
                        spCurrentNode->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
                }

        spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

        return err ;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::IsOverlappingRange 
                determines if the exclusion overlaps an existing range
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL 
CDhcpMScope::IsOverlappingRange 
( 
    CDhcpIpRange & dhcpIpRange 
)
{
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
        BOOL bOverlap = FALSE;

    m_spActiveLeases->GetEnum(&spNodeEnum);

        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
        {
                if (spCurrentNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_EXCLUSION_RANGE)
                {
                        // found the address
                        //
                        CDhcpExclusionRange * pExclusion = GETHANDLER(CDhcpExclusionRange, spCurrentNode);

                        if ( bOverlap = pExclusion->IsOverlap( dhcpIpRange ) )
                        {
                                spCurrentNode.Release();
                                break;
                        }
                }

                spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
        }

    return bOverlap ;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::IsValidExclusion
                determines if the exclusion is valid for this scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpMScope::IsValidExclusion
(
        CDhcpIpRange & dhcpExclusionRange
)
{
        DWORD err = 0;
        DHCP_IP_RANGE dhcpIpRange;

    err = GetIpRange (&dhcpIpRange);
        CDhcpIpRange dhcpScopeRange(dhcpIpRange);
    
        //
    //  Get the data into a range object.               
    //
    if ( IsOverlappingRange( dhcpExclusionRange ) )
    {
        //
        //  Walk the current list, determining if the new range is valid.
        //  Then, if OK, verify that it's really a sub-range of the current range.
        //
        err = IDS_ERR_IP_RANGE_OVERLAP ;
    }
    else if ( ! dhcpExclusionRange.IsSubset( dhcpScopeRange ) )
    {
        //
        //  Guarantee that the new range is an (improper) subset of the scope's range
        //
        err = IDS_ERR_IP_RANGE_NOT_SUBSET ;
    }

        return err;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::StoreExceptionList 
                Adds a bunch of exclusions to the scope
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
CDhcpMScope::StoreExceptionList 
(
        CExclusionList * plistExclusions
)
{
    DHCP_SUBNET_ELEMENT_DATA dhcElement ;
    DHCP_IP_RANGE dhipr ;
    CDhcpIpRange * pobIpRange ;
    DWORD err = 0, err1 = 0;
        POSITION pos;

        pos = plistExclusions->GetHeadPosition();
    while ( pos )
    {
                pobIpRange = plistExclusions->GetNext(pos);

            err1 = AddExclusion( *pobIpRange ) ;
        if ( err1 != 0 )
        {
                        err = err1;
                Trace1("CDhcpScope::StoreExceptionList error adding range %d\n", err);
        }
    }

    return err ;
}

/*---------------------------------------------------------------------------
        CDhcpMScope::AddExclusion
                Adds an individual exclusion to the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::AddExclusion
(
        CDhcpIpRange &   dhcpIpRange,
        BOOL                     bAddToUI
)
{
    DHCP_SUBNET_ELEMENT_DATA_V4 dhcElement ;
    DHCP_IP_RANGE dhipr ;
        DWORD err = 0;

        dhcElement.ElementType = DhcpExcludedIpRanges ;
    dhipr = dhcpIpRange ;
    dhcElement.Element.ExcludeIpRange = & dhipr ;

    Trace2("CDhcpMScope::AddExclusion add excluded range %lx %lx\n", dhipr.StartAddress, dhipr.EndAddress );

    err = AddElement( & dhcElement ) ;
    //if ( err != 0 && err != ERROR_DHCP_INVALID_RANGE)
    if ( err != 0 )
    {
        Trace1("CDhcpMScope::AddExclusion error removing range %d\n", err);
    }

    if (m_spAddressPool != NULL)
    {
        CMScopeAddressPool * pAddrPool = GETHANDLER(CMScopeAddressPool, m_spAddressPool);

            if (!err && bAddToUI && pAddrPool->m_bExpanded)
            {
                    SPITFSNode spNewExclusion;

                    CDhcpExclusionRange * pExclusion = 
                            new CDhcpExclusionRange(m_spTFSCompData, &((DHCP_IP_RANGE) dhcpIpRange));
                    
                    CreateLeafTFSNode(&spNewExclusion,
                                                      &GUID_DhcpExclusionNodeType,
                                                      pExclusion,
                                                      pExclusion,
                                                      m_spNodeMgr);

                    // Tell the handler to initialize any specific data
                    pExclusion->InitializeNode((ITFSNode *) spNewExclusion);

                    // Add the node as a child to this node
                    m_spAddressPool->AddChild(spNewExclusion);
                    pExclusion->Release();
            }
    }

        return err;
}


/*---------------------------------------------------------------------------
        CDhcpMScope::RemoveExclusion
                Removes and exclusion from the server
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CDhcpMScope::RemoveExclusion
(
        CDhcpIpRange & dhcpIpRange
)
{
    DHCP_SUBNET_ELEMENT_DATA_V4 dhcElement ;
    DHCP_IP_RANGE dhipr ;
        DWORD err = 0;

        dhcElement.ElementType = DhcpExcludedIpRanges ;
    dhipr = dhcpIpRange ;
    dhcElement.Element.ExcludeIpRange = & dhipr ;

    Trace2("CDhcpMScope::RemoveExclusion remove excluded range %lx %lx\n", dhipr.StartAddress, dhipr.EndAddress);

    err = RemoveElement( & dhcElement ) ;
    //if ( err != 0 && err != ERROR_DHCP_INVALID_RANGE)
    if ( err != 0 )
    {
        Trace1("CDhcpMScope::RemoveExclusion error removing range %d\n", err);
    }

        return err;
}






/////////////////////////////////////////////////////////////////////
// 
// CMScopeActiveLeases implementation
//
/////////////////////////////////////////////////////////////////////

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CMScopeActiveLeases::CMScopeActiveLeases
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CMScopeActiveLeases::~CMScopeActiveLeases()
{
}

/*!--------------------------------------------------------------------------
        CMScopeActiveLeases::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMScopeActiveLeases::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_ACTIVE_LEASES_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_MSCOPE_LEASES);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_MSCOPE_LEASES][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_MSCOPE_LEASES][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMScopeActiveLeases::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strNode, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    // id string is server name, scope name and guid.
    strNode = GetServerName(pNode);
    strNode += GetScopeObject(pNode)->GetName() + strGuid;

    strId = strNode;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CMScopeActiveLeases::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                            nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN;
            else
                nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED;
                        break;
        
        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_BUSY;
            break;

                case unableToLoad:
            if (bOpenImage)
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_OPEN_LOST_CONNECTION;
            else
                        nIndex = ICON_IDX_ACTIVE_LEASES_FOLDER_CLOSED_LOST_CONNECTION;
            break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}


/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMScopeActiveLeases::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMScopeActiveLeases::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMScopeActiveLeases::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  param
)
{ 
        HRESULT hr = hrOK;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spActiveLeases, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spActiveLeases);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spActiveLeases);
        if (spSelectedNode != spActiveLeases)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int)listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

        //
        // Loop through all items deleting
        //
    BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spActiveLeaseNode;
                spActiveLeaseNode = listNodesToDelete.RemoveHead();
                CDhcpMCastLease * pActiveLease = GETHANDLER(CDhcpMCastLease, spActiveLeaseNode);
                
                //
                // delete the node, check to see if it is a reservation
                //
                DWORD dwError = GetScopeObject(spActiveLeases)->DeleteClient(pActiveLease->GetIpAddress());
                if (dwError == ERROR_SUCCESS)
                {
                        //
                        // Client gone, now remove from UI
                        //
                        spActiveLeases->RemoveChild(spActiveLeaseNode);
                }
                else
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

            Trace1("DeleteClient failed %lx\n", dwError);
                        hr = E_FAIL;
                }

                spActiveLeaseNode.Release();
        }
    
    END_WAIT_CURSOR;

    return hr;
}

/*!--------------------------------------------------------------------------
        CMScopeActiveLeases::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMScopeActiveLeases::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeases::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CMScopeActiveLeases::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE      cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpMCastLease *pDhcpAL1 = GETHANDLER(CDhcpMCastLease, spNode1);
        CDhcpMCastLease *pDhcpAL2 = GETHANDLER(CDhcpMCastLease, spNode2);

        switch (nCol)
        {
                case 0:
                        {
                                // IP address compare
                                //
                                nCompare = CompareIpAddresses(pDhcpAL1, pDhcpAL2);
                        }
                        break;
                
                case 1:
                        {
                                // Client Name compare
                                //
                                CString strAL1 = pDhcpAL1->GetString(pComponent, cookieA, nCol);
                                CString strAL2 = pDhcpAL2->GetString(pComponent, cookieA, nCol);

                                // Compare should not be case sensitive
                                //
                                nCompare = strAL1.CompareNoCase(strAL2);
                        }
                        break;
                
                case 2:
                        {
                                // Lease start compare
                                //
                                CTime timeAL1, timeAL2;
        
                                pDhcpAL1->GetLeaseStartTime(timeAL1);
                                pDhcpAL2->GetLeaseStartTime(timeAL2);
                        
                                if (timeAL1 < timeAL2)
                                        nCompare = -1;
                                else
                                if (timeAL1 > timeAL2)
                                        nCompare = 1;
                        }
                        break;

                case 3:
                        {
                                // Lease expiration compare
                                //
                                CTime timeAL1, timeAL2;
        
                                pDhcpAL1->GetLeaseExpirationTime(timeAL1);
                                pDhcpAL2->GetLeaseExpirationTime(timeAL2);
                        
                                if (timeAL1 < timeAL2)
                                        nCompare = -1;
                                else
                                if (timeAL1 > timeAL2)
                                        nCompare = 1;
                        }
                        break;

                case 4:
                        {
                                CString strClientId1 = pDhcpAL1->GetClientId();

                                nCompare =      strClientId1.CompareNoCase(pDhcpAL2->GetClientId());
                        }
                        break;

        }

    return nCompare;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int
CMScopeActiveLeases::CompareIpAddresses
(
        CDhcpMCastLease * pDhcpAL1,
        CDhcpMCastLease * pDhcpAL2
)
{
        int     nCompare = 0;

        DHCP_IP_ADDRESS dhcpIp1 = pDhcpAL1->GetIpAddress();
        DHCP_IP_ADDRESS dhcpIp2 = pDhcpAL2->GetIpAddress();
        
        if (dhcpIp1 < dhcpIp2)
                nCompare = -1;
        else
        if (dhcpIp1 > dhcpIp2)
                nCompare =  1;

        return nCompare;
}

/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

 /*---------------------------------------------------------------------------
        CMScopeActiveLeases::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CMScopeActiveLeases::OnCreateQuery(ITFSNode * pNode)
{
        CMScopeActiveLeasesQueryObj* pQuery = 
                new CMScopeActiveLeasesQueryObj(m_spTFSCompData, m_spNodeMgr);
        
    if ( pQuery == NULL )
        return pQuery;

        pQuery->m_strServer = GetServerIpAddress(pNode);

    pQuery->m_dhcpResumeHandle = NULL;
        pQuery->m_dwPreferredMax = 200;

        CDhcpMScope * pScope = GetScopeObject(pNode);
        if (pScope) 
                pQuery->m_strName = pScope->GetName();
    else
        Panic0("no scope in MScopeActiveLease::OnCreateQuery!");

    GetServerVersion(pNode, pQuery->m_liDhcpVersion);
        
        return pQuery;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeasesQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CMScopeActiveLeasesQueryObj::Execute()
{
        HRESULT hr = hrOK;

    hr = EnumerateLeases();

        return hr;
}

/*---------------------------------------------------------------------------
        CMScopeActiveLeasesQueryObj::EnumerateLeases()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMScopeActiveLeasesQueryObj::EnumerateLeases()
{
        DWORD                                           dwError = ERROR_MORE_DATA;
        LPDHCP_MCLIENT_INFO_ARRAY       pdhcpClientArray = NULL;
        DWORD                                           dwClientsRead = 0, dwClientsTotal = 0;
        DWORD                                           dwEnumedClients = 0;
        
        while (dwError == ERROR_MORE_DATA)
        {
        if (m_strName.IsEmpty())
            Panic0("CMScopeActiveLeasesQueryObj::EnumerateLeases() - m_strName is empty!!");

        dwError = ::DhcpEnumMScopeClients(((LPWSTR) (LPCTSTR)m_strServer),
                                                                          (LPWSTR) ((LPCTSTR) m_strName),
                                                                                  &m_dhcpResumeHandle,
                                                                                  m_dwPreferredMax,
                                                                                  &pdhcpClientArray,
                                                                                  &dwClientsRead,
                                                                                  &dwClientsTotal);
                if (dwClientsRead && pdhcpClientArray)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        for (DWORD i = 0; i < pdhcpClientArray->NumElements; i++)
                        {

                                CDhcpMCastLease * pDhcpMCastLease;
                                
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                pDhcpMCastLease = 
                                        new CDhcpMCastLease(m_spTFSCompData);
                                
                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpMCastLeaseNodeType,
                                                                  pDhcpMCastLease,
                                                                  pDhcpMCastLease,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                pDhcpMCastLease->InitMCastInfo(pdhcpClientArray->Clients[i]);
                pDhcpMCastLease->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpMCastLease->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpClientArray);

                        dwEnumedClients += dwClientsRead;
        
                        dwClientsRead = 0;
                        dwClientsTotal = 0;
                        pdhcpClientArray = NULL;
                }
                
                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateLeases error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }
        
        Trace1("DHCP snpain: Leases enumerated: %d\n", dwEnumedClients);

    return hrFalse;
}

/*---------------------------------------------------------------------------
        Class CMScopeAddressPool implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CMScopeAddressPool::CMScopeAddressPool
(
        ITFSComponentData * pComponentData
) : CMTDhcpHandler(pComponentData)
{
}

CMScopeAddressPool::~CMScopeAddressPool()
{
}

/*!--------------------------------------------------------------------------
        CMScopeAddressPool::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMScopeAddressPool::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        HRESULT hr = hrOK;

        //
        // Create the display name for this scope
        //
        CString strTemp;
        strTemp.LoadString(IDS_ADDRESS_POOL_FOLDER);
        
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_ADDR_POOL_FOLDER_CLOSED);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_ADDR_POOL_FOLDER_OPEN);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ADDRESS_POOL);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

        SetColumnStringIDs(&aColumns[DHCPSNAP_ADDRESS_POOL][0]);
        SetColumnWidths(&aColumnWidths[DHCPSNAP_ADDRESS_POOL][0]);
        
        return hr;
}

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnCreateNodeId2
                Returns a unique string for this node
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMScopeAddressPool::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strNode, strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    // id string is server name, scope name and guid.
    strNode = GetServerName(pNode);
    strNode += GetScopeObject(pNode)->GetName() + strGuid;

    strId = strNode;

    return hrOK;
}

/*---------------------------------------------------------------------------
        CMScopeAddressPool::GetImageIndex
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CMScopeAddressPool::GetImageIndex(BOOL bOpenImage) 
{
        int nIndex = -1;
        switch (m_nState)
        {
                case notLoaded:
                case loaded:
            if (bOpenImage)
                            nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN;
            else
                nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED;
                        break;
        
        case loading:
            if (bOpenImage)
                nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN_BUSY;
            else
                nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED_BUSY;
            break;

                case unableToLoad:
            if (bOpenImage)
                        nIndex = ICON_IDX_ADDR_POOL_FOLDER_OPEN_LOST_CONNECTION;
            else
                        nIndex = ICON_IDX_ADDR_POOL_FOLDER_CLOSED_LOST_CONNECTION;
            break;
                
                default:
                        ASSERT(FALSE);
        }

        return nIndex;
}


/*---------------------------------------------------------------------------
        Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnAddMenuItems
                Adds entries to the context sensitive menu
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMScopeAddressPool::OnAddMenuItems
(
        ITFSNode *                              pNode,
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        LPDATAOBJECT                    lpDataObject, 
        DATA_OBJECT_TYPES               type, 
        DWORD                                   dwType,
        long *                                  pInsertionAllowed
)
{ 
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        LONG    fFlags = 0;
        HRESULT hr = S_OK;
        CString strMenuText;

        if ( (m_nState != loaded) )
        {
                fFlags |= MF_GRAYED;
        }

        if (type == CCT_SCOPE)
        {
                // these menu items go in the new menu, 
                // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
                    strMenuText.LoadString(IDS_CREATE_NEW_EXCLUSION);
                    hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                                                     strMenuText, 
                                                                     IDS_CREATE_NEW_EXCLUSION,
                                                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                                                     fFlags );
                    ASSERT( SUCCEEDED(hr) );
        }
        }

        return hr; 
}

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnCommand
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMScopeAddressPool::OnCommand
(
        ITFSNode *                      pNode, 
        long                            nCommandId, 
        DATA_OBJECT_TYPES       type, 
        LPDATAOBJECT            pDataObject, 
        DWORD                           dwType
)
{
        HRESULT hr = S_OK;

        switch (nCommandId)
        {
                case IDS_CREATE_NEW_EXCLUSION:
                        OnCreateNewExclusion(pNode);
                        break;
        
                case IDS_REFRESH:
                        OnRefresh(pNode, pDataObject, dwType, 0, 0);
                        break;

                default:
                        break;
        }

        return hr;
}

/*---------------------------------------------------------------------------
        Message handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnCreateNewExclusion
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CMScopeAddressPool::OnCreateNewExclusion
(
        ITFSNode *              pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spScopeNode;
        pNode->GetParent(&spScopeNode);

        CAddExclusion dlgAddExclusion(spScopeNode, TRUE /* multicast */);

        dlgAddExclusion.DoModal();

        return 0;
}

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnResultDelete
                This function is called when we are supposed to delete result
                pane items.  We build a list of selected items and then delete them.
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMScopeAddressPool::OnResultDelete
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg, 
        LPARAM                  lParam
)
{ 
        HRESULT hr = NOERROR;
        BOOL bIsRes, bIsActive, bBadAddress;

        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        // translate the cookie into a node pointer
        SPITFSNode spAddressPool, spSelectedNode;
    m_spNodeMgr->FindNode(cookie, &spAddressPool);
    pComponent->GetSelectedNode(&spSelectedNode);

        Assert(spSelectedNode == spAddressPool);
        if (spSelectedNode != spAddressPool)
                return hr;

        // build the list of selected nodes
        CTFSNodeList listNodesToDelete;
        hr = BuildSelectedItemList(pComponent, &listNodesToDelete);

        //
        // Confirm with the user
        //
        CString strMessage, strTemp;
        int nNodes = (int)listNodesToDelete.GetCount();
        if (nNodes > 1)
        {
                strTemp.Format(_T("%d"), nNodes);
                AfxFormatString1(strMessage, IDS_DELETE_ITEMS, (LPCTSTR) strTemp);
        }
        else
        {
                strMessage.LoadString(IDS_DELETE_ITEM);
        }

        if (AfxMessageBox(strMessage, MB_YESNO) == IDNO)
        {
                return NOERROR;
        }

        //
        // Loop through all items deleting
        //
        BEGIN_WAIT_CURSOR;

    while (listNodesToDelete.GetCount() > 0)
        {
                SPITFSNode spExclusionRangeNode;
                spExclusionRangeNode = listNodesToDelete.RemoveHead();
                
                CDhcpExclusionRange * pExclusion = GETHANDLER(CDhcpExclusionRange, spExclusionRangeNode);
                
                if (spExclusionRangeNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                {       
                        //
                        // This is the allocation range, can't delete
                        //
                        AfxMessageBox(IDS_CANNOT_DELETE_ALLOCATION_RANGE);
                        spExclusionRangeNode.Release();
                        continue;
                }

                //
                // Try to remove it from the server
                //
                CDhcpIpRange dhcpIpRange((DHCP_IP_RANGE) *pExclusion);

                DWORD dwError = GetScopeObject(spAddressPool)->RemoveExclusion(dhcpIpRange);
                if (dwError != 0)
                {
                        ::DhcpMessageBox(dwError);
            RESTORE_WAIT_CURSOR;

                        hr = E_FAIL;
                        continue;
                }

                //
                // Remove from UI now
                //
                spAddressPool->RemoveChild(spExclusionRangeNode);
                spExclusionRangeNode.Release();
        }

    END_WAIT_CURSOR;

    return hr;
}

/*!--------------------------------------------------------------------------
        CMScopeAddressPool::OnGetResultViewType
        MMC calls this to get the result view information               
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMScopeAddressPool::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

    // we still want the default MMC result pane view, we just want
    // multiselect, so return S_FALSE

    return S_FALSE;
}

/*---------------------------------------------------------------------------
        CMScopeAddressPool::CompareItems
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CMScopeAddressPool::CompareItems
(
        ITFSComponent * pComponent, 
        MMC_COOKIE              cookieA, 
        MMC_COOKIE              cookieB, 
        int                             nCol
) 
{ 
        SPITFSNode spNode1, spNode2;

        m_spNodeMgr->FindNode(cookieA, &spNode1);
        m_spNodeMgr->FindNode(cookieB, &spNode2);
        
        int nCompare = 0; 

        CDhcpAllocationRange *pDhcpAR1 = GETHANDLER(CDhcpAllocationRange, spNode1);
        CDhcpAllocationRange *pDhcpAR2 = GETHANDLER(CDhcpAllocationRange, spNode2);

        switch (nCol)
        {
                case 0:
                        {
                                // Start IP address compare
                                //
                                DHCP_IP_ADDRESS dhcpIp1 = pDhcpAR1->QueryAddr(TRUE);
                                DHCP_IP_ADDRESS dhcpIp2 = pDhcpAR2->QueryAddr(TRUE);
                                
                                if (dhcpIp1 < dhcpIp2)
                                        nCompare = -1;
                                else
                                if (dhcpIp1 > dhcpIp2)
                                        nCompare =  1;

                                // default is that they are equal
                        }
                        break;

                case 1:
                        {
                                // End IP address compare
                                //
                                DHCP_IP_ADDRESS dhcpIp1 = pDhcpAR1->QueryAddr(FALSE);
                                DHCP_IP_ADDRESS dhcpIp2 = pDhcpAR2->QueryAddr(FALSE);
                                
                                if (dhcpIp1 < dhcpIp2)
                                        nCompare = -1;
                                else
                                if (dhcpIp1 > dhcpIp2)
                                        nCompare =  1;

                                // default is that they are equal
                        }
                        break;

                case 2:
                        {
                                // Description compare
                                //
                                CString strRange1 = pDhcpAR1->GetString(pComponent, cookieA, nCol);
                                CString strRange2 = pDhcpAR2->GetString(pComponent, cookieA, nCol);

                                // Compare should not be case sensitive
                                //
                                strRange1.MakeUpper();
                                strRange2.MakeUpper();

                                nCompare = strRange1.Compare(strRange2);
                        }
                        break;
        }

        return nCompare;
}


/*---------------------------------------------------------------------------
        Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
        CMScopeAddressPool::OnCreateQuery()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CMScopeAddressPool::OnCreateQuery(ITFSNode * pNode)
{
        CMScopeAddressPoolQueryObj* pQuery = 
                new CMScopeAddressPoolQueryObj(m_spTFSCompData, m_spNodeMgr);

    if ( pQuery == NULL )
        return pQuery;

    pQuery->m_strServer = GetServerIpAddress(pNode);
    
        CDhcpMScope * pScope = GetScopeObject(pNode);
        if (pScope) 
                pQuery->m_strName = pScope->GetName();

        pQuery->m_dhcpExclResumeHandle = NULL;
        pQuery->m_dwExclPreferredMax = 0xFFFFFFFF;
        
        pQuery->m_dhcpIpResumeHandle = NULL;
        pQuery->m_dwIpPreferredMax = 0xFFFFFFFF;

    return pQuery;
}

/*---------------------------------------------------------------------------
        CMScopeAddressPoolQueryObj::Execute()
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CMScopeAddressPoolQueryObj::Execute()
{
        HRESULT hr1 = EnumerateIpRanges();
        HRESULT hr2 = EnumerateExcludedIpRanges();
        
        if (hr1 == hrOK || hr2 == hrOK)
                return hrOK;
        else
                return hrFalse;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMScopeAddressPoolQueryObj::EnumerateExcludedIpRanges()
{
    DWORD                                                           dwError = ERROR_MORE_DATA;
        DHCP_RESUME_HANDLE                                  dhcpResumeHandle = 0;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 pdhcpSubnetElementArray = NULL;
        DWORD                                                       dwElementsRead = 0, dwElementsTotal = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumMScopeElements((LPWSTR) ((LPCTSTR) m_strServer),
                                                                           (LPWSTR) ((LPCTSTR) m_strName),
                                                                                   DhcpExcludedIpRanges,
                                                                                   &m_dhcpExclResumeHandle,
                                                                                   m_dwExclPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);
                
                Trace3("Scope %s Excluded Ip Ranges read %d, total %d\n", m_strName, dwElementsRead, dwElementsTotal);
                
                if (dwElementsRead && dwElementsTotal && pdhcpSubnetElementArray)
                {
                        //
                        // loop through all of the elements that were returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                CDhcpExclusionRange * pDhcpExclusionRange = 
                                        new CDhcpExclusionRange(m_spTFSCompData,
                                                                                        pdhcpSubnetElementArray->Elements[i].Element.ExcludeIpRange);
                                
                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpExclusionNodeType,
                                                                  pDhcpExclusionRange,
                                                                  pDhcpExclusionRange,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpExclusionRange->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpExclusionRange->Release();
                        }

                        // Free up the memory from the RPC call
                        //
                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);
                }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateExcludedIpRanges error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }

    return hrFalse;
}

/*---------------------------------------------------------------------------
        Function Name Here
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMScopeAddressPoolQueryObj::EnumerateIpRanges()
{
        DWORD                                                       dwError = ERROR_MORE_DATA;
        LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 pdhcpSubnetElementArray = NULL;
        DWORD                                                       dwElementsRead = 0, dwElementsTotal = 0;

        while (dwError == ERROR_MORE_DATA)
        {
                dwError = ::DhcpEnumMScopeElements((LPWSTR) ((LPCTSTR) m_strServer),
                                                                           (LPWSTR) ((LPCTSTR) m_strName),
                                                                                   DhcpIpRanges,
                                                                                   &m_dhcpIpResumeHandle,
                                                                                   m_dwIpPreferredMax,
                                                                                   &pdhcpSubnetElementArray,
                                                                                   &dwElementsRead,
                                                                                   &dwElementsTotal);

        Trace4("Scope %s allocation ranges read %d, total %d, dwError = %lx\n", 
                        m_strName, dwElementsRead, dwElementsTotal, dwError);
                
                if ((dwError == ERROR_MORE_DATA) ||
                        ( (dwElementsRead) && (dwError == ERROR_SUCCESS) ))
                {
                        //
                        // Loop through the array that was returned
                        //
                        for (DWORD i = 0; i < pdhcpSubnetElementArray->NumElements; i++)
                        {
                                //
                                // Create the result pane item for this element
                                //
                                SPITFSNode spNode;
                                CDhcpAllocationRange * pDhcpAllocRange = 
                                        new CDhcpAllocationRange(m_spTFSCompData, 
                                                                                        pdhcpSubnetElementArray->Elements[i].Element.IpRange);
                                
                                CreateLeafTFSNode(&spNode,
                                                                  &GUID_DhcpAllocationNodeType,
                                                                  pDhcpAllocRange,
                                                                  pDhcpAllocRange,
                                                                  m_spNodeMgr);

                                // Tell the handler to initialize any specific data
                                pDhcpAllocRange->InitializeNode(spNode);

                                AddToQueue(spNode);
                                pDhcpAllocRange->Release();
                        }

                        ::DhcpRpcFreeMemory(pdhcpSubnetElementArray);
                }
        else
        if (dwError != ERROR_SUCCESS &&
            dwError != ERROR_NO_MORE_ITEMS)
        {
            // set the error variable so that it can be looked at later
            m_dwError = dwError;
        }

                // Check the abort flag on the thread
                if (FCheckForAbort() == hrOK)
                        break;

        // check to see if we have an error and post it to the main thread if we do..
        if (dwError != ERROR_NO_MORE_ITEMS && 
            dwError != ERROR_SUCCESS &&
            dwError != ERROR_MORE_DATA)
            {
                Trace1("DHCP snapin: EnumerateAllocationRanges error: %d\n", dwError);
                    m_dwErr = dwError;
                    PostError(dwError);
            }
        }

    return hrFalse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\guids.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	guids.cpp
		DHCP snapin GUID definitions

	FILE HISTORY:
        
*/
#include "stdafx.h"

// MMC required node types

// {90901AF6-7A31-11d0-97E0-00C04FC3357A}
const CLSID CLSID_DhcpSnapin = 
{ 0x90901af6, 0x7a31, 0x11d0, { 0x97, 0xe0, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {524CCE97-A886-11d0-AB86-00C04FC3357A}
const CLSID CLSID_DhcpSnapinExtension = 
{ 0x524cce97, 0xa886, 0x11d0, { 0xab, 0x86, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {1CE57F61-A88A-11d0-AB86-00C04FC3357A}
const GUID CLSID_DhcpSnapinAbout = 
{ 0x1ce57f61, 0xa88a, 0x11d0, { 0xab, 0x86, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// Scope pane node types

// {1AE7F339-AA00-11d0-AB88-00C04FC3357A}
const GUID GUID_DhcpRootNodeType = 
{ 0x1ae7f339, 0xaa00, 0x11d0, { 0xab, 0x88, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D6C-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpServerNodeType = 
{ 0x37d62d6c, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D6D-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpScopeNodeType = 
{ 0x37d62d6d, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D6E-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpBootpNodeType = 
{ 0x37d62d6e, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D6F-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpGlobalOptionsNodeType = 
{ 0x37d62d6f, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D70-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpSuperscopeNodeType = 
{ 0x37d62d70, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D71-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpAddressPoolNodeType = 
{ 0x37d62d71, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D72-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpActiveLeasesNodeType = 
{ 0x37d62d72, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D73-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpReservationsNodeType = 
{ 0x37d62d73, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D74-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpScopeOptionsNodeType = 
{ 0x37d62d74, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D75-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpReservationClientNodeType = 
{ 0x37d62d75, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7B-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpClassIdHolderNodeType = 
{ 0x37d62d7b, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7C-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpMScopeNodeType = 
{ 0x37d62d7c, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7D-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpMCastAddressPoolNodeType = 
{ 0x37d62d7d, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7E-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpMCastActiveLeasesNodeType = 
{ 0x37d62d7e, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };


// result pane item GUIDs

// {37D62D76-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpAllocationNodeType = 
{ 0x37d62d76, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D77-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpExclusionNodeType = 
{ 0x37d62d77, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D78-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpBootpEntryNodeType = 
{ 0x37d62d78, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D79-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpActiveLeaseNodeType = 
{ 0x37d62d79, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7A-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpOptionNodeType = 
{ 0x37d62d7a, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7C-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpClassIdNodeType = 
{ 0x37d62d7c, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };

// {37D62D7C-E357-11d0-ABB6-00C04FC3357A}
static const GUID GUID_DhcpMCastLeaseNodeType = 
{ 0x37d62d7c, 0xe357, 0x11d0, { 0xab, 0xb6, 0x0, 0xc0, 0x4f, 0xc3, 0x35, 0x7a } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\general.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	general.h
		Header file for the general DHCP snapin admin classes

    FILE HISTORY:
        
*/

#ifndef _GENERAL_H
#define _GENERAL_H

extern const TCHAR g_szDefaultHelpTopic[];

#define SCOPE_DFAULT_LEASE_DAYS      8
#define SCOPE_DFAULT_LEASE_HOURS     0
#define SCOPE_DFAULT_LEASE_MINUTES   0

#define MSCOPE_DFAULT_LEASE_DAYS      30
#define MSCOPE_DFAULT_LEASE_HOURS     0
#define MSCOPE_DFAULT_LEASE_MINUTES   0

#define DYN_BOOTP_DFAULT_LEASE_DAYS      30
#define DYN_BOOTP_DFAULT_LEASE_HOURS     0
#define DYN_BOOTP_DFAULT_LEASE_MINUTES   0

#define DHCP_IP_ADDRESS_INVALID  ((DHCP_IP_ADDRESS)0)

#define DHCP_OPTION_ID_CSR      249

class CDhcpServer;

class CTimerDesc
{
public:
    SPITFSNode      spNode;
    CDhcpServer *   pServer;
    UINT_PTR        uTimer;
    TIMERPROC       timerProc;
};

typedef CArray<CTimerDesc *, CTimerDesc *> CTimerArrayBase;

class CTimerMgr : CTimerArrayBase
{
public:
    CTimerMgr();
    ~CTimerMgr();

public:
    int                 AllocateTimer(ITFSNode * pNode, CDhcpServer * pServer, UINT uTimerValue, TIMERPROC TimerProc);
    void                FreeTimer(UINT_PTR uEventId);
    void                ChangeInterval(UINT_PTR uEventId, UINT uNewInterval);
    CTimerDesc *        GetTimerDesc(UINT_PTR uEventId);
    CCriticalSection    m_csTimerMgr;
};

typedef CArray<DWORD_DWORD, DWORD_DWORD> CDWordDWordArray;

/////////////////////////////////////////////////////////////////////
// 
// CDhcpIpRange prototype
//
//  Simple wrapper for a DHCP_IP_RANGE
//
/////////////////////////////////////////////////////////////////////
class CDhcpClient
{
public:
    CDhcpClient ( const DHCP_CLIENT_INFO * pdhcClientInfo ) ;
    CDhcpClient ( const DHCP_CLIENT_INFO_V4 * pdhcClientInfo ) ;
    CDhcpClient () ;
    ~ CDhcpClient () ;

    const CString & QueryName () const
        { return m_strName ; }
    const CString & QueryComment () const
        { return m_strComment ; }
    const CString & QueryHostName ( BOOL bNetbios = FALSE ) const
        { return bNetbios ? m_strHostNetbiosName : m_strHostName ; }
    DHCP_IP_ADDRESS QueryIpAddress () const
        { return m_dhcpIpAddress ; }
    DHCP_IP_MASK QuerySubnet () const
        { return m_dhcpIpMask ; }
    DHCP_IP_ADDRESS QueryHostAddress () const
        { return m_dhcpIpHost ; }
    const DATE_TIME & QueryExpiryDateTime () const
        { return m_dtExpires ; }
    const CByteArray & QueryHardwareAddress () const
        { return m_baHardwareAddress ; }
    BYTE QueryClientType() const
        { return m_bClientType; }

    BOOL IsReservation () const
        { return m_bReservation ; }
    void SetReservation ( BOOL bReservation = TRUE )
        { m_bReservation = bReservation ; }

    //  Data change accessors:  SOME OF THESE THROW EXCEPTIONS
    void SetIpAddress ( DHCP_IP_ADDRESS dhipa )
        { m_dhcpIpAddress = dhipa ; }
    void SetIpMask ( DHCP_IP_ADDRESS dhipa )
        { m_dhcpIpMask = dhipa ; }
    void SetName ( const CString & cName )
        { m_strName = cName ; }
    void SetComment( const CString & cComment )
        { m_strComment = cComment ; }
    void SetHostName ( const CString & cHostName )
        { m_strHostName = cHostName ; }
    void SetHostNetbiosName ( const CString & cHostNbName )
        { m_strHostNetbiosName = cHostNbName ; }
    void SetHostIpAddress ( DHCP_IP_ADDRESS dhipa )
        { m_dhcpIpHost = dhipa ; }
    void SetExpiryDateTime ( DATE_TIME dt )
        { m_dtExpires = dt ; }
    void SetHardwareAddress ( const CByteArray & caByte ) ;
    void SetClientType(BYTE bClientType)
        { m_bClientType = bClientType; }

protected:
    void InitializeData(const DHCP_CLIENT_INFO * pdhcClientInfo);

protected:
    DHCP_IP_ADDRESS		m_dhcpIpAddress;      // Client's IP address
    DHCP_IP_MASK		m_dhcpIpMask;         // Client's subnet
    CByteArray			m_baHardwareAddress;  // hardware addresss
    CString				m_strName;            // Client name
    CString				m_strComment;         // Client comment
    DATE_TIME			m_dtExpires;          // date/time lease expires
    BOOL				m_bReservation;       // This is a reservation
    BYTE                m_bClientType;        // Client Type V4 and above only
    //  Host information
    CString				m_strHostName;
    CString				m_strHostNetbiosName;
    DHCP_IP_ADDRESS		m_dhcpIpHost;
};

/////////////////////////////////////////////////////////////////////
// 
// CDhcpIpRange prototype
//
//  Simple wrapper for a DHCP_IP_RANGE
//
/////////////////////////////////////////////////////////////////////
class CDhcpIpRange 
{
protected:
    DHCP_IP_RANGE m_dhcpIpRange;
	UINT		  m_RangeType;

public:
    CDhcpIpRange (DHCP_IP_RANGE dhcpIpRange);
    CDhcpIpRange ();
    virtual ~CDhcpIpRange();

    operator DHCP_IP_RANGE ()
    { return m_dhcpIpRange;  }

    operator DHCP_IP_RANGE () const
    { return m_dhcpIpRange; }

    //  Return TRUE if both addresses are generally OK
    operator BOOL ()
    { return m_dhcpIpRange.StartAddress != DHCP_IP_ADDRESS_INVALID
          && m_dhcpIpRange.EndAddress   != DHCP_IP_ADDRESS_INVALID
          && m_dhcpIpRange.StartAddress <= m_dhcpIpRange.EndAddress; }

    CDhcpIpRange & operator = (const DHCP_IP_RANGE dhcpIpRange);

    DHCP_IP_ADDRESS QueryAddr (BOOL bStart) const
    { return bStart ? m_dhcpIpRange.StartAddress : m_dhcpIpRange.EndAddress; }

    DHCP_IP_ADDRESS SetAddr (DHCP_IP_ADDRESS dhcpIpAddress, BOOL bStart);

    //  Return TRUE if this range overlaps the given range.
    BOOL IsOverlap (DHCP_IP_RANGE dhcpIpRange);

    //  Return TRUE if this range is a subset of the given range.
    BOOL IsSubset (DHCP_IP_RANGE dhcpIpRange);
    
	//  Return TRUE if this range is a superset of the given range.
    BOOL IsSuperset (DHCP_IP_RANGE dhcpIpRange);

    //  Sort helper function
    //int OrderByAddress ( const CObjectPlus * pobIpRange ) const;

	void SetRangeType(UINT uRangeType);
	UINT GetRangeType();
};

typedef CList<CDhcpIpRange *, CDhcpIpRange *> CExclusionList;

/////////////////////////////////////////////////////////////////////
// 
// CDhcpOptionValue prototype
//
//  Simple wrapper for DHCP_OPTION_DATA
//
/////////////////////////////////////////////////////////////////////
class CDhcpOptionValue
{
public:
    CDhcpOptionValue ( const DHCP_OPTION & dhcpOption );
    CDhcpOptionValue ( const DHCP_OPTION_VALUE & dhcpOptionValue );
    CDhcpOptionValue ( DHCP_OPTION_DATA_TYPE dhcDataType, INT cUpperBound = 0);

    //  Copy constructor.
    CDhcpOptionValue ( const CDhcpOptionValue & cOptionValue );
    CDhcpOptionValue ( const CDhcpOptionValue * dhcpOption );

    //  Assignment operator: assign a new value to this one.
    CDhcpOptionValue & operator = ( const CDhcpOptionValue & dhcpValue );

	CDhcpOptionValue () {  };
    ~CDhcpOptionValue ();

    //
	//  Query functions
	//
    DHCP_OPTION_DATA_TYPE QueryDataType () const
    {
        return m_dhcpOptionDataType;
    }
    
	int QueryUpperBound () const
    {
        return m_nUpperBound;
    }
    void SetUpperBound ( int nNewBound = 1 );
    void RemoveAll();

    long				QueryNumber ( INT index = 0 ) const;
    DHCP_IP_ADDRESS		QueryIpAddr ( INT index = 0 ) const;
    LPCTSTR				QueryString ( INT index = 0 ) const;
    INT					QueryBinary ( INT index = 0 ) const;
    const CByteArray *	QueryBinaryArray () const;
    DWORD_DWORD			QueryDwordDword ( INT index = 0 ) const;

    //
	//  Return a string representation of the current value.
    //
	LONG QueryDisplayString ( CString & strResult, BOOL fLineFeed = FALSE ) const;
    LONG QueryRouteArrayDisplayString( CString & strResult) const;
    
    //
	//  Modifiers: SetString accepts any string representation;
    //  others are specific.
    //
	LONG SetData ( const DHCP_OPTION_DATA * podData );
	LONG SetData ( const CDhcpOptionValue * pOptionValue );
	BOOL SetDataType ( DHCP_OPTION_DATA_TYPE dhcpType, INT cUpperBound = 0 );
    LONG SetString ( LPCTSTR pszNewValue, INT index = 0 );
    LONG SetNumber ( INT nValue, INT nIndex = 0 );
    LONG SetIpAddr ( DHCP_IP_ADDRESS dhcpIpAddress, INT index = 0 );
    LONG SetDwordDword ( DWORD_DWORD dwdwValue, INT index = 0 );

	LONG RemoveString ( INT index = 0);
	LONG RemoveNumber ( INT index = 0);
	LONG RemoveIpAddr ( INT index = 0);
	LONG RemoveDwordDword ( INT index = 0);

    BOOL IsValid () const;

	LONG CreateOptionDataStruct(//const CDhcpOptionValue * pdhcpOptionValue,
								LPDHCP_OPTION_DATA *	 ppOptionData,
								BOOL					 bForceType = FALSE);
	LONG FreeOptionDataStruct();

// implementation
private: 
	//
	//  Release the value union data
    //
	void FreeValue ();
    
	//
	//  Initialize the value union data
    //
	LONG InitValue ( DHCP_OPTION_DATA_TYPE dhcDataType,
                     INT cUpperBound,
                     BOOL bProvideDefaultValue = TRUE );

    BOOL CreateBinaryData ( const DHCP_BINARY_DATA * podBin, DHCP_BINARY_DATA * pobData ) ;
    BOOL CreateBinaryData ( const CByteArray * paByte, DHCP_BINARY_DATA * pobData  ) ;

// Attributes
private:
    DHCP_OPTION_DATA_TYPE	m_dhcpOptionDataType;
    DHCP_OPTION_DATA *		m_pdhcpOptionDataStruct;
	INT						m_nUpperBound ;
    
	union
    {
        CObject * pCObj;                //  Generic pointer
        CDWordArray * paDword;          //  8-, 16-, 32-bit data.
        CStringArray * paString;        //  String data
        CByteArray * paBinary;          //  Binary and encapsulated data
        CDWordDWordArray * paDwordDword;//  62-bit data.
    } m_dhcpOptionValue;
};

/////////////////////////////////////////////////////////////////////
// 
// CDhcpOption prototype
//
//  Simple wrapper for DHCP_OPTION
//
/////////////////////////////////////////////////////////////////////
class CDhcpOption
{
public:
    // Standard constructor uses API data
    CDhcpOption ( const DHCP_OPTION & dhpOption );
    
	// Constructor that must get info about option id referenced by the given value.
    CDhcpOption ( const DHCP_OPTION_VALUE & dhcpOptionValue,
                  LPCTSTR pszVendor,
                  LPCTSTR pszClass );
    
	// Constructor with overriding value.
    CDhcpOption ( const CDhcpOption & dhpType,
				  const DHCP_OPTION_VALUE & dhcOptionValue );
    
	// Constructor for dynamic instances
    CDhcpOption ( DHCP_OPTION_ID		nId,
				  DHCP_OPTION_DATA_TYPE dhcType,
				  LPCTSTR				pszOptionName,
				  LPCTSTR				pszComment,
				  DHCP_OPTION_TYPE		dhcOptType = DhcpUnaryElementTypeOption );
    
	// Copy constructor
    CDhcpOption ( const CDhcpOption & dhpType );

    ~CDhcpOption ();

    CDhcpOptionValue & QueryValue ()
    {	
        return m_dhcpOptionValue ;
    }

    const CDhcpOptionValue & QueryValue () const
    {
        return m_dhcpOptionValue ;
    }

    DHCP_OPTION_DATA_TYPE QueryDataType () const
    {
        return m_dhcpOptionValue.QueryDataType() ;
    }

    DHCP_OPTION_ID QueryId () const
    {
         return m_dhcpOptionId ;
    }
    
	LPCTSTR QueryName () const
    {
        return m_strName ;
    }
    
	LPCTSTR QueryComment () const
    {
        return m_strComment ;
    }

    void SetOptType ( DHCP_OPTION_TYPE dhcOptType ) ;

    DHCP_OPTION_TYPE QueryOptType() const
    {
        return m_dhcpOptionType ;
    }

    // Return TRUE if the option type is an array.
    BOOL IsArray () const
    {
        return QueryOptType() == DhcpArrayTypeOption ;
    }

    //  Fill the given string with a displayable representation of the item.
    void QueryDisplayName ( CString & cStr ) const ;

    BOOL SetName ( LPCTSTR pszName ) ;
    BOOL SetComment ( LPCTSTR pszComment ) ;

    LONG Update ( const CDhcpOptionValue & dhcpOptionValue ) ;
	static INT MaxSizeOfType ( DHCP_OPTION_DATA_TYPE dhcType ) ;

	BOOL SetDirty(BOOL bDirty = TRUE)
	{
		BOOL bOldFlag = m_bDirty;
		m_bDirty = bDirty;
		return bOldFlag;
	}

    // vendor specifc option stuff
    void    SetVendor(LPCTSTR pszVendor) { m_strVendor = pszVendor; }
    BOOL    IsVendor() { return !m_strVendor.IsEmpty(); }
    LPCTSTR GetVendor() { return m_strVendor.IsEmpty() ? NULL : (LPCTSTR) m_strVendor; }

    BOOL IsDirty() { return m_bDirty; }

    // class ID methods
    LPCTSTR GetClassName() { return m_strClassName; }
    void    SetClassName(LPCTSTR pClassName) { m_strClassName = pClassName; }
    BOOL    IsClassOption() { return m_strClassName.IsEmpty() ? FALSE : TRUE; }
    
    DWORD SetApiErr(DWORD dwErr)
	{
		DWORD dwOldErr = m_dwErr;
		m_dwErr = dwErr;
		return dwOldErr;
	}

	DWORD QueryApiErr() { return m_dwErr; }

protected:
    DHCP_OPTION_ID		m_dhcpOptionId;     // Option identifier
    DHCP_OPTION_TYPE	m_dhcpOptionType;   // Option type
    CDhcpOptionValue    m_dhcpOptionValue;  // Default value info
    CString				m_strName;          // Name of option
    CString				m_strComment;       // Comment for option
	CString             m_strVendor;        // Vendor Name for this option
    BOOL			    m_bDirty;
	DWORD				m_dwErr;			// stored err for later display
    CString             m_strClassName;
};

/////////////////////////////////////////////////////////////////////
// 
// COptionList
//
//  Object contains a list of options.  Can be iterated.
//
/////////////////////////////////////////////////////////////////////
typedef CList<CDhcpOption*, CDhcpOption*> COptionListBase;

class COptionList : public COptionListBase
{
public:
	COptionList() 
		: m_pos(NULL), m_bDirty(FALSE) {}
    ~COptionList()
    {
        DeleteAll();
    }

public:
    void DeleteAll()
    {
	    while (!IsEmpty())
	    {
		    delete RemoveHead();
	    }
    }

    // removes an option from the list
	void Remove(CDhcpOption * pOption)
	{
		POSITION pos = Find(pOption);
        if (pos)
		    RemoveAt(pos);
	}

	void Reset() { m_pos = GetHeadPosition(); }
	
	CDhcpOption * Next()
	{
		if (m_pos)
			return GetNext(m_pos);
		else
			return NULL;
	}

	CDhcpOption * FindId(DWORD dwId, LPCTSTR pszVendor)
	{
		CDhcpOption * pOpt = NULL;
	    CString     strVendor = pszVendor;
        
		POSITION pos = GetHeadPosition();
		while (pos)
		{
			CDhcpOption * pCurOpt = GetNext(pos);
			if ( (pCurOpt->QueryId() == dwId) &&
                 ( (!pszVendor && !pCurOpt->GetVendor()) ||
                   (pCurOpt->GetVendor() && (strVendor.CompareNoCase(pCurOpt->GetVendor()) == 0) ) ) )
			{
				pOpt = pCurOpt;
				break;
			}
		}

		return pOpt;
	}

	BOOL SetAll(BOOL bDirty)
	{
		BOOL bWasDirty = FALSE;
		POSITION pos = GetHeadPosition();
		while (pos)
		{
			CDhcpOption * pCurOpt = GetNext(pos);
			if (pCurOpt->SetDirty(bDirty))
				bWasDirty = TRUE;
		}
		return bWasDirty;
	}

	BOOL SetDirty(BOOL bDirty = TRUE)
	{
		BOOL bOldFlag = m_bDirty;
		m_bDirty = bDirty;
		return bOldFlag;
	}

    static int __cdecl SortByIdHelper(const void * pa, const void * pb)
    {
        CDhcpOption ** ppOpt1 = (CDhcpOption **) pa;
        CDhcpOption ** ppOpt2 = (CDhcpOption **) pb;

        if ((*ppOpt1)->QueryId() < (*ppOpt2)->QueryId())
            return -1;
        else
        if ((*ppOpt1)->QueryId() > (*ppOpt2)->QueryId())
            return 1;
        else
        {
            // options have equal IDs, but standard options come first
            if ((*ppOpt1)->IsVendor() && !(*ppOpt2)->IsVendor())
                return 1;
            else
            if (!(*ppOpt1)->IsVendor() && (*ppOpt2)->IsVendor())
                return -1;
            else
                return 0;  // they are either both standard or both vendor -- equal
        }
    }

    LONG SortById()
    {
        LONG err = 0;
        CDhcpOption * pOpt;
        int cItems = (int) GetCount();

        if ( cItems < 2 )
            return NO_ERROR;

        CATCH_MEM_EXCEPTION
        {
            //  Allocate the array
            CDhcpOption ** paOpt = (CDhcpOption **) alloca(sizeof(CDhcpOption *) * cItems);

            /// Fill the helper array.
            POSITION pos = GetHeadPosition();
            for (UINT i = 0; pos != NULL; i++ )
            {
                pOpt = GetNext(pos);
                paOpt[i] = pOpt;
            }

            RemoveAll();

            ASSERT( GetCount() == 0 );

            //  Sort the helper array
            ::qsort( paOpt,
                 cItems,
                 sizeof(paOpt[0]),
                 SortByIdHelper ) ;

            //  Refill the list from the helper array.
            for ( i = 0 ; i < (UINT) cItems ; i++ )
            {
                AddTail( paOpt[i] );
            }

            ASSERT( GetCount() == cItems ) ;
        }
        END_MEM_EXCEPTION(err)

        return err ;
    }

private:
	POSITION	m_pos;
	BOOL		m_bDirty;
};

/*---------------------------------------------------------------------------
	Class:	COptionValueEnum
 ---------------------------------------------------------------------------*/
class COptionValueEnum : public COptionList
{
public:
    COptionValueEnum();
    
    DWORD Init(LPCTSTR pServer, LARGE_INTEGER & liVersion, DHCP_OPTION_SCOPE_INFO & dhcpOptionScopeInfo);
    DWORD Enum();
    void  Copy(COptionValueEnum * pEnum);
    void  Remove(DHCP_OPTION_ID optionId, LPCTSTR pszVendor, LPCTSTR pszClass);

protected:
    DWORD EnumOptions();
    DWORD EnumOptionsV5();

    // V5 Helper
    HRESULT CreateOptions(LPDHCP_OPTION_VALUE_ARRAY pOptionValues, LPCTSTR pClassName, LPCTSTR pszVendor);

public:
    DHCP_OPTION_SCOPE_INFO  m_dhcpOptionScopeInfo;
    LARGE_INTEGER           m_liVersion;
    CString                 m_strServer;
    CString                 m_strDynBootpClassName;
};

/////////////////////////////////////////////////////////////////////
// 
// CDhcpDefaultOptionsOnServer prototype
//
//  Object contains a list of default options on a DHCP server
//
/////////////////////////////////////////////////////////////////////
class CDhcpDefaultOptionsOnServer
{
// constructors
public:
	CDhcpDefaultOptionsOnServer();
	~CDhcpDefaultOptionsOnServer();

// exposed functions
public:
	LONG			Enumerate(LPCWSTR pServer, LARGE_INTEGER liVersion);
	CDhcpOption *	Find(DHCP_OPTION_ID dhcpOptionId, LPCTSTR pszVendor);
	BOOL			IsEmpty() { return m_listOptions.IsEmpty(); }
	int				GetCount() { return (int) m_listOptions.GetCount(); }

	CDhcpOption * First();
	CDhcpOption * Next();
	void          Reset();

    LONG SortById();

	COptionList & GetOptionList() { return m_listOptions; }

// implementation
private:
	LONG			RemoveAll();
	LONG			EnumerateV4(LPCWSTR pServer);
	LONG			EnumerateV5(LPCWSTR pServer);

// attributes
private:
	COptionList m_listOptions;

	DWORD		m_dwLastUpdate;
	DWORD		m_dwOptionsTotal;
	POSITION	m_pos;
};

/////////////////////////////////////////////////////////////////////
// 
// CDhcpDefaultOptionsMasterList prototype
//
//  Object contains master list of known options
//
/////////////////////////////////////////////////////////////////////
enum OPT_FIELD
{
    OPTF_OPTION,
    OPTF_NAME,
    OPTF_TYPE,
    OPTF_ARRAY_FLAG,
    OPTF_LENGTH,
    OPTF_DESCRIPTION,
    OPTF_REMARK,
    OPTF_MAX
};

typedef struct
{
    int		eOptType ;
    LPCTSTR pszOptTypeName ;
} OPT_TOKEN ;

class CDhcpDefaultOptionsMasterList
{
// constructors
public:
	CDhcpDefaultOptionsMasterList();
	~CDhcpDefaultOptionsMasterList();

// exposed functions
public:
	LONG BuildList();

	CDhcpOption * First();
	CDhcpOption * Next();
	void          Reset();
    
    int           GetCount();

// implementation
private:
	BOOL		scanNextParamType(LPCTSTR * ppszText, CDhcpOption * * ppParamType);
	LPCTSTR		scanNextField(LPCTSTR pszLine, LPTSTR pszOut, int cFieldSize);
	BOOL		allDigits(LPCTSTR psz);
	int			recognizeToken(OPT_TOKEN * apToken, LPCTSTR pszToken);
	LPCTSTR		skipToNextLine(LPCTSTR pszLine);
	BOOL		skipWs(LPCTSTR * ppszLine);


// attributes
private:
	COptionList		 m_listOptions;
	POSITION		 m_pos;
};

#endif _GENERAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscopwiz.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	mscopewiz.cpp
		DHCP multicast scope creation dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "mscope.h"
#include "mscopwiz.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define HOURS_MAX   23
#define MINUTES_MAX 59

int CMScopeWizLeaseTime::m_nDaysDefault = MSCOPE_DFAULT_LEASE_DAYS;
int CMScopeWizLeaseTime::m_nHoursDefault = MSCOPE_DFAULT_LEASE_HOURS;
int CMScopeWizLeaseTime::m_nMinutesDefault = MSCOPE_DFAULT_LEASE_MINUTES;

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWiz holder
//
/////////////////////////////////////////////////////////////////////////////
CMScopeWiz::CMScopeWiz
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageWelcome);
	AddPageToList((CPropertyPageBase*) &m_pageName);
	AddPageToList((CPropertyPageBase*) &m_pageInvalidName);
	AddPageToList((CPropertyPageBase*) &m_pageSetRange);
	AddPageToList((CPropertyPageBase*) &m_pageSetExclusions);
	AddPageToList((CPropertyPageBase*) &m_pageLeaseTime);
	AddPageToList((CPropertyPageBase*) &m_pageActivate);
	AddPageToList((CPropertyPageBase*) &m_pageFinished);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);

    m_bWiz97 = TRUE;

    m_spTFSCompData->SetWatermarkInfo(&g_WatermarkInfoScope);
}

CMScopeWiz::~CMScopeWiz()
{
    RemovePageFromList(( CPropertyPageBase * ) &m_pageWelcome, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageName, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageInvalidName, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageSetRange, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageSetExclusions, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageLeaseTime, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageActivate, FALSE );
    RemovePageFromList(( CPropertyPageBase *) &m_pageFinished, FALSE );
}

//
// Called from the OnWizardFinish to add the DHCP Server to the list
//
DWORD
CMScopeWiz::OnFinish()
{
	return CreateScope();
}

BOOL
CMScopeWiz::GetScopeRange(CDhcpIpRange * pdhcpIpRange)
{
	return m_pageSetRange.GetScopeRange(pdhcpIpRange);
}

DWORD
CMScopeWiz::CreateScope()
{
    LONG err = 0,
         err2 ;
    BOOL fScopeCreated = FALSE;
    CString strLangTag;
    CDhcpMScope * pobScope = NULL ;
    CDhcpIpRange dhcpIpRange;
	CDhcpServer * pServer;
	SPITFSNode spNode, spServerNode;

    spServerNode = GetNode();
    do
    {
        m_pageSetRange.GetScopeRange(&dhcpIpRange);

        pServer = GETHANDLER(CDhcpServer, spServerNode);
		
        //
		// Create the scope on the server and then we can
		// create our internal object.
		//
        DHCP_MSCOPE_INFO MScopeInfo = {0};
        MScopeInfo.MScopeName = (LPWSTR) ((LPCTSTR) m_pageName.m_strName);
        MScopeInfo.MScopeComment = (LPWSTR) ((LPCTSTR) m_pageName.m_strComment);
        
        // scope ID is the starting address of the madcap scope
        MScopeInfo.MScopeId = dhcpIpRange.QueryAddr(TRUE); 
        MScopeInfo.MScopeAddressPolicy = 0;
        MScopeInfo.MScopeState = (m_pageActivate.m_fActivate) ? DhcpSubnetEnabled : DhcpSubnetDisabled;
        MScopeInfo.MScopeFlags = 0;

        // TBD: there is a DCR to be able to set this value.
        //      set to infinite for now
        MScopeInfo.ExpiryTime.dwLowDateTime = DHCP_DATE_TIME_INFINIT_LOW;
        MScopeInfo.ExpiryTime.dwHighDateTime = DHCP_DATE_TIME_INFINIT_HIGH;
        
        MScopeInfo.TTL = m_pageSetRange.GetTTL();
        
        err = pServer->CreateMScope(&MScopeInfo);
    	if (err != 0)
		{
			Trace1("CMScopeWiz::CreateScope() - Couldn't create scope! Error = %d\n", err);
			break;
		}

		SPITFSComponentData spTFSCompData;
		spTFSCompData = GetTFSCompData();

        pobScope = new CDhcpMScope(spTFSCompData);
		if ( pobScope == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;    
        }

		SPITFSNodeMgr spNodeMgr;
		spServerNode->GetNodeMgr(&spNodeMgr);

		//
		// Store the server object in the holder
		//
		CreateContainerTFSNode(&spNode,
							   &GUID_DhcpServerNodeType,
							   pobScope,
							   pobScope,
							   spNodeMgr);

		// Tell the handler to initialize any specific data
		pobScope->SetServer(spServerNode);
        pobScope->InitMScopeInfo(&MScopeInfo);
        pobScope->InitializeNode((ITFSNode *) spNode);

		pServer = GETHANDLER(CDhcpServer, spServerNode);

        pServer->AddMScopeSorted(spServerNode, spNode);
		
		pobScope->Release();

        fScopeCreated = TRUE;

        //
        //  Finish updating the scope.  First, the IP address range
        //  from which to allocate addresses.
        //
		if ( err = pobScope->SetIpRange( dhcpIpRange, TRUE ) ) 
        {
			Trace1("SetIpRange failed!!  %d\n", err);
            break ; 
        }

        //
        //  Next, see if any exclusions were specified.
        //

        err = pobScope->StoreExceptionList( m_pageSetExclusions.GetExclusionList() ) ;
		if (err != ERROR_SUCCESS)
		{
			Trace1("StoreExceptionList failed!!  %d\n", err);
			break;
		}

		//
		//  set the lease time
		//
		DWORD dwLeaseTime;

		dwLeaseTime = m_pageLeaseTime.GetLeaseTime();

		err = pobScope->SetLeaseTime(dwLeaseTime);
		if (err != ERROR_SUCCESS)
		{
			Trace1("SetLeaseTime failed!!  %d\n", err);
			break;
		}
	}
    while ( FALSE ) ;

    if ( err )
    {
		//
        // CODEWORK:: The scope should never have been added
        //            to the remote registry in the first place.
        //
        if (pobScope != NULL)
        {
            if (fScopeCreated)
            {
                Trace0("Bad scope nevertheless was created\n");
                err2 = pServer->DeleteMSubnet(pobScope->GetName());
                if (err2 != ERROR_SUCCESS)
                {
                    Trace1("Couldn't remove the bad scope! Error = %d\n", err2);
                }
            }
            
			spServerNode->RemoveChild(spNode);
		}
	}

	return err;
}


/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizName property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizName, CPropertyPageBase)

CMScopeWizName::CMScopeWizName() : CPropertyPageBase(CMScopeWizName::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizName)
	m_strName = _T("");
	m_strComment = _T("");
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_NAME_TITLE, IDS_MSCOPE_WIZ_NAME_SUBTITLE);
}

CMScopeWizName::~CMScopeWizName()
{
}

void CMScopeWizName::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizName)
	DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editScopeName);
	DDX_Control(pDX, IDC_EDIT_SCOPE_COMMENT, m_editScopeComment);
	DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strName);
	DDX_Text(pDX, IDC_EDIT_SCOPE_COMMENT, m_strComment);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizName, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizName)
	ON_EN_CHANGE(IDC_EDIT_SCOPE_NAME, OnChangeEditScopeName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizName message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizName::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

    CEdit *pEditName = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_NAME ));
    if ( 0 != pEditName ) {
        pEditName->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }
    CEdit *pEditComment = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_COMMENT ));
    if ( 0 != pEditComment ) {
        pEditComment->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizName::OnWizardNext() 
{
	UpdateData();
	
	return IDW_MSCOPE_SET_SCOPE;
}

BOOL CMScopeWizName::OnSetActive() 
{
	UpdateButtons();
	
	return CPropertyPageBase::OnSetActive();
}

void CMScopeWizName::OnChangeEditScopeName() 
{
	UpdateButtons();	
}

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizName implementation specific
//
/////////////////////////////////////////////////////////////////////////////
void
CMScopeWizName::UpdateButtons()
{
	BOOL bValid = FALSE;

	UpdateData();

	if (m_strName.GetLength() > 0)
		bValid = TRUE;

	GetHolder()->SetWizardButtonsMiddle(bValid);
}


/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizInvalidName property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizInvalidName, CPropertyPageBase)

CMScopeWizInvalidName::CMScopeWizInvalidName() : CPropertyPageBase(CMScopeWizInvalidName::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizInvalidName)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_INVALID_NAME_TITLE, IDS_MSCOPE_WIZ_INVALID_NAME_SUBTITLE);
}

CMScopeWizInvalidName::~CMScopeWizInvalidName()
{
}

void CMScopeWizInvalidName::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizInvalidName)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizInvalidName, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizInvalidName)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizInvalidName message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizInvalidName::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizInvalidName::OnWizardBack() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return IDW_MSCOPE_NAME;
}

BOOL CMScopeWizInvalidName::OnSetActive() 
{
	GetHolder()->SetWizardButtonsLast(FALSE);
	
	return CPropertyPageBase::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetRange property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizSetRange, CPropertyPageBase)

CMScopeWizSetRange::CMScopeWizSetRange() : CPropertyPageBase(CMScopeWizSetRange::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizSetRange)
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_SCOPE_TITLE, IDS_MSCOPE_WIZ_SCOPE_SUBTITLE);
}

CMScopeWizSetRange::~CMScopeWizSetRange()
{
}

void CMScopeWizSetRange::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizSetRange)
	DDX_Control(pDX, IDC_SPIN_TTL, m_spinTTL);
	DDX_Control(pDX, IDC_EDIT_TTL, m_editTTL);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_POOL_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_POOL_STOP, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CMScopeWizSetRange, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizSetRange)
	ON_EN_KILLFOCUS(IDC_IPADDR_POOL_START, OnKillfocusPoolStart)
	ON_EN_KILLFOCUS(IDC_IPADDR_POOL_STOP, OnKillfocusPoolStop)
	ON_EN_CHANGE(IDC_EDIT_MASK_LENGTH, OnChangeEditMaskLength)

	ON_EN_CHANGE(IDC_IPADDR_POOL_START, OnChangePoolStart)
	ON_EN_CHANGE(IDC_IPADDR_POOL_STOP, OnChangePoolStop)
	
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetRange message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizSetRange::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	m_spinTTL.SetRange(1, 255);
    m_spinTTL.SetPos(32);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizSetRange::OnWizardNext() 
{
    UpdateData();
    CDhcpIpRange rangeMScope, rangeMulticast;

    rangeMulticast.SetAddr(MCAST_ADDRESS_MIN, TRUE);
    rangeMulticast.SetAddr(MCAST_ADDRESS_MAX, FALSE);

    // check the TTL
    int nTTL = m_spinTTL.GetPos();

    if ( (nTTL < 1) ||
         (nTTL > 255) )
    {
        // invalid TTL specified
        AfxMessageBox(IDS_INVALID_TTL);
        m_editTTL.SetFocus();
        m_editTTL.SetSel(0,-1);
        return -1;
    }

    // valid address range?
    GetScopeRange(&rangeMScope);
    if (rangeMScope.QueryAddr(TRUE) >= rangeMScope.QueryAddr(FALSE))
    {
        AfxMessageBox(IDS_ERR_IP_RANGE_INV_START);
        m_ipaStart.SetFocus();
        return -1;
    }
    
    if (!rangeMScope.IsSubset(rangeMulticast))
    {
        AfxMessageBox(IDS_INVALID_MCAST_ADDRESS);
        m_ipaStart.SetFocus();
        return -1;
    }

    // if the mcast scope range falls in the scoped area, make sure 
    // the range is at least 256 addresses
    if (rangeMScope.QueryAddr(FALSE) > MCAST_SCOPED_RANGE_MIN)
    {
        if ( ((rangeMScope.QueryAddr(FALSE) - rangeMScope.QueryAddr(TRUE)) + 1) < 256)
        {
            AfxMessageBox(IDS_INVALID_MCAST_SCOPED_RANGE);
            m_ipaStart.SetFocus();
            return -1;
        }
    }

    // is the scope ID in use?
    SPITFSNode spServerNode;
    CDhcpServer * pServer;
    
    spServerNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CDhcpServer, spServerNode);

    if (pServer->DoesMScopeExist(spServerNode, rangeMScope.QueryAddr(TRUE)))
    {
        AfxMessageBox(IDS_ERR_IP_RANGE_OVERLAP);
        return -1;
    }

    return IDW_MSCOPE_SET_EXCLUSIONS;
}

LRESULT CMScopeWizSetRange::OnWizardBack() 
{
	return IDW_MSCOPE_NAME;
}

BOOL CMScopeWizSetRange::OnSetActive() 
{
	m_fPageActive = TRUE;

	UpdateButtons();

	return CPropertyPageBase::OnSetActive();
}

BOOL CMScopeWizSetRange::OnKillActive() 
{
	m_fPageActive = FALSE;

	UpdateButtons();

	return CPropertyPageBase::OnKillActive();
}

void CMScopeWizSetRange::OnKillfocusPoolStart()
{
}

void CMScopeWizSetRange::OnKillfocusPoolStop()
{
}

void CMScopeWizSetRange::OnChangeEditMaskLength() 
{
	UpdateButtons();
}

void CMScopeWizSetRange::OnChangePoolStop()
{
	UpdateButtons();
}

void CMScopeWizSetRange::OnChangePoolStart()
{
	UpdateButtons();
}

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetRange implementation specific
//
/////////////////////////////////////////////////////////////////////////////
BOOL
CMScopeWizSetRange::GetScopeRange(CDhcpIpRange * pdhcpIpRange)
{
	DHCP_IP_RANGE dhcpIpRange;

    if ( !m_ipaStart.GetAddress( & dhcpIpRange.StartAddress ) )
    {
        return FALSE ;
    }

    if ( !m_ipaEnd.GetAddress( & dhcpIpRange.EndAddress ) )
    {
		return FALSE;
	}

	*pdhcpIpRange = dhcpIpRange;

	return TRUE;
}

BYTE
CMScopeWizSetRange::GetTTL()
{
    BYTE TTL;

    TTL = (LOBYTE(LOWORD(m_spinTTL.GetPos())));

	return TTL;
}

void
CMScopeWizSetRange::UpdateButtons()
{
	DWORD	lStart, lEnd;

	m_ipaStart.GetAddress(&lStart);
	m_ipaEnd.GetAddress(&lEnd);

	if (lStart && lEnd)
		GetHolder()->SetWizardButtonsMiddle(TRUE);
	else
		GetHolder()->SetWizardButtonsMiddle(FALSE);

}

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetExclusions property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizSetExclusions, CPropertyPageBase)

CMScopeWizSetExclusions::CMScopeWizSetExclusions() : CPropertyPageBase(CMScopeWizSetExclusions::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizSetExclusions)
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_EXCLUSIONS_TITLE, IDS_MSCOPE_WIZ_EXCLUSIONS_SUBTITLE);
}

CMScopeWizSetExclusions::~CMScopeWizSetExclusions()
{
	while (m_listExclusions.GetCount())
		delete m_listExclusions.RemoveHead();
}

void CMScopeWizSetExclusions::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizSetExclusions)
	DDX_Control(pDX, IDC_LIST_EXCLUSION_RANGES, m_listboxExclusions);
	DDX_Control(pDX, IDC_BUTTON_EXCLUSION_DELETE, m_buttonExclusionDelete);
	DDX_Control(pDX, IDC_BUTTON_EXCLUSION_ADD, m_buttonExclusionAdd);
	//}}AFX_DATA_MAP

	//
	// IP Address custom controls
	//
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_EXCLUSION_END, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CMScopeWizSetExclusions, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizSetExclusions)
	ON_BN_CLICKED(IDC_BUTTON_EXCLUSION_ADD, OnButtonExclusionAdd)
	ON_BN_CLICKED(IDC_BUTTON_EXCLUSION_DELETE, OnButtonExclusionDelete)
	//}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPADDR_EXCLUSION_START, OnChangeExclusionStart)
    ON_EN_CHANGE(IDC_IPADDR_EXCLUSION_END, OnChangeExclusionEnd)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetExclusions message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizSetExclusions::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizSetExclusions::OnWizardNext() 
{
	return IDW_MSCOPE_LEASE_TIME;
}

LRESULT CMScopeWizSetExclusions::OnWizardBack() 
{
	return IDW_MSCOPE_SET_SCOPE;
}

BOOL CMScopeWizSetExclusions::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(TRUE);
	
	UpdateButtons();

	return CPropertyPageBase::OnSetActive();
}

void CMScopeWizSetExclusions::OnChangeExclusionStart()
{
	UpdateButtons();
}

void CMScopeWizSetExclusions::OnChangeExclusionEnd()
{
	UpdateButtons();
}

void CMScopeWizSetExclusions::OnButtonExclusionAdd() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	DWORD err = 0;
	CDhcpIpRange dhcpExclusionRange;
	CDhcpIpRange dhcpScopeRange;

	((CMScopeWiz *)GetHolder())->GetScopeRange(&dhcpScopeRange);
	
    //
    //  Get the data into a range object.               
    //
    if ( !GetExclusionRange(dhcpExclusionRange) )
    {
        err = IDS_ERR_IP_RANGE_INVALID ;
    }
    else if ( IsOverlappingRange( dhcpExclusionRange ) )
    {
        //
        //  Walk the current list, determining if the new range is valid.
        //  Then, if OK, verify that it's really a sub-range of the current range.
        //
        err = IDS_ERR_IP_RANGE_OVERLAP ;
        m_ipaStart.SetFocus();
    }
    else if ( ! dhcpExclusionRange.IsSubset( dhcpScopeRange ) )
    {
        //
        //  Guarantee that the new range is an (improper) subset of the scope's range
        //
        err = IDS_ERR_IP_RANGE_NOT_SUBSET ;
        m_ipaStart.SetFocus();
    }
    if ( err == 0 )
    {
        //TRY
        {
            //
            //  Create a new IP range object and add it to the current list
            //
            CDhcpIpRange * pIpRange = new CDhcpIpRange( dhcpExclusionRange ) ;

			m_listExclusions.AddTail(pIpRange);

            //
            //  Refill the exclusions listbox including the new item.
            //
            Fill( (int) (m_listExclusions.GetCount() - 1) ) ;
        }
        //CATCH_ALL(e)
        //{
        //    err = ERROR_NOT_ENOUGH_MEMORY ;
        //}
        //END_CATCH_ALL
    }

    if ( err )
    {
        ::DhcpMessageBox( err ) ;
    }
    else
    {
        //
        // Succesfully added the exlusion range, now blank out the
        // ip controls
        //
        m_ipaStart.ClearAddress();
        m_ipaEnd.ClearAddress();
        m_ipaStart.SetFocus();
	}
}

void CMScopeWizSetExclusions::OnButtonExclusionDelete() 
{
    //
    //  Index into the listbox, delete the item from the active list
    //  and move its data into the edit controls
    //
    int index = m_listboxExclusions.GetCurSel() ;

    ASSERT( index >= 0 ) ;      // Button should not be enabled if no selection.
    if ( index < 0 )
    {
        return ;
    }

    POSITION pos = m_listExclusions.FindIndex(index);
	CDhcpIpRange * pdhcRange = (CDhcpIpRange *) m_listExclusions.GetAt(pos);

	m_listExclusions.RemoveAt(pos);

    ASSERT( pdhcRange != NULL ) ;

    //
    //  Put the deleted range into the exclusions controls
    //
    FillExcl( pdhcRange ) ;

    //
    //  Refill the list box and call HandleActivation()
    //
    if ( index >= m_listboxExclusions.GetCount() )
    {
        index-- ;
    }
    
	Fill( index ) ;
  
	m_ipaStart.SetFocus();

	UpdateButtons();
}

//
//  Format the IP range pair into the exclusion edit controls
//
void 
CMScopeWizSetExclusions::FillExcl 
( 
    CDhcpIpRange * pdhcIpRange 
)
{
    LONG lStart = pdhcIpRange->QueryAddr( TRUE );
    LONG lEnd = pdhcIpRange->QueryAddr( FALSE );

    m_ipaStart.SetAddress( lStart ) ;
    m_ipaStart.SetModify( TRUE ) ;
    m_ipaStart.Invalidate() ;

    //
    // If the ending address is the same as the starting address,
    // do not fill in the ending address.
    //
    if (lStart != lEnd)
    {
        m_ipaEnd.SetAddress( lEnd ) ;
    }
    else
    {
        m_ipaEnd.ClearAddress();
    }

    m_ipaEnd.SetModify( TRUE ) ;
    m_ipaEnd.Invalidate() ;
}

//
//  Convert the IP address range controls to a range.
//
BOOL 
CMScopeWizSetExclusions::GetExclusionRange 
( 
    CDhcpIpRange & dhcIpRange 
)
{
    DHCP_IP_RANGE dhipr ;

    if ( !m_ipaStart.GetAddress( & dhipr.StartAddress ) )
    {
        m_ipaStart.SetFocus();
        return FALSE ;
    }
    if ( !m_ipaEnd.GetAddress( & dhipr.EndAddress ) )
    {
        //
        // If no ending range was specified, assume a singular exlusion
        // (the starting address) was requested.
        //
        m_ipaEnd.SetFocus();
        dhipr.EndAddress = dhipr.StartAddress;
    }

    dhcIpRange = dhipr ;
    return (BOOL) dhcIpRange ;
}

BOOL 
CMScopeWizSetExclusions::IsOverlappingRange 
( 
    CDhcpIpRange & dhcpIpRange 
)
{
    POSITION pos;
	CDhcpIpRange * pdhcpRange ;
    BOOL bOverlap = FALSE ;

	pos = m_listExclusions.GetHeadPosition();
    while ( pos )
    {
		pdhcpRange = m_listExclusions.GetNext(pos);
        if ( bOverlap = pdhcpRange->IsOverlap( dhcpIpRange ) )
        {
            break ;
        }
    }

    return bOverlap ;
}

//
//  Fill the exclusions listbox from the current list
//
void 
CMScopeWizSetExclusions::Fill 
( 
    int		nCurSel, 
    BOOL	bToggleRedraw 
)
{
	POSITION pos;
    CDhcpIpRange * pIpRange ;
    CString strIp1 ;
    CString strIp2 ;
    CString strFormatPair ;
    CString strFormatSingleton ;
    TCHAR chBuff [STRING_LENGTH_MAX] ;

    if ( ! strFormatPair.LoadString( IDS_INFO_FORMAT_IP_RANGE ) )
    {
        return ;
    }

    if ( ! strFormatSingleton.LoadString( IDS_INFO_FORMAT_IP_UNITARY ) )
    {
        return ;
    }

    if ( bToggleRedraw )
    {
        m_listboxExclusions.SetRedraw( FALSE ) ;
    }

    m_listboxExclusions.ResetContent() ;
	pos = m_listExclusions.GetHeadPosition();

    while ( pos )
    {
        pIpRange = m_listExclusions.GetNext(pos);

		DHCP_IP_RANGE dhipr = *pIpRange ;

        CString & strFmt = dhipr.StartAddress == dhipr.EndAddress
                ? strFormatSingleton
                : strFormatPair ;

        //
        //  Format the IP addresses
        //
        UtilCvtIpAddrToWstr( dhipr.StartAddress, &strIp1 ) ;
        UtilCvtIpAddrToWstr( dhipr.EndAddress, &strIp2 ) ;

        //
        //  Construct the display line
        //
        ::wsprintf( chBuff,
                (LPCTSTR) strFmt,
                (LPCTSTR) strIp1,
                (LPCTSTR) strIp2 ) ;

        //
        //  Add it to the list box.                     
        //
        if ( m_listboxExclusions.AddString( chBuff ) < 0 )
        {
            break ;
        }
    }

    //
    //  Check that we loaded the list box successfully.
    //
    if ( pos != NULL )
    {
        AfxMessageBox( IDS_ERR_DLG_UPDATE ) ;
    }

    if ( bToggleRedraw )
    {
        m_listboxExclusions.SetRedraw( TRUE ) ;
        m_listboxExclusions.Invalidate() ;
    }

    if ( nCurSel >= 0 )
    {
        m_listboxExclusions.SetCurSel( nCurSel ) ;
    }
}

void CMScopeWizSetExclusions::UpdateButtons() 
{
	DWORD	dwAddress;
	BOOL	bEnable;

	m_ipaStart.GetAddress(&dwAddress);

	if (dwAddress)
	{
		bEnable = TRUE;
	}
	else
	{
		bEnable = FALSE;
		if (m_buttonExclusionAdd.GetButtonStyle() & BS_DEFPUSHBUTTON)
		{
			m_buttonExclusionAdd.SetButtonStyle(BS_PUSHBUTTON);
		}
	}
	m_buttonExclusionAdd.EnableWindow(bEnable);
	
	if (m_listboxExclusions.GetCurSel() != LB_ERR)
	{
		bEnable = TRUE;
	}
	else
	{
		bEnable = FALSE;
		if (m_buttonExclusionDelete.GetButtonStyle() & BS_DEFPUSHBUTTON)
		{
			m_buttonExclusionDelete.SetButtonStyle(BS_PUSHBUTTON);
		}
	}
	m_buttonExclusionDelete.EnableWindow(bEnable);
}

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizLeaseTime property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizLeaseTime, CPropertyPageBase)

CMScopeWizLeaseTime::CMScopeWizLeaseTime() : CPropertyPageBase(CMScopeWizLeaseTime::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizLeaseTime)
	//}}AFX_DATA_INIT

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_LEASE_TITLE, IDS_MSCOPE_WIZ_LEASE_SUBTITLE);
}

CMScopeWizLeaseTime::~CMScopeWizLeaseTime()
{
}

void CMScopeWizLeaseTime::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizLeaseTime)
	DDX_Control(pDX, IDC_SPIN_LEASE_MINUTES, m_spinMinutes);
	DDX_Control(pDX, IDC_SPIN_LEASE_HOURS, m_spinHours);
	DDX_Control(pDX, IDC_SPIN_LEASE_DAYS, m_spinDays);
	DDX_Control(pDX, IDC_EDIT_LEASE_MINUTES, m_editMinutes);
	DDX_Control(pDX, IDC_EDIT_LEASE_HOURS, m_editHours);
	DDX_Control(pDX, IDC_EDIT_LEASE_DAYS, m_editDays);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizLeaseTime, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizLeaseTime)
	ON_BN_CLICKED(IDC_RADIO_LEASE_LIMITED, OnRadioLeaseLimited)
	ON_BN_CLICKED(IDC_RADIO_LEASE_UNLIMITED, OnRadioLeaseUnlimited)
	ON_EN_CHANGE(IDC_EDIT_LEASE_HOURS, OnChangeEditLeaseHours)
	ON_EN_CHANGE(IDC_EDIT_LEASE_MINUTES, OnChangeEditLeaseMinutes)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizLeaseTime message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizLeaseTime::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	m_spinMinutes.SetRange(0, MINUTES_MAX);
	m_spinHours.SetRange(0, HOURS_MAX);
	m_spinDays.SetRange(0, 999);

	m_editMinutes.LimitText(2);
	m_editHours.LimitText(2);
	m_editDays.LimitText(3);

	m_spinMinutes.SetPos(CMScopeWizLeaseTime::m_nMinutesDefault);
	m_spinHours.SetPos(CMScopeWizLeaseTime::m_nHoursDefault);
	m_spinDays.SetPos(CMScopeWizLeaseTime::m_nDaysDefault);

	ActivateDuration(TRUE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizLeaseTime::OnWizardNext() 
{
    DWORD dwLeaseTime = GetLeaseTime();
    if (dwLeaseTime == 0)
    {
        AfxMessageBox(IDS_ERR_NO_DURATION_SPECIFIED);
        return -1;
    }
    else
    {
    	return IDW_MSCOPE_ACTIVATE;
    }
}

LRESULT CMScopeWizLeaseTime::OnWizardBack() 
{
	return IDW_MSCOPE_SET_EXCLUSIONS;
}

BOOL CMScopeWizLeaseTime::OnSetActive() 
{
	GetHolder()->SetWizardButtonsMiddle(TRUE);
	
	return CPropertyPageBase::OnSetActive();
}

void CMScopeWizLeaseTime::OnRadioLeaseLimited() 
{
	ActivateDuration(TRUE);
}

void CMScopeWizLeaseTime::OnRadioLeaseUnlimited() 
{
	ActivateDuration(FALSE);
}

void CMScopeWizLeaseTime::OnChangeEditLeaseHours() 
{
    if (IsWindow(m_editHours.GetSafeHwnd()))
    {
        CString strText;
        m_editHours.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > HOURS_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(HOURS_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editHours.SetWindowText(strText);
            m_spinHours.SetPos(HOURS_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }
}

void CMScopeWizLeaseTime::OnChangeEditLeaseMinutes() 
{
    if (IsWindow(m_editMinutes.GetSafeHwnd()))
    {
        CString strText;
        m_editMinutes.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > MINUTES_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MINUTES_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMinutes.SetWindowText(strText);
            m_spinMinutes.SetPos(MINUTES_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }
}

DWORD
CMScopeWizLeaseTime::GetLeaseTime()
{
	DWORD dwLeaseTime = 0;

	int nDays, nHours, nMinutes;

	nDays = m_spinDays.GetPos();
	nHours = m_spinHours.GetPos();
	nMinutes = m_spinMinutes.GetPos();

	//
	// Lease time is in minutes so convert
	//
	dwLeaseTime = UtilConvertLeaseTime(nDays, nHours, nMinutes);

	return dwLeaseTime;
}

void 
CMScopeWizLeaseTime::ActivateDuration
(
	BOOL fActive
)
{
	m_spinMinutes.EnableWindow(fActive);
    m_spinHours.EnableWindow(fActive);
    m_spinDays.EnableWindow(fActive);

	m_editMinutes.EnableWindow(fActive);
    m_editHours.EnableWindow(fActive);
    m_editDays.EnableWindow(fActive);

	GetDlgItem(IDC_STATIC_DAYS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_HOURS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_MINUTES)->EnableWindow(fActive);
}   

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizFinished property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMScopeWizFinished, CPropertyPageBase)

CMScopeWizFinished::CMScopeWizFinished() : CPropertyPageBase(CMScopeWizFinished::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizFinished)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CMScopeWizFinished::~CMScopeWizFinished()
{
}

void CMScopeWizFinished::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizFinished)
	DDX_Control(pDX, IDC_STATIC_FINISHED_TITLE, m_staticTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizFinished, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizFinished)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizFinished message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMScopeWizFinished::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	CString strFontName;
	CString strFontSize;

	strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
	strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
	if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CMScopeWizFinished::OnWizardFinish()
{
	DWORD err;

    BEGIN_WAIT_CURSOR;

    err = GetHolder()->OnFinish();

    END_WAIT_CURSOR;
    	
	if (err) 
	{
		::DhcpMessageBox(err);
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

BOOL CMScopeWizFinished::OnSetActive() 
{
	GetHolder()->SetWizardButtonsLast(TRUE);
	
	return CPropertyPageBase::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CMScopeWizWelcome property page

IMPLEMENT_DYNCREATE(CMScopeWizWelcome, CPropertyPageBase)

CMScopeWizWelcome::CMScopeWizWelcome() : CPropertyPageBase(CMScopeWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitWiz97(TRUE, 0, 0);
}

CMScopeWizWelcome::~CMScopeWizWelcome()
{
}

void CMScopeWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizWelcome)
	DDX_Control(pDX, IDC_STATIC_WELCOME_TITLE, m_staticTitle);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizWelcome, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMScopeWizWelcome message handlers
BOOL CMScopeWizWelcome::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	CString strFontName;
	CString strFontSize;

	strFontName.LoadString(IDS_BIG_BOLD_FONT_NAME);
	strFontSize.LoadString(IDS_BIG_BOLD_FONT_SIZE);

    CClientDC dc(this);

    int nFontSize = _ttoi(strFontSize) * 10;
	if (m_fontBig.CreatePointFont(nFontSize, strFontName, &dc))
        m_staticTitle.SetFont(&m_fontBig);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CMScopeWizWelcome::OnSetActive() 
{
    GetHolder()->SetWizardButtonsFirst(TRUE);
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CMScopeWizActivate property page

IMPLEMENT_DYNCREATE(CMScopeWizActivate, CPropertyPageBase)

CMScopeWizActivate::CMScopeWizActivate() : CPropertyPageBase(CMScopeWizActivate::IDD)
{
	//{{AFX_DATA_INIT(CMScopeWizActivate)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_fActivate = TRUE;

    InitWiz97(FALSE, IDS_MSCOPE_WIZ_ACTIVATE_TITLE, IDS_MSCOPE_WIZ_ACTIVATE_SUBTITLE);
}

CMScopeWizActivate::~CMScopeWizActivate()
{
}

void CMScopeWizActivate::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopeWizActivate)
	DDX_Control(pDX, IDC_RADIO_YES, m_radioYes);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopeWizActivate, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopeWizActivate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMScopeWizActivate message handlers

BOOL CMScopeWizActivate::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
    m_radioYes.SetCheck(TRUE);
    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CMScopeWizActivate::OnWizardNext() 
{
    m_fActivate = m_radioYes.GetCheck();
    
	return CPropertyPageBase::OnWizardNext();
}

BOOL CMScopeWizActivate::OnSetActive() 
{
    GetHolder()->SetWizardButtonsMiddle(TRUE);
	
	return CPropertyPageBase::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscpstat.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	mscpstat.h
		The scope statistics dialog
		
    FILE HISTORY:
        
*/


#ifndef _MSCPSTAT_H
#define _MSCPSTAT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

class CMScopeStats : public StatsDialog
{
public:
	CMScopeStats();
	~CMScopeStats();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    void UpdateWindow(LPDHCP_MCAST_MIB_INFO pMibInfo);

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }
    void SetScopeId(DWORD dwScopeId) { m_dwScopeId = dwScopeId; }
    void SetName(LPCTSTR pName) { m_strScopeName = pName; }

    DECLARE_MESSAGE_MAP()

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(IDD_STATS_NARROW); }
    
protected:
    CString         m_strServerAddress;
    CString         m_strScopeName;
    DWORD           m_dwScopeId;
    SPITFSNode      m_spNode;
};

#endif _MSCPSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscopepp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	MScopePP.cpp
		This file contains all of the implementation for the 
		scope property page.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "nodes.h"
#include "mscopepp.h"
#include "mscope.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMScopeProperties::CMScopeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
	m_liVersion.QuadPart = 0;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pageLifetime);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CMScopeProperties::~CMScopeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageLifetime, FALSE);
}

void
CMScopeProperties::SetVersion
(
	LARGE_INTEGER &	 liVersion
)
{
	m_liVersion = liVersion;
}

/////////////////////////////////////////////////////////////////////////////
// CScopePropGeneral property page

IMPLEMENT_DYNCREATE(CMScopePropGeneral, CPropertyPageBase)

CMScopePropGeneral::CMScopePropGeneral() : CPropertyPageBase(CMScopePropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CMScopePropGeneral)
	m_strComment = _T("");
	m_strName = _T("");
	//}}AFX_DATA_INIT

	m_bUpdateInfo = FALSE;
	m_bUpdateLease = FALSE;
	m_bUpdateRange = FALSE;
    m_bUpdateTTL = FALSE;
    m_uImage = 0;
}

CMScopePropGeneral::~CMScopePropGeneral()
{
}

void CMScopePropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopePropGeneral)
	DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_SCOPE_COMMENT, m_editComment);
	DDX_Control(pDX, IDC_EDIT_TTL, m_editTTL);
	DDX_Control(pDX, IDC_RADIO_LEASE_UNLIMITED, m_radioUnlimited);
	DDX_Control(pDX, IDC_RADIO_LEASE_LIMITED, m_radioLimited);
	DDX_Control(pDX, IDC_EDIT_LEASE_MINUTES, m_editMinutes);
	DDX_Control(pDX, IDC_EDIT_LEASE_HOURS, m_editHours);
	DDX_Control(pDX, IDC_EDIT_LEASE_DAYS, m_editDays);
	DDX_Control(pDX, IDC_SPIN_TTL, m_spinTTL);
	DDX_Control(pDX, IDC_SPIN_LEASE_HOURS, m_spinHours);
	DDX_Control(pDX, IDC_SPIN_LEASE_MINUTES, m_spinMinutes);
	DDX_Control(pDX, IDC_SPIN_LEASE_DAYS, m_spinDays);
	DDX_Text(pDX, IDC_EDIT_SCOPE_COMMENT, m_strComment);
	DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strName);
	//}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_IPADDR_START, m_ipaStart);
    DDX_Control(pDX, IDC_IPADDR_END, m_ipaEnd);
}


BEGIN_MESSAGE_MAP(CMScopePropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopePropGeneral)
	ON_BN_CLICKED(IDC_RADIO_LEASE_LIMITED, OnRadioLeaseLimited)
	ON_BN_CLICKED(IDC_RADIO_LEASE_UNLIMITED, OnRadioLeaseUnlimited)
	ON_EN_CHANGE(IDC_EDIT_LEASE_DAYS, OnChangeEditLeaseDays)
	ON_EN_CHANGE(IDC_EDIT_LEASE_HOURS, OnChangeEditLeaseHours)
	ON_EN_CHANGE(IDC_EDIT_LEASE_MINUTES, OnChangeEditLeaseMinutes)
	ON_EN_CHANGE(IDC_EDIT_TTL, OnChangeEditTTL)
	ON_EN_CHANGE(IDC_EDIT_SCOPE_COMMENT, OnChangeEditScopeComment)
	ON_EN_CHANGE(IDC_EDIT_SCOPE_NAME, OnChangeEditScopeName)
	//}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPADDR_START, OnChangeIpAddrStart)
    ON_EN_CHANGE(IDC_IPADDR_END, OnChangeIpAddrStart)

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMScopePropGeneral message handlers

BOOL CMScopePropGeneral::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();

    m_ipaStart.SetAddress(m_ScopeCfg.m_dwStartAddress);
    m_ipaEnd.SetAddress(m_ScopeCfg.m_dwEndAddress);

    m_spinMinutes.SetRange(0, 59);
    m_spinHours.SetRange(0, 23);
    m_spinDays.SetRange(0, 999);

    m_editMinutes.LimitText(2);
    m_editHours.LimitText(2);
    m_editDays.LimitText(3);

    // Limit the name and comment field to 255 chars
    CEdit *pEditName = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_NAME ));
    if ( 0 != pEditName ) {
        pEditName->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }
    CEdit *pEditComment = reinterpret_cast<CEdit *>(GetDlgItem( IDC_EDIT_SCOPE_COMMENT ));
    if ( 0 != pEditComment ) {
        pEditComment->LimitText( MAX_NAME_LENGTH ); // max characters for superscope name
    }

    // fill in the name & comment
    m_editName.SetWindowText(m_SubnetInfo.SubnetName);
    m_editComment.SetWindowText(m_SubnetInfo.SubnetComment);

    // fill in lease time info
    if (m_ScopeCfg.m_dwLeaseTime != DHCP_INFINIT_LEASE)
	{
		int nDays, nHours, nMinutes;

		UtilConvertLeaseTime(m_ScopeCfg.m_dwLeaseTime, &nDays, &nHours, &nMinutes);

		m_spinDays.SetPos(nDays);
		m_spinHours.SetPos(nHours);
		m_spinMinutes.SetPos(nMinutes);
	}

	// setup the lease time controls
    ActivateDuration (m_ScopeCfg.m_dwLeaseTime != DHCP_INFINIT_LEASE);

	m_radioUnlimited.SetCheck(m_ScopeCfg.m_dwLeaseTime == DHCP_INFINIT_LEASE);
	m_radioLimited.SetCheck(m_ScopeCfg.m_dwLeaseTime != DHCP_INFINIT_LEASE);

    // set the ttl
	m_spinTTL.SetRange(1, 255);
    m_spinTTL.SetPos(m_SubnetInfo.TTL);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

    SetDirty(FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMScopePropGeneral::OnRadioLeaseLimited() 
{
	ActivateDuration(TRUE);
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnRadioLeaseUnlimited() 
{
	ActivateDuration(FALSE);
	SetDirty(TRUE);
}

BOOL CMScopePropGeneral::OnApply() 
{
	// this gets the name and comment
    UpdateData();

    // grab the lease time
    DWORD dwLeaseTime;
	if (m_radioUnlimited.GetCheck())
	{
		dwLeaseTime = DHCP_INFINIT_LEASE;
	}
	else
	{
		dwLeaseTime = UtilConvertLeaseTime(m_spinDays.GetPos(), 
										   m_spinHours.GetPos(),
										   m_spinMinutes.GetPos());
	}
	
	if (dwLeaseTime == 0)
	{
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
		DhcpMessageBox(IDS_ERR_NO_DURATION_SPECIFIED);
		m_editDays.SetFocus();
		
		return FALSE;
	}

	if (dwLeaseTime != m_ScopeCfg.m_dwLeaseTime)
	{
		m_bUpdateLease = TRUE;
		m_ScopeCfgTemp.m_dwLeaseTime = dwLeaseTime;
	}
	
	m_bUpdateInfo = (m_editName.GetModify() || m_editComment.GetModify());

    // grab the TTL
    CString strTemp;
    DWORD dwTemp;
    m_editTTL.GetWindowText(strTemp);
    FCvtAsciiToInteger((LPCTSTR) strTemp, &dwTemp);
    m_SubnetInfoTemp.TTL = LOBYTE(LOWORD(dwTemp));

    if ( (dwTemp < 1) ||
         (dwTemp > 255) )
    {
        // invalid TTL specified
        AfxMessageBox(IDS_INVALID_TTL);
        m_editTTL.SetFocus();
        m_editTTL.SetSel(0,-1);
        return FALSE;
    }

    if (m_SubnetInfo.TTL != m_SubnetInfoTemp.TTL)
    {
        m_bUpdateInfo = TRUE;
    }
    
    // grab the addresses
    if (m_ipaStart.GetModify() ||
		m_ipaEnd.GetModify() )
	{
		m_bUpdateRange = TRUE;
		m_ipaStart.GetAddress(&m_ScopeCfgTemp.m_dwStartAddress);
		m_ipaEnd.GetAddress(&m_ScopeCfgTemp.m_dwEndAddress);
	}

    // call the base on apply which does the thread switch for us
    // and we come back through OnPropertyChange
	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

    m_editName.SetModify(FALSE);
	m_editComment.SetModify(FALSE);
    m_editTTL.SetModify(FALSE);

	return bRet;
}

BOOL CMScopePropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	CDhcpMScope *	pScope;
	SPITFSNode		spNode;
	DWORD			dwError = 0;	

	spNode = GetHolder()->GetNode();
	pScope = GETHANDLER(CDhcpMScope, spNode);
	
	BEGIN_WAIT_CURSOR;

    //
	// Check to see if we need to update the least time
	//
	if (m_bUpdateLease)
	{
		// Lease time changed, update on server
		dwError = pScope->SetLeaseTime(m_ScopeCfgTemp.m_dwLeaseTime);
		if (dwError != ERROR_SUCCESS)
        {
            GetHolder()->SetError(dwError);
        }
        else
        {
            m_ScopeCfg.m_dwLeaseTime = m_ScopeCfgTemp.m_dwLeaseTime;

            m_bUpdateLease = FALSE;
        }
	}

	//
	// Now check the allocation range
	//
	if (m_bUpdateRange)
    {
		// need to update the address pool allocation range
		DHCP_IP_RANGE dhcpIpRange;
		
		dhcpIpRange.StartAddress = m_ScopeCfgTemp.m_dwStartAddress;
		dhcpIpRange.EndAddress = m_ScopeCfgTemp.m_dwEndAddress;

		dwError = pScope->UpdateIpRange(&dhcpIpRange);
		if (dwError != ERROR_SUCCESS)
        {
            GetHolder()->SetError(dwError);
        }
        else
        {
            m_ScopeCfg.m_dwStartAddress = m_ScopeCfgTemp.m_dwStartAddress;
            m_ScopeCfg.m_dwEndAddress = m_ScopeCfgTemp.m_dwEndAddress;

            m_bUpdateRange = FALSE;
        }
	}

	//
	// Update the name and comment if necessary 
	//
    LPCTSTR pNewName = NULL;
    CString strDisplay, strOldComment;

    strOldComment = pScope->GetComment();

    if (m_bUpdateInfo)
	{
        // update the comment
        m_SubnetInfoTemp.SubnetComment = m_strComment;
        pScope->SetComment(m_strComment);

        // name
        m_SubnetInfoTemp.SubnetName = m_strName;
        pNewName = (LPCTSTR) m_strName;
		*ChangeMask = SCOPE_PANE_CHANGE_ITEM_DATA;

		// Lease time changed, update on server
		dwError = pScope->SetTTL(m_SubnetInfoTemp.TTL);
        
        // try to set the new info
        dwError = pScope->SetInfo(pNewName);
		if (dwError != ERROR_SUCCESS)
        {
            // failed, revert to old info
            pScope->SetComment(strOldComment);
            GetHolder()->SetError(dwError);
        }
        else
        {
            // success, rebuild display name
            pScope->BuildDisplayName(&strDisplay, pNewName);
            pScope->SetDisplayName(strDisplay);

            m_SubnetInfo = m_SubnetInfoTemp;

            m_bUpdateInfo = FALSE;
        }
	}
	
    END_WAIT_CURSOR;

	return FALSE;
}

void CMScopePropGeneral::OnChangeEditLeaseDays() 
{
    ValidateLeaseTime();
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeEditLeaseHours() 
{
    ValidateLeaseTime();
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeEditLeaseMinutes() 
{
    ValidateLeaseTime();
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeEditTTL() 
{
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeEditScopeComment() 
{
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeEditScopeName() 
{
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeIpAddrStart() 
{
	SetDirty(TRUE);
}

void CMScopePropGeneral::OnChangeIpAddrEnd() 
{
	SetDirty(TRUE);
}

//
// Helpers
//
void 
CMScopePropGeneral::ActivateDuration
(
	BOOL fActive
)
{
	m_spinMinutes.EnableWindow(fActive);
    m_spinHours.EnableWindow(fActive);
    m_spinDays.EnableWindow(fActive);

	m_editMinutes.EnableWindow(fActive);
    m_editHours.EnableWindow(fActive);
    m_editDays.EnableWindow(fActive);

	GetDlgItem(IDC_STATIC_DAYS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_HOURS)->EnableWindow(fActive);
	GetDlgItem(IDC_STATIC_MINUTES)->EnableWindow(fActive);
}   

void
CMScopePropGeneral::ValidateLeaseTime()
{
    CString strText;

    if (IsWindow(m_editHours.GetSafeHwnd()))
    {
        m_editHours.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > HOURS_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(HOURS_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editHours.SetWindowText(strText);
            m_spinHours.SetPos(HOURS_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

    if (IsWindow(m_editMinutes.GetSafeHwnd()))
    {
        m_editMinutes.GetWindowText(strText);

        // check to see if the value is greater than the max
        if (_ttoi(strText) > MINUTES_MAX)
        {   
            LPTSTR pBuf = strText.GetBuffer(5);

            _itot(MINUTES_MAX, pBuf, 10);
            strText.ReleaseBuffer();

            m_editMinutes.SetWindowText(strText);
            m_spinMinutes.SetPos(MINUTES_MAX);

            MessageBeep(MB_ICONEXCLAMATION);
        }
    }

}

/////////////////////////////////////////////////////////////////////////////
// CMScopePropLifetime property page

IMPLEMENT_DYNCREATE(CMScopePropLifetime, CPropertyPageBase)

CMScopePropLifetime::CMScopePropLifetime() : CPropertyPageBase(CMScopePropLifetime::IDD)
{
	//{{AFX_DATA_INIT(CMScopePropLifetime)
	//}}AFX_DATA_INIT

    m_Expiry.dwLowDateTime = DHCP_DATE_TIME_INFINIT_LOW;
    m_Expiry.dwHighDateTime = DHCP_DATE_TIME_INFINIT_HIGH;
}

CMScopePropLifetime::~CMScopePropLifetime()
{
}

void CMScopePropLifetime::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMScopePropLifetime)
	DDX_Control(pDX, IDC_RADIO_MSCOPE_FINITE, m_radioFinite);
	DDX_Control(pDX, IDC_RADIO_MSCOPE_INFINITE, m_radioInfinite);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMScopePropLifetime, CPropertyPageBase)
	//{{AFX_MSG_MAP(CMScopePropLifetime)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_TIME, OnDatetimechangeDatetimepickerTime)
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_DATETIMEPICKER_DATE, OnDatetimechangeDatetimepickerDate)
	ON_BN_CLICKED(IDC_RADIO_MSCOPE_INFINITE, OnRadioScopeInfinite)
	ON_BN_CLICKED(IDC_RADIO_MSCOPE_FINITE, OnRadioMscopeFinite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMScopePropLifetime message handlers

BOOL CMScopePropLifetime::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
    if ( (m_Expiry.dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) && 
         (m_Expiry.dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
    {
        m_radioInfinite.SetCheck(TRUE);
    }
    else
    {
        SYSTEMTIME st;
        FILETIME ft;

        m_radioFinite.SetCheck(TRUE);

        FileTimeToLocalFileTime((FILETIME *) &m_Expiry, &ft);
        FileTimeToSystemTime(&ft, &st);

        ::SendMessage(GetDlgItem(IDC_DATETIMEPICKER_DATE)->GetSafeHwnd(), DTM_SETSYSTEMTIME, 0, (LPARAM) &st);
        ::SendMessage(GetDlgItem(IDC_DATETIMEPICKER_TIME)->GetSafeHwnd(), DTM_SETSYSTEMTIME, 0, (LPARAM) &st);
    }

    UpdateControls();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CMScopePropLifetime::OnApply() 
{
    DATE_TIME datetime;
    
    if (m_radioInfinite.GetCheck())
    {
        datetime.dwLowDateTime = DHCP_DATE_TIME_INFINIT_LOW;
        datetime.dwHighDateTime = DHCP_DATE_TIME_INFINIT_HIGH;
    }
    else
    {
        SYSTEMTIME stDate, stTime;

	    ::SendMessage(GetDlgItem(IDC_DATETIMEPICKER_DATE)->GetSafeHwnd(), DTM_GETSYSTEMTIME, 0, (LPARAM) &stDate);
	    ::SendMessage(GetDlgItem(IDC_DATETIMEPICKER_TIME)->GetSafeHwnd(), DTM_GETSYSTEMTIME, 0, (LPARAM) &stTime);
        
        SYSTEMTIME systemtime;

        systemtime.wYear = stDate.wYear;
	    systemtime.wMonth = stDate.wMonth;
	    systemtime.wDayOfWeek = stDate.wDayOfWeek;
	    systemtime.wDay = stDate.wDay;
	    systemtime.wHour = stTime.wHour;
	    systemtime.wMinute = stTime.wMinute;
	    systemtime.wSecond = stTime.wSecond;
	    systemtime.wMilliseconds = 0;

        FILETIME ft;

        ::SystemTimeToFileTime(&systemtime, &ft);
        ::LocalFileTimeToFileTime(&ft, (LPFILETIME) &datetime);
    }

	CDhcpMScope *	pScope;
	SPITFSNode		spNode;
	DWORD			dwError = 0;	

	spNode = GetHolder()->GetNode();
	pScope = GETHANDLER(CDhcpMScope, spNode);

    pScope->SetLifetime(&datetime);
    dwError = pScope->SetInfo(NULL);

    if (dwError != ERROR_SUCCESS)
    {
        DhcpMessageBox(dwError);
        return FALSE;
    }

	return CPropertyPageBase::OnApply();
}

void CMScopePropLifetime::UpdateControls()
{
    BOOL fEnable = TRUE;

    if (m_radioInfinite.GetCheck())
    {
        fEnable = FALSE;
    }

    GetDlgItem(IDC_DATETIMEPICKER_DATE)->EnableWindow(fEnable);
    GetDlgItem(IDC_DATETIMEPICKER_TIME)->EnableWindow(fEnable);
}

void CMScopePropLifetime::OnDatetimechangeDatetimepickerTime(NMHDR* pNMHDR, LRESULT* pResult) 
{
    SetDirty(TRUE);
	
	*pResult = 0;
}

void CMScopePropLifetime::OnDatetimechangeDatetimepickerDate(NMHDR* pNMHDR, LRESULT* pResult) 
{
    SetDirty(TRUE);
    
	*pResult = 0;
}

void CMScopePropLifetime::OnRadioScopeInfinite() 
{
    SetDirty(TRUE);
    UpdateControls();
}

void CMScopePropLifetime::OnRadioMscopeFinite() 
{
    SetDirty(TRUE);
    UpdateControls();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscopepp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	MScopePP.
		This file contains all of the prototypes for the 
		scope property page.

    FILE HISTORY:
        
*/

#if !defined(AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
#define AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _SERVER_H
#include "server.h"
#endif

class MScopeCfg
{
public:
	DWORD			m_dwStartAddress;
	DWORD			m_dwEndAddress;

	DWORD			m_dwLeaseTime;
};

/////////////////////////////////////////////////////////////////////////////
// CScopePropGeneral dialog

class CMScopePropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopePropGeneral)

// Construction
public:
	CMScopePropGeneral();
	~CMScopePropGeneral();

// Dialog Data
	//{{AFX_DATA(CMScopePropGeneral)
	enum { IDD = IDP_MSCOPE_GENERAL };
	CEdit	m_editName;
	CEdit	m_editComment;
	CEdit	m_editTTL;
	CButton	m_radioUnlimited;
	CButton	m_radioLimited;
	CEdit	m_editMinutes;
	CEdit	m_editHours;
	CEdit	m_editDays;
	CSpinButtonCtrl	m_spinTTL;
	CSpinButtonCtrl	m_spinHours;
	CSpinButtonCtrl	m_spinMinutes;
	CSpinButtonCtrl	m_spinDays;
	CString	m_strComment;
	CString	m_strName;
	//}}AFX_DATA

    CWndIpAddress	m_ipaStart;       //  Start Address
    CWndIpAddress	m_ipaEnd;         //  End Address

    MScopeCfg       m_ScopeCfg;
    MScopeCfg       m_ScopeCfgTemp;
    
    CSubnetInfo     m_SubnetInfo;
    CSubnetInfo     m_SubnetInfoTemp;
    
    BOOL			m_bUpdateInfo;
	BOOL			m_bUpdateLease;
	BOOL			m_bUpdateRange;
    BOOL            m_bUpdateTTL;

    UINT            m_uImage;

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CMScopePropGeneral::IDD); }

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopePropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopePropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLeaseLimited();
	afx_msg void OnRadioLeaseUnlimited();
	afx_msg void OnChangeEditLeaseDays();
	afx_msg void OnChangeEditLeaseHours();
	afx_msg void OnChangeEditLeaseMinutes();
	afx_msg void OnChangeEditTTL();
	afx_msg void OnChangeEditScopeComment();
	afx_msg void OnChangeEditScopeName();
	afx_msg void OnCheckDefault();
	//}}AFX_MSG

	afx_msg void OnChangeIpAddrStart();
	afx_msg void OnChangeIpAddrEnd();
	
	DECLARE_MESSAGE_MAP()

	void ActivateDuration(BOOL fActive);
    void ValidateLeaseTime();

public:

};

/////////////////////////////////////////////////////////////////////////////
// CMScopePropLifetime dialog

class CMScopePropLifetime : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopePropLifetime)

// Construction
public:
	CMScopePropLifetime();
	~CMScopePropLifetime();

// Dialog Data
	//{{AFX_DATA(CMScopePropLifetime)
	enum { IDD = IDP_MSCOPE_LIFETIME };
	CButton	m_radioFinite;
	CButton	m_radioInfinite;
	//}}AFX_DATA

    DATE_TIME       m_Expiry;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopePropLifetime)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

    void UpdateControls();

    // Context Help Support
    virtual DWORD * GetHelpMap() { return DhcpGetHelpMap(CMScopePropLifetime::IDD); }

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopePropLifetime)
	virtual BOOL OnInitDialog();
	afx_msg void OnDatetimechangeDatetimepickerTime(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDatetimechangeDatetimepickerDate(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioScopeInfinite();
	afx_msg void OnRadioMscopeFinite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CMScopeProperties : public CPropertyPageHolderBase
{
	friend class CScopePropGeneral;

public:
	CMScopeProperties(ITFSNode *			 pNode,
	 				  IComponentData *	 pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			 pszSheetName);
	virtual ~CMScopeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetVersion(LARGE_INTEGER & liVersion);

public:
	CMScopePropGeneral			m_pageGeneral;
	CMScopePropLifetime			m_pageLifetime;

protected:
	SPITFSComponentData			m_spTFSCompData;

	LARGE_INTEGER				m_liVersion;
};


#endif // !defined(AFX_SCOPEPP_H__A1A51388_AAB3_11D0_AB8B_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscope.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        mscope.h
        This file contains the prototypes for the Multicast scope node
        and it's children.
                
    FILE HISTORY:
    07 Oct 1997  EricDav    Created
    
*/

#ifndef _MSCOPE_H
#define _MSCOPE_H

#ifndef _DHCPHAND_H
#include "dhcphand.h"
#endif

#ifndef _DHCPNODE_H
#include "nodes.h"
#endif

#ifndef _MSCPSTAT_H
#include "mscpstat.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

#define DHCP_QDATA_SUBNET_INFO            0x00000004

class CMScopeAddressPool;

void GetLangTag(CString & strLangTag);

/*---------------------------------------------------------------------------
        Class:  CDhcpMScope
 ---------------------------------------------------------------------------*/
class CDhcpMScope : public CMTDhcpHandler
{
public:
    CDhcpMScope(ITFSComponentData * pComponentData);
        ~CDhcpMScope();

// Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();
    OVERRIDE_NodeHandler_DestroyHandler();

    OVERRIDE_NodeHandler_HasPropertyPages() { return hrOK; }
    OVERRIDE_NodeHandler_CreatePropertyPages();
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
    OVERRIDE_BaseHandlerNotify_OnDelete();

    // Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();

    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
    // CMTDhcpHandler functionality
    virtual HRESULT InitializeNode(ITFSNode * pNode);
    virtual int     GetImageIndex(BOOL bOpenImage);
    virtual void    OnHaveData(ITFSNode * pParent, ITFSNode * pNew);
    virtual void    OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);
    HRESULT OnUpdateToolbarButtons(ITFSNode * pNode, LPDHCPTOOLBARNOTIFY pToolbarNotify);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    
    CDhcpServer* GetServerObject(ITFSNode * pNode)
    { 
        SPITFSNode spServerNode;
        pNode->GetParent(&spServerNode);
        return GETHANDLER(CDhcpServer, spServerNode);
    }
    
    CMScopeAddressPool* GetAddressPoolObject()
    { 
        if (m_spAddressPool) 
            return GETHANDLER(CMScopeAddressPool, m_spAddressPool); 
        else
            return NULL; 
    }

    // implementation
public:
    // helpers
    void SetServer(ITFSNode * pServerNode) { m_spServerNode.Set(pServerNode); }
    HRESULT GetServerNode(ITFSNode ** ppNode) 
    { 
        m_spServerNode->AddRef(); 
        *ppNode = m_spServerNode; 
        return hrOK; 
    }
    CDhcpServer *  GetServerObject() { return GETHANDLER(CDhcpServer, m_spServerNode); }
    LPCWSTR GetServerIpAddress();
    void    GetServerIpAddress(DHCP_IP_ADDRESS * pdhcpIpAddress);
    void    GetServerVersion(LARGE_INTEGER& liVersion);
    
    HRESULT BuildDisplayName(CString * pstrDisplayName, LPCTSTR pName);
    
    void    UpdateToolbarStates();
    
    // dhcp specific
    DWORD   SetInfo(LPCTSTR pNewName = NULL);
    HRESULT InitMScopeInfo(LPDHCP_MSCOPE_INFO pMScopeInfo);
    HRESULT InitMScopeInfo(CSubnetInfo & subnetInfo);

    // public functions for scope manipulation
    LPCWSTR GetName() { return m_SubnetInfo.SubnetName; };
    HRESULT SetName(LPCTSTR pName);
        
    LPCWSTR GetComment() { return m_SubnetInfo.SubnetComment; };
    void    SetComment(LPCWSTR pComment) { m_SubnetInfo.SubnetComment = pComment; };

    DWORD   GetScopeId() { return m_SubnetInfo.SubnetAddress; }

    // Functions to get and set the lease time
    DWORD   GetLeaseTime(LPDWORD pdwLeaseTime);
    DWORD   SetLeaseTime(DWORD dwLeaseTime);

    // Functions to get and set the madcap scope lifetime
    DWORD   GetLifetime(DATE_TIME * pdtLifetime);
    DWORD   SetLifetime(DATE_TIME * pdtLifetime);

    // Functions to get and set the TTL
    DWORD   GetTTL(LPBYTE TTL);
    DWORD   SetTTL(BYTE TTL);

    // option functionality
    DWORD   SetOptionValue(CDhcpOption *                        pdhcType);
    DWORD   GetOptionValue(DHCP_OPTION_ID                   OptionID,
                           DHCP_OPTION_VALUE **   ppdhcOptionValue);
    DWORD   RemoveOptionValue(DHCP_OPTION_ID                        dhcOptId);

    DWORD   DeleteClient(DHCP_IP_ADDRESS dhcpClientIpAddress);

    DWORD   UpdateIpRange(DHCP_IP_RANGE * pdhipr);
    DWORD   SetIpRange(DHCP_IP_RANGE *pdhcpIpRange, BOOL bSetOnServer);
    DWORD   SetIpRange(const CDhcpIpRange & dhcpIpRange, BOOL bSetOnServer);
    void    QueryIpRange (DHCP_IP_RANGE * pdhipr);
    DWORD   GetIpRange (DHCP_IP_RANGE * pdhipr);

    DWORD   StoreExceptionList(CExclusionList * plistExclusions);
    DWORD   AddExclusion(CDhcpIpRange & dhcpIpRange, BOOL bAddToUI = FALSE);
    DWORD   RemoveExclusion(CDhcpIpRange & dhcpIpRange);
    BOOL    IsOverlappingRange(CDhcpIpRange & dhcpIpRange);
    DWORD   IsValidExclusion(CDhcpIpRange & dhcpExclusion);

    DWORD   AddElement(DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData);
    DWORD   RemoveElement(DHCP_SUBNET_ELEMENT_DATA_V4 * pdhcpSubnetElementData, BOOL bForce = FALSE);

    // interal state information
    BOOL    IsEnabled() { return m_SubnetInfo.SubnetState == DhcpSubnetEnabled; }
    void    SetState(DHCP_SUBNET_STATE dhcpSubnetState) { m_SubnetInfo.SubnetState = dhcpSubnetState; } 
    DHCP_SUBNET_STATE GetState() { return m_SubnetInfo.SubnetState; }

private:
    // command handlers
    DWORD   OnActivateScope(ITFSNode * pNode);
    HRESULT OnReconcileScope(ITFSNode * pNode);
    HRESULT OnShowScopeStats(ITFSNode * pNode);
    HRESULT OnDelete(ITFSNode * pNode);

    // Implementation
private:

    // Attributes
private:
    CSubnetInfo         m_SubnetInfo;

    CString             m_strState;
    DHCP_SUBNET_STATE   m_dhcpSubnetState;

    DWORD               m_dwLeaseTime;

    SPITFSNode                      m_spAddressPool;
    SPITFSNode                      m_spActiveLeases;
    SPITFSNode                  m_spServerNode;

    CMScopeStats        m_dlgStats;
};

/*---------------------------------------------------------------------------
        Class:  CDhcpMScopeSubobject
        All subobjects of a scope derive from this to provide base
        functionality to get information from the scope.
 ---------------------------------------------------------------------------*/
class CDhcpMScopeSubobject
{
public:
    CDhcpMScope * GetScopeObject(ITFSNode * pNode, 
                                 BOOL bResClient = FALSE)
    { 
        if (pNode == NULL)
            return NULL;

        SPITFSNode spScopeNode;
        if (bResClient)
        {
            SPITFSNode spResNode;
            pNode->GetParent(&spResNode);
            spResNode->GetParent(&spScopeNode);
        }
        else
        {
            pNode->GetParent(&spScopeNode);
        }

        return GETHANDLER(CDhcpMScope, spScopeNode);
    }

    ITFSNode * GetServerNode(ITFSNode * pNode, BOOL bResClient = FALSE)
    {
        CDhcpMScope * pScope = GetScopeObject(pNode, bResClient);

        SPITFSNode spServerNode;

        if (pScope)
        {
            pScope->GetServerNode(&spServerNode);
            spServerNode->AddRef();
        }

        return spServerNode;
    }

    LPCTSTR GetServerName(ITFSNode * pNode, 
                          BOOL bResClient = FALSE) 
    {
        LPCTSTR pszReturn = NULL;

        CDhcpMScope * pScope = GetScopeObject(pNode, bResClient);
        if (pScope)
        {
            CDhcpServer * pServer = pScope->GetServerObject();
            if (pServer)
                pszReturn = pServer->GetName();
        }
        
        return pszReturn;
    }

    LPCTSTR GetServerIpAddress(ITFSNode * pNode, 
                               BOOL bResClient = FALSE) 
    {
        CDhcpMScope * pScope = GetScopeObject(pNode, bResClient);
        if (pScope)
            return pScope->GetServerIpAddress(); 
        else
            return NULL;
    }

    void GetServerIpAddress(ITFSNode * pNode, 
                            DHCP_IP_ADDRESS * pdhcpIpAddress, 
                            BOOL bResClient = FALSE)
    {
        CDhcpMScope * pScope = GetScopeObject(pNode, bResClient);
        if (pScope)
            pScope->GetServerIpAddress(pdhcpIpAddress);
    }

    void GetServerVersion(ITFSNode * pNode, 
                          LARGE_INTEGER& liVersion, 
                          BOOL bResClient = FALSE) 
    { 
        CDhcpMScope * pScope = GetScopeObject(pNode, bResClient);
        if (pScope)
            pScope->GetServerVersion(liVersion); 
    } 
};

/*---------------------------------------------------------------------------
        Class:  CMScopeActiveLeases
 ---------------------------------------------------------------------------*/
class CMScopeActiveLeases : 
    public CMTDhcpHandler,
    public CDhcpMScopeSubobject
{
public:
    CMScopeActiveLeases(ITFSComponentData * pComponentData);
    ~CMScopeActiveLeases();

    // Interface
public:
    // Node handler functionality we override
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();

    OVERRIDE_NodeHandler_GetString() 
    { return (nCol == 0) ? GetDisplayName() : NULL; }

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    // Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_CompareItems();

public:
    // CDhcpHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);
    virtual int GetImageIndex(BOOL bOpenImage);

public:
    // implementation specifiec
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

    // Implementation
private:
    int             CompareIpAddresses(CDhcpMCastLease * pDhcpAL1, CDhcpMCastLease * pDhcpAL2);

    // Attributes
private:
};


/*---------------------------------------------------------------------------
        Class:  CMScopeAddressPool
 ---------------------------------------------------------------------------*/
class CMScopeAddressPool : 
    public CMTDhcpHandler,
    public CDhcpMScopeSubobject

{
public:
    CMScopeAddressPool(ITFSComponentData * pComponentData);
    ~CMScopeAddressPool();

    // Interface
public:
    // Node handler functionality we override
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();

    OVERRIDE_NodeHandler_GetString() 
    { return (nCol == 0) ? GetDisplayName() : NULL; }
    
    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

    // Result Handler notification
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_ResultHandler_CompareItems();
    OVERRIDE_ResultHandler_OnGetResultViewType();

public:
    // CDhcpHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);
    virtual int GetImageIndex(BOOL bOpenImage);

public:
    // implementation specific
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

private:
    // command handlers
    DWORD OnCreateNewExclusion(ITFSNode * pNode);
    // Attributes
private:
};

/*---------------------------------------------------------------------------
        Class:  CDhcpMScopeQueryObj
 ---------------------------------------------------------------------------*/
class CDhcpMScopeQueryObj : public CDHCPQueryObj
{
public:
    CDhcpMScopeQueryObj
    (
         ITFSComponentData* pTFSComponentData,
         ITFSNodeMgr*       pNodeMgr
    ) : CDHCPQueryObj(pTFSComponentData, pNodeMgr) {};
    
    STDMETHODIMP Execute();
    HRESULT CreateSubcontainers();

public:
    CString             m_strName;
};

/*---------------------------------------------------------------------------
        Class:  CMScopeActiveLeasesQueryObj
 ---------------------------------------------------------------------------*/
class CMScopeActiveLeasesQueryObj : public CDHCPQueryObj
{
public:
    CMScopeActiveLeasesQueryObj(ITFSComponentData * pTFSCompData,
                                ITFSNodeMgr *                 pNodeMgr) 
        : CDHCPQueryObj(pTFSCompData, pNodeMgr) { m_nQueueCountMax = 20; }
        
    STDMETHODIMP Execute();
    HRESULT EnumerateLeases();

    LARGE_INTEGER           m_liDhcpVersion;
    DHCP_RESUME_HANDLE      m_dhcpResumeHandle;
    DWORD                           m_dwPreferredMax;

    CString             m_strName;
};

/*---------------------------------------------------------------------------
        Class:  CMScopeAddressPoolQueryObj
 ---------------------------------------------------------------------------*/
class CMScopeAddressPoolQueryObj : public CDHCPQueryObj
{
public:
    CMScopeAddressPoolQueryObj(ITFSComponentData * pTFSCompData,
                               ITFSNodeMgr *                  pNodeMgr) 
        : CDHCPQueryObj(pTFSCompData, pNodeMgr),
          m_dwError(0)    {};

    STDMETHODIMP Execute();
    HRESULT EnumerateIpRanges();
    HRESULT EnumerateExcludedIpRanges();

public:
    CString             m_strName;

    DHCP_RESUME_HANDLE      m_dhcpExclResumeHandle;
    DWORD                           m_dwExclPreferredMax;
        
    DHCP_RESUME_HANDLE      m_dhcpIpResumeHandle;
    DWORD                           m_dwIpPreferredMax;
    DWORD               m_dwError;
};

#endif _MSCOPE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscpstat.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	ScopStat.cpp
		The scope statistics dialog
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "mScpStat.h"
#include "mscope.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum 
{
    SCOPE_STAT_TOTAL_ADDRESSES = 0,
    SCOPE_STAT_IN_USE,
    SCOPE_STAT_AVAILABLE,
    SCOPE_STAT_MAX
};

/*---------------------------------------------------------------------------
	CMScopeStats implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgScopeStatsColumnInfo[] =
{
	{ IDS_STATS_TOTAL_ADDRESSES,		0,		TRUE },
	{ IDS_STATS_IN_USE,   		        0,		TRUE },
	{ IDS_STATS_AVAILABLE, 		        0,		TRUE },
};

CMScopeStats::CMScopeStats()
	: StatsDialog(STATSDLG_VERTICAL)
{
    SetColumnInfo(s_rgScopeStatsColumnInfo,
				  DimensionOf(s_rgScopeStatsColumnInfo));
}

CMScopeStats::~CMScopeStats()
{
}

BEGIN_MESSAGE_MAP(CMScopeStats, StatsDialog)
	//{{AFX_MSG_MAP(CMScopeStats)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
END_MESSAGE_MAP()

HRESULT CMScopeStats::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;
	    LPDHCP_MCAST_MIB_INFO pMibInfo = NULL;
	    
        BEGIN_WAIT_CURSOR;
        dwError = ::DhcpGetMCastMibInfo(m_strServerAddress, &pMibInfo);
        END_WAIT_CURSOR;
    
        if (dwError != ERROR_SUCCESS)
	    {
		    ::DhcpMessageBox(dwError);
		    return hrOK;
	    }

        UpdateWindow(pMibInfo);

        if (pMibInfo)
		    ::DhcpRpcFreeMemory(pMibInfo);
    }

    return hrOK;
}

BOOL CMScopeStats::OnInitDialog()
{
	CString	st;
    BOOL bRet;

    AfxFormatString1(st, IDS_MSCOPE_STATS_TITLE, m_strScopeName);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    return bRet;
}

void CMScopeStats::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}


afx_msg long CMScopeStats::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    SPITFSNode    spNode;
    CDhcpMScope *  pScope;
    CDhcpServer * pServer;

    pScope = GETHANDLER(CDhcpMScope, m_spNode);
    pServer = pScope->GetServerObject();

    LPDHCP_MCAST_MIB_INFO pMibInfo = pServer->DuplicateMCastMibInfo();

    Assert(pMibInfo);
    if (!pMibInfo)
        return 0;

    UpdateWindow(pMibInfo);

    pServer->FreeDupMCastMibInfo(pMibInfo);

    return 0;
}

void CMScopeStats::UpdateWindow(LPDHCP_MCAST_MIB_INFO pMibInfo)
{
	Assert (pMibInfo);

    UINT i;
    int nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;

    if (pMibInfo)
    {
        LPMSCOPE_MIB_INFO pScopeMibInfo = pMibInfo->ScopeInfo;

	    // walk the list of scopes and calculate totals
	    for (i = 0; i < pMibInfo->Scopes; i++)
	    {
		    if (pScopeMibInfo[i].MScopeId == m_dwScopeId)
		    {
			    nTotalAddresses += (pScopeMibInfo[i].NumAddressesInuse + pScopeMibInfo[i].NumAddressesFree);
			    nTotalInUse = pScopeMibInfo[i].NumAddressesInuse;
			    nTotalAvailable = pScopeMibInfo[i].NumAddressesFree;

			    break;
		    }
	    }
    }

    int     nPercent;
	CString	st;
    TCHAR   szFormat[] = _T("%d");
    TCHAR   szPercentFormat[] =  _T("%d (%d%%)");

    for (i = 0; i < SCOPE_STAT_MAX; i++)
	{
        if (!pMibInfo)
            st = _T("---");
        else
        {
		    switch (i)
		    {
                case SCOPE_STAT_TOTAL_ADDRESSES:
            	    st.Format(szFormat, nTotalAddresses);
                    break;

                case SCOPE_STAT_IN_USE:
	                if (nTotalAddresses > 0)
		                nPercent = (int)(((LONGLONG)nTotalInUse * (LONGLONG)100) / nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalInUse, nPercent);
                    break;

                case SCOPE_STAT_AVAILABLE:
	                if (nTotalAddresses > 0)
		                nPercent = (int)(((LONGLONG)nTotalAvailable * (LONGLONG)100) / nTotalAddresses);
	                else
		                nPercent = 0;

            	    st.Format(szPercentFormat, nTotalAvailable, nPercent);
                    break;
            
    		    default:
				    Panic1("Unknown scope stat id : %d", i);
				    break;
		    }
        }
        
		m_listCtrl.SetItemText(i, 1, (LPCTSTR) st);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\mscopwiz.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	mscopewiz.h
		DHCP multicast scope creation dialog
		
    FILE HISTORY:
        
*/

#if !defined _MSCOPWIZ_H
#define _MSCOPWIZ_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizName dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizName : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizName)

// Construction
public:
	CMScopeWizName();
	~CMScopeWizName();

// Dialog Data
	//{{AFX_DATA(CMScopeWizName)
	enum { IDD = IDW_MSCOPE_NAME };
	CEdit	m_editScopeName;
	CEdit	m_editScopeComment;
	CString	m_strName;
	CString	m_strComment;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizName)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	void UpdateButtons();

protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizName)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditScopeName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizInvalidName dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizInvalidName : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizInvalidName)

// Construction
public:
	CMScopeWizInvalidName();
	~CMScopeWizInvalidName();

// Dialog Data
	//{{AFX_DATA(CMScopeWizInvalidName)
	enum { IDD = IDW_MSCOPE_INVALID_NAME };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizInvalidName)
	public:
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizInvalidName)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetRange dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizSetRange : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizSetRange)

// Construction
public:
	CMScopeWizSetRange();
	~CMScopeWizSetRange();

// Dialog Data
	//{{AFX_DATA(CMScopeWizSetRange)
	enum { IDD = IDW_MSCOPE_SET_SCOPE };
	CSpinButtonCtrl	m_spinTTL;
	CEdit	m_editTTL;
	//}}AFX_DATA

    CWndIpAddress m_ipaStart;       //  Start Address
    CWndIpAddress m_ipaEnd;         //  End Address

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizSetRange)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	BOOL	GetScopeRange(CDhcpIpRange * pdhcpIpRange);
    BYTE    GetTTL();

protected:
	BOOL	m_fPageActive;

	// Generated message map functions
	//{{AFX_MSG(CMScopeWizSetRange)
	virtual BOOL OnInitDialog();
	afx_msg void OnKillfocusPoolStart();
	afx_msg void OnKillfocusPoolStop();
	afx_msg void OnChangeEditMaskLength();
	afx_msg void OnKillfocusSubnetMask();

	afx_msg void OnChangePoolStart();
	afx_msg void OnChangePoolStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void UpdateButtons();
};

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizSetExclusions dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizSetExclusions : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizSetExclusions)

// Construction
public:
	CMScopeWizSetExclusions();
	~CMScopeWizSetExclusions();

// Dialog Data
	//{{AFX_DATA(CMScopeWizSetExclusions)
	enum { IDD = IDW_MSCOPE_SET_EXCLUSIONS };
	CListBox	m_listboxExclusions;
	CButton	m_buttonExclusionDelete;
	CButton	m_buttonExclusionAdd;
	//}}AFX_DATA

    CWndIpAddress m_ipaStart;       //  Start Address
    CWndIpAddress m_ipaEnd;         //  End Address

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizSetExclusions)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	CExclusionList * GetExclusionList() { return &m_listExclusions; }

protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizSetExclusions)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonExclusionAdd();
	afx_msg void OnButtonExclusionDelete();
	//}}AFX_MSG
	
    afx_msg void OnChangeExclusionStart();
    afx_msg void OnChangeExclusionEnd();
	
	DECLARE_MESSAGE_MAP()

	CExclusionList m_listExclusions;

    //  Fill the exclusions listbox from the current list
    void Fill ( int nCurSel = 0, BOOL bToggleRedraw = TRUE ) ;

    //  Return TRUE if the given range overlaps an already-defined range
    BOOL IsOverlappingRange ( CDhcpIpRange & dhcIpRange ) ;

    //  Store the excluded IP range values into a range object
    BOOL GetExclusionRange (CDhcpIpRange & dhcIpRange ) ;

    //  Format an IP range pair into the exclusion edit controls
    void FillExcl ( CDhcpIpRange * pdhcIpRange ) ;

	void UpdateButtons();
};

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizLeaseTime dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizLeaseTime : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizLeaseTime)

// Construction
public:
	CMScopeWizLeaseTime();
	~CMScopeWizLeaseTime();

// Dialog Data
	//{{AFX_DATA(CMScopeWizLeaseTime)
	enum { IDD = IDW_MSCOPE_LEASE_TIME };
	CSpinButtonCtrl	m_spinMinutes;
	CSpinButtonCtrl	m_spinHours;
	CSpinButtonCtrl	m_spinDays;
	CEdit	m_editMinutes;
	CEdit	m_editHours;
	CEdit	m_editDays;
	//}}AFX_DATA

	static int m_nDaysDefault;
	static int m_nHoursDefault;
	static int m_nMinutesDefault;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizLeaseTime)
	public:
	virtual LRESULT OnWizardNext();
	virtual LRESULT OnWizardBack();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	DWORD GetLeaseTime();

protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizLeaseTime)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLeaseLimited();
	afx_msg void OnRadioLeaseUnlimited();
	afx_msg void OnChangeEditLeaseHours();
	afx_msg void OnChangeEditLeaseMinutes();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ActivateDuration(BOOL fActive);
};

/////////////////////////////////////////////////////////////////////////////
//
// CMScopeWizFinished dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWizFinished : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizFinished)

// Construction
public:
	CMScopeWizFinished();
	~CMScopeWizFinished();

// Dialog Data
	//{{AFX_DATA(CMScopeWizFinished)
	enum { IDD = IDW_MSCOPE_FINISHED };
	CStatic	m_staticTitle;
	//}}AFX_DATA

   	CFont	m_fontBig;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizFinished)
	public:
	virtual BOOL OnWizardFinish();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizFinished)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMScopeWizWelcome dialog

class CMScopeWizWelcome : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizWelcome)

// Construction
public:
	CMScopeWizWelcome();
	~CMScopeWizWelcome();

// Dialog Data
	//{{AFX_DATA(CMScopeWizWelcome)
	enum { IDD = IDW_MSCOPE_WELCOME };
	CStatic	m_staticTitle;
	//}}AFX_DATA

   	CFont	m_fontBig;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizWelcome)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
// CMScopeWizActivate dialog

class CMScopeWizActivate : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CMScopeWizActivate)

// Construction
public:
	CMScopeWizActivate();
	~CMScopeWizActivate();

// Dialog Data
	//{{AFX_DATA(CMScopeWizActivate)
	enum { IDD = IDW_MSCOPE_ACTIVATE };
	CButton	m_radioYes;
	//}}AFX_DATA

    BOOL    m_fActivate;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMScopeWizActivate)
	public:
	virtual LRESULT OnWizardNext();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMScopeWizActivate)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

///////////////////////////////////////////////////////////////////////////////
//
// CMScopeWiz
//	page holder to contain multicast scope wizard pages
//
/////////////////////////////////////////////////////////////////////////////
class CMScopeWiz : public CPropertyPageHolderBase
{
	friend class CMScopeWizWelcome;
	friend class CMScopeWizName;
	friend class CMScopeWizInvalidName;
	friend class CMScopeWizSetRange;
	friend class CMScopeWizSetExclusions;
	friend class CMScopeWizLeaseTime;
	friend class CMScopeWizFinished;

public:
	CMScopeWiz(ITFSNode *		  pNode,
			  IComponentData *	  pComponentData,
			  ITFSComponentData * pTFSCompData,
			  LPCTSTR			  pszSheetName);
	virtual ~CMScopeWiz();

	virtual DWORD OnFinish();
	BOOL GetScopeRange(CDhcpIpRange * pdhcpIpRange);

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

public:
	CMScopeWizWelcome			m_pageWelcome;
	CMScopeWizName				m_pageName;
	CMScopeWizInvalidName		m_pageInvalidName;
	CMScopeWizSetRange			m_pageSetRange;
	CMScopeWizSetExclusions		m_pageSetExclusions;
	CMScopeWizLeaseTime			m_pageLeaseTime;
	CMScopeWizActivate			m_pageActivate;
	CMScopeWizFinished			m_pageFinished;

protected:
	DWORD CreateScope();

	SPITFSComponentData		m_spTFSCompData;
};

#endif // !defined _MSCOPWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\options.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1999 - 1999 **/
/**********************************************************************/

/*
	options.h 
		defines for options
		
    FILE HISTORY:
        
*/

// This file includes the string IDs of the options
#define IDS_OPTION1                     59001
#define IDS_OPTION2                     59002
#define IDS_OPTION3                     59003
#define IDS_OPTION4                     59004
#define IDS_OPTION5                     59005
#define IDS_OPTION6                     59006
#define IDS_OPTION7                     59007
#define IDS_OPTION8                     59008
#define IDS_OPTION9                     59009
#define IDS_OPTION10                    59010
#define IDS_OPTION11                    59011
#define IDS_OPTION12                    59012
#define IDS_OPTION13                    59013
#define IDS_OPTION14                    59014
#define IDS_OPTION15                    59015
#define IDS_OPTION16                    59016
#define IDS_OPTION17                    59017
#define IDS_OPTION18                    59018
#define IDS_OPTION19                    59019
#define IDS_OPTION20                    59020
#define IDS_OPTION21                    59021
#define IDS_OPTION22                    59022
#define IDS_OPTION23                    59023
#define IDS_OPTION24                    59024
#define IDS_OPTION25                    59025
#define IDS_OPTION26                    59026
#define IDS_OPTION27                    59027
#define IDS_OPTION28                    59028
#define IDS_OPTION29                    59029
#define IDS_OPTION30                    59030
#define IDS_OPTION31                    59031
#define IDS_OPTION32                    59032
#define IDS_OPTION33                    59033
#define IDS_OPTION34                    59034
#define IDS_OPTION35                    59035
#define IDS_OPTION36                    59036
#define IDS_OPTION37                    59037
#define IDS_OPTION38                    59038
#define IDS_OPTION39                    59039
#define IDS_OPTION40                    59040
#define IDS_OPTION41                    59041
#define IDS_OPTION42                    59042
#define IDS_OPTION43                    59043
#define IDS_OPTION44                    59044
#define IDS_OPTION45                    59045
#define IDS_OPTION46                    59046
#define IDS_OPTION47                    59047
#define IDS_OPTION48                    59048
#define IDS_OPTION49                    59049
#define IDS_OPTION50                    59050
#define IDS_OPTION51                    59051
#define IDS_OPTION52                    59052
#define IDS_OPTION53                    59053
#define IDS_OPTION54                    59054
#define IDS_OPTION55                    59055
#define IDS_OPTION56                    59056
#define IDS_OPTION57                    59057
#define IDS_OPTION58                    59058
#define IDS_OPTION59                    59059
#define IDS_OPTION60                    59060
#define IDS_OPTION61                    59061
#define IDS_OPTION62                    59062
#define IDS_OPTION63                    59063
#define IDS_OPTION64                    59064
#define IDS_OPTION65                    59065
#define IDS_OPTION66                    59066
#define IDS_OPTION67                    59067
#define IDS_OPTION68                    59068
#define IDS_OPTION69                    59069
#define IDS_OPTION70                    59070
#define IDS_OPTION71                    59071
#define IDS_OPTION72                    59072
#define IDS_OPTION73                    59073
#define IDS_OPTION74                    59074
#define IDS_OPTION75                    59075
#define IDS_OPTION76                    59076
#define IDS_OPTION77                    59077
#define IDS_OPTION78                    59078
#define IDS_OPTION79                    59079
#define IDS_OPTION80                    59080
#define IDS_OPTION81                    59081
#define IDS_OPTION82                    59082
#define IDS_OPTION83                    59083
#define IDS_OPTION84                    59084
#define IDS_OPTION85                    59085
#define IDS_OPTION86                    59086
#define IDS_OPTION87                    59087
#define IDS_OPTION88                    59088
#define IDS_OPTION89                    59089
#define IDS_OPTION90                    59090
#define IDS_OPTION91                    59091
#define IDS_OPTION92                    59092
#define IDS_OPTION93                    59093
#define IDS_OPTION94                    59094
#define IDS_OPTION95                    59095
#define IDS_OPTION96                    59096
#define IDS_OPTION97                    59097
#define IDS_OPTION98                    59098
#define IDS_OPTION99                    59099
#define IDS_OPTION100                   59100
#define IDS_OPTION101                   59101
#define IDS_OPTION102                   59102
#define IDS_OPTION103                   59103
#define IDS_OPTION104                   59104
#define IDS_OPTION105                   59105
#define IDS_OPTION106                   59106
#define IDS_OPTION107                   59107
#define IDS_OPTION108                   59108
#define IDS_OPTION109                   59109
#define IDS_OPTION110                   59110
#define IDS_OPTION111                   59111
#define IDS_OPTION112                   59112
#define IDS_OPTION113                   59113
#define IDS_OPTION114                   59114
#define IDS_OPTION115                   59115
#define IDS_OPTION116                   59116
#define IDS_OPTION117                   59117
#define IDS_OPTION118                   59118
#define IDS_OPTION119                   59119
#define IDS_OPTION120                   59120
#define IDS_OPTION121                   59121
#define IDS_OPTION122                   59122
#define IDS_OPTION123                   59123
#define IDS_OPTION124                   59124
#define IDS_OPTION125                   59125
#define IDS_OPTION126                   59126
#define IDS_OPTION127                   59127
#define IDS_OPTION128                   59128
#define IDS_OPTION129                   59129
#define IDS_OPTION130                   59130
#define IDS_OPTION131                   59131
#define IDS_OPTION132                   59132
#define IDS_OPTION133                   59133
#define IDS_OPTION134                   59134
#define IDS_OPTION135                   59135
#define IDS_OPTION136                   59136
#define IDS_OPTION137                   59137
#define IDS_OPTION138                   59138
#define IDS_OPTION139                   59139
#define IDS_OPTION140                   59140
#define IDS_OPTION141                   59141
#define IDS_OPTION142                   59142
#define IDS_OPTION143                   59143
#define IDS_OPTION144                   59144

// IDS_OPTION_MAX must be in ssync witth the number of options
#define IDS_OPTION_MAX					144
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\nodes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
        nodes.h
                This file contains all of the implementation for the DHCP
                objects that appear in the result pane of the MMC framework.
                The objects are:

                        CDhcpActiveLease
                        CDhcpConflicAddress
                        CDhcpAllocationRange
                        CDhcpExclusionRange
                        CDhcpBootpTableEntry
                        CDhcpOption

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "nodes.h"
#include "server.h"
#include "scope.h"
#include "optcfg.h"
#include "intltime.h"

CString g_szClientTypeUnspecified;
CString g_szClientTypeNone;
CString g_szClientTypeUnknown;
const TCHAR g_szClientTypeDhcp[] = _T("DHCP");
const TCHAR g_szClientTypeBootp[] = _T("BOOTP");
const TCHAR g_szClientTypeBoth[] = _T("DHCP/BOOTP");

/*---------------------------------------------------------------------------
        Class CDhcpActiveLease implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(CDhcpActiveLease);

/*---------------------------------------------------------------------------
        CDhcpActiveLease constructor/destructor
                Takes the NT5 client info struct
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpActiveLease::CDhcpActiveLease
(
        ITFSComponentData *             pTFSCompData, 
        LPDHCP_CLIENT_INFO_V5   pDhcpClientInfo
) : CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpActiveLease);

    if (g_szClientTypeUnspecified.IsEmpty())
    {
        g_szClientTypeUnspecified.LoadString(IDS_UNSPECIFIED);
        g_szClientTypeNone.LoadString(IDS_NONE);
        g_szClientTypeUnknown.LoadString(IDS_UNKNOWN);
    }

    //
        // Reset our flags for this lease
        //
        m_dwTypeFlags = 0;

        //
        // Intialize our client type variable
        //
        m_bClientType = pDhcpClientInfo->bClientType;

        //
        // Initialize does everything but initialize the client type
        // since there are two versions of the client info struct, one
        // contains the type, the other doesn't.  So we need to save it
        // away after the call.
        //
        InitInfo((LPDHCP_CLIENT_INFO) pDhcpClientInfo);

        // now check NT5 specific flags
        if (pDhcpClientInfo->AddressState & V5_ADDRESS_BIT_UNREGISTERED)
        {
                if (pDhcpClientInfo->AddressState & V5_ADDRESS_BIT_DELETED)
                {       
                        // this lease is pending DNS unregistration
                        m_dwTypeFlags |= TYPE_FLAG_DNS_UNREG;
                }
                else
                {       
                        // this lease is pending DNS registration
                        m_dwTypeFlags |= TYPE_FLAG_DNS_REG;
                }
        }
        else
        if ((pDhcpClientInfo->AddressState & 0x03) == V5_ADDRESS_STATE_DOOM)
        {
                m_dwTypeFlags |= TYPE_FLAG_DOOMED;
        }
}

/*---------------------------------------------------------------------------
        CDhcpActiveLease constructor/destructor
                Takes the NT4 SP2 client info struct
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpActiveLease::CDhcpActiveLease
(
        ITFSComponentData *             pTFSCompData, 
        LPDHCP_CLIENT_INFO_V4   pDhcpClientInfo
) : CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpActiveLease);

    //
        // Reset our flags for this lease
        //
        m_dwTypeFlags = 0;

        //
        // Intialize our client type variable
        //
        m_bClientType = pDhcpClientInfo->bClientType;

        //
        // Initialize does everything but initialize the client type
        // since there are two versions of the client info struct, one
        // contains the type, the other doesn't.  So we need to save it
        // away after the call.
        //
        InitInfo((LPDHCP_CLIENT_INFO) pDhcpClientInfo);
}

/*---------------------------------------------------------------------------
        CDhcpActiveLease constructor/destructor
                Takes the pre-NT4 SP2 client info struct
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpActiveLease::CDhcpActiveLease
(
        ITFSComponentData *             pTFSCompData, 
        LPDHCP_CLIENT_INFO              pDhcpClientInfo
) : CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpActiveLease);

    //m_verbDefault = MMC_VERB_PROPERTIES;

    //
        // Reset our flags for this lease
        //
        m_dwTypeFlags = 0;

        //
        // Intialize our client type variable
        //
        m_bClientType = CLIENT_TYPE_DHCP;

        InitInfo((LPDHCP_CLIENT_INFO) pDhcpClientInfo);
}

CDhcpActiveLease::CDhcpActiveLease
(
        ITFSComponentData * pTFSCompData, 
        CDhcpClient & dhcpClient
) : CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpActiveLease);

    //
        // Reset our flags for this lease
        //
        m_dwTypeFlags = 0;

        //
        // Intialize our client type variable
        //
        m_bClientType = CLIENT_TYPE_NONE;

        m_dhcpClientIpAddress = dhcpClient.QueryIpAddress();
    m_strClientName = dhcpClient.QueryName();
        m_strComment = dhcpClient.QueryComment();

        //
        // Check to see if this lease has an infinite expiration.  If so, it's 
        // an active reservation.  If the expiration is zero, then it's an inactive reservation.
        //
    DATE_TIME dt = dhcpClient.QueryExpiryDateTime();
    m_leaseExpires.dwLowDateTime = dt.dwLowDateTime;
    m_leaseExpires.dwHighDateTime = dt.dwHighDateTime;

    if ( (dhcpClient.QueryExpiryDateTime().dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) &&
             (dhcpClient.QueryExpiryDateTime().dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
        {
                CString strBadAddress;
                strBadAddress.LoadString(IDS_DHCP_BAD_ADDRESS);

                // 
                // Bad addresses show up as active reservations, so we need to do the right thing.
                //
                if (strBadAddress.Compare(m_strClientName) == 0)
                {
                        m_dwTypeFlags |= TYPE_FLAG_RESERVATION;
                        m_dwTypeFlags |= TYPE_FLAG_BAD_ADDRESS;
                        
                        m_strLeaseExpires.LoadString(IDS_DHCP_LEASE_NOT_APPLICABLE);
                }
                else
                {
            //
            // Assume infinite lease clients
            //
                        m_strLeaseExpires.LoadString(IDS_INFINTE);
                }
        }
        else
        if ( (dhcpClient.QueryExpiryDateTime().dwLowDateTime == 0) &&
             (dhcpClient.QueryExpiryDateTime().dwHighDateTime == 0) )
        {
                //
                // This is an inactive reservation
                //
                m_dwTypeFlags |= TYPE_FLAG_RESERVATION;

                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_INACTIVE);
        }
        else
        {
                //
                // Generate the time the lease expires in a nicely formatted string
                //
        CTime timeTemp(m_leaseExpires);
        m_timeLeaseExpires = timeTemp;

        FormatDateTime(m_strLeaseExpires, &m_leaseExpires);

                SYSTEMTIME st;
                GetLocalTime(&st);
                CTime systemTime(st);

                if (systemTime > m_timeLeaseExpires)
                        m_dwTypeFlags |= TYPE_FLAG_GHOST;
        }

    if (dhcpClient.QueryHardwareAddress().GetSize() >= 3 &&
        dhcpClient.QueryHardwareAddress()[0] == 'R' &&
        dhcpClient.QueryHardwareAddress()[1] == 'A' &&
        dhcpClient.QueryHardwareAddress()[2] == 'S')
    {
        m_dwTypeFlags |= TYPE_FLAG_RAS;
                m_strUID = RAS_UID;
    }
        else
        {
                // build the client UID string
                UtilCvtByteArrayToString(dhcpClient.QueryHardwareAddress(), m_strUID);
        }
}

CDhcpActiveLease::~CDhcpActiveLease()
{
        DEBUG_DECREMENT_INSTANCE_COUNTER(CDhcpActiveLease);
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLease::InitializeNode
(
        ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
    CString strTemp;
    BOOL bIsRes, bActive, bBad;

    UtilCvtIpAddrToWstr (m_dhcpClientIpAddress,
                         &strTemp);
    SetDisplayName(strTemp);

    bIsRes = IsReservation(&bActive, &bBad);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ACTIVE_LEASE);

    int nImage = ICON_IDX_CLIENT;

    // Figure out if we need a different icon for this lease
    if (m_dwTypeFlags & TYPE_FLAG_RAS) {
        nImage = ICON_IDX_CLIENT_RAS;
    }
    else if (m_dwTypeFlags & TYPE_FLAG_DNS_REG) {
        nImage = ICON_IDX_CLIENT_DNS_REGISTERING;
    }
    else if (bIsRes) {
        nImage = ICON_IDX_RES_CLIENT;
    }

    if (( m_dwTypeFlags & TYPE_FLAG_DNS_UNREG) ||
        ( m_dwTypeFlags & TYPE_FLAG_DOOMED) ||
        ( m_dwTypeFlags & TYPE_FLAG_GHOST)) {
        nImage = ICON_IDX_CLIENT_EXPIRED;
    }
    pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nImage);

    //SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
    //SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::InitInfo
                Helper to initialize data
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpActiveLease::InitInfo(LPDHCP_CLIENT_INFO pDhcpClientInfo)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        m_dhcpClientIpAddress = pDhcpClientInfo->ClientIpAddress;

        //
        // Copy the client name if it has one
        //
        if (pDhcpClientInfo->ClientName)
        {
                m_strClientName = pDhcpClientInfo->ClientName;
        //m_strClientName.MakeLower();
        }

        if (pDhcpClientInfo->ClientComment)
        {
                m_strComment = pDhcpClientInfo->ClientComment;
        }

        //
        // Check to see if this lease has an infinite expiration.  If so, it's 
        // an active reservation.  If the expiration is zero, then it's an inactive reservation.
        //
    DATE_TIME dt = pDhcpClientInfo->ClientLeaseExpires;
    m_leaseExpires.dwLowDateTime = dt.dwLowDateTime;
    m_leaseExpires.dwHighDateTime = dt.dwHighDateTime;

        if ( (pDhcpClientInfo->ClientLeaseExpires.dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) &&
             (pDhcpClientInfo->ClientLeaseExpires.dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
        {
                CString strBadAddress;
                strBadAddress.LoadString(IDS_DHCP_BAD_ADDRESS);

                // 
                // Bad addresses show up as active reservations, so we need to do the right thing.
                //
                if (strBadAddress.Compare(m_strClientName) == 0)
                {
                        m_dwTypeFlags |= TYPE_FLAG_RESERVATION;
                        m_dwTypeFlags |= TYPE_FLAG_BAD_ADDRESS;
                        
                        m_strLeaseExpires.LoadString(IDS_DHCP_LEASE_NOT_APPLICABLE);
                }
                else
                {
            //
            // Assume infinite lease clients
            //
                        m_strLeaseExpires.LoadString(IDS_INFINTE);
                }
        }
        else
        if ( (pDhcpClientInfo->ClientLeaseExpires.dwLowDateTime == 0) &&
             (pDhcpClientInfo->ClientLeaseExpires.dwHighDateTime == 0) )
        {
                //
                // This is an inactive reservation
                //
                m_dwTypeFlags |= TYPE_FLAG_RESERVATION;

                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_INACTIVE);
        }
        else
        {
                //
                // Generate the time the lease expires in a nicely formatted string
                //
        CTime timeTemp(m_leaseExpires);
        m_timeLeaseExpires = timeTemp;

        FormatDateTime(m_strLeaseExpires, &m_leaseExpires);

        CTime timeCurrent = CTime::GetCurrentTime();

                if (timeCurrent > m_timeLeaseExpires)
                        m_dwTypeFlags |= TYPE_FLAG_GHOST;
        }

    if (pDhcpClientInfo->ClientHardwareAddress.DataLength >= 3 &&
        pDhcpClientInfo->ClientHardwareAddress.Data[0] == 'R' &&
        pDhcpClientInfo->ClientHardwareAddress.Data[1] == 'A' &&
        pDhcpClientInfo->ClientHardwareAddress.Data[2] == 'S')
    {
        m_dwTypeFlags |= TYPE_FLAG_RAS;
                m_strUID = RAS_UID;
    }
        else
        {
                // build the client UID string
                CByteArray baUID;
                for (DWORD i = 0; i < pDhcpClientInfo->ClientHardwareAddress.DataLength; i++)
                {
                        baUID.Add(pDhcpClientInfo->ClientHardwareAddress.Data[i]);
                }

                UtilCvtByteArrayToString(baUID, m_strUID);
        }
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::AddMenuItems
                Implementation of ITFSResultHandler::AddMenuItems
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpActiveLease::AddMenuItems
(
    ITFSComponent *         pComponent, 
        MMC_COOKIE                              cookie,
        LPDATAOBJECT                    pDataObject, 
        LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
        long *                                  pInsertionAllowed
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr;

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::Command
                Implementation of ITFSResultHandler::Command
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpActiveLease::Command
(
    ITFSComponent * pComponent, 
        MMC_COOKIE              cookie, 
        int                             nCommandID,
        LPDATAOBJECT    pDataObject
)
{
        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::CreatePropertyPages
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpActiveLease::CreatePropertyPages
(       
        ITFSComponent *                 pComponent, 
        MMC_COOKIE                              cookie, 
        LPPROPERTYSHEETCALLBACK lpProvider, 
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = hrOK;

        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);

        hr = DoPropSheet(spNode, lpProvider, handle);

    return hr;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpActiveLease::GetString
(
        ITFSComponent * pComponent,     
        MMC_COOKIE              cookie,
        int                             nCol
)
{
        switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
            return m_strClientName;

                case 2:
                        return (LPCWSTR)m_strLeaseExpires;

                case 3:
                        return GetClientType();
                
                case 4:
                        return m_strUID;
                
                case 5:
                        return m_strComment;
        }
        
        return NULL;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
LPCTSTR
CDhcpActiveLease::GetClientType()
{
    // set the default return value
    LPCTSTR pszReturn = g_szClientTypeUnknown;

    // this one must come before the check for DHCP or BOOTP
    // because it is a combination of both flags
    if ((m_bClientType & CLIENT_TYPE_BOTH) == CLIENT_TYPE_BOTH)
    {
        pszReturn = g_szClientTypeBoth;
    }
    else
    if (m_bClientType & CLIENT_TYPE_DHCP)
    {
            pszReturn = g_szClientTypeDhcp;
    }
    else
    if (m_bClientType & CLIENT_TYPE_BOOTP)
    {
            pszReturn = g_szClientTypeBootp;
    }
    else
    if (m_bClientType & CLIENT_TYPE_NONE)
    {
                pszReturn = g_szClientTypeNone;
    }
    else
    if (m_bClientType & CLIENT_TYPE_UNSPECIFIED)
    {
                pszReturn = g_szClientTypeUnspecified;
    }
    else
    {
                Assert1(FALSE, "CDhcpActiveLease::GetClientType - Unknown client type %d", m_bClientType);
        }

    return pszReturn;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CDhcpActiveLease::GetLeaseExpirationTime 
(
        CTime & time
)
{
        time = m_timeLeaseExpires;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL                    
CDhcpActiveLease::IsReservation
(
        BOOL * pbIsActive,
        BOOL * pbIsBad
)
{
        BOOL bIsReservation = FALSE;
        *pbIsBad = FALSE;

/*      if ( (m_dhcpClientInfo.ClientLeaseExpires.dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) &&
             (m_dhcpClientInfo.ClientLeaseExpires.dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
        {
                // 
                // This is an active reservation
                //
                bIsReservation = TRUE;
                *pbIsActive = TRUE;
                *pbIsBad = IsBadAddress();
        }
        else
        if ( (m_dhcpClientInfo.ClientLeaseExpires.dwLowDateTime == 0) &&
             (m_dhcpClientInfo.ClientLeaseExpires.dwHighDateTime == 0) )
        {
                // 
                // This is an inactive reservation
                //
                bIsReservation = TRUE;
                *pbIsActive = FALSE;
        }
*/

        *pbIsActive = m_dwTypeFlags & TYPE_FLAG_ACTIVE;
        *pbIsBad = m_dwTypeFlags & TYPE_FLAG_BAD_ADDRESS;

        return bIsReservation = m_dwTypeFlags & TYPE_FLAG_RESERVATION;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpActiveLease::DoPropSheet
(
        ITFSNode *                              pNode,
        LPPROPERTYSHEETCALLBACK lpProvider, 
        LONG_PTR                                handle
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

        HRESULT hr = hrOK;

    return hr;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpActiveLease::SetClientName
(
        LPCTSTR pName
)
{
        if (pName != NULL)      
        {
        m_strClientName = pName;
        }
        else
        {
        m_strClientName.Empty();
        }

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::SetReservation
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
void
CDhcpActiveLease::SetReservation(BOOL fReservation)
{
    if (fReservation)
    {
        if ( (m_leaseExpires.dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) &&
                 (m_leaseExpires.dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
        {
            // 
                // This is an active reservation
            //
                m_dwTypeFlags |= TYPE_FLAG_RESERVATION;
                m_dwTypeFlags |= TYPE_FLAG_ACTIVE;

                m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_ACTIVE);
        }
        else
        if ( (m_leaseExpires.dwLowDateTime == 0) &&
                 (m_leaseExpires.dwHighDateTime == 0) )
        {
                    m_dwTypeFlags |= TYPE_FLAG_RESERVATION;

                    m_strLeaseExpires.LoadString(IDS_DHCP_INFINITE_LEASE_INACTIVE);
        }
        else
        {
            Trace1("CDhcpActiveLease::SetReservation - %lx does not have a valid reservation lease time!", m_dhcpClientIpAddress);
        }
    }
    else
    {
        m_dwTypeFlags &= ~TYPE_FLAG_RESERVATION;
        m_dwTypeFlags &= ~TYPE_FLAG_ACTIVE;
    }
}

/*!--------------------------------------------------------------------------
        CDhcpActiveLease::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpActiveLease::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

        m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}

/*---------------------------------------------------------------------------
        Class CDhcpAllocationRange implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpAllocationRange::CDhcpAllocationRange
(
        ITFSComponentData * pTFSCompData,
        DHCP_IP_RANGE * pdhcpIpRange
) : CDhcpHandler(pTFSCompData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetAddr (pdhcpIpRange->StartAddress, TRUE);
    SetAddr (pdhcpIpRange->EndAddress, FALSE);

        // now do the ending IP address
        //
        UtilCvtIpAddrToWstr (pdhcpIpRange->EndAddress,
                                                 &m_strEndIpAddress);
        
        // and finally the description
        //
        m_strDescription.LoadString(IDS_ALLOCATION_RANGE_DESCRIPTION);
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpAllocationRange::CDhcpAllocationRange
(
        ITFSComponentData * pTFSCompData,
        DHCP_BOOTP_IP_RANGE * pdhcpIpRange
) : CDhcpHandler(pTFSCompData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetAddr (pdhcpIpRange->StartAddress, TRUE);
    SetAddr (pdhcpIpRange->EndAddress, FALSE);

    m_BootpAllocated = pdhcpIpRange->BootpAllocated;
    m_MaxBootpAllowed = pdhcpIpRange->MaxBootpAllowed;

        // now do the ending IP address
        //
        UtilCvtIpAddrToWstr (pdhcpIpRange->EndAddress,
                                                 &m_strEndIpAddress);
        
        // and finally the description
        //
        m_strDescription.LoadString(IDS_ALLOCATION_RANGE_DESCRIPTION);
}

/*!--------------------------------------------------------------------------
        CDhcpAllocationRange::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpAllocationRange::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strTemp;
        UtilCvtIpAddrToWstr (QueryAddr(TRUE), &strTemp);
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_ALLOCATION_RANGE);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_ALLOCATION_RANGE);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_ALLOCATION_RANGE);

        //SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
        //SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpAllocationRange::GetString
(
        ITFSComponent * pComponent,     
        MMC_COOKIE              cookie,
        int                             nCol
)
{
        switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
                        return (LPCWSTR)m_strEndIpAddress;

                case 2:
                        return (LPCWSTR)m_strDescription;
        }
        
        return NULL;
}

/*!--------------------------------------------------------------------------
        CDhcpAllocationRange::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpAllocationRange::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}

/*---------------------------------------------------------------------------
        Class CDhcpExclusionRange implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpExclusionRange::CDhcpExclusionRange
(
        ITFSComponentData * pTFSCompData,
        DHCP_IP_RANGE * pdhcpIpRange
) : CDhcpHandler(pTFSCompData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    SetAddr (pdhcpIpRange->StartAddress, TRUE);
    SetAddr (pdhcpIpRange->EndAddress, FALSE);

        // now do the ending IP address
        //
        UtilCvtIpAddrToWstr (pdhcpIpRange->EndAddress,
                                                 &m_strEndIpAddress);
        
        // and finally the description
        //
        m_strDescription.LoadString(IDS_EXCLUSION_RANGE_DESCRIPTION);

}

/*!--------------------------------------------------------------------------
        CDhcpExclusionRange::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpExclusionRange::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        CString strTemp;
        UtilCvtIpAddrToWstr (QueryAddr(TRUE), &strTemp);
        SetDisplayName(strTemp);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_EXCLUSION_RANGE);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_EXCLUSION_RANGE);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_EXCLUSION_RANGE);

        //SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
        //SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpExclusionRange::OnResultSelect
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpExclusionRange::OnResultSelect
(
        ITFSComponent * pComponent, 
        LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM                      arg, 
        LPARAM                  lParam
)
{
        HRESULT         hr = hrOK;
        SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;
    CTFSNodeList    listSelectedNodes;
        BOOL            bEnable = FALSE;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    
        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        // build the list of selected nodes
        hr = BuildSelectedItemList(pComponent, &listSelectedNodes);

        // walk the list of selected items.   Make sure an allocation range isn't
        // selected.  If it is, don't enable the delete key
    if (listSelectedNodes.GetCount() > 0)
    {
                BOOL     bAllocRangeSelected = FALSE;
                POSITION pos;
                ITFSNode * pNode;
                pos = listSelectedNodes.GetHeadPosition();

                while (pos)
                {
                        pNode = listSelectedNodes.GetNext(pos);
                        if (pNode->GetData(TFS_DATA_TYPE) == DHCPSNAP_ALLOCATION_RANGE)
                        {
                                bAllocRangeSelected = TRUE;
                                break;
                        }
                }

                if (!bAllocRangeSelected)
                        bEnable = TRUE;
        }

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = bEnable);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
        return hr;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpExclusionRange::GetString
(
        ITFSComponent * pComponent,     
        MMC_COOKIE      cookie,
        int                             nCol
)
{
        switch (nCol)
        {
                case 0:
                        return GetDisplayName();

                case 1:
                        return (LPCWSTR)m_strEndIpAddress;

                case 2:
                        return (LPCWSTR)m_strDescription;
        }
        
        return NULL;
}

/*!--------------------------------------------------------------------------
        CDhcpExclusionRange::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpExclusionRange::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}

/*---------------------------------------------------------------------------
        Class CDhcpBootpEntry implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        Constructor
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpBootpEntry::CDhcpBootpEntry
(
        ITFSComponentData * pTFSCompData
) : CDhcpHandler(pTFSCompData)
{
}

/*!--------------------------------------------------------------------------
        CDhcpBootpEntry::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpBootpEntry::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        SetDisplayName(m_strBootImage);

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_BOOTP_ENTRY);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_BOOTP_ENTRY);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_BOOTP_ENTRY);

        //SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
        //SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);

        return hrOK;
}

/*---------------------------------------------------------------------------
        CDhcpBootpEntry::OnPropertyChange
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CDhcpBootpEntry::OnResultPropertyChange
(
        ITFSComponent * pComponent,
        LPDATAOBJECT    pDataObject,
        MMC_COOKIE              cookie,
        LPARAM                  arg,
        LPARAM                  param
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpBootpEntry::GetString
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpBootpEntry::GetString
(
        ITFSComponent * pComponent,
        MMC_COOKIE              cookie,
        int                             nCol
)
{
        switch (nCol)
        {
                case 0:
                        return QueryBootImage();

                case 1:
                        return QueryFileName();

                case 2:
                        return QueryFileServer();
        }

        return NULL;
}

/*!--------------------------------------------------------------------------
        CDhcpBootpEntry::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpBootpEntry::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpBootpEntry::operator ==
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
CDhcpBootpEntry::operator ==
(
        CDhcpBootpEntry & bootpEntry
)
{
        CString strBootImage, strFileName, strFileServer;

        strBootImage = bootpEntry.QueryBootImage();
        strFileName = bootpEntry.QueryFileName();
        strFileServer = bootpEntry.QueryFileServer();

        if ( (m_strBootImage.CompareNoCase(strBootImage) == 0) &&
                 (m_strFileName.CompareNoCase(strFileName) == 0) &&
                 (m_strFileServer.CompareNoCase(strFileServer) == 0) )
        {
                return TRUE;
        }
        else
        {
                return FALSE;
        }
}

/*!--------------------------------------------------------------------------
        CDhcpBootpEntry::InitData
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR * 
CDhcpBootpEntry::InitData
(
        CONST WCHAR grszwBootTable[],   // IN: Group of strings for the boot table
    DWORD       dwLength
)
{
        ASSERT(grszwBootTable != NULL);
        
        CONST WCHAR * pszw;
        pszw = PchParseUnicodeString(IN grszwBootTable, dwLength, OUT m_strBootImage);
        ASSERT(*pszw == BOOT_FILE_STRING_DELIMITER_W);
    dwLength -= ((m_strBootImage.GetLength() + 1) * sizeof(TCHAR));

        pszw = PchParseUnicodeString(IN pszw + 1, dwLength, OUT m_strFileServer);
        ASSERT(*pszw == BOOT_FILE_STRING_DELIMITER_W);
        
        dwLength -= ((m_strFileServer.GetLength() + 1) * sizeof(TCHAR));
    pszw = PchParseUnicodeString(IN pszw + 1, dwLength, OUT m_strFileName);
        ASSERT(*pszw == '\0');
        
    dwLength -= (m_strFileName.GetLength() * sizeof(TCHAR));
    Assert(dwLength >= 0);

        return const_cast<WCHAR *>(pszw + 1);
}

/*!--------------------------------------------------------------------------
        Function
                Compute the length (number of characters) necessary
                to store the BOOTP entry.  Additional characters
                are added for extra security.
        Author: EricDav
 ---------------------------------------------------------------------------*/
int
CDhcpBootpEntry::CchGetDataLength()
{
        return 16 + m_strBootImage.GetLength() + m_strFileName.GetLength() + m_strFileServer.GetLength();
}

/*!--------------------------------------------------------------------------
        Function
                Write the data into a formatted string.
        Author: EricDav
 ---------------------------------------------------------------------------*/
WCHAR * 
CDhcpBootpEntry::PchStoreData
(
        OUT WCHAR szwBuffer[]
)
{
        int cch;
        cch = wsprintfW(OUT szwBuffer, L"%s,%s,%s",
                                        (LPCTSTR)m_strBootImage,
                                        (LPCTSTR)m_strFileServer,
                                        (LPCTSTR)m_strFileName);
        ASSERT(cch > 0);
        ASSERT(cch + 4 < CchGetDataLength());
        
        return const_cast<WCHAR *>(szwBuffer + cch + 1);
}

/*---------------------------------------------------------------------------
        Class CDhcpOptionItem implementation
 ---------------------------------------------------------------------------*/

DEBUG_DECLARE_INSTANCE_COUNTER(CDhcpOptionItem);

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpOptionItem::CDhcpOptionItem
(
        ITFSComponentData * pTFSCompData,
        LPDHCP_OPTION_VALUE pOptionValue, 
        int                                     nOptionImage
) : CDhcpOptionValue(*pOptionValue),
    CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpOptionItem);

    //
        // initialize this node
        //
        m_nOptionImage = nOptionImage;

        m_dhcpOptionId = pOptionValue->OptionID;

    // assume non-vendor option
    SetVendor(NULL);

    m_verbDefault = MMC_VERB_PROPERTIES;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpOptionItem::CDhcpOptionItem
(
        ITFSComponentData * pTFSCompData,
        CDhcpOption *       pOption, 
        int                                     nOptionImage
) : CDhcpOptionValue(pOption->QueryValue()),
    CDhcpHandler(pTFSCompData)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDhcpOptionItem);

    //
        // initialize this node
        //
        m_nOptionImage = nOptionImage;
        m_dhcpOptionId = pOption->QueryId();

    // assume non-vendor option
    if (pOption->IsVendor())
        SetVendor(pOption->GetVendor());
    else
        SetVendor(NULL);

    SetClassName(pOption->GetClassName());

    m_verbDefault = MMC_VERB_PROPERTIES;
}

CDhcpOptionItem::~CDhcpOptionItem()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDhcpOptionItem);
}

/*!--------------------------------------------------------------------------
        CDhcpOptionItem::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpOptionItem::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, m_nOptionImage);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, m_nOptionImage);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_OPTION_ITEM);

        //SetColumnStringIDs(&aColumns[DHCPSNAP_ACTIVE_LEASES][0]);
        //SetColumnWidths(&aColumnWidths[DHCPSNAP_ACTIVE_LEASES][0]);

        return hrOK;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpOptionItem::GetString
(
        ITFSComponent * pComponent,     
        MMC_COOKIE              cookie,
        int                             nCol
)
{
        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);
        
        CDhcpOption * pOptionInfo = FindOptionDefinition(pComponent, spNode);

        switch (nCol)
        {
                case 0:
                {
                        if (pOptionInfo)
                                pOptionInfo->QueryDisplayName(m_strName);
                        else
                                m_strName.LoadString(IDS_UNKNOWN);

                        return m_strName;
                }

                case 1:
                        return m_strVendorDisplay;

                case 2:
                {
                        if (pOptionInfo)
            {
                // special case the CSR option
                BOOL fRouteArray = (
                    !pOptionInfo->IsClassOption() &&
                    (DHCP_OPTION_ID_CSR == pOptionInfo->QueryId()) &&
                    DhcpUnaryElementTypeOption ==
                    pOptionInfo->QueryOptType() &&
                    DhcpBinaryDataOption == pOptionInfo->QueryDataType()
                    );
                if( !fRouteArray ) 
                    QueryDisplayString(m_strValue, FALSE);
                else
                    QueryRouteArrayDisplayString(m_strValue);
            }
                        else
                                m_strName.LoadString(IDS_UNKNOWN);

                        return m_strValue;
                }

        case 3:
            if (IsClassOption())
                return m_strClassName;    
            else
            {
                if (g_szClientTypeNone.IsEmpty())
                    g_szClientTypeNone.LoadString(IDS_NONE);

                return g_szClientTypeNone;
            }
        }
        
        return NULL;
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CDhcpOptionItem::CreatePropertyPages
(
        ITFSComponent *                 pComponent, 
        MMC_COOKIE                              cookie, 
        LPPROPERTYSHEETCALLBACK lpProvider, 
        LPDATAOBJECT                    pDataObject, 
        LONG_PTR                                handle
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
        // Create the property page
    //
        CPropertyPageHolderBase *   pPropSheet;
        SPITFSNode                  spSelectedNode, spNode, spOptCfgNode, spServerNode;
    CString                     strOptCfgTitle, strOptType;
    COptionValueEnum *          pOptionValueEnum = NULL;
    
    m_spNodeMgr->FindNode(cookie, &spNode);

        SPIComponentData spComponentData;
        m_spNodeMgr->GetComponentData(&spComponentData);

    pComponent->GetSelectedNode(&spSelectedNode);
    
    switch (spSelectedNode->GetData(TFS_DATA_TYPE))
        {
            case DHCPSNAP_GLOBAL_OPTIONS:
                {
                        SPITFSNode spGlobalOptions;

            // get some node information
            spNode->GetParent(&spGlobalOptions);
                        spGlobalOptions->GetParent(&spServerNode);

            CDhcpGlobalOptions * pGlobalOptions = GETHANDLER(CDhcpGlobalOptions, spGlobalOptions);
            
            if (pGlobalOptions->HasPropSheetsOpen())
            {
                            pGlobalOptions->GetOpenPropSheet(0, &pPropSheet);
                            pPropSheet->SetActiveWindow();

                ::PostMessage(PropSheet_GetCurrentPageHwnd(pPropSheet->GetSheetWindow()), WM_SELECTOPTION, (WPARAM) this, 0);
              
                return E_FAIL;
            }

            // get some context info
            pOptionValueEnum = pGlobalOptions->GetServerObject(spGlobalOptions)->GetOptionValueEnum();
            spOptCfgNode.Set(spGlobalOptions);

            // setup the page title
            strOptType.LoadString(IDS_CONFIGURE_OPTIONS_GLOBAL);
                    AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);
        }
                        break;

                case DHCPSNAP_SCOPE_OPTIONS:
                {
            // only the option type of this node can be configured here...
            if (spNode->GetData(TFS_DATA_IMAGEINDEX) != ICON_IDX_SCOPE_OPTION_LEAF)
            {
                AfxMessageBox(IDS_CONNOT_CONFIGURE_OPTION_SCOPE);
                return E_FAIL;
            }

                        SPITFSNode spScopeOptions;
                        spNode->GetParent(&spScopeOptions);

            // check to see if the page is already open, if so just activate it and
            // set the current option to this one.
            CDhcpScopeOptions * pScopeOptions = GETHANDLER(CDhcpScopeOptions, spScopeOptions);
            spServerNode = pScopeOptions->GetServerNode(spScopeOptions);
            if (pScopeOptions->HasPropSheetsOpen())
            {
                // found it, activate
                            pScopeOptions->GetOpenPropSheet(0, &pPropSheet);
                            pPropSheet->SetActiveWindow();

                ::PostMessage(PropSheet_GetCurrentPageHwnd(pPropSheet->GetSheetWindow()), WM_SELECTOPTION, (WPARAM) this, 0);

                return E_FAIL;
            }

            // prepare to create a new page
            pOptionValueEnum = pScopeOptions->GetScopeObject(spScopeOptions)->GetOptionValueEnum();
            spOptCfgNode.Set(spScopeOptions);

            strOptType.LoadString(IDS_CONFIGURE_OPTIONS_SCOPE);
                    AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);
        }
                        break;

                case DHCPSNAP_RESERVATION_CLIENT:
                {
            // only the option type of this node can be configured here...
            if (spNode->GetData(TFS_DATA_IMAGEINDEX) != ICON_IDX_CLIENT_OPTION_LEAF)
            {
                AfxMessageBox(IDS_CONNOT_CONFIGURE_OPTION_RES);
                return E_FAIL;
            }

            SPITFSNode spResClient;
                        spNode->GetParent(&spResClient);

                        CDhcpReservationClient * pResClient = GETHANDLER(CDhcpReservationClient, spResClient);
            spServerNode = pResClient->GetServerNode(spResClient, TRUE);

            strOptType.LoadString(IDS_CONFIGURE_OPTIONS_CLIENT);
                    AfxFormatString1(strOptCfgTitle, IDS_CONFIGURE_OPTIONS_TITLE, strOptType);

            // search the open prop pages to see if the option config page is up
            // since the option config page is technically a property sheet for the node.
            for (int i = 0; i < pResClient->HasPropSheetsOpen(); i++)
            {
                pResClient->GetOpenPropSheet(i, &pPropSheet);

                HWND hwnd = pPropSheet->GetSheetWindow();
                CString strTitle;

                ::GetWindowText(hwnd, strTitle.GetBuffer(256), 256);
                strTitle.ReleaseBuffer();

                if (strTitle == strOptCfgTitle)
                {
                    // found it, activate
                    pPropSheet->SetActiveWindow();
    
                    ::PostMessage(PropSheet_GetCurrentPageHwnd(pPropSheet->GetSheetWindow()), WM_SELECTOPTION, (WPARAM) this, 0);
                    
                    return E_FAIL;
                }
            }

            // no page up, get ready to create one
            pOptionValueEnum = pResClient->GetOptionValueEnum();
            spOptCfgNode.Set(spResClient); 
        }
                        break;
    }

    COptionsConfig * pOptionsConfig = 
                new COptionsConfig(spOptCfgNode, spServerNode, spComponentData, m_spTFSCompData, pOptionValueEnum, strOptCfgTitle, this);

    //
        // Object gets deleted when the page is destroyed
        //
        Assert(lpProvider != NULL);

        return pOptionsConfig->CreateModelessSheet(lpProvider, handle);
}

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpOption * 
CDhcpOptionItem::FindOptionDefinition
(
    ITFSComponent *     pComponent,
        ITFSNode *          pNode
)
{
        SPITFSNode  spSelectedNode;
    CDhcpServer * pServer = NULL;
        
    pComponent->GetSelectedNode(&spSelectedNode);
    
    switch (spSelectedNode->GetData(TFS_DATA_TYPE))
        {
            case DHCPSNAP_GLOBAL_OPTIONS:
                {
                        SPITFSNode spServer;
                        
                        spSelectedNode->GetParent(&spServer);
                        pServer = GETHANDLER(CDhcpServer, spServer);
                }
                        break;

                case DHCPSNAP_SCOPE_OPTIONS:
                {
                        CDhcpScopeOptions * pScopeOptions = GETHANDLER(CDhcpScopeOptions, spSelectedNode);
                        CDhcpScope * pScopeObject = pScopeOptions->GetScopeObject(spSelectedNode);
                        pServer = pScopeObject->GetServerObject();
                }
                        break;

                case DHCPSNAP_RESERVATION_CLIENT:
                {
                        CDhcpReservationClient * pResClient = GETHANDLER(CDhcpReservationClient, spSelectedNode);
                        CDhcpScope * pScopeObject = pResClient->GetScopeObject(spSelectedNode, TRUE);
                        pServer = pScopeObject->GetServerObject();
                }
                        break;

                default:
                        //ASSERT(FALSE);
                        break;
        }

        if (pServer)
        {
                return pServer->FindOption(m_dhcpOptionId, GetVendor());
        }
        else
        {
                return NULL;
        }

}

void 
CDhcpOptionItem::SetVendor
(
    LPCTSTR pszVendor
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (pszVendor == NULL)
        m_strVendorDisplay.LoadString (IDS_VENDOR_STANDARD);
    else
        m_strVendorDisplay = pszVendor;

    m_strVendor = pszVendor;
}

/*!--------------------------------------------------------------------------
        CDhcpOptionItem::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpOptionItem::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}



/*---------------------------------------------------------------------------
        Class CDhcpMCastLease implementation
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
        Function
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
CDhcpMCastLease::CDhcpMCastLease
(
        ITFSComponentData * pTFSCompData
) : CDhcpHandler(pTFSCompData)
{
    //m_verbDefault = MMC_VERB_PROPERTIES;
    m_dwTypeFlags = 0;
}

/*!--------------------------------------------------------------------------
        CDhcpMCastLease::InitializeNode
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CDhcpMCastLease::InitializeNode
(
        ITFSNode * pNode
)
{
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        
        int nImageIndex = ICON_IDX_CLIENT;

    // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, DHCPSNAP_MCAST_LEASE);

    if (m_dwTypeFlags & TYPE_FLAG_GHOST)
    {
        nImageIndex = ICON_IDX_CLIENT_EXPIRED;
    }

        pNode->SetData(TFS_DATA_IMAGEINDEX, nImageIndex);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nImageIndex);

    return hrOK;
}

/*!--------------------------------------------------------------------------
        CDhcpMCastLease::InitMCastInfo
                Initializes node specific data
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT         
CDhcpMCastLease::InitMCastInfo
(
    LPDHCP_MCLIENT_INFO pMClientInfo
)
{
    HRESULT hr = hrOK;
    BOOL    fInfinite = FALSE;

    m_dhcpClientIpAddress = pMClientInfo->ClientIpAddress;

    UtilCvtIpAddrToWstr(m_dhcpClientIpAddress, &m_strIp);
        m_strName = pMClientInfo->ClientName;

    if ( (pMClientInfo->ClientLeaseEnds.dwLowDateTime == DHCP_DATE_TIME_INFINIT_LOW) && 
         (pMClientInfo->ClientLeaseEnds.dwHighDateTime == DHCP_DATE_TIME_INFINIT_HIGH) )
    {
        fInfinite = TRUE;
    }

    CTime timeStart( (FILETIME&) pMClientInfo->ClientLeaseStarts );   

    FILETIME ft = {0};
    if (!fInfinite)
    {
        ft.dwLowDateTime = pMClientInfo->ClientLeaseEnds.dwLowDateTime;
        ft.dwHighDateTime = pMClientInfo->ClientLeaseEnds.dwHighDateTime;
    }

    CTime timeStop( ft );

    m_timeStart = timeStart;
    FormatDateTime(m_strLeaseStart, (FILETIME *) &pMClientInfo->ClientLeaseStarts);

    m_timeStop = timeStop; 

    if (!fInfinite)
    {
        FormatDateTime(m_strLeaseStop, (FILETIME *) &pMClientInfo->ClientLeaseEnds);
    }
    else
    {
        m_strLeaseStop.LoadString(IDS_INFO_TIME_INFINITE);
    }

        // build the UID string
    if (pMClientInfo->ClientId.DataLength >= 3 &&
        pMClientInfo->ClientId.Data[0] == 'R' &&
        pMClientInfo->ClientId.Data[1] == 'A' &&
        pMClientInfo->ClientId.Data[2] == 'S')
    {
                m_strUID = RAS_UID;
    }
        else
        {
                // build the client UID string
                CByteArray baUID;
                for (DWORD i = 0; i < pMClientInfo->ClientId.DataLength; i++)
                {
                        baUID.Add(pMClientInfo->ClientId.Data[i]);
                }

                UtilCvtByteArrayToString(baUID, m_strUID);
        }

        // check to see if this lease has expired
    SYSTEMTIME st;
        GetLocalTime(&st);
        CTime systemTime(st);

        if ( (systemTime > timeStop) && 
         (!fInfinite) )
    {
        Trace2("CDhcpMCastLease::InitMCastInfo - expired lease SysTime %s, StopTime %s\n", systemTime.Format(_T("%#c")), m_strLeaseStop);
                m_dwTypeFlags |= TYPE_FLAG_GHOST;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
        CDhcpMCastLease::GetString
                Description
        Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CDhcpMCastLease::GetString
(
        ITFSComponent * pComponent,
        MMC_COOKIE              cookie,
        int                             nCol
)
{
        SPITFSNode spNode;
        m_spNodeMgr->FindNode(cookie, &spNode);

        switch (nCol)
        {
                case 0:
                        return m_strIp;

                case 1:
                        return m_strName;

        case 2:
            return m_strLeaseStart;

        case 3:
            return m_strLeaseStop;

                case 4:
                        return m_strUID;
        }

        return NULL;
}

/*!--------------------------------------------------------------------------
        CDhcpMCastLease::OnResultRefresh
                Forwards refresh to parent to handle
        Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CDhcpMCastLease::OnResultRefresh(ITFSComponent * pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT  hr = hrOK;
        SPITFSNode spNode, spParent;
    SPITFSResultHandler spParentRH;

    m_spNodeMgr->FindNode(cookie, &spNode);

    // forward this command to the parent to handle
    CORg (spNode->GetParent(&spParent));
        CORg (spParent->GetResultHandler(&spParentRH));

        CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_REFRESH, arg, lParam));
    
Error:
    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\rclntpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	RClntPP.cpp
		This file contains all of the implementation for the 
		reserved client property page.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "rclntpp.h"
#include "scope.h"
#include "nodes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define RADIO_CLIENT_TYPE_BOTH  0
#define RADIO_CLIENT_TYPE_DHCP  1
#define RADIO_CLIENT_TYPE_BOOTP 2

/////////////////////////////////////////////////////////////////////////////
//
// CReservedClientProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CReservedClientProperties::CReservedClientProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
	//ASSERT(pFolderNode == GetContainerNode());

	m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CReservedClientProperties::~CReservedClientProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	
	if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
	{
		RemovePageFromList((CPropertyPageBase*) &m_pageDns, FALSE);
	}
}

void
CReservedClientProperties::SetVersion
(
	LARGE_INTEGER &	 liVersion
)
{
	m_liVersion = liVersion;

	if (m_liVersion.QuadPart >= DHCP_NT5_VERSION)
	{
		AddPageToList((CPropertyPageBase*) &m_pageDns);
	}
}

void
CReservedClientProperties::SetClientType
(
    BYTE bClientType
)
{
    m_pageGeneral.m_bClientType = bClientType;

    // this must come first
    if ((bClientType & CLIENT_TYPE_BOTH) == CLIENT_TYPE_BOTH)
    {
        m_pageGeneral.m_nClientType = RADIO_CLIENT_TYPE_BOTH;
    }
    else
    if (bClientType & CLIENT_TYPE_DHCP)
    {
        m_pageGeneral.m_nClientType = RADIO_CLIENT_TYPE_DHCP;
    }
    else
    if (bClientType & CLIENT_TYPE_BOOTP)
    {
        m_pageGeneral.m_nClientType = RADIO_CLIENT_TYPE_BOOTP;
    }
    else
    {
        // CLIENT_TYPE_NONE:
        // CLIENT_TYPE_UNSPECIFIED:
        m_pageGeneral.m_nClientType = -1;
    }
}

void
CReservedClientProperties::SetDnsRegistration
(
	DWORD					dnsRegOption,
	DHCP_OPTION_SCOPE_TYPE	dhcpOptionType
)
{
	m_pageDns.m_dwFlags = dnsRegOption;
	m_pageDns.m_dhcpOptionType = dhcpOptionType;
}

/////////////////////////////////////////////////////////////////////////////
// CReservedClientPropGeneral property page

IMPLEMENT_DYNCREATE(CReservedClientPropGeneral, CPropertyPageBase)

CReservedClientPropGeneral::CReservedClientPropGeneral() : CPropertyPageBase(CReservedClientPropGeneral::IDD)
{
	//{{AFX_DATA_INIT(CReservedClientPropGeneral)
	m_strComment = _T("");
	m_strName = _T("");
	m_strUID = _T("");
	m_nClientType = -1;
	//}}AFX_DATA_INIT
}

CReservedClientPropGeneral::~CReservedClientPropGeneral()
{
}

void CReservedClientPropGeneral::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReservedClientPropGeneral)
	DDX_Control(pDX, IDC_EDIT_COMMENT, m_editComment);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_EDIT_UNIQUE_IDENTIFIER, m_editUID);
	DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
	DDX_Text(pDX, IDC_EDIT_NAME, m_strName);
	DDX_Text(pDX, IDC_EDIT_UNIQUE_IDENTIFIER, m_strUID);
	DDX_Radio(pDX, IDC_RADIO_TYPE_BOTH, m_nClientType);
	//}}AFX_DATA_MAP

	DDX_Control(pDX, IDC_IPADDR_RES_CLIENT_ADDRESS, m_ipaClientIpAddress);
}


BEGIN_MESSAGE_MAP(CReservedClientPropGeneral, CPropertyPageBase)
	//{{AFX_MSG_MAP(CReservedClientPropGeneral)
	ON_EN_CHANGE(IDC_EDIT_COMMENT, OnChangeEditComment)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_EN_CHANGE(IDC_EDIT_UNIQUE_IDENTIFIER, OnChangeEditUniqueIdentifier)
	ON_BN_CLICKED(IDC_RADIO_TYPE_BOOTP, OnRadioTypeBootp)
	ON_BN_CLICKED(IDC_RADIO_TYPE_BOTH, OnRadioTypeBoth)
	ON_BN_CLICKED(IDC_RADIO_TYPE_DHCP, OnRadioTypeDhcp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReservedClientPropGeneral message handlers

BOOL CReservedClientPropGeneral::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();
	
	m_ipaClientIpAddress.SetAddress(m_dwClientAddress);
	m_ipaClientIpAddress.SetReadOnly(TRUE);
	m_ipaClientIpAddress.EnableWindow(FALSE);
		
	if (m_nClientType == -1)
    {
        // no valid client type.  Must be running something before
        // NT4 SP2.  Hide the client type controls.
        //
        GetDlgItem(IDC_STATIC_CLIENT_TYPE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_DHCP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOOTP)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_RADIO_TYPE_BOTH)->ShowWindow(SW_HIDE);
    }
    
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CReservedClientPropGeneral::OnChangeEditComment() 
{
	SetDirty(TRUE);	
}

void CReservedClientPropGeneral::OnChangeEditName() 
{
	SetDirty(TRUE);	
}

void CReservedClientPropGeneral::OnChangeEditUniqueIdentifier() 
{
	SetDirty(TRUE);	
}

BOOL CReservedClientPropGeneral::OnApply() 
{
	UpdateData();	
	
	DWORD				err = 0;
    CString				str;
    DATE_TIME			dt;
    DHCP_IP_ADDRESS		dhipa;
    CByteArray			cabUid;
	int					i;
	BOOL				fValidUID = TRUE;

    CATCH_MEM_EXCEPTION
    {
        do
        {
            dt.dwLowDateTime  = DHCP_DATE_TIME_ZERO_LOW;
            dt.dwHighDateTime = DHCP_DATE_TIME_ZERO_HIGH;

            m_dhcpClient.SetExpiryDateTime( dt );

            m_ipaClientIpAddress.GetAddress( &dhipa );
            if ( dhipa == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_IPADDR ;
                m_ipaClientIpAddress.SetFocusField(-1);
                 break ;
            }
			m_dhcpClient.SetIpAddress(dhipa);
	
			m_editUID.GetWindowText(str);
			if (str.IsEmpty())
			{
                err = IDS_ERR_INVALID_UID ;
                m_editUID.SetSel(0,-1);
                m_editUID.SetFocus();
                break ; 
            }
			
			//
			// Client UIDs should be 48 bits (6 bytes or 12 hex characters)
			//
			if (str.GetLength() != 6 * 2)
				fValidUID = FALSE;
			
			for (i = 0; i < str.GetLength(); i++)
			{
				if (!wcschr(rgchHex, str[i]))
					fValidUID = FALSE;
			}

			if (!::UtilCvtHexString(str, cabUid) && fValidUID)
			{
				err = IDS_ERR_INVALID_UID ;
                m_editUID.SetSel(0,-1);
                m_editUID.SetFocus();
                break ; 
			}

			if (!fValidUID)
			{
				AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
			
				if (IDYES != AfxMessageBox(IDS_UID_MAY_BE_WRONG, MB_ICONQUESTION | MB_YESNO))
				{
    	            m_editUID.SetSel(0,-1);
	                m_editUID.SetFocus();
					err = IDS_UID_MAY_BE_WRONG;
					break;
				}
			}
			m_dhcpClient.SetHardwareAddress( cabUid ) ;

            m_editName.GetWindowText( str ) ;
            if ( str.GetLength() == 0 ) 
            {
                err = IDS_ERR_INVALID_CLIENT_NAME ;
                m_editName.SetFocus();
                break ;
            }

            //
            // Convert client name to oem
            //
            m_dhcpClient.SetName( str ) ;
            m_editComment.GetWindowText( str ) ;
            m_dhcpClient.SetComment( str ) ;
        
            // Set the client type
            BYTE bClientType;
            switch (m_nClientType)
            {
                case RADIO_CLIENT_TYPE_DHCP:
                    bClientType = CLIENT_TYPE_DHCP;
                    break;

                case RADIO_CLIENT_TYPE_BOOTP:
                    bClientType = CLIENT_TYPE_BOOTP;
                    break;

                case RADIO_CLIENT_TYPE_BOTH:
                    bClientType = CLIENT_TYPE_BOTH;
                    break; 

                default:
                    Assert(FALSE); // should never get here
                    bClientType = CLIENT_TYPE_UNSPECIFIED;
                    break;
            }
            m_dhcpClient.SetClientType(bClientType);

        }
        while ( FALSE ) ;
    }
    END_MEM_EXCEPTION( err ) ;

	if (err)
	{
		if (err != IDS_UID_MAY_BE_WRONG)
		{
			AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		
			::DhcpMessageBox(err);
		}

		return FALSE;
	}

	BOOL bRet = CPropertyPageBase::OnApply();

	if (bRet == FALSE)
	{
		// Something bad happened... grab the error code
		AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		::DhcpMessageBox(GetHolder()->GetError());
	}

	return bRet;
}

BOOL CReservedClientPropGeneral::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	SPITFSNode spResClientNode, spActiveLeasesNode;
	CDhcpReservationClient *    pResClient;
	CDhcpScope *                pScope;
    DWORD                       err;

	spResClientNode = GetHolder()->GetNode();
	pResClient = GETHANDLER(CDhcpReservationClient, spResClientNode);

	pScope = pResClient->GetScopeObject(spResClientNode, TRUE);
	
	pScope->GetActiveLeasesNode(&spActiveLeasesNode);	

	// First tell the server to update the client information
	BEGIN_WAIT_CURSOR;
    err = pScope->UpdateReservation(&m_dhcpClient, pResClient->GetOptionValueEnum());
	END_WAIT_CURSOR;

    if (err != ERROR_SUCCESS)
	{
		GetHolder()->SetError(err);
		return FALSE;
	}

	*ChangeMask = SCOPE_PANE_CHANGE_ITEM_DATA;

	// now update our reserved client information
	pResClient->SetName(m_dhcpClient.QueryName());
	pResClient->SetComment(m_dhcpClient.QueryComment());
	pResClient->SetUID(m_dhcpClient.QueryHardwareAddress());
    pResClient->SetClientType(m_dhcpClient.QueryClientType());

	// Now we need to update the active lease record if it exists
	SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
	CDhcpActiveLease *pActiveLease = NULL;

	spActiveLeasesNode->GetEnum(&spNodeEnum);
	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		pActiveLease = GETHANDLER(CDhcpActiveLease, spCurrentNode);

		if (m_dhcpClient.QueryIpAddress() == pActiveLease->GetIpAddress())
		{
			// Update the name and client type
            pActiveLease->SetClientName(m_dhcpClient.QueryName());

			spCurrentNode.Release();
			break;
		}

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return FALSE;
}

void CReservedClientPropGeneral::OnRadioTypeBootp() 
{
    if (!IsDirty() &&
        m_bClientType != CLIENT_TYPE_BOOTP)
    {
        SetDirty(TRUE);
    }
}

void CReservedClientPropGeneral::OnRadioTypeBoth() 
{
    if (!IsDirty() &&
        m_bClientType != CLIENT_TYPE_BOTH)
    {
        SetDirty(TRUE);
    }
}

void CReservedClientPropGeneral::OnRadioTypeDhcp() 
{
    if (!IsDirty() &&
        m_bClientType != CLIENT_TYPE_DHCP)
    {
        SetDirty(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\dhcp\optcfg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation                **/
/**********************************************************************/

/*
   optcfg.cpp
      Individual option property page
   
   FILE HISTORY:

*/

#include "stdafx.h"
#include "optcfg.h"
#include "listview.h"
#include "server.h"
#include "nodes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_COLUMNS 2

UINT COLUM